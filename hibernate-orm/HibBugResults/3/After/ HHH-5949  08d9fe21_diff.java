diff --git a/build.gradle b/build.gradle
index efada05429..5d250557a0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,236 +1,234 @@
 apply plugin: 'eclipse'
 apply plugin: 'idea'
 
 allprojects {
     repositories {
         mavenCentral()
         mavenLocal()
         mavenRepo name: 'jboss-nexus', urls: "https://repository.jboss.org/nexus/content/groups/public/"
         mavenRepo name: "jboss-snapshots", urls: "http://snapshots.jboss.org/maven2/"
     }
 }
 
 ideaProject {
     javaVersion = "1.6"
     withXml { provider ->
         def node = provider.asNode()
         def vcsConfig = node.component.find { it.'@name' == 'VcsDirectoryMappings' }
         vcsConfig.mapping[0].'@vcs' = 'Git'
     }
 }
 
 ideaModule {
 }
 
 // build a map of the dependency artifacts to use.  Allows centralized definition of the version of artifacts to
 // use.  In that respect it serves a role similar to <dependencyManagement> in Maven
 slf4jVersion = '1.5.8'
 libraries = [
         // Ant
         ant:            'ant:ant:1.6.5',
 
         // Antlr
         antlr:          'antlr:antlr:2.7.7',
 
         // Annotations
         commons_annotations:
                         'org.hibernate:hibernate-commons-annotations:3.2.0.Final',
 
         // CGLIB
         cglib:          'cglib:cglib:2.2',
 
         // Jakarta commons-collections  todo : get rid of commons-collections dependency
         commons_collections:
                         'commons-collections:commons-collections:3.1',
 
         // Dom4J
         dom4j:          'dom4j:dom4j:1.6.1@jar',
 
         // h2
         h2:             'com.h2database:h2:1.2.145',
 
         // Javassist
         javassist:      'javassist:javassist:3.12.0.GA',
 
         // javax
         jpa:            'org.hibernate.javax.persistence:hibernate-jpa-2.0-api:1.0.0.Final',
         jta:            'javax.transaction:jta:1.1',
         validation:     'javax.validation:validation-api:1.0.0.GA',
         validator:      'org.hibernate:hibernate-validator:4.0.2.GA',
         jacc:           'org.jboss.javaee:jboss-jacc-api:1.1.0.GA',
 
         // logging
         slf4j_api:      'org.slf4j:slf4j-api:' + slf4jVersion,
         slf4j_simple:   'org.slf4j:slf4j-simple:' + slf4jVersion,
         jcl_slf4j:      'org.slf4j:jcl-over-slf4j:' + slf4jVersion,
         jcl_api:        'commons-logging:commons-logging-api:99.0-does-not-exist',
         jcl:            'commons-logging:commons-logging:99.0-does-not-exist',
 
         // testing
+        atomikos:       'com.atomikos:transactions-jdbc:3.6.4',
         junit:          'junit:junit:3.8.2',
         testng:         'org.testng:testng:5.8:jdk15',
         jpa_modelgen:   'org.hibernate:hibernate-jpamodelgen:1.1.0.Final',
         shrinkwrap_api: 'org.jboss.shrinkwrap:shrinkwrap-api:1.0.0-alpha-6',
         shrinkwrap:     'org.jboss.shrinkwrap:shrinkwrap-impl-base:1.0.0-alpha-6'
 ]
 
 
 subprojects { subProject ->
     apply plugin: 'idea'
 	apply plugin: 'eclipse'
 
     defaultTasks 'build'
 
     group = 'org.hibernate'
     version = '4.0.0-SNAPSHOT'
 
     // minimize changes, at least for now (gradle uses 'build' by default)..
     buildDir = "target"
     
     if ( ! subProject.name.startsWith( 'release' ) ) {
         apply plugin: 'java'
         apply plugin: 'maven' // for install task as well as deploy dependencies
         apply plugin: org.hibernate.build.gradle.upload.UploadAuthenticationManager
 
         configurations {
             provided {
                 // todo : need to make sure these are non-exported
                 description = 'Non-exported compile-time dependencies.'
             }
             deployerJars {
                 description = 'Jars needed for doing deployment to JBoss Nexus repo'
             }
         }
 
         // appropriately inject the common dependencies into each sub-project
         dependencies {
             compile( libraries.slf4j_api )
             testCompile( libraries.junit )
+            testCompile( libraries.atomikos )
             testRuntime( libraries.slf4j_simple )
             testRuntime( libraries.jcl_slf4j )
             testRuntime( libraries.jcl_api )
             testRuntime( libraries.jcl )
             testRuntime( libraries.javassist )
             testRuntime( libraries.h2 )
             deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
         }
 
         sourceSets {
             main {
                 compileClasspath += configurations.provided
             }
         }
 
         manifest.mainAttributes(
                 provider: 'gradle',
                 'Implementation-Url': 'http://hibernate.org',
                 'Implementation-Version': version,
                 'Implementation-Vendor': 'Hibernate.org',
                 'Implementation-Vendor-Id': 'org.hibernate'
         )
 
         test {
             systemProperties['hibernate.test.validatefailureexpected'] = true
             maxHeapSize = "1024m"
         }
 
         processTestResources.doLast( {
             copy {
                 from( sourceSets.test.java.srcDirs ) {
                     include '**/*.properties'
                     include '**/*.xml'
                 }
                 into sourceSets.test.classesDir
             }
         } )
 
         assemble.doLast( { install } )
         uploadArchives.dependsOn install
 
         targetCompatibility = "1.6"
         sourceCompatibility = "1.6"
 
         ideaModule {
-            // treat our "provided" configuration dependencies as "Compile" scope dependencies in IntelliJ
+            // treat our "provided" configuration dependencies as "compile" scope dependencies in IntelliJ
             scopes.COMPILE.plus.add( configurations.provided )
-            // Use explicitly separate compilation output directories for Gradle and IntelliJ
-            File baseDirectory = new File( subProject.buildDir, "idea/classes" )
-            outputDir = new File( baseDirectory, "main" )
-            testOutputDir = new File( baseDirectory, "test" )
             whenConfigured { module ->
                 module.dependencies*.exported = true
             }
         }
 		eclipseClasspath {
 			plusConfigurations.add( configurations.provided )
 		}
 
         // elements used to customize the generated POM used during upload
         def pomConfig = {
             url 'http://hibernate.org'
             organization {
                 name 'Hibernate.org'
                 url 'http://hibernate.org'
             }
             issueManagement {
                 system 'jira'
                 url 'http://opensource.atlassian.com/projects/hibernate/browse/HHH'
             }
             scm {
                 url "http://github.com/hibernate/hibernate-core"
                 connection "scm:git:http://github.com/hibernate/hibernate-core.git"
                 developerConnection "scm:git:git@github.com:hibernate/hibernate-core.git"
             }
             licenses {
                 license {
                     name 'GNU Lesser General Public License'
                     url 'http://www.gnu.org/licenses/lgpl-2.1.html'
                     comments 'See discussion at http://hibernate.org/356.html for more details.'
                     distribution 'repo'
                 }
             }
             developers {
             }
         }
 
         subProject.basePomConfig = pomConfig
 
         configure(install.repositories.mavenInstaller) {
             pom.project pomConfig
         }
 
         uploadArchives {
             repositories.mavenDeployer {
                 name = 'jbossDeployer'
                 configuration = configurations.deployerJars
                 pom.project pomConfig
                 repository(id: "jboss-releases-repository", url: "https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/")
                 snapshotRepository(id: "jboss-snapshots-repository", url: "https://repository.jboss.org/nexus/content/repositories/snapshots")
             }
         }
 
         task sourcesJar(type: Jar, dependsOn: compileJava) {
             from sourceSets.main.allSource
             classifier = 'sources'
         }
 
         artifacts {
             archives sourcesJar
         }
 
         uploadArchives.dependsOn sourcesJar
     }
 
 }
 
 dependsOnChildren()
 
 // This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
 // on their system.
 // This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
 //  1) /gradlew which is the *NIX shell script for executing builds
 //  2) /gradlew.bat which is the windows bat script for for executing builds
 //  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
 task wrapper(type: Wrapper) {
     gradleVersion = '0.9.2'
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/HibernateException.java b/hibernate-core/src/main/java/org/hibernate/HibernateException.java
index 4699d28dc7..5e75777632 100644
--- a/hibernate-core/src/main/java/org/hibernate/HibernateException.java
+++ b/hibernate-core/src/main/java/org/hibernate/HibernateException.java
@@ -1,56 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate;
 
 /**
  * The base {@link Throwable} type for Hibernate.
  * <p/>
  * Note that all {@link java.sql.SQLException SQLExceptions} will be wrapped in some form of 
  * {@link JDBCException}.
  * 
  * @see JDBCException
  * 
  * @author Gavin King
  */
 public class HibernateException extends RuntimeException {
+	public HibernateException(String s) {
+		super(s);
+	}
 
 	public HibernateException(Throwable root) {
 		super(root);
 	}
 
 	public HibernateException(String string, Throwable root) {
 		super(string, root);
 	}
-
-	public HibernateException(String s) {
-		super(s);
-	}
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JRun4TransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/ResourceClosedException.java
similarity index 66%
rename from hibernate-core/src/main/java/org/hibernate/transaction/JRun4TransactionManagerLookup.java
rename to hibernate-core/src/main/java/org/hibernate/ResourceClosedException.java
index 5f0bf15fd0..800d478cf0 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JRun4TransactionManagerLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/ResourceClosedException.java
@@ -1,41 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.transaction;
+package org.hibernate;
 
 /**
- * {@link TransactionManagerLookup} strategy for JRun4 AS
+ * Indicates an attempt was made to use a closed resource (Session, SessionFactory, etc).
  *
- * @author Joseph Bissen
+ * @author Steve Ebersole
  */
-public class JRun4TransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	protected String getName() {
-		return "java:/TransactionManager";
+public class ResourceClosedException extends HibernateException {
+	public ResourceClosedException(String s) {
+		super( s );
 	}
 
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
+	public ResourceClosedException(String string, Throwable root) {
+		super( string, root );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
index af193fc35e..c097bfb29f 100644
--- a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
@@ -1,396 +1,395 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Set;
 
 import javax.naming.Referenceable;
 
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.stat.Statistics;
 import org.hibernate.engine.FilterDefinition;
 
 /**
  * The main contract here is the creation of {@link Session} instances.  Usually
  * an application has a single {@link SessionFactory} instance and threads
  * servicing client requests obtain {@link Session} instances from this factory.
  * <p/>
  * The internal state of a {@link SessionFactory} is immutable.  Once it is created
  * this internal state is set.  This internal state includes all of the metadata
  * about Object/Relational Mapping.
  * <p/>
  * Implementors <strong>must</strong> be threadsafe.
  *
  * @see org.hibernate.cfg.Configuration
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface SessionFactory extends Referenceable, Serializable {
 	/**
 	 * Open a {@link Session}.
 	 * <p/>
 	 * JDBC {@link Connection connection(s} will be obtained from the
 	 * configured {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} as needed
 	 * to perform requested work.
 	 *
 	 * @return The created session.
 	 *
 	 * @throws HibernateException Indicates a peroblem opening the session; pretty rare here.
 	 */
 	public org.hibernate.classic.Session openSession() throws HibernateException;
 
 	/**
 	 * Open a {@link Session}, utilizing the specified {@link Interceptor}.
 	 * <p/>
 	 * JDBC {@link Connection connection(s} will be obtained from the
 	 * configured {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} as needed
 	 * to perform requested work.
 	 *
 	 * @param interceptor a session-scoped interceptor
 	 *
 	 * @return The created session.
 	 *
 	 * @throws HibernateException Indicates a peroblem opening the session; pretty rare here.
 	 */
 	public org.hibernate.classic.Session openSession(Interceptor interceptor) throws HibernateException;
 
 	/**
 	 * Open a {@link Session}, utilizing the specfied JDBC {@link Connection}.
 	 * <p>
 	 * Note that the second-level cache will be disabled if you supply a JDBC
 	 * connection. Hibernate will not be able to track any statements you might
 	 * have executed in the same transaction.  Consider implementing your own
 	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} instead as a highly
 	 * recommended alternative.
 	 *
 	 * @param connection a connection provided by the application.
 	 *
 	 * @return The created session.
 	 */
 	public org.hibernate.classic.Session openSession(Connection connection);
 
 	/**
 	 * Open a {@link Session}, utilizing the specfied JDBC {@link Connection} and
 	 * specified {@link Interceptor}.
 	 * <p>
 	 * Note that the second-level cache will be disabled if you supply a JDBC
 	 * connection. Hibernate will not be able to track any statements you might
 	 * have executed in the same transaction.  Consider implementing your own
 	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} instead as a highly
 	 * recommended alternative.
 	 *
 	 * @param connection a connection provided by the application.
 	 * @param interceptor a session-scoped interceptor
 	 *
 	 * @return The created session.
 	 */
 	public org.hibernate.classic.Session openSession(Connection connection, Interceptor interceptor);
 
 	/**
 	 * Obtains the current session.  The definition of what exactly "current"
 	 * means controlled by the {@link org.hibernate.context.CurrentSessionContext} impl configured
 	 * for use.
 	 * <p/>
 	 * Note that for backwards compatibility, if a {@link org.hibernate.context.CurrentSessionContext}
-	 * is not configured but a JTA {@link org.hibernate.transaction.TransactionManagerLookup}
-	 * is configured this will default to the {@link org.hibernate.context.JTASessionContext}
+	 * is not configured but JTA is configured this will default to the {@link org.hibernate.context.JTASessionContext}
 	 * impl.
 	 *
 	 * @return The current session.
 	 *
 	 * @throws HibernateException Indicates an issue locating a suitable current session.
 	 */
 	public org.hibernate.classic.Session getCurrentSession() throws HibernateException;
 
 	/**
 	 * Open a new stateless session.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession();
 
 	/**
 	 * Open a new stateless session, utilizing the specified JDBC
 	 * {@link Connection}.
 	 *
 	 * @param connection Connection provided by the application.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession(Connection connection);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityClass The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public ClassMetadata getClassMetadata(Class entityClass);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityName The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 * @since 3.0
 	 */
 	public ClassMetadata getClassMetadata(String entityName);
 
 	/**
 	 * Get the {@link CollectionMetadata} associated with the named collection role.
 	 *
 	 * @param roleName The collection role (in form [owning-entity-name].[collection-property-name]).
 	 *
 	 * @return The metadata associated with the given collection; may be null if no such
 	 * collection was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public CollectionMetadata getCollectionMetadata(String roleName);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} for all mapped entities.
 	 *
 	 * @return A map containing all {@link ClassMetadata} keyed by the
 	 * corresponding {@link String} entity-name.
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 *
 	 * @since 3.0 changed key from {@link Class} to {@link String}.
 	 */
 	public Map<String,ClassMetadata> getAllClassMetadata();
 
 	/**
 	 * Get the {@link CollectionMetadata} for all mapped collections
 	 *
 	 * @return a map from <tt>String</tt> to <tt>CollectionMetadata</tt>
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 */
 	public Map getAllCollectionMetadata();
 
 	/**
 	 * Retrieve the statistics fopr this factory.
 	 *
 	 * @return The statistics.
 	 */
 	public Statistics getStatistics();
 
 	/**
 	 * Destroy this <tt>SessionFactory</tt> and release all resources (caches,
 	 * connection pools, etc).
 	 * <p/>
 	 * It is the responsibility of the application to ensure that there are no
 	 * open {@link Session sessions} before calling this method as the impact
 	 * on those {@link Session sessions} is indeterminate.
 	 * <p/>
 	 * No-ops if already {@link #isClosed closed}.
 	 *
 	 * @throws HibernateException Indicates an issue closing the factory.
 	 */
 	public void close() throws HibernateException;
 
 	/**
 	 * Is this factory already closed?
 	 *
 	 * @return True if this factory is already closed; false otherwise.
 	 */
 	public boolean isClosed();
 
 	/**
 	 * Obtain direct access to the underlying cache regions.
 	 *
 	 * @return The direct cache access API.
 	 */
 	public Cache getCache();
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evict(Class persistentClass) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#containsEntity(Class, Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evict(Class persistentClass, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictEntity(String entityName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictEntity(String entityName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role whose regions should be evicted
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictCollection(String roleName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role
 	 * @param id The id of the collection owner
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictCollection(String roleName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the named query cache region.
 	 *
 	 * @param cacheRegion The named query cache region from which to evict.
 	 *
 	 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,
 	 * this should indicate a problem communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictQueries(String cacheRegion) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the default query cache region.
 	 *
 	 * @throws HibernateException Indicate a problem communicating with
 	 * underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegions} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictQueries() throws HibernateException;
 
 	/**
 	 * Obtain a set of the names of all filters defined on this SessionFactory.
 	 *
 	 * @return The set of filter names.
 	 */
 	public Set getDefinedFilterNames();
 
 	/**
 	 * Obtain the definition of a filter by name.
 	 *
 	 * @param filterName The name of the filter for which to obtain the definition.
 	 * @return The filter definition.
 	 * @throws HibernateException If no filter defined with the given name.
 	 */
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException;
 
 	/**
 	 * Determine if this session factory contains a fetch profile definition
 	 * registered under the given name.
 	 *
 	 * @param name The name to check
 	 * @return True if there is such a fetch profile; false otherwise.
 	 */
 	public boolean containsFetchProfileDefinition(String name);
 
 	/**
 	 * Retrieve this factory's {@link TypeHelper}
 	 *
 	 * @return The factory's {@link TypeHelper}
 	 */
 	public TypeHelper getTypeHelper();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/Transaction.java b/hibernate-core/src/main/java/org/hibernate/Transaction.java
index 38635007c1..cbed4ea957 100644
--- a/hibernate-core/src/main/java/org/hibernate/Transaction.java
+++ b/hibernate-core/src/main/java/org/hibernate/Transaction.java
@@ -1,128 +1,159 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate;
 
+import org.hibernate.engine.transaction.spi.LocalStatus;
+
 import javax.transaction.Synchronization;
 
 /**
- * Allows the application to define units of work, while
- * maintaining abstraction from the underlying transaction
- * implementation (eg. JTA, JDBC).<br>
- * <br>
- * A transaction is associated with a <tt>Session</tt> and is
- * usually instantiated by a call to <tt>Session.beginTransaction()</tt>.
- * A single session might span multiple transactions since
- * the notion of a session (a conversation between the application
- * and the datastore) is of coarser granularity than the notion of
- * a transaction. However, it is intended that there be at most one
- * uncommitted <tt>Transaction</tt> associated with a particular
- * <tt>Session</tt> at any time.<br>
- * <br>
- * Implementors are not intended to be threadsafe.
+ * Defines the contract for abstracting applications from the configured underlying means of transaction management.
+ * Allows the application to define units of work, while maintaining abstraction from the underlying transaction
+ * implementation (eg. JTA, JDBC).
+ * <p/>
+ * A transaction is associated with a {@link Session} and is usually initiated by a call to
+ * {@link org.hibernate.Session#beginTransaction()}.  A single session might span multiple transactions since
+ * the notion of a session (a conversation between the application and the datastore) is of coarser granularity than
+ * the notion of a transaction.  However, it is intended that there be at most one uncommitted transaction associated
+ * with a particular {@link Session} at any time.
+ * <p/>
+ * Implementers are not intended to be thread-safe.
  *
- * @see Session#beginTransaction()
- * @see org.hibernate.transaction.TransactionFactory
  * @author Anton van Straaten
+ * @author Steve Ebersole
  */
 public interface Transaction {
-	
 	/**
-	 * Begin a new transaction.
+	 * Is this transaction the initiator of any underlying transaction?
+	 *
+	 * @return {@literal true} if this transaction initiated the underlying transaction; {@literal false} otherwise.
 	 */
-	public void begin() throws HibernateException;
+	public boolean isInitiator();
 
 	/**
-	 * Flush the associated <tt>Session</tt> and end the unit of work (unless
-	 * we are in {@link FlushMode#MANUAL}.
-	 * </p>
-	 * This method will commit the underlying transaction if and only
-	 * if the underlying transaction was initiated by this object.
+	 * Begin this transaction.  No-op if the transaction has already been begun.  Note that this is not necessarily
+	 * symmetrical since usually multiple calls to {@link #commit} or {@link #rollback} will error.
 	 *
-	 * @throws HibernateException
+	 * @throws HibernateException Indicates a problem beginning the transaction.
 	 */
-	public void commit() throws HibernateException;
+	public void begin();
 
 	/**
-	 * Force the underlying transaction to roll back.
+	 * Commit this transaction.  This might entail a number of things depending on the context:<ul>
+	 *     <li>
+	 *         If this transaction is the {@link #isInitiator initiator}, {@link Session#flush} the {@link Session}
+	 *         with which it is associated (unless {@link Session} is in {@link FlushMode#MANUAL}).
+	 *     </li>
+	 *     <li>
+	 *         If this transaction is the {@link #isInitiator initiator}, commit the underlying transaction.
+	 *     </li>
+	 *     <li>
+	 *         Coordinate various callbacks
+	 *     </li>
+	 * </ul>
 	 *
-	 * @throws HibernateException
+	 * @throws HibernateException Indicates a problem committing the transaction.
 	 */
-	public void rollback() throws HibernateException;
+	public void commit();
 
 	/**
-	 * Was this transaction rolled back or set to rollback only?
-	 * <p/>
-	 * This only accounts for actions initiated from this local transaction.
-	 * If, for example, the underlying transaction is forced to rollback via
-	 * some other means, this method still reports false because the rollback
-	 * was not initiated from here.
+	 * Rollback this transaction.  Either rolls back the underlying transaction or ensures it cannot later commit
+	 * (depending on the actual underlying strategy).
 	 *
-	 * @return boolean True if the transaction was rolled back via this
-	 * local transaction; false otherwise.
-	 * @throws HibernateException
+	 * @throws HibernateException Indicates a problem rolling back the transaction.
 	 */
-	public boolean wasRolledBack() throws HibernateException;
+	public void rollback();
 
 	/**
-	 * Check if this transaction was successfully committed.
+	 * Get the current local status of this transaction.
 	 * <p/>
-	 * This method could return <tt>false</tt> even after successful invocation
-	 * of {@link #commit}.  As an example, JTA based strategies no-op on
-	 * {@link #commit} calls if they did not start the transaction; in that case,
-	 * they also report {@link #wasCommitted} as false.
+	 * This only accounts for the local view of the transaction status.  In other words it does not check the status
+	 * of the actual underlying transaction.
 	 *
-	 * @return boolean True if the transaction was (unequivocally) committed
-	 * via this local transaction; false otherwise.
-	 * @throws HibernateException
+	 * @return The current local status.
 	 */
-	public boolean wasCommitted() throws HibernateException;
-	
+	public LocalStatus getLocalStatus();
+
 	/**
 	 * Is this transaction still active?
 	 * <p/>
-	 * Again, this only returns information in relation to the
-	 * local transaction, not the actual underlying transaction.
+	 * Answers on a best effort basis.  For example, in the case of JDBC based transactions we cannot know that a
+	 * transaction is active when it is initiated directly through the JDBC {@link java.sql.Connection}, only when
+	 * it is initiated from here.
+	 *
+	 * @return {@literal true} if the transaction is still active; {@literal false} otherwise.
+	 *
+	 * @throws HibernateException Indicates a problem checking the transaction status.
+	 */
+	public boolean isActive();
+
+	/**
+	 * Was this transaction committed?
+	 * <p/>
+	 * Answers on a best effort basis.  For example, in the case of JDBC based transactions we cannot know that a
+	 * transaction was committed when the commit was performed directly through the JDBC {@link java.sql.Connection},
+	 * only when the commit was done from this.
+	 *
+	 * @return {@literal true} if the transaction is rolled back; {@literal false} otherwise.
 	 *
-	 * @return boolean Treu if this local transaction is still active.
+	 * @throws HibernateException Indicates a problem checking the transaction status.
 	 */
-	public boolean isActive() throws HibernateException;
+	public boolean wasCommitted();
+
+	/**
+	 * Was this transaction rolled back or set to rollback only?
+	 * <p/>
+	 * Answers on a best effort basis.  For example, in the case of JDBC based transactions we cannot know that a
+	 * transaction was rolled back when rollback was performed directly through the JDBC {@link java.sql.Connection},
+	 * only when it was rolled back  from here.
+	 *
+	 * @return {@literal true} if the transaction is rolled back; {@literal false} otherwise.
+	 *
+	 * @throws HibernateException Indicates a problem checking the transaction status.
+	 */
+	public boolean wasRolledBack();
 
 	/**
 	 * Register a user synchronization callback for this transaction.
 	 *
 	 * @param synchronization The Synchronization callback to register.
-	 * @throws HibernateException
+	 *
+	 * @throws HibernateException Indicates a problem registering the synchronization.
 	 */
-	public void registerSynchronization(Synchronization synchronization) 
-	throws HibernateException;
+	public void registerSynchronization(Synchronization synchronization) throws HibernateException;
 
 	/**
-	 * Set the transaction timeout for any transaction started by
-	 * a subsequent call to <tt>begin()</tt> on this instance.
+	 * Set the transaction timeout for any transaction started by a subsequent call to {@link #begin} on this instance.
 	 *
 	 * @param seconds The number of seconds before a timeout.
 	 */
 	public void setTimeout(int seconds);
+
+	/**
+	 * Retrieve the transaction timeout set for this transaction.  A negative indicates no timeout has been set.
+	 *
+	 * @return The timeout, in seconds.
+	 */
+	public int getTimeout();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index 2e71eab331..ba64ce4900 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -845,2995 +845,2995 @@ public class Configuration implements Serializable {
 			try {
 				jarFile = new JarFile( jar );
 			}
 			catch (IOException ioe) {
 				throw new InvalidMappingException(
 						"Could not read mapping documents from jar: " + jar.getName(), "jar", jar.getName(),
 						ioe
 				);
 			}
 			Enumeration jarEntries = jarFile.entries();
 			while ( jarEntries.hasMoreElements() ) {
 				ZipEntry ze = (ZipEntry) jarEntries.nextElement();
 				if ( ze.getName().endsWith( ".hbm.xml" ) ) {
 					log.info( "Found mapping document in jar: " + ze.getName() );
 					try {
 						addInputStream( jarFile.getInputStream( ze ) );
 					}
 					catch (Exception e) {
 						throw new InvalidMappingException(
 								"Could not read mapping documents from jar: " + jar.getName(),
 								"jar",
 								jar.getName(),
 								e
 						);
 					}
 				}
 			}
 		}
 		finally {
 			try {
 				if ( jarFile != null ) {
 					jarFile.close();
 				}
 			}
 			catch (IOException ioe) {
 				log.error("could not close jar", ioe);
 			}
 		}
 
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		File[] files = dir.listFiles();
 		for ( File file : files ) {
 			if ( file.isDirectory() ) {
 				addDirectory( file );
 			}
 			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 				addFile( file );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Create a new <tt>Mappings</tt> to add class and collection mappings to.
 	 *
 	 * @return The created mappings
 	 */
 	public Mappings createMappings() {
 		return new MappingsImpl();
 	}
 
 
 	@SuppressWarnings({ "unchecked" })
 	private Iterator<IdentifierGenerator> iterateGenerators(Dialect dialect) throws MappingException {
 
 		TreeMap generators = new TreeMap();
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		for ( PersistentClass pc : classes.values() ) {
 			if ( !pc.isInherited() ) {
 				IdentifierGenerator ig = pc.getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						(RootClass) pc
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 				else if ( ig instanceof IdentifierGeneratorAggregator ) {
 					( (IdentifierGeneratorAggregator) ig ).registerPersistentGenerators( generators );
 				}
 			}
 		}
 
 		for ( Collection collection : collections.values() ) {
 			if ( collection.isIdentified() ) {
 				IdentifierGenerator ig = ( ( IdentifierCollection ) collection ).getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						null
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 			}
 		}
 
 		return generators.values().iterator();
 	}
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		// drop them in reverse order in case db needs it done that way...
 		{
 			ListIterator itr = auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 			while ( itr.hasPrevious() ) {
 				AuxiliaryDatabaseObject object = (AuxiliaryDatabaseObject) itr.previous();
 				if ( object.appliesToDialect( dialect ) ) {
 					script.add( object.sqlDropString( dialect, defaultCatalog, defaultSchema ) );
 				}
 			}
 		}
 
 		if ( dialect.dropConstraints() ) {
 			Iterator itr = getTableMappings();
 			while ( itr.hasNext() ) {
 				Table table = (Table) itr.next();
 				if ( table.isPhysicalTable() ) {
 					Iterator subItr = table.getForeignKeyIterator();
 					while ( subItr.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subItr.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlDropString(
 											dialect,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 			}
 		}
 
 
 		Iterator itr = getTableMappings();
 		while ( itr.hasNext() ) {
 
 			Table table = (Table) itr.next();
 			if ( table.isPhysicalTable() ) {
 
 				/*Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					if ( !index.isForeignKey() || !dialect.hasImplicitIndexForForeignKey() ) {
 						script.add( index.sqlDropString(dialect) );
 					}
 				}*/
 
 				script.add(
 						table.sqlDropString(
 								dialect,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 
 			}
 
 		}
 
 		itr = iterateGenerators( dialect );
 		while ( itr.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) itr.next() ).sqlDropStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				script.add(
 						table.sqlCreateString(
 								dialect,
 								mapping,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				if ( !dialect.supportsUniqueConstraintInCreateAlterTable() ) {
 					Iterator subIter = table.getUniqueKeyIterator();
 					while ( subIter.hasNext() ) {
 						UniqueKey uk = (UniqueKey) subIter.next();
 						String constraintString = uk.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema );
 						if (constraintString != null) script.add( constraintString );
 					}
 				}
 
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 
 				if ( dialect.hasAlterTable() ) {
 					subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlCreateString(
 											dialect, mapping,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) iter.next() ).sqlCreateStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		for ( AuxiliaryDatabaseObject auxiliaryDatabaseObject : auxiliaryDatabaseObjects ) {
 			if ( auxiliaryDatabaseObject.appliesToDialect( dialect ) ) {
 				script.add( auxiliaryDatabaseObject.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out what
 	 * should be created/altered
 	 *
 	 * @return The sequence of DDL commands to apply the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaUpdateScript(Dialect dialect, DatabaseMetadata databaseMetadata)
 			throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						( table.getSchema() == null ) ? defaultSchema : table.getSchema(),
 						( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog(),
 								table.isQuoted()
 
 					);
 				if ( tableInfo == null ) {
 					script.add(
 							table.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 				else {
 					Iterator<String> subiter = table.sqlAlterStrings(
 							dialect,
 							mapping,
 							tableInfo,
 							defaultCatalog,
 							defaultSchema
 						);
 					while ( subiter.hasNext() ) {
 						script.add( subiter.next() );
 					}
 				}
 
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						table.getSchema(),
 						table.getCatalog(),
 						table.isQuoted()
 					);
 
 				if ( dialect.hasAlterTable() ) {
 					Iterator subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							boolean create = tableInfo == null || (
 									tableInfo.getForeignKeyMetadata( fk ) == null && (
 											//Icky workaround for MySQL bug:
 											!( dialect instanceof MySQLDialect ) ||
 													tableInfo.getIndexMetadata( fk.getName() ) == null
 										)
 								);
 							if ( create ) {
 								script.add(
 										fk.sqlCreateString(
 												dialect,
 												mapping,
 												defaultCatalog,
 												defaultSchema
 											)
 									);
 							}
 						}
 					}
 				}
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					final Index index = (Index) subIter.next();
 					// Skip if index already exists
 					if ( tableInfo != null && StringHelper.isNotEmpty( index.getName() ) ) {
 						final IndexMetadata meta = tableInfo.getIndexMetadata( index.getName() );
 						if ( meta != null ) {
 							continue;
 						}
 					}
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 							)
 					);
 				}
 
 //broken, 'cos we don't generate these with names in SchemaExport
 //				subIter = table.getUniqueKeyIterator();
 //				while ( subIter.hasNext() ) {
 //					UniqueKey uk = (UniqueKey) subIter.next();
 //					if ( tableInfo==null || tableInfo.getIndexMetadata( uk.getFilterName() ) == null ) {
 //						script.add( uk.sqlCreateString(dialect, mapping) );
 //					}
 //				}
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				String[] lines = generator.sqlCreateStrings( dialect );
 				script.addAll( Arrays.asList( lines ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	public void validateSchema(Dialect dialect, DatabaseMetadata databaseMetadata)throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 		
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						( table.getSchema() == null ) ? defaultSchema : table.getSchema(),
 						( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog(),
 								table.isQuoted());
 				if ( tableInfo == null ) {
 					throw new HibernateException( "Missing table: " + table.getName() );
 				}
 				else {
 					table.validateColumns( dialect, mapping, tableInfo );
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				throw new HibernateException( "Missing sequence or table: " + key );
 			}
 		}
 	}
 
 	private void validate() throws MappingException {
 		Iterator iter = classes.values().iterator();
 		while ( iter.hasNext() ) {
 			( (PersistentClass) iter.next() ).validate( mapping );
 		}
 		iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			( (Collection) iter.next() ).validate( mapping );
 		}
 	}
 
 	/**
 	 * Call this to ensure the mappings are fully compiled/built. Usefull to ensure getting
 	 * access to all information in the metamodel when calling e.g. getClassMappings().
 	 */
 	public void buildMappings() {
 		secondPassCompile();
 	}
 
 	protected void secondPassCompile() throws MappingException {
 		log.trace( "Starting secondPassCompile() processing" );
 
 		//process default values first
 		{
 			if ( !isDefaultProcessed ) {
 				//use global delimiters if orm.xml declare it
 				final Object isDelimited = reflectionManager.getDefaults().get( "delimited-identifier" );
 				if ( isDelimited != null && isDelimited == Boolean.TRUE ) {
 					getProperties().put( Environment.GLOBALLY_QUOTED_IDENTIFIERS, "true" );
 				}
 
 				AnnotationBinder.bindDefaults( createMappings() );
 				isDefaultProcessed = true;
 			}
 		}
 
 		// process metadata queue
 		{
 			metadataSourceQueue.syncAnnotatedClasses();
 			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
 		}
 
 		// process cache queue
 		{
 			for ( CacheHolder holder : caches ) {
 				if ( holder.isClass ) {
 					applyCacheConcurrencyStrategy( holder );
 				}
 				else {
 					applyCollectionCacheConcurrencyStrategy( holder );
 				}
 			}
 			caches.clear();
 		}
 
 		try {
 			inSecondPass = true;
 			processSecondPassesOfType( PkDrivenByDefaultMapsIdSecondPass.class );
 			processSecondPassesOfType( SetSimpleValueTypeSecondPass.class );
 			processSecondPassesOfType( CopyIdentifierComponentSecondPass.class );
 			processFkSecondPassInOrder();
 			processSecondPassesOfType( CreateKeySecondPass.class );
 			processSecondPassesOfType( SecondaryTableSecondPass.class );
 
 			originalSecondPassCompile();
 
 			inSecondPass = false;
 		}
 		catch ( RecoverableException e ) {
 			//the exception was not recoverable after all
 			throw ( RuntimeException ) e.getCause();
 		}
 
 		for ( Map.Entry<Table, List<UniqueConstraintHolder>> tableListEntry : uniqueConstraintHoldersByTable.entrySet() ) {
 			final Table table = tableListEntry.getKey();
 			final List<UniqueConstraintHolder> uniqueConstraints = tableListEntry.getValue();
 			int uniqueIndexPerTable = 0;
 			for ( UniqueConstraintHolder holder : uniqueConstraints ) {
 				uniqueIndexPerTable++;
 				final String keyName = StringHelper.isEmpty( holder.getName() )
 						? "key" + uniqueIndexPerTable
 						: holder.getName();
 				buildUniqueKeyFromColumnNames( table, keyName, holder.getColumns() );
 			}
 		}
 
 		applyConstraintsToDDL();
 	}
 
 	private void processSecondPassesOfType(Class<? extends SecondPass> type) {
 		Iterator iter = secondPasses.iterator();
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of simple value types first and remove them
 			if ( type.isInstance( sp ) ) {
 				sp.doSecondPass( classes );
 				iter.remove();
 			}
 		}
 	}
 
 	/**
 	 * Processes FKSecondPass instances trying to resolve any
 	 * graph circularity (ie PK made of a many to one linking to
 	 * an entity having a PK made of a ManyToOne ...).
 	 */
 	private void processFkSecondPassInOrder() {
 		log.debug( "processing fk mappings (*ToOne and JoinedSubclass)" );
 		List<FkSecondPass> fkSecondPasses = getFKSecondPassesOnly();
 
 		if ( fkSecondPasses.size() == 0 ) {
 			return; // nothing to do here
 		}
 
 		// split FkSecondPass instances into primary key and non primary key FKs.
 		// While doing so build a map of class names to FkSecondPass instances depending on this class.
 		Map<String, Set<FkSecondPass>> isADependencyOf = new HashMap<String, Set<FkSecondPass>>();
 		List<FkSecondPass> endOfQueueFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( FkSecondPass sp : fkSecondPasses ) {
 			if ( sp.isInPrimaryKey() ) {
 				String referenceEntityName = sp.getReferencedEntityName();
 				PersistentClass classMapping = getClassMapping( referenceEntityName );
 				String dependentTable = classMapping.getTable().getQuotedName();
 				if ( !isADependencyOf.containsKey( dependentTable ) ) {
 					isADependencyOf.put( dependentTable, new HashSet<FkSecondPass>() );
 				}
 				isADependencyOf.get( dependentTable ).add( sp );
 			}
 			else {
 				endOfQueueFkSecondPasses.add( sp );
 			}
 		}
 
 		// using the isADependencyOf map we order the FkSecondPass recursively instances into the right order for processing
 		List<FkSecondPass> orderedFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( String tableName : isADependencyOf.keySet() ) {
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, tableName, tableName );
 		}
 
 		// process the ordered FkSecondPasses
 		for ( FkSecondPass sp : orderedFkSecondPasses ) {
 			sp.doSecondPass( classes );
 		}
 
 		processEndOfQueue( endOfQueueFkSecondPasses );
 	}
 
 	/**
 	 * @return Returns a list of all <code>secondPasses</code> instances which are a instance of
 	 *         <code>FkSecondPass</code>.
 	 */
 	private List<FkSecondPass> getFKSecondPassesOnly() {
 		Iterator iter = secondPasses.iterator();
 		List<FkSecondPass> fkSecondPasses = new ArrayList<FkSecondPass>( secondPasses.size() );
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of fk before the others and remove them
 			if ( sp instanceof FkSecondPass ) {
 				fkSecondPasses.add( ( FkSecondPass ) sp );
 				iter.remove();
 			}
 		}
 		return fkSecondPasses;
 	}
 
 	/**
 	 * Recursively builds a list of FkSecondPass instances ready to be processed in this order.
 	 * Checking all dependencies recursively seems quite expensive, but the original code just relied
 	 * on some sort of table name sorting which failed in certain circumstances.
 	 * <p/>
 	 * See <tt>ANN-722</tt> and <tt>ANN-730</tt>
 	 *
 	 * @param orderedFkSecondPasses The list containing the <code>FkSecondPass<code> instances ready
 	 * for processing.
 	 * @param isADependencyOf Our lookup data structure to determine dependencies between tables
 	 * @param startTable Table name to start recursive algorithm.
 	 * @param currentTable The current table name used to check for 'new' dependencies.
 	 */
 	private void buildRecursiveOrderedFkSecondPasses(
 			List<FkSecondPass> orderedFkSecondPasses,
 			Map<String, Set<FkSecondPass>> isADependencyOf,
 			String startTable,
 			String currentTable) {
 
 		Set<FkSecondPass> dependencies = isADependencyOf.get( currentTable );
 
 		// bottom out
 		if ( dependencies == null || dependencies.size() == 0 ) {
 			return;
 		}
 
 		for ( FkSecondPass sp : dependencies ) {
 			String dependentTable = sp.getValue().getTable().getQuotedName();
 			if ( dependentTable.compareTo( startTable ) == 0 ) {
 				StringBuilder sb = new StringBuilder(
 						"Foreign key circularity dependency involving the following tables: "
 				);
 				throw new AnnotationException( sb.toString() );
 			}
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, startTable, dependentTable );
 			if ( !orderedFkSecondPasses.contains( sp ) ) {
 				orderedFkSecondPasses.add( 0, sp );
 			}
 		}
 	}
 
 	private void processEndOfQueue(List<FkSecondPass> endOfQueueFkSecondPasses) {
 		/*
 		 * If a second pass raises a recoverableException, queue it for next round
 		 * stop of no pass has to be processed or if the number of pass to processes
 		 * does not diminish between two rounds.
 		 * If some failing pass remain, raise the original exception
 		 */
 		boolean stopProcess = false;
 		RuntimeException originalException = null;
 		while ( !stopProcess ) {
 			List<FkSecondPass> failingSecondPasses = new ArrayList<FkSecondPass>();
 			Iterator<FkSecondPass> it = endOfQueueFkSecondPasses.listIterator();
 			while ( it.hasNext() ) {
 				final FkSecondPass pass = it.next();
 				try {
 					pass.doSecondPass( classes );
 				}
 				catch ( RecoverableException e ) {
 					failingSecondPasses.add( pass );
 					if ( originalException == null ) {
 						originalException = ( RuntimeException ) e.getCause();
 					}
 				}
 			}
 			stopProcess = failingSecondPasses.size() == 0 || failingSecondPasses.size() == endOfQueueFkSecondPasses.size();
 			endOfQueueFkSecondPasses = failingSecondPasses;
 		}
 		if ( endOfQueueFkSecondPasses.size() > 0 ) {
 			throw originalException;
 		}
 	}
 
 	private void buildUniqueKeyFromColumnNames(Table table, String keyName, String[] columnNames) {
 		keyName = normalizer.normalizeIdentifierQuoting( keyName );
 
 		UniqueKey uc;
 		int size = columnNames.length;
 		Column[] columns = new Column[size];
 		Set<Column> unbound = new HashSet<Column>();
 		Set<Column> unboundNoLogical = new HashSet<Column>();
 		for ( int index = 0; index < size; index++ ) {
 			final String logicalColumnName = normalizer.normalizeIdentifierQuoting( columnNames[index] );
 			try {
 				final String columnName = createMappings().getPhysicalColumnName( logicalColumnName, table );
 				columns[index] = new Column( columnName );
 				unbound.add( columns[index] );
 				//column equals and hashcode is based on column name
 			}
 			catch ( MappingException e ) {
 				unboundNoLogical.add( new Column( logicalColumnName ) );
 			}
 		}
 		for ( Column column : columns ) {
 			if ( table.containsColumn( column ) ) {
 				uc = table.getOrCreateUniqueKey( keyName );
 				uc.addColumn( table.getColumn( column ) );
 				unbound.remove( column );
 			}
 		}
 		if ( unbound.size() > 0 || unboundNoLogical.size() > 0 ) {
 			StringBuilder sb = new StringBuilder( "Unable to create unique key constraint (" );
 			for ( String columnName : columnNames ) {
 				sb.append( columnName ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( ") on table " ).append( table.getName() ).append( ": " );
 			for ( Column column : unbound ) {
 				sb.append( column.getName() ).append( ", " );
 			}
 			for ( Column column : unboundNoLogical ) {
 				sb.append( column.getName() ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( " not found" );
 			throw new AnnotationException( sb.toString() );
 		}
 	}
 
 	private void applyConstraintsToDDL() {
 		boolean applyOnDdl = getProperties().getProperty(
 				"hibernate.validator.apply_to_ddl",
 				"true"
 		)
 				.equalsIgnoreCase( "true" );
 
 		if ( !applyOnDdl ) {
 			return; // nothing to do in this case
 		}
 		applyHibernateValidatorLegacyConstraintsOnDDL();
 		applyBeanValidationConstraintsOnDDL();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void applyHibernateValidatorLegacyConstraintsOnDDL() {
 		//TODO search for the method only once and cache it?
 		Constructor validatorCtr = null;
 		Method applyMethod = null;
 		try {
 			Class classValidator = ReflectHelper.classForName(
 					"org.hibernate.validator.ClassValidator", this.getClass()
 			);
 			Class messageInterpolator = ReflectHelper.classForName(
 					"org.hibernate.validator.MessageInterpolator", this.getClass()
 			);
 			validatorCtr = classValidator.getDeclaredConstructor(
 					Class.class, ResourceBundle.class, messageInterpolator, Map.class, ReflectionManager.class
 			);
 			applyMethod = classValidator.getMethod( "apply", PersistentClass.class );
 		}
 		catch ( ClassNotFoundException e ) {
 			if ( !isValidatorNotPresentLogged ) {
 				log.info( "Hibernate Validator not found: ignoring" );
 			}
 			isValidatorNotPresentLogged = true;
 		}
 		catch ( NoSuchMethodException e ) {
 			throw new AnnotationException( e );
 		}
 		if ( applyMethod != null ) {
 			for ( PersistentClass persistentClazz : classes.values() ) {
 				//integrate the validate framework
 				String className = persistentClazz.getClassName();
 				if ( StringHelper.isNotEmpty( className ) ) {
 					try {
 						Object validator = validatorCtr.newInstance(
 								ReflectHelper.classForName( className ), null, null, null, reflectionManager
 						);
 						applyMethod.invoke( validator, persistentClazz );
 					}
 					catch ( Exception e ) {
 						log.warn( "Unable to apply constraints on DDL for " + className, e );
 					}
 				}
 			}
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void applyBeanValidationConstraintsOnDDL() {
 		BeanValidationActivator.applyDDL( classes.values(), getProperties() );
 	}
 
 	private void originalSecondPassCompile() throws MappingException {
 		log.debug( "processing extends queue" );
 		processExtendsQueue();
 
 		log.debug( "processing collection mappings" );
 		Iterator itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			if ( ! (sp instanceof QuerySecondPass) ) {
 				sp.doSecondPass( classes );
 				itr.remove();
 			}
 		}
 
 		log.debug( "processing native query and ResultSetMapping mappings" );
 		itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			sp.doSecondPass( classes );
 			itr.remove();
 		}
 
 		log.debug( "processing association property references" );
 
 		itr = propertyReferences.iterator();
 		while ( itr.hasNext() ) {
 			Mappings.PropertyReference upr = (Mappings.PropertyReference) itr.next();
 
 			PersistentClass clazz = getClassMapping( upr.referencedClass );
 			if ( clazz == null ) {
 				throw new MappingException(
 						"property-ref to unmapped class: " +
 						upr.referencedClass
 					);
 			}
 
 			Property prop = clazz.getReferencedProperty( upr.propertyName );
 			if ( upr.unique ) {
 				( (SimpleValue) prop.getValue() ).setAlternateUniqueKey( true );
 			}
 		}
 
 		//TODO: Somehow add the newly created foreign keys to the internal collection
 
 		log.debug( "processing foreign key constraints" );
 
 		itr = getTableMappings();
 		Set done = new HashSet();
 		while ( itr.hasNext() ) {
 			secondPassCompileForeignKeys( (Table) itr.next(), done );
 		}
 
 	}
 
 	private int processExtendsQueue() {
 		log.debug( "processing extends queue" );
 		int added = 0;
 		ExtendsQueueEntry extendsQueueEntry = findPossibleExtends();
 		while ( extendsQueueEntry != null ) {
 			metadataSourceQueue.processHbmXml( extendsQueueEntry.getMetadataXml(), extendsQueueEntry.getEntityNames() );
 			extendsQueueEntry = findPossibleExtends();
 		}
 
 		if ( extendsQueue.size() > 0 ) {
 			Iterator iterator = extendsQueue.keySet().iterator();
 			StringBuffer buf = new StringBuffer( "Following super classes referenced in extends not found: " );
 			while ( iterator.hasNext() ) {
 				final ExtendsQueueEntry entry = ( ExtendsQueueEntry ) iterator.next();
 				buf.append( entry.getExplicitName() );
 				if ( entry.getMappingPackage() != null ) {
 					buf.append( "[" ).append( entry.getMappingPackage() ).append( "]" );
 				}
 				if ( iterator.hasNext() ) {
 					buf.append( "," );
 				}
 			}
 			throw new MappingException( buf.toString() );
 		}
 
 		return added;
 	}
 
 	protected ExtendsQueueEntry findPossibleExtends() {
 		Iterator<ExtendsQueueEntry> itr = extendsQueue.keySet().iterator();
 		while ( itr.hasNext() ) {
 			final ExtendsQueueEntry entry = itr.next();
 			boolean found = getClassMapping( entry.getExplicitName() ) != null
 					|| getClassMapping( HbmBinder.getClassName( entry.getExplicitName(), entry.getMappingPackage() ) ) != null;
 			if ( found ) {
 				itr.remove();
 				return entry;
 			}
 		}
 		return null;
 	}
 
 	protected void secondPassCompileForeignKeys(Table table, Set done) throws MappingException {
 		table.createForeignKeys();
 		Iterator iter = table.getForeignKeyIterator();
 		while ( iter.hasNext() ) {
 
 			ForeignKey fk = (ForeignKey) iter.next();
 			if ( !done.contains( fk ) ) {
 				done.add( fk );
 				final String referencedEntityName = fk.getReferencedEntityName();
 				if ( referencedEntityName == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" does not specify the referenced entity"
 						);
 				}
 				if ( log.isDebugEnabled() ) {
 					log.debug( "resolving reference to class: " + referencedEntityName );
 				}
 				PersistentClass referencedClass = classes.get( referencedEntityName );
 				if ( referencedClass == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" refers to an unmapped class: " +
 							referencedEntityName
 						);
 				}
 				if ( referencedClass.isJoinedSubclass() ) {
 					secondPassCompileForeignKeys( referencedClass.getSuperclass().getTable(), done );
 				}
 				fk.setReferencedTable( referencedClass.getTable() );
 				fk.alignColumns();
 			}
 		}
 	}
 
 	public Map<String, NamedQueryDefinition> getNamedQueries() {
 		return namedQueries;
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @return The build {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 */
 	public SessionFactory buildSessionFactory(ServiceRegistry serviceRegistry) throws HibernateException {
 		log.debug( "Preparing to build session factory with filters : " + filterDefinitions );
 
 		secondPassCompile();
 		if ( ! metadataSourceQueue.isEmpty() ) {
 			log.warn( "mapping metadata cache was not completely processed" );
 		}
 
 		enableLegacyHibernateValidator();
 		enableBeanValidation();
 		enableHibernateSearch();
 
 		validate();
 		Environment.verifyProperties( properties );
 		Properties copy = new Properties();
 		copy.putAll( properties );
 		ConfigurationHelper.resolvePlaceHolders( copy );
-		Settings settings = buildSettings( copy, serviceRegistry.getService( JdbcServices.class ) );
+		Settings settings = buildSettings( copy, serviceRegistry );
 
 		return new SessionFactoryImpl(
 				this,
 				mapping,
 				serviceRegistry,
 				settings,
 				getInitializedEventListeners(),
 				sessionFactoryObserver
 			);
 	}
 
 	private static final String LEGACY_VALIDATOR_EVENT_LISTENER = "org.hibernate.validator.event.ValidateEventListener";
 
 	private void enableLegacyHibernateValidator() {
 		//add validator events if the jar is available
 		boolean enableValidatorListeners = !"false".equalsIgnoreCase(
 				getProperty(
 						"hibernate.validator.autoregister_listeners"
 				)
 		);
 		Class validateEventListenerClass = null;
 		try {
 			validateEventListenerClass = ReflectHelper.classForName( LEGACY_VALIDATOR_EVENT_LISTENER, Configuration.class );
 		}
 		catch ( ClassNotFoundException e ) {
 			//validator is not present
 			log.debug( "Legacy Validator not present in classpath, ignoring event listener registration" );
 		}
 		if ( enableValidatorListeners && validateEventListenerClass != null ) {
 			//TODO so much duplication
 			Object validateEventListener;
 			try {
 				validateEventListener = validateEventListenerClass.newInstance();
 			}
 			catch ( Exception e ) {
 				throw new AnnotationException( "Unable to load Validator event listener", e );
 			}
 			{
 				boolean present = false;
 				PreInsertEventListener[] listeners = getEventListeners().getPreInsertEventListeners();
 				if ( listeners != null ) {
 					for ( Object eventListener : listeners ) {
 						//not isAssignableFrom since the user could subclass
 						present = present || validateEventListenerClass == eventListener.getClass();
 					}
 					if ( !present ) {
 						int length = listeners.length + 1;
 						PreInsertEventListener[] newListeners = new PreInsertEventListener[length];
 						System.arraycopy( listeners, 0, newListeners, 0, length - 1 );
 						newListeners[length - 1] = ( PreInsertEventListener ) validateEventListener;
 						getEventListeners().setPreInsertEventListeners( newListeners );
 					}
 				}
 				else {
 					getEventListeners().setPreInsertEventListeners(
 							new PreInsertEventListener[] { ( PreInsertEventListener ) validateEventListener }
 					);
 				}
 			}
 
 			//update event listener
 			{
 				boolean present = false;
 				PreUpdateEventListener[] listeners = getEventListeners().getPreUpdateEventListeners();
 				if ( listeners != null ) {
 					for ( Object eventListener : listeners ) {
 						//not isAssignableFrom since the user could subclass
 						present = present || validateEventListenerClass == eventListener.getClass();
 					}
 					if ( !present ) {
 						int length = listeners.length + 1;
 						PreUpdateEventListener[] newListeners = new PreUpdateEventListener[length];
 						System.arraycopy( listeners, 0, newListeners, 0, length - 1 );
 						newListeners[length - 1] = ( PreUpdateEventListener ) validateEventListener;
 						getEventListeners().setPreUpdateEventListeners( newListeners );
 					}
 				}
 				else {
 					getEventListeners().setPreUpdateEventListeners(
 							new PreUpdateEventListener[] { ( PreUpdateEventListener ) validateEventListener }
 					);
 				}
 			}
 		}
 	}
 
 	private void enableBeanValidation() {
 		BeanValidationActivator.activateBeanValidation( getEventListeners(), getProperties() );
 	}
 
 	private static final String SEARCH_EVENT_LISTENER_REGISTERER_CLASS = "org.hibernate.cfg.search.HibernateSearchEventListenerRegister";
 
 	/**
 	 * Tries to automatically register Hibernate Search event listeners by locating the
 	 * appropriate bootstrap class and calling the <code>enableHibernateSearch</code> method.
 	 */
 	private void enableHibernateSearch() {
 		// load the bootstrap class
 		Class searchStartupClass;
 		try {
 			searchStartupClass = ReflectHelper.classForName( SEARCH_STARTUP_CLASS, getClass() );
 		}
 		catch ( ClassNotFoundException e ) {
 			// TODO remove this together with SearchConfiguration after 3.1.0 release of Search
 			// try loading deprecated HibernateSearchEventListenerRegister
 			try {
 				searchStartupClass = ReflectHelper.classForName( SEARCH_EVENT_LISTENER_REGISTERER_CLASS, getClass() );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				log.debug( "Search not present in classpath, ignoring event listener registration." );
 				return;
 			}
 		}
 
 		// call the method for registering the listeners
 		try {
 			Object searchStartupInstance = searchStartupClass.newInstance();
 			Method enableSearchMethod = searchStartupClass.getDeclaredMethod(
 					SEARCH_STARTUP_METHOD,
 					EventListeners.class,
 					Properties.class
 			);
 			enableSearchMethod.invoke( searchStartupInstance, getEventListeners(), getProperties() );
 		}
 		catch ( InstantiationException e ) {
 			log.debug( "Unable to instantiate {}, ignoring event listener registration.", SEARCH_STARTUP_CLASS );
 		}
 		catch ( IllegalAccessException e ) {
 			log.debug( "Unable to instantiate {}, ignoring event listener registration.", SEARCH_STARTUP_CLASS );
 		}
 		catch ( NoSuchMethodException e ) {
 			log.debug( "Method enableHibernateSearch() not found in {}.", SEARCH_STARTUP_CLASS );
 		}
 		catch ( InvocationTargetException e ) {
 			log.debug( "Unable to execute {}, ignoring event listener registration.", SEARCH_STARTUP_METHOD );
 		}
 	}
 
 	private EventListeners getInitializedEventListeners() {
 		EventListeners result = (EventListeners) eventListeners.shallowCopy();
 		result.initializeListeners( this );
 		return result;
 	}
 
 	/**
 	 * Rterieve the configured {@link Interceptor}.
 	 *
 	 * @return The current {@link Interceptor}
 	 */
 	public Interceptor getInterceptor() {
 		return interceptor;
 	}
 
 	/**
 	 * Set the current {@link Interceptor}
 	 *
 	 * @param interceptor The {@link Interceptor} to use for the {@link #buildSessionFactory() built}
 	 * {@link SessionFactory}.
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setInterceptor(Interceptor interceptor) {
 		this.interceptor = interceptor;
 		return this;
 	}
 
 	/**
 	 * Get all properties
 	 *
 	 * @return all properties
 	 */
 	public Properties getProperties() {
 		return properties;
 	}
 
 	/**
 	 * Get a property value by name
 	 *
 	 * @param propertyName The name of the property
 	 *
 	 * @return The value curently associated with that property name; may be null.
 	 */
 	public String getProperty(String propertyName) {
 		return properties.getProperty( propertyName );
 	}
 
 	/**
 	 * Specify a completely new set of properties
 	 *
 	 * @param properties The new set of properties
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperties(Properties properties) {
 		this.properties = properties;
 		return this;
 	}
 
 	/**
 	 * Add the given properties to ours.
 	 *
 	 * @param extraProperties The properties to add.
 	 *
 	 * @return this for method chaining
 	 *
 	 */
 	public Configuration addProperties(Properties extraProperties) {
 		this.properties.putAll( extraProperties );
 		return this;
 	}
 
 	/**
 	 * Adds the incoming properties to the internal properties structure, as long as the internal structure does not
 	 * already contain an entry for the given key.
 	 *
 	 * @param properties The properties to merge
 	 *
 	 * @return this for ethod chaining
 	 */
 	public Configuration mergeProperties(Properties properties) {
 		for ( Map.Entry entry : properties.entrySet() ) {
 			if ( this.properties.containsKey( entry.getKey() ) ) {
 				continue;
 			}
 			this.properties.setProperty( (String) entry.getKey(), (String) entry.getValue() );
 		}
 		return this;
 	}
 
 	/**
 	 * Set a property value by name
 	 *
 	 * @param propertyName The name of the property to set
 	 * @param value The new property value
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperty(String propertyName, String value) {
 		properties.setProperty( propertyName, value );
 		return this;
 	}
 
 	private void addProperties(Element parent) {
 		Iterator itr = parent.elementIterator( "property" );
 		while ( itr.hasNext() ) {
 			Element node = (Element) itr.next();
 			String name = node.attributeValue( "name" );
 			String value = node.getText().trim();
 			log.debug( name + "=" + value );
 			properties.setProperty( name, value );
 			if ( !name.startsWith( "hibernate" ) ) {
 				properties.setProperty( "hibernate." + name, value );
 			}
 		}
 		Environment.verifyProperties( properties );
 	}
 
 	/**
 	 * Use the mappings and properties specified in an application resource named <tt>hibernate.cfg.xml</tt>.
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find <tt>hibernate.cfg.xml</tt>
 	 *
 	 * @see #configure(String)
 	 */
 	public Configuration configure() throws HibernateException {
 		configure( "/hibernate.cfg.xml" );
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application resource. The format of the resource is
 	 * defined in <tt>hibernate-configuration-3.0.dtd</tt>.
 	 * <p/>
 	 * The resource is found via {@link #getConfigurationInputStream}
 	 *
 	 * @param resource The resource to use
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(String resource) throws HibernateException {
 		log.info( "configuring from resource: " + resource );
 		InputStream stream = getConfigurationInputStream( resource );
 		return doConfigure( stream, resource );
 	}
 
 	/**
 	 * Get the configuration file as an <tt>InputStream</tt>. Might be overridden
 	 * by subclasses to allow the configuration to be located by some arbitrary
 	 * mechanism.
 	 * <p/>
 	 * By default here we use classpath resource resolution
 	 *
 	 * @param resource The resource to locate
 	 *
 	 * @return The stream
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 */
 	protected InputStream getConfigurationInputStream(String resource) throws HibernateException {
 		log.info( "Configuration resource: " + resource );
 		return ConfigHelper.getResourceAsStream( resource );
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given document. The format of the document is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param url URL from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the url
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(URL url) throws HibernateException {
 		log.info( "configuring from url: " + url.toString() );
 		try {
 			return doConfigure( url.openStream(), url.toString() );
 		}
 		catch (IOException ioe) {
 			throw new HibernateException( "could not configure from URL: " + url, ioe );
 		}
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application file. The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param configFile File from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the file
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(File configFile) throws HibernateException {
 		log.info( "configuring from file: " + configFile.getName() );
 		try {
 			return doConfigure( new FileInputStream( configFile ), configFile.toString() );
 		}
 		catch (FileNotFoundException fnfe) {
 			throw new HibernateException( "could not find file: " + configFile, fnfe );
 		}
 	}
 
 	/**
 	 * Configure this configuration's state from the contents of the given input stream.  The expectation is that
 	 * the stream contents represent an XML document conforming to the Hibernate Configuration DTD.  See
 	 * {@link #doConfigure(Document)} for further details.
 	 *
 	 * @param stream The input stream from which to read
 	 * @param resourceName The name to use in warning/error messages
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem reading the stream contents.
 	 */
 	protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {
 		try {
 			List errors = new ArrayList();
 			Document document = xmlHelper.createSAXReader( resourceName, errors, entityResolver )
 					.read( new InputSource( stream ) );
 			if ( errors.size() != 0 ) {
 				throw new MappingException( "invalid configuration", (Throwable) errors.get( 0 ) );
 			}
 			doConfigure( document );
 		}
 		catch (DocumentException e) {
 			throw new HibernateException( "Could not parse configuration: " + resourceName, e );
 		}
 		finally {
 			try {
 				stream.close();
 			}
 			catch (IOException ioe) {
 				log.warn( "could not close input stream for: " + resourceName, ioe );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given XML document.
 	 * The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param document an XML document from which you wish to load the configuration
 	 * @return A configuration configured via the <tt>Document</tt>
 	 * @throws HibernateException if there is problem in accessing the file.
 	 */
 	public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
 		log.info( "configuring from XML document" );
 		return doConfigure( xmlHelper.createDOMReader().read( document ) );
 	}
 
 	/**
 	 * Parse a dom4j document conforming to the Hibernate Configuration DTD (<tt>hibernate-configuration-3.0.dtd</tt>)
 	 * and use its information to configure this {@link Configuration}'s state
 	 *
 	 * @param doc The dom4j document
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem performing the configuration task
 	 */
 	protected Configuration doConfigure(Document doc) throws HibernateException {
 		Element sfNode = doc.getRootElement().element( "session-factory" );
 		String name = sfNode.attributeValue( "name" );
 		if ( name != null ) {
 			properties.setProperty( Environment.SESSION_FACTORY_NAME, name );
 		}
 		addProperties( sfNode );
 		parseSessionFactory( sfNode, name );
 
 		Element secNode = doc.getRootElement().element( "security" );
 		if ( secNode != null ) {
 			parseSecurity( secNode );
 		}
 
 		log.info( "Configured SessionFactory: " + name );
 		log.debug( "properties: " + properties );
 
 		return this;
 	}
 
 
 	private void parseSessionFactory(Element sfNode, String name) {
 		Iterator elements = sfNode.elementIterator();
 		while ( elements.hasNext() ) {
 			Element subelement = (Element) elements.next();
 			String subelementName = subelement.getName();
 			if ( "mapping".equals( subelementName ) ) {
 				parseMappingElement( subelement, name );
 			}
 			else if ( "class-cache".equals( subelementName ) ) {
 				String className = subelement.attributeValue( "class" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? className : regionNode.getValue();
 				boolean includeLazy = !"non-lazy".equals( subelement.attributeValue( "include" ) );
 				setCacheConcurrencyStrategy( className, subelement.attributeValue( "usage" ), region, includeLazy );
 			}
 			else if ( "collection-cache".equals( subelementName ) ) {
 				String role = subelement.attributeValue( "collection" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? role : regionNode.getValue();
 				setCollectionCacheConcurrencyStrategy( role, subelement.attributeValue( "usage" ), region );
 			}
 			else if ( "listener".equals( subelementName ) ) {
 				parseListener( subelement );
 			}
 			else if ( "event".equals( subelementName ) ) {
 				parseEvent( subelement );
 			}
 		}
 	}
 
 	private void parseMappingElement(Element mappingElement, String name) {
 		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
 		final Attribute fileAttribute = mappingElement.attribute( "file" );
 		final Attribute jarAttribute = mappingElement.attribute( "jar" );
 		final Attribute packageAttribute = mappingElement.attribute( "package" );
 		final Attribute classAttribute = mappingElement.attribute( "class" );
 
 		if ( resourceAttribute != null ) {
 			final String resourceName = resourceAttribute.getValue();
 			log.debug( "session-factory config [{}] named resource [{}] for mapping", name, resourceName );
 			addResource( resourceName );
 		}
 		else if ( fileAttribute != null ) {
 			final String fileName = fileAttribute.getValue();
 			log.debug( "session-factory config [{}] named file [{}] for mapping", name, fileName );
 			addFile( fileName );
 		}
 		else if ( jarAttribute != null ) {
 			final String jarFileName = jarAttribute.getValue();
 			log.debug( "session-factory config [{}] named jar file [{}] for mapping", name, jarFileName );
 			addJar( new File( jarFileName ) );
 		}
 		else if ( packageAttribute != null ) {
 			final String packageName = packageAttribute.getValue();
 			log.debug( "session-factory config [{}] named package [{}] for mapping", name, packageName );
 			addPackage( packageName );
 		}
 		else if ( classAttribute != null ) {
 			final String className = classAttribute.getValue();
 			log.debug( "session-factory config [{}] named class [{}] for mapping", name, className );
 
 			try {
 				addAnnotatedClass( ReflectHelper.classForName( className ) );
 			}
 			catch ( Exception e ) {
 				throw new MappingException(
 						"Unable to load class [ " + className + "] declared in Hibernate configuration <mapping/> entry",
 						e
 				);
 			}
 		}
 		else {
 			throw new MappingException( "<mapping> element in configuration specifies no known attributes" );
 		}
 	}
 
 	private void parseSecurity(Element secNode) {
 		String contextId = secNode.attributeValue( "context" );
       setProperty(Environment.JACC_CONTEXTID, contextId);
 		log.info( "JACC contextID: " + contextId );
 		JACCConfiguration jcfg = new JACCConfiguration( contextId );
 		Iterator grantElements = secNode.elementIterator();
 		while ( grantElements.hasNext() ) {
 			Element grantElement = (Element) grantElements.next();
 			String elementName = grantElement.getName();
 			if ( "grant".equals( elementName ) ) {
 				jcfg.addPermission(
 						grantElement.attributeValue( "role" ),
 						grantElement.attributeValue( "entity-name" ),
 						grantElement.attributeValue( "actions" )
 					);
 			}
 		}
 	}
 
 	private void parseEvent(Element element) {
 		String type = element.attributeValue( "type" );
 		List listeners = element.elements();
 		String[] listenerClasses = new String[ listeners.size() ];
 		for ( int i = 0; i < listeners.size() ; i++ ) {
 			listenerClasses[i] = ( (Element) listeners.get( i ) ).attributeValue( "class" );
 		}
 		log.debug( "Event listeners: " + type + "=" + StringHelper.toString( listenerClasses ) );
 		setListeners( type, listenerClasses );
 	}
 
 	private void parseListener(Element element) {
 		String type = element.attributeValue( "type" );
 		if ( type == null ) {
 			throw new MappingException( "No type specified for listener" );
 		}
 		String impl = element.attributeValue( "class" );
 		log.debug( "Event listener: " + type + "=" + impl );
 		setListeners( type, new String[]{impl} );
 	}
 
 	public void setListener(String type, String listener) {
 		String[] listeners = null;
 		if ( listener != null ) {
 			listeners = (String[]) Array.newInstance( String.class, 1 );
 			listeners[0] = listener;
 		}
 		setListeners( type, listeners );
 	}
 
 	public void setListeners(String type, String[] listenerClasses) {
 		Object[] listeners = null;
 		if ( listenerClasses != null ) {
 			listeners = (Object[]) Array.newInstance( eventListeners.getListenerClassFor(type), listenerClasses.length );
 			for ( int i = 0; i < listeners.length ; i++ ) {
 				try {
 					listeners[i] = ReflectHelper.classForName( listenerClasses[i] ).newInstance();
 				}
 				catch (Exception e) {
 					throw new MappingException(
 							"Unable to instantiate specified event (" + type + ") listener class: " + listenerClasses[i],
 							e
 						);
 				}
 			}
 		}
 		setListeners( type, listeners );
 	}
 
 	public void setListener(String type, Object listener) {
 		Object[] listeners = null;
 		if ( listener != null ) {
 			listeners = (Object[]) Array.newInstance( eventListeners.getListenerClassFor(type), 1 );
 			listeners[0] = listener;
 		}
 		setListeners( type, listeners );
 	}
 
 	public void setListeners(String type, Object[] listeners) {
 		if ( "auto-flush".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setAutoFlushEventListeners( new AutoFlushEventListener[]{} );
 			}
 			else {
 				eventListeners.setAutoFlushEventListeners( (AutoFlushEventListener[]) listeners );
 			}
 		}
 		else if ( "merge".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setMergeEventListeners( new MergeEventListener[]{} );
 			}
 			else {
 				eventListeners.setMergeEventListeners( (MergeEventListener[]) listeners );
 			}
 		}
 		else if ( "create".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPersistEventListeners( new PersistEventListener[]{} );
 			}
 			else {
 				eventListeners.setPersistEventListeners( (PersistEventListener[]) listeners );
 			}
 		}
 		else if ( "create-onflush".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPersistOnFlushEventListeners( new PersistEventListener[]{} );
 			}
 			else {
 				eventListeners.setPersistOnFlushEventListeners( (PersistEventListener[]) listeners );
 			}
 		}
 		else if ( "delete".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setDeleteEventListeners( new DeleteEventListener[]{} );
 			}
 			else {
 				eventListeners.setDeleteEventListeners( (DeleteEventListener[]) listeners );
 			}
 		}
 		else if ( "dirty-check".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setDirtyCheckEventListeners( new DirtyCheckEventListener[]{} );
 			}
 			else {
 				eventListeners.setDirtyCheckEventListeners( (DirtyCheckEventListener[]) listeners );
 			}
 		}
 		else if ( "evict".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setEvictEventListeners( new EvictEventListener[]{} );
 			}
 			else {
 				eventListeners.setEvictEventListeners( (EvictEventListener[]) listeners );
 			}
 		}
 		else if ( "flush".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setFlushEventListeners( new FlushEventListener[]{} );
 			}
 			else {
 				eventListeners.setFlushEventListeners( (FlushEventListener[]) listeners );
 			}
 		}
 		else if ( "flush-entity".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setFlushEntityEventListeners( new FlushEntityEventListener[]{} );
 			}
 			else {
 				eventListeners.setFlushEntityEventListeners( (FlushEntityEventListener[]) listeners );
 			}
 		}
 		else if ( "load".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setLoadEventListeners( new LoadEventListener[]{} );
 			}
 			else {
 				eventListeners.setLoadEventListeners( (LoadEventListener[]) listeners );
 			}
 		}
 		else if ( "load-collection".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setInitializeCollectionEventListeners(
 						new InitializeCollectionEventListener[]{}
 					);
 			}
 			else {
 				eventListeners.setInitializeCollectionEventListeners(
 						(InitializeCollectionEventListener[]) listeners
 					);
 			}
 		}
 		else if ( "lock".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setLockEventListeners( new LockEventListener[]{} );
 			}
 			else {
 				eventListeners.setLockEventListeners( (LockEventListener[]) listeners );
 			}
 		}
 		else if ( "refresh".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setRefreshEventListeners( new RefreshEventListener[]{} );
 			}
 			else {
 				eventListeners.setRefreshEventListeners( (RefreshEventListener[]) listeners );
 			}
 		}
 		else if ( "replicate".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setReplicateEventListeners( new ReplicateEventListener[]{} );
 			}
 			else {
 				eventListeners.setReplicateEventListeners( (ReplicateEventListener[]) listeners );
 			}
 		}
 		else if ( "save-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setSaveOrUpdateEventListeners( new SaveOrUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setSaveOrUpdateEventListeners( (SaveOrUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "save".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setSaveEventListeners( new SaveOrUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setSaveEventListeners( (SaveOrUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setUpdateEventListeners( new SaveOrUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setUpdateEventListeners( (SaveOrUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-load".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreLoadEventListeners( new PreLoadEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreLoadEventListeners( (PreLoadEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreUpdateEventListeners( new PreUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreUpdateEventListeners( (PreUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-delete".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreDeleteEventListeners( new PreDeleteEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreDeleteEventListeners( (PreDeleteEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-insert".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreInsertEventListeners( new PreInsertEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreInsertEventListeners( (PreInsertEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-collection-recreate".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreCollectionRecreateEventListeners( new PreCollectionRecreateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreCollectionRecreateEventListeners( (PreCollectionRecreateEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-collection-remove".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreCollectionRemoveEventListeners( new PreCollectionRemoveEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreCollectionRemoveEventListeners( ( PreCollectionRemoveEventListener[]) listeners );
 			}
 		}
 		else if ( "pre-collection-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPreCollectionUpdateEventListeners( new PreCollectionUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPreCollectionUpdateEventListeners( ( PreCollectionUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "post-load".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostLoadEventListeners( new PostLoadEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostLoadEventListeners( (PostLoadEventListener[]) listeners );
 			}
 		}
 		else if ( "post-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostUpdateEventListeners( new PostUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostUpdateEventListeners( (PostUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "post-delete".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostDeleteEventListeners( new PostDeleteEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostDeleteEventListeners( (PostDeleteEventListener[]) listeners );
 			}
 		}
 		else if ( "post-insert".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostInsertEventListeners( new PostInsertEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostInsertEventListeners( (PostInsertEventListener[]) listeners );
 			}
 		}
 		else if ( "post-commit-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCommitUpdateEventListeners(
 						new PostUpdateEventListener[]{}
 					);
 			}
 			else {
 				eventListeners.setPostCommitUpdateEventListeners( (PostUpdateEventListener[]) listeners );
 			}
 		}
 		else if ( "post-commit-delete".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCommitDeleteEventListeners(
 						new PostDeleteEventListener[]{}
 					);
 			}
 			else {
 				eventListeners.setPostCommitDeleteEventListeners( (PostDeleteEventListener[]) listeners );
 			}
 		}
 		else if ( "post-commit-insert".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCommitInsertEventListeners(
 						new PostInsertEventListener[]{}
 				);
 			}
 			else {
 				eventListeners.setPostCommitInsertEventListeners( (PostInsertEventListener[]) listeners );
 			}
 		}
 		else if ( "post-collection-recreate".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCollectionRecreateEventListeners( new PostCollectionRecreateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostCollectionRecreateEventListeners( (PostCollectionRecreateEventListener[]) listeners );
 			}
 		}
 		else if ( "post-collection-remove".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCollectionRemoveEventListeners( new PostCollectionRemoveEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostCollectionRemoveEventListeners( ( PostCollectionRemoveEventListener[]) listeners );
 			}
 		}
 		else if ( "post-collection-update".equals( type ) ) {
 			if ( listeners == null ) {
 				eventListeners.setPostCollectionUpdateEventListeners( new PostCollectionUpdateEventListener[]{} );
 			}
 			else {
 				eventListeners.setPostCollectionUpdateEventListeners( ( PostCollectionUpdateEventListener[]) listeners );
 			}
 		}
 		else {
 			throw new MappingException("Unrecognized listener type [" + type + "]");
 		}
 	}
 
 	public EventListeners getEventListeners() {
 		return eventListeners;
 	}
 
 	RootClass getRootClassMapping(String clazz) throws MappingException {
 		try {
 			return (RootClass) getClassMapping( clazz );
 		}
 		catch (ClassCastException cce) {
 			throw new MappingException( "You may only specify a cache for root <class> mappings" );
 		}
 	}
 
 	/**
 	 * Set up a cache for an entity class
 	 *
 	 * @param entityName The name of the entity to which we shoudl associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for an entity class, giving an explicit region name
 	 *
 	 * @param entityName The name of the entity to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy, String region) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, region, true );
 		return this;
 	}
 
 	public void setCacheConcurrencyStrategy(
 			String entityName,
 			String concurrencyStrategy,
 			String region,
 			boolean cacheLazyProperty) throws MappingException {
 		caches.add( new CacheHolder( entityName, concurrencyStrategy, region, true, cacheLazyProperty ) );
 	}
 
 	private void applyCacheConcurrencyStrategy(CacheHolder holder) {
 		RootClass rootClass = getRootClassMapping( holder.role );
 		if ( rootClass == null ) {
 			throw new MappingException( "Cannot cache an unknown entity: " + holder.role );
 		}
 		rootClass.setCacheConcurrencyStrategy( holder.usage );
 		rootClass.setCacheRegionName( holder.region );
 		rootClass.setLazyPropertiesCacheable( holder.cacheLazy );
 	}
 
 	/**
 	 * Set up a cache for a collection role
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy) {
 		setCollectionCacheConcurrencyStrategy( collectionRole, concurrencyStrategy, collectionRole );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for a collection role, giving an explicit region name
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 *
 	 * @return this for method chaining
 	 */
 	public void setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy, String region) {
 		caches.add( new CacheHolder( collectionRole, concurrencyStrategy, region, false, false ) );
 	}
 
 	private void applyCollectionCacheConcurrencyStrategy(CacheHolder holder) {
 		Collection collection = getCollectionMapping( holder.role );
 		if ( collection == null ) {
 			throw new MappingException( "Cannot cache an unknown collection: " + holder.role );
 		}
 		collection.setCacheConcurrencyStrategy( holder.usage );
 		collection.setCacheRegionName( holder.region );
 	}
 
 	/**
 	 * Get the query language imports
 	 *
 	 * @return a mapping from "import" names to fully qualified class names
 	 */
 	public Map<String,String> getImports() {
 		return imports;
 	}
 
 	/**
 	 * Create an object-oriented view of the configuration properties
 	 *
 	 * @return The build settings
 	 */
-	public Settings buildSettings(JdbcServices jdbcServices) {
+	public Settings buildSettings(ServiceRegistry serviceRegistry) {
 		Properties clone = ( Properties ) properties.clone();
 		ConfigurationHelper.resolvePlaceHolders( clone );
-		return buildSettingsInternal( clone, jdbcServices );
+		return buildSettingsInternal( clone, serviceRegistry );
 	}
 
-	public Settings buildSettings(Properties props, JdbcServices jdbcServices) throws HibernateException {
-		return buildSettingsInternal( props, jdbcServices );
+	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) throws HibernateException {
+		return buildSettingsInternal( props, serviceRegistry );
 	}
 
-	private Settings buildSettingsInternal(Properties props, JdbcServices jdbcServices) {
-		final Settings settings = settingsFactory.buildSettings( props, jdbcServices );
+	private Settings buildSettingsInternal(Properties props, ServiceRegistry serviceRegistry) {
+		final Settings settings = settingsFactory.buildSettings( props, serviceRegistry );
 		settings.setEntityTuplizerFactory( this.getEntityTuplizerFactory() );
 //		settings.setComponentTuplizerFactory( this.getComponentTuplizerFactory() );
 		return settings;
 	}
 
 	public Map getNamedSQLQueries() {
 		return namedSqlQueries;
 	}
 
 	public Map getSqlResultSetMappings() {
 		return sqlResultSetMappings;
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	/**
 	 * Set a custom naming strategy
 	 *
 	 * @param namingStrategy the NamingStrategy to set
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setNamingStrategy(NamingStrategy namingStrategy) {
 		this.namingStrategy = namingStrategy;
 		return this;
 	}
 
 	public PersisterClassProvider getPersisterClassProvider() {
 		return persisterClassProvider;
 	}
 
 	/**
 	 * Defines a custom persister class provider.
 	 *
 	 * The persister class is chosen according to the following rules in decreasing priority:
 	 *  - the persister class defined explicitly via annotation or XML
 	 *  - the persister class returned by the PersisterClassProvider implementation (if not null)
 	 *  - the default provider as chosen by Hibernate Core (best choice most of the time)
 	 *
 	 *
 	 * @param persisterClassProvider implementation
 	 */
 	public Configuration setPersisterClassProvider(PersisterClassProvider persisterClassProvider) {
 		this.persisterClassProvider = persisterClassProvider;
 		return this;
 	}
 
 	/**
 	 * Retrieve the IdentifierGeneratorFactory in effect for this configuration.
 	 *
 	 * @return This configuration's IdentifierGeneratorFactory.
 	 */
 	public DefaultIdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return identifierGeneratorFactory;
 	}
 
 	public Mapping buildMapping() {
 		return new Mapping() {
 			public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 				return identifierGeneratorFactory;
 			}
 
 			/**
 			 * Returns the identifier type of a mapped class
 			 */
 			public Type getIdentifierType(String entityName) throws MappingException {
 				PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				return pc.getIdentifier().getType();
 			}
 
 			public String getIdentifierPropertyName(String entityName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				if ( !pc.hasIdentifierProperty() ) {
 					return null;
 				}
 				return pc.getIdentifierProperty().getName();
 			}
 
 			public Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				Property prop = pc.getReferencedProperty( propertyName );
 				if ( prop == null ) {
 					throw new MappingException(
 							"property not known: " +
 							entityName + '.' + propertyName
 						);
 				}
 				return prop.getType();
 			}
 		};
 	}
 
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		//we need  reflectionManager before reading the other components (MetadataSourceQueue in particular)
 		final MetadataProvider metadataProvider = (MetadataProvider) ois.readObject();
 		this.mapping = buildMapping();
 		xmlHelper = new XMLHelper();
 		createReflectionManager(metadataProvider);
 		ois.defaultReadObject();
 	}
 
 	private void writeObject(java.io.ObjectOutputStream out) throws IOException {
 		//We write MetadataProvider first as we need  reflectionManager before reading the other components
 		final MetadataProvider metadataProvider = ( ( MetadataProviderInjector ) reflectionManager ).getMetadataProvider();
 		out.writeObject( metadataProvider );
 		out.defaultWriteObject();
 	}
 
 	private void createReflectionManager() {
 		createReflectionManager( new JPAMetadataProvider() );
 	}
 
 	private void createReflectionManager(MetadataProvider metadataProvider) {
 		reflectionManager = new JavaReflectionManager();
 		( ( MetadataProviderInjector ) reflectionManager ).setMetadataProvider( metadataProvider );
 	}
 
 	public Map getFilterDefinitions() {
 		return filterDefinitions;
 	}
 
 	public void addFilterDefinition(FilterDefinition definition) {
 		filterDefinitions.put( definition.getFilterName(), definition );
 	}
 
 	public Iterator iterateFetchProfiles() {
 		return fetchProfiles.values().iterator();
 	}
 
 	public void addFetchProfile(FetchProfile fetchProfile) {
 		fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 	}
 
 	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject object) {
 		auxiliaryDatabaseObjects.add( object );
 	}
 
 	public Map getSqlFunctions() {
 		return sqlFunctions;
 	}
 
 	public void addSqlFunction(String functionName, SQLFunction function) {
 		sqlFunctions.put( functionName, function );
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	/**
 	 * Allows registration of a type into the type registry.  The phrase 'override' in the method name simply
 	 * reminds that registration *potentially* replaces a previously registered type .
 	 *
 	 * @param type The type to register.
 	 */
 	public void registerTypeOverride(BasicType type) {
 		getTypeResolver().registerTypeOverride( type );
 	}
 
 
 	public void registerTypeOverride(UserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public void registerTypeOverride(CompositeUserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public SessionFactoryObserver getSessionFactoryObserver() {
 		return sessionFactoryObserver;
 	}
 
 	public void setSessionFactoryObserver(SessionFactoryObserver sessionFactoryObserver) {
 		this.sessionFactoryObserver = sessionFactoryObserver;
 	}
 
 
 	// Mappings impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Internal implementation of the Mappings interface giving access to the Configuration's internal
 	 * <tt>metadata repository</tt> state ({@link Configuration#classes}, {@link Configuration#tables}, etc).
 	 */
 	protected class MappingsImpl implements ExtendedMappings, Serializable {
 
 		private String schemaName;
 
 		public String getSchemaName() {
 			return schemaName;
 		}
 
 		public void setSchemaName(String schemaName) {
 			this.schemaName = schemaName;
 		}
 
 
 		private String catalogName;
 
 		public String getCatalogName() {
 			return catalogName;
 		}
 
 		public void setCatalogName(String catalogName) {
 			this.catalogName = catalogName;
 		}
 
 
 		private String defaultPackage;
 
 		public String getDefaultPackage() {
 			return defaultPackage;
 		}
 
 		public void setDefaultPackage(String defaultPackage) {
 			this.defaultPackage = defaultPackage;
 		}
 
 
 		private boolean autoImport;
 
 		public boolean isAutoImport() {
 			return autoImport;
 		}
 
 		public void setAutoImport(boolean autoImport) {
 			this.autoImport = autoImport;
 		}
 
 
 		private boolean defaultLazy;
 
 		public boolean isDefaultLazy() {
 			return defaultLazy;
 		}
 
 		public void setDefaultLazy(boolean defaultLazy) {
 			this.defaultLazy = defaultLazy;
 		}
 
 
 		private String defaultCascade;
 
 		public String getDefaultCascade() {
 			return defaultCascade;
 		}
 
 		public void setDefaultCascade(String defaultCascade) {
 			this.defaultCascade = defaultCascade;
 		}
 
 
 		private String defaultAccess;
 
 		public String getDefaultAccess() {
 			return defaultAccess;
 		}
 
 		public void setDefaultAccess(String defaultAccess) {
 			this.defaultAccess = defaultAccess;
 		}
 
 
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 
 		public void setNamingStrategy(NamingStrategy namingStrategy) {
 			Configuration.this.namingStrategy = namingStrategy;
 		}
 
 		public PersisterClassProvider getPersisterClassProvider() {
 			return persisterClassProvider;
 		}
 
 		public void setPersisterClassProvider(PersisterClassProvider persisterClassProvider) {
 			Configuration.this.persisterClassProvider = persisterClassProvider;
 		}
 
 		public TypeResolver getTypeResolver() {
 			return typeResolver;
 		}
 
 		public Iterator<PersistentClass> iterateClasses() {
 			return classes.values().iterator();
 		}
 
 		public PersistentClass getClass(String entityName) {
 			return classes.get( entityName );
 		}
 
 		public PersistentClass locatePersistentClassByEntityName(String entityName) {
 			PersistentClass persistentClass = classes.get( entityName );
 			if ( persistentClass == null ) {
 				String actualEntityName = imports.get( entityName );
 				if ( StringHelper.isNotEmpty( actualEntityName ) ) {
 					persistentClass = classes.get( actualEntityName );
 				}
 			}
 			return persistentClass;
 		}
 
 		public void addClass(PersistentClass persistentClass) throws DuplicateMappingException {
 			Object old = classes.put( persistentClass.getEntityName(), persistentClass );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "class/entity", persistentClass.getEntityName() );
 			}
 		}
 
 		public void addImport(String entityName, String rename) throws DuplicateMappingException {
 			String existing = imports.put( rename, entityName );
 			if ( existing != null ) {
 				if ( existing.equals( entityName ) ) {
 					log.info( "duplicate import: {} -> {}", entityName, rename );
 				}
 				else {
 					throw new DuplicateMappingException(
 							"duplicate import: " + rename + " refers to both " + entityName +
 									" and " + existing + " (try using auto-import=\"false\")",
 							"import",
 							rename
 					);
 				}
 			}
 		}
 
 		public Collection getCollection(String role) {
 			return collections.get( role );
 		}
 
 		public Iterator<Collection> iterateCollections() {
 			return collections.values().iterator();
 		}
 
 		public void addCollection(Collection collection) throws DuplicateMappingException {
 			Object old = collections.put( collection.getRole(), collection );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "collection role", collection.getRole() );
 			}
 		}
 
 		public Table getTable(String schema, String catalog, String name) {
 			String key = Table.qualify(catalog, schema, name);
 			return tables.get(key);
 		}
 
 		public Iterator<Table> iterateTables() {
 			return tables.values().iterator();
 		}
 
 		public Table addTable(
 				String schema,
 				String catalog,
 				String name,
 				String subselect,
 				boolean isAbstract) {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify( catalog, schema, name ) : subselect;
 			Table table = tables.get( key );
 
 			if ( table == null ) {
 				table = new Table();
 				table.setAbstract( isAbstract );
 				table.setName( name );
 				table.setSchema( schema );
 				table.setCatalog( catalog );
 				table.setSubselect( subselect );
 				tables.put( key, table );
 			}
 			else {
 				if ( !isAbstract ) {
 					table.setAbstract( false );
 				}
 			}
 
 			return table;
 		}
 
 		public Table addDenormalizedTable(
 				String schema,
 				String catalog,
 				String name,
 				boolean isAbstract,
 				String subselect,
 				Table includedTable) throws DuplicateMappingException {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify(catalog, schema, name) : subselect;
 			if ( tables.containsKey( key ) ) {
 				throw new DuplicateMappingException( "table", name );
 			}
 
 			Table table = new DenormalizedTable( includedTable );
 			table.setAbstract( isAbstract );
 			table.setName( name );
 			table.setSchema( schema );
 			table.setCatalog( catalog );
 			table.setSubselect( subselect );
 
 			tables.put( key, table );
 			return table;
 		}
 
 		public NamedQueryDefinition getQuery(String name) {
 			return namedQueries.get( name );
 		}
 
 		public void addQuery(String name, NamedQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedQueryNames.contains( name ) ) {
 				applyQuery( name, query );
 			}
 		}
 
 		private void applyQuery(String name, NamedQueryDefinition query) {
 			checkQueryName( name );
 			namedQueries.put( name.intern(), query );
 		}
 
 		private void checkQueryName(String name) throws DuplicateMappingException {
 			if ( namedQueries.containsKey( name ) || namedSqlQueries.containsKey( name ) ) {
 				throw new DuplicateMappingException( "query", name );
 			}
 		}
 
 		public void addDefaultQuery(String name, NamedQueryDefinition query) {
 			applyQuery( name, query );
 			defaultNamedQueryNames.add( name );
 		}
 
 		public NamedSQLQueryDefinition getSQLQuery(String name) {
 			return namedSqlQueries.get( name );
 		}
 
 		public void addSQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedNativeQueryNames.contains( name ) ) {
 				applySQLQuery( name, query );
 			}
 		}
 
 		private void applySQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			checkQueryName( name );
 			namedSqlQueries.put( name.intern(), query );
 		}
 
 		public void addDefaultSQLQuery(String name, NamedSQLQueryDefinition query) {
 			applySQLQuery( name, query );
 			defaultNamedNativeQueryNames.add( name );
 		}
 
 		public ResultSetMappingDefinition getResultSetMapping(String name) {
 			return sqlResultSetMappings.get(name);
 		}
 
 		public void addResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping) throws DuplicateMappingException {
 			if ( !defaultSqlResultSetMappingNames.contains( sqlResultSetMapping.getName() ) ) {
 				applyResultSetMapping( sqlResultSetMapping );
 			}
 		}
 
 		public void applyResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping) throws DuplicateMappingException {
 			Object old = sqlResultSetMappings.put( sqlResultSetMapping.getName(), sqlResultSetMapping );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "resultSet",  sqlResultSetMapping.getName() );
 			}
 		}
 
 		public void addDefaultResultSetMapping(ResultSetMappingDefinition definition) {
 			final String name = definition.getName();
 			if ( !defaultSqlResultSetMappingNames.contains( name ) && getResultSetMapping( name ) != null ) {
 				removeResultSetMapping( name );
 			}
 			applyResultSetMapping( definition );
 			defaultSqlResultSetMappingNames.add( name );
 		}
 
 		protected void removeResultSetMapping(String name) {
 			sqlResultSetMappings.remove( name );
 		}
 
 		public TypeDef getTypeDef(String typeName) {
 			return typeDefs.get( typeName );
 		}
 
 		public void addTypeDef(String typeName, String typeClass, Properties paramMap) {
 			TypeDef def = new TypeDef( typeClass, paramMap );
 			typeDefs.put( typeName, def );
 			log.debug( "Added " + typeName + " with class " + typeClass );
 		}
 
 		public Map getFilterDefinitions() {
 			return filterDefinitions;
 		}
 
 		public FilterDefinition getFilterDefinition(String name) {
 			return filterDefinitions.get( name );
 		}
 
 		public void addFilterDefinition(FilterDefinition definition) {
 			filterDefinitions.put( definition.getFilterName(), definition );
 		}
 
 		public FetchProfile findOrCreateFetchProfile(String name, MetadataSource source) {
 			FetchProfile profile = fetchProfiles.get( name );
 			if ( profile == null ) {
 				profile = new FetchProfile( name, source );
 				fetchProfiles.put( name, profile );
 			}
 			return profile;
 		}
 
 		public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects() {
 			return iterateAuxiliaryDatabaseObjects();
 		}
 
 		public Iterator<AuxiliaryDatabaseObject> iterateAuxiliaryDatabaseObjects() {
 			return auxiliaryDatabaseObjects.iterator();
 		}
 
 		public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse() {
 			return iterateAuxiliaryDatabaseObjectsInReverse();
 		}
 
 		public ListIterator<AuxiliaryDatabaseObject> iterateAuxiliaryDatabaseObjectsInReverse() {
 			return auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 		}
 
 		public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject auxiliaryDatabaseObject) {
 			auxiliaryDatabaseObjects.add( auxiliaryDatabaseObject );
 		}
 
 		/**
 		 * Internal struct used to help track physical table names to logical table names.
 		 */
 		private class TableDescription implements Serializable {
 			final String logicalName;
 			final Table denormalizedSupertable;
 
 			TableDescription(String logicalName, Table denormalizedSupertable) {
 				this.logicalName = logicalName;
 				this.denormalizedSupertable = denormalizedSupertable;
 			}
 		}
 
 		public String getLogicalTableName(Table table) throws MappingException {
 			return getLogicalTableName( table.getQuotedSchema(), table.getCatalog(), table.getQuotedName() );
 		}
 
 		private String getLogicalTableName(String schema, String catalog, String physicalName) throws MappingException {
 			String key = buildTableNameKey( schema, catalog, physicalName );
 			TableDescription descriptor = (TableDescription) tableNameBinding.get( key );
 			if (descriptor == null) {
 				throw new MappingException( "Unable to find physical table: " + physicalName);
 			}
 			return descriptor.logicalName;
 		}
 
 		public void addTableBinding(
 				String schema,
 				String catalog,
 				String logicalName,
 				String physicalName,
 				Table denormalizedSuperTable) throws DuplicateMappingException {
 			String key = buildTableNameKey( schema, catalog, physicalName );
 			TableDescription tableDescription = new TableDescription( logicalName, denormalizedSuperTable );
 			TableDescription oldDescriptor = ( TableDescription ) tableNameBinding.put( key, tableDescription );
 			if ( oldDescriptor != null && ! oldDescriptor.logicalName.equals( logicalName ) ) {
 				//TODO possibly relax that
 				throw new DuplicateMappingException(
 						"Same physical table name [" + physicalName + "] references several logical table names: [" +
 								oldDescriptor.logicalName + "], [" + logicalName + ']',
 						"table",
 						physicalName
 				);
 			}
 		}
 
 		private String buildTableNameKey(String schema, String catalog, String finalName) {
 			StringBuffer keyBuilder = new StringBuffer();
 			if (schema != null) keyBuilder.append( schema );
 			keyBuilder.append( ".");
 			if (catalog != null) keyBuilder.append( catalog );
 			keyBuilder.append( ".");
 			keyBuilder.append( finalName );
 			return keyBuilder.toString();
 		}
 
 		/**
 		 * Internal struct used to maintain xref between physical and logical column
 		 * names for a table.  Mainly this is used to ensure that the defined
 		 * {@link NamingStrategy} is not creating duplicate column names.
 		 */
 		private class TableColumnNameBinding implements Serializable {
 			private final String tableName;
 			private Map/*<String, String>*/ logicalToPhysical = new HashMap();
 			private Map/*<String, String>*/ physicalToLogical = new HashMap();
 
 			private TableColumnNameBinding(String tableName) {
 				this.tableName = tableName;
 			}
 
 			public void addBinding(String logicalName, Column physicalColumn) {
 				bindLogicalToPhysical( logicalName, physicalColumn );
 				bindPhysicalToLogical( logicalName, physicalColumn );
 			}
 
 			private void bindLogicalToPhysical(String logicalName, Column physicalColumn) throws DuplicateMappingException {
 				final String logicalKey = logicalName.toLowerCase();
 				final String physicalName = physicalColumn.getQuotedName();
 				final String existingPhysicalName = ( String ) logicalToPhysical.put( logicalKey, physicalName );
 				if ( existingPhysicalName != null ) {
 					boolean areSamePhysicalColumn = physicalColumn.isQuoted()
 							? existingPhysicalName.equals( physicalName )
 							: existingPhysicalName.equalsIgnoreCase( physicalName );
 					if ( ! areSamePhysicalColumn ) {
 						throw new DuplicateMappingException(
 								" Table [" + tableName + "] contains logical column name [" + logicalName
 										+ "] referenced by multiple physical column names: [" + existingPhysicalName
 										+ "], [" + physicalName + "]",
 								"column-binding",
 								tableName + "." + logicalName
 						);
 					}
 				}
 			}
 
 			private void bindPhysicalToLogical(String logicalName, Column physicalColumn) throws DuplicateMappingException {
 				final String physicalName = physicalColumn.getQuotedName();
 				final String existingLogicalName = ( String ) physicalToLogical.put( physicalName, logicalName );
 				if ( existingLogicalName != null && ! existingLogicalName.equals( logicalName ) ) {
 					throw new DuplicateMappingException(
 							" Table [" + tableName + "] contains phyical column name [" + physicalName
 									+ "] represented by different logical column names: [" + existingLogicalName
 									+ "], [" + logicalName + "]",
 							"column-binding",
 							tableName + "." + physicalName
 					);
 				}
 			}
 		}
 
 		public void addColumnBinding(String logicalName, Column physicalColumn, Table table) throws DuplicateMappingException {
 			TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( table );
 			if ( binding == null ) {
 				binding = new TableColumnNameBinding( table.getName() );
 				columnNameBindingPerTable.put( table, binding );
 			}
 			binding.addBinding( logicalName, physicalColumn );
 		}
  
 		public String getPhysicalColumnName(String logicalName, Table table) throws MappingException {
 			logicalName = logicalName.toLowerCase();
 			String finalName = null;
 			Table currentTable = table;
 			do {
 				TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( currentTable );
 				if ( binding != null ) {
 					finalName = ( String ) binding.logicalToPhysical.get( logicalName );
 				}
 				String key = buildTableNameKey(
 						currentTable.getQuotedSchema(), currentTable.getCatalog(), currentTable.getQuotedName()
 				);
 				TableDescription description = ( TableDescription ) tableNameBinding.get( key );
 				if ( description != null ) {
 					currentTable = description.denormalizedSupertable;
 				}
 				else {
 					currentTable = null;
 				}
 			} while ( finalName == null && currentTable != null );
 
 			if ( finalName == null ) {
 				throw new MappingException(
 						"Unable to find column with logical name " + logicalName + " in table " + table.getName()
 				);
 			}
 			return finalName;
 		}
 
 		public String getLogicalColumnName(String physicalName, Table table) throws MappingException {
 			String logical = null;
 			Table currentTable = table;
 			TableDescription description = null;
 			do {
 				TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( currentTable );
 				if ( binding != null ) {
 					logical = ( String ) binding.physicalToLogical.get( physicalName );
 				}
 				String key = buildTableNameKey(
 						currentTable.getQuotedSchema(), currentTable.getCatalog(), currentTable.getQuotedName()
 				);
 				description = ( TableDescription ) tableNameBinding.get( key );
 				if ( description != null ) {
 					currentTable = description.denormalizedSupertable;
 				}
 				else {
 					currentTable = null;
 				}
 			}
 			while ( logical == null && currentTable != null && description != null );
 			if ( logical == null ) {
 				throw new MappingException(
 						"Unable to find logical column name from physical name "
 								+ physicalName + " in table " + table.getName()
 				);
 			}
 			return logical;
 		}
 
 		public void addSecondPass(SecondPass sp) {
 			addSecondPass( sp, false );
 		}
 
 		public void addSecondPass(SecondPass sp, boolean onTopOfTheQueue) {
 			if ( onTopOfTheQueue ) {
 				secondPasses.add( 0, sp );
 			}
 			else {
 				secondPasses.add( sp );
 			}
 		}
 
 		public void addPropertyReference(String referencedClass, String propertyName) {
 			propertyReferences.add( new PropertyReference( referencedClass, propertyName, false ) );
 		}
 
 		public void addUniquePropertyReference(String referencedClass, String propertyName) {
 			propertyReferences.add( new PropertyReference( referencedClass, propertyName, true ) );
 		}
 
 		public void addToExtendsQueue(ExtendsQueueEntry entry) {
 			extendsQueue.put( entry, null );
 		}
 
 		public DefaultIdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 			return identifierGeneratorFactory;
 		}
 
 		public void addMappedSuperclass(Class type, MappedSuperclass mappedSuperclass) {
 			mappedSuperClasses.put( type, mappedSuperclass );
 		}
 
 		public MappedSuperclass getMappedSuperclass(Class type) {
 			return mappedSuperClasses.get( type );
 		}
 
 		public ObjectNameNormalizer getObjectNameNormalizer() {
 			return normalizer;
 		}
 
 		public Properties getConfigurationProperties() {
 			return properties;
 		}
 
 
 		private Boolean useNewGeneratorMappings;
 
 		public void addDefaultGenerator(IdGenerator generator) {
 			this.addGenerator( generator );
 			defaultNamedGenerators.add( generator.getName() );
 		}
 
 		public boolean isInSecondPass() {
 			return inSecondPass;
 		}
 
 		public PropertyData getPropertyAnnotatedWithMapsId(XClass entityType, String propertyName) {
 			final Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			return map == null ? null : map.get( propertyName );
 		}
 
 		public void addPropertyAnnotatedWithMapsId(XClass entityType, PropertyData property) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithMapsId.put( entityType, map );
 			}
 			map.put( property.getProperty().getAnnotation( MapsId.class ).value(), property );
 		}
 
 		public boolean isSpecjProprietarySyntaxEnabled() {
 			return specjProprietarySyntaxEnabled;
 		}
 
 		public void addPropertyAnnotatedWithMapsIdSpecj(XClass entityType, PropertyData property, String mapsIdValue) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithMapsId.put( entityType, map );
 			}
 			map.put( mapsIdValue, property );
 		}
 
 		public PropertyData getPropertyAnnotatedWithIdAndToOne(XClass entityType, String propertyName) {
 			final Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 			return map == null ? null : map.get( propertyName );
 		}
 
 		public void addToOneAndIdProperty(XClass entityType, PropertyData property) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithIdAndToOne.put( entityType, map );
 			}
 			map.put( property.getPropertyName(), property );
 		}
 
 		@SuppressWarnings({ "UnnecessaryUnboxing" })
 		public boolean useNewGeneratorMappings() {
 			if ( useNewGeneratorMappings == null ) {
 				final String booleanName = getConfigurationProperties().getProperty( USE_NEW_ID_GENERATOR_MAPPINGS );
 				useNewGeneratorMappings = Boolean.valueOf( booleanName );
 			}
 			return useNewGeneratorMappings.booleanValue();
 		}
 
 		public IdGenerator getGenerator(String name) {
 			return getGenerator( name, null );
 		}
 
 		public IdGenerator getGenerator(String name, Map<String, IdGenerator> localGenerators) {
 			if ( localGenerators != null ) {
 				IdGenerator result = localGenerators.get( name );
 				if ( result != null ) {
 					return result;
 				}
 			}
 			return namedGenerators.get( name );
 		}
 
 		public void addGenerator(IdGenerator generator) {
 			if ( !defaultNamedGenerators.contains( generator.getName() ) ) {
 				IdGenerator old = namedGenerators.put( generator.getName(), generator );
 				if ( old != null ) {
 					log.warn( "duplicate generator name {}", old.getName() );
 				}
 			}
 		}
 
 		public void addGeneratorTable(String name, Properties params) {
 			Object old = generatorTables.put( name, params );
 			if ( old != null ) {
 				log.warn( "duplicate generator table: {}", name );
 			}
 		}
 
 		public Properties getGeneratorTableProperties(String name, Map<String, Properties> localGeneratorTables) {
 			if ( localGeneratorTables != null ) {
 				Properties result = localGeneratorTables.get( name );
 				if ( result != null ) {
 					return result;
 				}
 			}
 			return generatorTables.get( name );
 		}
 
 		public Map<String, Join> getJoins(String entityName) {
 			return joins.get( entityName );
 		}
 
 		public void addJoins(PersistentClass persistentClass, Map<String, Join> joins) {
 			Object old = Configuration.this.joins.put( persistentClass.getEntityName(), joins );
 			if ( old != null ) {
 				log.warn( "duplicate joins for class: {}", persistentClass.getEntityName() );
 			}
 		}
 
 		public AnnotatedClassType getClassType(XClass clazz) {
 			AnnotatedClassType type = classTypes.get( clazz.getName() );
 			if ( type == null ) {
 				return addClassType( clazz );
 			}
 			else {
 				return type;
 			}
 		}
 
 		//FIXME should be private but is part of the ExtendedMapping contract
 
 		public AnnotatedClassType addClassType(XClass clazz) {
 			AnnotatedClassType type;
 			if ( clazz.isAnnotationPresent( Entity.class ) ) {
 				type = AnnotatedClassType.ENTITY;
 			}
 			else if ( clazz.isAnnotationPresent( Embeddable.class ) ) {
 				type = AnnotatedClassType.EMBEDDABLE;
 			}
 			else if ( clazz.isAnnotationPresent( javax.persistence.MappedSuperclass.class ) ) {
 				type = AnnotatedClassType.EMBEDDABLE_SUPERCLASS;
 			}
 			else {
 				type = AnnotatedClassType.NONE;
 			}
 			classTypes.put( clazz.getName(), type );
 			return type;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Map<Table, List<String[]>> getTableUniqueConstraints() {
 			final Map<Table, List<String[]>> deprecatedStructure = new HashMap<Table, List<String[]>>(
 					CollectionHelper.determineProperSizing( getUniqueConstraintHoldersByTable() ),
 					CollectionHelper.LOAD_FACTOR
 			);
 			for ( Map.Entry<Table, List<UniqueConstraintHolder>> entry : getUniqueConstraintHoldersByTable().entrySet() ) {
 				List<String[]> columnsPerConstraint = new ArrayList<String[]>(
 						CollectionHelper.determineProperSizing( entry.getValue().size() )
 				);
 				deprecatedStructure.put( entry.getKey(), columnsPerConstraint );
 				for ( UniqueConstraintHolder holder : entry.getValue() ) {
 					columnsPerConstraint.add( holder.getColumns() );
 				}
 			}
 			return deprecatedStructure;
 		}
 
 		public Map<Table, List<UniqueConstraintHolder>> getUniqueConstraintHoldersByTable() {
 			return uniqueConstraintHoldersByTable;
 		}
 
 		@SuppressWarnings({ "unchecked" })
 		public void addUniqueConstraints(Table table, List uniqueConstraints) {
 			List<UniqueConstraintHolder> constraintHolders = new ArrayList<UniqueConstraintHolder>(
 					CollectionHelper.determineProperSizing( uniqueConstraints.size() )
 			);
 
 			int keyNameBase = determineCurrentNumberOfUniqueConstraintHolders( table );
 			for ( String[] columns : ( List<String[]> ) uniqueConstraints ) {
 				final String keyName = "key" + keyNameBase++;
 				constraintHolders.add(
 						new UniqueConstraintHolder().setName( keyName ).setColumns( columns )
 				);
 			}
 			addUniqueConstraintHolders( table, constraintHolders );
 		}
 
 		private int determineCurrentNumberOfUniqueConstraintHolders(Table table) {
 			List currentHolders = getUniqueConstraintHoldersByTable().get( table );
 			return currentHolders == null
 					? 0
 					: currentHolders.size();
 		}
 
 		public void addUniqueConstraintHolders(Table table, List<UniqueConstraintHolder> uniqueConstraintHolders) {
 			List<UniqueConstraintHolder> holderList = getUniqueConstraintHoldersByTable().get( table );
 			if ( holderList == null ) {
 				holderList = new ArrayList<UniqueConstraintHolder>();
 				getUniqueConstraintHoldersByTable().put( table, holderList );
 			}
 			holderList.addAll( uniqueConstraintHolders );
 		}
 
 		public void addMappedBy(String entityName, String propertyName, String inversePropertyName) {
 			mappedByResolver.put( entityName + "." + propertyName, inversePropertyName );
 		}
 
 		public String getFromMappedBy(String entityName, String propertyName) {
 			return mappedByResolver.get( entityName + "." + propertyName );
 		}
 
 		public void addPropertyReferencedAssociation(String entityName, String propertyName, String propertyRef) {
 			propertyRefResolver.put( entityName + "." + propertyName, propertyRef );
 		}
 
 		public String getPropertyReferencedAssociation(String entityName, String propertyName) {
 			return propertyRefResolver.get( entityName + "." + propertyName );
 		}
 
 		public ReflectionManager getReflectionManager() {
 			return reflectionManager;
 		}
 
 		public Map getClasses() {
 			return classes;
 		}
 
 		public void addAnyMetaDef(AnyMetaDef defAnn) throws AnnotationException {
 			if ( anyMetaDefs.containsKey( defAnn.name() ) ) {
 				throw new AnnotationException( "Two @AnyMetaDef with the same name defined: " + defAnn.name() );
 			}
 			anyMetaDefs.put( defAnn.name(), defAnn );
 		}
 
 		public AnyMetaDef getAnyMetaDef(String name) {
 			return anyMetaDefs.get( name );
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java b/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
index e2e670501c..51a7628170 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
@@ -1,825 +1,826 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.sql.Connection;
 import java.sql.Statement;
 import java.sql.Timestamp;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Version;
 import org.hibernate.bytecode.BytecodeProvider;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.util.ConfigHelper;
 
 
 /**
  * Provides access to configuration info passed in <tt>Properties</tt> objects.
  * <br><br>
  * Hibernate has two property scopes:
  * <ul>
  * <li><b>Factory-level</b> properties may be passed to the <tt>SessionFactory</tt> when it
  * instantiated. Each instance might have different property values. If no
  * properties are specified, the factory calls <tt>Environment.getProperties()</tt>.
  * <li><b>System-level</b> properties are shared by all factory instances and are always
  * determined by the <tt>Environment</tt> properties.
  * </ul>
  * The only system-level properties are
  * <ul>
  * <li><tt>hibernate.jdbc.use_streams_for_binary</tt>
  * <li><tt>hibernate.cglib.use_reflection_optimizer</tt>
  * </ul>
  * <tt>Environment</tt> properties are populated by calling <tt>System.getProperties()</tt>
  * and then from a resource named <tt>/hibernate.properties</tt> if it exists. System
  * properties override properties specified in <tt>hibernate.properties</tt>.<br>
  * <br>
  * The <tt>SessionFactory</tt> is controlled by the following properties.
  * Properties may be either be <tt>System</tt> properties, properties
  * defined in a resource named <tt>/hibernate.properties</tt> or an instance of
  * <tt>java.util.Properties</tt> passed to
  * <tt>Configuration.buildSessionFactory()</tt><br>
  * <br>
  * <table>
  * <tr><td><b>property</b></td><td><b>meaning</b></td></tr>
  * <tr>
  *   <td><tt>hibernate.dialect</tt></td>
  *   <td>classname of <tt>org.hibernate.dialect.Dialect</tt> subclass</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.cache.provider_class</tt></td>
  *   <td>classname of <tt>org.hibernate.cache.CacheProvider</tt>
  *   subclass (if not specified EHCache is used)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.provider_class</tt></td>
  *   <td>classname of <tt>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</tt>
  *   subclass (if not specified hueristics are used)</td>
  * </tr>
  * <tr><td><tt>hibernate.connection.username</tt></td><td>database username</td></tr>
  * <tr><td><tt>hibernate.connection.password</tt></td><td>database password</td></tr>
  * <tr>
  *   <td><tt>hibernate.connection.url</tt></td>
  *   <td>JDBC URL (when using <tt>java.sql.DriverManager</tt>)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.driver_class</tt></td>
  *   <td>classname of JDBC driver</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.isolation</tt></td>
  *   <td>JDBC transaction isolation level (only when using
  *     <tt>java.sql.DriverManager</tt>)
  *   </td>
  * </tr>
  *   <td><tt>hibernate.connection.pool_size</tt></td>
  *   <td>the maximum size of the connection pool (only when using
  *     <tt>java.sql.DriverManager</tt>)
  *   </td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.datasource</tt></td>
  *   <td>databasource JNDI name (when using <tt>javax.sql.Datasource</tt>)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jndi.url</tt></td><td>JNDI <tt>InitialContext</tt> URL</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jndi.class</tt></td><td>JNDI <tt>InitialContext</tt> classname</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.max_fetch_depth</tt></td>
  *   <td>maximum depth of outer join fetching</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.batch_size</tt></td>
  *   <td>enable use of JDBC2 batch API for drivers which support it</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.fetch_size</tt></td>
  *   <td>set the JDBC fetch size</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.use_scrollable_resultset</tt></td>
  *   <td>enable use of JDBC2 scrollable resultsets (you only need this specify
  *   this property when using user supplied connections)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.use_getGeneratedKeys</tt></td>
  *   <td>enable use of JDBC3 PreparedStatement.getGeneratedKeys() to retrieve
  *   natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.hbm2ddl.auto</tt></td>
  *   <td>enable auto DDL export</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.default_schema</tt></td>
  *   <td>use given schema name for unqualified tables (always optional)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.default_catalog</tt></td>
  *   <td>use given catalog name for unqualified tables (always optional)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.session_factory_name</tt></td>
  *   <td>If set, the factory attempts to bind this name to itself in the
  *   JNDI context. This name is also used to support cross JVM <tt>
  *   Session</tt> (de)serialization.</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.transaction.manager_lookup_class</tt></td>
  *   <td>classname of <tt>org.hibernate.transaction.TransactionManagerLookup</tt>
  *   implementor</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.transaction.factory_class</tt></td>
  *   <td>the factory to use for instantiating <tt>Transaction</tt>s.
- *   (Defaults to <tt>JDBCTransactionFactory</tt>.)</td>
+ *   (Defaults to <tt>JdbcTransactionFactory</tt>.)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.query.substitutions</tt></td><td>query language token substitutions</td>
  * </tr>
  * </table>
  *
  * @see org.hibernate.SessionFactory
  * @author Gavin King
  */
 public final class Environment {
 	/**
 	 * <tt>ConnectionProvider</tt> implementor to use when obtaining connections
 	 */
 	public static final String CONNECTION_PROVIDER ="hibernate.connection.provider_class";
 	/**
 	 * JDBC driver class
 	 */
 	public static final String DRIVER ="hibernate.connection.driver_class";
 	/**
 	 * JDBC transaction isolation level
 	 */
 	public static final String ISOLATION ="hibernate.connection.isolation";
 	/**
 	 * JDBC URL
 	 */
 	public static final String URL ="hibernate.connection.url";
 	/**
 	 * JDBC user
 	 */
 	public static final String USER ="hibernate.connection.username";
 	/**
 	 * JDBC password
 	 */
 	public static final String PASS ="hibernate.connection.password";
 	/**
 	 * JDBC autocommit mode
 	 */
 	public static final String AUTOCOMMIT ="hibernate.connection.autocommit";
 	/**
 	 * Maximum number of inactive connections for Hibernate's connection pool
 	 */
 	public static final String POOL_SIZE ="hibernate.connection.pool_size";
 	/**
 	 * <tt>java.sql.Datasource</tt> JNDI name
 	 */
 	public static final String DATASOURCE ="hibernate.connection.datasource";
 	/**
 	 * prefix for arbitrary JDBC connection properties
 	 */
 	public static final String CONNECTION_PREFIX = "hibernate.connection";
 
 	/**
 	 * JNDI initial context class, <tt>Context.INITIAL_CONTEXT_FACTORY</tt>
 	 */
 	public static final String JNDI_CLASS ="hibernate.jndi.class";
 	/**
 	 * JNDI provider URL, <tt>Context.PROVIDER_URL</tt>
 	 */
 	public static final String JNDI_URL ="hibernate.jndi.url";
 	/**
 	 * prefix for arbitrary JNDI <tt>InitialContext</tt> properties
 	 */
 	public static final String JNDI_PREFIX = "hibernate.jndi";
 	/**
 	 * JNDI name to bind to <tt>SessionFactory</tt>
 	 */
 	public static final String SESSION_FACTORY_NAME = "hibernate.session_factory_name";
 
 	/**
 	 * Hibernate SQL {@link org.hibernate.dialect.Dialect} class
 	 */
 	public static final String DIALECT ="hibernate.dialect";
 
 	/**
 	 * {@link org.hibernate.service.jdbc.dialect.spi.DialectResolver} classes to register with the
 	 * {@link org.hibernate.service.jdbc.dialect.spi.DialectFactory}
 	 */
 	public static final String DIALECT_RESOLVERS = "hibernate.dialect_resolvers";
 
 	/**
 	 * A default database schema (owner) name to use for unqualified tablenames
 	 */
 	public static final String DEFAULT_SCHEMA = "hibernate.default_schema";
 	/**
 	 * A default database catalog name to use for unqualified tablenames
 	 */
 	public static final String DEFAULT_CATALOG = "hibernate.default_catalog";
 
 	/**
 	 * Enable logging of generated SQL to the console
 	 */
 	public static final String SHOW_SQL ="hibernate.show_sql";
 	/**
 	 * Enable formatting of SQL logged to the console
 	 */
 	public static final String FORMAT_SQL ="hibernate.format_sql";
 	/**
 	 * Add comments to the generated SQL
 	 */
 	public static final String USE_SQL_COMMENTS ="hibernate.use_sql_comments";
 	/**
 	 * Maximum depth of outer join fetching
 	 */
 	public static final String MAX_FETCH_DEPTH = "hibernate.max_fetch_depth";
 	/**
 	 * The default batch size for batch fetching
 	 */
 	public static final String DEFAULT_BATCH_FETCH_SIZE = "hibernate.default_batch_fetch_size";
 	/**
 	 * Use <tt>java.io</tt> streams to read / write binary data from / to JDBC
 	 */
 	public static final String USE_STREAMS_FOR_BINARY = "hibernate.jdbc.use_streams_for_binary";
 	/**
 	 * Use JDBC scrollable <tt>ResultSet</tt>s. This property is only necessary when there is
 	 * no <tt>ConnectionProvider</tt>, ie. the user is supplying JDBC connections.
 	 */
 	public static final String USE_SCROLLABLE_RESULTSET = "hibernate.jdbc.use_scrollable_resultset";
 	/**
 	 * Tells the JDBC driver to attempt to retrieve row Id with the JDBC 3.0 PreparedStatement.getGeneratedKeys()
 	 * method. In general, performance will be better if this property is set to true and the underlying
 	 * JDBC driver supports getGeneratedKeys().
 	 */
 	public static final String USE_GET_GENERATED_KEYS = "hibernate.jdbc.use_get_generated_keys";
 	/**
 	 * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database
 	 * when more rows are needed. If <tt>0</tt>, JDBC driver default settings will be used.
 	 */
 	public static final String STATEMENT_FETCH_SIZE = "hibernate.jdbc.fetch_size";
 	/**
 	 * Maximum JDBC batch size. A nonzero value enables batch updates.
 	 */
 	public static final String STATEMENT_BATCH_SIZE = "hibernate.jdbc.batch_size";
 	/**
 	 * Select a custom batcher.
 	 */
 	public static final String BATCH_STRATEGY = "hibernate.jdbc.factory_class";
 	/**
 	 * Should versioned data be included in batching?
 	 */
 	public static final String BATCH_VERSIONED_DATA = "hibernate.jdbc.batch_versioned_data";
 	/**
 	 * An XSLT resource used to generate "custom" XML
 	 */
 	public static final String OUTPUT_STYLESHEET ="hibernate.xml.output_stylesheet";
 
 	/**
 	 * Maximum size of C3P0 connection pool
 	 */
 	public static final String C3P0_MAX_SIZE = "hibernate.c3p0.max_size";
 	/**
 	 * Minimum size of C3P0 connection pool
 	 */
 	public static final String C3P0_MIN_SIZE = "hibernate.c3p0.min_size";
 
 	/**
 	 * Maximum idle time for C3P0 connection pool
 	 */
 	public static final String C3P0_TIMEOUT = "hibernate.c3p0.timeout";
 	/**
 	 * Maximum size of C3P0 statement cache
 	 */
 	public static final String C3P0_MAX_STATEMENTS = "hibernate.c3p0.max_statements";
 	/**
 	 * Number of connections acquired when pool is exhausted
 	 */
 	public static final String C3P0_ACQUIRE_INCREMENT = "hibernate.c3p0.acquire_increment";
 	/**
 	 * Idle time before a C3P0 pooled connection is validated
 	 */
 	public static final String C3P0_IDLE_TEST_PERIOD = "hibernate.c3p0.idle_test_period";
 
 	/**
 	 * Proxool/Hibernate property prefix
 	 */
 	public static final String PROXOOL_PREFIX = "hibernate.proxool";
 	/**
 	 * Proxool property to configure the Proxool Provider using an XML (<tt>/path/to/file.xml</tt>)
 	 */
 	public static final String PROXOOL_XML = "hibernate.proxool.xml";
 	/**
 	 * Proxool property to configure the Proxool Provider  using a properties file (<tt>/path/to/proxool.properties</tt>)
 	 */
 	public static final String PROXOOL_PROPERTIES = "hibernate.proxool.properties";
 	/**
 	 * Proxool property to configure the Proxool Provider from an already existing pool (<tt>true</tt> / <tt>false</tt>)
 	 */
 	public static final String PROXOOL_EXISTING_POOL = "hibernate.proxool.existing_pool";
 	/**
 	 * Proxool property with the Proxool pool alias to use
 	 * (Required for <tt>PROXOOL_EXISTING_POOL</tt>, <tt>PROXOOL_PROPERTIES</tt>, or
 	 * <tt>PROXOOL_XML</tt>)
 	 */
 	public static final String PROXOOL_POOL_ALIAS = "hibernate.proxool.pool_alias";
 
 	/**
 	 * Enable automatic session close at end of transaction
 	 */
 	public static final String AUTO_CLOSE_SESSION = "hibernate.transaction.auto_close_session";
 	/**
 	 * Enable automatic flush during the JTA <tt>beforeCompletion()</tt> callback
 	 */
 	public static final String FLUSH_BEFORE_COMPLETION = "hibernate.transaction.flush_before_completion";
 	/**
 	 * Specifies how Hibernate should release JDBC connections.
 	 */
 	public static final String RELEASE_CONNECTIONS = "hibernate.connection.release_mode";
 	/**
 	 * Context scoping impl for {@link org.hibernate.SessionFactory#getCurrentSession()} processing.
 	 */
 	public static final String CURRENT_SESSION_CONTEXT_CLASS = "hibernate.current_session_context_class";
 	/**
-	 * <tt>TransactionFactory</tt> implementor to use for creating <tt>Transaction</tt>s
+	 * Names the implementation of {@link org.hibernate.engine.transaction.spi.TransactionContext} to use for
+	 * creating {@link org.hibernate.Transaction} instances
 	 */
 	public static final String TRANSACTION_STRATEGY = "hibernate.transaction.factory_class";
 	/**
 	 * <tt>TransactionManagerLookup</tt> implementor to use for obtaining the <tt>TransactionManager</tt>
 	 */
 	public static final String TRANSACTION_MANAGER_STRATEGY = "hibernate.transaction.manager_lookup_class";
 	/**
 	 * JNDI name of JTA <tt>UserTransaction</tt> object
 	 */
 	public static final String USER_TRANSACTION = "jta.UserTransaction";
 
 	/**
 	 * The <tt>CacheProvider</tt> implementation class
 	 */
 	public static final String CACHE_PROVIDER = "hibernate.cache.provider_class";
 
 	/**
 	 * The {@link org.hibernate.cache.RegionFactory} implementation class
 	 */
 	public static final String CACHE_REGION_FACTORY = "hibernate.cache.region.factory_class";
 
 	/**
 	 * The <tt>CacheProvider</tt> implementation class
 	 */
 	public static final String CACHE_PROVIDER_CONFIG = "hibernate.cache.provider_configuration_file_resource_path";
 	/**
 	 * The <tt>CacheProvider</tt> JNDI namespace, if pre-bound to JNDI.
 	 */
 	public static final String CACHE_NAMESPACE = "hibernate.cache.jndi";
 	/**
 	 * Enable the query cache (disabled by default)
 	 */
 	public static final String USE_QUERY_CACHE = "hibernate.cache.use_query_cache";
 	/**
 	 * The <tt>QueryCacheFactory</tt> implementation class.
 	 */
 	public static final String QUERY_CACHE_FACTORY = "hibernate.cache.query_cache_factory";
 	/**
 	 * Enable the second-level cache (enabled by default)
 	 */
 	public static final String USE_SECOND_LEVEL_CACHE = "hibernate.cache.use_second_level_cache";
 	/**
 	 * Optimize the cache for minimal puts instead of minimal gets
 	 */
 	public static final String USE_MINIMAL_PUTS = "hibernate.cache.use_minimal_puts";
 	/**
 	 * The <tt>CacheProvider</tt> region name prefix
 	 */
 	public static final String CACHE_REGION_PREFIX = "hibernate.cache.region_prefix";
 	/**
 	 * Enable use of structured second-level cache entries
 	 */
 	public static final String USE_STRUCTURED_CACHE = "hibernate.cache.use_structured_entries";
 
 	/**
 	 * Enable statistics collection
 	 */
 	public static final String GENERATE_STATISTICS = "hibernate.generate_statistics";
 
 	public static final String USE_IDENTIFIER_ROLLBACK = "hibernate.use_identifier_rollback";
 
 	/**
 	 * Use bytecode libraries optimized property access
 	 */
 	public static final String USE_REFLECTION_OPTIMIZER = "hibernate.bytecode.use_reflection_optimizer";
 
 	/**
 	 * The classname of the HQL query parser factory
 	 */
 	public static final String QUERY_TRANSLATOR = "hibernate.query.factory_class";
 
 	/**
 	 * A comma-separated list of token substitutions to use when translating a Hibernate
 	 * query to SQL
 	 */
 	public static final String QUERY_SUBSTITUTIONS = "hibernate.query.substitutions";
 
 	/**
 	 * Should named queries be checked during startup (the default is enabled).
 	 * <p/>
 	 * Mainly intended for test environments.
 	 */
 	public static final String QUERY_STARTUP_CHECKING = "hibernate.query.startup_check";
 
 	/**
 	 * Auto export/update schema using hbm2ddl tool. Valid values are <tt>update</tt>,
 	 * <tt>create</tt>, <tt>create-drop</tt> and <tt>validate</tt>.
 	 */
 	public static final String HBM2DDL_AUTO = "hibernate.hbm2ddl.auto";
 
 	/**
 	 * Comma-separated names of the optional files containing SQL DML statements executed
 	 * during the SessionFactory creation.
 	 * File order matters, the statements of a give file are executed before the statements of the
 	 * following files.
 	 *
 	 * These statements are only executed if the schema is created ie if <tt>hibernate.hbm2ddl.auto</tt>
 	 * is set to <tt>create</tt> or <tt>create-drop</tt>.
 	 *
 	 * The default value is <tt>/import.sql</tt>
 	 */
 	public static final String HBM2DDL_IMPORT_FILES = "hibernate.hbm2ddl.import_files";
 
 	/**
 	 * The {@link org.hibernate.exception.SQLExceptionConverter} to use for converting SQLExceptions
 	 * to Hibernate's JDBCException hierarchy.  The default is to use the configured
 	 * {@link org.hibernate.dialect.Dialect}'s preferred SQLExceptionConverter.
 	 */
 	public static final String SQL_EXCEPTION_CONVERTER = "hibernate.jdbc.sql_exception_converter";
 
 	/**
 	 * Enable wrapping of JDBC result sets in order to speed up column name lookups for
 	 * broken JDBC drivers
 	 */
 	public static final String WRAP_RESULT_SETS = "hibernate.jdbc.wrap_result_sets";
 
 	/**
 	 * Enable ordering of update statements by primary key value
 	 */
 	public static final String ORDER_UPDATES = "hibernate.order_updates";
 
 	/**
 	 * Enable ordering of insert statements for the purpose of more efficient JDBC batching.
 	 */
 	public static final String ORDER_INSERTS = "hibernate.order_inserts";
 
 	/**
 	 * The EntityMode in which set the Session opened from the SessionFactory.
 	 */
     public static final String DEFAULT_ENTITY_MODE = "hibernate.default_entity_mode";
 
     /**
      * The jacc context id of the deployment
      */
     public static final String JACC_CONTEXTID = "hibernate.jacc_context_id";
 
 	/**
 	 * Should all database identifiers be quoted.
 	 */
 	public static final String GLOBALLY_QUOTED_IDENTIFIERS = "hibernate.globally_quoted_identifiers";
 
 	/**
 	 * Enable nullability checking.
 	 * Raises an exception if a property marked as not-null is null.
 	 * Default to false if Bean Validation is present in the classpath and Hibernate Annotations is used,
 	 * true otherwise.
 	 */
 	public static final String CHECK_NULLABILITY = "hibernate.check_nullability";
 
 
 	public static final String BYTECODE_PROVIDER = "hibernate.bytecode.provider";
 
 	public static final String JPAQL_STRICT_COMPLIANCE= "hibernate.query.jpaql_strict_compliance";
 
 	/**
 	 * When using pooled {@link org.hibernate.id.enhanced.Optimizer optimizers}, prefer interpreting the 
 	 * database value as the lower (lo) boundary.  The default is to interpret it as the high boundary.
 	 */
 	public static final String PREFER_POOLED_VALUES_LO = "hibernate.id.optimizer.pooled.prefer_lo";
 
 	/**
 	 * The maximum number of strong references maintained by {@link org.hibernate.util.SoftLimitMRUCache}. Default is 128.
 	 */
 	public static final String QUERY_PLAN_CACHE_MAX_STRONG_REFERENCES = "hibernate.query.plan_cache_max_strong_references";
 
 	/**
 	 * The maximum number of soft references maintained by {@link org.hibernate.util.SoftLimitMRUCache}. Default is 2048.
 	 */
 	public static final String QUERY_PLAN_CACHE_MAX_SOFT_REFERENCES = "hibernate.query.plan_cache_max_soft_references";
 
 	/**
 	 * Should we not use contextual LOB creation (aka based on {@link java.sql.Connection#createBlob()} et al).
 	 */
 	public static final String NON_CONTEXTUAL_LOB_CREATION = "hibernate.jdbc.lob.non_contextual_creation";
 
 
 	private static final BytecodeProvider BYTECODE_PROVIDER_INSTANCE;
 	private static final boolean ENABLE_BINARY_STREAMS;
 	private static final boolean ENABLE_REFLECTION_OPTIMIZER;
 	private static final boolean JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
 	private static final boolean JVM_HAS_TIMESTAMP_BUG;
 	private static final boolean JVM_HAS_JDK14_TIMESTAMP;
 	private static final boolean JVM_SUPPORTS_GET_GENERATED_KEYS;
 
 	private static final Properties GLOBAL_PROPERTIES;
 	private static final HashMap ISOLATION_LEVELS = new HashMap();
 	private static final Map OBSOLETE_PROPERTIES = new HashMap();
 	private static final Map RENAMED_PROPERTIES = new HashMap();
 
 	private static final Logger log = LoggerFactory.getLogger(Environment.class);
 
 	/**
 	 * Issues warnings to the user when any obsolete or renamed property names are used.
 	 *
 	 * @param props The specified properties.
 	 */
 	public static void verifyProperties(Properties props) {
 		Iterator iter = props.keySet().iterator();
 		Map propertiesToAdd = new HashMap();
 		while ( iter.hasNext() ) {
 			final Object propertyName = iter.next();
 			Object newPropertyName = OBSOLETE_PROPERTIES.get( propertyName );
 			if ( newPropertyName != null ) {
 				log.warn( "Usage of obsolete property: " + propertyName + " no longer supported, use: " + newPropertyName );
 			}
 			newPropertyName = RENAMED_PROPERTIES.get( propertyName );
 			if ( newPropertyName != null ) {
 				log.warn( "Property [" + propertyName + "] has been renamed to [" + newPropertyName + "]; update your properties appropriately" );
 				if ( ! props.containsKey( newPropertyName ) ) {
 					propertiesToAdd.put( newPropertyName, props.get( propertyName ) );
 				}
 			}
 		}
 		props.putAll(propertiesToAdd);
 	}
 
 	static {
 
 		log.info( "Hibernate " + Version.getVersionString() );
 
 		RENAMED_PROPERTIES.put( "hibernate.cglib.use_reflection_optimizer", USE_REFLECTION_OPTIMIZER );
 
 		ISOLATION_LEVELS.put( new Integer(Connection.TRANSACTION_NONE), "NONE" );
 		ISOLATION_LEVELS.put( new Integer(Connection.TRANSACTION_READ_UNCOMMITTED), "READ_UNCOMMITTED" );
 		ISOLATION_LEVELS.put( new Integer(Connection.TRANSACTION_READ_COMMITTED), "READ_COMMITTED" );
 		ISOLATION_LEVELS.put( new Integer(Connection.TRANSACTION_REPEATABLE_READ), "REPEATABLE_READ" );
 		ISOLATION_LEVELS.put( new Integer(Connection.TRANSACTION_SERIALIZABLE), "SERIALIZABLE" );
 
 		GLOBAL_PROPERTIES = new Properties();
 		//Set USE_REFLECTION_OPTIMIZER to false to fix HHH-227
 		GLOBAL_PROPERTIES.setProperty( USE_REFLECTION_OPTIMIZER, Boolean.FALSE.toString() );
 
 		try {
 			InputStream stream = ConfigHelper.getResourceAsStream("/hibernate.properties");
 			try {
 				GLOBAL_PROPERTIES.load(stream);
 				log.info( "loaded properties from resource hibernate.properties: " + ConfigurationHelper.maskOut(GLOBAL_PROPERTIES, PASS) );
 			}
 			catch (Exception e) {
 				log.error("problem loading properties from hibernate.properties");
 			}
 			finally {
 				try{
 					stream.close();
 				}
 				catch (IOException ioe){
 					log.error("could not close stream on hibernate.properties", ioe);
 				}
 			}
 		}
 		catch (HibernateException he) {
 			log.info("hibernate.properties not found");
 		}
 
 		try {
 			GLOBAL_PROPERTIES.putAll( System.getProperties() );
 		}
 		catch (SecurityException se) {
 			log.warn("could not copy system properties, system properties will be ignored");
 		}
 
 		verifyProperties(GLOBAL_PROPERTIES);
 
 		ENABLE_BINARY_STREAMS = ConfigurationHelper.getBoolean(USE_STREAMS_FOR_BINARY, GLOBAL_PROPERTIES);
 		ENABLE_REFLECTION_OPTIMIZER = ConfigurationHelper.getBoolean(USE_REFLECTION_OPTIMIZER, GLOBAL_PROPERTIES);
 
 		if (ENABLE_BINARY_STREAMS) {
 			log.info("using java.io streams to persist binary types");
 		}
 		if (ENABLE_REFLECTION_OPTIMIZER) {
 			log.info("using bytecode reflection optimizer");
 		}
 		BYTECODE_PROVIDER_INSTANCE = buildBytecodeProvider( GLOBAL_PROPERTIES );
 
 		boolean getGeneratedKeysSupport;
 		try {
 			Statement.class.getMethod("getGeneratedKeys", (Class[])null);
 			getGeneratedKeysSupport = true;
 		}
 		catch (NoSuchMethodException nsme) {
 			getGeneratedKeysSupport = false;
 		}
 		JVM_SUPPORTS_GET_GENERATED_KEYS = getGeneratedKeysSupport;
 		if (!JVM_SUPPORTS_GET_GENERATED_KEYS) {
 			log.info("JVM does not support Statement.getGeneratedKeys()");
 		}
 
 		boolean linkedHashSupport;
 		try {
 			Class.forName("java.util.LinkedHashSet");
 			linkedHashSupport = true;
 		}
 		catch (ClassNotFoundException cnfe) {
 			linkedHashSupport = false;
 		}
 		JVM_SUPPORTS_LINKED_HASH_COLLECTIONS = linkedHashSupport;
 		if (!JVM_SUPPORTS_LINKED_HASH_COLLECTIONS) {
 			log.info("JVM does not support LinkedHasMap, LinkedHashSet - ordered maps and sets disabled");
 		}
 
 		long x = 123456789;
 		JVM_HAS_TIMESTAMP_BUG = new Timestamp(x).getTime() != x;
 		if (JVM_HAS_TIMESTAMP_BUG) {
 			log.info("using workaround for JVM bug in java.sql.Timestamp");
 		}
 
 		Timestamp t = new Timestamp(0);
 		t.setNanos(5 * 1000000);
 		JVM_HAS_JDK14_TIMESTAMP = t.getTime() == 5;
 		if (JVM_HAS_JDK14_TIMESTAMP) {
 			log.info("using JDK 1.4 java.sql.Timestamp handling");
 		}
 		else {
 			log.info("using pre JDK 1.4 java.sql.Timestamp handling");
 		}
 	}
 
 	public static BytecodeProvider getBytecodeProvider() {
 		return BYTECODE_PROVIDER_INSTANCE;
 	}
 
 	/**
 	 * Does this JVM's implementation of {@link java.sql.Timestamp} have a bug in which the following is true:<code>
 	 * new java.sql.Timestamp( x ).getTime() != x
 	 * </code>
 	 * <p/>
 	 * NOTE : IBM JDK 1.3.1 the only known JVM to exhibit this behavior.
 	 *
 	 * @return True if the JVM's {@link Timestamp} implementa
 	 */
 	public static boolean jvmHasTimestampBug() {
 		return JVM_HAS_TIMESTAMP_BUG;
 	}
 
 	/**
 	 * Does this JVM handle {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 	 *
 	 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 	 *
 	 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 	 */
 	public static boolean jvmHasJDK14Timestamp() {
 		return JVM_HAS_JDK14_TIMESTAMP;
 	}
 
 	/**
 	 * Does this JVM support {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}?
 	 * <p/>
 	 * Note, this is true for JDK 1.4 and above; hence the deprecation.
 	 *
 	 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 	 *
 	 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 	 * @see java.util.LinkedHashSet
 	 * @see java.util.LinkedHashMap
 	 */
 	public static boolean jvmSupportsLinkedHashCollections() {
 		return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
 	}
 
 	/**
 	 * Does this JDK/JVM define the JDBC {@link Statement} interface with a 'getGeneratedKeys' method?
 	 * <p/>
 	 * Note, this is true for JDK 1.4 and above; hence the deprecation.
 	 *
 	 * @return True if generated keys can be retrieved via Statement; false otherwise.
 	 *
 	 * @see Statement
 	 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 	 */
 	public static boolean jvmSupportsGetGeneratedKeys() {
 		return JVM_SUPPORTS_GET_GENERATED_KEYS;
 	}
 
 	/**
 	 * Should we use streams to bind binary types to JDBC IN parameters?
 	 *
 	 * @return True if streams should be used for binary data handling; false otherwise.
 	 *
 	 * @see #USE_STREAMS_FOR_BINARY
 	 */
 	public static boolean useStreamsForBinary() {
 		return ENABLE_BINARY_STREAMS;
 	}
 
 	/**
 	 * Should we use reflection optimization?
 	 *
 	 * @return True if reflection optimization should be used; false otherwise.
 	 *
 	 * @see #USE_REFLECTION_OPTIMIZER
 	 * @see #getBytecodeProvider()
 	 * @see BytecodeProvider#getReflectionOptimizer
 	 */
 	public static boolean useReflectionOptimizer() {
 		return ENABLE_REFLECTION_OPTIMIZER;
 	}
 
 	/**
 	 * Disallow instantiation
 	 */
 	private Environment() {
 		throw new UnsupportedOperationException();
 	}
 
 	/**
 	 * Return <tt>System</tt> properties, extended by any properties specified
 	 * in <tt>hibernate.properties</tt>.
 	 * @return Properties
 	 */
 	public static Properties getProperties() {
 		Properties copy = new Properties();
 		copy.putAll(GLOBAL_PROPERTIES);
 		return copy;
 	}
 
 	/**
 	 * Get the name of a JDBC transaction isolation level
 	 *
 	 * @see java.sql.Connection
 	 * @param isolation as defined by <tt>java.sql.Connection</tt>
 	 * @return a human-readable name
 	 */
 	public static String isolationLevelToString(int isolation) {
 		return (String) ISOLATION_LEVELS.get( new Integer(isolation) );
 	}
 
 	public static BytecodeProvider buildBytecodeProvider(Properties properties) {
 		String provider = ConfigurationHelper.getString( BYTECODE_PROVIDER, properties, "javassist" );
 		log.info( "Bytecode provider name : " + provider );
 		return buildBytecodeProvider( provider );
 	}
 
 	private static BytecodeProvider buildBytecodeProvider(String providerName) {
 		if ( "javassist".equals( providerName ) ) {
 			return new org.hibernate.bytecode.javassist.BytecodeProviderImpl();
 		}
 		else if ( "cglib".equals( providerName ) ) {
 			return new org.hibernate.bytecode.cglib.BytecodeProviderImpl();
 		}
 
 		log.warn( "unrecognized bytecode provider [" + providerName + "], using javassist by default" );
 		return new org.hibernate.bytecode.javassist.BytecodeProviderImpl();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
index 5e8056a6b5..fbc5e31eac 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
@@ -1,499 +1,481 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
-import java.util.Map;
-
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.cache.QueryCacheFactory;
 import org.hibernate.cache.RegionFactory;
 import org.hibernate.engine.jdbc.JdbcSupport;
-import org.hibernate.engine.jdbc.batch.internal.BatchBuilder;
 import org.hibernate.hql.QueryTranslatorFactory;
 import org.hibernate.jdbc.util.SQLStatementLogger;
-import org.hibernate.transaction.TransactionFactory;
-import org.hibernate.transaction.TransactionManagerLookup;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 
+import java.util.Map;
+
 /**
  * Settings that affect the behaviour of Hibernate at runtime.
  *
  * @author Gavin King
  */
 public final class Settings {
 
 //	private boolean showSql;
 //	private boolean formatSql;
 	private SQLStatementLogger sqlStatementLogger;
 	private Integer maximumFetchDepth;
 	private Map querySubstitutions;
 	private int jdbcBatchSize;
 	private int defaultBatchFetchSize;
 	private boolean scrollableResultSetsEnabled;
 	private boolean getGeneratedKeysEnabled;
 	private String defaultSchemaName;
 	private String defaultCatalogName;
 	private Integer jdbcFetchSize;
 	private String sessionFactoryName;
 	private boolean autoCreateSchema;
 	private boolean autoDropSchema;
 	private boolean autoUpdateSchema;
 	private boolean autoValidateSchema;
 	private boolean queryCacheEnabled;
 	private boolean structuredCacheEntriesEnabled;
 	private boolean secondLevelCacheEnabled;
 	private String cacheRegionPrefix;
 	private boolean minimalPutsEnabled;
 	private boolean commentsEnabled;
 	private boolean statisticsEnabled;
 	private boolean jdbcBatchVersionedData;
 	private boolean identifierRollbackEnabled;
 	private boolean flushBeforeCompletionEnabled;
 	private boolean autoCloseSessionEnabled;
 	private ConnectionReleaseMode connectionReleaseMode;
 	private RegionFactory regionFactory;
 	private QueryCacheFactory queryCacheFactory;
-	private TransactionFactory transactionFactory;
-	private TransactionManagerLookup transactionManagerLookup;
-	private BatchBuilder batchBuilder;
 	private QueryTranslatorFactory queryTranslatorFactory;
 	private boolean wrapResultSetsEnabled;
 	private boolean orderUpdatesEnabled;
 	private boolean orderInsertsEnabled;
 	private EntityMode defaultEntityMode;
 	private boolean dataDefinitionImplicitCommit;
 	private boolean dataDefinitionInTransactionSupported;
 	private boolean strictJPAQLCompliance;
 	private boolean namedQueryStartupCheckingEnabled;
 	private EntityTuplizerFactory entityTuplizerFactory;
 	private boolean checkNullability;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 //	private BytecodeProvider bytecodeProvider;
 	private JdbcSupport jdbcSupport;
 	private String importFiles;
 
+	private JtaPlatform jtaPlatform;
+
 	/**
 	 * Package protected constructor
 	 */
 	Settings() {
 	}
 
 	// public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 //	public boolean isShowSqlEnabled() {
 //		return showSql;
 //	}
 //
 //	public boolean isFormatSqlEnabled() {
 //		return formatSql;
 //	}
 
 	public String getImportFiles() {
 		return importFiles;
 	}
 
 	public void setImportFiles(String importFiles) {
 		this.importFiles = importFiles;
 	}
 
 	public SQLStatementLogger getSqlStatementLogger() {
 		return sqlStatementLogger;
 	}
 
 	public String getDefaultSchemaName() {
 		return defaultSchemaName;
 	}
 
 	public String getDefaultCatalogName() {
 		return defaultCatalogName;
 	}
 
 	public int getJdbcBatchSize() {
 		return jdbcBatchSize;
 	}
 
 	public int getDefaultBatchFetchSize() {
 		return defaultBatchFetchSize;
 	}
 
 	public Map getQuerySubstitutions() {
 		return querySubstitutions;
 	}
 
 	public boolean isIdentifierRollbackEnabled() {
 		return identifierRollbackEnabled;
 	}
 
 	public boolean isScrollableResultSetsEnabled() {
 		return scrollableResultSetsEnabled;
 	}
 
 	public boolean isGetGeneratedKeysEnabled() {
 		return getGeneratedKeysEnabled;
 	}
 
 	public boolean isMinimalPutsEnabled() {
 		return minimalPutsEnabled;
 	}
 
 	public Integer getJdbcFetchSize() {
 		return jdbcFetchSize;
 	}
 
-	public TransactionFactory getTransactionFactory() {
-		return transactionFactory;
-	}
-
 	public String getSessionFactoryName() {
 		return sessionFactoryName;
 	}
 
 	public boolean isAutoCreateSchema() {
 		return autoCreateSchema;
 	}
 
 	public boolean isAutoDropSchema() {
 		return autoDropSchema;
 	}
 
 	public boolean isAutoUpdateSchema() {
 		return autoUpdateSchema;
 	}
 
 	public Integer getMaximumFetchDepth() {
 		return maximumFetchDepth;
 	}
 
 	public RegionFactory getRegionFactory() {
 		return regionFactory;
 	}
 
-	public TransactionManagerLookup getTransactionManagerLookup() {
-		return transactionManagerLookup;
-	}
-
 	public boolean isQueryCacheEnabled() {
 		return queryCacheEnabled;
 	}
 
 	public boolean isCommentsEnabled() {
 		return commentsEnabled;
 	}
 
 	public boolean isSecondLevelCacheEnabled() {
 		return secondLevelCacheEnabled;
 	}
 
 	public String getCacheRegionPrefix() {
 		return cacheRegionPrefix;
 	}
 
 	public QueryCacheFactory getQueryCacheFactory() {
 		return queryCacheFactory;
 	}
 
 	public boolean isStatisticsEnabled() {
 		return statisticsEnabled;
 	}
 
 	public boolean isJdbcBatchVersionedData() {
 		return jdbcBatchVersionedData;
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
-	public BatchBuilder getBatchBuilder() {
-		return batchBuilder;
-	}
-
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return connectionReleaseMode;
 	}
 
 	public QueryTranslatorFactory getQueryTranslatorFactory() {
 		return queryTranslatorFactory;
 	}
 
 	public boolean isWrapResultSetsEnabled() {
 		return wrapResultSetsEnabled;
 	}
 
 	public boolean isOrderUpdatesEnabled() {
 		return orderUpdatesEnabled;
 	}
 
 	public boolean isOrderInsertsEnabled() {
 		return orderInsertsEnabled;
 	}
 
 	public boolean isStructuredCacheEntriesEnabled() {
 		return structuredCacheEntriesEnabled;
 	}
 
 	public EntityMode getDefaultEntityMode() {
 		return defaultEntityMode;
 	}
 
 	public boolean isAutoValidateSchema() {
 		return autoValidateSchema;
 	}
 
 	public boolean isDataDefinitionImplicitCommit() {
 		return dataDefinitionImplicitCommit;
 	}
 
 	public boolean isDataDefinitionInTransactionSupported() {
 		return dataDefinitionInTransactionSupported;
 	}
 
 	public boolean isStrictJPAQLCompliance() {
 		return strictJPAQLCompliance;
 	}
 
 	public boolean isNamedQueryStartupCheckingEnabled() {
 		return namedQueryStartupCheckingEnabled;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	public JdbcSupport getJdbcSupport() {
 		return jdbcSupport;
 	}
 
 
 	// package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 //	void setShowSqlEnabled(boolean b) {
 //		showSql = b;
 //	}
 //
 //	void setFormatSqlEnabled(boolean b) {
 //		formatSql = b;
 //	}
 
 	void setSqlStatementLogger(SQLStatementLogger sqlStatementLogger) {
 		this.sqlStatementLogger = sqlStatementLogger;
 	}
 
 	void setDefaultSchemaName(String string) {
 		defaultSchemaName = string;
 	}
 
 	void setDefaultCatalogName(String string) {
 		defaultCatalogName = string;
 	}
 
 	void setJdbcBatchSize(int i) {
 		jdbcBatchSize = i;
 	}
 
 	void setDefaultBatchFetchSize(int i) {
 		defaultBatchFetchSize = i;
 	}
 
 	void setQuerySubstitutions(Map map) {
 		querySubstitutions = map;
 	}
 
 	void setIdentifierRollbackEnabled(boolean b) {
 		identifierRollbackEnabled = b;
 	}
 
 	void setMinimalPutsEnabled(boolean b) {
 		minimalPutsEnabled = b;
 	}
 
 	void setScrollableResultSetsEnabled(boolean b) {
 		scrollableResultSetsEnabled = b;
 	}
 
 	void setGetGeneratedKeysEnabled(boolean b) {
 		getGeneratedKeysEnabled = b;
 	}
 
 	void setJdbcFetchSize(Integer integer) {
 		jdbcFetchSize = integer;
 	}
 
-	void setTransactionFactory(TransactionFactory factory) {
-		transactionFactory = factory;
-	}
-
 	void setSessionFactoryName(String string) {
 		sessionFactoryName = string;
 	}
 
 	void setAutoCreateSchema(boolean b) {
 		autoCreateSchema = b;
 	}
 
 	void setAutoDropSchema(boolean b) {
 		autoDropSchema = b;
 	}
 
 	void setAutoUpdateSchema(boolean b) {
 		autoUpdateSchema = b;
 	}
 
 	void setMaximumFetchDepth(Integer i) {
 		maximumFetchDepth = i;
 	}
 
 	void setRegionFactory(RegionFactory regionFactory) {
 		this.regionFactory = regionFactory;
 	}
 
-	void setTransactionManagerLookup(TransactionManagerLookup lookup) {
-		transactionManagerLookup = lookup;
-	}
-
 	void setQueryCacheEnabled(boolean b) {
 		queryCacheEnabled = b;
 	}
 
 	void setCommentsEnabled(boolean commentsEnabled) {
 		this.commentsEnabled = commentsEnabled;
 	}
 
 	void setSecondLevelCacheEnabled(boolean secondLevelCacheEnabled) {
 		this.secondLevelCacheEnabled = secondLevelCacheEnabled;
 	}
 
 	void setCacheRegionPrefix(String cacheRegionPrefix) {
 		this.cacheRegionPrefix = cacheRegionPrefix;
 	}
 
 	void setQueryCacheFactory(QueryCacheFactory queryCacheFactory) {
 		this.queryCacheFactory = queryCacheFactory;
 	}
 
 	void setStatisticsEnabled(boolean statisticsEnabled) {
 		this.statisticsEnabled = statisticsEnabled;
 	}
 
 	void setJdbcBatchVersionedData(boolean jdbcBatchVersionedData) {
 		this.jdbcBatchVersionedData = jdbcBatchVersionedData;
 	}
 
 	void setFlushBeforeCompletionEnabled(boolean flushBeforeCompletionEnabled) {
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 	}
 
-	void setBatcherBuilder(BatchBuilder batchBuilder) {
-		this.batchBuilder = batchBuilder;
-	}
-
 	void setAutoCloseSessionEnabled(boolean autoCloseSessionEnabled) {
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 	}
 
 	void setConnectionReleaseMode(ConnectionReleaseMode connectionReleaseMode) {
 		this.connectionReleaseMode = connectionReleaseMode;
 	}
 
 	void setQueryTranslatorFactory(QueryTranslatorFactory queryTranslatorFactory) {
 		this.queryTranslatorFactory = queryTranslatorFactory;
 	}
 
 	void setWrapResultSetsEnabled(boolean wrapResultSetsEnabled) {
 		this.wrapResultSetsEnabled = wrapResultSetsEnabled;
 	}
 
 	void setOrderUpdatesEnabled(boolean orderUpdatesEnabled) {
 		this.orderUpdatesEnabled = orderUpdatesEnabled;
 	}
 
 	void setOrderInsertsEnabled(boolean orderInsertsEnabled) {
 		this.orderInsertsEnabled = orderInsertsEnabled;
 	}
 
 	void setStructuredCacheEntriesEnabled(boolean structuredCacheEntriesEnabled) {
 		this.structuredCacheEntriesEnabled = structuredCacheEntriesEnabled;
 	}
 
 	void setDefaultEntityMode(EntityMode defaultEntityMode) {
 		this.defaultEntityMode = defaultEntityMode;
 	}
 
 	void setAutoValidateSchema(boolean autoValidateSchema) {
 		this.autoValidateSchema = autoValidateSchema;
 	}
 
 	void setDataDefinitionImplicitCommit(boolean dataDefinitionImplicitCommit) {
 		this.dataDefinitionImplicitCommit = dataDefinitionImplicitCommit;
 	}
 
 	void setDataDefinitionInTransactionSupported(boolean dataDefinitionInTransactionSupported) {
 		this.dataDefinitionInTransactionSupported = dataDefinitionInTransactionSupported;
 	}
 
 	void setStrictJPAQLCompliance(boolean strictJPAQLCompliance) {
 		this.strictJPAQLCompliance = strictJPAQLCompliance;
 	}
 
 	void setNamedQueryStartupCheckingEnabled(boolean namedQueryStartupCheckingEnabled) {
 		this.namedQueryStartupCheckingEnabled = namedQueryStartupCheckingEnabled;
 	}
 
 	void setEntityTuplizerFactory(EntityTuplizerFactory entityTuplizerFactory) {
 		this.entityTuplizerFactory = entityTuplizerFactory;
 	}
 
 	public boolean isCheckNullability() {
 		return checkNullability;
 	}
 
 	public void setCheckNullability(boolean checkNullability) {
 		this.checkNullability = checkNullability;
 	}
 
 	//	void setComponentTuplizerFactory(ComponentTuplizerFactory componentTuplizerFactory) {
 //		this.componentTuplizerFactory = componentTuplizerFactory;
 //	}
 
 	void setJdbcSupport(JdbcSupport jdbcSupport) {
 		this.jdbcSupport = jdbcSupport;
 	}
 
 	//	public BytecodeProvider getBytecodeProvider() {
 //		return bytecodeProvider;
 //	}
 //
 //	void setBytecodeProvider(BytecodeProvider bytecodeProvider) {
 //		this.bytecodeProvider = bytecodeProvider;
 //	}
+
+
+	public JtaPlatform getJtaPlatform() {
+		return jtaPlatform;
+	}
+
+	void setJtaPlatform(JtaPlatform jtaPlatform) {
+		this.jtaPlatform = jtaPlatform;
+	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
index ca2a34f396..73801f2b98 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
@@ -1,378 +1,346 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.Serializable;
 import java.util.Map;
 import java.util.Properties;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.jdbc.JdbcSupport;
 import org.hibernate.bytecode.BytecodeProvider;
 import org.hibernate.cache.QueryCacheFactory;
 import org.hibernate.cache.RegionFactory;
 import org.hibernate.cache.impl.NoCachingRegionFactory;
 import org.hibernate.cache.impl.bridge.RegionFactoryCacheProviderBridge;
-import org.hibernate.engine.jdbc.batch.internal.BatchBuilder;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.hql.QueryTranslatorFactory;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.util.SQLStatementLogger;
-import org.hibernate.transaction.TransactionFactory;
-import org.hibernate.transaction.TransactionFactoryFactory;
-import org.hibernate.transaction.TransactionManagerLookup;
-import org.hibernate.transaction.TransactionManagerLookupFactory;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.util.ReflectHelper;
 import org.hibernate.util.StringHelper;
 
 /**
  * Reads configuration properties and builds a {@link Settings} instance.
  *
  * @author Gavin King
  */
 public class SettingsFactory implements Serializable {
 	private static final Logger log = LoggerFactory.getLogger( SettingsFactory.class );
 	private static final long serialVersionUID = -1194386144994524825L;
 
 	public static final String DEF_CACHE_REG_FACTORY = NoCachingRegionFactory.class.getName();
 
 	protected SettingsFactory() {
 	}
 
-	public Settings buildSettings(Properties props, JdbcServices jdbcServices) {
+	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) {
+		final JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		Settings settings = new Settings();
 
 		//SessionFactory name:
 
 		String sessionFactoryName = props.getProperty(Environment.SESSION_FACTORY_NAME);
 		settings.setSessionFactoryName(sessionFactoryName);
 
 		//JDBC and connection settings:
 
 		//Interrogate JDBC metadata
 		ExtractedDatabaseMetaData meta = jdbcServices.getExtractedMetaDataSupport();
 
 		settings.setDataDefinitionImplicitCommit( meta.doesDataDefinitionCauseTransactionCommit() );
 		settings.setDataDefinitionInTransactionSupported( meta.supportsDataDefinitionInTransaction() );
 
 		//use dialect default properties
 		final Properties properties = new Properties();
 		properties.putAll( jdbcServices.getDialect().getDefaultProperties() );
 		properties.putAll( props );
 
 		settings.setJdbcSupport( new JdbcSupport( ! ConfigurationHelper.getBoolean( Environment.NON_CONTEXTUAL_LOB_CREATION, properties ) ) );
 
 		// Transaction settings:
-
-		TransactionFactory transactionFactory = createTransactionFactory(properties);
-		settings.setTransactionFactory(transactionFactory);
-		settings.setTransactionManagerLookup( createTransactionManagerLookup(properties) );
+		settings.setJtaPlatform( serviceRegistry.getService( JtaPlatform.class ) );
 
 		boolean flushBeforeCompletion = ConfigurationHelper.getBoolean(Environment.FLUSH_BEFORE_COMPLETION, properties);
 		log.info("Automatic flush during beforeCompletion(): " + enabledDisabled(flushBeforeCompletion) );
 		settings.setFlushBeforeCompletionEnabled(flushBeforeCompletion);
 
 		boolean autoCloseSession = ConfigurationHelper.getBoolean(Environment.AUTO_CLOSE_SESSION, properties);
 		log.info("Automatic session close at end of transaction: " + enabledDisabled(autoCloseSession) );
 		settings.setAutoCloseSessionEnabled(autoCloseSession);
 
 		//JDBC and connection settings:
 
 		int batchSize = ConfigurationHelper.getInt(Environment.STATEMENT_BATCH_SIZE, properties, 0);
 		if ( !meta.supportsBatchUpdates() ) batchSize = 0;
 		if (batchSize>0) log.info("JDBC batch size: " + batchSize);
 		settings.setJdbcBatchSize(batchSize);
 		boolean jdbcBatchVersionedData = ConfigurationHelper.getBoolean(Environment.BATCH_VERSIONED_DATA, properties, false);
 		if (batchSize>0) log.info("JDBC batch updates for versioned data: " + enabledDisabled(jdbcBatchVersionedData) );
 		settings.setJdbcBatchVersionedData(jdbcBatchVersionedData);
-		settings.setBatcherBuilder( createBatchBuilder(properties, batchSize) );
 
 		boolean useScrollableResultSets = ConfigurationHelper.getBoolean(Environment.USE_SCROLLABLE_RESULTSET, properties, meta.supportsScrollableResults());
 		log.info("Scrollable result sets: " + enabledDisabled(useScrollableResultSets) );
 		settings.setScrollableResultSetsEnabled(useScrollableResultSets);
 
 		boolean wrapResultSets = ConfigurationHelper.getBoolean(Environment.WRAP_RESULT_SETS, properties, false);
 		log.debug( "Wrap result sets: " + enabledDisabled(wrapResultSets) );
 		settings.setWrapResultSetsEnabled(wrapResultSets);
 
 		boolean useGetGeneratedKeys = ConfigurationHelper.getBoolean(Environment.USE_GET_GENERATED_KEYS, properties, meta.supportsGetGeneratedKeys());
 		log.info("JDBC3 getGeneratedKeys(): " + enabledDisabled(useGetGeneratedKeys) );
 		settings.setGetGeneratedKeysEnabled(useGetGeneratedKeys);
 
 		Integer statementFetchSize = ConfigurationHelper.getInteger(Environment.STATEMENT_FETCH_SIZE, properties);
 		if (statementFetchSize!=null) log.info("JDBC result set fetch size: " + statementFetchSize);
 		settings.setJdbcFetchSize(statementFetchSize);
 
 		String releaseModeName = ConfigurationHelper.getString( Environment.RELEASE_CONNECTIONS, properties, "auto" );
 		log.info( "Connection release mode: " + releaseModeName );
 		ConnectionReleaseMode releaseMode;
 		if ( "auto".equals(releaseModeName) ) {
-			releaseMode = transactionFactory.getDefaultReleaseMode();
+			releaseMode = serviceRegistry.getService( TransactionFactory.class ).getDefaultReleaseMode();
 		}
 		else {
 			releaseMode = ConnectionReleaseMode.parse( releaseModeName );
 			if ( releaseMode == ConnectionReleaseMode.AFTER_STATEMENT &&
 					! jdbcServices.getConnectionProvider().supportsAggressiveRelease() ) {			
 				log.warn( "Overriding release mode as connection provider does not support 'after_statement'" );
 				releaseMode = ConnectionReleaseMode.AFTER_TRANSACTION;
 			}
 		}
 		settings.setConnectionReleaseMode( releaseMode );
 
 		//SQL Generation settings:
 
 		String defaultSchema = properties.getProperty(Environment.DEFAULT_SCHEMA);
 		String defaultCatalog = properties.getProperty(Environment.DEFAULT_CATALOG);
 		if (defaultSchema!=null) log.info("Default schema: " + defaultSchema);
 		if (defaultCatalog!=null) log.info("Default catalog: " + defaultCatalog);
 		settings.setDefaultSchemaName(defaultSchema);
 		settings.setDefaultCatalogName(defaultCatalog);
 
 		Integer maxFetchDepth = ConfigurationHelper.getInteger(Environment.MAX_FETCH_DEPTH, properties);
 		if (maxFetchDepth!=null) log.info("Maximum outer join fetch depth: " + maxFetchDepth);
 		settings.setMaximumFetchDepth(maxFetchDepth);
 		int batchFetchSize = ConfigurationHelper.getInt(Environment.DEFAULT_BATCH_FETCH_SIZE, properties, 1);
 		log.info("Default batch fetch size: " + batchFetchSize);
 		settings.setDefaultBatchFetchSize(batchFetchSize);
 
 		boolean comments = ConfigurationHelper.getBoolean(Environment.USE_SQL_COMMENTS, properties);
 		log.info( "Generate SQL with comments: " + enabledDisabled(comments) );
 		settings.setCommentsEnabled(comments);
 
 		boolean orderUpdates = ConfigurationHelper.getBoolean(Environment.ORDER_UPDATES, properties);
 		log.info( "Order SQL updates by primary key: " + enabledDisabled(orderUpdates) );
 		settings.setOrderUpdatesEnabled(orderUpdates);
 
 		boolean orderInserts = ConfigurationHelper.getBoolean(Environment.ORDER_INSERTS, properties);
 		log.info( "Order SQL inserts for batching: " + enabledDisabled( orderInserts ) );
 		settings.setOrderInsertsEnabled( orderInserts );
 
 		//Query parser settings:
 
 		settings.setQueryTranslatorFactory( createQueryTranslatorFactory(properties) );
 
 		Map querySubstitutions = ConfigurationHelper.toMap(Environment.QUERY_SUBSTITUTIONS, " ,=;:\n\t\r\f", properties);
 		log.info("Query language substitutions: " + querySubstitutions);
 		settings.setQuerySubstitutions(querySubstitutions);
 
 		boolean jpaqlCompliance = ConfigurationHelper.getBoolean( Environment.JPAQL_STRICT_COMPLIANCE, properties, false );
 		settings.setStrictJPAQLCompliance( jpaqlCompliance );
 		log.info( "JPA-QL strict compliance: " + enabledDisabled( jpaqlCompliance ) );
 
 		// Second-level / query cache:
 
 		boolean useSecondLevelCache = ConfigurationHelper.getBoolean(Environment.USE_SECOND_LEVEL_CACHE, properties, true);
 		log.info( "Second-level cache: " + enabledDisabled(useSecondLevelCache) );
 		settings.setSecondLevelCacheEnabled(useSecondLevelCache);
 
 		boolean useQueryCache = ConfigurationHelper.getBoolean(Environment.USE_QUERY_CACHE, properties);
 		log.info( "Query cache: " + enabledDisabled(useQueryCache) );
 		settings.setQueryCacheEnabled(useQueryCache);
 
 		// The cache provider is needed when we either have second-level cache enabled
 		// or query cache enabled.  Note that useSecondLevelCache is enabled by default
 		settings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ) ) );
 
 		boolean useMinimalPuts = ConfigurationHelper.getBoolean(
 				Environment.USE_MINIMAL_PUTS, properties, settings.getRegionFactory().isMinimalPutsEnabledByDefault()
 		);
 		log.info( "Optimize cache for minimal puts: " + enabledDisabled(useMinimalPuts) );
 		settings.setMinimalPutsEnabled(useMinimalPuts);
 
 		String prefix = properties.getProperty(Environment.CACHE_REGION_PREFIX);
 		if ( StringHelper.isEmpty(prefix) ) prefix=null;
 		if (prefix!=null) log.info("Cache region prefix: "+ prefix);
 		settings.setCacheRegionPrefix(prefix);
 
 		boolean useStructuredCacheEntries = ConfigurationHelper.getBoolean(Environment.USE_STRUCTURED_CACHE, properties, false);
 		log.info( "Structured second-level cache entries: " + enabledDisabled(useStructuredCacheEntries) );
 		settings.setStructuredCacheEntriesEnabled(useStructuredCacheEntries);
 
 		if (useQueryCache) settings.setQueryCacheFactory( createQueryCacheFactory(properties) );
 
 		//Statistics and logging:
 
 		boolean showSql = ConfigurationHelper.getBoolean(Environment.SHOW_SQL, properties);
 		if (showSql) log.info("Echoing all SQL to stdout");
 //		settings.setShowSqlEnabled(showSql);
 
 		boolean formatSql = ConfigurationHelper.getBoolean(Environment.FORMAT_SQL, properties);
 //		settings.setFormatSqlEnabled(formatSql);
 
 		settings.setSqlStatementLogger( new SQLStatementLogger( showSql, formatSql ) );
 
 		boolean useStatistics = ConfigurationHelper.getBoolean(Environment.GENERATE_STATISTICS, properties);
 		log.info( "Statistics: " + enabledDisabled(useStatistics) );
 		settings.setStatisticsEnabled(useStatistics);
 
 		boolean useIdentifierRollback = ConfigurationHelper.getBoolean(Environment.USE_IDENTIFIER_ROLLBACK, properties);
 		log.info( "Deleted entity synthetic identifier rollback: " + enabledDisabled(useIdentifierRollback) );
 		settings.setIdentifierRollbackEnabled(useIdentifierRollback);
 
 		//Schema export:
 
 		String autoSchemaExport = properties.getProperty(Environment.HBM2DDL_AUTO);
 		if ( "validate".equals(autoSchemaExport) ) settings.setAutoValidateSchema(true);
 		if ( "update".equals(autoSchemaExport) ) settings.setAutoUpdateSchema(true);
 		if ( "create".equals(autoSchemaExport) ) settings.setAutoCreateSchema(true);
 		if ( "create-drop".equals(autoSchemaExport) ) {
 			settings.setAutoCreateSchema(true);
 			settings.setAutoDropSchema(true);
 		}
 		settings.setImportFiles( properties.getProperty( Environment.HBM2DDL_IMPORT_FILES ) );
 
 		EntityMode defaultEntityMode = EntityMode.parse( properties.getProperty( Environment.DEFAULT_ENTITY_MODE ) );
 		log.info( "Default entity-mode: " + defaultEntityMode );
 		settings.setDefaultEntityMode( defaultEntityMode );
 
 		boolean namedQueryChecking = ConfigurationHelper.getBoolean( Environment.QUERY_STARTUP_CHECKING, properties, true );
 		log.info( "Named query checking : " + enabledDisabled( namedQueryChecking ) );
 		settings.setNamedQueryStartupCheckingEnabled( namedQueryChecking );
 
 		boolean checkNullability = ConfigurationHelper.getBoolean(Environment.CHECK_NULLABILITY, properties, true);
 		log.info( "Check Nullability in Core (should be disabled when Bean Validation is on): " + enabledDisabled(checkNullability) );
 		settings.setCheckNullability(checkNullability);
 
 
 //		String provider = properties.getProperty( Environment.BYTECODE_PROVIDER );
 //		log.info( "Bytecode provider name : " + provider );
 //		BytecodeProvider bytecodeProvider = buildBytecodeProvider( provider );
 //		settings.setBytecodeProvider( bytecodeProvider );
 
 		return settings;
 
 	}
 
 	protected BytecodeProvider buildBytecodeProvider(String providerName) {
 		if ( "javassist".equals( providerName ) ) {
 			return new org.hibernate.bytecode.javassist.BytecodeProviderImpl();
 		}
 		else if ( "cglib".equals( providerName ) ) {
 			return new org.hibernate.bytecode.cglib.BytecodeProviderImpl();
 		}
 		else {
 			log.debug( "using javassist as bytecode provider by default" );
 			return new org.hibernate.bytecode.javassist.BytecodeProviderImpl();
 		}
 	}
 
 	private static String enabledDisabled(boolean value) {
 		return value ? "enabled" : "disabled";
 	}
 
 	protected QueryCacheFactory createQueryCacheFactory(Properties properties) {
 		String queryCacheFactoryClassName = ConfigurationHelper.getString(
 				Environment.QUERY_CACHE_FACTORY, properties, "org.hibernate.cache.StandardQueryCacheFactory"
 		);
 		log.info("Query cache factory: " + queryCacheFactoryClassName);
 		try {
 			return (QueryCacheFactory) ReflectHelper.classForName(queryCacheFactoryClassName).newInstance();
 		}
 		catch (Exception cnfe) {
 			throw new HibernateException("could not instantiate QueryCacheFactory: " + queryCacheFactoryClassName, cnfe);
 		}
 	}
 
 	public static RegionFactory createRegionFactory(Properties properties, boolean cachingEnabled) {
-		String regionFactoryClassName = ConfigurationHelper.getString( Environment.CACHE_REGION_FACTORY, properties, null );
+		String regionFactoryClassName = ConfigurationHelper.getString(
+				Environment.CACHE_REGION_FACTORY, properties, null
+		);
 		if ( regionFactoryClassName == null && cachingEnabled ) {
 			String providerClassName = ConfigurationHelper.getString( Environment.CACHE_PROVIDER, properties, null );
 			if ( providerClassName != null ) {
 				// legacy behavior, apply the bridge...
 				regionFactoryClassName = RegionFactoryCacheProviderBridge.class.getName();
 			}
 		}
 		if ( regionFactoryClassName == null ) {
 			regionFactoryClassName = DEF_CACHE_REG_FACTORY;
 		}
 		log.info( "Cache region factory : " + regionFactoryClassName );
 		try {
 			try {
 				return (RegionFactory) ReflectHelper.classForName( regionFactoryClassName )
 						.getConstructor( Properties.class )
 						.newInstance( properties );
 			}
 			catch ( NoSuchMethodException nsme ) {
 				// no constructor accepting Properties found, try no arg constructor
 				log.debug(
 						regionFactoryClassName + " did not provide constructor accepting java.util.Properties; " +
 								"attempting no-arg constructor."
 				);
 				return (RegionFactory) ReflectHelper.classForName( regionFactoryClassName ).newInstance();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate RegionFactory [" + regionFactoryClassName + "]", e );
 		}
 	}
 
 	protected QueryTranslatorFactory createQueryTranslatorFactory(Properties properties) {
 		String className = ConfigurationHelper.getString(
 				Environment.QUERY_TRANSLATOR, properties, "org.hibernate.hql.ast.ASTQueryTranslatorFactory"
 		);
 		log.info("Query translator: " + className);
 		try {
 			return (QueryTranslatorFactory) ReflectHelper.classForName(className).newInstance();
 		}
 		catch (Exception cnfe) {
 			throw new HibernateException("could not instantiate QueryTranslatorFactory: " + className, cnfe);
 		}
 	}
 
-	protected BatchBuilder createBatchBuilder(Properties properties, int batchSize) {
-		String batchBuilderClass = properties.getProperty(Environment.BATCH_STRATEGY);
-		BatchBuilder batchBuilder;
-		if (batchBuilderClass==null) {
-			batchBuilder = batchSize > 0
-					? new BatchBuilder( batchSize )
-					: new BatchBuilder();
-		}
-		else {
-			log.info("Batch factory: " + batchBuilderClass);
-			try {
-				batchBuilder = (BatchBuilder) ReflectHelper.classForName(batchBuilderClass).newInstance();
-			}
-			catch (Exception cnfe) {
-				throw new HibernateException("could not instantiate BatchBuilder: " + batchBuilderClass, cnfe);
-			}
-		}
-		batchBuilder.setJdbcBatchSize( batchSize );
-		return batchBuilder;
-	}
-
-	protected TransactionFactory createTransactionFactory(Properties properties) {
-		return TransactionFactoryFactory.buildTransactionFactory(properties);
-	}
-
-	protected TransactionManagerLookup createTransactionManagerLookup(Properties properties) {
-		return TransactionManagerLookupFactory.getTransactionManagerLookup(properties);
-	}
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
index 7b7f7fc7e8..058882c5cc 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
@@ -1,212 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.context;
 
 import org.hibernate.HibernateException;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.classic.Session;
 import org.hibernate.engine.SessionFactoryImplementor;
-import org.hibernate.util.JTAHelper;
+import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.Synchronization;
 import java.util.Map;
 import java.util.Hashtable;
 
 /**
  * An implementation of {@link CurrentSessionContext} which scopes the notion
  * of a current session to a JTA transaction.  Because JTA gives us a nice
  * tie-in to clean up after ourselves, this implementation will generate
  * Sessions as needed provided a JTA transaction is in effect.  If a session
  * is not already associated with the current JTA transaction at the time
  * {@link #currentSession()} is called, a new session will be opened and it
  * will be associated with that JTA transaction.
  * <p/>
  * Note that the sessions returned from this method are automatically configured with
  * both the {@link org.hibernate.cfg.Environment#FLUSH_BEFORE_COMPLETION auto-flush} and
  * {@link org.hibernate.cfg.Environment#AUTO_CLOSE_SESSION auto-close} attributes set to
  * true, meaning that the Session will be automatically flushed and closed
  * as part of the lifecycle for the JTA transaction to which it is associated.
  * Additionally, it will also be configured to aggressively release JDBC
  * connections after each statement is executed.  These settings are governed
  * by the {@link #isAutoFlushEnabled()}, {@link #isAutoCloseEnabled()}, and
  * {@link #getConnectionReleaseMode()} methods; these are provided (along with
  * the {@link #buildOrObtainSession()} method) for easier subclassing for custom
  * JTA-based session tracking logic (like maybe long-session semantics).
  *
  * @author Steve Ebersole
  */
 public class JTASessionContext implements CurrentSessionContext {
 
 	private static final Logger log = LoggerFactory.getLogger( JTASessionContext.class );
 
 	protected final SessionFactoryImplementor factory;
 	private transient Map currentSessionMap = new Hashtable();
 
 	public JTASessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Session currentSession() throws HibernateException {
-		TransactionManager transactionManager = factory.getTransactionManager();
+		final JtaPlatform jtaPlatform = factory.getServiceRegistry().getService( JtaPlatform.class );
+		final TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();
 		if ( transactionManager == null ) {
 			throw new HibernateException( "No TransactionManagerLookup specified" );
 		}
 
 		Transaction txn;
 		try {
 			txn = transactionManager.getTransaction();
 			if ( txn == null ) {
 				throw new HibernateException( "Unable to locate current JTA transaction" );
 			}
-			if ( !JTAHelper.isInProgress( txn.getStatus() ) ) {
+			if ( !JtaStatusHelper.isActive( txn.getStatus() ) ) {
 				// We could register the session against the transaction even though it is
-				// not started, but we'd have no guarentee of ever getting the map
+				// not started, but we'd have no guarantee of ever getting the map
 				// entries cleaned up (aside from spawning threads).
 				throw new HibernateException( "Current transaction is not in progress" );
 			}
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Problem locating/validating JTA transaction", t );
 		}
 
-		final Object txnIdentifier = factory.getSettings().getTransactionManagerLookup() == null
-				? txn
-				: factory.getSettings().getTransactionManagerLookup().getTransactionIdentifier( txn );
+		final Object txnIdentifier = jtaPlatform.getTransactionIdentifier( txn );
 
 		Session currentSession = ( Session ) currentSessionMap.get( txnIdentifier );
 
 		if ( currentSession == null ) {
 			currentSession = buildOrObtainSession();
 
 			try {
 				txn.registerSynchronization( buildCleanupSynch( txnIdentifier ) );
 			}
 			catch ( Throwable t ) {
 				try {
 					currentSession.close();
 				}
 				catch ( Throwable ignore ) {
 					log.debug( "Unable to release generated current-session on failed synch registration", ignore );
 				}
 				throw new HibernateException( "Unable to register cleanup Synchronization with TransactionManager" );
 			}
 
 			currentSessionMap.put( txnIdentifier, currentSession );
 		}
 
 		return currentSession;
 	}
 
 	/**
 	 * Builds a {@link CleanupSynch} capable of cleaning up the the current session map as an after transaction
 	 * callback.
 	 *
 	 * @param transactionIdentifier The transaction identifier under which the current session is registered.
 	 * @return The cleanup synch.
 	 */
 	private CleanupSynch buildCleanupSynch(Object transactionIdentifier) {
 		return new CleanupSynch( transactionIdentifier, this );
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return factory.openSession(
 				null,
 		        isAutoFlushEnabled(),
 		        isAutoCloseEnabled(),
 		        getConnectionReleaseMode()
 			);
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_statement.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization {
 		private Object transactionIdentifier;
 		private JTASessionContext context;
 
 		public CleanupSynch(Object transactionIdentifier, JTASessionContext context) {
 			this.transactionIdentifier = transactionIdentifier;
 			this.context = context;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			context.currentSessionMap.remove( transactionIdentifier );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
index a0613d8a6f..f3bbe79cd9 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
@@ -1,390 +1,394 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.context;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.HashMap;
 import java.util.Map;
 import javax.transaction.Synchronization;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.classic.Session;
 import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.SessionImplementor;
+import org.hibernate.engine.jdbc.LobCreationContext;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.event.EventSource;
 
 /**
  * A {@link CurrentSessionContext} impl which scopes the notion of current
  * session by the current thread of execution.  Unlike the JTA counterpart,
  * threads do not give us a nice hook to perform any type of cleanup making
  * it questionable for this impl to actually generate Session instances.  In
  * the interest of usability, it was decided to have this default impl
  * actually generate a session upon first request and then clean it up
  * after the {@link org.hibernate.Transaction} associated with that session
  * is committed/rolled-back.  In order for ensuring that happens, the sessions
  * generated here are unusable until after {@link Session#beginTransaction()}
  * has been called. If <tt>close()</tt> is called on a session managed by
  * this class, it will be automatically unbound.
  * <p/>
  * Additionally, the static {@link #bind} and {@link #unbind} methods are
  * provided to allow application code to explicitly control opening and
  * closing of these sessions.  This, with some from of interception,
  * is the preferred approach.  It also allows easy framework integration
  * and one possible approach for implementing long-sessions.
  * <p/>
  * The {@link #buildOrObtainSession}, {@link #isAutoCloseEnabled},
  * {@link #isAutoFlushEnabled}, {@link #getConnectionReleaseMode}, and
  * {@link #buildCleanupSynch} methods are all provided to allow easy
  * subclassing (for long-running session scenarios, for example).
  *
  * @author Steve Ebersole
  */
 public class ThreadLocalSessionContext implements CurrentSessionContext {
 
 	private static final Logger log = LoggerFactory.getLogger( ThreadLocalSessionContext.class );
 	private static final Class[] SESSION_PROXY_INTERFACES = new Class[] {
-			org.hibernate.classic.Session.class,
-	        org.hibernate.engine.SessionImplementor.class,
-	        org.hibernate.engine.jdbc.spi.JDBCContext.Context.class,
-	        org.hibernate.event.EventSource.class,
-			org.hibernate.engine.jdbc.LobCreationContext.class
+			Session.class,
+	        SessionImplementor.class,
+	        EventSource.class,
+			TransactionContext.class,
+			LobCreationContext.class
 	};
 
 	/**
 	 * A ThreadLocal maintaining current sessions for the given execution thread.
 	 * The actual ThreadLocal variable is a java.util.Map to account for
 	 * the possibility for multiple SessionFactorys being used during execution
 	 * of the given thread.
 	 */
 	private static final ThreadLocal<Map> context = new ThreadLocal<Map>();
 
 	protected final SessionFactoryImplementor factory;
 
 	public ThreadLocalSessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public final Session currentSession() throws HibernateException {
 		Session current = existingSession( factory );
 		if (current == null) {
 			current = buildOrObtainSession();
 			// register a cleanup sync
 			current.getTransaction().registerSynchronization( buildCleanupSynch() );
 			// wrap the session in the transaction-protection proxy
 			if ( needsWrapping( current ) ) {
 				current = wrap( current );
 			}
 			// then bind it
 			doBind( current, factory );
 		}
 		return current;
 	}
 
 	private boolean needsWrapping(Session session) {
 		// try to make sure we don't wrap and already wrapped session
 		return session != null
 		       && ! Proxy.isProxyClass( session.getClass() )
 		       || ( Proxy.getInvocationHandler( session ) != null
 		       && ! ( Proxy.getInvocationHandler( session ) instanceof TransactionProtectionWrapper ) );
 	}
 
 	/**
 	 * Getter for property 'factory'.
 	 *
 	 * @return Value for property 'factory'.
 	 */
 	protected SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return factory.openSession(
 				null,
 		        isAutoFlushEnabled(),
 		        isAutoCloseEnabled(),
 		        getConnectionReleaseMode()
 			);
 	}
 
 	protected CleanupSynch buildCleanupSynch() {
 		return new CleanupSynch( factory );
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_transaction.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return factory.getSettings().getConnectionReleaseMode();
 	}
 
 	protected Session wrap(Session session) {
 		TransactionProtectionWrapper wrapper = new TransactionProtectionWrapper( session );
 		Session wrapped = ( Session ) Proxy.newProxyInstance(
 				Session.class.getClassLoader(),
 				SESSION_PROXY_INTERFACES,
 		        wrapper
 			);
 		// yick!  need this for proper serialization/deserialization handling...
 		wrapper.setWrapped( wrapped );
 		return wrapped;
 	}
 
 	/**
 	 * Associates the given session with the current thread of execution.
 	 *
 	 * @param session The session to bind.
 	 */
 	public static void bind(org.hibernate.Session session) {
 		SessionFactory factory = session.getSessionFactory();
 		cleanupAnyOrphanedSession( factory );
 		doBind( session, factory );
 	}
 
 	private static void cleanupAnyOrphanedSession(SessionFactory factory) {
 		Session orphan = doUnbind( factory, false );
 		if ( orphan != null ) {
 			log.warn( "Already session bound on call to bind(); make sure you clean up your sessions!" );
 			try {
 				if ( orphan.getTransaction() != null && orphan.getTransaction().isActive() ) {
 					try {
 						orphan.getTransaction().rollback();
 					}
 					catch( Throwable t ) {
 						log.debug( "Unable to rollback transaction for orphaned session", t );
 					}
 				}
 				orphan.close();
 			}
 			catch( Throwable t ) {
 				log.debug( "Unable to close orphaned session", t );
 			}
 		}
 	}
 
 	/**
 	 * Disassociates a previously bound session from the current thread of execution.
 	 *
 	 * @param factory The factory for which the session should be unbound.
 	 * @return The session which was unbound.
 	 */
 	public static Session unbind(SessionFactory factory) {
 		return doUnbind( factory, true );
 	}
 
 	private static Session existingSession(SessionFactory factory) {
 		Map sessionMap = sessionMap();
 		if ( sessionMap == null ) {
 			return null;
 		}
 		else {
 			return ( Session ) sessionMap.get( factory );
 		}
 	}
 
 	protected static Map sessionMap() {
 		return context.get();
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private static void doBind(org.hibernate.Session session, SessionFactory factory) {
 		Map sessionMap = sessionMap();
 		if ( sessionMap == null ) {
 			sessionMap = new HashMap();
 			context.set( sessionMap );
 		}
 		sessionMap.put( factory, session );
 	}
 
 	private static Session doUnbind(SessionFactory factory, boolean releaseMapIfEmpty) {
 		Map sessionMap = sessionMap();
 		Session session = null;
 		if ( sessionMap != null ) {
 			session = ( Session ) sessionMap.remove( factory );
 			if ( releaseMapIfEmpty && sessionMap.isEmpty() ) {
 				context.set( null );
 			}
 		}
 		return session;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization, Serializable {
 		protected final SessionFactory factory;
 
 		public CleanupSynch(SessionFactory factory) {
 			this.factory = factory;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			unbind( factory );
 		}
 	}
 
 	private class TransactionProtectionWrapper implements InvocationHandler, Serializable {
 		private final Session realSession;
 		private Session wrappedSession;
 
 		public TransactionProtectionWrapper(Session realSession) {
 			this.realSession = realSession;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			try {
 				// If close() is called, guarantee unbind()
 				if ( "close".equals( method.getName()) ) {
 					unbind( realSession.getSessionFactory() );
 				}
 				else if ( "toString".equals( method.getName() )
 					     || "equals".equals( method.getName() )
 					     || "hashCode".equals( method.getName() )
 				         || "getStatistics".equals( method.getName() )
 					     || "isOpen".equals( method.getName() )
 						 || "getListeners".equals( method.getName() ) //useful for HSearch in particular
 						) {
 					// allow these to go through the the real session no matter what
 				}
 				else if ( !realSession.isOpen() ) {
 					// essentially, if the real session is closed allow any
 					// method call to pass through since the real session
 					// will complain by throwing an appropriate exception;
 					// NOTE that allowing close() above has the same basic effect,
 					//   but we capture that there simply to doAfterTransactionCompletion the unbind...
 				}
 				else if ( !realSession.getTransaction().isActive() ) {
 					// limit the methods available if no transaction is active
 					if ( "beginTransaction".equals( method.getName() )
 					     || "getTransaction".equals( method.getName() )
 					     || "isTransactionInProgress".equals( method.getName() )
 					     || "setFlushMode".equals( method.getName() )
 					     || "getSessionFactory".equals( method.getName() ) ) {
 						log.trace( "allowing method [" + method.getName() + "] in non-transacted context" );
 					}
 					else if ( "reconnect".equals( method.getName() )
 					          || "disconnect".equals( method.getName() ) ) {
 						// allow these (deprecated) methods to pass through
 					}
 					else {
 						throw new HibernateException( method.getName() + " is not valid without active transaction" );
 					}
 				}
 				log.trace( "allowing proxied method [" + method.getName() + "] to proceed to real session" );
 				return method.invoke( realSession, args );
 			}
 			catch ( InvocationTargetException e ) {
 				if ( e.getTargetException() instanceof RuntimeException ) {
 					throw ( RuntimeException ) e.getTargetException();
 				}
 				else {
 					throw e;
 				}
 			}
 		}
 
 		/**
 		 * Setter for property 'wrapped'.
 		 *
 		 * @param wrapped Value to set for property 'wrapped'.
 		 */
 		public void setWrapped(Session wrapped) {
 			this.wrappedSession = wrapped;
 		}
 
 
 		// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		private void writeObject(ObjectOutputStream oos) throws IOException {
 			// if a ThreadLocalSessionContext-bound session happens to get
 			// serialized, to be completely correct, we need to make sure
 			// that unbinding of that session occurs.
 			oos.defaultWriteObject();
 			if ( existingSession( factory ) == wrappedSession ) {
 				unbind( factory );
 			}
 		}
 
 		private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 			// on the inverse, it makes sense that if a ThreadLocalSessionContext-
 			// bound session then gets deserialized to go ahead and re-bind it to
 			// the ThreadLocalSessionContext session map.
 			ois.defaultReadObject();
 			realSession.getTransaction().registerSynchronization( buildCleanupSynch() );
 			doBind( wrappedSession, factory );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadSelectLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadSelectLockingStrategy.java
index 12e7b4c575..d8db93be62 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadSelectLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadSelectLockingStrategy.java
@@ -1,139 +1,139 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import org.hibernate.LockOptions;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.LockMode;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.JDBCException;
 import org.hibernate.PessimisticLockException;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 /**
  * A pessimistic locking strategy where the locks are obtained through select statements.
  * <p/>
  * For non-read locks, this is achieved through the Dialect's specific
  * SELECT ... FOR UPDATE syntax.
  *
  * This strategy is valid for LockMode.PESSIMISTIC_READ
  *
  * This class is a clone of SelectLockingStrategy.
  *
  * @author Steve Ebersole
  * @author Scott Marlow
  * @see org.hibernate.dialect.Dialect#getForUpdateString(org.hibernate.LockMode)
  * @see org.hibernate.dialect.Dialect#appendLockHint(org.hibernate.LockMode, String)
  * @since 3.5
  */
 public class PessimisticReadSelectLockingStrategy extends AbstractSelectLockingStrategy {
 	/**
 	 * Construct a locking strategy based on SQL SELECT statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indicates the type of lock to be acquired.
 	 */
 	public PessimisticReadSelectLockingStrategy(Lockable lockable, LockMode lockMode) {
 		super( lockable, lockMode );
 	}
 
 	/**
 	 * @see org.hibernate.dialect.lock.LockingStrategy#lock
 	 */
 	public void lock(
 			Serializable id,
 			Object version,
 			Object object,
 			int timeout,
 			SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		final String sql = determineSql( timeout );
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				getLockable().getIdentifierType().nullSafeSet( st, id, 1, session );
 				if ( getLockable().isVersioned() ) {
 					getLockable().getVersionType().nullSafeSet(
 							st,
 							version,
 							getLockable().getIdentifierType().getColumnSpan( factory ) + 1,
 							session
 					);
 				}
 
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						if ( factory.getStatistics().isStatisticsEnabled() ) {
 							factory.getStatisticsImplementor()
 									.optimisticFailure( getLockable().getEntityName() );
 						}
 						throw new StaleObjectStateException( getLockable().getEntityName(), id );
 					}
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			JDBCException e = session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not lock: " + MessageHelper.infoString( getLockable(), id, session.getFactory() ),
 					sql
 			);
 			throw new PessimisticLockException( "could not obtain pessimistic lock", e, object );
 		}
 	}
 
 	protected String generateLockString(int lockTimeout) {
 		SessionFactoryImplementor factory = getLockable().getFactory();
 		LockOptions lockOptions = new LockOptions( getLockMode() );
 		lockOptions.setTimeOut( lockTimeout );
 		SimpleSelect select = new SimpleSelect( factory.getDialect() )
 				.setLockOptions( lockOptions )
 				.setTableName( getLockable().getRootTableName() )
 				.addColumn( getLockable().getRootTableIdentifierColumnNames()[0] )
 				.addCondition( getLockable().getRootTableIdentifierColumnNames(), "=?" );
 		if ( getLockable().isVersioned() ) {
 			select.addCondition( getLockable().getVersionColumnName(), "=?" );
 		}
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			select.setComment( getLockMode() + " lock " + getLockable().getEntityName() );
 		}
 		return select.toStatementString();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadUpdateLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadUpdateLockingStrategy.java
index 9d473ca9b9..19976b0898 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadUpdateLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticReadUpdateLockingStrategy.java
@@ -1,147 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Update;
 import org.hibernate.LockMode;
 import org.hibernate.HibernateException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.JDBCException;
 import org.hibernate.PessimisticLockException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * A pessimistic locking strategy where the locks are obtained through update statements.
  * <p/>
  * This strategy is valid for LockMode.PESSIMISTIC_READ
  *
  * This class is a clone of UpdateLockingStrategy.
  *
  * @since 3.5
  *
  * @author Steve Ebersole
  * @author Scott Marlow
  */
 public class PessimisticReadUpdateLockingStrategy implements LockingStrategy {
 	private static final Logger log = LoggerFactory.getLogger( PessimisticReadUpdateLockingStrategy.class );
 
 	private final Lockable lockable;
 	private final LockMode lockMode;
 	private final String sql;
 
 	/**
 	 * Construct a locking strategy based on SQL UPDATE statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indictates the type of lock to be acquired.  Note that
 	 * read-locks are not valid for this strategy.
 	 */
 	public PessimisticReadUpdateLockingStrategy(Lockable lockable, LockMode lockMode) {
 		this.lockable = lockable;
 		this.lockMode = lockMode;
 		if ( lockMode.lessThan( LockMode.PESSIMISTIC_READ ) ) {
 			throw new HibernateException( "[" + lockMode + "] not valid for update statement" );
 		}
 		if ( !lockable.isVersioned() ) {
 			log.warn( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 			this.sql = null;
 		}
 		else {
 			this.sql = generateLockString();
 		}
 	}
 
    /**
 	 * @see org.hibernate.dialect.lock.LockingStrategy#lock
 	 */
 	public void lock(
       Serializable id,
       Object version,
       Object object,
       int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		if ( !lockable.isVersioned() ) {
 			throw new HibernateException( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 		}
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				lockable.getVersionType().nullSafeSet( st, version, 1, session );
 				int offset = 2;
 
 				lockable.getIdentifierType().nullSafeSet( st, id, offset, session );
 				offset += lockable.getIdentifierType().getColumnSpan( factory );
 
 				if ( lockable.isVersioned() ) {
 					lockable.getVersionType().nullSafeSet( st, version, offset, session );
 				}
 
 				int affected = st.executeUpdate();
 				if ( affected < 0 ) {  // todo:  should this instead check for exactly one row modified?
 					factory.getStatisticsImplementor().optimisticFailure( lockable.getEntityName() );
 					throw new StaleObjectStateException( lockable.getEntityName(), id );
 				}
 
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			JDBCException e = session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not lock: " + MessageHelper.infoString( lockable, id, session.getFactory() ),
 					sql
 				);
 			throw new PessimisticLockException("could not obtain pessimistic lock", e, object);
 		}
 	}
 
 	protected String generateLockString() {
 		SessionFactoryImplementor factory = lockable.getFactory();
 		Update update = new Update( factory.getDialect() );
 		update.setTableName( lockable.getRootTableName() );
 		update.addPrimaryKeyColumns( lockable.getRootTableIdentifierColumnNames() );
 		update.setVersionColumnName( lockable.getVersionColumnName() );
 		update.addColumn( lockable.getVersionColumnName() );
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			update.setComment( lockMode + " lock " + lockable.getEntityName() );
 		}
 		return update.toStatementString();
 	}
 
 	protected LockMode getLockMode() {
 		return lockMode;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteSelectLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteSelectLockingStrategy.java
index d7cd8e96c2..a280a88526 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteSelectLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteSelectLockingStrategy.java
@@ -1,139 +1,139 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import org.hibernate.LockOptions;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.JDBCException;
 import org.hibernate.LockMode;
 import org.hibernate.PessimisticLockException;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.pretty.MessageHelper;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 /**
  * A pessimistic locking strategy where the locks are obtained through select statements.
  * <p/>
  * For non-read locks, this is achieved through the Dialect's specific
  * SELECT ... FOR UPDATE syntax.
  *
  * This strategy is valid for LockMode.PESSIMISTIC_WRITE
  *
  * This class is a clone of SelectLockingStrategy.
  *
  * @author Steve Ebersole
  * @author Scott Marlow
  * @see org.hibernate.dialect.Dialect#getForUpdateString(org.hibernate.LockMode)
  * @see org.hibernate.dialect.Dialect#appendLockHint(org.hibernate.LockMode, String)
  * @since 3.5
  */
 public class PessimisticWriteSelectLockingStrategy extends AbstractSelectLockingStrategy {
 	/**
 	 * Construct a locking strategy based on SQL SELECT statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indicates the type of lock to be acquired.
 	 */
 	public PessimisticWriteSelectLockingStrategy(Lockable lockable, LockMode lockMode) {
 		super( lockable, lockMode );
 	}
 
 	/**
 	 * @see LockingStrategy#lock
 	 */
 	public void lock(
 			Serializable id,
 			Object version,
 			Object object,
 			int timeout,
 			SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		final String sql = determineSql( timeout );
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				getLockable().getIdentifierType().nullSafeSet( st, id, 1, session );
 				if ( getLockable().isVersioned() ) {
 					getLockable().getVersionType().nullSafeSet(
 							st,
 							version,
 							getLockable().getIdentifierType().getColumnSpan( factory ) + 1,
 							session
 					);
 				}
 
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						if ( factory.getStatistics().isStatisticsEnabled() ) {
 							factory.getStatisticsImplementor()
 									.optimisticFailure( getLockable().getEntityName() );
 						}
 						throw new StaleObjectStateException( getLockable().getEntityName(), id );
 					}
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			JDBCException e = session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not lock: " + MessageHelper.infoString( getLockable(), id, session.getFactory() ),
 					sql
 			);
 			throw new PessimisticLockException( "could not obtain pessimistic lock", e, object );
 		}
 	}
 
 	protected String generateLockString(int lockTimeout) {
 		SessionFactoryImplementor factory = getLockable().getFactory();
 		LockOptions lockOptions = new LockOptions( getLockMode() );
 		lockOptions.setTimeOut( lockTimeout );
 		SimpleSelect select = new SimpleSelect( factory.getDialect() )
 				.setLockOptions( lockOptions )
 				.setTableName( getLockable().getRootTableName() )
 				.addColumn( getLockable().getRootTableIdentifierColumnNames()[0] )
 				.addCondition( getLockable().getRootTableIdentifierColumnNames(), "=?" );
 		if ( getLockable().isVersioned() ) {
 			select.addCondition( getLockable().getVersionColumnName(), "=?" );
 		}
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			select.setComment( getLockMode() + " lock " + getLockable().getEntityName() );
 		}
 		return select.toStatementString();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteUpdateLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteUpdateLockingStrategy.java
index 47d9af492c..d59c619e24 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteUpdateLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteUpdateLockingStrategy.java
@@ -1,147 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Update;
 import org.hibernate.LockMode;
 import org.hibernate.HibernateException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.JDBCException;
 import org.hibernate.PessimisticLockException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * A pessimistic locking strategy where the locks are obtained through update statements.
  * <p/>
  * This strategy is valid for LockMode.PESSIMISTIC_WRITE
  *
  * This class is a clone of UpdateLockingStrategy.
  *
  * @since 3.5
  *
  * @author Steve Ebersole
  * @author Scott Marlow
  */
 public class PessimisticWriteUpdateLockingStrategy implements LockingStrategy {
 	private static final Logger log = LoggerFactory.getLogger( PessimisticWriteUpdateLockingStrategy.class );
 
 	private final Lockable lockable;
 	private final LockMode lockMode;
 	private final String sql;
 
 	/**
 	 * Construct a locking strategy based on SQL UPDATE statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indictates the type of lock to be acquired.  Note that
 	 * read-locks are not valid for this strategy.
 	 */
 	public PessimisticWriteUpdateLockingStrategy(Lockable lockable, LockMode lockMode) {
 		this.lockable = lockable;
 		this.lockMode = lockMode;
 		if ( lockMode.lessThan( LockMode.PESSIMISTIC_READ ) ) {
 			throw new HibernateException( "[" + lockMode + "] not valid for update statement" );
 		}
 		if ( !lockable.isVersioned() ) {
 			log.warn( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 			this.sql = null;
 		}
 		else {
 			this.sql = generateLockString();
 		}
 	}
 
    /**
 	 * @see LockingStrategy#lock
 	 */
 	public void lock(
       Serializable id,
       Object version,
       Object object,
       int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		if ( !lockable.isVersioned() ) {
 			throw new HibernateException( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 		}
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				lockable.getVersionType().nullSafeSet( st, version, 1, session );
 				int offset = 2;
 
 				lockable.getIdentifierType().nullSafeSet( st, id, offset, session );
 				offset += lockable.getIdentifierType().getColumnSpan( factory );
 
 				if ( lockable.isVersioned() ) {
 					lockable.getVersionType().nullSafeSet( st, version, offset, session );
 				}
 
 				int affected = st.executeUpdate();
 				if ( affected < 0 ) {  // todo:  should this instead check for exactly one row modified?
 					factory.getStatisticsImplementor().optimisticFailure( lockable.getEntityName() );
 					throw new StaleObjectStateException( lockable.getEntityName(), id );
 				}
 
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			JDBCException e = session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not lock: " + MessageHelper.infoString( lockable, id, session.getFactory() ),
 					sql
 				);
 			throw new PessimisticLockException("could not obtain pessimistic lock", e, object);
 		}
 	}
 
 	protected String generateLockString() {
 		SessionFactoryImplementor factory = lockable.getFactory();
 		Update update = new Update( factory.getDialect() );
 		update.setTableName( lockable.getRootTableName() );
 		update.addPrimaryKeyColumns( lockable.getRootTableIdentifierColumnNames() );
 		update.setVersionColumnName( lockable.getVersionColumnName() );
 		update.addColumn( lockable.getVersionColumnName() );
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			update.setComment( lockMode + " lock " + lockable.getEntityName() );
 		}
 		return update.toStatementString();
 	}
 
 	protected LockMode getLockMode() {
 		return lockMode;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/SelectLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/SelectLockingStrategy.java
index 65e563f76b..dbca19411f 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/SelectLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/SelectLockingStrategy.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import org.hibernate.LockOptions;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.JDBCException;
 import org.hibernate.LockMode;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.pretty.MessageHelper;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 /**
  * A locking strategy where the locks are obtained through select statements.
  * <p/>
  * For non-read locks, this is achieved through the Dialect's specific
  * SELECT ... FOR UPDATE syntax.
  *
  * @see org.hibernate.dialect.Dialect#getForUpdateString(org.hibernate.LockMode)
  * @see org.hibernate.dialect.Dialect#appendLockHint(org.hibernate.LockMode, String)
  * @since 3.2
  *
  * @author Steve Ebersole
  */
 public class SelectLockingStrategy extends AbstractSelectLockingStrategy {
 	/**
 	 * Construct a locking strategy based on SQL SELECT statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indictates the type of lock to be acquired.
 	 */
 	public SelectLockingStrategy(Lockable lockable, LockMode lockMode) {
 		super( lockable, lockMode );
 	}
 
 	/**
 	 * @see LockingStrategy#lock
 	 */
 	public void lock(
 	        Serializable id,
 	        Object version,
 	        Object object,
 	        int timeout, 
 	        SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		final String sql = determineSql( timeout );
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				getLockable().getIdentifierType().nullSafeSet( st, id, 1, session );
 				if ( getLockable().isVersioned() ) {
 					getLockable().getVersionType().nullSafeSet(
 							st,
 							version,
 							getLockable().getIdentifierType().getColumnSpan( factory ) + 1,
 							session
 					);
 				}
 
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						if ( factory.getStatistics().isStatisticsEnabled() ) {
 							factory.getStatisticsImplementor()
 									.optimisticFailure( getLockable().getEntityName() );
 						}
 						throw new StaleObjectStateException( getLockable().getEntityName(), id );
 					}
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not lock: " + MessageHelper.infoString( getLockable(), id, session.getFactory() ),
 					sql
 				);
 		}
 	}
 
 	protected String generateLockString(int timeout) {
 		SessionFactoryImplementor factory = getLockable().getFactory();
 		LockOptions lockOptions = new LockOptions( getLockMode() );
 		lockOptions.setTimeOut( timeout );
 		SimpleSelect select = new SimpleSelect( factory.getDialect() )
 				.setLockOptions( lockOptions )
 				.setTableName( getLockable().getRootTableName() )
 				.addColumn( getLockable().getRootTableIdentifierColumnNames()[0] )
 				.addCondition( getLockable().getRootTableIdentifierColumnNames(), "=?" );
 		if ( getLockable().isVersioned() ) {
 			select.addCondition( getLockable().getVersionColumnName(), "=?" );
 		}
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			select.setComment( getLockMode() + " lock " + getLockable().getEntityName() );
 		}
 		return select.toStatementString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/UpdateLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/UpdateLockingStrategy.java
index a8c7e2b47d..d68b79b0a7 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/UpdateLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/UpdateLockingStrategy.java
@@ -1,144 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.LockMode;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Update;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * A locking strategy where the locks are obtained through update statements.
  * <p/>
  * This strategy is not valid for read style locks.
  *
  * @since 3.2
  *
  * @author Steve Ebersole
  */
 public class UpdateLockingStrategy implements LockingStrategy {
 	private static final Logger log = LoggerFactory.getLogger( UpdateLockingStrategy.class );
 
 	private final Lockable lockable;
 	private final LockMode lockMode;
 	private final String sql;
 
 	/**
 	 * Construct a locking strategy based on SQL UPDATE statements.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indictates the type of lock to be acquired.  Note that
 	 * read-locks are not valid for this strategy.
 	 */
 	public UpdateLockingStrategy(Lockable lockable, LockMode lockMode) {
 		this.lockable = lockable;
 		this.lockMode = lockMode;
 		if ( lockMode.lessThan( LockMode.UPGRADE ) ) {
 			throw new HibernateException( "[" + lockMode + "] not valid for update statement" );
 		}
 		if ( !lockable.isVersioned() ) {
 			log.warn( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 			this.sql = null;
 		}
 		else {
 			this.sql = generateLockString();
 		}
 	}
 
 	/**
 	 * @see LockingStrategy#lock
 	 */
 	public void lock(
 	        Serializable id,
 	        Object version,
 	        Object object,
 	        int timeout,
 	        SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		if ( !lockable.isVersioned() ) {
 			throw new HibernateException( "write locks via update not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 		}
 		// todo : should we additionally check the current isolation mode explicitly?
 		SessionFactoryImplementor factory = session.getFactory();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				lockable.getVersionType().nullSafeSet( st, version, 1, session );
 				int offset = 2;
 
 				lockable.getIdentifierType().nullSafeSet( st, id, offset, session );
 				offset += lockable.getIdentifierType().getColumnSpan( factory );
 
 				if ( lockable.isVersioned() ) {
 					lockable.getVersionType().nullSafeSet( st, version, offset, session );
 				}
 
 				int affected = st.executeUpdate();
 				if ( affected < 0 ) {
 					factory.getStatisticsImplementor().optimisticFailure( lockable.getEntityName() );
 					throw new StaleObjectStateException( lockable.getEntityName(), id );
 				}
 
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not lock: " + MessageHelper.infoString( lockable, id, session.getFactory() ),
 			        sql
 			);
 		}
 	}
 
 	protected String generateLockString() {
 		SessionFactoryImplementor factory = lockable.getFactory();
 		Update update = new Update( factory.getDialect() );
 		update.setTableName( lockable.getRootTableName() );
 		update.addPrimaryKeyColumns( lockable.getRootTableIdentifierColumnNames() );
 		update.setVersionColumnName( lockable.getVersionColumnName() );
 		update.addColumn( lockable.getVersionColumnName() );
 		if ( factory.getSettings().isCommentsEnabled() ) {
 			update.setComment( lockMode + " lock " + lockable.getEntityName() );
 		}
 		return update.toStatementString();
 	}
 
 	protected LockMode getLockMode() {
 		return lockMode;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/ActionQueue.java b/hibernate-core/src/main/java/org/hibernate/engine/ActionQueue.java
index 56b5bcb939..92c8709fa5 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/ActionQueue.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/ActionQueue.java
@@ -1,733 +1,733 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.action.AfterTransactionCompletionProcess;
 import org.hibernate.action.BeforeTransactionCompletionProcess;
 import org.hibernate.action.BulkOperationCleanupAction;
 import org.hibernate.action.CollectionRecreateAction;
 import org.hibernate.action.CollectionRemoveAction;
 import org.hibernate.action.CollectionUpdateAction;
 import org.hibernate.action.EntityDeleteAction;
 import org.hibernate.action.EntityIdentityInsertAction;
 import org.hibernate.action.EntityInsertAction;
 import org.hibernate.action.EntityUpdateAction;
 import org.hibernate.action.Executable;
 import org.hibernate.cache.CacheException;
 import org.hibernate.type.Type;
 
 /**
  * Responsible for maintaining the queue of actions related to events.
  * </p>
  * The ActionQueue holds the DML operations queued as part of a session's
  * transactional-write-behind semantics.  DML operations are queued here
  * until a flush forces them to be executed against the database.
  *
  * @author Steve Ebersole
  */
 public class ActionQueue {
 
 	private static final Logger log = LoggerFactory.getLogger( ActionQueue.class );
 	private static final int INIT_QUEUE_LIST_SIZE = 5;
 
 	private SessionImplementor session;
 
 	// Object insertions, updates, and deletions have list semantics because
 	// they must happen in the right order so as to respect referential
 	// integrity
 	private ArrayList insertions;
 	private ArrayList deletions;
 	private ArrayList updates;
 	// Actually the semantics of the next three are really "Bag"
 	// Note that, unlike objects, collection insertions, updates,
 	// deletions are not really remembered between flushes. We
 	// just re-use the same Lists for convenience.
 	private ArrayList collectionCreations;
 	private ArrayList collectionUpdates;
 	private ArrayList collectionRemovals;
 
 	private AfterTransactionCompletionProcessQueue afterTransactionProcesses;
 	private BeforeTransactionCompletionProcessQueue beforeTransactionProcesses;
 
 	/**
 	 * Constructs an action queue bound to the given session.
 	 *
 	 * @param session The session "owning" this queue.
 	 */
 	public ActionQueue(SessionImplementor session) {
 		this.session = session;
 		init();
 	}
 
 	private void init() {
 		insertions = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		deletions = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		updates = new ArrayList( INIT_QUEUE_LIST_SIZE );
 
 		collectionCreations = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		collectionRemovals = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		collectionUpdates = new ArrayList( INIT_QUEUE_LIST_SIZE );
 
 		afterTransactionProcesses = new AfterTransactionCompletionProcessQueue( session );
 		beforeTransactionProcesses = new BeforeTransactionCompletionProcessQueue( session );
 	}
 
 	public void clear() {
 		updates.clear();
 		insertions.clear();
 		deletions.clear();
 
 		collectionCreations.clear();
 		collectionRemovals.clear();
 		collectionUpdates.clear();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityInsertAction action) {
 		insertions.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityDeleteAction action) {
 		deletions.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityUpdateAction action) {
 		updates.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionRecreateAction action) {
 		collectionCreations.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionRemoveAction action) {
 		collectionRemovals.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionUpdateAction action) {
 		collectionUpdates.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityIdentityInsertAction insert) {
 		insertions.add( insert );
 	}
 
 	public void addAction(BulkOperationCleanupAction cleanupAction) {
 		registerCleanupActions( cleanupAction );
 	}
 
 	public void registerProcess(AfterTransactionCompletionProcess process) {
 		afterTransactionProcesses.register( process );
 	}
 
 	public void registerProcess(BeforeTransactionCompletionProcess process) {
 		beforeTransactionProcesses.register( process );
 	}
 
 	/**
 	 * Perform all currently queued entity-insertion actions.
 	 *
 	 * @throws HibernateException error executing queued insertion actions.
 	 */
 	public void executeInserts() throws HibernateException {
 		executeActions( insertions );
 	}
 
 	/**
 	 * Perform all currently queued actions.
 	 *
 	 * @throws HibernateException error executing queued actions.
 	 */
 	public void executeActions() throws HibernateException {
 		executeActions( insertions );
 		executeActions( updates );
 		executeActions( collectionRemovals );
 		executeActions( collectionUpdates );
 		executeActions( collectionCreations );
 		executeActions( deletions );
 	}
 
 	/**
 	 * Prepares the internal action queues for execution.
 	 *
 	 * @throws HibernateException error preparing actions.
 	 */
 	public void prepareActions() throws HibernateException {
 		prepareActions( collectionRemovals );
 		prepareActions( collectionUpdates );
 		prepareActions( collectionCreations );
 	}
 
 	/**
 	 * Performs cleanup of any held cache softlocks.
 	 *
 	 * @param success Was the transaction successful.
 	 */
 	public void afterTransactionCompletion(boolean success) {
 		afterTransactionProcesses.afterTransactionCompletion( success );
 	}
 
 	/**
 	 * Execute any registered {@link BeforeTransactionCompletionProcess}
 	 */
 	public void beforeTransactionCompletion() {
 		beforeTransactionProcesses.beforeTransactionCompletion();
 	}
 
 	/**
 	 * Check whether the given tables/query-spaces are to be executed against
 	 * given the currently queued actions.
 	 *
 	 * @param tables The table/query-spaces to check.
 	 *
 	 * @return True if we contain pending actions against any of the given
 	 *         tables; false otherwise.
 	 */
 	public boolean areTablesToBeUpdated(Set tables) {
 		return areTablesToUpdated( updates, tables ) ||
 				areTablesToUpdated( insertions, tables ) ||
 				areTablesToUpdated( deletions, tables ) ||
 				areTablesToUpdated( collectionUpdates, tables ) ||
 				areTablesToUpdated( collectionCreations, tables ) ||
 				areTablesToUpdated( collectionRemovals, tables );
 	}
 
 	/**
 	 * Check whether any insertion or deletion actions are currently queued.
 	 *
 	 * @return True if insertions or deletions are currently queued; false otherwise.
 	 */
 	public boolean areInsertionsOrDeletionsQueued() {
 		return ( insertions.size() > 0 || deletions.size() > 0 );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private static boolean areTablesToUpdated(List actions, Set tableSpaces) {
 		for ( Executable action : (List<Executable>) actions ) {
 			final Serializable[] spaces = action.getPropertySpaces();
 			for ( Serializable space : spaces ) {
 				if ( tableSpaces.contains( space ) ) {
 					if ( log.isDebugEnabled() ) {
 						log.debug( "changes must be flushed to space: " + space );
 					}
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	private void executeActions(List list) throws HibernateException {
 		int size = list.size();
 		for ( int i = 0; i < size; i++ ) {
 			execute( ( Executable ) list.get( i ) );
 		}
 		list.clear();
-		session.getJDBCContext().getConnectionManager().executeBatch();
+		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 	}
 
 	public void execute(Executable executable) {
 		try {
 			executable.execute();
 		}
 		finally {
 			registerCleanupActions( executable );
 		}
 	}
 
 	private void registerCleanupActions(Executable executable) {
 		beforeTransactionProcesses.register( executable.getBeforeTransactionCompletionProcess() );
 		if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
 			final String[] spaces = (String[]) executable.getPropertySpaces();
 			afterTransactionProcesses.addSpacesToInvalidate( spaces );
 			session.getFactory().getUpdateTimestampsCache().preinvalidate( spaces );
 		}
 		afterTransactionProcesses.register( executable.getAfterTransactionCompletionProcess() );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void prepareActions(List queue) throws HibernateException {
 		for ( Executable executable : (List<Executable>) queue ) {
 			executable.beforeExecutions();
 		}
 	}
 
 	/**
 	 * Returns a string representation of the object.
 	 *
 	 * @return a string representation of the object.
 	 */
 	public String toString() {
 		return new StringBuffer()
 				.append( "ActionQueue[insertions=" ).append( insertions )
 				.append( " updates=" ).append( updates )
 				.append( " deletions=" ).append( deletions )
 				.append( " collectionCreations=" ).append( collectionCreations )
 				.append( " collectionRemovals=" ).append( collectionRemovals )
 				.append( " collectionUpdates=" ).append( collectionUpdates )
 				.append( "]" )
 				.toString();
 	}
 
 	public int numberOfCollectionRemovals() {
 		return collectionRemovals.size();
 	}
 
 	public int numberOfCollectionUpdates() {
 		return collectionUpdates.size();
 	}
 
 	public int numberOfCollectionCreations() {
 		return collectionCreations.size();
 	}
 
 	public int numberOfDeletions() {
 		return deletions.size();
 	}
 
 	public int numberOfUpdates() {
 		return updates.size();
 	}
 
 	public int numberOfInsertions() {
 		return insertions.size();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void sortCollectionActions() {
 		if ( session.getFactory().getSettings().isOrderUpdatesEnabled() ) {
 			//sort the updates by fk
 			java.util.Collections.sort( collectionCreations );
 			java.util.Collections.sort( collectionUpdates );
 			java.util.Collections.sort( collectionRemovals );
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void sortActions() {
 		if ( session.getFactory().getSettings().isOrderUpdatesEnabled() ) {
 			//sort the updates by pk
 			java.util.Collections.sort( updates );
 		}
 		if ( session.getFactory().getSettings().isOrderInsertsEnabled() ) {
 			sortInsertActions();
 		}
 	}
 
 	/**
 	 * Order the {@link #insertions} queue such that we group inserts
 	 * against the same entity together (without violating constraints).  The
 	 * original order is generated by cascade order, which in turn is based on
 	 * the directionality of foreign-keys.  So even though we will be changing
 	 * the ordering here, we need to make absolutely certain that we do not
 	 * circumvent this FK ordering to the extent of causing constraint
 	 * violations
 	 */
 	private void sortInsertActions() {
 		new InsertActionSorter().sort();
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public ArrayList cloneDeletions() {
 		return ( ArrayList ) deletions.clone();
 	}
 
 	public void clearFromFlushNeededCheck(int previousCollectionRemovalSize) {
 		collectionCreations.clear();
 		collectionUpdates.clear();
 		updates.clear();
 		// collection deletions are a special case since update() can add
 		// deletions of collections not loaded by the session.
 		for ( int i = collectionRemovals.size() - 1; i >= previousCollectionRemovalSize; i-- ) {
 			collectionRemovals.remove( i );
 		}
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public boolean hasAfterTransactionActions() {
 		return afterTransactionProcesses.processes.size() > 0;
 	}
 
 	public boolean hasBeforeTransactionActions() {
 		return beforeTransactionProcesses.processes.size() > 0;
 	}
 
 	public boolean hasAnyQueuedActions() {
 		return updates.size() > 0 ||
 				insertions.size() > 0 ||
 				deletions.size() > 0 ||
 				collectionUpdates.size() > 0 ||
 				collectionRemovals.size() > 0 ||
 				collectionCreations.size() > 0;
 	}
 
 	/**
 	 * Used by the owning session to explicitly control serialization of the
 	 * action queue
 	 *
 	 * @param oos The stream to which the action queue should get written
 	 *
 	 * @throws IOException Indicates an error writing to the stream
 	 */
 	public void serialize(ObjectOutputStream oos) throws IOException {
 		log.trace( "serializing action-queue" );
 
 		int queueSize = insertions.size();
 		log.trace( "starting serialization of [" + queueSize + "] insertions entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( insertions.get( i ) );
 		}
 
 		queueSize = deletions.size();
 		log.trace( "starting serialization of [" + queueSize + "] deletions entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( deletions.get( i ) );
 		}
 
 		queueSize = updates.size();
 		log.trace( "starting serialization of [" + queueSize + "] updates entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( updates.get( i ) );
 		}
 
 		queueSize = collectionUpdates.size();
 		log.trace( "starting serialization of [" + queueSize + "] collectionUpdates entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionUpdates.get( i ) );
 		}
 
 		queueSize = collectionRemovals.size();
 		log.trace( "starting serialization of [" + queueSize + "] collectionRemovals entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionRemovals.get( i ) );
 		}
 
 		queueSize = collectionCreations.size();
 		log.trace( "starting serialization of [" + queueSize + "] collectionCreations entries" );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionCreations.get( i ) );
 		}
 	}
 
 	/**
 	 * Used by the owning session to explicitly control deserialization of the
 	 * action queue
 	 *
 	 * @param ois The stream from which to read the action queue
 	 * @param session The session to which the action queue belongs
 	 *
 	 * @return The deserialized action queue
 	 *
 	 * @throws IOException indicates a problem reading from the stream
 	 * @throws ClassNotFoundException Generally means we were unable to locate user classes.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public static ActionQueue deserialize(
 			ObjectInputStream ois,
 			SessionImplementor session) throws IOException, ClassNotFoundException {
 		log.trace( "deserializing action-queue" );
 		ActionQueue rtn = new ActionQueue( session );
 
 		int queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] insertions entries" );
 		rtn.insertions = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.insertions.add( ois.readObject() );
 		}
 
 		queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] deletions entries" );
 		rtn.deletions = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.deletions.add( ois.readObject() );
 		}
 
 		queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] updates entries" );
 		rtn.updates = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.updates.add( ois.readObject() );
 		}
 
 		queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] collectionUpdates entries" );
 		rtn.collectionUpdates = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.collectionUpdates.add( ois.readObject() );
 		}
 
 		queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] collectionRemovals entries" );
 		rtn.collectionRemovals = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.collectionRemovals.add( ois.readObject() );
 		}
 
 		queueSize = ois.readInt();
 		log.trace( "starting deserialization of [" + queueSize + "] collectionCreations entries" );
 		rtn.collectionCreations = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			rtn.collectionCreations.add( ois.readObject() );
 		}
 		return rtn;
 	}
 
 	private static class BeforeTransactionCompletionProcessQueue {
 		private SessionImplementor session;
 		private List<BeforeTransactionCompletionProcess> processes = new ArrayList<BeforeTransactionCompletionProcess>();
 
 		private BeforeTransactionCompletionProcessQueue(SessionImplementor session) {
 			this.session = session;
 		}
 
 		public void register(BeforeTransactionCompletionProcess process) {
 			if ( process == null ) {
 				return;
 			}
 			processes.add( process );
 		}
 
 		public void beforeTransactionCompletion() {
 			final int size = processes.size();
 			for ( int i = 0; i < size; i++ ) {
 				try {
 					BeforeTransactionCompletionProcess process = processes.get( i );
 					process.doBeforeTransactionCompletion( session );
 				}
 				catch ( HibernateException he ) {
 					throw he;
 				}
 				catch ( Exception e ) {
 					throw new AssertionFailure( "Unable to perform beforeTransactionCompletion callback", e );
 				}
 			}
 			processes.clear();
 		}
 	}
 
 	private static class AfterTransactionCompletionProcessQueue {
 		private SessionImplementor session;
 		private Set<String> querySpacesToInvalidate = new HashSet<String>();
 		private List<AfterTransactionCompletionProcess> processes
 				= new ArrayList<AfterTransactionCompletionProcess>( INIT_QUEUE_LIST_SIZE * 3 );
 
 		private AfterTransactionCompletionProcessQueue(SessionImplementor session) {
 			this.session = session;
 		}
 
 		public void addSpacesToInvalidate(String[] spaces) {
 			if ( spaces == null ) {
 				return;
 			}
 			for ( int i = 0, max = spaces.length; i < max; i++ ) {
 				addSpaceToInvalidate( spaces[i] );
 			}
 		}
 
 		public void addSpaceToInvalidate(String space) {
 			querySpacesToInvalidate.add( space );
 		}
 
 		public void register(AfterTransactionCompletionProcess process) {
 			if ( process == null ) {
 				return;
 			}
 			processes.add( process );
 		}
 
 		public void afterTransactionCompletion(boolean success) {
 			final int size = processes.size();
 			for ( int i = 0; i < size; i++ ) {
 				try {
 					AfterTransactionCompletionProcess process = processes.get( i );
 					process.doAfterTransactionCompletion( success, session );
 				}
 				catch ( CacheException ce ) {
 					log.error( "could not release a cache lock", ce );
 					// continue loop
 				}
 				catch ( Exception e ) {
 					throw new AssertionFailure( "Exception releasing cache locks", e );
 				}
 			}
 			processes.clear();
 
 			if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
 				session.getFactory().getUpdateTimestampsCache().invalidate(
 						querySpacesToInvalidate.toArray( new String[ querySpacesToInvalidate.size()] )
 				);
 			}
 			querySpacesToInvalidate.clear();
 		}
 	}
 
 	/**
 	 * Sorts the insert actions using more hashes.
 	 *
 	 * @author Jay Erb
 	 */
 	private class InsertActionSorter {
 		// the mapping of entity names to their latest batch numbers.
 		private HashMap latestBatches = new HashMap();
 		private HashMap entityBatchNumber;
 
 		// the map of batch numbers to EntityInsertAction lists
 		private HashMap actionBatches = new HashMap();
 
 		public InsertActionSorter() {
 			//optimize the hash size to eliminate a rehash.
 			entityBatchNumber = new HashMap( insertions.size() + 1, 1.0f );
 		}
 
 		/**
 		 * Sort the insert actions.
 		 */
 		@SuppressWarnings({ "unchecked", "UnnecessaryBoxing" })
 		public void sort() {
 			// the list of entity names that indicate the batch number
 			for ( EntityInsertAction action : (List<EntityInsertAction>) insertions ) {
 				// remove the current element from insertions. It will be added back later.
 				String entityName = action.getEntityName();
 
 				// the entity associated with the current action.
 				Object currentEntity = action.getInstance();
 
 				Integer batchNumber;
 				if ( latestBatches.containsKey( entityName ) ) {
 					// There is already an existing batch for this type of entity.
 					// Check to see if the latest batch is acceptable.
 					batchNumber = findBatchNumber( action, entityName );
 				}
 				else {
 					// add an entry for this type of entity.
 					// we can be assured that all referenced entities have already
 					// been processed,
 					// so specify that this entity is with the latest batch.
 					// doing the batch number before adding the name to the list is
 					// a faster way to get an accurate number.
 
 					batchNumber = Integer.valueOf( actionBatches.size() );
 					latestBatches.put( entityName, batchNumber );
 				}
 				entityBatchNumber.put( currentEntity, batchNumber );
 				addToBatch( batchNumber, action );
 			}
 			insertions.clear();
 
 			// now rebuild the insertions list. There is a batch for each entry in the name list.
 			for ( int i = 0; i < actionBatches.size(); i++ ) {
 				List batch = ( List ) actionBatches.get( new Integer( i ) );
 				for ( Object aBatch : batch ) {
 					EntityInsertAction action = (EntityInsertAction) aBatch;
 					insertions.add( action );
 				}
 			}
 		}
 
 		/**
 		 * Finds an acceptable batch for this entity to be a member as part of the {@link InsertActionSorter}
 		 *
 		 * @param action The action being sorted
 		 * @param entityName The name of the entity affected by the action
 		 *
 		 * @return An appropriate batch number; todo document this process better
 		 */
 		@SuppressWarnings({ "UnnecessaryBoxing", "unchecked" })
 		private Integer findBatchNumber(
 				EntityInsertAction action,
 				String entityName) {
 			// loop through all the associated entities and make sure they have been
 			// processed before the latest
 			// batch associated with this entity type.
 
 			// the current batch number is the latest batch for this entity type.
 			Integer latestBatchNumberForType = ( Integer ) latestBatches.get( entityName );
 
 			// loop through all the associations of the current entity and make sure that they are processed
 			// before the current batch number
 			Object[] propertyValues = action.getState();
 			Type[] propertyTypes = action.getPersister().getClassMetadata()
 					.getPropertyTypes();
 
 			for ( int i = 0; i < propertyValues.length; i++ ) {
 				Object value = propertyValues[i];
 				Type type = propertyTypes[i];
 				if ( type.isEntityType() && value != null ) {
 					// find the batch number associated with the current association, if any.
 					Integer associationBatchNumber = ( Integer ) entityBatchNumber.get( value );
 					if ( associationBatchNumber != null && associationBatchNumber.compareTo( latestBatchNumberForType ) > 0 ) {
 						// create a new batch for this type. The batch number is the number of current batches.
 						latestBatchNumberForType = Integer.valueOf( actionBatches.size() );
 						latestBatches.put( entityName, latestBatchNumberForType );
 						// since this entity will now be processed in the latest possible batch,
 						// we can be assured that it will come after all other associations,
 						// there's not need to continue checking.
 						break;
 					}
 				}
 			}
 			return latestBatchNumberForType;
 		}
 
 		@SuppressWarnings({ "unchecked" })
 		private void addToBatch(Integer batchNumber, EntityInsertAction action) {
 			List actions = ( List ) actionBatches.get( batchNumber );
 
 			if ( actions == null ) {
 				actions = new LinkedList();
 				actionBatches.put( batchNumber, actions );
 			}
 			actions.add( action );
 		}
 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
index 4a8eba6789..a72b2aee50 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
@@ -1,265 +1,260 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine;
 
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.sql.Connection;
 
 import javax.transaction.TransactionManager;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.engine.query.QueryPlanCache;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.cache.QueryCache;
 import org.hibernate.cache.UpdateTimestampsCache;
 import org.hibernate.cache.Region;
 import org.hibernate.cfg.Settings;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
+import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.stat.StatisticsImplementor;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 /**
  * Defines the internal contract between the <tt>SessionFactory</tt> and other parts of
  * Hibernate such as implementors of <tt>Type</tt>.
  *
  * @see org.hibernate.SessionFactory
  * @see org.hibernate.impl.SessionFactoryImpl
  * @author Gavin King
  */
 public interface SessionFactoryImplementor extends Mapping, SessionFactory {
 	/**
 	 * Retrieve the {@link Type} resolver associated with this factory.
 	 *
 	 * @return The type resolver
 	 */
 	public TypeResolver getTypeResolver();
 
 	/**
 	 * Get a copy of the Properties used to configure this session factory.
 	 *
 	 * @return The properties.
 	 */
 	public Properties getProperties();
 
 	/**
 	 * Get the persister for the named entity
 	 *
 	 * @param entityName The name of the entity for which to retrieve the persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that name.
 	 */
 	public EntityPersister getEntityPersister(String entityName) throws MappingException;
 
 	/**
 	 * Get the persister object for a collection role.
 	 *
 	 * @param role The role (name) of the collection for which to retrieve the
 	 * persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that role.
 	 */
 	public CollectionPersister getCollectionPersister(String role) throws MappingException;
 
 	/**
 	 * Get the JdbcServices.
 	 * @return the JdbcServices
 	 */
 	public JdbcServices getJdbcServices();
 
 	/**
 	 * Get the SQL dialect.
 	 * <p/>
 	 * Shorthand for {@link #getJdbcServices().getDialect()}.{@link JdbcServices#getDialect()}
 	 *
 	 * @return The dialect
 	 */
 	public Dialect getDialect();
 
 	/**
 	 * Get the factory scoped interceptor for this factory.
 	 *
 	 * @return The factory scope interceptor, or null if none.
 	 */
 	public Interceptor getInterceptor();
 
 	public QueryPlanCache getQueryPlanCache();
 
 	/**
 	 * Get the return types of a query
 	 */
 	public Type[] getReturnTypes(String queryString) throws HibernateException;
 
 	/**
 	 * Get the return aliases of a query
 	 */
 	public String[] getReturnAliases(String queryString) throws HibernateException;
 
 	/**
 	 * Get the connection provider
 	 */
 	public ConnectionProvider getConnectionProvider();
 	/**
 	 * Get the names of all persistent classes that implement/extend the given interface/class
 	 */
 	public String[] getImplementors(String className) throws MappingException;
 	/**
 	 * Get a class name, using query language imports
 	 */
 	public String getImportedClassName(String name);
 
-
-	/**
-	 * Get the JTA transaction manager
-	 */
-	public TransactionManager getTransactionManager();
-
-
 	/**
 	 * Get the default query cache
 	 */
 	public QueryCache getQueryCache();
 	/**
 	 * Get a particular named query cache, or the default cache
 	 * @param regionName the name of the cache region, or null for the default query cache
 	 * @return the existing cache, or a newly created cache if none by that region name
 	 */
 	public QueryCache getQueryCache(String regionName) throws HibernateException;
 	
 	/**
 	 * Get the cache of table update timestamps
 	 */
 	public UpdateTimestampsCache getUpdateTimestampsCache();
 	/**
 	 * Statistics SPI
 	 */
 	public StatisticsImplementor getStatisticsImplementor();
 	
 	public NamedQueryDefinition getNamedQuery(String queryName);
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName);
 	public ResultSetMappingDefinition getResultSetMapping(String name);
 
 	/**
 	 * Get the identifier generator for the hierarchy
 	 */
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName);
 	
 	/**
 	 * Get a named second-level cache region
 	 *
 	 * @param regionName The name of the region to retrieve.
 	 * @return The region
 	 */
 	public Region getSecondLevelCacheRegion(String regionName);
 
 	/**
 	 * Get a map of all the second level cache regions currently maintained in
 	 * this session factory.  The map is structured with the region name as the
 	 * key and the {@link Region} instances as the values.
 	 *
 	 * @return The map of regions
 	 */
 	public Map getAllSecondLevelCacheRegions();
 	
 	/**
 	 * Retrieves the SQLExceptionConverter in effect for this SessionFactory.
 	 *
 	 * @return The SQLExceptionConverter for this SessionFactory.
 	 *
 	 */
 	public SQLExceptionConverter getSQLExceptionConverter();
 	   // TODO: deprecate???
 
 	/**
 	 * Retrieves the SQLExceptionHelper in effect for this SessionFactory.
 	 *
 	 * @return The SQLExceptionHelper for this SessionFactory.
 	 *
 	 */
 	public SQLExceptionHelper getSQLExceptionHelper();
 
 	public Settings getSettings();
 
 	/**
 	 * Get a nontransactional "current" session for Hibernate EntityManager
 	 */
 	public org.hibernate.classic.Session openTemporarySession() throws HibernateException;
 
 	/**
 	 * Open a session conforming to the given parameters.  Used mainly by
 	 * {@link org.hibernate.context.JTASessionContext} for current session processing.
 	 *
 	 * @param connection The external jdbc connection to use, if one (i.e., optional).
 	 * @param flushBeforeCompletionEnabled Should the session be auto-flushed
 	 * prior to transaction completion?
 	 * @param autoCloseSessionEnabled Should the session be auto-closed after
 	 * transaction completion?
 	 * @param connectionReleaseMode The release mode for managed jdbc connections.
 	 * @return An appropriate session.
 	 * @throws HibernateException
 	 */
 	public org.hibernate.classic.Session openSession(
 			final Connection connection,
 			final boolean flushBeforeCompletionEnabled,
 			final boolean autoCloseSessionEnabled,
 			final ConnectionReleaseMode connectionReleaseMode) throws HibernateException;
 
 	/**
 	 * Retrieves a set of all the collection roles in which the given entity
 	 * is a participant, as either an index or an element.
 	 *
 	 * @param entityName The entity name for which to get the collection roles.
 	 * @return set of all the collection roles in which the given entityName participates.
 	 */
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName);
 
 	public EntityNotFoundDelegate getEntityNotFoundDelegate();
 
 	public SQLFunctionRegistry getSqlFunctionRegistry();
 
 	/**
 	 * Retrieve fetch profile by name.
 	 *
 	 * @param name The name of the profile to retrieve.
 	 * @return The profile definition
 	 */
 	public FetchProfile getFetchProfile(String name);
 
+	public ServiceRegistry getServiceRegistry();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/SessionImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/SessionImplementor.java
index ca3a585439..a566ce401c 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/SessionImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/SessionImplementor.java
@@ -1,362 +1,353 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.CacheMode;
 import org.hibernate.EntityMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.Query;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Transaction;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
 import org.hibernate.collection.PersistentCollection;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.event.EventListeners;
 import org.hibernate.impl.CriteriaImpl;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.type.Type;
 
 
 /**
  * Defines the internal contract between the <tt>Session</tt> and other parts of
  * Hibernate such as implementors of <tt>Type</tt> or <tt>EntityPersister</tt>.
  *
  * @see org.hibernate.Session the interface to the application
  * @see org.hibernate.impl.SessionImpl the actual implementation
  * @author Gavin King
  */
 public interface SessionImplementor extends Serializable {
 
 	/**
 	 * Retrieves the interceptor currently in use by this event source.
 	 *
 	 * @return The interceptor.
 	 */
 	public Interceptor getInterceptor();
 	
 	/**
 	 * Enable/disable automatic cache clearing from after transaction
 	 * completion (for EJB3)
 	 */
 	public void setAutoClear(boolean enabled);
 		
 	/**
 	 * Does this <tt>Session</tt> have an active Hibernate transaction
 	 * or is there a JTA transaction in progress?
 	 */
 	public boolean isTransactionInProgress();
 
 	/**
 	 * Initialize the collection (if not already initialized)
 	 */
 	public void initializeCollection(PersistentCollection collection, boolean writing) 
 	throws HibernateException;
 	
 	/**
 	 * Load an instance without checking if it was deleted. 
 	 * 
 	 * When <tt>nullable</tt> is disabled this method may create a new proxy or 
 	 * return an existing proxy; if it does not exist, throw an exception.
 	 * 
 	 * When <tt>nullable</tt> is enabled, the method does not create new proxies 
 	 * (but might return an existing proxy); if it does not exist, return 
 	 * <tt>null</tt>.
 	 * 
 	 * When <tt>eager</tt> is enabled, the object is eagerly fetched
 	 */
 	public Object internalLoad(String entityName, Serializable id, boolean eager, boolean nullable) 
 	throws HibernateException;
 
 	/**
 	 * Load an instance immediately. This method is only called when lazily initializing a proxy.
 	 * Do not return the proxy.
 	 */
 	public Object immediateLoad(String entityName, Serializable id) throws HibernateException;
 
 	/**
 	 * System time before the start of the transaction
 	 */
 	public long getTimestamp();
 	/**
 	 * Get the creating <tt>SessionFactoryImplementor</tt>
 	 */
 	public SessionFactoryImplementor getFactory();
 
 	/**
 	 * Execute a <tt>find()</tt> query
 	 */
 	public List list(String query, QueryParameters queryParameters) throws HibernateException;
 	/**
 	 * Execute an <tt>iterate()</tt> query
 	 */
 	public Iterator iterate(String query, QueryParameters queryParameters) throws HibernateException;
 	/**
 	 * Execute a <tt>scroll()</tt> query
 	 */
 	public ScrollableResults scroll(String query, QueryParameters queryParameters) throws HibernateException;
 	/**
 	 * Execute a criteria query
 	 */
 	public ScrollableResults scroll(CriteriaImpl criteria, ScrollMode scrollMode);
 	/**
 	 * Execute a criteria query
 	 */
 	public List list(CriteriaImpl criteria);
 	
 	/**
 	 * Execute a filter
 	 */
 	public List listFilter(Object collection, String filter, QueryParameters queryParameters) throws HibernateException;
 	/**
 	 * Iterate a filter
 	 */
 	public Iterator iterateFilter(Object collection, String filter, QueryParameters queryParameters) throws HibernateException;
 	
 	/**
 	 * Get the <tt>EntityPersister</tt> for any instance
 	 * @param entityName optional entity name
 	 * @param object the entity instance
 	 */
 	public EntityPersister getEntityPersister(String entityName, Object object) throws HibernateException;
 	
 	/**
 	 * Get the entity instance associated with the given <tt>Key</tt>,
 	 * calling the Interceptor if necessary
 	 */
 	public Object getEntityUsingInterceptor(EntityKey key) throws HibernateException;
 
 	/**
-	 * Notify the session that the transaction completed, so we no longer
-	 * own the old locks. (Also we should release cache softlocks.) May
-	 * be called multiple times during the transaction completion process.
-	 * Also called after an autocommit, in which case the second argument
-	 * is null.
-	 */
-	public void afterTransactionCompletion(boolean successful, Transaction tx);
-	
-	/**
-	 * Notify the session that the transaction is about to complete
-	 */
-	public void beforeTransactionCompletion(Transaction tx);
-
-	/**
 	 * Return the identifier of the persistent object, or null if 
 	 * not associated with the session
 	 */
 	public Serializable getContextEntityIdentifier(Object object);
 
 	/**
 	 * The best guess entity name for an entity not in an association
 	 */
 	public String bestGuessEntityName(Object object);
 	
 	/**
 	 * The guessed entity name for an entity not in an association
 	 */
 	public String guessEntityName(Object entity) throws HibernateException;
 	
 	/** 
 	 * Instantiate the entity class, initializing with the given identifier
 	 */
 	public Object instantiate(String entityName, Serializable id) throws HibernateException;
 	
 	/**
 	 * Execute an SQL Query
 	 */
 	public List listCustomQuery(CustomQuery customQuery, QueryParameters queryParameters) 
 	throws HibernateException;
 	
 	/**
 	 * Execute an SQL Query
 	 */
 	public ScrollableResults scrollCustomQuery(CustomQuery customQuery, QueryParameters queryParameters) 
 	throws HibernateException;
 
 	/**
 	 * Execute a native SQL query, and return the results as a fully built list.
 	 *
 	 * @param spec The specification of the native SQL query to execute.
 	 * @param queryParameters The parameters by which to perform the execution.
 	 * @return The result list.
 	 * @throws HibernateException
 	 */
 	public List list(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 	throws HibernateException;
 
 	/**
 	 * Execute a native SQL query, and return the results as a scrollable result.
 	 *
 	 * @param spec The specification of the native SQL query to execute.
 	 * @param queryParameters The parameters by which to perform the execution.
 	 * @return The resulting scrollable result.
 	 * @throws HibernateException
 	 */
 	public ScrollableResults scroll(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 	throws HibernateException;
 
 	/**
 	 * Retreive the currently set value for a filter parameter.
 	 *
 	 * @param filterParameterName The filter parameter name in the format
 	 * {FILTER_NAME.PARAMETER_NAME}.
 	 * @return The filter parameter value.
 	 * @deprecated use #getLoadQueryInfluencers instead
 	 */
 	public Object getFilterParameterValue(String filterParameterName);
 
 	/**
 	 * Retreive the type for a given filter parrameter.
 	 *
 	 * @param filterParameterName The filter parameter name in the format
 	 * {FILTER_NAME.PARAMETER_NAME}.
 	 * @return The filter param type
 	 * @deprecated use #getLoadQueryInfluencers instead
 	 */
 	public Type getFilterParameterType(String filterParameterName);
 
 	/**
 	 * Return the currently enabled filters.  The filter map is keyed by filter
 	 * name, with values corresponding to the {@link org.hibernate.impl.FilterImpl}
 	 * instance.
 	 * @return The currently enabled filters.
 	 * @deprecated use #getLoadQueryInfluencers instead
 	 */
 	public Map getEnabledFilters();
 	
 	public int getDontFlushFromFind();
 	
 	/**
 	 * Retrieves the configured event listeners from this event source.
 	 *
 	 * @return The configured event listeners.
 	 */
 	public EventListeners getListeners();
 	
 	//TODO: temporary
 	
 	/**
 	 * Get the persistence context for this session
 	 */
 	public PersistenceContext getPersistenceContext();
 	
 	/**
 	 * Execute a HQL update or delete query
 	 */
 	int executeUpdate(String query, QueryParameters queryParameters) throws HibernateException;
 	
 	/**
 	 * Execute a native SQL update or delete query
 	 */
 	int executeNativeUpdate(NativeSQLQuerySpecification specification, QueryParameters queryParameters) throws HibernateException;
 
 
 	/**
 	 * Return changes to this session that have not been flushed yet.
 	 *
 	 * @return The non-flushed changes.
 	 */
 	public NonFlushedChanges getNonFlushedChanges() throws HibernateException;
 
 	/**
 	 * Apply non-flushed changes from a different session to this session. It is assumed
 	 * that this SessionImpl is "clean" (e.g., has no non-flushed changes, no cached entities,
 	 * no cached collections, no queued actions). The specified NonFlushedChanges object cannot
 	 * be bound to any session.
 	 * <p/>
 	 * @param nonFlushedChanges the non-flushed changes
 	 */
 	public void applyNonFlushedChanges(NonFlushedChanges nonFlushedChanges) throws HibernateException;	
 
 	// copied from Session:
 	
 	public EntityMode getEntityMode();
 	public CacheMode getCacheMode();
 	public void setCacheMode(CacheMode cm);
 	public boolean isOpen();
 	public boolean isConnected();
 	public FlushMode getFlushMode();
 	public void setFlushMode(FlushMode fm);
 	public Connection connection();
 	public void flush();
 	
 	/**
 	 * Get a Query instance for a named query or named native SQL query
 	 */
 	public Query getNamedQuery(String name);
 	/**
 	 * Get a Query instance for a named native SQL query
 	 */
 	public Query getNamedSQLQuery(String name);
 	
 	public boolean isEventSource();
 
 	public void afterScrollOperation();
 
 	/**
 	 * Get the <i>internal</i> fetch profile currently associated with this session.
 	 *
 	 * @return The current internal fetch profile, or null if none currently associated.
 	 * @deprecated use #getLoadQueryInfluencers instead
 	 */
 	public String getFetchProfile();
 
 	/**
 	 * Set the current <i>internal</i> fetch profile for this session.
 	 *
 	 * @param name The internal fetch profile name to use
 	 * @deprecated use #getLoadQueryInfluencers instead
 	 */
 	public void setFetchProfile(String name);
 
-	public JDBCContext getJDBCContext();
+	/**
+	 * Retrieve access to the session's transaction coordinator.
+	 *
+	 * @return The transaction coordinator.
+	 */
+	public TransactionCoordinator getTransactionCoordinator();
 
 	/**
-	 * Determine whether the session is closed.  Provided seperately from
-	 * {@link #isOpen()} as this method does not attempt any JTA synch
+	 * Determine whether the session is closed.  Provided separately from
+	 * {@link #isOpen()} as this method does not attempt any JTA synchronization
 	 * registration, where as {@link #isOpen()} does; which makes this one
 	 * nicer to use for most internal purposes.
 	 *
 	 * @return True if the session is closed; false otherwise.
 	 */
 	public boolean isClosed();
 
 	/**
 	 * Get the load query influencers associated with this session.
 	 *
 	 * @return the load query influencers associated with this session;
 	 * should never be null.
 	 */
 	public LoadQueryInfluencers getLoadQueryInfluencers();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/TransactionHelper.java b/hibernate-core/src/main/java/org/hibernate/engine/TransactionHelper.java
index 0c7df45cdc..d820594a9a 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/TransactionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/TransactionHelper.java
@@ -1,76 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.engine;
 
+import org.hibernate.HibernateException;
+import org.hibernate.jdbc.Work;
+
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 
-import org.hibernate.HibernateException;
-import org.hibernate.engine.transaction.IsolatedWork;
-import org.hibernate.engine.transaction.Isolater;
-import org.hibernate.exception.JDBCExceptionHelper;
-
 /**
  * Allows work to be done outside the current transaction, by suspending it,
  * and performing work in a new transaction
  * 
  * @author Emmanuel Bernard
  */
 public abstract class TransactionHelper {
 
-	// todo : remove this and just have subclasses use Isolater/IsolatedWork directly...
+	// todo : remove this and just have subclasses use IsolationDelegate directly...
 
 	/**
 	 * The work to be done
 	 */
 	protected abstract Serializable doWorkInCurrentTransaction(Connection conn, String sql) throws SQLException;
 
 	/**
 	 * Suspend the current transaction and perform work in a new transaction
 	 */
-	public Serializable doWorkInNewTransaction(final SessionImplementor session)
-	throws HibernateException {
-		class Work implements IsolatedWork {
+	public Serializable doWorkInNewTransaction(final SessionImplementor session) throws HibernateException {
+		class WorkToDo implements Work {
 			Serializable generatedValue;
-			public void doWork(Connection connection) throws HibernateException {
+
+			@Override
+			public void execute(Connection connection) throws SQLException {
 				String sql = null;
 				try {
 					generatedValue = doWorkInCurrentTransaction( connection, sql );
 				}
-				catch( SQLException sqle ) {
+				catch( SQLException e ) {
 					throw session.getFactory().getSQLExceptionHelper().convert(
-							sqle,
+							e,
 							"could not get or update next value",
 							sql
-						);
+					);
 				}
 			}
 		}
-		Work work = new Work();
-		Isolater.doIsolatedWork( work, session );
+		WorkToDo work = new WorkToDo();
+		session.getTransactionCoordinator().getTransaction().createIsolationDelegate().delegateWork( work, true );
 		return work.generatedValue;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/AbstractBatchImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/AbstractBatchImpl.java
index 5d171f4a38..a0c4bd2b97 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/AbstractBatchImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/AbstractBatchImpl.java
@@ -1,208 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.internal;
 
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
 import org.hibernate.engine.jdbc.batch.spi.BatchObserver;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 
 /**
  * Convenience base class for implementors of the Batch interface.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractBatchImpl implements Batch {
 	private static final Logger log = LoggerFactory.getLogger( AbstractBatchImpl.class );
 
-	private final SQLStatementLogger statementLogger;
-	private final SQLExceptionHelper exceptionHelper;
-	private Object key;
+	private final BatchKey key;
+	private final JdbcCoordinator jdbcCoordinator;
 	private LinkedHashMap<String,PreparedStatement> statements = new LinkedHashMap<String,PreparedStatement>();
 	private LinkedHashSet<BatchObserver> observers = new LinkedHashSet<BatchObserver>();
 
-	protected AbstractBatchImpl(Object key,
-								SQLStatementLogger statementLogger,
-								SQLExceptionHelper exceptionHelper) {
-		if ( key == null || statementLogger == null || exceptionHelper == null ) {
-			throw new IllegalArgumentException( "key, statementLogger, and exceptionHelper must be non-null." );
+	protected AbstractBatchImpl(BatchKey key, JdbcCoordinator jdbcCoordinator) {
+		if ( key == null ) {
+			throw new IllegalArgumentException( "batch key cannot be null" );
+		}
+		if ( jdbcCoordinator == null ) {
+			throw new IllegalArgumentException( "JDBC coordinator cannot be null" );
 		}
 		this.key = key;
-		this.statementLogger = statementLogger;
-		this.exceptionHelper = exceptionHelper;
+		this.jdbcCoordinator = jdbcCoordinator;
 	}
 
 	/**
 	 * Perform batch execution.
 	 * <p/>
 	 * This is called from the explicit {@link #execute() execution}, but may also be called from elsewhere
 	 * depending on the exact implementation.
 	 */
 	protected abstract void doExecuteBatch();
 
 	/**
 	 * Convenience access to the SQLException helper.
 	 *
 	 * @return The underlying SQLException helper.
 	 */
-	protected SQLExceptionHelper getSqlExceptionHelper() {
-		return exceptionHelper;
+	protected SQLExceptionHelper sqlExceptionHelper() {
+		return jdbcCoordinator.getTransactionCoordinator()
+				.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJdbcServices()
+				.getSqlExceptionHelper();
 	}
 
 	/**
 	 * Convenience access to the SQL statement logger.
 	 *
 	 * @return The underlying JDBC services.
 	 */
-	protected SQLStatementLogger getSqlStatementLogger() {
-		return statementLogger;
+	protected SQLStatementLogger sqlStatementLogger() {
+		return jdbcCoordinator.getTransactionCoordinator()
+				.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJdbcServices()
+				.getSqlStatementLogger();
 	}
 
 	/**
 	 * Access to the batch's map of statements (keyed by SQL statement string).
 	 *
 	 * @return This batch's statements.
 	 */
 	protected LinkedHashMap<String,PreparedStatement> getStatements() {
 		return statements;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public final Object getKey() {
+	@Override
+	public final BatchKey getKey() {
 		return key;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public void addObserver(BatchObserver observer) {
 		observers.add( observer );
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public final PreparedStatement getBatchStatement(Object key, String sql) {
-		checkConsistentBatchKey( key );
+	@Override
+	public PreparedStatement getBatchStatement(String sql, boolean callable) {
 		if ( sql == null ) {
 			throw new IllegalArgumentException( "sql must be non-null." );
 		}
 		PreparedStatement statement = statements.get( sql );
-		if ( statement != null ) {
-			log.debug( "reusing prepared statement" );
-			statementLogger.logStatement( sql );
-		}		
-		return statement;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	// TODO: should this be final???
-	@Override
-	public void addBatchStatement(Object key, String sql, PreparedStatement preparedStatement) {
-		checkConsistentBatchKey( key );
-		if ( sql == null ) {
-			throw new IllegalArgumentException( "sql must be non-null." );
+		if ( statement == null ) {
+			statement = buildBatchStatement( sql, callable );
+			statements.put( sql, statement );
 		}
-		if ( statements.put( sql, preparedStatement ) != null ) {
-			log.error( "PreparedStatement was already in the batch, [" + sql + "]." );
+		else {
+			log.debug( "reusing batch statement" );
+			sqlStatementLogger().logStatement( sql );
 		}
+		return statement;
 	}
 
-	protected void checkConsistentBatchKey(Object key) {
-		if ( ! this.key.equals( key ) ) {
-			throw new IllegalStateException(
-					"specified key ["+ key + "] is different from internal batch key [" + this.key + "]."
-			);
+	private PreparedStatement buildBatchStatement(String sql, boolean callable) {
+		try {
+			if ( callable ) {
+				return jdbcCoordinator.getLogicalConnection().getShareableConnectionProxy().prepareCall( sql );
+			}
+			else {
+				return jdbcCoordinator.getLogicalConnection().getShareableConnectionProxy().prepareStatement( sql );
+			}
+		}
+		catch ( SQLException sqle ) {
+			log.error( "sqlexception escaped proxy", sqle );
+			throw sqlExceptionHelper().convert( sqle, "could not prepare batch statement", sql );
 		}
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public final void execute() {
 		notifyObserversExplicitExecution();
 		if ( statements.isEmpty() ) {
 			return;
 		}
 		try {
 			try {
 				doExecuteBatch();
 			}
 			finally {
-				release();
+				releaseStatements();
 			}
 		}
 		finally {
 			statements.clear();
 		}
 	}
 
 	private void releaseStatements() {
 		for ( PreparedStatement statement : getStatements().values() ) {
 			try {
 				statement.close();
 			}
 			catch ( SQLException e ) {
-				log.error( "unable to release batch statement..." );
-				log.error( "sqlexception escaped proxy", e );
+				log.error( "unable to release batch statement; sqlexception escaped proxy", e );
 			}
 		}
 		getStatements().clear();
 	}
 
-	private void notifyObserversExplicitExecution() {
+	/**
+	 * Convenience method to notify registered observers of an explicit execution of this batch.
+	 */
+	protected final void notifyObserversExplicitExecution() {
 		for ( BatchObserver observer : observers ) {
 			observer.batchExplicitlyExecuted();
 		}
 	}
 
 	/**
 	 * Convenience method to notify registered observers of an implicit execution of this batch.
 	 */
-	protected void notifyObserversImplicitExecution() {
+	protected final void notifyObserversImplicitExecution() {
 		for ( BatchObserver observer : observers ) {
 			observer.batchImplicitlyExecuted();
 		}
 	}
 
+	@Override
 	public void release() {
 		if ( getStatements() != null && !getStatements().isEmpty() ) {
 			log.info( "On release of batch it still contained JDBC statements" );
 		}
 		releaseStatements();
 		observers.clear();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BasicBatchKey.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BasicBatchKey.java
new file mode 100644
index 0000000000..0cff7e330a
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BasicBatchKey.java
@@ -0,0 +1,89 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.batch.internal;
+
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.jdbc.Expectation;
+
+/**
+ * @author Steve Ebersole
+ */
+public class BasicBatchKey implements BatchKey {
+	private final String comparison;
+	private final int statementCount;
+	private final Expectation expectation;
+
+//	public BasicBatchKey(String comparison, int statementCount, Expectation expectation) {
+//		this.comparison = comparison;
+//		this.statementCount = statementCount;
+//		this.expectations = new Expectation[statementCount];
+//		Arrays.fill( this.expectations, expectation );
+//	}
+//
+//	public BasicBatchKey(String comparison, Expectation... expectations) {
+//		this.comparison = comparison;
+//		this.statementCount = expectations.length;
+//		this.expectations = expectations;
+//	}
+
+	public BasicBatchKey(String comparison, Expectation expectation) {
+		this.comparison = comparison;
+		this.statementCount = 1;
+		this.expectation = expectation;
+	}
+
+	@Override
+	public Expectation getExpectation() {
+		return expectation;
+	}
+
+	@Override
+	public int getBatchedStatementCount() {
+		return statementCount;
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		if ( this == o ) {
+			return true;
+		}
+		if ( o == null || getClass() != o.getClass() ) {
+			return false;
+		}
+
+		BasicBatchKey that = (BasicBatchKey) o;
+
+		if ( !comparison.equals( that.comparison ) ) {
+			return false;
+		}
+
+		return true;
+	}
+
+	@Override
+	public int hashCode() {
+		return comparison.hashCode();
+	}
+
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilder.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderImpl.java
similarity index 59%
rename from hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderImpl.java
index e01a7047b3..71157a798f 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderImpl.java
@@ -1,64 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.internal;
 
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.spi.Configurable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.engine.jdbc.batch.spi.Batch;
-import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
+import java.util.Map;
 
 /**
  * A builder for {@link Batch} instances.
  *
  * @author Steve Ebersole
  */
-public class BatchBuilder {
-	private static final Logger log = LoggerFactory.getLogger( BatchBuilder.class );
+public class BatchBuilderImpl implements BatchBuilder, Configurable {
+	private static final Logger log = LoggerFactory.getLogger( BatchBuilderImpl.class );
 
 	private int size;
 
-	public BatchBuilder() {
+	public BatchBuilderImpl() {
 	}
 
-	public BatchBuilder(int size) {
+	@Override
+	public void configure(Map configurationValues) {
+		size = ConfigurationHelper.getInt( Environment.STATEMENT_BATCH_SIZE, configurationValues, size );
+	}
+
+	public BatchBuilderImpl(int size) {
 		this.size = size;
 	}
 
 	public void setJdbcBatchSize(int size) {
 		this.size = size;
 	}
 
-	public Batch buildBatch(Object key,
-							SQLStatementLogger statementLogger,
-							SQLExceptionHelper exceptionHelper) {
+	@Override
+	public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {
 		log.trace( "building batch [size={}]", size );
 		return size > 1
-				? new BatchingBatch( key, statementLogger, exceptionHelper, size )
-				: new NonBatchingBatch( key, statementLogger, exceptionHelper );
+				? new BatchingBatch( key, jdbcCoordinator, size )
+				: new NonBatchingBatch( key, jdbcCoordinator );
+	}
+
+	@Override
+	public String getManagementDomain() {
+		return null; // use Hibernate default domain
+	}
+
+	@Override
+	public String getManagementServiceType() {
+		return null;  // use Hibernate default scheme
+	}
+
+	@Override
+	public Object getManagementBean() {
+		return this;
 	}
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java
new file mode 100644
index 0000000000..26b5c4f3bd
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java
@@ -0,0 +1,69 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.batch.internal;
+
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
+import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.service.spi.ServiceException;
+import org.hibernate.service.spi.ServiceInitiator;
+import org.hibernate.service.spi.ServiceRegistry;
+
+import java.util.Map;
+
+/**
+ * @author Steve Ebersole
+ */
+public class BatchBuilderInitiator implements ServiceInitiator<BatchBuilder> {
+	public static final BatchBuilderInitiator INSTANCE = new BatchBuilderInitiator();
+	public static final String BUILDER = "hibernate.jdbc.batch.builder";
+
+	@Override
+	public Class<BatchBuilder> getServiceInitiated() {
+		return BatchBuilder.class;
+	}
+
+	@Override
+	public BatchBuilder initiateService(Map configurationValues, ServiceRegistry registry) {
+		final Object builder = configurationValues.get( BUILDER );
+		if ( builder == null ) {
+			return new BatchBuilderImpl(
+					ConfigurationHelper.getInt( Environment.STATEMENT_BATCH_SIZE, configurationValues, 1 )
+			);
+		}
+
+		if ( BatchBuilder.class.isInstance( builder ) ) {
+			return (BatchBuilder) builder;
+		}
+
+		final String builderClassName = builder.toString();
+		try {
+			return (BatchBuilder) registry.getService( ClassLoaderService.class ).classForName( builderClassName ).newInstance();
+		}
+		catch (Exception e) {
+			throw new ServiceException( "Could not build explicit BatchBuilder [" + builderClassName + "]", e );
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchingBatch.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchingBatch.java
index 9dc1b27020..1b91a78b0a 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchingBatch.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchingBatch.java
@@ -1,195 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.internal;
 
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
+import org.hibernate.HibernateException;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.AssertionFailure;
-import org.hibernate.HibernateException;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
-import org.hibernate.jdbc.Expectation;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.Map;
 
 /**
- * A {@link org.hibernate.engine.jdbc.batch.spi.Batch} implementation which does
- * batching based on a given size.  Once the batch size is reached for a statement
- * in the batch, the entire batch is implicitly executed.
+ * A {@link org.hibernate.engine.jdbc.batch.spi.Batch} implementation which does bathing based on a given size.  Once
+ * the batch size is reached for a statement in the batch, the entire batch is implicitly executed.
  *
  * @author Steve Ebersole
  */
 public class BatchingBatch extends AbstractBatchImpl {
 	private static final Logger log = LoggerFactory.getLogger( BatchingBatch.class );
 
-	private final int batchSize;
+	// IMPL NOTE : Until HHH-5797 is fixed, there will only be 1 statement in a batch
 
-	// TODO: A Map is used for expectations so it is possible to track when a batch
-	// is full (i.e., when the batch for a particular statement exceeds batchSize)
-	// Until HHH-5797 is fixed, there will only be 1 statement in a batch, so it won't
-	// be necessary to track expectations by statement.
-	private Map<String, List<Expectation>>  expectationsBySql;
-	private int maxBatchPosition;
+	private final int batchSize;
+	private int batchPosition;
+	private int statementPosition;
 
-	public BatchingBatch(Object key,
-						 SQLStatementLogger statementLogger,
-						 SQLExceptionHelper exceptionHelper,
-						 int batchSize) {
-		super( key, statementLogger, exceptionHelper );
+	public BatchingBatch(
+			BatchKey key,
+			JdbcCoordinator jdbcCoordinator,
+			int batchSize) {
+		super( key, jdbcCoordinator );
+		if ( ! key.getExpectation().canBeBatched() ) {
+			throw new HibernateException( "attempting to batch an operation which cannot be batched" );
+		}
 		this.batchSize = batchSize;
-		this.expectationsBySql = new HashMap<String, List<Expectation>>();
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public void addToBatch(Object key, String sql, Expectation expectation) {
-		checkConsistentBatchKey( key );
-		if ( sql == null || expectation == null ) {
-			throw new AssertionFailure( "sql or expection was null." );
-		}
-		if ( ! expectation.canBeBatched() ) {
-			throw new HibernateException( "attempting to batch an operation which cannot be batched" );
-		}
-		final PreparedStatement statement = getStatements().get( sql );
+	private String currentStatementSql;
+	private PreparedStatement currentStatement;
+
+	@Override
+	public PreparedStatement getBatchStatement(String sql, boolean callable) {
+		currentStatementSql = sql;
+		currentStatement = super.getBatchStatement( sql, callable );
+		return currentStatement;
+	}
+
+	@Override
+	public void addToBatch() {
 		try {
-			statement.addBatch();
+			currentStatement.addBatch();
 		}
 		catch ( SQLException e ) {
-			log.error( "sqlexception escaped proxy", e );
-			throw getSqlExceptionHelper().convert( e, "could not perform addBatch", sql );
+			log.debug( "sqlexception escaped proxy", e );
+			throw sqlExceptionHelper().convert( e, "could not perform addBatch", currentStatementSql );
 		}
-		List<Expectation> expectations = expectationsBySql.get( sql );
-		if ( expectations == null ) {
-			expectations = new ArrayList<Expectation>( batchSize );
-			expectationsBySql.put( sql, expectations );
-		}
-		expectations.add( expectation );
-		maxBatchPosition = Math.max( maxBatchPosition, expectations.size() );
-
-		// TODO: When HHH-5797 is fixed the following if-block should probably be moved before
-		// adding the batch to the current statement (to detect that we have finished
-		// with the previous entity).
-		if ( maxBatchPosition == batchSize ) {
-			notifyObserversImplicitExecution();
-			doExecuteBatch();
+		statementPosition++;
+		if ( statementPosition >= getKey().getBatchedStatementCount() ) {
+			batchPosition++;
+			if ( batchPosition == batchSize ) {
+				notifyObserversImplicitExecution();
+				performExecution();
+				batchPosition = 0;
+			}
+			statementPosition = 0;
 		}
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	protected void doExecuteBatch() {
-		if ( maxBatchPosition == 0 ) {
+		if ( batchPosition == 0 ) {
 			log.debug( "no batched statements to execute" );
 		}
 		else {
 			if ( log.isDebugEnabled() ) {
-				log.debug( "Executing {} statements with maximum batch size {} ",
-						getStatements().size(), maxBatchPosition
-				);
-			}
-			try {
-				executeStatements();
-			}
-			catch ( RuntimeException re ) {
-				log.error( "Exception executing batch [{}]", re.getMessage() );
-				throw re;
-			}
-			finally {
-				for ( List<Expectation> expectations : expectationsBySql.values() ) {
-					expectations.clear();
-				}				
-				maxBatchPosition = 0;
+				log.debug( "Executing batch size: " + batchPosition );
 			}
+			performExecution();
 		}
 	}
 
-	private void executeStatements() {
-		for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
-			final String sql = entry.getKey();
-			final PreparedStatement statement = entry.getValue();
-			final List<Expectation> expectations = expectationsBySql.get( sql );
-			if ( batchSize < expectations.size() ) {
-				throw new IllegalStateException(
-						"Number of expectations [" + expectations.size() +
-								"] is greater than batch size [" + batchSize +
-								"] for statement [" + sql +
-								"]"
-				);
-			}
-			if ( expectations.size() > 0 ) {
-				if ( log.isDebugEnabled() ) {
-					log.debug( "Executing with batch of size {}: {}", expectations.size(), sql  );
+	private void performExecution() {
+		try {
+			for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
+				try {
+					final PreparedStatement statement = entry.getValue();
+					checkRowCounts( statement.executeBatch(), statement );
 				}
-				executeStatement( sql, statement, expectations );
-				expectations.clear();
-			}
-			else {
-				if ( log.isDebugEnabled() ) {
-					log.debug( "Skipped executing because batch size is 0: ", sql );
+				catch ( SQLException e ) {
+					log.debug( "sqlexception escaped proxy", e );
+					throw sqlExceptionHelper().convert( e, "could not perform addBatch", entry.getKey() );
 				}
 			}
 		}
-	}
-
-	private void executeStatement(String sql, PreparedStatement ps, List<Expectation> expectations) {
-		try {
-			checkRowCounts( sql, ps.executeBatch(), ps, expectations );
+		catch ( RuntimeException re ) {
+			log.error( "Exception executing batch [{}]", re.getMessage() );
+			throw re;
 		}
-		catch ( SQLException e ) {
-			log.error( "sqlexception escaped proxy", e );
-			throw getSqlExceptionHelper()
-					.convert( e, "could not execute statement: " + sql );
+		finally {
+			batchPosition = 0;
 		}
 	}
 
-	private void checkRowCounts(String sql, int[] rowCounts, PreparedStatement ps, List<Expectation> expectations) {
+	private void checkRowCounts(int[] rowCounts, PreparedStatement ps) throws SQLException, HibernateException {
 		int numberOfRowCounts = rowCounts.length;
-		if ( numberOfRowCounts != expectations.size() ) {
+		if ( numberOfRowCounts != batchPosition ) {
 			log.warn( "JDBC driver did not return the expected number of row counts" );
 		}
-		try {
-			for ( int i = 0; i < numberOfRowCounts; i++ ) {
-				expectations.get( i ).verifyOutcome( rowCounts[i], ps, i );
-			}
-		}
-		catch ( SQLException e ) {
-			log.error( "sqlexception escaped proxy", e );
-			throw getSqlExceptionHelper()
-					.convert( e, "row count verification failed for statement: ", sql );
+		for ( int i = 0; i < numberOfRowCounts; i++ ) {
+			getKey().getExpectation().verifyOutcome( rowCounts[i], ps, i );
 		}
 	}
 
-	public void release() {
-		expectationsBySql.clear();
-		maxBatchPosition = 0;
-	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/NonBatchingBatch.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/NonBatchingBatch.java
index 64eb6b116a..9b2e280096 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/NonBatchingBatch.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/NonBatchingBatch.java
@@ -1,71 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.internal;
 
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
-import org.hibernate.jdbc.Expectation;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.Map;
 
 /**
- * An implementation of {@link org.hibernate.engine.jdbc.batch.spi.Batch} which does not perform batching.  It simply executes each statement as it is
- * encountered.
+ * An implementation of {@link org.hibernate.engine.jdbc.batch.spi.Batch} which does not perform batching.  It simply
+ * executes each statement as it is encountered.
  *
  * @author Steve Ebersole
  */
 public class NonBatchingBatch extends AbstractBatchImpl {
 	private static final Logger log = LoggerFactory.getLogger( NonBatchingBatch.class );
 
-	protected NonBatchingBatch(Object key,
-							SQLStatementLogger statementLogger,
-							SQLExceptionHelper exceptionHelper) {
-		super( key, statementLogger, exceptionHelper );
+	protected NonBatchingBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {
+		super( key, jdbcCoordinator );
 	}
 
-	public void addToBatch(Object key, String sql, Expectation expectation) {
-		checkConsistentBatchKey( key );
-		if ( sql == null ) {
-			throw new IllegalArgumentException( "sql must be non-null." );
-		}
+	@Override
+	public void addToBatch() {
 		notifyObserversImplicitExecution();
-		try {
-			final PreparedStatement statement = getStatements().get( sql );
-			final int rowCount = statement.executeUpdate();
-			expectation.verifyOutcome( rowCount, statement, 0 );
-		}
-		catch ( SQLException e ) {
-			log.error( "sqlexception escaped proxy", e );
-			throw getSqlExceptionHelper().convert( e, "could not execute batch statement", sql );
+		for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
+			try {
+				final PreparedStatement statement = entry.getValue();
+				final int rowCount = statement.executeUpdate();
+				getKey().getExpectation().verifyOutcome( rowCount, statement, 0 );
+				try {
+					statement.close();
+				}
+				catch (SQLException e) {
+					log.debug( "Unable to close non-batched batch statement", e );
+				}
+			}
+			catch ( SQLException e ) {
+				log.debug( "sqlexception escaped proxy", e );
+				throw sqlExceptionHelper().convert( e, "could not execute batch statement", entry.getKey() );
+			}
 		}
+		getStatements().clear();
 	}
 
+	@Override
 	protected void doExecuteBatch() {
 		// nothing to do
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/Batch.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/Batch.java
index 7c99332100..3a3ee658bb 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/Batch.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/Batch.java
@@ -1,91 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.spi;
 
 import java.sql.PreparedStatement;
 
 import org.hibernate.jdbc.Expectation;
 
 /**
  * Conceptually models a batch.
  * <p/>
  * Unlike directly in JDBC, here we add the ability to batch together multiple statements at a time.  In the underlying
  * JDBC this correlates to multiple {@link java.sql.PreparedStatement} objects (one for each DML string) maintained within the
  * batch.
  *
  * @author Steve Ebersole
  */
 public interface Batch {
 	/**
 	 * Retrieves the object being used to key (uniquely identify) this batch.
 	 *
 	 * @return The batch key.
 	 */
-	public Object getKey();
+	public BatchKey getKey();
 
 	/**
 	 * Adds an observer to this batch.
 	 *
 	 * @param observer The batch observer.
 	 */
 	public void addObserver(BatchObserver observer);
 
 	/**
-	 * Get a statement which is part of the batch.
+	 * Get a statement which is part of the batch, creating if necessary (and storing for next time).
 	 *
 	 * @param sql The SQL statement.
-	 * @return the prepared statement representing the SQL statement, if the batch contained it;
-	 *         null, otherwise.
-	 */
-	public PreparedStatement getBatchStatement(Object key, String sql);
-
-	/**
-	 * Add a prepared statement to the batch.
+	 * @param callable Is the SQL statement callable?
 	 *
-	 * @param sql The SQL statement.
+	 * @return The prepared statement instance, representing the SQL statement.
 	 */
-	public void addBatchStatement(Object key, String sql, PreparedStatement preparedStatement);
-
+	public PreparedStatement getBatchStatement(String sql, boolean callable);
 
 	/**
 	 * Indicates completion of the current part of the batch.
-	 *
-	 * @param key
-	 * @param sql
-	 * @param expectation The expectation for the part's result.
 	 */
-	public void addToBatch(Object key, String sql, Expectation expectation);
+	public void addToBatch();
 
 	/**
 	 * Execute this batch.
 	 */
 	public void execute();
 
 	/**
 	 * Used to indicate that the batch instance is no longer needed and that, therefore, it can release its
 	 * resources.
 	 */
 	public void release();
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchBuilder.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchBuilder.java
new file mode 100644
index 0000000000..4715c13faa
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchBuilder.java
@@ -0,0 +1,45 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.batch.spi;
+
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.service.spi.Manageable;
+import org.hibernate.service.spi.Service;
+
+/**
+ * A builder for {@link Batch} instances
+ *
+ * @author Steve Ebersole
+ */
+public interface BatchBuilder extends Service, Manageable {
+	/**
+	 * Build a batch.
+	 *
+	 * @param key Value to uniquely identify a batch
+	 * @param jdbcCoordinator The JDBC coordinator with which to coordinate efforts
+	 *
+	 * @return The built batch
+	 */
+	public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchKey.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchKey.java
new file mode 100644
index 0000000000..86e8338cc0
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/spi/BatchKey.java
@@ -0,0 +1,49 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.batch.spi;
+
+import org.hibernate.jdbc.Expectation;
+
+/**
+ * Unique key for batch identification.
+ *
+ * @author Steve Ebersole
+ */
+public interface BatchKey {
+	/**
+	 * How many statements will be in this batch?
+	 * <p/>
+	 * Note that this is distinctly different than the size of the batch.
+	 *
+	 * @return The number of statements.
+	 */
+	public int getBatchedStatementCount();
+
+	/**
+	 * Get the expectation pertaining to the outcome of the {@link Batch} associated with this key.
+	 *
+	 * @return The expectations
+	 */
+	public Expectation getExpectation();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ConnectionManagerImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ConnectionManagerImpl.java
deleted file mode 100644
index dddaa20eca..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ConnectionManagerImpl.java
+++ /dev/null
@@ -1,611 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.engine.jdbc.internal;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.sql.CallableStatement;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Interceptor;
-import org.hibernate.ScrollMode;
-import org.hibernate.engine.SessionFactoryImplementor;
-import org.hibernate.engine.jdbc.batch.internal.BatchBuilder;
-import org.hibernate.engine.jdbc.batch.spi.Batch;
-import org.hibernate.engine.jdbc.spi.ConnectionManager;
-import org.hibernate.engine.jdbc.spi.ConnectionObserver;
-import org.hibernate.jdbc.Expectation;
-
-/**
- * Encapsulates JDBC Connection management logic needed by Hibernate.
- * <p/>
- * The lifecycle is intended to span a logical series of interactions with the
- * database.  Internally, this means the the lifecycle of the Session.
- *
- * @author Steve Ebersole
- */
-public class ConnectionManagerImpl implements ConnectionManager {
-
-	private static final Logger log = LoggerFactory.getLogger( ConnectionManagerImpl.class );
-
-	public static interface Callback extends ConnectionObserver {
-		public boolean isTransactionInProgress();
-	}
-
-	// TODO: check if it's ok to change the method names in Callback
-
-	private transient Interceptor interceptor;
-
-	private final Callback callback;
-	private transient LogicalConnectionImpl logicalConnection;
-	private transient StatementPreparer statementPreparer;
-	private final transient BatchBuilder batchBuilder;
-	private Batch batch;
-
-	/**
-	 * Constructs a ConnectionManager.
-	 * <p/>
-	 * This is the form used internally.
-	 * 
-	 * @param callback An observer for internal state change.
-	 * @param releaseMode The mode by which to release JDBC connections.
-	 * @param suppliedConnection An externally supplied connection.
-	 */ 
-	public ConnectionManagerImpl(
-	        SessionFactoryImplementor factory,
-	        Callback callback,
-	        ConnectionReleaseMode releaseMode,
-	        Connection suppliedConnection,
-	        Interceptor interceptor) {
-		this( factory,
-				callback,
-				interceptor,
-				new LogicalConnectionImpl(
-						suppliedConnection,
-						releaseMode,
-						factory.getJdbcServices(),
-						factory.getStatistics() != null ? factory.getStatisticsImplementor() : null
-				)
-		);
-	}
-
-	/**
-	 * Private constructor used exclusively from custom serialization
-	 */
-	private ConnectionManagerImpl(
-			SessionFactoryImplementor factory,
-			Callback callback,
-			Interceptor interceptor,
-			LogicalConnectionImpl logicalConnection
-	) {
-		this.callback = callback;
-		this.interceptor = interceptor;
-		this.logicalConnection = logicalConnection;
-		this.logicalConnection.addObserver( callback );
-		this.statementPreparer = new StatementPreparer( logicalConnection, factory.getSettings() );
-		this.batchBuilder = factory.getSettings().getBatchBuilder();
-	}
-
-	/**
-	 * Retrieves the connection currently managed by this ConnectionManager.
-	 * <p/>
-	 * Note, that we may need to obtain a connection to return here if a
-	 * connection has either not yet been obtained (non-UserSuppliedConnectionProvider)
-	 * or has previously been aggressively released (if supported in this environment).
-	 *
-	 * @return The current Connection.
-	 *
-	 * @throws HibernateException Indicates a connection is currently not
-	 * available (we are currently manually disconnected).
-	 */
-	@Override
-	public Connection getConnection() throws HibernateException {
-		return logicalConnection.getConnection();
-	}
-
-	@Override
-	public boolean hasBorrowedConnection() {
-		// used from testsuite
-		return logicalConnection.hasBorrowedConnection();
-	}
-
-	public Connection borrowConnection() {
-		return logicalConnection.borrowConnection();
-	}
-
-	@Override
-	public void releaseBorrowedConnection() {
-		logicalConnection.releaseBorrowedConnection();
-	}
-
-	/**
-	 * Is the connection considered "auto-commit"?
-	 *
-	 * @return True if we either do not have a connection, or the connection
-	 * really is in auto-commit mode.
-	 *
-	 * @throws SQLException Can be thrown by the Connection.isAutoCommit() check.
-	 */
-	public boolean isAutoCommit() throws SQLException {
-		return logicalConnection == null ||
-				! logicalConnection.isOpen() ||
-				! logicalConnection.isPhysicallyConnected() ||
-				logicalConnection.getConnection().getAutoCommit();
-	}
-
-	/**
-	 * Will connections be released after each statement execution?
-	 * <p/>
-	 * Connections will be released after each statement if either:<ul>
-	 * <li>the defined release-mode is {@link ConnectionReleaseMode#AFTER_STATEMENT}; or
-	 * <li>the defined release-mode is {@link ConnectionReleaseMode#AFTER_TRANSACTION} but
-	 * we are in auto-commit mode.
-	 * <p/>
-	 * release-mode = {@link ConnectionReleaseMode#ON_CLOSE} should [b]never[/b] release
-	 * a connection.
-	 *
-	 * @return True if the connections will be released after each statement; false otherwise.
-	 */
-	public boolean isAggressiveRelease() {
-		if ( logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_STATEMENT ) {
-			return true;
-		}
-		else if ( logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION ) {
-			boolean inAutoCommitState;
-			try {
-				inAutoCommitState = isAutoCommit() && ! callback.isTransactionInProgress();
-			}
-			catch( SQLException e ) {
-				// assume we are in an auto-commit state
-				inAutoCommitState = true;
-			}
-			return inAutoCommitState;
-		}
-		return false;
-	}
-
-	/**
-	 * Modified version of {@link #isAggressiveRelease} which does not force a
-	 * transaction check.  This is solely used from our {@link #afterTransaction}
-	 * callback, so no need to do the check; plus it seems to cause problems on
-	 * websphere (god i love websphere ;)
-	 * </p>
-	 * It uses this information to decide if an aggressive release was skipped
-	 * do to open resources, and if so forces a release.
-	 *
-	 * @return True if the connections will be released after each statement; false otherwise.
-	 */
-	private boolean isAggressiveReleaseNoTransactionCheck() {
-		if ( logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_STATEMENT ) {
-			return true;
-		}
-		else {
-			boolean inAutoCommitState;
-			try {
-				inAutoCommitState = isAutoCommit();
-			}
-			catch( SQLException e ) {
-				// assume we are in an auto-commit state
-				inAutoCommitState = true;
-			}
-			return logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION && inAutoCommitState;
-		}
-	}
-
-	/**
-	 * Is this ConnectionManager instance "logically" connected.  Meaning
-	 * do we either have a cached connection available or do we have the
-	 * ability to obtain a connection on demand.
-	 *
-	 * @return True if logically connected; false otherwise.
-	 */
-	@Override
-	public boolean isCurrentlyConnected() {
-		return logicalConnection != null && logicalConnection.isLogicallyConnected();
-	}
-
-	/**
-	 * To be called after execution of each JDBC statement.  Used to
-	 * conditionally release the JDBC connection aggressively if
-	 * the configured release mode indicates.
-	 */
-	@Override
-	public void afterStatement() {
-		if ( isAggressiveRelease() ) {
-			logicalConnection.afterStatementExecution();
-		}
-	}
-
-	/**
-	 * To be called after local transaction completion.  Used to conditionally
-	 * release the JDBC connection aggressively if the configured release mode
-	 * indicates.
-	 */
-	public void afterTransaction() {
-		if ( logicalConnection != null ) {
-			if ( isAfterTransactionRelease() || isAggressiveReleaseNoTransactionCheck() ) {
-				logicalConnection.afterTransaction();
-			}
-			else if ( isOnCloseRelease() ) {
-				// log a message about potential connection leaks
-				log.debug( "transaction completed on session with on_close connection release mode; be sure to close the session to release JDBC resources!" );
-			}
-		}
-		if ( statementPreparer != null ) {
-			statementPreparer.unsetTransactionTimeout();
-		}
-	}
-
-	private boolean isAfterTransactionRelease() {
-		return logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION;
-	}
-
-	private boolean isOnCloseRelease() {
-		return logicalConnection.getConnectionReleaseMode() == ConnectionReleaseMode.ON_CLOSE;
-	}
-
-	private boolean isLogicallyConnected() {
-		return logicalConnection != null && logicalConnection.isOpen();
-	}
-
-	@Override
-	public void setTransactionTimeout(int seconds) {
-		statementPreparer.setTransactionTimeout( seconds );
-	}
-
-	/**
-	 * To be called after Session completion.  Used to release the JDBC
-	 * connection.
-	 *
-	 * @return The connection mantained here at time of close.  Null if
-	 * there was no connection cached internally.
-	 */
-	@Override
-	public Connection close() {
-		return cleanup();
-	}
-
-	/**
-	 * Manually disconnect the underlying JDBC Connection.  The assumption here
-	 * is that the manager will be reconnected at a later point in time.
-	 *
-	 * @return The connection mantained here at time of disconnect.  Null if
-	 * there was no connection cached internally.
-	 */
-	@Override
-	public Connection manualDisconnect() {
-		if ( ! isLogicallyConnected() ) {
-			throw new IllegalStateException( "cannot manually disconnect because not logically connected." );
-		}
-		releaseBatch();
-		return logicalConnection.manualDisconnect();
-	}
-
-	/**
-	 * Manually reconnect the underlying JDBC Connection.  Should be called at
-	 * some point after manualDisconnect().
-	 * <p/>
-	 * This form is used for ConnectionProvider-supplied connections.
-	 */
-	@Override
-	public void manualReconnect() {
-		manualReconnect( null );
-	}
-
-	/**
-	 * Manually reconnect the underlying JDBC Connection.  Should be called at
-	 * some point after manualDisconnect().
-	 * <p/>
-	 * This form is used for user-supplied connections.
-	 */
-	@Override
-	public void manualReconnect(Connection suppliedConnection) {
-		if ( ! isLogicallyConnected() ) {
-			throw new IllegalStateException( "cannot manually disconnect because not logically connected." );
-		}
-		logicalConnection.reconnect( suppliedConnection );
-	}
-
-	/**
-	 * Releases the Connection and cleans up any resources associated with
-	 * that Connection.  This is intended for use:
-	 * 1) at the end of the session
-	 * 2) on a manual disconnect of the session
-	 * 3) from afterTransaction(), in the case of skipped aggressive releasing
-	 *
-	 * @return The released connection.
-	 * @throws HibernateException
-	 */
-	private Connection cleanup() throws HibernateException {
-		if ( logicalConnection == null ) {
-			log.trace( "connection already null in cleanup : no action");
-			return null;
-		}
-		try {
-			log.trace( "performing cleanup" );
-			releaseBatch();
-			statementPreparer.close();
-			Connection c = logicalConnection.close();
-			return c;
-		}
-		finally {
-			batch = null;
-			statementPreparer = null;
-			logicalConnection = null;
-		}
-	}
-
-	/**
-	 * Callback to let us know that a flush is beginning.  We use this fact
-	 * to temporarily circumvent aggressive connection releasing until after
-	 * the flush cycle is complete {@link #flushEnding()}
-	 */
-	@Override
-	public void flushBeginning() {
-		log.trace( "registering flush begin" );
-		logicalConnection.disableReleases();
-	}
-
-	/**
-	 * Callback to let us know that a flush is ending.  We use this fact to
-	 * stop circumventing aggressive releasing connections.
-	 */
-	@Override
-	public void flushEnding() {
-		log.trace( "registering flush end" );
-		logicalConnection.enableReleases();
-		afterStatement();
-	}
-
-	/**
-	 * Get a non-batchable prepared statement to use for inserting / deleting / updating,
-	 * using JDBC3 getGeneratedKeys ({@link java.sql.Connection#prepareStatement(String, int)}).
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()}, it will be
-	 * released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareStatement(String sql, final int autoGeneratedKeys)
-			throws HibernateException {
-		executeBatch();
-		return statementPreparer.prepareStatement( getSQL( sql ), autoGeneratedKeys );
-	}
-
-	/**
-	 * Get a non-batchable prepared statement to use for inserting / deleting / updating.
-	 * using JDBC3 getGeneratedKeys ({@link java.sql.Connection#prepareStatement(String, String[])}).
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()}, it will be
-	 * released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareStatement(String sql, final String[] columnNames) {
-		executeBatch();
-		return statementPreparer.prepareStatement( getSQL( sql ), columnNames );
-	}
-
-	/**
-	 * Get a non-batchable prepared statement to use for selecting. Does not
-	 * result in execution of the current batch.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareSelectStatement(String sql) {
-		return statementPreparer.prepareStatement( getSQL( sql ), false );
-	}
-
-	/**
-	 * Get a non-batchable prepared statement to use for inserting / deleting / updating.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()}, it will be
-	 * released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareStatement(String sql, final boolean isCallable) {
-		executeBatch();
-		return statementPreparer.prepareStatement( getSQL( sql ), isCallable );
-	}
-
-	/**
-	 * Get a non-batchable callable statement to use for inserting / deleting / updating.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()}, it will be
-	 * released when the session is closed or disconnected.
-	 */
-	@Override
-	public CallableStatement prepareCallableStatement(String sql) {
-		executeBatch();
-		log.trace("preparing callable statement");
-		return CallableStatement.class.cast( statementPreparer.prepareStatement( getSQL( sql ), true ) );
-	}
-
-	/**
-	 * Get a batchable prepared statement to use for inserting / deleting / updating
-	 * (might be called many times before a single call to <tt>executeBatch()</tt>).
-	 * After setting parameters, call <tt>addToBatch</tt> - do not execute the
-	 * statement explicitly.
-	 * @see org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()}, it will be
-	 * released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareBatchStatement(Object key, String sql, boolean isCallable) {
-		if ( key == null ) {
-			throw new IllegalArgumentException( "batch key must be non-null." );
-		}
-		String actualSQL = getSQL( sql );
-		PreparedStatement batchUpdate = null;
-		if ( batch != null ) {
-			if ( key.equals( batch.getKey() ) ) {
-				batchUpdate = batch.getBatchStatement( key, actualSQL );
-			}
-			else {
-				batch.execute();
-				batch = null;
-			}
-		}
-		if ( batch == null ) {
-			batch =  batchBuilder.buildBatch(
-					key,
-					logicalConnection.getJdbcServices().getSqlStatementLogger(),
-					logicalConnection.getJdbcServices().getSqlExceptionHelper()
-			);
-		}
-		if ( batchUpdate == null ) {
-			batchUpdate = statementPreparer.prepareStatement( actualSQL, isCallable );
-			batch.addBatchStatement( key, actualSQL, batchUpdate );
-		}
-		return batchUpdate;
-	}
-
-	/**
-	 * Get a prepared statement for use in loading / querying. Does not
-	 * result in execution of the current batch.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 */
-	@Override
-	public PreparedStatement prepareQueryStatement(
-			String sql,
-			final boolean isScrollable,
-			final ScrollMode scrollMode,
-			final boolean isCallable) {
-		PreparedStatement ps = (
-				isScrollable ?
-						statementPreparer.prepareScrollableQueryStatement(
-								getSQL( sql ), scrollMode, isCallable
-						) :
-						statementPreparer.prepareQueryStatement(
-								getSQL( sql ), isCallable
-						)
-		);
-		logicalConnection.getResourceRegistry().registerLastQuery( ps );
-		return ps;
-	}
-
-	/**
-	 * Cancel the current query statement
-	 */
-	@Override
-	public void cancelLastQuery() throws HibernateException {
-		logicalConnection.getResourceRegistry().cancelLastQuery();
-	}
-
-	@Override
-	public void addToBatch(Object batchKey, String sql, Expectation expectation) {
-		batch.addToBatch( batchKey, sql, expectation );
-	}
-
-	@Override
-	public void executeBatch() throws HibernateException {
-		if ( batch != null ) {
-			batch.execute();
-			batch.release(); // needed?
-		}
-	}
-
-	@Override
-	public void abortBatch() {
-		releaseBatch();
-	}
-
-	private void releaseBatch() {
-		if ( batch != null ) {
-			batch.release();
-		}
-	}
-
-	private String getSQL(String sql) {
-		sql = interceptor.onPrepareStatement( sql );
-		if ( sql==null || sql.length() == 0 ) {
-			throw new AssertionFailure( "Interceptor.onPrepareStatement() returned null or empty string." );
-		}
-		return sql;
-	}
-
-	public boolean isReadyForSerialization() {
-		return logicalConnection == null ? true : logicalConnection.isReadyForSerialization();
-	}
-
-	/**
-	 * Used during serialization.
-	 *
-	 * @param oos The stream to which we are being written.
-	 * @throws IOException Indicates an I/O error writing to the stream
-	 */
-	private void writeObject(ObjectOutputStream oos) throws IOException {
-		if ( !isReadyForSerialization() ) {
-			throw new IllegalStateException( "Cannot serialize a ConnectionManager while connected" );
-		}
-		oos.defaultWriteObject();
-	}
-
-	/**
-	 * Used during deserialization.
-	 *
-	 * @param ois The stream from which we are being read.
-	 * @throws IOException Indicates an I/O error reading the stream
-	 * @throws ClassNotFoundException Indicates resource class resolution.
-	 */
-	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
-		ois.defaultReadObject();
-	}
-
-	public void serialize(ObjectOutputStream oos) throws IOException {
-		logicalConnection.serialize( oos );
-	}
-
-	public static ConnectionManagerImpl deserialize(
-			ObjectInputStream ois,
-	        SessionFactoryImplementor factory,
-	        Interceptor interceptor,
-	        ConnectionReleaseMode connectionReleaseMode,
-	        Callback callback) throws IOException {
-		return new ConnectionManagerImpl(
-				factory,
-		        callback,
-				interceptor,
-				LogicalConnectionImpl.deserialize(
-						ois,
-						factory.getJdbcServices(),
-						factory.getStatistics() != null ? factory.getStatisticsImplementor() : null,
-						connectionReleaseMode
-				)
-		);
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JDBCContextImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JDBCContextImpl.java
deleted file mode 100644
index bc3e7fb75a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JDBCContextImpl.java
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.engine.jdbc.internal;
-
-import java.io.ObjectOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.sql.Connection;
-import java.sql.SQLException;
-
-import javax.transaction.TransactionManager;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Interceptor;
-import org.hibernate.SessionException;
-import org.hibernate.Transaction;
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.ConnectionManager;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.transaction.synchronization.CallbackCoordinator;
-import org.hibernate.transaction.synchronization.HibernateSynchronizationImpl;
-import org.hibernate.util.JTAHelper;
-import org.hibernate.engine.SessionFactoryImplementor;
-
-/**
- * Acts as the mediary between "entity-mode related" sessions in terms of
- * their interaction with the JDBC data store.
- *
- * @author Steve Ebersole
- */
-public class JDBCContextImpl implements ConnectionManagerImpl.Callback, JDBCContext {
-
-	// TODO : make this the factory for "entity mode related" sessions;
-	// also means making this the target of transaction-synch and the
-	// thing that knows how to cascade things between related sessions
-	//
-	// At that point, perhaps this thing is a "SessionContext", and
-	// ConnectionManager is a "JDBCContext"?  A "SessionContext" should
-	// live in the impl package...
-
-	private static final Logger log = LoggerFactory.getLogger( JDBCContextImpl.class );
-
-	private Context owner;
-	private ConnectionManagerImpl connectionManager;
-	private transient boolean isTransactionCallbackRegistered;
-	private transient Transaction hibernateTransaction;
-
-	private CallbackCoordinator jtaSynchronizationCallbackCoordinator;
-
-	public JDBCContextImpl(Context owner, Connection connection, Interceptor interceptor) {
-		this.owner = owner;
-		this.connectionManager = new ConnectionManagerImpl(
-		        owner.getFactory(),
-				this,
-		        owner.getConnectionReleaseMode(),
-		        connection,
-		        interceptor
-		);
-
-		final boolean registerSynchronization = owner.isAutoCloseSessionEnabled()
-		        || owner.isFlushBeforeCompletionEnabled()
-		        || owner.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION;
-		if ( registerSynchronization ) {
-			registerSynchronizationIfPossible();
-		}
-	}
-
-	/**
-	 * Private constructor used exclusively for custom serialization...
-	 *
-	 */
-	private JDBCContextImpl() {
-	}
-
-	@Override
-	public CallbackCoordinator getJtaSynchronizationCallbackCoordinator() {
-		return jtaSynchronizationCallbackCoordinator;
-	}
-
-	private CallbackCoordinator getJtaSynchronizationCallbackCoordinator(javax.transaction.Transaction jtaTransaction) {
-		jtaSynchronizationCallbackCoordinator = new CallbackCoordinator( owner, this, jtaTransaction, hibernateTransaction );
-		return jtaSynchronizationCallbackCoordinator;
-	}
-
-	@Override
-	public void cleanUpJtaSynchronizationCallbackCoordinator() {
-		jtaSynchronizationCallbackCoordinator = null;
-	}
-
-
-	// ConnectionManager.Callback implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-	@Override
-	public void physicalConnectionObtained(Connection connection) {
-		if ( owner.getFactory().getStatistics().isStatisticsEnabled() ) {
-			owner.getFactory().getStatisticsImplementor().connect();
-		}
-	}
-
-	@Override
-	public void physicalConnectionReleased() {
-		if ( !isTransactionCallbackRegistered ) {
-			afterTransactionCompletion( false, null );
-			// Note : success = false, because we don't know the outcome of the transaction
-		}
-	}
-
-	@Override
-	public void logicalConnectionClosed() {
-		// TODO: anything need to be done?
-	}
-
-	@Override
-	public SessionFactoryImplementor getFactory() {
-		return owner.getFactory();
-	}
-
-	@Override
-	public ConnectionManager getConnectionManager() {
-		return connectionManager;
-	}
-
-	public Connection borrowConnection() {
-		return connectionManager.borrowConnection();
-	}
-	
-	@Override
-	public Connection connection() throws HibernateException {
-		if ( owner.isClosed() ) {
-			throw new SessionException( "Session is closed" );
-		}
-
-		return connectionManager.getConnection();
-	}
-
-	@Override
-	public boolean registerCallbackIfNecessary() {
-		if ( isTransactionCallbackRegistered ) {
-			return false;
-		}
-		else {
-			isTransactionCallbackRegistered = true;
-			return true;
-		}
-
-	}
-
-	@Override
-	public boolean registerSynchronizationIfPossible() {
-		if ( isTransactionCallbackRegistered ) {
-			// we already have a callback registered; either a local
-			// (org.hibernate.Transaction) transaction has accepted
-			// callback responsibilities, or we have previously
-			// registered a transaction synch.
-			return true;
-		}
-		boolean localCallbacksOnly = owner.getFactory().getSettings()
-				.getTransactionFactory()
-				.areCallbacksLocalToHibernateTransactions();
-		if ( localCallbacksOnly ) {
-			// the configured transaction-factory says it only supports
-			// local callback mode, so no sense attempting to register a
-			// JTA Synchronization
-			return false;
-		}
-		TransactionManager tm = owner.getFactory().getTransactionManager();
-		if ( tm == null ) {
-			// if there is no TM configured, we will not be able to access
-			// the javax.transaction.Transaction object in order to
-			// register a synch anyway.
-			return false;
-		}
-		else {
-			try {
-				if ( !isTransactionInProgress() ) {
-					log.trace( "TransactionFactory reported no active transaction; Synchronization not registered" );
-					return false;
-				}
-				else {
-					javax.transaction.Transaction tx = tm.getTransaction();
-					if ( JTAHelper.isMarkedForRollback( tx ) ) {
-						// transactions marked for rollback-only cause some TM impls to throw exceptions
-						log.debug( "Transaction is marked for rollback; skipping Synchronization registration" );
-						return false;
-					}
-					else {
-						if ( hibernateTransaction == null ) {
-							hibernateTransaction = owner.getFactory().getSettings().getTransactionFactory().createTransaction( this, owner );
-						}
-						tx.registerSynchronization(
-								new HibernateSynchronizationImpl( getJtaSynchronizationCallbackCoordinator( tx ) )
-						);
-//						tx.registerSynchronization( new CacheSynchronization(owner, this, tx, hibernateTransaction) );
-						isTransactionCallbackRegistered = true;
-						log.debug("successfully registered Synchronization");
-						return true;
-					}
-				}
-			}
-			catch( HibernateException e ) {
-				throw e;
-			}
-			catch (Exception e) {
-				throw new TransactionException( "could not register synchronization with JTA TransactionManager", e );
-			}
-		}
-	}
-	
-	@Override
-	public boolean isTransactionInProgress() {
-		return owner.getFactory().getSettings().getTransactionFactory()
-				.isTransactionInProgress( this, owner, hibernateTransaction );
-	}
-
-	@Override
-	public Transaction getTransaction() throws HibernateException {
-		if (hibernateTransaction==null) {
-			hibernateTransaction = owner.getFactory().getSettings()
-					.getTransactionFactory()
-					.createTransaction( this, owner );
-		}
-		return hibernateTransaction;
-	}
-	
-	@Override
-	public void beforeTransactionCompletion(Transaction tx) {
-		log.trace( "before transaction completion" );
-		owner.beforeTransactionCompletion(tx);
-	}
-	
-	/**
-	 * We cannot rely upon this method being called! It is only
-	 * called if we are using Hibernate Transaction API.
-	 */
-	@Override
-	public void afterTransactionBegin(Transaction tx) {
-		log.trace( "after transaction begin" );
-		owner.afterTransactionBegin(tx);
-	}
-
-	@Override
-	public void afterTransactionCompletion(boolean success, Transaction tx) {
-		log.trace( "after transaction completion" );
-
-		if ( getFactory().getStatistics().isStatisticsEnabled() ) {
-			getFactory().getStatisticsImplementor().endTransaction(success);
-		}
-
-		connectionManager.afterTransaction();
-
-		isTransactionCallbackRegistered = false;
-		hibernateTransaction = null;
-		owner.afterTransactionCompletion(success, tx);
-	}
-	
-	/**
-	 * Called after executing a query outside the scope of
-	 * a Hibernate or JTA transaction
-	 */
-	@Override
-	public void afterNontransactionalQuery(boolean success) {
-		log.trace( "after autocommit" );
-		try {
-			// check to see if the connection is in auto-commit 
-			// mode (no connection means aggressive connection
-			// release outside a JTA transaction context, so MUST
-			// be autocommit mode)
-			boolean isAutocommit = connectionManager.isAutoCommit();
-
-			connectionManager.afterTransaction();
-			
-			if ( isAutocommit ) {
-				owner.afterTransactionCompletion(success, null);
-			}
-		}
-		catch (SQLException sqle) {
-			throw owner.getFactory().getSQLExceptionHelper().convert(
-					sqle,
-					"could not inspect JDBC autocommit mode"
-				);
-		}
-	}
-
-
-	// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	public boolean isReadyForSerialization() {
-		return connectionManager.isReadyForSerialization();
-	}
-
-	private void writeObject(ObjectOutputStream oos) throws IOException {
-		// isTransactionCallbackRegistered denotes whether any Hibernate
-		// Transaction has registered as a callback against this
-		// JDBCContext; only one such callback is allowed.  Directly
-		// serializing this value causes problems with JDBCTransaction,
-		// or really any Transaction impl where the callback is local
-		// to the Transaction instance itself, since that Transaction
-		// is not serialized along with the JDBCContext.  Thus we
-		// handle that fact here explicitly...
-		oos.defaultWriteObject();
-		boolean deserHasCallbackRegistered = isTransactionCallbackRegistered
-				&& ! owner.getFactory().getSettings().getTransactionFactory()
-				.areCallbacksLocalToHibernateTransactions();
-		oos.writeBoolean( deserHasCallbackRegistered );
-	}
-
-	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
-		ois.defaultReadObject();
-		isTransactionCallbackRegistered = ois.readBoolean();
-	}
-
-	/**
-	 * Custom serialization routine used during serialization of a
-	 * Session/PersistenceContext for increased performance.
-	 *
-	 * @param oos The stream to which we should write the serial data.
-	 * @throws IOException
-	 */
-	public void serialize(ObjectOutputStream oos) throws IOException {
-		connectionManager.serialize( oos );
-	}
-
-	/**
-	 * Custom deserialization routine used during deserialization of a
-	 * Session/PersistenceContext for increased performance.
-	 *
-	 * @param ois The stream from which to read the entry.
-	 * @throws IOException
-	 */
-	public static JDBCContextImpl deserialize(
-			ObjectInputStream ois,
-	        Context context,
-	        Interceptor interceptor) throws IOException, ClassNotFoundException {
-		JDBCContextImpl jdbcContext = new JDBCContextImpl();
-		jdbcContext.owner = context;
-		jdbcContext.connectionManager = ConnectionManagerImpl.deserialize(
-				ois,
-				context.getFactory(),
-				interceptor,
-		        context.getConnectionReleaseMode(),
-		        jdbcContext
-		);
-		return jdbcContext;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcCoordinatorImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcCoordinatorImpl.java
new file mode 100644
index 0000000000..241530c1a6
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcCoordinatorImpl.java
@@ -0,0 +1,236 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.internal;
+
+import org.hibernate.HibernateException;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
+import org.hibernate.engine.jdbc.spi.StatementPreparer;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.jdbc.Work;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.sql.Connection;
+import java.sql.SQLException;
+
+/**
+ * Standard Hibernate implementation of {@link JdbcCoordinator}
+ * <p/>
+ * IMPL NOTE : Custom serialization handling!
+ *
+ * @author Steve Ebersole
+ */
+public class JdbcCoordinatorImpl implements JdbcCoordinator {
+	private static final Logger log = LoggerFactory.getLogger( JdbcCoordinatorImpl.class );
+
+	private transient TransactionCoordinatorImpl transactionCoordinator;
+
+	private final transient LogicalConnectionImpl logicalConnection;
+
+	private transient Batch currentBatch;
+
+	public JdbcCoordinatorImpl(
+			Connection userSuppliedConnection,
+			TransactionCoordinatorImpl transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
+		this.logicalConnection = new LogicalConnectionImpl(
+				userSuppliedConnection,
+				transactionCoordinator.getTransactionContext().getConnectionReleaseMode(),
+				transactionCoordinator.getTransactionContext().getTransactionEnvironment().getJdbcServices()
+		);
+	}
+
+	private JdbcCoordinatorImpl(LogicalConnectionImpl logicalConnection) {
+		this.logicalConnection = logicalConnection;
+	}
+
+	@Override
+	public TransactionCoordinator getTransactionCoordinator() {
+		return transactionCoordinator;
+	}
+
+	@Override
+	public LogicalConnectionImplementor getLogicalConnection() {
+		return logicalConnection;
+	}
+
+	protected TransactionEnvironment transactionEnvironment() {
+		return getTransactionCoordinator().getTransactionContext().getTransactionEnvironment();
+	}
+
+	protected SessionFactoryImplementor sessionFactory() {
+		return transactionEnvironment().getSessionFactory();
+	}
+
+	protected BatchBuilder batchBuilder() {
+		return sessionFactory().getServiceRegistry().getService( BatchBuilder.class );
+	}
+
+	private SQLExceptionHelper sqlExceptionHelper() {
+		return transactionEnvironment().getJdbcServices().getSqlExceptionHelper();
+	}
+
+
+	private int flushDepth = 0;
+
+	@Override
+	public void flushBeginning() {
+		if ( flushDepth == 0 ) {
+			logicalConnection.disableReleases();
+		}
+		flushDepth++;
+	}
+
+	@Override
+	public void flushEnding() {
+		flushDepth--;
+		if ( flushDepth < 0 ) {
+			throw new HibernateException( "Mismatched flush handling" );
+		}
+		if ( flushDepth == 0 ) {
+			logicalConnection.enableReleases();
+		}
+	}
+
+	@Override
+	public Connection close() {
+		if ( currentBatch != null ) {
+			log.warn( "Closing un-released batch" );
+			currentBatch.release();
+		}
+		return logicalConnection.close();
+	}
+
+	@Override
+	public Batch getBatch(BatchKey key) {
+		if ( currentBatch != null ) {
+			if ( currentBatch.getKey().equals( key ) ) {
+				return currentBatch;
+			}
+			else {
+				currentBatch.execute();
+				currentBatch.release();
+			}
+		}
+		currentBatch = batchBuilder().buildBatch( key, this );
+		return currentBatch;
+	}
+
+	@Override
+	public void abortBatch() {
+		if ( currentBatch != null ) {
+			currentBatch.release();
+		}
+	}
+
+	private transient StatementPreparer statementPreparer;
+
+	@Override
+	public StatementPreparer getStatementPreparer() {
+		if ( statementPreparer == null ) {
+			statementPreparer = new StatementPreparerImpl( this );
+		}
+		return statementPreparer;
+	}
+
+	@Override
+	public void setTransactionTimeOut(int timeOut) {
+		getStatementPreparer().setTransactionTimeOut( timeOut );
+	}
+
+	/**
+	 * To be called after local transaction completion.  Used to conditionally
+	 * release the JDBC connection aggressively if the configured release mode
+	 * indicates.
+	 */
+	public void afterTransaction() {
+		logicalConnection.afterTransaction();
+		if ( statementPreparer != null ) {
+			statementPreparer.unsetTransactionTimeOut();
+		}
+	}
+
+	public void coordinateWork(Work work) {
+		Connection connection = getLogicalConnection().getDistinctConnectionProxy();
+		try {
+			work.execute( connection );
+			getLogicalConnection().afterStatementExecution();
+		}
+		catch ( SQLException e ) {
+			throw sqlExceptionHelper().convert( e, "error executing work" );
+		}
+		finally {
+			try {
+				if ( ! connection.isClosed() ) {
+					connection.close();
+				}
+			}
+			catch (SQLException e) {
+				log.debug( "Error closing connection proxy", e );
+			}
+		}
+	}
+
+	public void executeBatch() {
+		if ( currentBatch != null ) {
+			currentBatch.execute();
+			currentBatch.release(); // needed?
+		}
+	}
+
+	@Override
+	public void cancelLastQuery() {
+		logicalConnection.getResourceRegistry().cancelLastQuery();
+	}
+
+
+	public void serialize(ObjectOutputStream oos) throws IOException {
+		if ( ! logicalConnection.isReadyForSerialization() ) {
+			throw new HibernateException( "Cannot serialize Session while connected" );
+		}
+		logicalConnection.serialize( oos );
+	}
+
+	public static JdbcCoordinatorImpl deserialize(
+			ObjectInputStream ois,
+			TransactionContext transactionContext) throws IOException, ClassNotFoundException {
+		return new JdbcCoordinatorImpl( LogicalConnectionImpl.deserialize( ois, transactionContext ) );
+ 	}
+
+	public void afterDeserialize(TransactionCoordinatorImpl transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/LogicalConnectionImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/LogicalConnectionImpl.java
index 8191d94162..25a5c208f2 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/LogicalConnectionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/LogicalConnectionImpl.java
@@ -1,430 +1,445 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.internal;
 
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.HibernateException;
+import org.hibernate.JDBCException;
+import org.hibernate.engine.jdbc.internal.proxy.ProxyBuilder;
+import org.hibernate.engine.jdbc.spi.ConnectionObserver;
+import org.hibernate.engine.jdbc.spi.JdbcResourceRegistry;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.jdbc.spi.NonDurableConnectionObserver;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.util.CollectionHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.JDBCException;
-import org.hibernate.engine.jdbc.spi.JdbcResourceRegistry;
-import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.engine.jdbc.spi.ConnectionObserver;
-import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
-import org.hibernate.jdbc.BorrowedConnectionProxy;
-import org.hibernate.stat.StatisticsImplementor;
-
 /**
- * LogicalConnectionImpl implementation
+ * Standard Hibernate {@link org.hibernate.engine.jdbc.spi.LogicalConnection} implementation
+ * <p/>
+ * IMPL NOTE : Custom serialization handling!
  *
  * @author Steve Ebersole
  */
 public class LogicalConnectionImpl implements LogicalConnectionImplementor {
 	private static final Logger log = LoggerFactory.getLogger( LogicalConnectionImpl.class );
 
-	private Connection physicalConnection;
-	private Connection borrowedConnection;
+	private transient Connection physicalConnection;
+	private transient Connection shareableConnectionProxy;
 
-	private final ConnectionReleaseMode connectionReleaseMode;
-	private final JdbcServices jdbcServices;
-	private final StatisticsImplementor statisticsImplementor;
-	private final JdbcResourceRegistry jdbcResourceRegistry;
-	private final List<ConnectionObserver> observers = new ArrayList<ConnectionObserver>();
+	private final transient ConnectionReleaseMode connectionReleaseMode;
+	private final transient JdbcServices jdbcServices;
+	private final transient JdbcResourceRegistry jdbcResourceRegistry;
+	private final transient List<ConnectionObserver> observers;
 
 	private boolean releasesEnabled = true;
 
 	private final boolean isUserSuppliedConnection;
 
 	private boolean isClosed;
 
-	public LogicalConnectionImpl(Connection userSuppliedConnection,
-								 ConnectionReleaseMode connectionReleaseMode,
-								 JdbcServices jdbcServices,
-								 StatisticsImplementor statisticsImplementor
-	) {
-		this( connectionReleaseMode,
+	public LogicalConnectionImpl(
+			Connection userSuppliedConnection,
+			ConnectionReleaseMode connectionReleaseMode,
+			JdbcServices jdbcServices) {
+		this(
+				connectionReleaseMode,
 				jdbcServices,
-				statisticsImplementor,
-				userSuppliedConnection != null,
-				false
+				(userSuppliedConnection != null),
+				false,
+				new ArrayList<ConnectionObserver>()
 		);
 		this.physicalConnection = userSuppliedConnection;
 	}
 
-	private LogicalConnectionImpl(ConnectionReleaseMode connectionReleaseMode,
-								  JdbcServices jdbcServices,
-								  StatisticsImplementor statisticsImplementor,
-								  boolean isUserSuppliedConnection,
-								  boolean isClosed) {
+	private LogicalConnectionImpl(
+			ConnectionReleaseMode connectionReleaseMode,
+			JdbcServices jdbcServices,
+			boolean isUserSuppliedConnection,
+			boolean isClosed,
+			List<ConnectionObserver> observers) {
 		this.connectionReleaseMode = determineConnectionReleaseMode(
 				jdbcServices, isUserSuppliedConnection, connectionReleaseMode
 		);
 		this.jdbcServices = jdbcServices;
-		this.statisticsImplementor = statisticsImplementor;
-		this.jdbcResourceRegistry =
-				new JdbcResourceRegistryImpl( getJdbcServices().getSqlExceptionHelper() );
+		this.jdbcResourceRegistry = new JdbcResourceRegistryImpl( getJdbcServices().getSqlExceptionHelper() );
+		this.observers = observers;
 
 		this.isUserSuppliedConnection = isUserSuppliedConnection;
 		this.isClosed = isClosed;
 	}
 
-	private static ConnectionReleaseMode determineConnectionReleaseMode(JdbcServices jdbcServices,
-																		boolean isUserSuppliedConnection,
-																		ConnectionReleaseMode connectionReleaseMode) {
+	private static ConnectionReleaseMode determineConnectionReleaseMode(
+			JdbcServices jdbcServices,
+			boolean isUserSuppliedConnection,
+			ConnectionReleaseMode connectionReleaseMode) {
 		if ( isUserSuppliedConnection ) {
 			return ConnectionReleaseMode.ON_CLOSE;
 		}
 		else if ( connectionReleaseMode == ConnectionReleaseMode.AFTER_STATEMENT &&
 				! jdbcServices.getConnectionProvider().supportsAggressiveRelease() ) {
 			log.debug( "connection provider reports to not support aggressive release; overriding" );
 			return ConnectionReleaseMode.AFTER_TRANSACTION;
 		}
 		else {
 			return connectionReleaseMode;
 		}
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public JdbcServices getJdbcServices() {
 		return jdbcServices;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public StatisticsImplementor getStatisticsImplementor() {
-		return statisticsImplementor;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public JdbcResourceRegistry getResourceRegistry() {
 		return jdbcResourceRegistry;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public void addObserver(ConnectionObserver observer) {
 		observers.add( observer );
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isOpen() {
-		return !isClosed;
+	@Override
+	public void removeObserver(ConnectionObserver connectionObserver) {
+		observers.remove( connectionObserver );
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isLogicallyConnected() {
-		return isUserSuppliedConnection ?
-				isPhysicallyConnected() :
-				isOpen();
+	@Override
+	public boolean isOpen() {
+		return !isClosed;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public boolean isPhysicallyConnected() {
 		return physicalConnection != null;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public Connection getConnection() throws HibernateException {
 		if ( isClosed ) {
 			throw new HibernateException( "Logical connection is closed" );
 		}
 		if ( physicalConnection == null ) {
 			if ( isUserSuppliedConnection ) {
 				// should never happen
 				throw new HibernateException( "User-supplied connection was null" );
 			}
 			obtainConnection();
 		}
 		return physicalConnection;
 	}
 
+	@Override
+	public Connection getShareableConnectionProxy() {
+		if ( shareableConnectionProxy == null ) {
+			shareableConnectionProxy = buildConnectionProxy();
+		}
+		return shareableConnectionProxy;
+	}
+
+	private Connection buildConnectionProxy() {
+		return ProxyBuilder.buildConnection( this );
+	}
+
+	@Override
+	public Connection getDistinctConnectionProxy() {
+		return buildConnectionProxy();
+	}
+
 	/**
 	 * {@inheritDoc}
 	 */
 	public Connection close() {
-		Connection c = physicalConnection;
+		log.trace( "closing logical connection" );
+		Connection c = isUserSuppliedConnection ? physicalConnection : null;
 		try {
-			releaseBorrowedConnection();
-			log.trace( "closing logical connection" );
+			releaseProxies();
+			jdbcResourceRegistry.close();
 			if ( !isUserSuppliedConnection && physicalConnection != null ) {
-				jdbcResourceRegistry.close();
 				releaseConnection();
 			}
 			return c;
 		}
 		finally {
 			// no matter what
 			physicalConnection = null;
 			isClosed = true;
 			log.trace( "logical connection closed" );
 			for ( ConnectionObserver observer : observers ) {
 				observer.logicalConnectionClosed();
 			}
+			observers.clear();
 		}			
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public ConnectionReleaseMode getConnectionReleaseMode() {
-		return connectionReleaseMode;
-	}
-
-	public boolean hasBorrowedConnection() {
-		return borrowedConnection != null;
-	}
-
-	public Connection borrowConnection() {
-		if ( isClosed ) {
-			throw new HibernateException( "connection has been closed" );
-		}
-		if ( isUserSuppliedConnection ) {
-			return physicalConnection;
-		}
-		else {
-			if ( borrowedConnection == null ) {
-				borrowedConnection = BorrowedConnectionProxy.generateProxy( this );
-			}
-			return borrowedConnection;
-		}
-	}
-
-	public void releaseBorrowedConnection() {
-		if ( borrowedConnection != null ) {
+	private void releaseProxies() {
+		if ( shareableConnectionProxy != null ) {
 			try {
-				BorrowedConnectionProxy.renderUnuseable( borrowedConnection );
+				shareableConnectionProxy.close();
 			}
-			finally {
-				borrowedConnection = null;
+			catch (SQLException e) {
+				log.debug( "Error releasing shared connection proxy", e );
 			}
 		}
+		shareableConnectionProxy = null;
+	}
+
+	@Override
+	public ConnectionReleaseMode getConnectionReleaseMode() {
+		return connectionReleaseMode;
 	}
 
+	@Override
 	public void afterStatementExecution() {
 		log.trace( "starting after statement execution processing [{}]", connectionReleaseMode );
 		if ( connectionReleaseMode == ConnectionReleaseMode.AFTER_STATEMENT ) {
 			if ( ! releasesEnabled ) {
 				log.debug( "skipping aggressive release due to manual disabling" );
 				return;
 			}
 			if ( jdbcResourceRegistry.hasRegisteredResources() ) {
 				log.debug( "skipping aggressive release due to registered resources" );
 				return;
 			}
-			else if ( borrowedConnection != null ) {
-				log.debug( "skipping aggresive-release due to borrowed connection" );
-			}			
 			releaseConnection();
 		}
 	}
 
+	@Override
 	public void afterTransaction() {
 		if ( connectionReleaseMode == ConnectionReleaseMode.AFTER_STATEMENT ||
 				connectionReleaseMode == ConnectionReleaseMode.AFTER_TRANSACTION ) {
 			if ( jdbcResourceRegistry.hasRegisteredResources() ) {
 				log.info( "forcing container resource cleanup on transaction completion" );
 				jdbcResourceRegistry.releaseResources();
 			}
 			aggressiveRelease();
 		}
 	}
 
+	@Override
 	public void disableReleases() {
 		log.trace( "disabling releases" );
 		releasesEnabled = false;
 	}
 
+	@Override
 	public void enableReleases() {
 		log.trace( "(re)enabling releases" );
 		releasesEnabled = true;
-		//FIXME: uncomment after new batch stuff is integrated!!!
-		//afterStatementExecution();
+		afterStatementExecution();
 	}
 
 	/**
-	 * Force aggresive release of the underlying connection.
+	 * Force aggressive release of the underlying connection.
 	 */
 	public void aggressiveRelease() {
 		if ( isUserSuppliedConnection ) {
 			log.debug( "cannot aggressively release user-supplied connection; skipping" );
 		}
 		else {
 			log.debug( "aggressively releasing JDBC connection" );
 			if ( physicalConnection != null ) {
 				releaseConnection();
 			}
 		}
 	}
 
 
 	/**
-	 * Pysically opens a JDBC Connection.
+	 * Physically opens a JDBC Connection.
 	 *
 	 * @throws org.hibernate.JDBCException Indicates problem opening a connection
 	 */
 	private void obtainConnection() throws JDBCException {
 		log.debug( "obtaining JDBC connection" );
 		try {
 			physicalConnection = getJdbcServices().getConnectionProvider().getConnection();
 			for ( ConnectionObserver observer : observers ) {
 				observer.physicalConnectionObtained( physicalConnection );
 			}
 			log.debug( "obtained JDBC connection" );
 		}
 		catch ( SQLException sqle) {
 			throw getJdbcServices().getSqlExceptionHelper().convert( sqle, "Could not open connection" );
 		}
 	}
 
 	/**
 	 * Physically closes the JDBC Connection.
 	 *
 	 * @throws JDBCException Indicates problem closing a connection
 	 */
 	private void releaseConnection() throws JDBCException {
 		log.debug( "releasing JDBC connection" );
 		if ( physicalConnection == null ) {
 			return;
 		}
 		try {
 			if ( ! physicalConnection.isClosed() ) {
 				getJdbcServices().getSqlExceptionHelper().logAndClearWarnings( physicalConnection );
 			}
 			if ( !isUserSuppliedConnection ) {
 				getJdbcServices().getConnectionProvider().closeConnection( physicalConnection );
 			}
 			log.debug( "released JDBC connection" );
 		}
 		catch (SQLException sqle) {
 			throw getJdbcServices().getSqlExceptionHelper().convert( sqle, "Could not close connection" );
 		}
 		finally {
 			physicalConnection = null;
 		}
 		log.debug( "released JDBC connection" );
 		for ( ConnectionObserver observer : observers ) {
 			observer.physicalConnectionReleased();
 		}
+		releaseNonDurableObservers();
 	}
 
-	/**
-	 * Manually disconnect the underlying JDBC Connection.  The assumption here
-	 * is that the manager will be reconnected at a later point in time.
-	 *
-	 * @return The connection mantained here at time of disconnect.  Null if
-	 * there was no connection cached internally.
-	 */
+	@Override
 	public Connection manualDisconnect() {
 		if ( isClosed ) {
 			throw new IllegalStateException( "cannot manually disconnect because logical connection is already closed" );
 		}
+		releaseProxies();
 		Connection c = physicalConnection;
 		jdbcResourceRegistry.releaseResources();
 		releaseConnection();
 		return c;
 	}
 
-	/**
-	 * Manually reconnect the underlying JDBC Connection.  Should be called at
-	 * some point after manualDisconnect().
-	 * <p/>
-	 * This form is used for user-supplied connections.
-	 */
-	public void reconnect(Connection suppliedConnection) {
+	private void releaseNonDurableObservers() {
+		Iterator observers = this.observers.iterator();
+		while ( observers.hasNext() ) {
+			if ( NonDurableConnectionObserver.class.isInstance( observers.next() ) ) {
+				observers.remove();
+			}
+		}
+	}
+
+	@Override
+	public void manualReconnect(Connection suppliedConnection) {
 		if ( isClosed ) {
 			throw new IllegalStateException( "cannot manually reconnect because logical connection is already closed" );
 		}
 		if ( isUserSuppliedConnection ) {
 			if ( suppliedConnection == null ) {
 				throw new IllegalArgumentException( "cannot reconnect a null user-supplied connection" );
 			}
 			else if ( suppliedConnection == physicalConnection ) {
 				log.warn( "reconnecting the same connection that is already connected; should this connection have been disconnected?" );
 			}
 			else if ( physicalConnection != null ) {
 				throw new IllegalArgumentException(
 						"cannot reconnect to a new user-supplied connection because currently connected; must disconnect before reconnecting."
 				);
 			}
 			physicalConnection = suppliedConnection;
 			log.debug( "reconnected JDBC connection" );
 		}
 		else {
 			if ( suppliedConnection != null ) {
 				throw new IllegalStateException( "unexpected user-supplied connection" );
 			}
 			log.debug( "called reconnect() with null connection (not user-supplied)" );
 		}
 	}
 
+	@Override
+	public boolean isAutoCommit() {
+		if ( !isOpen() || ! isPhysicallyConnected() ) {
+			return true;
+		}
+
+		try {
+			return getConnection().getAutoCommit();
+		}
+		catch (SQLException e) {
+			throw jdbcServices.getSqlExceptionHelper().convert( e, "could not inspect JDBC autocommit mode" );
+		}
+	}
+
+	@Override
+	public void notifyObserversStatementPrepared() {
+		for ( ConnectionObserver observer : observers ) {
+			observer.statementPrepared();
+		}
+	}
+
+	@Override
 	public boolean isReadyForSerialization() {
-		return isUserSuppliedConnection ?
-				! isPhysicallyConnected() :
-				! getResourceRegistry().hasRegisteredResources()
-				;
+		return isUserSuppliedConnection
+				? ! isPhysicallyConnected()
+				: ! getResourceRegistry().hasRegisteredResources();
 	}
 
 	public void serialize(ObjectOutputStream oos) throws IOException {
 		oos.writeBoolean( isUserSuppliedConnection );
 		oos.writeBoolean( isClosed );
+		List<ConnectionObserver> durableConnectionObservers = new ArrayList<ConnectionObserver>();
+		for ( ConnectionObserver observer : observers ) {
+			if ( ! NonDurableConnectionObserver.class.isInstance( observer ) ) {
+				durableConnectionObservers.add( observer );
+			}
+		}
+		oos.writeInt( durableConnectionObservers.size() );
+		for ( ConnectionObserver observer : durableConnectionObservers ) {
+			oos.writeObject( observer );
+		}
 	}
 
-	public static LogicalConnectionImpl deserialize(ObjectInputStream ois,
-													JdbcServices jdbcServices,
-													StatisticsImplementor statisticsImplementor,
-													ConnectionReleaseMode connectionReleaseMode
-	) throws IOException {
+	public static LogicalConnectionImpl deserialize(
+			ObjectInputStream ois,
+			TransactionContext transactionContext) throws IOException, ClassNotFoundException {
+		boolean isUserSuppliedConnection = ois.readBoolean();
+		boolean isClosed = ois.readBoolean();
+		int observerCount = ois.readInt();
+		List<ConnectionObserver> observers = CollectionHelper.arrayList( observerCount );
+		for ( int i = 0; i < observerCount; i++ ) {
+			observers.add( (ConnectionObserver) ois.readObject() );
+		}
 		return new LogicalConnectionImpl(
-				connectionReleaseMode,
-				jdbcServices,
-				statisticsImplementor,
-				ois.readBoolean(),
-				ois.readBoolean()
+				transactionContext.getConnectionReleaseMode(),
+				transactionContext.getTransactionEnvironment().getJdbcServices(),
+				isUserSuppliedConnection,
+				isClosed,
+				observers
 		);
  	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparer.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparer.java
deleted file mode 100644
index 2500f328f9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparer.java
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.engine.jdbc.internal;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.HibernateException;
-import org.hibernate.ScrollMode;
-import org.hibernate.TransactionException;
-import org.hibernate.cfg.Settings;
-import org.hibernate.engine.jdbc.internal.proxy.ProxyBuilder;
-import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-
-/**
- * Prepares statements.
- *
- * @author Gail Badner
- */
-public class StatementPreparer {
-
-	private static final Logger log = LoggerFactory.getLogger( StatementPreparer.class );
-
-	// TODO: Move JDBC settings into a different object...
-	private final Settings settings;
-	private final Connection proxiedConnection;
-	private final SQLExceptionHelper sqlExceptionHelper;
-
-	private long transactionTimeout = -1;
-	boolean isTransactionTimeoutSet;
-
-	/**
-	 * Constructs a StatementPreparer object
-	 * @param logicalConnection - the logical connection
-	 * @param settings - contains settings configured for preparing statements
-	 */
-	public StatementPreparer(LogicalConnectionImplementor logicalConnection, Settings settings) {
-		this.settings = settings;
-		proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
-		sqlExceptionHelper = logicalConnection.getJdbcServices().getSqlExceptionHelper();
-	}
-
-	private abstract class StatementPreparation {
-		private final String sql;
-		protected abstract PreparedStatement doPrepare() throws SQLException;
-		public StatementPreparation(String sql) {
-			this.sql = sql;
-		}
-		public String getSql() {
-			return sql;
-		}
-		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
-			setStatementTimeout( preparedStatement );
-		}
-		public PreparedStatement prepareAndPostProcess() {
-			try {
-				PreparedStatement ps = doPrepare();
-				postProcess( ps );
-				return ps;
-			}
-			catch ( SQLException sqle ) {
-				log.error( "sqlexception escaped proxy", sqle );
-				throw sqlExceptionHelper.convert(
-						sqle, "could not prepare statement", sql
-				);
-			}
-		}
-	}
-
-	private abstract class QueryStatementPreparation extends StatementPreparation {
-		QueryStatementPreparation(String sql) {
-			super( sql );
-		}
-		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
-			super.postProcess( preparedStatement );
-			setStatementFetchSize( preparedStatement );
-		}
-	}
-
-	public void close() {
-		try {
-			proxiedConnection.close();
-		}
-		catch (SQLException sqle) {
-			log.error( "sqlexception escaped proxy", sqle );
-			throw sqlExceptionHelper.convert( sqle, "could not close connection proxy" );
-		}
-	}
-
-	/**
-	 * Prepare a statement. If configured, the query timeout is set.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 *
-	 * @param sql - the SQL for the statement to be prepared
-	 * @param isCallable - true, if a callable statement is to be prepared
-	 * @return the prepared statement
-	 */
-	public PreparedStatement prepareStatement(String sql, final boolean isCallable) {
-		StatementPreparation statementPreparation = new StatementPreparation( sql ) {
-			public PreparedStatement doPrepare() throws SQLException {
-				return isCallable ?
-						proxiedConnection.prepareCall( getSql() ) :
-						proxiedConnection.prepareStatement( getSql() );
-			}
-		};
-		return statementPreparation.prepareAndPostProcess();
-	}
-
-	/**
-	 * Get a prepared statement to use for inserting / deleting / updating,
-	 * using JDBC3 getGeneratedKeys ({@link java.sql.Connection#prepareStatement(String, int)}).
-	 * If configured, the query timeout is set.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-
-	 * @param sql - the SQL for the statement to be prepared
-	 * @param autoGeneratedKeys - a flag indicating whether auto-generated
-	 *        keys should be returned; one of
-     *        <code>PreparedStatement.RETURN_GENERATED_KEYS</code> or
-     *	      <code>Statement.NO_GENERATED_KEYS</code>
-	 * @return the prepared statement
-	 */
-	public PreparedStatement prepareStatement(String sql, final int autoGeneratedKeys)
-			throws HibernateException {
-		if ( autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS ) {
-			checkAutoGeneratedKeysSupportEnabled();
-		}
-		StatementPreparation statementPreparation = new StatementPreparation( sql ) {
-			public PreparedStatement doPrepare() throws SQLException {
-				return proxiedConnection.prepareStatement( getSql(), autoGeneratedKeys );
-			}
-		};
-		return statementPreparation.prepareAndPostProcess();
-	}
-
-	/**
-	 * Get a prepared statement to use for inserting / deleting / updating.
-	 * using JDBC3 getGeneratedKeys ({@link java.sql.Connection#prepareStatement(String, String[])}).
-	 * If configured, the query timeout is set.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 */
-	public PreparedStatement prepareStatement(String sql, final String[] columnNames) {
-		checkAutoGeneratedKeysSupportEnabled();
-		StatementPreparation preparation = new StatementPreparation( sql ) {
-			public PreparedStatement doPrepare() throws SQLException {
-				return proxiedConnection.prepareStatement( getSql(), columnNames );
-			}
-		};
-		return preparation.prepareAndPostProcess();
-	}
-
-	private void checkAutoGeneratedKeysSupportEnabled() {
-		if ( ! settings.isGetGeneratedKeysEnabled() ) {
-			throw new AssertionFailure("getGeneratedKeys() support is not enabled");
-		}
-	}
-
-	/**
-	 * Get a prepared statement for use in loading / querying.
-	 * If configured, the query timeout and statement fetch size are set.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 */
-	public PreparedStatement prepareQueryStatement(
-			String sql,
-			final boolean isCallable
-	) {
-		StatementPreparation prep = new QueryStatementPreparation( sql ) {
-			public PreparedStatement doPrepare() throws SQLException {
-				return isCallable ?
-						proxiedConnection.prepareCall( getSql() ) :
-						proxiedConnection.prepareStatement( getSql() );
-			}
-		};
-		return prep.prepareAndPostProcess();
-	}
-
-	/**
-	 * Get a scrollable prepared statement for use in loading / querying.
-	 * If configured, the query timeout and statement fetch size are set.
-	 * <p/>
-	 * If not explicitly closed via {@link java.sql.PreparedStatement#close()},
-	 * it will be released when the session is closed or disconnected.
-	 */
-	public PreparedStatement prepareScrollableQueryStatement(
-			String sql,
-			final ScrollMode scrollMode,
-			final boolean isCallable
-	) {
-		if ( ! settings.isScrollableResultSetsEnabled() ) {
-			throw new AssertionFailure("scrollable result sets are not enabled");
-		}
-		StatementPreparation prep = new QueryStatementPreparation( sql ) {
-			public PreparedStatement doPrepare() throws SQLException {
-					return isCallable ?
-							proxiedConnection.prepareCall(
-									getSql(), scrollMode.toResultSetType(), ResultSet.CONCUR_READ_ONLY
-							) :
-							proxiedConnection.prepareStatement(
-									getSql(), scrollMode.toResultSetType(), ResultSet.CONCUR_READ_ONLY
-					);
-			}
-		};
-		return prep.prepareAndPostProcess();
-	}
-
-	/**
-	 * Sets the transaction timeout.
-	 * @param seconds - number of seconds until the the transaction times out.
-	 */
-	public void setTransactionTimeout(int seconds) {
-		isTransactionTimeoutSet = true;
-		transactionTimeout = System.currentTimeMillis() / 1000 + seconds;
-	}
-
-	/**
-	 * Unset the transaction timeout, called after the end of a
-	 * transaction.
-	 */
-	public void unsetTransactionTimeout() {
-		isTransactionTimeoutSet = false;
-	}
-
-	private void setStatementTimeout(PreparedStatement preparedStatement) throws SQLException {
-		if ( isTransactionTimeoutSet ) {
-			int timeout = (int) ( transactionTimeout - ( System.currentTimeMillis() / 1000 ) );
-			if ( timeout <=  0) {
-				throw new TransactionException("transaction timeout expired");
-			}
-			else {
-				preparedStatement.setQueryTimeout(timeout);
-			}
-		}
-	}
-
-	private void setStatementFetchSize(PreparedStatement statement) throws SQLException {
-		if ( settings.getJdbcFetchSize() != null ) {
-			statement.setFetchSize( settings.getJdbcFetchSize() );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparerImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparerImpl.java
new file mode 100644
index 0000000000..ed4fa259b0
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/StatementPreparerImpl.java
@@ -0,0 +1,223 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.internal;
+
+import org.hibernate.AssertionFailure;
+import org.hibernate.ScrollMode;
+import org.hibernate.TransactionException;
+import org.hibernate.cfg.Settings;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
+import org.hibernate.engine.jdbc.spi.StatementPreparer;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
+/**
+* @author Steve Ebersole
+*/
+class StatementPreparerImpl implements StatementPreparer {
+	private long transactionTimeOut = -1;
+	private JdbcCoordinatorImpl jdbcCoordinator;
+
+	StatementPreparerImpl(JdbcCoordinatorImpl jdbcCoordinator) {
+		this.jdbcCoordinator = jdbcCoordinator;
+	}
+
+	protected final Settings settings() {
+		return jdbcCoordinator.sessionFactory().getSettings();
+	}
+
+	protected final Connection connectionProxy() {
+		return logicalConnection().getShareableConnectionProxy();
+	}
+
+	protected final LogicalConnectionImplementor logicalConnection() {
+		return jdbcCoordinator.getLogicalConnection();
+	}
+
+	protected final SQLExceptionHelper sqlExceptionHelper() {
+		return jdbcCoordinator.getTransactionCoordinator()
+				.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJdbcServices()
+				.getSqlExceptionHelper();
+	}
+
+	@Override
+	public PreparedStatement prepareStatement(String sql) {
+		return buildPreparedStatementPreparationTemplate( sql, false ).prepareStatement();
+	}
+
+	@Override
+	public PreparedStatement prepareStatement(String sql, final boolean isCallable) {
+		jdbcCoordinator.executeBatch();
+		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();
+	}
+
+	private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
+		return new StatementPreparationTemplate( sql ) {
+			@Override
+			protected PreparedStatement doPrepare() throws SQLException {
+				return isCallable
+						? connectionProxy().prepareCall( sql )
+						: connectionProxy().prepareStatement( sql );
+			}
+		};
+	}
+
+	private void checkAutoGeneratedKeysSupportEnabled() {
+		if ( ! settings().isGetGeneratedKeysEnabled() ) {
+			throw new AssertionFailure( "getGeneratedKeys() support is not enabled" );
+		}
+	}
+
+	@Override
+	public PreparedStatement prepareStatement(String sql, final int autoGeneratedKeys) {
+		if ( autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS ) {
+			checkAutoGeneratedKeysSupportEnabled();
+		}
+		jdbcCoordinator.executeBatch();
+		return new StatementPreparationTemplate( sql ) {
+			public PreparedStatement doPrepare() throws SQLException {
+				return connectionProxy().prepareStatement( sql, autoGeneratedKeys );
+			}
+		}.prepareStatement();
+	}
+
+	@Override
+	public PreparedStatement prepareStatement(String sql, final String[] columnNames) {
+		checkAutoGeneratedKeysSupportEnabled();
+		jdbcCoordinator.executeBatch();
+		return new StatementPreparationTemplate( sql ) {
+			public PreparedStatement doPrepare() throws SQLException {
+				return connectionProxy().prepareStatement( sql, columnNames );
+			}
+		}.prepareStatement();
+	}
+
+	@Override
+	public PreparedStatement prepareQueryStatement(
+			String sql,
+			final boolean isCallable,
+			final ScrollMode scrollMode) {
+		if ( scrollMode != null && !scrollMode.equals( ScrollMode.FORWARD_ONLY ) ) {
+			if ( ! settings().isScrollableResultSetsEnabled() ) {
+				throw new AssertionFailure("scrollable result sets are not enabled");
+			}
+			PreparedStatement ps = new QueryStatementPreparationTemplate( sql ) {
+				public PreparedStatement doPrepare() throws SQLException {
+						return isCallable
+								? connectionProxy().prepareCall(
+								sql, scrollMode.toResultSetType(), ResultSet.CONCUR_READ_ONLY
+						)
+								: connectionProxy().prepareStatement(
+								sql, scrollMode.toResultSetType(), ResultSet.CONCUR_READ_ONLY
+						);
+				}
+			}.prepareStatement();
+			logicalConnection().getResourceRegistry().registerLastQuery( ps );
+			return ps;
+		}
+		else {
+			PreparedStatement ps = new QueryStatementPreparationTemplate( sql ) {
+				public PreparedStatement doPrepare() throws SQLException {
+						return isCallable
+								? connectionProxy().prepareCall( sql )
+								: connectionProxy().prepareStatement( sql );
+				}
+			}.prepareStatement();
+			logicalConnection().getResourceRegistry().registerLastQuery( ps );
+			return ps;
+		}
+	}
+
+	@Override
+	public void setTransactionTimeOut(int timeOut) {
+		transactionTimeOut = timeOut;
+	}
+
+	@Override
+	public void unsetTransactionTimeOut() {
+		transactionTimeOut = -1;
+	}
+
+	private abstract class StatementPreparationTemplate {
+		protected final String sql;
+
+		protected StatementPreparationTemplate(String sql) {
+			this.sql = sql;
+		}
+
+		public PreparedStatement prepareStatement() {
+			try {
+				PreparedStatement preparedStatement = doPrepare();
+				setStatementTimeout( preparedStatement );
+				postProcess( preparedStatement );
+				return preparedStatement;
+			}
+			catch ( SQLException e ) {
+				throw sqlExceptionHelper().convert( e, "could not prepare statement", sql );
+			}
+		}
+
+		protected abstract PreparedStatement doPrepare() throws SQLException;
+
+		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
+		}
+
+		private void setStatementTimeout(PreparedStatement preparedStatement) throws SQLException {
+			if ( transactionTimeOut > 0 ) {
+				int timeout = (int) ( transactionTimeOut - ( System.currentTimeMillis() / 1000 ) );
+				if ( timeout <= 0 ) {
+					throw new TransactionException( "transaction timeout expired" );
+				}
+				else {
+					preparedStatement.setQueryTimeout( timeout );
+				}
+			}
+		}
+
+	}
+
+	private abstract class QueryStatementPreparationTemplate extends StatementPreparationTemplate {
+		protected QueryStatementPreparationTemplate(String sql) {
+			super( sql );
+		}
+
+		public void postProcess(PreparedStatement preparedStatement) throws SQLException {
+			super.postProcess( preparedStatement );
+			setStatementFetchSize( preparedStatement );
+		}
+	}
+
+	private void setStatementFetchSize(PreparedStatement statement) throws SQLException {
+		if ( settings().getJdbcFetchSize() != null ) {
+			statement.setFetchSize( settings().getJdbcFetchSize() );
+		}
+	}
+
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/proxy/ConnectionProxyHandler.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/proxy/ConnectionProxyHandler.java
index ef5e0fcf47..206ae0b2e7 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/proxy/ConnectionProxyHandler.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/proxy/ConnectionProxyHandler.java
@@ -1,231 +1,229 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.internal.proxy;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.TransactionException;
 import org.hibernate.engine.jdbc.spi.JdbcResourceRegistry;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.engine.jdbc.spi.ConnectionObserver;
 import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
-import org.hibernate.stat.StatisticsImplementor;
+import org.hibernate.engine.jdbc.spi.NonDurableConnectionObserver;
 
 /**
  * The {@link InvocationHandler} for intercepting messages to {@link java.sql.Connection} proxies.
  *
  * @author Steve Ebersole
  */
-public class ConnectionProxyHandler extends AbstractProxyHandler implements InvocationHandler, ConnectionObserver {
+public class ConnectionProxyHandler
+		extends AbstractProxyHandler
+		implements InvocationHandler, NonDurableConnectionObserver {
 	private static final Logger log = LoggerFactory.getLogger( ConnectionProxyHandler.class );
 
 	private LogicalConnectionImplementor logicalConnection;
 
 	public ConnectionProxyHandler(LogicalConnectionImplementor logicalConnection) {
 		super( logicalConnection.hashCode() );
 		this.logicalConnection = logicalConnection;
 		this.logicalConnection.addObserver( this );
 	}
 
 	/**
 	 * Access to our logical connection.
 	 *
 	 * @return the logical connection
 	 */
 	protected LogicalConnectionImplementor getLogicalConnection() {
 		errorIfInvalid();
 		return logicalConnection;
 	}
 
 	/**
 	 * Get reference to physical connection.
 	 * <p/>
 	 * NOTE : be sure this handler is still valid before calling!
 	 *
 	 * @return The physical connection
 	 */
 	private Connection extractPhysicalConnection() {
 		return logicalConnection.getConnection();
 	}
 
 	/**
 	 * Provide access to JDBCServices.
 	 * <p/>
 	 * NOTE : package-protected
 	 *
 	 * @return JDBCServices
 	 */
 	JdbcServices getJdbcServices() {
 		return logicalConnection.getJdbcServices();
 	}
 
 	/**
 	 * Provide access to JDBCContainer.
 	 * <p/>
 	 * NOTE : package-protected
 	 *
 	 * @return JDBCContainer
 	 */
 	JdbcResourceRegistry getResourceRegistry() {
 		return logicalConnection.getResourceRegistry();
 	}
 
 	protected Object continueInvocation(Object proxy, Method method, Object[] args) throws Throwable {
 		String methodName = method.getName();
 		log.trace( "Handling invocation of connection method [{}]", methodName );
 
 		// other methods allowed while invalid ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		if ( "close".equals( methodName ) ) {
 			explicitClose();
 			return null;
 		}
 
+		if ( "isClosed".equals( methodName ) ) {
+			return ! isValid();
+		}
+
 		errorIfInvalid();
 
 		// handle the JDBC 4 Wrapper#isWrapperFor and Wrapper#unwrap calls
 		//		these cause problems to the whole proxy scheme though as we need to return the raw objects
 		if ( "isWrapperFor".equals( methodName ) && args.length == 1 ) {
 			return method.invoke( extractPhysicalConnection(), args );
 		}
 		if ( "unwrap".equals( methodName ) && args.length == 1 ) {
 			return method.invoke( extractPhysicalConnection(), args );
 		}
 
 		if ( "getWrappedObject".equals( methodName ) ) {
 			return extractPhysicalConnection();
 		}
 
 		try {
 			Object result = method.invoke( extractPhysicalConnection(), args );
 			result = postProcess( result, proxy, method, args );
 
 			return result;
 		}
 		catch( InvocationTargetException e ) {
 			Throwable realException = e.getTargetException();
 			if ( SQLException.class.isInstance( realException ) ) {
 				throw logicalConnection.getJdbcServices().getSqlExceptionHelper()
 						.convert( ( SQLException ) realException, realException.getMessage() );
 			}
 			else {
 				throw realException;
 			}
 		}
 	}
 
 	private Object postProcess(Object result, Object proxy, Method method, Object[] args) throws SQLException {
 		String methodName = method.getName();
 		Object wrapped = result;
 		if ( "createStatement".equals( methodName ) ) {
 			wrapped = ProxyBuilder.buildStatement(
 					(Statement) result,
 					this,
 					( Connection ) proxy
 			);
 			postProcessStatement( ( Statement ) wrapped );
 		}
 		else if ( "prepareStatement".equals( methodName ) ) {
 			wrapped = ProxyBuilder.buildPreparedStatement(
 					( String ) args[0],
 					(PreparedStatement) result,
 					this,
 					( Connection ) proxy
 			);
 			postProcessPreparedStatement( ( Statement ) wrapped );
 		}
 		else if ( "prepareCall".equals( methodName ) ) {
 			wrapped = ProxyBuilder.buildCallableStatement(
 					( String ) args[0],
 					(CallableStatement) result,
 					this,
 					( Connection ) proxy
 			);
 			postProcessPreparedStatement( ( Statement ) wrapped );
 		}
 		else if ( "getMetaData".equals( methodName ) ) {
 			wrapped = ProxyBuilder.buildDatabaseMetaData( (DatabaseMetaData) result, this, ( Connection ) proxy );
 		}
 		return wrapped;
 	}
 
 	private void postProcessStatement(Statement statement) throws SQLException {
 		getResourceRegistry().register( statement );
 	}
 
 	private void postProcessPreparedStatement(Statement statement) throws SQLException  {
-		if ( getStatisticsImplementorOrNull() != null ) {
-			getStatisticsImplementorOrNull().prepareStatement();
-		}
+		logicalConnection.notifyObserversStatementPrepared();
 		postProcessStatement( statement );
 	}
 
 	private void explicitClose() {
 		if ( isValid() ) {
 			invalidateHandle();
 		}
 	}
 
 	private void invalidateHandle() {
 		log.trace( "Invalidating connection handle" );
 		logicalConnection = null;
 		invalidate();
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	// ConnectionObserver ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+	@Override
 	public void physicalConnectionObtained(Connection connection) {
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public void physicalConnectionReleased() {
 		log.info( "logical connection releasing its physical connection");
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public void logicalConnectionClosed() {
 		log.info( "*** logical connection closed ***" );
 		invalidateHandle();
 	}
 
-	/* package-protected */
-	StatisticsImplementor getStatisticsImplementorOrNull() {
-		return getLogicalConnection().getStatisticsImplementor();
+	@Override
+	public void statementPrepared() {
+		// N/A
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserver.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserver.java
index 20abcbf038..27072979d7 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserver.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserver.java
@@ -1,50 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
 import java.sql.Connection;
 
 /**
  * An observer of logical connection events.
  *
  * @author Steve Ebersole
  */
 public interface ConnectionObserver {
 	/**
 	 * A physical connection was obtained.
 	 *
 	 * @param connection The physical connection just obtained.
 	 */
 	public void physicalConnectionObtained(Connection connection);
 
 	/**
 	 * A physical connection was released.
 	 */
 	public void physicalConnectionReleased();
 
 	/**
 	 * The logical connection was closed.
 	 */
 	public void logicalConnectionClosed();
+
+	/**
+	 * Notification of a statement being prepared
+	 */
+	public void statementPrepared();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/jdbc/ConnectionWrapper.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserverAdapter.java
similarity index 66%
rename from hibernate-core/src/main/java/org/hibernate/jdbc/ConnectionWrapper.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserverAdapter.java
index 1515245d79..32408525b2 100644
--- a/hibernate-core/src/main/java/org/hibernate/jdbc/ConnectionWrapper.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/ConnectionObserverAdapter.java
@@ -1,42 +1,47 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.jdbc;
-
-import java.sql.Connection;
-
-/**
- * Interface implemented by JDBC connection wrappers in order to give
- * access to the underlying wrapped connection.
- *
- * @author Steve Ebersole
- */
-public interface ConnectionWrapper {
-	/**
-	 * Get a reference to the wrapped connection.
-	 *
-	 * @return The wrapped connection.
-	 */
-	public Connection getWrappedConnection();
-}
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.spi;
+
+import java.sql.Connection;
+
+/**
+ * @author Steve Ebersole
+ */
+public class ConnectionObserverAdapter implements ConnectionObserver {
+	@Override
+	public void physicalConnectionObtained(Connection connection) {
+	}
+
+	@Override
+	public void physicalConnectionReleased() {
+	}
+
+	@Override
+	public void logicalConnectionClosed() {
+	}
+
+	@Override
+	public void statementPrepared() {
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JDBCContext.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JDBCContext.java
deleted file mode 100644
index 4e177d44a0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JDBCContext.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.engine.jdbc.spi;
-
-import java.io.Serializable;
-import java.sql.Connection;
-
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.engine.SessionFactoryImplementor;
-import org.hibernate.transaction.TransactionFactory;
-import org.hibernate.transaction.synchronization.CallbackCoordinator;
-
-/**
- * Acts as the SPI for the mediary between "entity-mode related" sessions in terms of
- * their interaction with the JDBC data store.
- *
- * @author Gail Badner
- */
-public interface JDBCContext extends Serializable {
-
-	// TODO: Document these methods...
-
-	CallbackCoordinator getJtaSynchronizationCallbackCoordinator();
-
-	void cleanUpJtaSynchronizationCallbackCoordinator();
-
-	SessionFactoryImplementor getFactory();
-
-	ConnectionManager getConnectionManager();
-
-	Connection connection() throws HibernateException;
-
-	boolean registerCallbackIfNecessary();
-
-	boolean registerSynchronizationIfPossible();
-
-	boolean isTransactionInProgress();
-
-	Transaction getTransaction() throws HibernateException;
-
-	void beforeTransactionCompletion(Transaction tx);
-
-	void afterTransactionBegin(Transaction tx);
-
-	void afterTransactionCompletion(boolean success, Transaction tx);
-
-	void afterNontransactionalQuery(boolean success);
-
-	public static interface Context extends TransactionFactory.Context {
-		/**
-		 * We cannot rely upon this method being called! It is only
-		 * called if we are using Hibernate Transaction API.
-		 */
-		public void afterTransactionBegin(Transaction tx);
-		public void beforeTransactionCompletion(Transaction tx);
-		public void afterTransactionCompletion(boolean success, Transaction tx);
-		public ConnectionReleaseMode getConnectionReleaseMode();
-		public boolean isAutoCloseSessionEnabled();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcContext.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcContext.java
new file mode 100644
index 0000000000..a3c8ad8998
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcContext.java
@@ -0,0 +1,51 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.spi;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.SessionFactoryImplementor;
+
+import java.io.Serializable;
+
+/**
+ * Access to services needed in the context of processing JDBC requests.
+ *
+ * @author Steve Ebersole
+ */
+public interface JdbcContext extends Serializable {
+	public SessionFactoryImplementor getSessionFactory();
+	public ConnectionReleaseMode getConnectionReleaseMode();
+
+	public boolean isClosed();
+
+	public boolean isFlushModeNever();
+
+	public boolean isFlushBeforeCompletionEnabled();
+
+	public void managedFlush();
+
+	public boolean shouldAutoClose();
+
+	public void managedClose();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcCoordinator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcCoordinator.java
new file mode 100644
index 0000000000..d1d9a143de
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcCoordinator.java
@@ -0,0 +1,96 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.spi;
+
+import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.jdbc.Work;
+
+import java.io.Serializable;
+import java.sql.Connection;
+
+/**
+ * Coordinates JDBC-related activities.
+ *
+ * @author Steve Ebersole
+ */
+public interface JdbcCoordinator extends Serializable {
+	/**
+	 * Retrieve the transaction coordinator associated with this JDBC coordinator.
+	 *
+	 * @return The transaction coordinator
+	 */
+	public TransactionCoordinator getTransactionCoordinator();
+
+	/**
+	 * Retrieves the logical connection associated with this JDBC coordinator.
+	 *
+	 * @return The logical connection
+	 */
+	public LogicalConnectionImplementor getLogicalConnection();
+
+	/**
+	 * Get a batch instance.
+	 *
+	 * @param key The unique batch key.
+	 *
+	 * @return The batch
+	 */
+	public Batch getBatch(BatchKey key);
+
+	public void abortBatch();
+
+	/**
+	 * Obtain the statement preparer associated with this JDBC coordinator.
+	 *
+	 * @return This coordinator's statement preparer
+	 */
+	public StatementPreparer getStatementPreparer();
+
+	/**
+	 * Callback to let us know that a flush is beginning.  We use this fact
+	 * to temporarily circumvent aggressive connection releasing until after
+	 * the flush cycle is complete {@link #flushEnding()}
+	 */
+	public void flushBeginning();
+
+	/**
+	 * Callback to let us know that a flush is ending.  We use this fact to
+	 * stop circumventing aggressive releasing connections.
+	 */
+	public void flushEnding();
+
+	public Connection close();
+
+	public void afterTransaction();
+
+	public void coordinateWork(Work work);
+
+	public void executeBatch();
+
+	public void cancelLastQuery();
+
+	public void setTransactionTimeOut(int timeout);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcResourceRegistry.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcResourceRegistry.java
index 078c6d48ec..4ec5c57ee3 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcResourceRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcResourceRegistry.java
@@ -1,85 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
+import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.Statement;
 
 /**
  * Defines a registry of JDBC resources related to a particular unit of work.
  *
  * @author Steve Ebersole
  */
-public interface JdbcResourceRegistry {
+public interface JdbcResourceRegistry extends Serializable {
 	/**
 	 * Register a JDBC statement.
 	 *
 	 * @param statement The statement to register.
 	 */
 	public void register(Statement statement);
 
 	public void registerLastQuery(Statement statement);
 
 	public void cancelLastQuery();
 	
 	/**
 	 * Release a previously registered statement.
 	 *
 	 * @param statement The statement to release.
 	 */
 	public void release(Statement statement);
 
 	/**
 	 * Register a JDBC result set.
 	 *
 	 * @param resultSet The result set to register.
 	 */
 	public void register(ResultSet resultSet);
 
 	/**
 	 * Release a previously registered result set.
 	 *
 	 * @param resultSet The result set to release.
 	 */
 	public void release(ResultSet resultSet);
 
 	/**
 	 * Does this registry currently have any registered resources?
 	 *
 	 * @return True if the registry does have registered resources; false otherwise.
 	 */
 	public boolean hasRegisteredResources();
 
 	/**
 	 * Release all registered resources.
 	 */
 	public void releaseResources();
 
 	/**
 	 * Close this registry.  Also {@link #releaseResources releases} any registered resources.
 	 * <p/>
 	 * After execution, the registry is considered unusable.
 	 */
 	public void close();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnection.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnection.java
index 1c54e3f6aa..0a237d0860 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnection.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnection.java
@@ -1,71 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
 import java.io.Serializable;
 import java.sql.Connection;
 
 /**
  * LogicalConnection contract
  *
  * @author Steve Ebersole
  */
-public interface LogicalConnection {
+public interface LogicalConnection extends Serializable {
 	/**
 	 * Is this logical connection open?  Another phraseology sometimes used is: "are we
 	 * logically connected"?
 	 *
 	 * @return True if logically connected; false otherwise.
 	 */
 	public boolean isOpen();
 
 	/**
 	 * Is this logical connection instance "physically" connected.  Meaning
 	 * do we currently internally have a cached connection.
 	 *
 	 * @return True if physically connected; false otherwise.
 	 */
 	public boolean isPhysicallyConnected();
 
 	/**
 	 * Retrieves the connection currently "logically" managed by this LogicalConnectionImpl.
 	 * <p/>
 	 * Note, that we may need to obtain a connection to return here if a
 	 * connection has either not yet been obtained (non-UserSuppliedConnectionProvider)
 	 * or has previously been aggressively released.
 	 *
+	 * @todo ?? Move this to {@link LogicalConnectionImplementor} in lieu of {@link #getShareableConnectionProxy} and {@link #getDistinctConnectionProxy} ??
+	 *
 	 * @return The current Connection.
 	 */
 	public Connection getConnection();
 
 	/**
+	 * Retrieves the shareable connection proxy (see {@link org.hibernate.engine.jdbc.internal.proxy} for details).
+	 *
+	 * @return The shareable connection proxy.
+	 */
+	public Connection getShareableConnectionProxy();
+
+	/**
+	 * Retrieves a distinct connection proxy (see {@link org.hibernate.engine.jdbc.internal.proxy} for details).  It
+	 * is distinct in that it is not shared with others unless the caller explicitly shares it.
+	 *
+	 * @return The distinct connection proxy.
+	 */
+	public Connection getDistinctConnectionProxy();
+
+	/**
 	 * Release the underlying connection and clean up any other resources associated
 	 * with this logical connection.
 	 * <p/>
 	 * This leaves the logical connection in a "no longer useable" state.
 	 *
 	 * @return The physical connection which was being used.
 	 */
 	public Connection close();
+
+	public void afterTransaction();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnectionImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnectionImplementor.java
index 288554ff35..4c505836bd 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnectionImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/LogicalConnectionImplementor.java
@@ -1,95 +1,119 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
 import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.jdbc.internal.proxy.ConnectionProxyHandler;
 import org.hibernate.stat.StatisticsImplementor;
 
+import java.sql.Connection;
+
 /**
  * The "internal" contract for LogicalConnection
  *
  * @author Steve Ebersole
  */
 public interface LogicalConnectionImplementor extends LogicalConnection {
 	/**
 	 * Obtains the JDBC services associated with this logical connection.
 	 *
 	 * @return JDBC services
 	 */
 	public JdbcServices getJdbcServices();
 
 	/**
-	 * Obtains the statistics implementor.
-	 *
-	 * @return the statistics implementor
-	 */
-	public StatisticsImplementor getStatisticsImplementor();
-
-	/**
 	 * Obtains the JDBC resource registry associated with this logical connection.
 	 *
 	 * @return The JDBC resource registry.
 	 */
 	public JdbcResourceRegistry getResourceRegistry();
 
 	/**
 	 * Add an observer interested in notification of connection events.
 	 *
 	 * @param observer The observer.
 	 */
 	public void addObserver(ConnectionObserver observer);
 
 	/**
+	 * Remove an observer
+	 *
+	 * @param connectionObserver The observer to remove.
+	 */
+	public void removeObserver(ConnectionObserver connectionObserver);
+
+	/**
 	 * The release mode under which this logical connection is operating.
 	 *
 	 * @return the release mode.
 	 */
 	public ConnectionReleaseMode getConnectionReleaseMode();
 
 	/**
 	 * Used to signify that a statement has completed execution which may
 	 * indicate that this logical connection need to perform an
 	 * aggressive release of its physical connection.
 	 */
 	public void afterStatementExecution();
 
 	/**
 	 * Used to signify that a transaction has completed which may indicate
 	 * that this logical connection need to perform an aggressive release
 	 * of its physical connection.
 	 */
 	public void afterTransaction();
 
 	/**
 	 * Manually (and temporarily) circumvent aggressive release processing.
 	 */
 	public void disableReleases();
 
 	/**
 	 * Re-enable aggressive release processing (after a prior {@link #disableReleases()} call.
 	 */
 	public void enableReleases();
 
+	/**
+	 * Manually disconnect the underlying JDBC Connection.  The assumption here
+	 * is that the manager will be reconnected at a later point in time.
+	 *
+	 * @return The connection maintained here at time of disconnect.  Null if
+	 * there was no connection cached internally.
+	 */
+	public Connection manualDisconnect();
+
+	/**
+	 * Manually reconnect the underlying JDBC Connection.  Should be called at some point after manualDisconnect().
+	 *
+	 * @param suppliedConnection For user supplied connection strategy the user needs to hand us the connection
+	 * with which to reconnect.  It is an error to pass a connection in the other strategies.
+	 */
+	public void manualReconnect(Connection suppliedConnection);
+
+	public boolean isAutoCommit();
+
+	public boolean isReadyForSerialization();
 
+	public void notifyObserversStatementPrepared();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JBossTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/NonDurableConnectionObserver.java
similarity index 65%
rename from hibernate-core/src/main/java/org/hibernate/transaction/JBossTransactionManagerLookup.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/NonDurableConnectionObserver.java
index cdfd63390a..7a84ded4f9 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JBossTransactionManagerLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/NonDurableConnectionObserver.java
@@ -1,42 +1,33 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.transaction;
+package org.hibernate.engine.jdbc.spi;
 
 /**
- * A {@link TransactionManagerLookup} lookup strategy for JBoss AS.
+ * Additional optional contract for connection observers to indicate that they should be released when the physical
+ * connection is released.
  *
- * @author Gavin King
+ * @author Steve Ebersole
  */
-public final class JBossTransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	protected String getName() {
-		return "java:/TransactionManager";
-	}
-
-	public String getUserTransactionName() {
-		return "UserTransaction";
-	}
-
+public interface NonDurableConnectionObserver extends ConnectionObserver {
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/SQLExceptionHelper.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/SQLExceptionHelper.java
index bb70a938cf..0db12c826b 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/SQLExceptionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/SQLExceptionHelper.java
@@ -1,212 +1,213 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
+import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.JDBCException;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.exception.SQLStateConverter;
 import org.hibernate.exception.ViolatedConstraintNameExtracter;
 import org.hibernate.util.StringHelper;
 
 /**
  * Helper for handling SQLExceptions in various manners.
  *
  * @author Steve Ebersole
  */
-public class SQLExceptionHelper {
+public class SQLExceptionHelper implements Serializable {
 	private static final Logger log = LoggerFactory.getLogger( SQLExceptionHelper.class );
 
 	public static final String DEFAULT_EXCEPTION_MSG = "SQL Exception";
 	public static final String DEFAULT_WARNING_MSG = "SQL Warning";
 
 	public static final SQLExceptionConverter DEFAULT_CONVERTER = new SQLStateConverter(
 			new ViolatedConstraintNameExtracter() {
 				public String extractConstraintName(SQLException e) {
 					return null;
 				}
 			}
 	);
 
 	private SQLExceptionConverter sqlExceptionConverter;
 
 	/**
 	 * Create an exception helper with a default exception converter.
 	 */
 	public SQLExceptionHelper() {
 		sqlExceptionConverter = DEFAULT_CONVERTER;
 	}
 
 	/**
 	 * Create an exception helper with a specific exception converter.
 	 *
 	 * @param sqlExceptionConverter The exception converter to use.
 	 */
 	public SQLExceptionHelper(SQLExceptionConverter sqlExceptionConverter) {
 		this.sqlExceptionConverter = sqlExceptionConverter;
 	}
 
 	/**
 	 * Access the current exception converter being used internally.
 	 *
 	 * @return The current exception converter.
 	 */
 	public SQLExceptionConverter getSqlExceptionConverter() {
 		return sqlExceptionConverter;
 	}
 
 	/**
 	 * Inject the exception converter to use.
 	 * <p/>
 	 * NOTE : <tt>null</tt> is allowed and signifies to use the default.
 	 *
 	 * @param sqlExceptionConverter The converter to use.
 	 */
 	public void setSqlExceptionConverter(SQLExceptionConverter sqlExceptionConverter) {
 		this.sqlExceptionConverter = ( sqlExceptionConverter == null ? DEFAULT_CONVERTER : sqlExceptionConverter );
 	}
 
 	/**
 	 * Convert an SQLException using the current converter, doing some logging first.
 	 *
 	 * @param sqle The exception to convert
 	 * @param message An error message.
 	 * @return The converted exception
 	 */
 	public JDBCException convert(SQLException sqle, String message) {
 		return convert( sqle, message, "n/a" );
 	}
 
 	/**
 	 * Convert an SQLException using the current converter, doing some logging first.
 	 *
 	 * @param sqle The exception to convert
 	 * @param message An error message.
 	 * @param sql The SQL being executed when the exception occurred
 	 * @return The converted exception
 	 */
 	public JDBCException convert(SQLException sqle, String message, String sql) {
 		logExceptions( sqle, message + " [" + sql + "]" );
 		return sqlExceptionConverter.convert( sqle, message, sql );
 	}
 
 	/**
 	 * Log any {@link java.sql.SQLWarning}s registered with the connection.
 	 *
 	 * @param connection The connection to check for warnings.
 	 */
 	public void logAndClearWarnings(Connection connection) {
 		if ( log.isWarnEnabled() ) {
 			try {
 				logWarnings( connection.getWarnings() );
 			}
 			catch ( SQLException sqle ) {
 				//workaround for WebLogic
 				log.debug( "could not log warnings", sqle );
 			}
 		}
 		try {
 			//Sybase fail if we don't do that, sigh...
 			connection.clearWarnings();
 		}
 		catch ( SQLException sqle ) {
 			log.debug( "could not clear warnings", sqle );
 		}
 
 	}
 
 	/**
 	 * Log the given (and any nested) warning.
 	 *
 	 * @param warning The warning
 	 */
 	public void logWarnings(SQLWarning warning) {
 		logWarnings( warning, null );
 	}
 
 	/**
 	 * Log the given (and any nested) warning.
 	 *
 	 * @param warning The warning
 	 * @param message The message text to use as a preamble.
 	 */
 	public void logWarnings(SQLWarning warning, String message) {
 		if ( log.isWarnEnabled() ) {
 			if ( log.isDebugEnabled() && warning != null ) {
 				message = StringHelper.isNotEmpty( message ) ? message : DEFAULT_WARNING_MSG;
 				log.debug( message, warning );
 			}
 			while ( warning != null ) {
 				StringBuffer buf = new StringBuffer( 30 )
 						.append( "SQL Warning: " )
 						.append( warning.getErrorCode() )
 						.append( ", SQLState: " )
 						.append( warning.getSQLState() );
 				log.warn( buf.toString() );
 				log.warn( warning.getMessage() );
 				warning = warning.getNextWarning();
 			}
 		}
 	}
 
 	/**
 	 * Log the given (and any nested) exception.
 	 *
 	 * @param sqlException The exception to log
 	 */
 	public void logExceptions(SQLException sqlException) {
 		logExceptions( sqlException, null );
 	}
 
 	/**
 	 * Log the given (and any nested) exception.
 	 *
 	 * @param sqlException The exception to log
 	 * @param message The message text to use as a preamble.
 	 */
 	public void logExceptions(SQLException sqlException, String message) {
 		if ( log.isErrorEnabled() ) {
 			if ( log.isDebugEnabled() ) {
 				message = StringHelper.isNotEmpty( message ) ? message : DEFAULT_EXCEPTION_MSG;
 				log.debug( message, sqlException );
 			}
 			while ( sqlException != null ) {
 				StringBuffer buf = new StringBuffer( 30 )
 						.append( "SQL Error: " )
 						.append( sqlException.getErrorCode() )
 						.append( ", SQLState: " )
 						.append( sqlException.getSQLState() );
 				log.warn( buf.toString() );
 				log.error( sqlException.getMessage() );
 				sqlException = sqlException.getNextException();
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/StatementPreparer.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/StatementPreparer.java
new file mode 100644
index 0000000000..56c02e6653
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/StatementPreparer.java
@@ -0,0 +1,97 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.jdbc.spi;
+
+import org.hibernate.ScrollMode;
+
+import java.sql.PreparedStatement;
+
+/**
+ * @author Steve Ebersole
+ */
+public interface StatementPreparer {
+	/**
+	 * Prepare a statement.
+	 *
+	 * @param sql The SQL the statement to be prepared
+	 *
+	 * @return the prepared statement
+	 */
+	public PreparedStatement prepareStatement(String sql);
+
+	/**
+	 * Prepare a statement.
+	 *
+	 * @param sql The SQL the statement to be prepared
+	 * @param isCallable Whether to prepare as a callable statement.
+	 *
+	 * @return the prepared statement
+	 */
+	public PreparedStatement prepareStatement(String sql, boolean isCallable);
+
+	/**
+	 * Get a prepared statement to use for inserting using JDBC3
+	 * {@link java.sql.PreparedStatement#getGeneratedKeys getGeneratedKeys} processing.
+	 *
+	 * @param sql - the SQL for the statement to be prepared
+	 * @param autoGeneratedKeys - a flag indicating whether auto-generated keys should be returned; one of<ul>
+	 *     <li>{@link PreparedStatement#RETURN_GENERATED_KEYS}</li>
+	 *     <li>{@link PreparedStatement#NO_GENERATED_KEYS}</li>
+	 *     </li>
+	 *
+	 * @return the prepared statement
+	 *
+	 * @see java.sql.Connection#prepareStatement(String, int)
+	 */
+	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys);
+
+
+	/**
+	 * Get a prepared statement to use for inserting using JDBC3
+	 * {@link java.sql.PreparedStatement#getGeneratedKeys getGeneratedKeys} processing.
+	 *
+	 * @param sql - the SQL for the statement to be prepared
+	 * @param columnNames The name of the columns to be returned in the generated keys result set.
+	 *
+	 * @return the prepared statement
+	 *
+	 * @see java.sql.Connection#prepareStatement(String, String[])
+	 */
+	public PreparedStatement prepareStatement(String sql, String[] columnNames);
+
+	/**
+	 * Get a prepared statement for use in loading / querying.
+	 *
+	 * @param sql The SQL the statement to be prepared
+	 * @param isCallable Whether to prepare as a callable statement.
+	 * @param scrollMode (optional) scroll mode to be applied to the resulting result set; may be null to indicate
+	 * no scrolling should be applied.
+	 *
+	 * @return the prepared statement
+	 */
+	public PreparedStatement prepareQueryStatement(String sql, boolean isCallable, ScrollMode scrollMode);
+
+	public void setTransactionTimeOut(int timeout);
+	public void unsetTransactionTimeOut();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/NativeSQLQueryPlan.java b/hibernate-core/src/main/java/org/hibernate/engine/query/NativeSQLQueryPlan.java
index e930ef4ff4..dfa7d3c94f 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/NativeSQLQueryPlan.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/NativeSQLQueryPlan.java
@@ -1,225 +1,225 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine.query;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.HibernateException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
 import org.hibernate.action.BulkOperationCleanupAction;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.TypedValue;
 import org.hibernate.event.EventSource;
 import org.hibernate.loader.custom.sql.SQLCustomQuery;
 import org.hibernate.type.Type;
 import org.hibernate.util.ArrayHelper;
 
 /**
  * Defines a query execution plan for a native-SQL query.
  *
  * @author Steve Ebersole
  */
 public class NativeSQLQueryPlan implements Serializable {
 	private final String sourceQuery;
 
 	private final SQLCustomQuery customQuery;
 
 	private static final Logger log = LoggerFactory.getLogger(NativeSQLQueryPlan.class);
 
 	public NativeSQLQueryPlan(
 			NativeSQLQuerySpecification specification,
 			SessionFactoryImplementor factory) {
 		this.sourceQuery = specification.getQueryString();
 
 		customQuery = new SQLCustomQuery(
 				specification.getQueryString(),
 				specification.getQueryReturns(),
 				specification.getQuerySpaces(),
 				factory );
 	}
 
 	public String getSourceQuery() {
 		return sourceQuery;
 	}
 
 	public SQLCustomQuery getCustomQuery() {
 		return customQuery;
 	}
 
 	private int[] getNamedParameterLocs(String name) throws QueryException {
 		Object loc = customQuery.getNamedParameterBindPoints().get( name );
 		if ( loc == null ) {
 			throw new QueryException(
 					"Named parameter does not appear in Query: " + name,
 					customQuery.getSQL() );
 		}
 		if ( loc instanceof Integer ) {
 			return new int[] { ((Integer) loc ).intValue() };
 		}
 		else {
 			return ArrayHelper.toIntArray( (List) loc );
 		}
 	}
 
 	/**
 	 * Perform binding of all the JDBC bind parameter values based on the user-defined
 	 * positional query parameters (these are the '?'-style hibernate query
 	 * params) into the JDBC {@link PreparedStatement}.
 	 *
 	 * @param st The prepared statement to which to bind the parameter values.
 	 * @param queryParameters The query parameters specified by the application.
 	 * @param start JDBC paramer binds are positional, so this is the position
 	 * from which to start binding.
 	 * @param session The session from which the query originated.
 	 *
 	 * @return The number of JDBC bind positions accounted for during execution.
 	 *
 	 * @throws SQLException Some form of JDBC error binding the values.
 	 * @throws HibernateException Generally indicates a mapping problem or type mismatch.
 	 */
 	private int bindPositionalParameters(
 			final PreparedStatement st,
 			final QueryParameters queryParameters,
 			final int start,
 			final SessionImplementor session) throws SQLException {
 		final Object[] values = queryParameters.getFilteredPositionalParameterValues();
 		final Type[] types = queryParameters.getFilteredPositionalParameterTypes();
 		int span = 0;
 		for (int i = 0; i < values.length; i++) {
 			types[i].nullSafeSet( st, values[i], start + span, session );
 			span += types[i].getColumnSpan( session.getFactory() );
 		}
 		return span;
 	}
 
 	/**
 	 * Perform binding of all the JDBC bind parameter values based on the user-defined
 	 * named query parameters into the JDBC {@link PreparedStatement}.
 	 *
 	 * @param ps The prepared statement to which to bind the parameter values.
 	 * @param namedParams The named query parameters specified by the application.
 	 * @param start JDBC paramer binds are positional, so this is the position
 	 * from which to start binding.
 	 * @param session The session from which the query originated.
 	 *
 	 * @return The number of JDBC bind positions accounted for during execution.
 	 *
 	 * @throws SQLException Some form of JDBC error binding the values.
 	 * @throws HibernateException Generally indicates a mapping problem or type mismatch.
 	 */
 	private int bindNamedParameters(
 			final PreparedStatement ps,
 			final Map namedParams,
 			final int start,
 			final SessionImplementor session) throws SQLException {
 		if ( namedParams != null ) {
 			// assumes that types are all of span 1
 			Iterator iter = namedParams.entrySet().iterator();
 			int result = 0;
 			while ( iter.hasNext() ) {
 				Map.Entry e = (Map.Entry) iter.next();
 				String name = (String) e.getKey();
 				TypedValue typedval = (TypedValue) e.getValue();
 				int[] locs = getNamedParameterLocs( name );
 				for (int i = 0; i < locs.length; i++) {
 					if ( log.isDebugEnabled() ) {
 						log.debug( "bindNamedParameters() "
 								+ typedval.getValue() + " -> " + name + " ["
 								+ (locs[i] + start ) + "]" );
 					}
 					typedval.getType().nullSafeSet( ps, typedval.getValue(),
 							locs[i] + start, session );
 				}
 				result += locs.length;
 			}
 			return result;
 		}
 		else {
 			return 0;
 		}
 	}
 
 	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
 		BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );
 
 		if ( session.isEventSource() ) {
 			( ( EventSource ) session ).getActionQueue().addAction( action );
 		}
 		else {
 			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
 		}
 	}
 
 	public int performExecuteUpdate(QueryParameters queryParameters,
 			SessionImplementor session) throws HibernateException {
 
 		coordinateSharedCacheCleanup( session );
 
 		if(queryParameters.isCallable()) {
 			throw new IllegalArgumentException("callable not yet supported for native queries");
 		}
 
 		int result = 0;
 		PreparedStatement ps;
 		try {
 			queryParameters.processFilters( this.customQuery.getSQL(),
 					session );
 			String sql = queryParameters.getFilteredSQL();
 
-			ps = session.getJDBCContext().getConnectionManager().prepareStatement( sql, false );
+			ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 
 			try {
 				int col = 1;
 				col += bindPositionalParameters( ps, queryParameters, col,
 						session );
 				col += bindNamedParameters( ps, queryParameters
 						.getNamedParameters(), col, session );
 				result = ps.executeUpdate();
 			}
 			finally {
 				if ( ps != null ) {
 					ps.close();
 				}
 			}
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle, "could not execute native bulk manipulation query", this.sourceQuery );
 		}
 
 		return result;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/Isolater.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/Isolater.java
deleted file mode 100644
index ba2c75f799..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/Isolater.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.engine.transaction;
-
-import java.sql.Connection;
-import java.sql.SQLException;
-import javax.transaction.Transaction;
-import javax.transaction.TransactionManager;
-import javax.transaction.SystemException;
-import javax.transaction.NotSupportedException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.hibernate.HibernateException;
-import org.hibernate.engine.SessionImplementor;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.exception.JDBCExceptionHelper;
-import org.hibernate.exception.SQLExceptionConverter;
-
-/**
- * Class which provides the isolation semantics required by
- * an {@link IsolatedWork}.  Processing comes in two flavors:<ul>
- * <li>{@link #doIsolatedWork} : makes sure the work to be done is
- * performed in a seperate, distinct transaction</li>
- * <li>{@link #doNonTransactedWork} : makes sure the work to be
- * done is performed outside the scope of any transaction</li>
- * </ul>
- *
- * @author Steve Ebersole
- */
-public class Isolater {
-
-	private static final Logger log = LoggerFactory.getLogger( Isolater.class );
-
-	/**
-	 * Ensures that all processing actually performed by the given work will
-	 * occur on a seperate transaction.
-	 *
-	 * @param work The work to be performed.
-	 * @param session The session from which this request is originating.
-	 * @throws HibernateException
-	 */
-	public static void doIsolatedWork(IsolatedWork work, SessionImplementor session) throws HibernateException {
-		boolean isJta = session.getFactory().getTransactionManager() != null;
-		if ( isJta ) {
-			new JtaDelegate( session ).delegateWork( work, true );
-		}
-		else {
-			new JdbcDelegate( session ).delegateWork( work, true );
-		}
-	}
-
-	/**
-	 * Ensures that all processing actually performed by the given work will
-	 * occur outside of a transaction.
-	 *
-	 * @param work The work to be performed.
-	 * @param session The session from which this request is originating.
-	 * @throws HibernateException
-	 */
-	public static void doNonTransactedWork(IsolatedWork work, SessionImplementor session) throws HibernateException {
-		boolean isJta = session.getFactory().getTransactionManager() != null;
-		if ( isJta ) {
-			new JtaDelegate( session ).delegateWork( work, false );
-		}
-		else {
-			new JdbcDelegate( session ).delegateWork( work, false );
-		}
-	}
-
-	// should be ok performance-wise to generate new delegate instances for each
-	// request since these are locally stack-scoped.  Besides, it makes the code
-	// much easier to read than the old TransactionHelper stuff...
-
-	private static interface Delegate {
-		public void delegateWork(IsolatedWork work, boolean transacted) throws HibernateException;
-	}
-
-	/**
-	 * An isolation delegate for JTA-based transactions.  Essentially susepnds
-	 * any current transaction, does the work in a new transaction, and then
-	 * resumes the initial transaction (if there was one).
-	 */
-	public static class JtaDelegate implements Delegate {
-		private final SessionImplementor session;
-
-		public JtaDelegate(SessionImplementor session) {
-			this.session = session;
-		}
-
-		public void delegateWork(IsolatedWork work, boolean transacted) throws HibernateException {
-			TransactionManager transactionManager = session.getFactory().getTransactionManager();
-
-			try {
-				// First we suspend any current JTA transaction
-				Transaction surroundingTransaction = transactionManager.suspend();
-				if ( log.isDebugEnabled() ) {
-					log.debug( "surrounding JTA transaction suspended [" + surroundingTransaction + "]" );
-				}
-
-				boolean hadProblems = false;
-				try {
-					// then peform the requested work
-					if ( transacted ) {
-						doTheWorkInNewTransaction( work, transactionManager );
-					}
-					else {
-						doTheWorkInNoTransaction( work );
-					}
-				}
-				catch ( HibernateException e ) {
-					hadProblems = true;
-					throw e;
-				}
-				finally {
-					try {
-						transactionManager.resume( surroundingTransaction );
-						if ( log.isDebugEnabled() ) {
-							log.debug( "surrounding JTA transaction resumed [" + surroundingTransaction + "]" );
-						}
-					}
-					catch( Throwable t ) {
-						// if the actually work had an error use that, otherwise error based on t
-						if ( !hadProblems ) {
-							//noinspection ThrowFromFinallyBlock
-							throw new HibernateException( "Unable to resume previously suspended transaction", t );
-						}
-					}
-				}
-			}
-			catch ( SystemException e ) {
-				throw new HibernateException( "Unable to suspend current JTA transaction", e );
-			}
-		}
-
-		private void doTheWorkInNewTransaction(IsolatedWork work, TransactionManager transactionManager) {
-			try {
-				// start the new isolated transaction
-				transactionManager.begin();
-
-				try {
-					doTheWork( work );
-					// if everythign went ok, commit the isolated transaction
-					transactionManager.commit();
-				}
-				catch ( Exception e ) {
-					try {
-						transactionManager.rollback();
-					}
-					catch ( Exception ignore ) {
-						log.info( "Unable to rollback isolated transaction on error [" + e + "] : [" + ignore + "]" );
-					}
-				}
-			}
-			catch ( SystemException e ) {
-				throw new HibernateException( "Unable to start isolated transaction", e );
-			}
-			catch ( NotSupportedException e ) {
-				throw new HibernateException( "Unable to start isolated transaction", e );
-			}
-		}
-
-		private void doTheWorkInNoTransaction(IsolatedWork work) {
-			doTheWork( work );
-		}
-
-		private void doTheWork(IsolatedWork work) {
-			try {
-				// obtain our isolated connection
-				Connection connection = session.getFactory().getConnectionProvider().getConnection();
-				try {
-					// do the actual work
-					work.doWork( connection );
-				}
-				catch ( HibernateException e ) {
-					throw e;
-				}
-				catch ( Exception e ) {
-					throw new HibernateException( "Unable to perform isolated work", e );
-				}
-				finally {
-					try {
-						// no matter what, release the connection (handle)
-						session.getFactory().getConnectionProvider().closeConnection( connection );
-					}
-					catch ( Throwable ignore ) {
-						log.info( "Unable to release isolated connection [" + ignore + "]" );
-					}
-				}
-			}
-			catch ( SQLException sqle ) {
-				throw sqlExceptionHelper().convert(
-						sqle,
-						"unable to obtain isolated JDBC connection"
-				);
-			}
-		}
-
-		private SQLExceptionHelper sqlExceptionHelper() {
-			return session.getFactory().getSQLExceptionHelper();
-		}
-	}
-
-	/**
-	 * An isolation delegate for JDBC-based transactions.  Basically just
-	 * grabs a new connection and does the work on that.
-	 */
-	public static class JdbcDelegate implements Delegate {
-		private final SessionImplementor session;
-
-		public JdbcDelegate(SessionImplementor session) {
-			this.session = session;
-		}
-
-		public void delegateWork(IsolatedWork work, boolean transacted) throws HibernateException {
-			boolean wasAutoCommit = false;
-			try {
-				Connection connection = session.getFactory().getConnectionProvider().getConnection();
-				try {
-					if ( transacted ) {
-						if ( connection.getAutoCommit() ) {
-							wasAutoCommit = true;
-							connection.setAutoCommit( false );
-						}
-					}
-
-					work.doWork( connection );
-
-					if ( transacted ) {
-						connection.commit();
-					}
-				}
-				catch( Exception e ) {
-					try {
-						if ( transacted && !connection.isClosed() ) {
-							connection.rollback();
-						}
-					}
-					catch( Exception ignore ) {
-						log.info( "unable to rollback connection on exception [" + ignore + "]" );
-					}
-
-					if ( e instanceof HibernateException ) {
-						throw ( HibernateException ) e;
-					}
-					else if ( e instanceof SQLException ) {
-						throw sqlExceptionHelper().convert(
-								( SQLException ) e,
-								"error performing isolated work"
-						);
-					}
-					else {
-						throw new HibernateException( "error performing isolated work", e );
-					}
-				}
-				finally {
-					if ( transacted && wasAutoCommit ) {
-						try {
-							connection.setAutoCommit( true );
-						}
-						catch( Exception ignore ) {
-							log.trace( "was unable to reset connection back to auto-commit" );
-						}
-					}
-					try {
-						session.getFactory().getConnectionProvider().closeConnection( connection );
-					}
-					catch ( Exception ignore ) {
-						log.info( "Unable to release isolated connection [" + ignore + "]" );
-					}
-				}
-			}
-			catch ( SQLException sqle ) {
-				throw sqlExceptionHelper().convert(
-						sqle,
-						"unable to obtain isolated JDBC connection"
-				);
-			}
-		}
-
-		private SQLExceptionHelper sqlExceptionHelper() {
-			return session.getFactory().getSQLExceptionHelper();
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/NullSynchronizationException.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/NullSynchronizationException.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/engine/transaction/NullSynchronizationException.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/NullSynchronizationException.java
index 083ba68072..e4080b7b62 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/NullSynchronizationException.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/NullSynchronizationException.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.engine.transaction;
+package org.hibernate.engine.transaction.internal;
 
 import org.hibernate.HibernateException;
 
 /**
- * TODO : javadoc
+ * Indicates an attempt to register a null synchronization.  Basically a glorified {@link NullPointerException}
  *
  * @author Steve Ebersole
  */
 public class NullSynchronizationException extends HibernateException {
 	public NullSynchronizationException() {
 		this( "Synchronization to register cannot be null" );
 	}
 
 	public NullSynchronizationException(String s) {
 		super( s );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/SynchronizationRegistry.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/SynchronizationRegistryImpl.java
similarity index 75%
rename from hibernate-core/src/main/java/org/hibernate/engine/transaction/SynchronizationRegistry.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/SynchronizationRegistryImpl.java
index c0a3ad9e68..ca504aac1b 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/SynchronizationRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/SynchronizationRegistryImpl.java
@@ -1,101 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.engine.transaction;
+package org.hibernate.engine.transaction.internal;
+
+import org.hibernate.engine.transaction.spi.SynchronizationRegistry;
 
 import java.util.LinkedHashSet;
 import javax.transaction.Synchronization;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.HibernateException;
-
 /**
  * Manages a registry of {@link Synchronization Synchronizations}.
  *
  * @author Steve Ebersole
  */
-public class SynchronizationRegistry {
-	private static final Logger log = LoggerFactory.getLogger( SynchronizationRegistry.class );
+public class SynchronizationRegistryImpl implements SynchronizationRegistry {
+	private static final Logger log = LoggerFactory.getLogger( SynchronizationRegistryImpl.class );
 
 	private LinkedHashSet<Synchronization> synchronizations;
 
-	/**
-	 * Register a user {@link Synchronization} callback for this transaction.
-	 *
-	 * @param synchronization The synchronization callback to register.
-	 * 
-	 * @throws HibernateException
-	 */
+	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		if ( synchronization == null ) {
 			throw new NullSynchronizationException();
 		}
 
 		if ( synchronizations == null ) {
 			synchronizations = new LinkedHashSet<Synchronization>();
 		}
 
 		boolean added = synchronizations.add( synchronization );
 		if ( !added ) {
 			log.info( "Synchronization [{}] was already registered", synchronization );
 		}
 	}
 
-	/**
-	 * Delegate {@link Synchronization#beforeCompletion} calls to {@link #registerSynchronization registered}
-	 * {@link Synchronization Synchronizations}
-	 */
+	@Override
 	public void notifySynchronizationsBeforeTransactionCompletion() {
 		if ( synchronizations != null ) {
 			for ( Synchronization synchronization : synchronizations ) {
 				try {
 					synchronization.beforeCompletion();
 				}
 				catch ( Throwable t ) {
 					log.error( "exception calling user Synchronization [{}]", synchronization, t );
 				}
 			}
 		}
 	}
 
-	/**
-	 * Delegate {@link Synchronization#afterCompletion} calls to {@link #registerSynchronization registered}
-	 * {@link Synchronization Synchronizations}
-	 *
-	 * @param status The transaction status (if known) per {@link javax.transaction.Status}
-	 */
+	@Override
 	public void notifySynchronizationsAfterTransactionCompletion(int status) {
 		if ( synchronizations != null ) {
 			for ( Synchronization synchronization : synchronizations ) {
 				try {
 					synchronization.afterCompletion( status );
 				}
 				catch ( Throwable t ) {
 					log.error( "exception calling user Synchronization [{}]", synchronization, t );
 				}
 			}
 		}
 	}
+
+	/**
+	 * Package-protected access to clear registered synchronizations.
+	 */
+	void clearSynchronizations() {
+		if ( synchronizations != null ) {
+			synchronizations.clear();
+			synchronizations = null;
+		}
+	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java
new file mode 100644
index 0000000000..b9d4fc59ff
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java
@@ -0,0 +1,348 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.ResourceClosedException;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.SynchronizationRegistry;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.engine.transaction.spi.TransactionObserver;
+import org.hibernate.engine.transaction.synchronization.internal.RegisteredSynchronization;
+import org.hibernate.engine.transaction.synchronization.internal.SynchronizationCallbackCoordinatorImpl;
+import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.util.CollectionHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.sql.Connection;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Standard implementation of the Hibernate {@link TransactionCoordinator}
+ * <p/>
+ * IMPL NOTE : Custom serialization handling!
+ *
+ * @author Steve Ebersole
+ */
+public class TransactionCoordinatorImpl implements TransactionCoordinator {
+	private static final Logger log = LoggerFactory.getLogger( TransactionCoordinatorImpl.class );
+
+	private final transient TransactionContext transactionContext;
+	private final transient JdbcCoordinatorImpl jdbcCoordinator;
+
+	private final transient List<TransactionObserver> observers;
+	private final transient SynchronizationRegistryImpl synchronizationRegistry;
+
+	private transient TransactionImplementor currentHibernateTransaction;
+
+	private transient SynchronizationCallbackCoordinatorImpl callbackCoordinator;
+
+	private transient boolean open = true;
+	private transient boolean synchronizationRegistered;
+	private transient boolean ownershipTaken;
+
+	public TransactionCoordinatorImpl(
+			Connection userSuppliedConnection,
+			TransactionContext transactionContext) {
+		this.transactionContext = transactionContext;
+		this.jdbcCoordinator = new JdbcCoordinatorImpl( userSuppliedConnection, this );
+		this.observers = new ArrayList<TransactionObserver>();
+		this.synchronizationRegistry = new SynchronizationRegistryImpl();
+		reset();
+
+		final boolean registerSynchronization = transactionContext.isAutoCloseSessionEnabled()
+		        || transactionContext.isFlushBeforeCompletionEnabled()
+		        || transactionContext.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION;
+		if ( registerSynchronization ) {
+			pulse();
+		}
+	}
+
+	public TransactionCoordinatorImpl(
+			TransactionContext transactionContext,
+			JdbcCoordinatorImpl jdbcCoordinator,
+			List<TransactionObserver> observers) {
+		this.transactionContext = transactionContext;
+		this.jdbcCoordinator = jdbcCoordinator;
+		this.observers = observers;
+		this.synchronizationRegistry = new SynchronizationRegistryImpl();
+		reset();
+	}
+
+	/**
+	 * Reset the internal state.
+	 */
+	public void reset() {
+		synchronizationRegistered = false;
+		ownershipTaken = false;
+
+		if ( currentHibernateTransaction != null ) {
+			currentHibernateTransaction.invalidate();
+		}
+		currentHibernateTransaction = transactionFactory().createTransaction( this );
+
+		// IMPL NOTE : reset clears synchronizations (following jta spec), but not observers!
+		synchronizationRegistry.clearSynchronizations();
+	}
+
+	public void afterTransaction(TransactionImplementor hibernateTransaction, int status) {
+		log.trace( "after transaction completion" );
+
+		final boolean success = JtaStatusHelper.isCommitted( status );
+
+		// todo : handle stats as observer?
+		// as is this messes up unit tests which do not build a sf
+//		if ( sessionFactory().getStatistics().isStatisticsEnabled() ) {
+//			sessionFactory().getStatisticsImplementor().endTransaction( success );
+//		}
+
+		getJdbcCoordinator().afterTransaction();
+
+		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
+		sendAfterTransactionCompletionNotifications( hibernateTransaction, status );
+		reset();
+	}
+
+	private SessionFactoryImplementor sessionFactory() {
+		return transactionContext.getTransactionEnvironment().getSessionFactory();
+	}
+
+	public boolean isSynchronizationRegistered() {
+		return synchronizationRegistered;
+	}
+
+	@Override
+	@SuppressWarnings( {"unchecked"})
+	public boolean isTransactionInProgress() {
+		return getTransaction().isActive() &&
+				transactionFactory().getJoinStatus( this, getTransaction() ) == JoinStatus.JOINED;
+	}
+
+	@Override
+	public TransactionContext getTransactionContext() {
+		return transactionContext;
+	}
+
+	@Override
+	public JdbcCoordinator getJdbcCoordinator() {
+		return jdbcCoordinator;
+	}
+
+	private TransactionFactory transactionFactory() {
+		return getTransactionEnvironment().getTransactionFactory();
+	}
+
+	private TransactionEnvironment getTransactionEnvironment() {
+		return getTransactionContext().getTransactionEnvironment();
+	}
+
+	@Override
+	public TransactionImplementor getTransaction() {
+		if ( ! open ) {
+			throw new ResourceClosedException( "This TransactionCoordinator has been closed" );
+		}
+		pulse();
+		return currentHibernateTransaction;
+	}
+
+	public void afterNonTransactionalQuery(boolean success) {
+		// check to see if the connection is in auto-commit mode (no connection means aggressive connection
+		// release outside a JTA transaction context, so MUST be autocommit mode)
+		boolean isAutocommit = getJdbcCoordinator().getLogicalConnection().isAutoCommit();
+		getJdbcCoordinator().getLogicalConnection().afterTransaction();
+
+		if ( isAutocommit ) {
+			for ( TransactionObserver observer : observers ) {
+				observer.afterCompletion( success, this.getTransaction() );
+			}
+		}
+	}
+
+	@Override
+	public void resetJoinStatus() {
+		getTransaction().resetJoinStatus();
+	}
+
+	@SuppressWarnings({ "unchecked" })
+	private void attemptToRegisterJtaSync() {
+		if ( synchronizationRegistered ) {
+			return;
+		}
+
+		// Has the local transaction (Hibernate facade) taken on the responsibility of driving the transaction inflow?
+		if ( currentHibernateTransaction.isInitiator() ) {
+			return;
+		}
+
+		// IMPL NOTE : At this point the local callback is the "maybe" one.  The only time that needs to change is if
+		// we are able to successfully register the transaction synchronization in which case the local callback would  become
+		// non driving.  To that end, the following checks are simply opt outs where we are unable to register the
+		// synchronization
+
+		JtaPlatform jtaPlatform = getTransactionEnvironment().getJtaPlatform();
+		if ( jtaPlatform == null ) {
+			// if no jta platform was registered we wont be able to register a jta synchronization
+			return;
+		}
+
+		// Can we resister a synchronization
+		if ( ! jtaPlatform.canRegisterSynchronization() ) {
+			log.trace(  "registered JTA platform says we cannot currently resister synchronization; skipping" );
+			return;
+		}
+
+		// Should we resister a synchronization
+		if ( ! transactionFactory().isJoinableJtaTransaction( this, currentHibernateTransaction ) ) {
+			log.trace( "TransactionFactory reported no JTA transaction to join; skipping Synchronization registration" );
+			return;
+		}
+
+		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
+		synchronizationRegistered = true;
+		log.debug( "successfully registered Synchronization" );
+	}
+
+	@Override
+	public SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {
+		if ( callbackCoordinator == null ) {
+			callbackCoordinator = new SynchronizationCallbackCoordinatorImpl( this );
+		}
+		return callbackCoordinator;
+	}
+
+	public void pulse() {
+		log.trace( "Starting transaction coordinator pulse" );
+		if ( transactionFactory().compatibleWithJtaSynchronization() ) {
+			// the configured transaction strategy says it supports callbacks via JTA synchronization, so attempt to
+			// register JTA synchronization if possible
+			attemptToRegisterJtaSync();
+		}
+	}
+
+	public Connection close() {
+		open = false;
+		reset();
+		observers.clear();
+		return jdbcCoordinator.close();
+	}
+
+	public SynchronizationRegistry getSynchronizationRegistry() {
+		return synchronizationRegistry;
+	}
+
+	public void addObserver(TransactionObserver observer) {
+		observers.add( observer );
+	}
+
+	@Override
+	@SuppressWarnings( {"unchecked"})
+	public boolean isTransactionJoinable() {
+		return transactionFactory().isJoinableJtaTransaction( this, currentHibernateTransaction );
+	}
+
+	@Override
+	@SuppressWarnings( {"unchecked"})
+	public boolean isTransactionJoined() {
+		return transactionFactory().getJoinStatus( this, currentHibernateTransaction ) == JoinStatus.JOINED;
+	}
+
+	public void setRollbackOnly() {
+		getTransaction().markRollbackOnly();
+	}
+
+	@Override
+	public boolean takeOwnership() {
+		if ( ownershipTaken ) {
+			return false;
+		}
+		else {
+			ownershipTaken = true;
+			return true;
+		}
+	}
+
+	@Override
+	public void sendAfterTransactionBeginNotifications(TransactionImplementor hibernateTransaction) {
+		for ( TransactionObserver observer : observers ) {
+			observer.afterBegin( currentHibernateTransaction );
+		}
+	}
+
+	@Override
+	public void sendBeforeTransactionCompletionNotifications(TransactionImplementor hibernateTransaction) {
+		synchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();
+		for ( TransactionObserver observer : observers ) {
+			observer.beforeCompletion( hibernateTransaction );
+		}
+	}
+
+	@Override
+	public void sendAfterTransactionCompletionNotifications(TransactionImplementor hibernateTransaction, int status) {
+		final boolean successful = JtaStatusHelper.isCommitted( status );
+		for ( TransactionObserver observer : observers ) {
+			observer.afterCompletion( successful, hibernateTransaction );
+		}
+		synchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( status );
+	}
+
+
+	// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+	public void serialize(ObjectOutputStream oos) throws IOException {
+		jdbcCoordinator.serialize( oos );
+		oos.writeInt( observers.size() );
+		for ( TransactionObserver observer : observers ) {
+			oos.writeObject( observer );
+		}
+	}
+
+	public static TransactionCoordinatorImpl deserialize(
+			ObjectInputStream ois,
+			TransactionContext transactionContext) throws ClassNotFoundException, IOException {
+		final JdbcCoordinatorImpl jdbcCoordinator = JdbcCoordinatorImpl.deserialize( ois, transactionContext );
+		final int observerCount = ois.readInt();
+		final List<TransactionObserver> observers = CollectionHelper.arrayList( observerCount );
+		for ( int i = 0; i < observerCount; i++ ) {
+			observers.add( (TransactionObserver) ois.readObject() );
+		}
+		final TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( transactionContext, jdbcCoordinator, observers );
+		jdbcCoordinator.afterDeserialize( transactionCoordinator );
+		return transactionCoordinator;
+	}
+
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java
new file mode 100644
index 0000000000..a72526ff98
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java
@@ -0,0 +1,96 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal;
+
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.hibernate.HibernateException;
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
+import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
+import org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.service.spi.ServiceInitiator;
+import org.hibernate.service.spi.ServiceRegistry;
+
+/**
+ * Standard instantiator for the standard {@link TransactionFactory} service.
+ *
+ * @author Steve Ebersole
+ */
+public class TransactionFactoryInitiator implements ServiceInitiator<TransactionFactory> {
+	private static final Logger log = LoggerFactory.getLogger( TransactionFactoryInitiator.class );
+
+	public static final TransactionFactoryInitiator INSTANCE = new TransactionFactoryInitiator();
+
+	@Override
+	public Class<TransactionFactory> getServiceInitiated() {
+		return TransactionFactory.class;
+	}
+
+	@Override
+	public TransactionFactory initiateService(Map configVales, ServiceRegistry registry) {
+		final Object strategy = configVales.get( Environment.TRANSACTION_STRATEGY );
+		if ( TransactionFactory.class.isInstance( strategy ) ) {
+			return (TransactionFactory) strategy;
+		}
+
+		if ( strategy == null ) {
+			log.info( "Using default transaction strategy (direct JDBC transactions)" );
+			return new JdbcTransactionFactory();
+		}
+
+		final String strategyClassName = mapLegacyNames( strategy.toString() );
+		log.info( "Transaction strategy: " + strategyClassName );
+
+		ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
+		try {
+			return (TransactionFactory) classLoaderService.classForName( strategyClassName ).newInstance();
+		}
+		catch ( Exception e ) {
+			throw new HibernateException( "Unable to instantiate specified TransactionFactory class [" + strategyClassName + "]", e );
+		}
+	}
+
+	private String mapLegacyNames(String name) {
+		if ( "org.hibernate.transaction.JDBCTransactionFactory".equals( name ) ) {
+			return JdbcTransactionFactory.class.getName();
+		}
+
+		if ( "org.hibernate.transaction.JTATransactionFactory".equals( name ) ) {
+			return JtaTransactionFactory.class.getName();
+		}
+
+		if ( "org.hibernate.transaction.CMTTransactionFactory".equals( name ) ) {
+			return CMTTransactionFactory.class.getName();
+		}
+
+		return name;
+	}
+}
+
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcIsolationDelegate.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcIsolationDelegate.java
new file mode 100644
index 0000000000..01a4e611d2
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcIsolationDelegate.java
@@ -0,0 +1,123 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jdbc;
+
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.hibernate.HibernateException;
+import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
+import org.hibernate.engine.transaction.spi.IsolationDelegate;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.jdbc.Work;
+import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+
+/**
+ * The isolation delegate for JDBC {@link Connection} based transactions
+ *
+ * @author Steve Ebersole
+ */
+public class JdbcIsolationDelegate implements IsolationDelegate {
+	private static final Logger log = LoggerFactory.getLogger( JdbcIsolationDelegate.class );
+
+	private final TransactionCoordinator transactionCoordinator;
+
+	public JdbcIsolationDelegate(TransactionCoordinator transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
+	}
+
+	protected ConnectionProvider connectionProvider() {
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getJdbcServices().getConnectionProvider();
+	}
+
+	protected SQLExceptionHelper sqlExceptionHelper() {
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getJdbcServices().getSqlExceptionHelper();
+	}
+
+	@Override
+	public void delegateWork(Work work, boolean transacted) throws HibernateException {
+		boolean wasAutoCommit = false;
+		try {
+			// todo : should we use a connection proxy here?
+			Connection connection = connectionProvider().getConnection();
+			try {
+				if ( transacted ) {
+					if ( connection.getAutoCommit() ) {
+						wasAutoCommit = true;
+						connection.setAutoCommit( false );
+					}
+				}
+
+				work.execute( connection );
+
+				if ( transacted ) {
+					connection.commit();
+				}
+			}
+			catch ( Exception e ) {
+				try {
+					if ( transacted && !connection.isClosed() ) {
+						connection.rollback();
+					}
+				}
+				catch ( Exception ignore ) {
+					log.info( "unable to rollback connection on exception [" + ignore + "]" );
+				}
+
+				if ( e instanceof HibernateException ) {
+					throw (HibernateException) e;
+				}
+				else if ( e instanceof SQLException ) {
+					throw sqlExceptionHelper().convert( (SQLException) e, "error performing isolated work" );
+				}
+				else {
+					throw new HibernateException( "error performing isolated work", e );
+				}
+			}
+			finally {
+				if ( transacted && wasAutoCommit ) {
+					try {
+						connection.setAutoCommit( true );
+					}
+					catch ( Exception ignore ) {
+						log.trace( "was unable to reset connection back to auto-commit" );
+					}
+				}
+				try {
+					connectionProvider().closeConnection( connection );
+				}
+				catch ( Exception ignore ) {
+					log.info( "Unable to release isolated connection [" + ignore + "]" );
+				}
+			}
+		}
+		catch ( SQLException sqle ) {
+			throw sqlExceptionHelper().convert( sqle, "unable to obtain isolated JDBC connection" );
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java
new file mode 100644
index 0000000000..9896ffe917
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java
@@ -0,0 +1,208 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jdbc;
+
+import org.hibernate.HibernateException;
+import org.hibernate.TransactionException;
+import org.hibernate.engine.transaction.spi.AbstractTransactionImpl;
+import org.hibernate.engine.transaction.spi.IsolationDelegate;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.LocalStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+/**
+ * {@link org.hibernate.Transaction} implementation based on transaction management through a JDBC {@link java.sql.Connection}.
+ * <p/>
+ * This the default transaction strategy.
+ *
+ * @author Anton van Straaten
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class JdbcTransaction extends AbstractTransactionImpl {
+	private static final Logger log = LoggerFactory.getLogger( JdbcTransaction.class );
+
+	private Connection managedConnection;
+	private boolean wasInitiallyAutoCommit;
+	private boolean isDriver;
+
+	protected JdbcTransaction(TransactionCoordinator transactionCoordinator) {
+		super( transactionCoordinator );
+	}
+
+	@Override
+	protected void doBegin() {
+		try {
+			if ( managedConnection != null ) {
+				throw new TransactionException( "Already have an associated managed connection" );
+			}
+			managedConnection = transactionCoordinator().getJdbcCoordinator().getLogicalConnection().getConnection();
+			wasInitiallyAutoCommit = managedConnection.getAutoCommit();
+			if ( log.isDebugEnabled() ) {
+				log.debug( "initial autocommit status: " + wasInitiallyAutoCommit );
+			}
+			if ( wasInitiallyAutoCommit ) {
+				log.debug( "disabling autocommit" );
+				managedConnection.setAutoCommit( false );
+			}
+		}
+		catch( SQLException e ) {
+			throw new TransactionException( "JDBC begin transaction failed: ", e );
+		}
+
+		isDriver = transactionCoordinator().takeOwnership();
+	}
+
+	@Override
+	protected void afterTransactionBegin() {
+		if ( getTimeout() > 0 ) {
+			transactionCoordinator().getJdbcCoordinator().setTransactionTimeOut( getTimeout() );
+		}
+		transactionCoordinator().sendAfterTransactionBeginNotifications( this );
+		if ( isDriver ) {
+			transactionCoordinator().getTransactionContext().afterTransactionBegin( this );
+		}
+	}
+
+	@Override
+	protected void beforeTransactionCommit() {
+		transactionCoordinator().sendBeforeTransactionCompletionNotifications( this );
+
+		// basically, if we are the driver of the transaction perform a managed flush prior to
+		// physically committing the transaction
+		if ( isDriver && !transactionCoordinator().getTransactionContext().isFlushModeNever() ) {
+			// if an exception occurs during flush, user must call rollback()
+			transactionCoordinator().getTransactionContext().managedFlush();
+		}
+
+		if ( isDriver ) {
+			transactionCoordinator().getTransactionContext().beforeTransactionCompletion( this );
+		}
+	}
+
+	@Override
+	protected void doCommit() throws TransactionException {
+		try {
+			managedConnection.commit();
+			log.debug( "committed JDBC Connection" );
+		}
+		catch( SQLException e ) {
+			throw new TransactionException( "unable to commit against JDBC connection", e );
+		}
+		finally {
+			releaseManagedConnection();
+		}
+	}
+
+	private void releaseManagedConnection() {
+		try {
+			if ( wasInitiallyAutoCommit ) {
+				log.debug( "re-enabling autocommit" );
+				managedConnection.setAutoCommit( true );
+			}
+			managedConnection = null;
+		}
+		catch ( Exception e ) {
+			log.debug( "Could not toggle autocommit", e );
+		}
+	}
+
+	@Override
+	protected void afterTransactionCompletion(int status) {
+		transactionCoordinator().afterTransaction( this, status );
+	}
+
+	@Override
+	protected void afterAfterCompletion() {
+		if ( isDriver
+				&& transactionCoordinator().getTransactionContext().shouldAutoClose()
+				&& !transactionCoordinator().getTransactionContext().isClosed() ) {
+			try {
+				transactionCoordinator().getTransactionContext().managedClose();
+			}
+			catch (HibernateException e) {
+				log.info( "Could not close session; swallowing exception as transaction completed", e );
+			}
+		}
+	}
+
+	@Override
+	protected void beforeTransactionRollBack() {
+		// nothing to do here
+	}
+
+	@Override
+	protected void doRollback() throws TransactionException {
+		try {
+			managedConnection.rollback();
+			log.debug( "rolled JDBC Connection" );
+		}
+		catch( SQLException e ) {
+			throw new TransactionException( "unable to rollback against JDBC connection", e );
+		}
+		finally {
+			releaseManagedConnection();
+		}
+	}
+
+	@Override
+	public boolean isInitiator() {
+		return isActive();
+	}
+
+	@Override
+	public IsolationDelegate createIsolationDelegate() {
+		return new JdbcIsolationDelegate( transactionCoordinator() );
+	}
+
+	@Override
+	public JoinStatus getJoinStatus() {
+		return isActive() ? JoinStatus.JOINED : JoinStatus.NOT_JOINED;
+	}
+
+	@Override
+	public void markRollbackOnly() {
+		// nothing to do here
+	}
+
+	@Override
+	public void join() {
+		// nothing to do
+	}
+
+	@Override
+	public void resetJoinStatus() {
+		// nothing to do
+	}
+
+	@Override
+	public boolean isActive() throws HibernateException {
+		return getLocalStatus() == LocalStatus.ACTIVE;
+	}
+}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java
new file mode 100644
index 0000000000..494d886dcf
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java
@@ -0,0 +1,71 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jdbc;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+
+/**
+ * Factory for {@link org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction} instances.
+ *
+ * @author Anton van Straaten
+ * @author Steve Ebersole
+ */
+public final class JdbcTransactionFactory implements TransactionFactory<JdbcTransaction> {
+	@Override
+	public JdbcTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
+		return new JdbcTransaction( transactionCoordinator );
+	}
+
+	@Override
+	public boolean canBeDriver() {
+		return true;
+	}
+
+	@Override
+	public ConnectionReleaseMode getDefaultReleaseMode() {
+		return ConnectionReleaseMode.ON_CLOSE;
+	}
+
+	@Override
+	public boolean compatibleWithJtaSynchronization() {
+		return false;
+	}
+
+
+
+
+
+	@Override
+	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, JdbcTransaction transaction) {
+		return false;
+	}
+
+	@Override
+	public JoinStatus getJoinStatus(TransactionCoordinator transactionCoordinator, JdbcTransaction transaction) {
+		return transaction.getJoinStatus();
+	}
+}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransaction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransaction.java
new file mode 100644
index 0000000000..1600f20930
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransaction.java
@@ -0,0 +1,154 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jta;
+
+import org.hibernate.TransactionException;
+import org.hibernate.engine.transaction.spi.AbstractTransactionImpl;
+import org.hibernate.engine.transaction.spi.IsolationDelegate;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+
+import javax.transaction.SystemException;
+import javax.transaction.TransactionManager;
+
+/**
+ * Implements a transaction strategy for Container Managed Transaction (CMT) scenarios.  All work is done in
+ * the context of the container managed transaction.
+ * <p/>
+ * The term 'CMT' is potentially misleading; the pertinent point simply being that the transactions are being
+ * managed by something other than the Hibernate transaction mechanism.
+ * <p/>
+ * Additionally, this strategy does *not* attempt to access or use the {@link javax.transaction.UserTransaction} since
+ * in the actual case CMT access to the {@link javax.transaction.UserTransaction} is explicitly disallowed.  Instead
+ * we use the JTA {@link javax.transaction.Transaction} object obtained from the {@link TransactionManager}
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class CMTTransaction extends AbstractTransactionImpl {
+	protected CMTTransaction(TransactionCoordinator transactionCoordinator) {
+		super( transactionCoordinator );
+	}
+
+	protected TransactionManager transactionManager() {
+		return jtaPlatform().retrieveTransactionManager();
+	}
+
+	private TransactionManager getTransactionManager() {
+		return transactionManager();
+	}
+
+	@Override
+	protected void doBegin() {
+		transactionCoordinator().pulse();
+	}
+
+	@Override
+	protected void afterTransactionBegin() {
+		if ( ! transactionCoordinator().isSynchronizationRegistered() ) {
+			throw new TransactionException("Could not register synchronization for container transaction");
+		}
+		transactionCoordinator().sendAfterTransactionBeginNotifications( this );
+		transactionCoordinator().getTransactionContext().afterTransactionBegin( this );
+	}
+
+	@Override
+	protected void beforeTransactionCommit() {
+		boolean flush = ! transactionCoordinator().getTransactionContext().isFlushModeNever() &&
+				! transactionCoordinator().getTransactionContext().isFlushBeforeCompletionEnabled();
+		if ( flush ) {
+			// if an exception occurs during flush, user must call rollback()
+			transactionCoordinator().getTransactionContext().managedFlush();
+		}
+	}
+
+	@Override
+	protected void doCommit() {
+		// nothing to do
+	}
+
+	@Override
+	protected void beforeTransactionRollBack() {
+		// nothing to do
+	}
+
+	@Override
+	protected void doRollback() {
+		markRollbackOnly();
+	}
+
+	@Override
+	protected void afterTransactionCompletion(int status) {
+		// nothing to do
+	}
+
+	@Override
+	protected void afterAfterCompletion() {
+		// nothing to do
+	}
+
+	@Override
+	public boolean isActive() throws TransactionException {
+		return JtaStatusHelper.isActive( getTransactionManager() );
+	}
+
+	@Override
+	public IsolationDelegate createIsolationDelegate() {
+		return new JtaIsolationDelegate( transactionCoordinator() );
+	}
+
+	@Override
+	public boolean isInitiator() {
+		return false; // cannot be
+	}
+
+	@Override
+	public void markRollbackOnly() {
+		try {
+			getTransactionManager().setRollbackOnly();
+		}
+		catch ( SystemException se ) {
+			throw new TransactionException("Could not set transaction to rollback only", se);
+		}
+	}
+
+	@Override
+	public void join() {
+		// todo : implement method body
+	}
+
+	@Override
+	public void resetJoinStatus() {
+		// todo : implement method body
+	}
+
+	boolean isJoinable() {
+		return JtaStatusHelper.isActive( transactionManager() );
+	}
+
+	@Override
+	public JoinStatus getJoinStatus() {
+		return isJoinable() ? JoinStatus.JOINED : JoinStatus.NOT_JOINED;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/CMTTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransactionFactory.java
old mode 100755
new mode 100644
similarity index 50%
rename from hibernate-core/src/main/java/org/hibernate/transaction/CMTTransactionFactory.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransactionFactory.java
index fac6e191d1..42a79256ce
--- a/hibernate-core/src/main/java/org/hibernate/transaction/CMTTransactionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/CMTTransactionFactory.java
@@ -1,79 +1,83 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.transaction;
-
-import java.util.Properties;
+package org.hibernate.engine.transaction.internal.jta;
 
 import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
 import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.util.JTAHelper;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
 
 import javax.transaction.SystemException;
 
 /**
- * Factory for {@link CMTTransaction} instances.
+ * Factory for Container Managed Transaction (CMT) based transaction facades.
  *
+ * @author Steve Ebersole
  * @author Gavin King
  */
-public class CMTTransactionFactory implements TransactionFactory {
-
-	public ConnectionReleaseMode getDefaultReleaseMode() {
-		return ConnectionReleaseMode.AFTER_STATEMENT;
+public class CMTTransactionFactory  implements TransactionFactory<CMTTransaction> {
+	@Override
+	public CMTTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
+		return new CMTTransaction( transactionCoordinator );
 	}
 
-	public void configure(Properties props) throws HibernateException {}
-
-	public Transaction createTransaction(JDBCContext jdbcContext, Context transactionContext)
-	throws HibernateException {
-		return new CMTTransaction(jdbcContext, transactionContext);
+	@Override
+	public boolean canBeDriver() {
+		return false;
 	}
 
-	public boolean isTransactionManagerRequired() {
-		return true;
+	@Override
+	public ConnectionReleaseMode getDefaultReleaseMode() {
+		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
-	public boolean areCallbacksLocalToHibernateTransactions() {
-		return false;
+	@Override
+	public boolean compatibleWithJtaSynchronization() {
+		return true;
 	}
 
-	public boolean isTransactionInProgress(
-			JDBCContext jdbcContext,
-	        Context transactionContext,
-	        Transaction transaction) {
+	@Override
+	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, CMTTransaction transaction) {
 		try {
-			return JTAHelper.isTransactionInProgress(
-					transactionContext.getFactory().getTransactionManager().getTransaction()
-			);
+			final int status = transactionCoordinator
+					.getTransactionContext()
+					.getTransactionEnvironment()
+					.getJtaPlatform()
+					.retrieveTransactionManager()
+					.getStatus();
+			return JtaStatusHelper.isActive( status );
 		}
 		catch( SystemException se ) {
 			throw new TransactionException( "Unable to check transaction status", se );
 		}
+	}
+
 
+	@Override
+	public JoinStatus getJoinStatus(TransactionCoordinator transactionCoordinator, CMTTransaction transaction) {
+		return null; // todo : implement method body
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaIsolationDelegate.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaIsolationDelegate.java
new file mode 100644
index 0000000000..7e071428fe
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaIsolationDelegate.java
@@ -0,0 +1,185 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jta;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import javax.transaction.NotSupportedException;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.hibernate.HibernateException;
+import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
+import org.hibernate.engine.transaction.spi.IsolationDelegate;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.jdbc.Work;
+import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+
+/**
+ * An isolation delegate for JTA environments.
+ *
+ * @author Steve Ebersole
+ */
+public class JtaIsolationDelegate implements IsolationDelegate {
+	private static final Logger log = LoggerFactory.getLogger( JtaIsolationDelegate.class );
+
+	private final TransactionCoordinator transactionCoordinator;
+
+	public JtaIsolationDelegate(TransactionCoordinator transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
+	}
+
+	protected TransactionManager transactionManager() {
+		return transactionCoordinator.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJtaPlatform()
+				.retrieveTransactionManager();
+	}
+
+	protected ConnectionProvider connectionProvider() {
+		return transactionCoordinator.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJdbcServices()
+				.getConnectionProvider();
+	}
+
+	protected SQLExceptionHelper sqlExceptionHelper() {
+		return transactionCoordinator.getTransactionContext()
+				.getTransactionEnvironment()
+				.getJdbcServices()
+				.getSqlExceptionHelper();
+	}
+
+	@Override
+	public void delegateWork(Work work, boolean transacted) throws HibernateException {
+		TransactionManager transactionManager = transactionManager();
+
+		try {
+			// First we suspend any current JTA transaction
+			Transaction surroundingTransaction = transactionManager.suspend();
+			if ( log.isDebugEnabled() ) {
+				log.debug( "surrounding JTA transaction suspended [" + surroundingTransaction + "]" );
+			}
+
+			boolean hadProblems = false;
+			try {
+				// then perform the requested work
+				if ( transacted ) {
+					doTheWorkInNewTransaction( work, transactionManager );
+				}
+				else {
+					doTheWorkInNoTransaction( work );
+				}
+			}
+			catch ( HibernateException e ) {
+				hadProblems = true;
+				throw e;
+			}
+			finally {
+				try {
+					transactionManager.resume( surroundingTransaction );
+					if ( log.isDebugEnabled() ) {
+						log.debug( "surrounding JTA transaction resumed [" + surroundingTransaction + "]" );
+					}
+				}
+				catch( Throwable t ) {
+					// if the actually work had an error use that, otherwise error based on t
+					if ( !hadProblems ) {
+						//noinspection ThrowFromFinallyBlock
+						throw new HibernateException( "Unable to resume previously suspended transaction", t );
+					}
+				}
+			}
+		}
+		catch ( SystemException e ) {
+			throw new HibernateException( "Unable to suspend current JTA transaction", e );
+		}
+	}
+
+	private void doTheWorkInNewTransaction(Work work, TransactionManager transactionManager) {
+		try {
+			// start the new isolated transaction
+			transactionManager.begin();
+
+			try {
+				doTheWork( work );
+				// if everythign went ok, commit the isolated transaction
+				transactionManager.commit();
+			}
+			catch ( Exception e ) {
+				try {
+					transactionManager.rollback();
+				}
+				catch ( Exception ignore ) {
+					log.info( "Unable to rollback isolated transaction on error [" + e + "] : [" + ignore + "]" );
+				}
+			}
+		}
+		catch ( SystemException e ) {
+			throw new HibernateException( "Unable to start isolated transaction", e );
+		}
+		catch ( NotSupportedException e ) {
+			throw new HibernateException( "Unable to start isolated transaction", e );
+		}
+	}
+
+	private void doTheWorkInNoTransaction(Work work) {
+		doTheWork( work );
+	}
+
+	private void doTheWork(Work work) {
+		try {
+			// obtain our isolated connection
+			Connection connection = connectionProvider().getConnection();
+			try {
+				// do the actual work
+				work.execute( connection );
+			}
+			catch ( HibernateException e ) {
+				throw e;
+			}
+			catch ( Exception e ) {
+				throw new HibernateException( "Unable to perform isolated work", e );
+			}
+			finally {
+				try {
+					// no matter what, release the connection (handle)
+					connectionProvider().closeConnection( connection );
+				}
+				catch ( Throwable ignore ) {
+					log.info( "Unable to release isolated connection [" + ignore + "]" );
+				}
+			}
+		}
+		catch ( SQLException sqle ) {
+			throw sqlExceptionHelper().convert( sqle, "unable to obtain isolated JDBC connection" );
+		}
+	}
+
+}
+
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/jta/JtaStatusHelper.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaStatusHelper.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/internal/util/jta/JtaStatusHelper.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaStatusHelper.java
index d9c2c05e45..639dea75c7 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/jta/JtaStatusHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaStatusHelper.java
@@ -1,198 +1,197 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.internal.util.jta;
+package org.hibernate.engine.transaction.internal.jta;
 
 import javax.transaction.Status;
 import javax.transaction.SystemException;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.TransactionException;
 
 /**
- * Utility for dealing with JTA statses.
+ * Utility for dealing with JTA statuses.
  *
  * @author Steve Ebersole
  */
 public class JtaStatusHelper {
 	/**
 	 * Extract the status code from a {@link UserTransaction}
 	 *
 	 * @param userTransaction The {@link UserTransaction} from which to extract the status.
 	 *
 	 * @return The transaction status
 	 *
 	 * @throws TransactionException If the {@link UserTransaction} reports the status as unknown
 	 */
 	public static int getStatus(UserTransaction userTransaction) {
 		try {
 			final int status = userTransaction.getStatus();
 			if ( status == Status.STATUS_UNKNOWN ) {
-				throw new TransactionException( "UserTransaction reported transaction status as unknwon" );
+				throw new TransactionException( "UserTransaction reported transaction status as unknown" );
 			}
 			return status;
 		}
 		catch ( SystemException se ) {
 			throw new TransactionException( "Could not determine transaction status", se );
 		}
 	}
 
 	/**
 	 * Extract the status code from the current {@link javax.transaction.Transaction} associated with the
 	 * given {@link TransactionManager}
 	 *
 	 * @param transactionManager The {@link TransactionManager} from which to extract the status.
 	 *
 	 * @return The transaction status
 	 *
 	 * @throws TransactionException If the {@link TransactionManager} reports the status as unknown
 	 */
 	public static int getStatus(TransactionManager transactionManager) {
 		try {
 			final int status = transactionManager.getStatus();
 			if ( status == Status.STATUS_UNKNOWN ) {
 				throw new TransactionException( "TransactionManager reported transaction status as unknwon" );
 			}
 			return status;
 		}
 		catch ( SystemException se ) {
 			throw new TransactionException( "Could not determine transaction status", se );
 		}
 	}
 
 	/**
 	 * Does the given status code indicate an active transaction?
 	 *
 	 * @param status The transaction status code to check
 	 *
 	 * @return True if the code indicates active; false otherwise.
 	 */
 	public static boolean isActive(int status) {
 		return status == Status.STATUS_ACTIVE;
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link UserTransaction} indicate an active transaction?
 	 *
 	 * @param userTransaction The {@link UserTransaction} whose status is to be checked
 	 *
-	 * @return True if the transactiion is active; false otherwise.
+	 * @return True if the transaction is active; false otherwise.
 	 */
 	public static boolean isActive(UserTransaction userTransaction) {
 		final int status = getStatus( userTransaction );
 		return isActive( status );
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link TransactionManager} indicate an active transaction?
 	 *
 	 * @param transactionManager The {@link TransactionManager} whose status is to be checked
 	 *
-	 * @return True if the transactiion is active; false otherwise.
+	 * @return True if the transaction is active; false otherwise.
 	 */
 	public static boolean isActive(TransactionManager transactionManager) {
 		return isActive( getStatus( transactionManager ) );
 	}
 
 	/**
 	 * Does the given status code indicate a rolled back transaction?
 	 *
 	 * @param status The transaction status code to check
 	 *
 	 * @return True if the code indicates a roll back; false otherwise.
 	 */
 	public static boolean isRollback(int status) {
 		return status == Status.STATUS_MARKED_ROLLBACK ||
 				status == Status.STATUS_ROLLING_BACK ||
 				status == Status.STATUS_ROLLEDBACK;
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link UserTransaction} indicate a roll back?
 	 *
 	 * @param userTransaction The {@link UserTransaction} whose status is to be checked
 	 *
-	 * @return True if the transactiion indicates roll back; false otherwise.
+	 * @return True if the transaction indicates roll back; false otherwise.
 	 */
 	public static boolean isRollback(UserTransaction userTransaction) {
 		return isRollback( getStatus( userTransaction ) );
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link TransactionManager} indicate a roll back?
 	 *
 	 * @param transactionManager The {@link TransactionManager} whose status is to be checked
 	 *
-	 * @return True if the transactiion indicates roll back; false otherwise.
+	 * @return True if the transaction indicates roll back; false otherwise.
 	 */
 	public static boolean isRollback(TransactionManager transactionManager) {
 		return isRollback( getStatus( transactionManager ) );
 	}
 
 	/**
 	 * Does the given status code indicate a committed transaction?
 	 *
 	 * @param status The transaction status code to check
 	 *
 	 * @return True if the code indicates a roll back; false otherwise.
 	 */
 	public static boolean isCommitted(int status) {
-		return status == Status.STATUS_MARKED_ROLLBACK ||
-				status == Status.STATUS_ROLLING_BACK ||
-				status == Status.STATUS_ROLLEDBACK;
+		return status == Status.STATUS_COMMITTED;
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link UserTransaction} indicate a commit?
 	 *
 	 * @param userTransaction The {@link UserTransaction} whose status is to be checked
 	 *
-	 * @return True if the transactiion indicates commit; false otherwise.
+	 * @return True if the transaction indicates commit; false otherwise.
 	 */
 	public static boolean isCommitted(UserTransaction userTransaction) {
 		return isCommitted( getStatus( userTransaction ) );
 	}
 
 	/**
 	 * Does the status code obtained from the given {@link TransactionManager} indicate a commit?
 	 *
 	 * @param transactionManager The {@link TransactionManager} whose status is to be checked
 	 *
-	 * @return True if the transactiion indicates commit; false otherwise.
+	 * @return True if the transaction indicates commit; false otherwise.
 	 */
 	public static boolean isCommitted(TransactionManager transactionManager) {
 		return isCommitted( getStatus( transactionManager ) );
 	}
 
 	/**
 	 * Does the given status code indicate the transaction has been marked for rollback?
 	 *
 	 * @param status The transaction status code to check
 	 *
 	 * @return True if the code indicates a roll back; false otherwise.
 	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
 	public static boolean isMarkedForRollback(int status) {
 		return status == Status.STATUS_MARKED_ROLLBACK;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransaction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransaction.java
new file mode 100644
index 0000000000..1c06032bf5
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransaction.java
@@ -0,0 +1,276 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jta;
+
+import org.hibernate.HibernateException;
+import org.hibernate.TransactionException;
+import org.hibernate.engine.transaction.spi.AbstractTransactionImpl;
+import org.hibernate.engine.transaction.spi.IsolationDelegate;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.LocalStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.transaction.Status;
+import javax.transaction.SystemException;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * Implements a transaction strategy based on transaction management through a JTA {@link UserTransaction}.
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ * @author Les Hazlewood
+ */
+public class JtaTransaction extends AbstractTransactionImpl {
+	private static final Logger log = LoggerFactory.getLogger( JtaTransaction.class );
+
+	private UserTransaction userTransaction;
+
+	private boolean isInitiator;
+	private boolean isDriver;
+
+	protected JtaTransaction(TransactionCoordinator transactionCoordinator) {
+		super( transactionCoordinator );
+	}
+
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public UserTransaction getUserTransaction() {
+		return userTransaction;
+	}
+
+	@Override
+	protected void doBegin() {
+		log.debug( "begin" );
+
+		userTransaction = jtaPlatform().retrieveUserTransaction();
+		if ( userTransaction == null ) {
+			throw new TransactionException( "Unable to locate JTA UserTransaction" );
+		}
+
+		try {
+			if ( userTransaction.getStatus() == Status.STATUS_NO_TRANSACTION ) {
+				userTransaction.begin();
+				isInitiator = true;
+				log.debug( "Began a new JTA transaction" );
+			}
+		}
+		catch ( Exception e ) {
+			throw new TransactionException( "JTA transaction begin failed", e );
+		}
+
+	}
+
+	@Override
+	protected void afterTransactionBegin() {
+		transactionCoordinator().pulse();
+
+		if ( !transactionCoordinator().isSynchronizationRegistered() ) {
+			isDriver = transactionCoordinator().takeOwnership();
+		}
+
+		applyTimeout();
+		transactionCoordinator().sendAfterTransactionBeginNotifications( this );
+		transactionCoordinator().getTransactionContext().afterTransactionBegin( this );
+	}
+
+	private void applyTimeout() {
+		if ( getTimeout() > 0 ) {
+			if ( userTransaction != null ) {
+				try {
+					userTransaction.setTransactionTimeout( getTimeout() );
+				}
+				catch ( SystemException e ) {
+					throw new TransactionException( "Unable to apply requested transaction timeout", e );
+				}
+			}
+			else {
+				log.debug( "Unable to apply requested transaction timeout; no UserTransaction.  Will try later" );
+			}
+		}
+	}
+
+	@Override
+	protected void beforeTransactionCommit() {
+		transactionCoordinator().sendBeforeTransactionCompletionNotifications( this );
+
+		final boolean flush = ! transactionCoordinator().getTransactionContext().isFlushModeNever() &&
+				( isDriver || ! transactionCoordinator().getTransactionContext().isFlushBeforeCompletionEnabled() );
+
+		if ( flush ) {
+			// if an exception occurs during flush, user must call rollback()
+			transactionCoordinator().getTransactionContext().managedFlush();
+		}
+
+		if ( isDriver && isInitiator ) {
+			transactionCoordinator().getTransactionContext().beforeTransactionCompletion( this );
+		}
+
+		closeIfRequired();
+	}
+
+	private void closeIfRequired() throws HibernateException {
+		final boolean close = isDriver &&
+				transactionCoordinator().getTransactionContext().shouldAutoClose() &&
+				! transactionCoordinator().getTransactionContext().isClosed();
+		if ( close ) {
+			transactionCoordinator().getTransactionContext().managedClose();
+		}
+	}
+
+	@Override
+	protected void doCommit() {
+		try {
+			if ( isInitiator ) {
+				userTransaction.commit();
+				log.debug( "Committed JTA UserTransaction" );
+			}
+		}
+		catch ( Exception e ) {
+			throw new TransactionException( "JTA commit failed: ", e );
+		}
+		finally {
+			isInitiator = false;
+		}
+	}
+
+	@Override
+	protected void afterTransactionCompletion(int status) {
+		// nothing to do
+	}
+
+	@Override
+	protected void afterAfterCompletion() {
+		// this method is a noop if there is a Synchronization!
+		if ( isDriver ) {
+			if ( !isInitiator ) {
+				log.warn( "You should set hibernate.transaction.manager_lookup_class if cache is enabled" );
+			}
+			try {
+				transactionCoordinator().afterTransaction( this, userTransaction.getStatus() );
+			}
+			catch (SystemException e) {
+				throw new TransactionException( "Unable to determine UserTransaction status", e );
+			}
+		}
+	}
+
+	@Override
+	protected void beforeTransactionRollBack() {
+		// nothing to do
+	}
+
+	@Override
+	protected void doRollback() {
+		try {
+			if ( isInitiator ) {
+				// failed commits automatically rollback the transaction per JTA spec
+				if ( getLocalStatus() != LocalStatus.FAILED_COMMIT  ) {
+					userTransaction.rollback();
+					log.debug( "Rolled back JTA UserTransaction" );
+				}
+			}
+			else {
+				markRollbackOnly();
+			}
+		}
+		catch ( Exception e ) {
+			throw new TransactionException( "JTA rollback failed", e );
+		}
+	}
+
+	@Override
+	public void markRollbackOnly() {
+		log.trace( "Marking transaction for rollback only" );
+		try {
+			userTransaction.setRollbackOnly();
+			log.debug( "set JTA UserTransaction to rollback only" );
+		}
+		catch (SystemException e) {
+			log.debug( "Unable to mark transaction for rollback only", e );
+		}
+	}
+
+	@Override
+	public IsolationDelegate createIsolationDelegate() {
+		return new JtaIsolationDelegate( transactionCoordinator() );
+	}
+
+	@Override
+	public boolean isInitiator() {
+		return isInitiator;
+	}
+
+	@Override
+	public boolean isActive() throws HibernateException {
+		if ( getLocalStatus() != LocalStatus.ACTIVE ) {
+			return false;
+		}
+
+		final int status;
+		try {
+			status = userTransaction.getStatus();
+		}
+		catch ( SystemException se ) {
+			throw new TransactionException( "Could not determine transaction status: ", se );
+		}
+		return JtaStatusHelper.isActive( status );
+	}
+
+	@Override
+	public void setTimeout(int seconds) {
+		super.setTimeout( seconds );
+		applyTimeout();
+	}
+
+	@Override
+	public void join() {
+	}
+
+	@Override
+	public void resetJoinStatus() {
+	}
+
+	@Override
+	public JoinStatus getJoinStatus() {
+		// if we already have the UserTransaction cached locally, use it to avoid JNDI look ups
+		if ( this.userTransaction != null ) {
+			return JtaStatusHelper.isActive( this.userTransaction ) ? JoinStatus.JOINED : JoinStatus.NOT_JOINED;
+		}
+
+		// Otherwise, try to use the TransactionManager since it is generally cached
+		TransactionManager transactionManager = jtaPlatform().retrieveTransactionManager();
+		if ( transactionManager != null ) {
+			return JtaStatusHelper.isActive( transactionManager ) ? JoinStatus.JOINED : JoinStatus.NOT_JOINED;
+		}
+
+		// Finally, look up the UserTransaction
+		UserTransaction userTransaction = jtaPlatform().retrieveUserTransaction();
+		return userTransaction != null && JtaStatusHelper.isActive( userTransaction )
+				? JoinStatus.JOINED
+				: JoinStatus.NOT_JOINED;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
new file mode 100644
index 0000000000..3c258bdcbd
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
@@ -0,0 +1,109 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.internal.jta;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.TransactionException;
+import org.hibernate.engine.transaction.spi.JoinStatus;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.util.JTAHelper;
+
+import javax.transaction.SystemException;
+import javax.transaction.UserTransaction;
+
+/**
+ * Factory for {@link JtaTransaction} instances.
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ * @author Les Hazlewood
+ */
+public class JtaTransactionFactory implements TransactionFactory<JtaTransaction> {
+	@Override
+	public JtaTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
+		return new JtaTransaction( transactionCoordinator );
+	}
+
+	@Override
+	public boolean canBeDriver() {
+		return true;
+	}
+
+	@Override
+	public ConnectionReleaseMode getDefaultReleaseMode() {
+		return ConnectionReleaseMode.AFTER_STATEMENT;
+	}
+
+	@Override
+	public boolean compatibleWithJtaSynchronization() {
+		return true;
+	}
+
+	@Override
+	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, JtaTransaction transaction) {
+		try {
+			// Essentially:
+			// 1) If we have a local (Hibernate) transaction in progress
+			//      and it already has the UserTransaction cached, use that
+			//      UserTransaction to determine the status.
+			// 2) If a transaction manager has been located, use
+			//      that transaction manager to determine the status.
+			// 3) Finally, as the last resort, try to lookup the
+			//      UserTransaction via JNDI and use that to determine the
+			//      status.
+			if ( transaction != null ) {
+				UserTransaction ut = transaction.getUserTransaction();
+				if ( ut != null ) {
+					return JTAHelper.isInProgress( ut.getStatus() );
+				}
+			}
+
+			final JtaPlatform jtaPlatform = transactionCoordinator
+					.getTransactionContext()
+					.getTransactionEnvironment()
+					.getJtaPlatform();
+			if ( jtaPlatform == null ) {
+				throw new TransactionException( "Unable to check transaction status" );
+			}
+			if ( jtaPlatform.retrieveTransactionManager() != null ) {
+				return JtaStatusHelper.isActive( jtaPlatform.retrieveTransactionManager().getStatus() );
+			}
+			else {
+				final UserTransaction ut = jtaPlatform.retrieveUserTransaction();
+				return ut != null && JTAHelper.isInProgress( ut.getStatus() );
+			}
+		}
+		catch ( SystemException se ) {
+			throw new TransactionException( "Unable to check transaction status", se );
+		}
+	}
+
+	@Override
+	public JoinStatus getJoinStatus(TransactionCoordinator transactionCoordinator, JtaTransaction transaction) {
+		return null; // todo : implement method body
+	}
+
+}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java
new file mode 100644
index 0000000000..e8b41ae045
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java
@@ -0,0 +1,237 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.HibernateException;
+import org.hibernate.TransactionException;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.transaction.Status;
+import javax.transaction.Synchronization;
+
+/**
+ * Abstract support for creating {@link TransactionImplementor transaction} implementations
+ *
+ * @author Steve Ebersole
+ */
+public abstract class AbstractTransactionImpl implements TransactionImplementor {
+	private static final Logger log = LoggerFactory.getLogger( AbstractTransactionImpl.class );
+
+	private final TransactionCoordinator transactionCoordinator;
+
+	private boolean valid = true;
+
+	private LocalStatus localStatus = LocalStatus.NOT_ACTIVE;
+	private int timeout = -1;
+
+	protected AbstractTransactionImpl(TransactionCoordinator transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
+	}
+
+	@Override
+	public void invalidate() {
+		valid = false;
+	}
+
+	/**
+	 * Perform the actual steps of beginning a transaction according to the strategy.
+	 *
+	 * @throws org.hibernate.TransactionException Indicates a problem beginning the transaction
+	 */
+	protected abstract void doBegin();
+
+	/**
+	 * Perform the actual steps of committing a transaction according to the strategy.
+	 *
+	 * @throws org.hibernate.TransactionException Indicates a problem committing the transaction
+	 */
+	protected abstract void doCommit();
+
+	/**
+	 * Perform the actual steps of rolling back a transaction according to the strategy.
+	 *
+	 * @throws org.hibernate.TransactionException Indicates a problem rolling back the transaction
+	 */
+	protected abstract void doRollback();
+
+	protected abstract void afterTransactionBegin();
+	protected abstract void beforeTransactionCommit();
+	protected abstract void beforeTransactionRollBack();
+	protected abstract void afterTransactionCompletion(int status);
+	protected abstract void afterAfterCompletion();
+
+	/**
+	 * Provide subclasses with access to the transaction coordinator.
+	 *
+	 * @return This transaction's context.
+	 */
+	protected TransactionCoordinator transactionCoordinator() {
+		return transactionCoordinator;
+	}
+
+	/**
+	 * Provide subclasses with convenient access to the configured {@link JtaPlatform}
+	 *
+	 * @return The {@link org.hibernate.service.jta.platform.spi.JtaPlatform}
+	 */
+	protected JtaPlatform jtaPlatform() {
+		return transactionCoordinator().getTransactionContext().getTransactionEnvironment().getJtaPlatform();
+	}
+
+	@Override
+	public void registerSynchronization(Synchronization synchronization) {
+		transactionCoordinator().getSynchronizationRegistry().registerSynchronization( synchronization );
+	}
+
+	@Override
+	public LocalStatus getLocalStatus() {
+		return localStatus;
+	}
+
+	@Override
+	public boolean isActive() {
+		return localStatus == LocalStatus.ACTIVE && doExtendedActiveCheck();
+	}
+
+	@Override
+	public boolean wasCommitted() {
+		return localStatus == LocalStatus.COMMITTED;
+	}
+
+	@Override
+	public boolean wasRolledBack() throws HibernateException {
+		return localStatus == LocalStatus.ROLLED_BACK;
+	}
+
+	/**
+	 * Active has been checked against local state.  Perform any needed checks against resource transactions.
+	 *
+	 * @return {@code true} if the extended active check checks out as well; false otherwise.
+	 */
+	protected boolean doExtendedActiveCheck() {
+		return true;
+	}
+
+	@Override
+	public void begin() throws HibernateException {
+		if ( ! valid ) {
+			throw new TransactionException( "Transaction instance is no longer valid" );
+		}
+		if ( localStatus == LocalStatus.ACTIVE ) {
+			throw new TransactionException( "nested transactions not supported" );
+		}
+		if ( localStatus != LocalStatus.NOT_ACTIVE ) {
+			throw new TransactionException( "reuse of Transaction instances not supported" );
+		}
+
+		log.debug( "begin" );
+
+		doBegin();
+
+		localStatus = LocalStatus.ACTIVE;
+
+		afterTransactionBegin();
+	}
+
+	@Override
+	public void commit() throws HibernateException {
+		if ( localStatus != LocalStatus.ACTIVE ) {
+			throw new TransactionException( "Transaction not successfully started" );
+		}
+
+		log.debug( "committing" );
+
+		beforeTransactionCommit();
+
+		try {
+			doCommit();
+			localStatus = LocalStatus.COMMITTED;
+			afterTransactionCompletion( Status.STATUS_COMMITTED );
+		}
+		catch ( Exception e ) {
+			localStatus = LocalStatus.FAILED_COMMIT;
+			afterTransactionCompletion( Status.STATUS_UNKNOWN );
+			throw new TransactionException( "commit failed", e );
+		}
+		finally {
+			invalidate();
+			afterAfterCompletion();
+		}
+	}
+
+	protected boolean allowFailedCommitToPhysicallyRollback() {
+		return false;
+	}
+
+	@Override
+	public void rollback() throws HibernateException {
+		if ( localStatus != LocalStatus.ACTIVE && localStatus != LocalStatus.FAILED_COMMIT ) {
+			throw new TransactionException( "Transaction not successfully started" );
+		}
+
+		log.debug( "rolling back" );
+
+		beforeTransactionRollBack();
+
+		if ( localStatus != LocalStatus.FAILED_COMMIT || allowFailedCommitToPhysicallyRollback() ) {
+			try {
+				doRollback();
+				localStatus = LocalStatus.ROLLED_BACK;
+				afterTransactionCompletion( Status.STATUS_ROLLEDBACK );
+			}
+			catch ( Exception e ) {
+				afterTransactionCompletion( Status.STATUS_UNKNOWN );
+				throw new TransactionException( "rollback failed", e );
+			}
+			finally {
+				invalidate();
+				afterAfterCompletion();
+			}
+		}
+
+	}
+
+	@Override
+	public void setTimeout(int seconds) {
+		timeout = seconds;
+	}
+
+	@Override
+	public int getTimeout() {
+		return timeout;
+	}
+
+	@Override
+	public void resetJoinStatus() {
+		// generally speaking this is no-op
+	}
+
+	@Override
+	public void join() {
+		// generally speaking this is no-op
+	}
+
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/IsolationDelegate.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/IsolationDelegate.java
new file mode 100644
index 0000000000..68935e95f4
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/IsolationDelegate.java
@@ -0,0 +1,44 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.HibernateException;
+import org.hibernate.jdbc.Work;
+
+/**
+ * Contract for performing work in a manner that isolates it from any current transaction.
+ *
+ * @author Steve Ebersole
+ */
+public interface IsolationDelegate {
+	/**
+	 * Perform the given work in isolation from current transaction.
+	 *
+	 * @param work The work to be performed.
+	 * @param transacted Should the work itself be done in a (isolated) transaction?
+	 *
+	 * @throws HibernateException Indicates a problem performing the work.
+	 */
+	public void delegateWork(Work work, boolean transacted) throws HibernateException;
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/AfterCompletionAction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/JoinStatus.java
similarity index 77%
rename from hibernate-core/src/main/java/org/hibernate/transaction/synchronization/AfterCompletionAction.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/JoinStatus.java
index 29a6d14ffb..f81c71d4ab 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/AfterCompletionAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/JoinStatus.java
@@ -1,35 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction.synchronization;
-
-import org.hibernate.transaction.TransactionFactory;
+package org.hibernate.engine.transaction.spi;
 
 /**
- * TODO : javadoc
+ * See the JPA notion of joining a transaction for details.
  *
+ * @author Emmanuel Bernard
  * @author Steve Ebersole
  */
-public interface AfterCompletionAction {
-	public void doAction(TransactionFactory.Context ctx, int status);
+public enum JoinStatus {
+	NOT_JOINED,
+	MARKED_FOR_JOINED,
+	JOINED
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/LocalStatus.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/LocalStatus.java
new file mode 100644
index 0000000000..ef9343c825
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/LocalStatus.java
@@ -0,0 +1,52 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+/**
+ * Enumeration of statuses in which a local transaction facade ({@link org.hibernate.Transaction}) might be.
+ *
+ * @author Steve Ebersole
+ */
+public enum LocalStatus {
+	/**
+	 * The local transaction has not yet been begun
+	 */
+	NOT_ACTIVE,
+	/**
+	 * The local transaction has been begun, but not yet completed.
+	 */
+	ACTIVE,
+	/**
+	 * The local transaction has been competed successfully.
+	 */
+	COMMITTED,
+	/**
+	 * The local transaction has been rolled back.
+	 */
+	ROLLED_BACK,
+	/**
+	 * The local transaction attempted to commit, but failed.
+	 */
+	FAILED_COMMIT
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/SynchronizationRegistry.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/SynchronizationRegistry.java
new file mode 100644
index 0000000000..bad7582a6f
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/SynchronizationRegistry.java
@@ -0,0 +1,57 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import javax.transaction.Synchronization;
+import java.io.Serializable;
+
+/**
+ * Manages a registry of {@link Synchronization Synchronizations}.
+ *
+ * @author Steve Ebersole
+ */
+public interface SynchronizationRegistry extends Serializable {
+	/**
+	 * Register a user {@link Synchronization} callback for this transaction.
+	 *
+	 * @param synchronization The synchronization callback to register.
+	 *
+	 * @throws org.hibernate.HibernateException
+	 */
+	public void registerSynchronization(Synchronization synchronization);
+
+	/**
+	 * Delegate {@link Synchronization#beforeCompletion} calls to the {@link #registerSynchronization registered}
+	 * {@link Synchronization Synchronizations}
+	 */
+	void notifySynchronizationsBeforeTransactionCompletion();
+
+	/**
+	 * Delegate {@link Synchronization#afterCompletion} calls to {@link #registerSynchronization registered}
+	 * {@link Synchronization Synchronizations}
+	 *
+	 * @param status The transaction status (if known) per {@link javax.transaction.Status}
+	 */
+	void notifySynchronizationsAfterTransactionCompletion(int status);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionContext.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionContext.java
new file mode 100644
index 0000000000..7737980758
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionContext.java
@@ -0,0 +1,105 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.ConnectionReleaseMode;
+
+import java.io.Serializable;
+
+/**
+ * Access to services needed in the context of processing transaction requests.
+ * <p/>
+ * The context is roughly speaking equivalent to the Hibernate session, as opposed to the {@link TransactionEnvironment}
+ * which is roughly equivalent to the Hibernate session factory
+ * 
+ * @author Steve Ebersole
+ */
+public interface TransactionContext extends Serializable {
+	/**
+	 * Obtain the {@link TransactionEnvironment} associated with this context.
+	 *
+	 * @return The transaction environment.
+	 */
+	public TransactionEnvironment getTransactionEnvironment();
+
+	/**
+	 * Get the mode for releasing JDBC connection in effect for ths context.
+	 *
+	 * @return The connection release mode.
+	 */
+	public ConnectionReleaseMode getConnectionReleaseMode();
+
+	/**
+	 * Should session automatically be closed after transaction completion in this context?
+	 *
+	 * @return {@literal true}/{@literal false} appropriately.
+	 */
+	public boolean isAutoCloseSessionEnabled();
+
+	/**
+	 * Is this context already closed?
+	 *
+	 * @return {@literal true}/{@literal false} appropriately.
+	 */
+	public boolean isClosed();
+
+	/**
+	 * Should flushes only happen manually for this context?
+	 *
+	 * @return {@literal true}/{@literal false} appropriately.
+	 */
+	public boolean isFlushModeNever();
+
+	/**
+	 * Should before transaction completion processing perform a flush when initiated from JTA synchronization for this
+	 * context?
+	 *
+	 * @return {@literal true}/{@literal false} appropriately.
+	 */
+	public boolean isFlushBeforeCompletionEnabled();
+
+	/**
+	 * Perform a managed flush.
+	 */
+	public void managedFlush();
+
+	/**
+	 * Should JTA synchronization processing perform a automatic close (call to {@link #managedClose} for this
+	 * context?
+	 * 
+	 * @return {@literal true}/{@literal false} appropriately.
+	 */
+	public boolean shouldAutoClose();
+
+	/**
+	 * Perform a managed close.
+	 */
+	public void managedClose();
+
+	public void afterTransactionBegin(TransactionImplementor hibernateTransaction);
+
+	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction);
+
+	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java
new file mode 100644
index 0000000000..05ad71ab67
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java
@@ -0,0 +1,139 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
+
+import java.io.Serializable;
+import java.sql.Connection;
+
+/**
+ * Acts as the coordinator between the Hibernate engine and physical transactions.
+ *
+ * @author Steve Ebersole
+ */
+public interface TransactionCoordinator extends Serializable {
+	/**
+	 * Retrieves the context in which this coordinator operates.
+	 *
+	 * @return The context of the coordinator
+	 */
+	public TransactionContext getTransactionContext();
+
+	/**
+	 * Retrieves the JDBC coordinator currently operating within this transaction coordinator.
+	 *
+	 * @return The JDBC coordinator.
+	 */
+	public JdbcCoordinator getJdbcCoordinator();
+
+	/**
+	 * Get the Hibernate transaction facade object currently associated with this coordinator.
+	 *
+	 * @return The current Hibernate transaction.
+	 */
+	public TransactionImplementor getTransaction();
+
+	/**
+	 * Obtain the {@link javax.transaction.Synchronization} registry associated with this coordinator.
+	 *
+	 * @return The registry
+	 */
+	public SynchronizationRegistry getSynchronizationRegistry();
+
+	/**
+	 * Adds an observer to the coordinator.
+	 * <p/>
+	 * Unlike synchronizations added to the {@link #getSynchronizationRegistry() registry}, observers are not to be
+	 * cleared on transaction completion.
+	 *
+	 * @param observer The observer to add.
+	 */
+	public void addObserver(TransactionObserver observer);
+
+	/**
+	 * Can we join to the underlying transaction?
+	 *
+	 * @return {@literal true} if the underlying transaction can be joined or is already joined; {@literal false}
+	 * otherwise.
+	 *
+	 * @see TransactionFactory#isJoinableJtaTransaction(TransactionCoordinator, TransactionImplementor)
+	 */
+	public boolean isTransactionJoinable();
+
+	/**
+	 * Is the underlying transaction already joined?
+	 *
+	 * @return {@literal true} if the underlying transaction is already joined; {@literal false} otherwise.
+	 *
+	 * @see TransactionFactory#getJoinStatus(TransactionCoordinator, TransactionImplementor)
+	 */
+	public boolean isTransactionJoined();
+
+	/**
+	 * Reset the transaction's join status.
+	 */
+	public void resetJoinStatus();
+
+	/**
+	 * Are we "in" an active and joined transaction
+	 *
+	 * @return {@literal true} if there is currently a transaction in progress; {@literal false} otherwise.
+	 */
+	public boolean isTransactionInProgress();
+
+	/**
+	 * Attempts to register JTA synchronization if possible and needed.
+	 */
+	public void pulse();
+
+	/**
+	 * Close the transaction context, returning any user supplied connection from the underlying JDBC coordinator.
+	 *
+	 * @return The user supplied connection (if one).
+	 */
+	public Connection close();
+
+	/**
+	 * Performs actions needed after execution of a non-transactional query.
+	 *
+	 * @param success Was the query successfully performed
+	 */
+	public void afterNonTransactionalQuery(boolean success);
+
+	public void setRollbackOnly();
+
+	public SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator();
+
+	public boolean isSynchronizationRegistered();
+	public boolean takeOwnership();
+
+	public void afterTransaction(TransactionImplementor hibernateTransaction, int status);
+
+	public void sendAfterTransactionBeginNotifications(TransactionImplementor hibernateTransaction);
+	public void sendBeforeTransactionCompletionNotifications(TransactionImplementor hibernateTransaction);
+	public void sendAfterTransactionCompletionNotifications(TransactionImplementor hibernateTransaction, int status);
+
+}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java
new file mode 100644
index 0000000000..b916a41b99
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java
@@ -0,0 +1,63 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+
+/**
+ * Provides access to transactional services.
+ *
+ * @author Steve Ebersole
+ */
+public interface TransactionEnvironment {
+	/**
+	 * Retrieve the session factory for this environment.
+	 *
+	 * @return The session factory
+	 */
+	public SessionFactoryImplementor getSessionFactory();
+
+	/**
+	 * Retrieve the JDBC services for this environment.
+	 *
+	 * @return The JDBC services
+	 */
+	public JdbcServices getJdbcServices();
+
+	/**
+	 * Retrieve the JTA platform for this environment.
+	 *
+	 * @return The JTA platform
+	 */
+	public JtaPlatform getJtaPlatform();
+
+	/**
+	 * Retrieve the transaction factory for this environment.
+	 *
+	 * @return The transaction factory
+	 */
+	public TransactionFactory getTransactionFactory();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionFactory.java
new file mode 100644
index 0000000000..3688dd8fe3
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionFactory.java
@@ -0,0 +1,93 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.service.spi.Service;
+
+/**
+ * Contract for transaction creation, as well as providing metadata and contextual information about that creation.
+ *
+ * @author Steve Ebersole
+ */
+public interface TransactionFactory<T extends TransactionImplementor> extends Service {
+	/**
+	 * Construct a transaction instance compatible with this strategy.
+	 *
+	 * @param coordinator The coordinator for this transaction
+	 *
+	 * @return The appropriate transaction instance.
+	 *
+	 * @throws org.hibernate.HibernateException Indicates a problem constructing the transaction.
+	 */
+	public T createTransaction(TransactionCoordinator coordinator);
+
+	/**
+	 * Can the transactions created from this strategy act as the driver?  In other words can the user actually manage
+	 * transactions with this strategy?
+	 *
+	 * @return {@literal true} if the transaction strategy represented by this factory can act as the driver callback;
+	 * {@literal false} otherwise.
+	 */
+	public boolean canBeDriver();
+
+	/**
+	 * Should we attempt to register JTA transaction {@link javax.transaction.Synchronization synchronizations}.
+	 * <p/>
+	 * In other words, is this strategy JTA-based?
+	 *
+	 * @return {@literal true} if the transaction strategy represented by this factory is compatible with registering
+	 * {@link javax.transaction.Synchronization synchronizations}; {@literal false} otherwise.
+	 */
+	public boolean compatibleWithJtaSynchronization();
+
+	/**
+	 * Can the underlying transaction represented by the passed Hibernate {@link TransactionImplementor} be joined?
+	 *
+	 * @param transactionCoordinator The transaction coordinator
+	 * @param transaction The current Hibernate transaction
+	 *
+	 * @return {@literal true} is the transaction can be joined; {@literal false} otherwise.
+	 */
+	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, T transaction);
+
+	/**
+	 * Retrieve the current join status of the Hibernate transaction
+	 *
+	 * @param transactionCoordinator The transaction coordinator
+	 * @param transaction The current Hibernate transaction
+	 *
+	 * @return The join status.
+	 */
+	public JoinStatus getJoinStatus(TransactionCoordinator transactionCoordinator, T transaction);
+
+	/**
+	 * Get the default connection release mode.
+	 *
+	 * @return The default release mode associated with this strategy
+	 */
+	public ConnectionReleaseMode getDefaultReleaseMode();
+
+}
+
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionImplementor.java
new file mode 100644
index 0000000000..57de1d3dfd
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionImplementor.java
@@ -0,0 +1,67 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+import org.hibernate.Transaction;
+
+/**
+ * Additional contract for implementors of the Hibernate {@link Transaction} API.
+ * 
+ * @author Steve Ebersole
+ */
+public interface TransactionImplementor extends Transaction {
+	/**
+	 * Retrieve an isolation delegate appropriate for this transaction strategy.
+	 *
+	 * @return An isolation delegate.
+	 */
+	public IsolationDelegate createIsolationDelegate();
+
+	/**
+	 * Get the current state of this transaction's join status.
+	 *
+	 * @return The current join status
+	 */
+	public JoinStatus getJoinStatus();
+
+	/**
+	 * Perform a join to the underlying transaction
+	 */
+	public void join();
+
+	/**
+	 * Reset this transaction's join status.
+	 */
+	public void resetJoinStatus();
+
+	/**
+	 * Make a best effort to mark the underlying transaction for rollback only.
+	 */
+	public void markRollbackOnly();
+
+	/**
+	 * Called after completion of the underlying transaction to signify the facade is no longer valid.
+	 */
+	public void invalidate();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionObserver.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionObserver.java
new file mode 100644
index 0000000000..5a3472f046
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionObserver.java
@@ -0,0 +1,57 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.spi;
+
+/**
+ * Observer of internal transaction events.
+ *
+ * @author Steve Ebersole
+ */
+public interface TransactionObserver {
+	/**
+	 * Callback for processing the beginning of a transaction.
+	 *
+	 * Do not rely on this being called as the transaction mat be started in a manner other than through the
+	 * {@link org.hibernate.Transaction} API.
+	 *
+	 * @param transaction The Hibernate transaction
+	 */
+	public void afterBegin(TransactionImplementor transaction);
+
+	/**
+	 * Callback for processing the initial phase of transaction completion.
+	 *
+	 * @param transaction The Hibernate transaction
+	 */
+	public void beforeCompletion(TransactionImplementor transaction);
+
+	/**
+	 * Callback for processing the last phase of transaction completion.
+	 *
+	 * @param successful Was the transaction successful?
+	 * @param transaction The Hibernate transaction
+	 */
+	public void afterCompletion(boolean successful, TransactionImplementor transaction);
+}
+
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/HibernateSynchronizationImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/RegisteredSynchronization.java
similarity index 60%
rename from hibernate-core/src/main/java/org/hibernate/transaction/synchronization/HibernateSynchronizationImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/RegisteredSynchronization.java
index 5cd3c5ba48..c8651d8217 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/HibernateSynchronizationImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/RegisteredSynchronization.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction.synchronization;
-
-import javax.transaction.Synchronization;
+package org.hibernate.engine.transaction.synchronization.internal;
 
+import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.transaction.Synchronization;
+
 /**
- * The {@link Synchronization} implementation Hibernate registers with the JTA {@link javax.transaction.Transaction}
+ * The JTA {@link javax.transaction.Synchronization} Hibernate registers when needed for JTA callbacks
  *
- * @author Gavin King
  * @author Steve Ebersole
  */
-public class HibernateSynchronizationImpl implements Synchronization {
-	private static final Logger log = LoggerFactory.getLogger( HibernateSynchronizationImpl.class );
+public class RegisteredSynchronization implements Synchronization {
+	private static final Logger log = LoggerFactory.getLogger( RegisteredSynchronization.class );
 
-	private final CallbackCoordinator coordinator;
+	private final SynchronizationCallbackCoordinator synchronizationCallbackCoordinator;
 
-	public HibernateSynchronizationImpl(CallbackCoordinator coordinator) {
-		this.coordinator = coordinator;
+	public RegisteredSynchronization(SynchronizationCallbackCoordinator synchronizationCallbackCoordinator) {
+		this.synchronizationCallbackCoordinator = synchronizationCallbackCoordinator;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void beforeCompletion() {
 		log.trace( "JTA sync : beforeCompletion()" );
-		coordinator.beforeCompletion();
+		synchronizationCallbackCoordinator.beforeCompletion();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void afterCompletion(int status) {
 		log.trace( "JTA sync : afterCompletion({})", status );
-		coordinator.afterCompletion( status );
+		synchronizationCallbackCoordinator.afterCompletion( status );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/CallbackCoordinator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/SynchronizationCallbackCoordinatorImpl.java
similarity index 53%
rename from hibernate-core/src/main/java/org/hibernate/transaction/synchronization/CallbackCoordinator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/SynchronizationCallbackCoordinatorImpl.java
index 3f42cc2d8c..ff0ba26775 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/CallbackCoordinator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/internal/SynchronizationCallbackCoordinatorImpl.java
@@ -1,185 +1,166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction.synchronization;
-
-import javax.transaction.Status;
-import javax.transaction.SystemException;
-import javax.transaction.Transaction;
+package org.hibernate.engine.transaction.synchronization.internal;
 
+import org.hibernate.TransactionException;
+import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.synchronization.spi.AfterCompletionAction;
+import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
+import org.hibernate.engine.transaction.synchronization.spi.ExceptionMapper;
+import org.hibernate.engine.transaction.synchronization.spi.ManagedFlushChecker;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.transaction.TransactionFactory;
-import org.hibernate.util.JTAHelper;
+import javax.transaction.SystemException;
 
 /**
  * Manages callbacks from the {@link javax.transaction.Synchronization} registered by Hibernate.
  *
  * @author Steve Ebersole
  */
-public class CallbackCoordinator {
-	private static final Logger log = LoggerFactory.getLogger( CallbackCoordinator.class );
+public class SynchronizationCallbackCoordinatorImpl implements SynchronizationCallbackCoordinator {
+	private static final Logger log = LoggerFactory.getLogger( SynchronizationCallbackCoordinatorImpl.class );
 
-	private final TransactionFactory.Context ctx;
-	private JDBCContext jdbcContext;
-	private final Transaction jtaTransaction;
-	private final org.hibernate.Transaction hibernateTransaction;
+	private final TransactionCoordinator transactionCoordinator;
 
-	private BeforeCompletionManagedFlushChecker beforeCompletionManagedFlushChecker;
+	private ManagedFlushChecker managedFlushChecker;
 	private AfterCompletionAction afterCompletionAction;
 	private ExceptionMapper exceptionMapper;
 
-	public CallbackCoordinator(
-			TransactionFactory.Context ctx,
-			JDBCContext jdbcContext,
-			Transaction jtaTransaction,
-			org.hibernate.Transaction hibernateTransaction) {
-		this.ctx = ctx;
-		this.jdbcContext = jdbcContext;
-		this.jtaTransaction = jtaTransaction;
-		this.hibernateTransaction = hibernateTransaction;
+	public SynchronizationCallbackCoordinatorImpl(TransactionCoordinator transactionCoordinator) {
+		this.transactionCoordinator = transactionCoordinator;
 		reset();
 	}
 
 	public void reset() {
-		beforeCompletionManagedFlushChecker = STANDARD_MANAGED_FLUSH_CHECKER;
+		managedFlushChecker = STANDARD_MANAGED_FLUSH_CHECKER;
 		exceptionMapper = STANDARD_EXCEPTION_MAPPER;
 		afterCompletionAction = STANDARD_AFTER_COMPLETION_ACTION;
 	}
 
-	public BeforeCompletionManagedFlushChecker getBeforeCompletionManagedFlushChecker() {
-		return beforeCompletionManagedFlushChecker;
-	}
-
-	public void setBeforeCompletionManagedFlushChecker(BeforeCompletionManagedFlushChecker beforeCompletionManagedFlushChecker) {
-		this.beforeCompletionManagedFlushChecker = beforeCompletionManagedFlushChecker;
-	}
-
-	public ExceptionMapper getExceptionMapper() {
-		return exceptionMapper;
+	@Override
+	public void setManagedFlushChecker(ManagedFlushChecker managedFlushChecker) {
+		this.managedFlushChecker = managedFlushChecker;
 	}
 
+	@Override
 	public void setExceptionMapper(ExceptionMapper exceptionMapper) {
 		this.exceptionMapper = exceptionMapper;
 	}
 
-	public AfterCompletionAction getAfterCompletionAction() {
-		return afterCompletionAction;
-	}
-
+	@Override
 	public void setAfterCompletionAction(AfterCompletionAction afterCompletionAction) {
 		this.afterCompletionAction = afterCompletionAction;
 	}
 
 
 	// sync callbacks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void beforeCompletion() {
 		log.trace( "transaction before completion callback" );
 
 		boolean flush;
 		try {
-			flush = beforeCompletionManagedFlushChecker.shouldDoManagedFlush( ctx, jtaTransaction );
+			final int status = transactionCoordinator
+					.getTransactionContext()
+					.getTransactionEnvironment()
+					.getJtaPlatform()
+					.getCurrentStatus();
+			flush = managedFlushChecker.shouldDoManagedFlush( transactionCoordinator, status );
 		}
 		catch ( SystemException se ) {
 			setRollbackOnly();
 			throw exceptionMapper.mapStatusCheckFailure( "could not determine transaction status in beforeCompletion()", se );
 		}
 
 		try {
 			if ( flush ) {
 				log.trace( "automatically flushing session" );
-				ctx.managedFlush();
+				transactionCoordinator.getTransactionContext().managedFlush();
 			}
 		}
 		catch ( RuntimeException re ) {
 			setRollbackOnly();
 			throw exceptionMapper.mapManagedFlushFailure( "error during managed flush", re );
 		}
 		finally {
-			jdbcContext.beforeTransactionCompletion( hibernateTransaction );
+			transactionCoordinator.sendBeforeTransactionCompletionNotifications( null );
+			transactionCoordinator.getTransactionContext().beforeTransactionCompletion( null );
 		}
 	}
 
 	private void setRollbackOnly() {
-		try {
-			jtaTransaction.setRollbackOnly();
-		}
-		catch ( SystemException se ) {
-			// best effort
-			log.error( "could not set transaction to rollback only", se );
-		}
+		transactionCoordinator.setRollbackOnly();
 	}
 
 	public void afterCompletion(int status) {
 		log.trace( "transaction after completion callback [status={}]", status );
 
 		try {
-			afterCompletionAction.doAction( ctx, status );
-
-			final boolean wasSuccessful = ( status == Status.STATUS_COMMITTED );
-			jdbcContext.afterTransactionCompletion( wasSuccessful, hibernateTransaction );
+			afterCompletionAction.doAction( transactionCoordinator, status );
+			transactionCoordinator.afterTransaction( null, status );
 		}
 		finally {
 			reset();
-			jdbcContext.cleanUpJtaSynchronizationCallbackCoordinator();
-			if ( ctx.shouldAutoClose() && !ctx.isClosed() ) {
+			if ( transactionContext().shouldAutoClose() && ! transactionContext().isClosed() ) {
 				log.trace( "automatically closing session" );
-				ctx.managedClose();
+				transactionContext().managedClose();
 			}
 		}
 	}
 
-	private static final BeforeCompletionManagedFlushChecker STANDARD_MANAGED_FLUSH_CHECKER = new BeforeCompletionManagedFlushChecker() {
-		public boolean shouldDoManagedFlush(TransactionFactory.Context ctx, Transaction jtaTransaction)
-				throws SystemException {
-			return !ctx.isClosed() &&
-					!ctx.isFlushModeNever() &&
-					ctx.isFlushBeforeCompletionEnabled() &&
-			        !JTAHelper.isRollback( jtaTransaction.getStatus() );
-					//actually, this last test is probably unnecessary, since
-					//beforeCompletion() doesn't get called during rollback
+	private TransactionContext transactionContext() {
+		return transactionCoordinator.getTransactionContext();
+	}
+
+	private static final ManagedFlushChecker STANDARD_MANAGED_FLUSH_CHECKER = new ManagedFlushChecker() {
+		@Override
+		public boolean shouldDoManagedFlush(TransactionCoordinator coordinator, int jtaStatus) {
+			return coordinator.getTransactionContext().isFlushModeNever() &&
+					coordinator.getTransactionContext().isFlushBeforeCompletionEnabled() &&
+					!JtaStatusHelper.isRollback( jtaStatus );
 		}
 	};
 
 	private static final ExceptionMapper STANDARD_EXCEPTION_MAPPER = new ExceptionMapper() {
 		public RuntimeException mapStatusCheckFailure(String message, SystemException systemException) {
 			log.error( "could not determine transaction status [{}]", systemException.getMessage() );
 			return new TransactionException( "could not determine transaction status in beforeCompletion()", systemException );
 		}
 
 		public RuntimeException mapManagedFlushFailure(String message, RuntimeException failure) {
 			log.error( "Error during managed flush [{}]", failure.getMessage() );
 			return failure;
 		}
 	};
 
 	private static final AfterCompletionAction STANDARD_AFTER_COMPLETION_ACTION = new AfterCompletionAction() {
-		public void doAction(TransactionFactory.Context ctx, int status) {
+		@Override
+		public void doAction(TransactionCoordinator transactionCoordinator, int status) {
 			// nothing to do by default.
 		}
 	};
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/AfterCompletionAction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/AfterCompletionAction.java
new file mode 100644
index 0000000000..c4e0298451
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/AfterCompletionAction.java
@@ -0,0 +1,38 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.synchronization.spi;
+
+
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+
+/**
+ * A pluggable strategy for defining any actions to be performed during
+ * {@link javax.transaction.Synchronization#afterCompletion} processing from the the
+ * {@link javax.transaction.Synchronization} registered by Hibernate with the underlying JTA platform.
+ *
+ * @author Steve Ebersole
+ */
+public interface AfterCompletionAction {
+	public void doAction(TransactionCoordinator transactionCoordinator, int status);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/ExceptionMapper.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ExceptionMapper.java
similarity index 79%
rename from hibernate-core/src/main/java/org/hibernate/transaction/synchronization/ExceptionMapper.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ExceptionMapper.java
index 403c558dca..1a0182a050 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/ExceptionMapper.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ExceptionMapper.java
@@ -1,53 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction.synchronization;
+package org.hibernate.engine.transaction.synchronization.spi;
 
 import javax.transaction.SystemException;
+import java.io.Serializable;
 
 /**
- * TODO : javadoc
+ * A pluggable strategy for defining how the {@link javax.transaction.Synchronization} registered by Hibernate handles
+ * exceptions.
  *
  * @author Steve Ebersole
  */
-public interface ExceptionMapper {
+public interface ExceptionMapper extends Serializable {
 	/**
-	 * Map a JTA {@link SystemException} to the appropriate runtime-based exception.
+	 * Map a JTA {@link javax.transaction.SystemException} to the appropriate runtime-based exception.
 	 *
 	 * @param message The message to use for the returned exception
 	 * @param systemException The causal exception
 	 *
 	 * @return The appropriate exception to throw
 	 */
 	public RuntimeException mapStatusCheckFailure(String message, SystemException systemException);
 
 	/**
 	 * Map an exception encountered during a managed flush to the appropriate runtime-based exception.
 	 *
 	 * @param message The message to use for the returned exception
 	 * @param failure The causal exception
 	 *
 	 * @return The appropriate exception to throw
 	 */
 	public RuntimeException mapManagedFlushFailure(String message, RuntimeException failure);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/BeforeCompletionManagedFlushChecker.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ManagedFlushChecker.java
similarity index 58%
rename from hibernate-core/src/main/java/org/hibernate/transaction/synchronization/BeforeCompletionManagedFlushChecker.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ManagedFlushChecker.java
index 90994fcc41..5734b11d3d 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/synchronization/BeforeCompletionManagedFlushChecker.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/ManagedFlushChecker.java
@@ -1,51 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction.synchronization;
+package org.hibernate.engine.transaction.synchronization.spi;
 
-import javax.transaction.SystemException;
-import javax.transaction.Transaction;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 
-import org.hibernate.transaction.TransactionFactory;
+import java.io.Serializable;
 
 /**
- * Contract for checking whether to perform a managed flush in a
- * {@link javax.transaction.Synchronization#beforeCompletion()} callback
+ * A pluggable strategy for defining how the {@link javax.transaction.Synchronization} registered by Hibernate determines
+ * whether to perform a managed flush.  An exceptions from either this delegate or the subsequent flush are routed
+ * through the sister strategy {@link ExceptionMapper}.
  *
  * @author Steve Ebersole
  */
-public interface BeforeCompletionManagedFlushChecker {
+public interface ManagedFlushChecker  extends Serializable {
 	/**
 	 * Check whether we should perform the managed flush
 	 *
-	 * @param ctx The Hibernate "transaction context"
-	 * @param jtaTransaction The JTA transaction
+	 * @param coordinator The transaction coordinator
+	 * @param jtaStatus The status of the current JTA transaction.
 	 *
 	 * @return True to indicate to perform the managed flush; false otherwise.
-	 *
-	 * @throws SystemException Can be thrown while accessing the JTA transaction; will result in transaction being
-	 * marked for rollback (best effort).
 	 */
-	public boolean shouldDoManagedFlush(TransactionFactory.Context ctx, Transaction jtaTransaction)
-			throws SystemException;
+	public boolean shouldDoManagedFlush(TransactionCoordinator coordinator, int jtaStatus);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/SynchronizationCallbackCoordinator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/SynchronizationCallbackCoordinator.java
new file mode 100644
index 0000000000..d96a62b0f9
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/synchronization/spi/SynchronizationCallbackCoordinator.java
@@ -0,0 +1,35 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.engine.transaction.synchronization.spi;
+
+import javax.transaction.Synchronization;
+
+/**
+ * @author Steve Ebersole
+ */
+public interface SynchronizationCallbackCoordinator extends Synchronization{
+	public void setManagedFlushChecker(ManagedFlushChecker managedFlushChecker);
+	public void setAfterCompletionAction(AfterCompletionAction afterCompletionAction);
+	public void setExceptionMapper(ExceptionMapper exceptionMapper);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java
index d252b091f1..15aa516d8c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java
@@ -1,379 +1,379 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.event.def;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.HibernateException;
 import org.hibernate.action.CollectionRecreateAction;
 import org.hibernate.action.CollectionRemoveAction;
 import org.hibernate.action.CollectionUpdateAction;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.engine.ActionQueue;
 import org.hibernate.engine.Cascade;
 import org.hibernate.engine.CascadingAction;
 import org.hibernate.engine.CollectionEntry;
 import org.hibernate.engine.CollectionKey;
 import org.hibernate.engine.Collections;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.PersistenceContext;
 import org.hibernate.engine.Status;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.FlushEntityEvent;
 import org.hibernate.event.FlushEntityEventListener;
 import org.hibernate.event.FlushEvent;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.Printer;
 import org.hibernate.util.IdentityMap;
 import org.hibernate.util.LazyIterator;
 
 /**
  * A convenience base class for listeners whose functionality results in flushing.
  *
  * @author Steve Eberole
  */
 public abstract class AbstractFlushingEventListener implements Serializable {
 
 	private static final Logger log = LoggerFactory.getLogger(AbstractFlushingEventListener.class);
 	
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Pre-flushing section
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/** 
 	 * Coordinates the processing necessary to get things ready for executions
 	 * as db calls by preping the session caches and moving the appropriate
 	 * entities and collections to their respective execution queues.
 	 *
 	 * @param event The flush event.
 	 * @throws HibernateException Error flushing caches to execution queues.
 	 */
 	protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException {
 
 		log.trace("flushing session");
 		
 		EventSource session = event.getSession();
 		
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		session.getInterceptor().preFlush( new LazyIterator( persistenceContext.getEntitiesByKey() ) );
 
 		prepareEntityFlushes(session);
 		// we could move this inside if we wanted to
 		// tolerate collection initializations during
 		// collection dirty checking:
 		prepareCollectionFlushes(session);
 		// now, any collections that are initialized
 		// inside this block do not get updated - they
 		// are ignored until the next flush
 				
 		persistenceContext.setFlushing(true);
 		try {
 			flushEntities(event);
 			flushCollections(session);
 		}
 		finally {
 			persistenceContext.setFlushing(false);
 		}
 
 		//some statistics
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Flushed: " +
 					session.getActionQueue().numberOfInsertions() + " insertions, " +
 					session.getActionQueue().numberOfUpdates() + " updates, " +
 					session.getActionQueue().numberOfDeletions() + " deletions to " +
 					persistenceContext.getEntityEntries().size() + " objects"
 				);
 			log.debug( "Flushed: " +
 					session.getActionQueue().numberOfCollectionCreations() + " (re)creations, " +
 					session.getActionQueue().numberOfCollectionUpdates() + " updates, " +
 					session.getActionQueue().numberOfCollectionRemovals() + " removals to " +
 					persistenceContext.getCollectionEntries().size() + " collections"
 				);
 			new Printer( session.getFactory() ).toString( 
 					persistenceContext.getEntitiesByKey().values().iterator(), 
 					session.getEntityMode() 
 				);
 		}
 	}
 
 	/**
 	 * process cascade save/update at the start of a flush to discover
 	 * any newly referenced entity that must be passed to saveOrUpdate(),
 	 * and also apply orphan delete
 	 */
 	private void prepareEntityFlushes(EventSource session) throws HibernateException {
 		
 		log.debug("processing flush-time cascades");
 
 		final Map.Entry[] list = IdentityMap.concurrentEntries( session.getPersistenceContext().getEntityEntries() );
 		//safe from concurrent modification because of how entryList() is implemented on IdentityMap
 		final int size = list.length;
 		final Object anything = getAnything();
 		for ( int i=0; i<size; i++ ) {
 			Map.Entry me = list[i];
 			EntityEntry entry = (EntityEntry) me.getValue();
 			Status status = entry.getStatus();
 			if ( status == Status.MANAGED || status == Status.SAVING || status == Status.READ_ONLY ) {
 				cascadeOnFlush( session, entry.getPersister(), me.getKey(), anything );
 			}
 		}
 	}
 	
 	private void cascadeOnFlush(EventSource session, EntityPersister persister, Object object, Object anything) 
 	throws HibernateException {
 		session.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadingAction(), Cascade.BEFORE_FLUSH, session )
 			.cascade( persister, object, anything );
 		}
 		finally {
 			session.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 	
 	protected Object getAnything() { return null; }
 	
 	protected CascadingAction getCascadingAction() {
 		return CascadingAction.SAVE_UPDATE;
 	}
 
 	/**
 	 * Initialize the flags of the CollectionEntry, including the
 	 * dirty check.
 	 */
 	private void prepareCollectionFlushes(SessionImplementor session) throws HibernateException {
 
 		// Initialize dirty flags for arrays + collections with composite elements
 		// and reset reached, doupdate, etc.
 		
 		log.debug("dirty checking collections");
 
 		final List list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		final int size = list.size();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry e = ( Map.Entry ) list.get( i );
 			( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );
 		}
 	}
 
 	/**
 	 * 1. detect any dirty entities
 	 * 2. schedule any entity updates
 	 * 3. search out any reachable collections
 	 */
 	private void flushEntities(FlushEvent event) throws HibernateException {
 
 		log.trace("Flushing entities and processing referenced collections");
 
 		// Among other things, updateReachables() will recursively load all
 		// collections that are moving roles. This might cause entities to
 		// be loaded.
 
 		// So this needs to be safe from concurrent modification problems.
 		// It is safe because of how IdentityMap implements entrySet()
 
 		final EventSource source = event.getSession();
 		
 		final Map.Entry[] list = IdentityMap.concurrentEntries( source.getPersistenceContext().getEntityEntries() );
 		final int size = list.length;
 		for ( int i = 0; i < size; i++ ) {
 
 			// Update the status of the object and if necessary, schedule an update
 
 			Map.Entry me = list[i];
 			EntityEntry entry = (EntityEntry) me.getValue();
 			Status status = entry.getStatus();
 
 			if ( status != Status.LOADING && status != Status.GONE ) {
 				FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
 				FlushEntityEventListener[] listeners = source.getListeners().getFlushEntityEventListeners();
 				for ( int j = 0; j < listeners.length; j++ ) {
 					listeners[j].onFlushEntity(entityEvent);
 				}
 			}
 		}
 
 		source.getActionQueue().sortActions();
 	}
 
 	/**
 	 * process any unreferenced collections and then inspect all known collections,
 	 * scheduling creates/removes/updates
 	 */
 	private void flushCollections(EventSource session) throws HibernateException {
 
 		log.trace("Processing unreferenced collections");
 
 		List list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		int size = list.size();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry me = ( Map.Entry ) list.get( i );
 			CollectionEntry ce = (CollectionEntry) me.getValue();
 			if ( !ce.isReached() && !ce.isIgnore() ) {
 				Collections.processUnreachableCollection( (PersistentCollection) me.getKey(), session );
 			}
 		}
 
 		// Schedule updates to collections:
 
 		log.trace( "Scheduling collection removes/(re)creates/updates" );
 
 		list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		size = list.size();
 		ActionQueue actionQueue = session.getActionQueue();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry me = (Map.Entry) list.get(i);
 			PersistentCollection coll = (PersistentCollection) me.getKey();
 			CollectionEntry ce = (CollectionEntry) me.getValue();
 
 			if ( ce.isDorecreate() ) {
 				session.getInterceptor().onCollectionRecreate( coll, ce.getCurrentKey() );
 				actionQueue.addAction(
 						new CollectionRecreateAction( 
 								coll, 
 								ce.getCurrentPersister(), 
 								ce.getCurrentKey(), 
 								session 
 							)
 					);
 			}
 			if ( ce.isDoremove() ) {
 				session.getInterceptor().onCollectionRemove( coll, ce.getLoadedKey() );
 				actionQueue.addAction(
 						new CollectionRemoveAction( 
 								coll, 
 								ce.getLoadedPersister(), 
 								ce.getLoadedKey(), 
 								ce.isSnapshotEmpty(coll), 
 								session 
 							)
 					);
 			}
 			if ( ce.isDoupdate() ) {
 				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
 				actionQueue.addAction(
 						new CollectionUpdateAction( 
 								coll, 
 								ce.getLoadedPersister(), 
 								ce.getLoadedKey(), 
 								ce.isSnapshotEmpty(coll), 
 								session 
 							)
 					);
 			}
 
 		}
 
 		actionQueue.sortCollectionActions();
 		
 	}
 
 	/**
 	 * Execute all SQL and second-level cache updates, in a
 	 * special order so that foreign-key constraints cannot
 	 * be violated:
 	 * <ol>
 	 * <li> Inserts, in the order they were performed
 	 * <li> Updates
 	 * <li> Deletion of collection elements
 	 * <li> Insertion of collection elements
 	 * <li> Deletes, in the order they were performed
 	 * </ol>
 	 */
 	protected void performExecutions(EventSource session) throws HibernateException {
 
 		log.trace("executing flush");
 
 		try {
-			session.getJDBCContext().getConnectionManager().flushBeginning();
+			session.getTransactionCoordinator().getJdbcCoordinator().flushBeginning();
 			// we need to lock the collection caches before
 			// executing entity inserts/updates in order to
 			// account for bidi associations
 			session.getActionQueue().prepareActions();
 			session.getActionQueue().executeActions();
 		}
 		catch (HibernateException he) {
 			log.error("Could not synchronize database state with session", he);
 			throw he;
 		}
 		finally {
-			session.getJDBCContext().getConnectionManager().flushEnding();
+			session.getTransactionCoordinator().getJdbcCoordinator().flushEnding();
 		}
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Post-flushing section
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * 1. Recreate the collection key -> collection map
 	 * 2. rebuild the collection entries
 	 * 3. call Interceptor.postFlush()
 	 */
 	protected void postFlush(SessionImplementor session) throws HibernateException {
 
 		log.trace( "post flush" );
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		persistenceContext.getCollectionsByKey().clear();
 		persistenceContext.getBatchFetchQueue()
 				.clearSubselects(); //the database has changed now, so the subselect results need to be invalidated
 
 		Iterator iter = persistenceContext.getCollectionEntries().entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = (Map.Entry) iter.next();
 			CollectionEntry collectionEntry = (CollectionEntry) me.getValue();
 			PersistentCollection persistentCollection = (PersistentCollection) me.getKey();
 			collectionEntry.postFlush(persistentCollection);
 			if ( collectionEntry.getLoadedPersister() == null ) {
 				//if the collection is dereferenced, remove from the session cache
 				//iter.remove(); //does not work, since the entrySet is not backed by the set
 				persistenceContext.getCollectionEntries()
 						.remove(persistentCollection);
 			}
 			else {
 				//otherwise recreate the mapping between the collection and its key
 				CollectionKey collectionKey = new CollectionKey( 
 						collectionEntry.getLoadedPersister(), 
 						collectionEntry.getLoadedKey(), 
 						session.getEntityMode() 
 					);
 				persistenceContext.getCollectionsByKey()
 						.put(collectionKey, persistentCollection);
 			}
 		}
 		
 		session.getInterceptor().postFlush( new LazyIterator( persistenceContext.getEntitiesByKey() ) );
 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
index 9bf1ad0950..7cc8bfa059 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
@@ -1,561 +1,561 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.def;
 
 import java.io.Serializable;
 import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.LockMode;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.action.EntityIdentityInsertAction;
 import org.hibernate.action.EntityInsertAction;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.classic.Validatable;
 import org.hibernate.engine.Cascade;
 import org.hibernate.engine.CascadingAction;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.ForeignKeys;
 import org.hibernate.engine.Nullability;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.Status;
 import org.hibernate.engine.Versioning;
 import org.hibernate.event.EventSource;
 import org.hibernate.id.IdentifierGenerationException;
 import org.hibernate.id.IdentifierGeneratorHelper;
 import org.hibernate.intercept.FieldInterceptionHelper;
 import org.hibernate.intercept.FieldInterceptor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * A convenience bas class for listeners responding to save events.
  *
  * @author Steve Ebersole.
  */
 public abstract class AbstractSaveEventListener extends AbstractReassociateEventListener {
 
 	protected static final int PERSISTENT = 0;
 	protected static final int TRANSIENT = 1;
 	protected static final int DETACHED = 2;
 	protected static final int DELETED = 3;
 
 	private static final Logger log = LoggerFactory.getLogger( AbstractSaveEventListener.class );
 
 	/**
 	 * Prepares the save call using the given requested id.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param requestedId The id to which to associate the entity.
 	 * @param entityName The name of the entity being saved.
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 *
 	 * @return The id used to save the entity.
 	 */
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		return performSave(
 				entity,
 				requestedId,
 				source.getEntityPersister( entityName, entity ),
 				false,
 				anything,
 				source,
 				true
 		);
 	}
 
 	/**
 	 * Prepares the save call using a newly generated id.
 	 *
 	 * @param entity The entity to be saved
 	 * @param entityName The entity-name for the entity to be saved
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		EntityPersister persister = source.getEntityPersister( entityName, entity );
 		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
 		if ( generatedId == null ) {
 			throw new IdentifierGenerationException( "null id generated for:" + entity.getClass() );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.SHORT_CIRCUIT_INDICATOR ) {
 			return source.getIdentifier( entity );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.POST_INSERT_INDICATOR ) {
 			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
 		}
 		else {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug(
 						"generated identifier: " +
 								persister.getIdentifierType().toLoggableString( generatedId, source.getFactory() ) +
 								", using strategy: " +
 								persister.getIdentifierGenerator().getClass().getName()
 						//TODO: define toString()s for generators
 				);
 			}
 
 			return performSave( entity, generatedId, persister, false, anything, source, true );
 		}
 	}
 
 	/**
 	 * Ppepares the save call by checking the session caches for a pre-existing
 	 * entity and performing any lifecycle callbacks.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param id The id by which to save the entity.
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Is an identity column being used?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session from which the event originated.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSave(
 			Object entity,
 			Serializable id,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace(
 					"saving " +
 							MessageHelper.infoString( persister, id, source.getFactory() )
 			);
 		}
 
 		EntityKey key;
 		if ( !useIdentityColumn ) {
 			key = new EntityKey( id, persister, source.getEntityMode() );
 			Object old = source.getPersistenceContext().getEntity( key );
 			if ( old != null ) {
 				if ( source.getPersistenceContext().getEntry( old ).getStatus() == Status.DELETED ) {
 					source.forceFlush( source.getPersistenceContext().getEntry( old ) );
 				}
 				else {
 					throw new NonUniqueObjectException( id, persister.getEntityName() );
 				}
 			}
 			persister.setIdentifier( entity, id, source );
 		}
 		else {
 			key = null;
 		}
 
 		if ( invokeSaveLifecycle( entity, persister, source ) ) {
 			return id; //EARLY EXIT
 		}
 
 		return performSaveOrReplicate(
 				entity,
 				key,
 				persister,
 				useIdentityColumn,
 				anything,
 				source,
 				requiresImmediateIdAccess
 		);
 	}
 
 	protected boolean invokeSaveLifecycle(Object entity, EntityPersister persister, EventSource source) {
 		// Sub-insertions should occur before containing insertion so
 		// Try to do the callback now
 		if ( persister.implementsLifecycle( source.getEntityMode() ) ) {
 			log.debug( "calling onSave()" );
 			if ( ( ( Lifecycle ) entity ).onSave( source ) ) {
 				log.debug( "insertion vetoed by onSave()" );
 				return true;
 			}
 		}
 		return false;
 	}
 
 	protected void validate(Object entity, EntityPersister persister, EventSource source) {
 		if ( persister.implementsValidatable( source.getEntityMode() ) ) {
 			( ( Validatable ) entity ).validate();
 		}
 	}
 
 	/**
 	 * Performs all the actual work needed to save an entity (well to get the save moved to
 	 * the execution queue).
 	 *
 	 * @param entity The entity to be saved
 	 * @param key The id to be used for saving the entity (or null, in the case of identity columns)
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Should an identity column be used for id generation?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of the current event.
 	 * @param requiresImmediateIdAccess Is access to the identifier required immediately
 	 * after the completion of the save?  persist(), for example, does not require this...
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSaveOrReplicate(
 			Object entity,
 			EntityKey key,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
 		validate( entity, persister, source );
 
 		Serializable id = key == null ? null : key.getIdentifier();
 
-		boolean inTxn = source.getJDBCContext().isTransactionInProgress();
+		boolean inTxn = source.getTransactionCoordinator().isTransactionInProgress();
 		boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;
 
 		// Put a placeholder in entries, so we don't recurse back and try to save() the
 		// same object again. QUESTION: should this be done before onSave() is called?
 		// likewise, should it be done before onUpdate()?
 		source.getPersistenceContext().addEntry(
 				entity,
 				Status.SAVING,
 				null,
 				null,
 				id,
 				null,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				false,
 				false
 		);
 
 		cascadeBeforeSave( source, persister, entity, anything );
 
 		if ( useIdentityColumn && !shouldDelayIdentityInserts ) {
 			log.trace( "executing insertions" );
 			source.getActionQueue().executeInserts();
 		}		
 
 		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
 		Type[] types = persister.getPropertyTypes();
 
 		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
 
 		if ( persister.hasCollections() ) {
 			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
 		}
 
 		if ( substitute ) {
 			persister.setPropertyValues( entity, values, source.getEntityMode() );
 		}
 
 		TypeHelper.deepCopy(
 				values,
 				types,
 				persister.getPropertyUpdateability(),
 				values,
 				source
 		);
 
 		new ForeignKeys.Nullifier( entity, false, useIdentityColumn, source )
 				.nullifyTransientReferences( values, types );
 		new Nullability( source ).checkNullability( values, persister, false );
 
 		if ( useIdentityColumn ) {
 			EntityIdentityInsertAction insert = new EntityIdentityInsertAction(
 					values, entity, persister, source, shouldDelayIdentityInserts
 			);
 			if ( !shouldDelayIdentityInserts ) {
 				log.debug( "executing identity-insert immediately" );
 				source.getActionQueue().execute( insert );
 				id = insert.getGeneratedId();
 				key = new EntityKey( id, persister, source.getEntityMode() );
 				source.getPersistenceContext().checkUniqueness( key, entity );
 			}
 			else {
 				log.debug( "delaying identity-insert due to no transaction in progress" );
 				source.getActionQueue().addAction( insert );
 				key = insert.getDelayedEntityKey();
 			}
 		}
 
 		Object version = Versioning.getVersion( values, persister );
 		source.getPersistenceContext().addEntity(
 				entity,
 				( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 				values,
 				key,
 				version,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				isVersionIncrementDisabled(),
 				false
 		);
 		//source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );
 
 		if ( !useIdentityColumn ) {
 			source.getActionQueue().addAction(
 					new EntityInsertAction( id, values, entity, version, persister, source )
 			);
 		}
 
 		cascadeAfterSave( source, persister, entity, anything );
 
 		markInterceptorDirty( entity, persister, source );
 
 		return id;
 	}
 
 	private void markInterceptorDirty(Object entity, EntityPersister persister, EventSource source) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.injectFieldInterceptor(
 					entity,
 					persister.getEntityName(),
 					null,
 					source
 			);
 			interceptor.dirty();
 		}
 	}
 
 	protected Map getMergeMap(Object anything) {
 		return null;
 	}
 
 	/**
 	 * After the save, will te version number be incremented
 	 * if the instance is modified?
 	 *
 	 * @return True if the version will be incremented on an entity change after save;
 	 *         false otherwise.
 	 */
 	protected boolean isVersionIncrementDisabled() {
 		return false;
 	}
 
 	protected boolean visitCollectionsBeforeSave(Object entity, Serializable id, Object[] values, Type[] types, EventSource source) {
 		WrapVisitor visitor = new WrapVisitor( source );
 		// substitutes into values by side-effect
 		visitor.processEntityPropertyValues( values, types );
 		return visitor.isSubstitutionRequired();
 	}
 
 	/**
 	 * Perform any property value substitution that is necessary
 	 * (interceptor callback, version initialization...)
 	 *
 	 * @param entity The entity
 	 * @param id The entity identifier
 	 * @param values The snapshot entity state
 	 * @param persister The entity persister
 	 * @param source The originating session
 	 *
 	 * @return True if the snapshot state changed such that
 	 * reinjection of the values into the entity is required.
 	 */
 	protected boolean substituteValuesIfNecessary(
 			Object entity,
 			Serializable id,
 			Object[] values,
 			EntityPersister persister,
 			SessionImplementor source) {
 		boolean substitute = source.getInterceptor().onSave(
 				entity,
 				id,
 				values,
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 		);
 
 		//keep the existing version number in the case of replicate!
 		if ( persister.isVersioned() ) {
 			substitute = Versioning.seedVersion(
 					values,
 					persister.getVersionProperty(),
 					persister.getVersionType(),
 					source
 			) || substitute;
 		}
 		return substitute;
 	}
 
 	/**
 	 * Handles the calls needed to perform pre-save cascades for the given entity.
 	 *
 	 * @param source The session from whcih the save event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity to be saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeBeforeSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to many-to-one BEFORE the parent is saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.BEFORE_INSERT_AFTER_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	/**
 	 * Handles to calls needed to perform post-save cascades.
 	 *
 	 * @param source The session from which the event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity beng saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeAfterSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to collections AFTER the collection owner was saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.AFTER_INSERT_BEFORE_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	protected abstract CascadingAction getCascadeAction();
 
 	/**
 	 * Determine whether the entity is persistent, detached, or transient
 	 *
 	 * @param entity The entity to check
 	 * @param entityName The name of the entity
 	 * @param entry The entity's entry in the persistence context
 	 * @param source The originating session.
 	 *
 	 * @return The state.
 	 */
 	protected int getEntityState(
 			Object entity,
 			String entityName,
 			EntityEntry entry, //pass this as an argument only to avoid double looking
 			SessionImplementor source) {
 
 		if ( entry != null ) { // the object is persistent
 
 			//the entity is associated with the session, so check its status
 			if ( entry.getStatus() != Status.DELETED ) {
 				// do nothing for persistent instances
 				if ( log.isTraceEnabled() ) {
 					log.trace(
 							"persistent instance of: " +
 									getLoggableName( entityName, entity )
 					);
 				}
 				return PERSISTENT;
 			}
 			else {
 				//ie. e.status==DELETED
 				if ( log.isTraceEnabled() ) {
 					log.trace(
 							"deleted instance of: " +
 									getLoggableName( entityName, entity )
 					);
 				}
 				return DELETED;
 			}
 
 		}
 		else { // the object is transient or detached
 
 			//the entity is not associated with the session, so
 			//try interceptor and unsaved-value
 
 			if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source ) ) {
 				if ( log.isTraceEnabled() ) {
 					log.trace(
 							"transient instance of: " +
 									getLoggableName( entityName, entity )
 					);
 				}
 				return TRANSIENT;
 			}
 			else {
 				if ( log.isTraceEnabled() ) {
 					log.trace(
 							"detached instance of: " +
 									getLoggableName( entityName, entity )
 					);
 				}
 				return DETACHED;
 			}
 
 		}
 	}
 
 	protected String getLoggableName(String entityName, Object entity) {
 		return entityName == null ? entity.getClass().getName() : entityName;
 	}
 
 	protected Boolean getAssumedUnsaved() {
 		return null;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/exception/SQLExceptionConverter.java b/hibernate-core/src/main/java/org/hibernate/exception/SQLExceptionConverter.java
index 1a0e1df965..630db0ab6b 100644
--- a/hibernate-core/src/main/java/org/hibernate/exception/SQLExceptionConverter.java
+++ b/hibernate-core/src/main/java/org/hibernate/exception/SQLExceptionConverter.java
@@ -1,55 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.exception;
 
 import org.hibernate.JDBCException;
 
+import java.io.Serializable;
 import java.sql.SQLException;
 
 /**
  * Defines a contract for implementations that know how to convert a SQLException
  * into Hibernate's JDBCException hierarchy.  Inspired by Spring's
  * SQLExceptionTranslator.
  * <p/>
  * Implementations <b>must</b> have a constructor which takes a
  * {@link ViolatedConstraintNameExtracter} parameter.
  * <p/>
  * Implementations may implement {@link Configurable} if they need to perform
  * configuration steps prior to first use.
  *
  * @author Steve Ebersole
  * @see SQLExceptionConverterFactory
  */
-public interface SQLExceptionConverter {
+public interface SQLExceptionConverter extends Serializable {
 	/**
-	 * Convert the given SQLException into Hibernate's JDBCException hierarchy.
+	 * Convert the given SQLException into the Hibernate {@link JDBCException} hierarchy.
 	 *
 	 * @param sqlException The SQLException to be converted.
 	 * @param message      An optional error message.
 	 * @return The resulting JDBCException.
 	 * @see ConstraintViolationException, JDBCConnectionException, SQLGrammarException, LockAcquisitionException
 	 */
 	public JDBCException convert(SQLException sqlException, String message, String sql);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
index 50f486cd0d..efb94d6869 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
@@ -1,283 +1,308 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.ast.exec;
 
-import java.sql.PreparedStatement;
-import java.sql.Connection;
-import java.sql.SQLWarning;
-import java.sql.Statement;
-import java.util.List;
-import java.util.Collections;
+import antlr.RecognitionException;
+import antlr.collections.AST;
 
 import org.hibernate.HibernateException;
 import org.hibernate.action.BulkOperationCleanupAction;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
-import org.hibernate.engine.transaction.Isolater;
-import org.hibernate.engine.transaction.IsolatedWork;
 import org.hibernate.event.EventSource;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.hql.ast.SqlGenerator;
+import org.hibernate.jdbc.Work;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InsertSelect;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.util.JDBCExceptionReporter;
 import org.hibernate.util.StringHelper;
-
-import antlr.RecognitionException;
-import antlr.collections.AST;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLWarning;
+import java.sql.Statement;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Implementation of AbstractStatementExecutor.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractStatementExecutor implements StatementExecutor {
 	private static final Logger LOG = LoggerFactory.getLogger( AbstractStatementExecutor.class );
 
 	private final Logger log;
 	private final HqlSqlWalker walker;
 	private List idSelectParameterSpecifications = Collections.EMPTY_LIST;
 
 	public AbstractStatementExecutor(HqlSqlWalker walker, Logger log) {
 		this.walker = walker;
 		this.log = log;
 	}
 
 	protected HqlSqlWalker getWalker() {
 		return walker;
 	}
 
 	protected SessionFactoryImplementor getFactory() {
 		return walker.getSessionFactoryHelper().getFactory();
 	}
 
 	protected List getIdSelectParameterSpecifications() {
 		return idSelectParameterSpecifications;
 	}
 
 	protected abstract Queryable[] getAffectedQueryables();
 
 	protected String generateIdInsertSelect(Queryable persister, String tableAlias, AST whereClause) {
 		Select select = new Select( getFactory().getDialect() );
 		SelectFragment selectFragment = new SelectFragment()
 				.addColumns( tableAlias, persister.getIdentifierColumnNames(), persister.getIdentifierColumnNames() );
 		select.setSelectClause( selectFragment.toFragmentString().substring( 2 ) );
 
 		String rootTableName = persister.getTableName();
 		String fromJoinFragment = persister.fromJoinFragment( tableAlias, true, false );
 		String whereJoinFragment = persister.whereJoinFragment( tableAlias, true, false );
 
 		select.setFromClause( rootTableName + ' ' + tableAlias + fromJoinFragment );
 
 		if ( whereJoinFragment == null ) {
 			whereJoinFragment = "";
 		}
 		else {
 			whereJoinFragment = whereJoinFragment.trim();
 			if ( whereJoinFragment.startsWith( "and" ) ) {
 				whereJoinFragment = whereJoinFragment.substring( 4 );
 			}
 		}
 
 		String userWhereClause = "";
 		if ( whereClause.getNumberOfChildren() != 0 ) {
 			// If a where clause was specified in the update/delete query, use it to limit the
 			// returned ids here...
 			try {
 				SqlGenerator sqlGenerator = new SqlGenerator( getFactory() );
 				sqlGenerator.whereClause( whereClause );
 				userWhereClause = sqlGenerator.getSQL().substring( 7 );  // strip the " where "
 				idSelectParameterSpecifications = sqlGenerator.getCollectedParameters();
 			}
 			catch ( RecognitionException e ) {
 				throw new HibernateException( "Unable to generate id select for DML operation", e );
 			}
 			if ( whereJoinFragment.length() > 0 ) {
 				whereJoinFragment += " and ";
 			}
 		}
 
 		select.setWhereClause( whereJoinFragment + userWhereClause );
 
 		InsertSelect insert = new InsertSelect( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert-select for " + persister.getEntityName() + " ids" );
 		}
 		insert.setTableName( persister.getTemporaryIdTableName() );
 		insert.setSelect( select );
 		return insert.toStatementString();
 	}
 
 	protected String generateIdSubselect(Queryable persister) {
 		return "select " + StringHelper.join( ", ", persister.getIdentifierColumnNames() ) +
 			        " from " + persister.getTemporaryIdTableName();
 	}
 
-	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
-		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
-		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
-		IsolatedWork work = new IsolatedWork() {
-			public void doWork(Connection connection) throws HibernateException {
+	private static class TemporaryTableCreationWork implements Work {
+		private final Queryable persister;
+
+		private TemporaryTableCreationWork(Queryable persister) {
+			this.persister = persister;
+		}
+
+		@Override
+		public void execute(Connection connection) {
+			try {
+				Statement statement = connection.createStatement();
 				try {
-					Statement statement = connection.createStatement();
+					statement.executeUpdate( persister.getTemporaryIdTableDDL() );
+					JDBCExceptionReporter.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
+				}
+				finally {
 					try {
-						statement.executeUpdate( persister.getTemporaryIdTableDDL() );
-						JDBCExceptionReporter.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
+						statement.close();
 					}
-					finally {
-						try {
-							statement.close();
-						}
-						catch( Throwable ignore ) {
-							// ignore
-						}
+					catch( Throwable ignore ) {
+						// ignore
 					}
 				}
-				catch( Exception e ) {
-					log.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
-				}
-			}
-		};
-		if ( shouldIsolateTemporaryTableDDL() ) {
-			if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
-				Isolater.doIsolatedWork( work, session );
 			}
-			else {
-				Isolater.doNonTransactedWork( work, session );
+			catch( Exception e ) {
+				LOG.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
 			}
 		}
+	}
+	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
+		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
+		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
+		TemporaryTableCreationWork work = new TemporaryTableCreationWork( persister );
+		if ( shouldIsolateTemporaryTableDDL() ) {
+			session.getTransactionCoordinator()
+					.getTransaction()
+					.createIsolationDelegate()
+					.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
+		}
 		else {
-			work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
-			session.getJDBCContext().getConnectionManager().afterStatement();
+			final Connection connection = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getLogicalConnection()
+					.getShareableConnectionProxy();
+			work.execute( connection );
+			session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getLogicalConnection()
+					.afterStatementExecution();
 		}
 	}
 
 	private static JDBCExceptionReporter.WarningHandler CREATION_WARNING_HANDLER = new JDBCExceptionReporter.WarningHandlerLoggingSupport() {
 		public boolean doProcess() {
 			return LOG.isDebugEnabled();
 		}
 
 		public void prepare(SQLWarning warning) {
 			LOG.debug( "Warnings creating temp table", warning );
 		}
 
 		@Override
 		protected void logWarning(String description, String message) {
 			LOG.debug( description );
 			LOG.debug( message );
 		}
 	};
 
-	protected void dropTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
-		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
-			IsolatedWork work = new IsolatedWork() {
-				public void doWork(Connection connection) throws HibernateException {
-					final String command = session.getFactory().getDialect().getDropTemporaryTableString()
-							+ ' ' + persister.getTemporaryIdTableName();
+	private static class TemporaryTableDropWork implements Work {
+		private final Queryable persister;
+		private final SessionImplementor session;
+
+		private TemporaryTableDropWork(Queryable persister, SessionImplementor session) {
+			this.persister = persister;
+			this.session = session;
+		}
+
+		@Override
+		public void execute(Connection connection) {
+			final String command = session.getFactory().getDialect().getDropTemporaryTableString()
+					+ ' ' + persister.getTemporaryIdTableName();
+			try {
+				Statement statement = connection.createStatement();
+				try {
+					statement = connection.createStatement();
+					statement.executeUpdate( command );
+				}
+				finally {
 					try {
-						Statement statement = connection.createStatement();
-						try {
-							statement = connection.createStatement();
-							statement.executeUpdate( command );
-						}
-						finally {
-							try {
-								statement.close();
-							}
-							catch( Throwable ignore ) {
-								// ignore
-							}
-						}
+						statement.close();
 					}
-					catch( Exception e ) {
-						log.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
+					catch( Throwable ignore ) {
+						// ignore
 					}
 				}
-			};
+			}
+			catch( Exception e ) {
+				LOG.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
+			}
+		}
+	}
 
+	protected void dropTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
+		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
+			TemporaryTableDropWork work = new TemporaryTableDropWork( persister, session );
 			if ( shouldIsolateTemporaryTableDDL() ) {
-				if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
-					Isolater.doIsolatedWork( work, session );
-				}
-				else {
-					Isolater.doNonTransactedWork( work, session );
-				}
+				session.getTransactionCoordinator()
+						.getTransaction()
+						.createIsolationDelegate()
+						.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
 			}
 			else {
-				work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
-				session.getJDBCContext().getConnectionManager().afterStatement();
+				final Connection connection = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getLogicalConnection()
+						.getShareableConnectionProxy();
+				work.execute( connection );
+				session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getLogicalConnection()
+						.afterStatementExecution();
 			}
 		}
 		else {
 			// at the very least cleanup the data :)
 			PreparedStatement ps = null;
 			try {
-				ps = session.getJDBCContext().getConnectionManager().prepareStatement( "delete from " + persister.getTemporaryIdTableName(),
-						false
-				);
+				final String sql = "delete from " + persister.getTemporaryIdTableName();
+				ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				ps.executeUpdate();
 			}
 			catch( Throwable t ) {
 				log.warn( "unable to cleanup temporary id table after use [" + t + "]" );
 			}
 			finally {
 				if ( ps != null ) {
 					try {
 						ps.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 		}
 	}
 
 	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
 		BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getAffectedQueryables() );
 
 		if ( session.isEventSource() ) {
 			( ( EventSource ) session ).getActionQueue().addAction( action );
 		}
 		else {
 			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
 		}
 	}
 
 	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	protected boolean shouldIsolateTemporaryTableDDL() {
 		Boolean dialectVote = getFactory().getDialect().performTemporaryTableDDLInIsolation();
 		if ( dialectVote != null ) {
 			return dialectVote.booleanValue();
 		}
 		else {
 			return getFactory().getSettings().isDataDefinitionImplicitCommit();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java
index 53c0aeee67..6aebc128dd 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java
@@ -1,120 +1,120 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.ast.exec;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.RowSelection;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.hql.ast.QuerySyntaxException;
 import org.hibernate.hql.ast.SqlGenerator;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 
 import antlr.RecognitionException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Implementation of BasicExecutor.
  *
  * @author Steve Ebersole
  */
 public class BasicExecutor extends AbstractStatementExecutor {
 	private static final Logger log = LoggerFactory.getLogger( BasicExecutor.class );
 
 	private final Queryable persister;
 	private final String sql;
 	private final List parameterSpecifications;
 
 	public BasicExecutor(HqlSqlWalker walker, Queryable persister) {
 		super( walker, log );
 		this.persister = persister;
 		try {
 			SqlGenerator gen = new SqlGenerator( getFactory() );
 			gen.statement( walker.getAST() );
 			sql = gen.getSQL();
 			gen.getParseErrorHandler().throwQueryException();
 			parameterSpecifications = gen.getCollectedParameters();
 		}
 		catch ( RecognitionException e ) {
 			throw QuerySyntaxException.convert( e );
 		}
 	}
 
 	public String[] getSqlStatements() {
 		return new String[] { sql };
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 
 		coordinateSharedCacheCleanup( session );
 
 		PreparedStatement st = null;
 		RowSelection selection = parameters.getRowSelection();
 
 		try {
 			try {
-				st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, false );
+				st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				Iterator parameterSpecifications = this.parameterSpecifications.iterator();
 				int pos = 1;
 				while ( parameterSpecifications.hasNext() ) {
 					final ParameterSpecification paramSpec = ( ParameterSpecification ) parameterSpecifications.next();
 					pos += paramSpec.bind( st, parameters, session, pos );
 				}
 				if ( selection != null ) {
 					if ( selection.getTimeout() != null ) {
 						st.setQueryTimeout( selection.getTimeout().intValue() );
 					}
 				}
 
 				return st.executeUpdate();
 			}
 			finally {
 				if ( st != null ) {
 					st.close();
 				}
 			}
 		}
 		catch( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute update query",
 			        sql
 				);
 		}
 	}
 
 	protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
index 4290cb2ef4..4c40bc3aa5 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.ast.exec;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.hql.ast.tree.DeleteStatement;
 import org.hibernate.hql.ast.tree.FromElement;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.Delete;
 import org.hibernate.util.StringHelper;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Implementation of MultiTableDeleteExecutor.
  *
  * @author Steve Ebersole
  */
 public class MultiTableDeleteExecutor extends AbstractStatementExecutor {
 	private static final Logger log = LoggerFactory.getLogger( MultiTableDeleteExecutor.class );
 
 	private final Queryable persister;
 	private final String idInsertSelect;
 	private final String[] deletes;
 
 	public MultiTableDeleteExecutor(HqlSqlWalker walker) {
 		super( walker, log );
 
 		if ( !walker.getSessionFactoryHelper().getFactory().getDialect().supportsTemporaryTables() ) {
 			throw new HibernateException( "cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables" );
 		}
 
 		DeleteStatement deleteStatement = ( DeleteStatement ) walker.getAST();
 		FromElement fromElement = deleteStatement.getFromClause().getFromElement();
 		String bulkTargetAlias = fromElement.getTableAlias();
 		this.persister = fromElement.getQueryable();
 
 		this.idInsertSelect = generateIdInsertSelect( persister, bulkTargetAlias, deleteStatement.getWhereClause() );
 		log.trace( "Generated ID-INSERT-SELECT SQL (multi-table delete) : " +  idInsertSelect );
 
 		String[] tableNames = persister.getConstraintOrderedTableNameClosure();
 		String[][] columnNames = persister.getContraintOrderedTableKeyColumnClosure();
 		String idSubselect = generateIdSubselect( persister );
 
 		deletes = new String[tableNames.length];
 		for ( int i = tableNames.length - 1; i >= 0; i-- ) {
 			// TODO : an optimization here would be to consider cascade deletes and not gen those delete statements;
 			//      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters ->
 			//          the table info gotten here should really be self-contained (i.e., a class representation
 			//          defining all the needed attributes), then we could then get an array of those
 			final Delete delete = new Delete()
 					.setTableName( tableNames[i] )
 					.setWhere( "(" + StringHelper.join( ", ", columnNames[i] ) + ") IN (" + idSubselect + ")" );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				delete.setComment( "bulk delete" );
 			}
 
 			deletes[i] = delete.toStatementString();
 		}
 	}
 
 	public String[] getSqlStatements() {
 		return deletes;
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 		coordinateSharedCacheCleanup( session );
 
 		createTemporaryTableIfNecessary( persister, session );
 
 		try {
 			// First, save off the pertinent ids, saving the number of pertinent ids for return
 			PreparedStatement ps = null;
 			int resultCount = 0;
 			try {
 				try {
-					ps = session.getJDBCContext().getConnectionManager().prepareStatement( idInsertSelect, false );
+					ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( idInsertSelect, false );
 					Iterator paramSpecifications = getIdSelectParameterSpecifications().iterator();
 					int pos = 1;
 					while ( paramSpecifications.hasNext() ) {
 						final ParameterSpecification paramSpec = ( ParameterSpecification ) paramSpecifications.next();
 						pos += paramSpec.bind( ps, parameters, session, pos );
 					}
 					resultCount = ps.executeUpdate();
 				}
 				finally {
 					if ( ps != null ) {
 						ps.close();
 					}
 				}
 			}
 			catch( SQLException e ) {
 				throw getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "could not insert/select ids for bulk delete",
 				        idInsertSelect
 					);
 			}
 
 			// Start performing the deletes
 			for ( int i = 0; i < deletes.length; i++ ) {
 				try {
 					try {
-						ps = session.getJDBCContext().getConnectionManager().prepareStatement( deletes[i], false );
+						ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( deletes[i], false );
 						ps.executeUpdate();
 					}
 					finally {
 						if ( ps != null ) {
 							ps.close();
 						}
 					}
 				}
 				catch( SQLException e ) {
 					throw getFactory().getSQLExceptionHelper().convert(
 					        e,
 					        "error performing bulk delete",
 					        deletes[i]
 						);
 				}
 			}
 
 			return resultCount;
 		}
 		finally {
 			dropTemporaryTableIfNecessary( persister, session );
 		}
 	}
 
 	protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java
index 17f4cfc2a0..d183f29498 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java
@@ -1,198 +1,198 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.ast.exec;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.hql.ast.tree.AssignmentSpecification;
 import org.hibernate.hql.ast.tree.FromElement;
 import org.hibernate.hql.ast.tree.UpdateStatement;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.Update;
 import org.hibernate.util.StringHelper;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Implementation of MultiTableUpdateExecutor.
  *
  * @author Steve Ebersole
  */
 public class MultiTableUpdateExecutor extends AbstractStatementExecutor {
 	private static final Logger log = LoggerFactory.getLogger( MultiTableUpdateExecutor.class );
 
 	private final Queryable persister;
 	private final String idInsertSelect;
 	private final String[] updates;
 	private final ParameterSpecification[][] hqlParameters;
 
 	public MultiTableUpdateExecutor(HqlSqlWalker walker) {
 		super( walker, log );
 
 		if ( !walker.getSessionFactoryHelper().getFactory().getDialect().supportsTemporaryTables() ) {
 			throw new HibernateException( "cannot doAfterTransactionCompletion multi-table updates using dialect not supporting temp tables" );
 		}
 
 		UpdateStatement updateStatement = ( UpdateStatement ) walker.getAST();
 		FromElement fromElement = updateStatement.getFromClause().getFromElement();
 		String bulkTargetAlias = fromElement.getTableAlias();
 		this.persister = fromElement.getQueryable();
 
 		this.idInsertSelect = generateIdInsertSelect( persister, bulkTargetAlias, updateStatement.getWhereClause() );
 		log.trace( "Generated ID-INSERT-SELECT SQL (multi-table update) : " +  idInsertSelect );
 
 		String[] tableNames = persister.getConstraintOrderedTableNameClosure();
 		String[][] columnNames = persister.getContraintOrderedTableKeyColumnClosure();
 
 		String idSubselect = generateIdSubselect( persister );
 		List assignmentSpecifications = walker.getAssignmentSpecifications();
 
 		updates = new String[tableNames.length];
 		hqlParameters = new ParameterSpecification[tableNames.length][];
 		for ( int tableIndex = 0; tableIndex < tableNames.length; tableIndex++ ) {
 			boolean affected = false;
 			List parameterList = new ArrayList();
 			Update update = new Update( getFactory().getDialect() )
 					.setTableName( tableNames[tableIndex] )
 					.setWhere( "(" + StringHelper.join( ", ", columnNames[tableIndex] ) + ") IN (" + idSubselect + ")" );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				update.setComment( "bulk update" );
 			}
 			final Iterator itr = assignmentSpecifications.iterator();
 			while ( itr.hasNext() ) {
 				final AssignmentSpecification specification = ( AssignmentSpecification ) itr.next();
 				if ( specification.affectsTable( tableNames[tableIndex] ) ) {
 					affected = true;
 					update.appendAssignmentFragment( specification.getSqlAssignmentFragment() );
 					if ( specification.getParameters() != null ) {
 						for ( int paramIndex = 0; paramIndex < specification.getParameters().length; paramIndex++ ) {
 							parameterList.add( specification.getParameters()[paramIndex] );
 						}
 					}
 				}
 			}
 			if ( affected ) {
 				updates[tableIndex] = update.toStatementString();
 				hqlParameters[tableIndex] = ( ParameterSpecification[] ) parameterList.toArray( new ParameterSpecification[0] );
 			}
 		}
 	}
 
 	public Queryable getAffectedQueryable() {
 		return persister;
 	}
 
 	public String[] getSqlStatements() {
 		return updates;
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 		coordinateSharedCacheCleanup( session );
 
 		createTemporaryTableIfNecessary( persister, session );
 
 		try {
 			// First, save off the pertinent ids, as the return value
 			PreparedStatement ps = null;
 			int resultCount = 0;
 			try {
 				try {
-					ps = session.getJDBCContext().getConnectionManager().prepareStatement( idInsertSelect, false );
+					ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( idInsertSelect, false );
 //					int parameterStart = getWalker().getNumberOfParametersInSetClause();
 //					List allParams = getIdSelectParameterSpecifications();
 //					Iterator whereParams = allParams.subList( parameterStart, allParams.size() ).iterator();
 					Iterator whereParams = getIdSelectParameterSpecifications().iterator();
 					int sum = 1; // jdbc params are 1-based
 					while ( whereParams.hasNext() ) {
 						sum += ( ( ParameterSpecification ) whereParams.next() ).bind( ps, parameters, session, sum );
 					}
 					resultCount = ps.executeUpdate();
 				}
 				finally {
 					if ( ps != null ) {
 						ps.close();
 					}
 				}
 			}
 			catch( SQLException e ) {
 				throw getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "could not insert/select ids for bulk update",
 				        idInsertSelect
 					);
 			}
 
 			// Start performing the updates
 			for ( int i = 0; i < updates.length; i++ ) {
 				if ( updates[i] == null ) {
 					continue;
 				}
 				try {
 					try {
-						ps = session.getJDBCContext().getConnectionManager().prepareStatement( updates[i], false );
+						ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( updates[i], false );
 						if ( hqlParameters[i] != null ) {
 							int position = 1; // jdbc params are 1-based
 							for ( int x = 0; x < hqlParameters[i].length; x++ ) {
 								position += hqlParameters[i][x].bind( ps, parameters, session, position );
 							}
 						}
 						ps.executeUpdate();
 					}
 					finally {
 						if ( ps != null ) {
 							ps.close();
 						}
 					}
 				}
 				catch( SQLException e ) {
 					throw getFactory().getSQLExceptionHelper().convert(
 					        e,
 					        "error performing bulk update",
 					        updates[i]
 						);
 				}
 			}
 
 			return resultCount;
 		}
 		finally {
 			dropTemporaryTableIfNecessary( persister, session );
 		}
 	}
 
 	protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/GUIDGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/GUIDGenerator.java
index d183b1a592..3f24e37b12 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/GUIDGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/GUIDGenerator.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.SessionImplementor;
 
 /**
  * Generates <tt>string</tt> values using the SQL Server NEWID() function.
  *
  * @author Joseph Fifield
  */
 public class GUIDGenerator implements IdentifierGenerator {
 	private static final Logger log = LoggerFactory.getLogger(GUIDGenerator.class);
 	private static boolean warned = false;
 
 	public GUIDGenerator() {
 		if ( ! warned ) {
 			warned = true;
 			log.warn(
 					"DEPRECATED : use {} instead with custom {} implementation",
 					UUIDGenerator.class.getName(),
 					UUIDGenerationStrategy.class.getName()
 			);
 		}
 	}
 
 	public Serializable generate(SessionImplementor session, Object obj)
 	throws HibernateException {
 		
 		final String sql = session.getFactory().getDialect().getSelectGUIDString();
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement(sql);
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				ResultSet rs = st.executeQuery();
 				final String result;
 				try {
 					rs.next();
 					result = rs.getString(1);
 				}
 				finally {
 					rs.close();
 				}
 				log.debug("GUID identifier generated: " + result);
 				return result;
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not retrieve GUID",
 					sql
 				);
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/IdentityGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/IdentityGenerator.java
index 65aa1e4b5f..72318efff4 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/IdentityGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/IdentityGenerator.java
@@ -1,191 +1,197 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.PreparedStatement;
 
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.id.insert.IdentifierGeneratingInsert;
 import org.hibernate.id.insert.AbstractSelectingDelegate;
 import org.hibernate.id.insert.AbstractReturningDelegate;
 import org.hibernate.id.insert.InsertSelectIdentityInsert;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.HibernateException;
 import org.hibernate.AssertionFailure;
 
 /**
  * A generator for use with ANSI-SQL IDENTITY columns used as the primary key.
  * The IdentityGenerator for autoincrement/identity key generation.
  * <br><br>
  * Indicates to the <tt>Session</tt> that identity (ie. identity/autoincrement
  * column) key generation should be used.
  *
  * @author Christoph Sturm
  */
 public class IdentityGenerator extends AbstractPostInsertGenerator {
 
 	public InsertGeneratedIdentifierDelegate getInsertGeneratedIdentifierDelegate(
 			PostInsertIdentityPersister persister,
 	        Dialect dialect,
 	        boolean isGetGeneratedKeysEnabled) throws HibernateException {
 		if ( isGetGeneratedKeysEnabled ) {
 			return new GetGeneratedKeysDelegate( persister, dialect );
 		}
 		else if ( dialect.supportsInsertSelectIdentity() ) {
 			return new InsertSelectDelegate( persister, dialect );
 		}
 		else {
 			return new BasicDelegate( persister, dialect );
 		}
 	}
 
 	/**
 	 * Delegate for dealing with IDENTITY columns using JDBC3 getGeneratedKeys
 	 */
 	public static class GetGeneratedKeysDelegate
 			extends AbstractReturningDelegate
 			implements InsertGeneratedIdentifierDelegate {
 		private final PostInsertIdentityPersister persister;
 		private final Dialect dialect;
 
 		public GetGeneratedKeysDelegate(PostInsertIdentityPersister persister, Dialect dialect) {
 			super( persister );
 			this.persister = persister;
 			this.dialect = dialect;
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			IdentifierGeneratingInsert insert = new IdentifierGeneratingInsert( dialect );
 			insert.addIdentityColumn( persister.getRootTableKeyColumnNames()[0] );
 			return insert;
 		}
 
 		protected PreparedStatement prepare(String insertSQL, SessionImplementor session) throws SQLException {
-			return session.getJDBCContext().getConnectionManager().prepareStatement( insertSQL, PreparedStatement.RETURN_GENERATED_KEYS );
+			return session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( insertSQL, PreparedStatement.RETURN_GENERATED_KEYS );
 		}
 
 		public Serializable executeAndExtract(PreparedStatement insert) throws SQLException {
 			insert.executeUpdate();
 			ResultSet rs = null;
 			try {
 				rs = insert.getGeneratedKeys();
 				return IdentifierGeneratorHelper.getGeneratedIdentity(
 						rs,
 						persister.getIdentifierType()
 				);
 			}
 			finally {
 				if ( rs != null ) {
 					rs.close();
 				}
 			}
 		}
 	}
 
 	/**
 	 * Delegate for dealing with IDENTITY columns where the dialect supports returning
 	 * the generated IDENTITY value directly from the insert statement.
 	 */
 	public static class InsertSelectDelegate
 			extends AbstractReturningDelegate
 			implements InsertGeneratedIdentifierDelegate {
 		private final PostInsertIdentityPersister persister;
 		private final Dialect dialect;
 
 		public InsertSelectDelegate(PostInsertIdentityPersister persister, Dialect dialect) {
 			super( persister );
 			this.persister = persister;
 			this.dialect = dialect;
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			InsertSelectIdentityInsert insert = new InsertSelectIdentityInsert( dialect );
 			insert.addIdentityColumn( persister.getRootTableKeyColumnNames()[0] );
 			return insert;
 		}
 
 		protected PreparedStatement prepare(String insertSQL, SessionImplementor session) throws SQLException {
-			return session.getJDBCContext().getConnectionManager().prepareStatement( insertSQL, PreparedStatement.NO_GENERATED_KEYS );
+			return session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( insertSQL, PreparedStatement.NO_GENERATED_KEYS );
 		}
 
 		public Serializable executeAndExtract(PreparedStatement insert) throws SQLException {
 			if ( !insert.execute() ) {
 				while ( !insert.getMoreResults() && insert.getUpdateCount() != -1 ) {
 					// do nothing until we hit the rsult set containing the generated id
 				}
 			}
 			ResultSet rs = insert.getResultSet();
 			try {
 				return IdentifierGeneratorHelper.getGeneratedIdentity( rs, persister.getIdentifierType() );
 			}
 			finally {
 				rs.close();
 			}
 		}
 
 		public Serializable determineGeneratedIdentifier(SessionImplementor session, Object entity) {
 			throw new AssertionFailure( "insert statement returns generated value" );
 		}
 	}
 
 	/**
 	 * Delegate for dealing with IDENTITY columns where the dialect requires an
 	 * additional command execution to retrieve the generated IDENTITY value
 	 */
 	public static class BasicDelegate
 			extends AbstractSelectingDelegate
 			implements InsertGeneratedIdentifierDelegate {
 		private final PostInsertIdentityPersister persister;
 		private final Dialect dialect;
 
 		public BasicDelegate(PostInsertIdentityPersister persister, Dialect dialect) {
 			super( persister );
 			this.persister = persister;
 			this.dialect = dialect;
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			IdentifierGeneratingInsert insert = new IdentifierGeneratingInsert( dialect );
 			insert.addIdentityColumn( persister.getRootTableKeyColumnNames()[0] );
 			return insert;
 		}
 
 		protected String getSelectSQL() {
 			return persister.getIdentitySelectString();
 		}
 
 		protected Serializable getResult(
 				SessionImplementor session,
 		        ResultSet rs,
 		        Object object) throws SQLException {
 			return IdentifierGeneratorHelper.getGeneratedIdentity( rs, persister.getIdentifierType() );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
index 7cdd9bf16e..45b93f297b 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
@@ -1,154 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cfg.ObjectNameNormalizer;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.mapping.Table;
 import org.hibernate.type.Type;
 import org.hibernate.util.StringHelper;
 
 /**
  * <b>increment</b><br>
  * <br>
  * An <tt>IdentifierGenerator</tt> that returns a <tt>long</tt>, constructed by
  * counting from the maximum primary key value at startup. Not safe for use in a
  * cluster!<br>
  * <br>
  * Mapping parameters supported, but not usually needed: tables, column.
  * (The tables parameter specified a comma-separated list of table names.)
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class IncrementGenerator implements IdentifierGenerator, Configurable {
 	private static final Logger log = LoggerFactory.getLogger(IncrementGenerator.class);
 
 	private Class returnClass;
 	private String sql;
 
 	private IntegralDataTypeHolder previousValueHolder;
 
 	public synchronized Serializable generate(SessionImplementor session, Object object) throws HibernateException {
 		if ( sql != null ) {
 			initializePreviousValueHolder( session );
 		}
 		return previousValueHolder.makeValueThenIncrement();
 	}
 
 	public void configure(Type type, Properties params, Dialect dialect) throws MappingException {
 		returnClass = type.getReturnedClass();
 
 		ObjectNameNormalizer normalizer =
 				( ObjectNameNormalizer ) params.get( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER );
 
 		String column = params.getProperty( "column" );
 		if ( column == null ) {
 			column = params.getProperty( PersistentIdentifierGenerator.PK );
 		}
 		column = dialect.quote( normalizer.normalizeIdentifierQuoting( column ) );
 
 		String tableList = params.getProperty( "tables" );
 		if ( tableList == null ) {
 			tableList = params.getProperty( PersistentIdentifierGenerator.TABLES );
 		}
 		String[] tables = StringHelper.split( ", ", tableList );
 
 		final String schema = dialect.quote(
 				normalizer.normalizeIdentifierQuoting(
 						params.getProperty( PersistentIdentifierGenerator.SCHEMA )
 				)
 		);
 		final String catalog = dialect.quote(
 				normalizer.normalizeIdentifierQuoting(
 						params.getProperty( PersistentIdentifierGenerator.CATALOG )
 				)
 		);
 
 		StringBuffer buf = new StringBuffer();
 		for ( int i=0; i < tables.length; i++ ) {
 			final String tableName = dialect.quote( normalizer.normalizeIdentifierQuoting( tables[i] ) );
 			if ( tables.length > 1 ) {
 				buf.append( "select " ).append( column ).append( " from " );
 			}
 			buf.append( Table.qualify( catalog, schema, tableName ) );
 			if ( i < tables.length-1 ) {
 				buf.append( " union " );
 			}
 		}
 		if ( tables.length > 1 ) {
 			buf.insert( 0, "( " ).append( " ) ids_" );
 			column = "ids_." + column;
 		}
 		
 		sql = "select max(" + column + ") from " + buf.toString();
 	}
 
 	private void initializePreviousValueHolder(SessionImplementor session) {
 		previousValueHolder = IdentifierGeneratorHelper.getIntegralDataTypeHolder( returnClass );
 
 		log.debug( "fetching initial value: " + sql );
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( rs.next() ) {
 						previousValueHolder.initialize( rs, 0L ).increment();
 					}
 					else {
 						previousValueHolder.initialize( 1L );
 					}
 					sql = null;
 					log.debug( "first free id: " + previousValueHolder.makeValue() );
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not fetch initial value for increment generator",
 					sql
 			);
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
index 87f37e08a7..d3da145438 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cfg.ObjectNameNormalizer;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.mapping.Table;
 import org.hibernate.type.Type;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * <b>sequence</b><br>
  * <br>
  * Generates <tt>long</tt> values using an oracle-style sequence. A higher
  * performance algorithm is <tt>SequenceHiLoGenerator</tt>.<br>
  * <br>
  * Mapping parameters supported: sequence, parameters.
  *
  * @see SequenceHiLoGenerator
  * @see TableHiLoGenerator
  * @author Gavin King
  */
 public class SequenceGenerator implements PersistentIdentifierGenerator, Configurable {
 	private static final Logger log = LoggerFactory.getLogger(SequenceGenerator.class);
 
 	/**
 	 * The sequence parameter
 	 */
 	public static final String SEQUENCE = "sequence";
 
 	/**
 	 * The parameters parameter, appended to the create sequence DDL.
 	 * For example (Oracle): <tt>INCREMENT BY 1 START WITH 1 MAXVALUE 100 NOCACHE</tt>.
 	 */
 	public static final String PARAMETERS = "parameters";
 
 	private String sequenceName;
 	private String parameters;
 	private Type identifierType;
 	private String sql;
 
 	protected Type getIdentifierType() {
 		return identifierType;
 	}
 
 	public void configure(Type type, Properties params, Dialect dialect) throws MappingException {
 		ObjectNameNormalizer normalizer = ( ObjectNameNormalizer ) params.get( IDENTIFIER_NORMALIZER );
 		sequenceName = normalizer.normalizeIdentifierQuoting(
 				ConfigurationHelper.getString( SEQUENCE, params, "hibernate_sequence" )
 		);
 		parameters = params.getProperty( PARAMETERS );
 
 		if ( sequenceName.indexOf( '.' ) < 0 ) {
 			final String schemaName = normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) );
 			final String catalogName = normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) );
 			sequenceName = Table.qualify(
 					dialect.quote( catalogName ),
 					dialect.quote( schemaName ),
 					dialect.quote( sequenceName )
 			);
 		}
 		else {
 			// if already qualified there is not much we can do in a portable manner so we pass it
 			// through and assume the user has set up the name correctly.
 		}
 
 		this.identifierType = type;
 		sql = dialect.getSequenceNextValString( sequenceName );
 	}
 
 	public Serializable generate(SessionImplementor session, Object obj) {
 		return generateHolder( session ).makeValue();
 	}
 
 	protected IntegralDataTypeHolder generateHolder(SessionImplementor session) {
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				ResultSet rs = st.executeQuery();
 				try {
 					rs.next();
 					IntegralDataTypeHolder result = buildHolder();
 					result.initialize( rs, 1 );
 					if ( log.isDebugEnabled() ) {
 						log.debug("Sequence identifier generated: " + result);
 					}
 					return result;
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not get next sequence value",
 					sql
 			);
 		}
 	}
 
 	protected IntegralDataTypeHolder buildHolder() {
 		return IdentifierGeneratorHelper.getIntegralDataTypeHolder( identifierType.getReturnedClass() );
 	}
 
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		String[] ddl = dialect.getCreateSequenceStrings(sequenceName);
 		if ( parameters != null ) {
 			ddl[ddl.length - 1] += ' ' + parameters;
 		}
 		return ddl;
 	}
 
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return dialect.getDropSequenceStrings(sequenceName);
 	}
 
 	public Object generatorKey() {
 		return sequenceName;
 	}
 
 	public String getSequenceName() {
 		return sequenceName;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
index 5382fbeda2..d61e23aac0 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
@@ -1,123 +1,123 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.id;
 
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.id.insert.AbstractReturningDelegate;
 import org.hibernate.id.insert.IdentifierGeneratingInsert;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.sql.Insert;
 import org.hibernate.type.Type;
 import org.hibernate.engine.SessionImplementor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Properties;
 
 /**
  * A generator which combines sequence generation with immediate retrieval
  * through JDBC3 {@link java.sql.Connection#prepareStatement(String, String[]) getGeneratedKeys}.
  * In this respect it works much like ANSI-SQL IDENTITY generation.
  * <p/>
  * This generator only known to work with newer Oracle drivers compiled for
  * JDK 1.4 (JDBC3).
  * <p/>
  * Note: Due to a bug in Oracle drivers, sql comments on these insert statements
  * are completely disabled.
  *
  * @author Steve Ebersole
  */
 public class SequenceIdentityGenerator extends SequenceGenerator
 		implements PostInsertIdentifierGenerator {
 
 	private static final Logger log = LoggerFactory.getLogger( SequenceIdentityGenerator.class );
 
 	public Serializable generate(SessionImplementor s, Object obj) {
 		return IdentifierGeneratorHelper.POST_INSERT_INDICATOR;
 	}
 
 	public InsertGeneratedIdentifierDelegate getInsertGeneratedIdentifierDelegate(
 			PostInsertIdentityPersister persister,
 	        Dialect dialect,
 	        boolean isGetGeneratedKeysEnabled) throws HibernateException {
 		return new Delegate( persister, dialect, getSequenceName() );
 	}
 
 	public void configure(Type type, Properties params, Dialect dialect) throws MappingException {
 		super.configure( type, params, dialect );
 	}
 
 	public static class Delegate extends AbstractReturningDelegate {
 		private final Dialect dialect;
 		private final String sequenceNextValFragment;
 		private final String[] keyColumns;
 
 		public Delegate(PostInsertIdentityPersister persister, Dialect dialect, String sequenceName) {
 			super( persister );
 			this.dialect = dialect;
 			this.sequenceNextValFragment = dialect.getSelectSequenceNextValString( sequenceName );
 			this.keyColumns = getPersister().getRootTableKeyColumnNames();
 			if ( keyColumns.length > 1 ) {
 				throw new HibernateException( "sequence-identity generator cannot be used with with multi-column keys" );
 			}
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			NoCommentsInsert insert = new NoCommentsInsert( dialect );
 			insert.addColumn( getPersister().getRootTableKeyColumnNames()[0], sequenceNextValFragment );
 			return insert;
 		}
 
 		protected PreparedStatement prepare(String insertSQL, SessionImplementor session) throws SQLException {
-			return session.getJDBCContext().getConnectionManager().prepareStatement( insertSQL, keyColumns );
+			return session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( insertSQL, keyColumns );
 		}
 
 		protected Serializable executeAndExtract(PreparedStatement insert) throws SQLException {
 			insert.executeUpdate();
 			return IdentifierGeneratorHelper.getGeneratedIdentity(
 					insert.getGeneratedKeys(),
 			        getPersister().getIdentifierType()
 			);
 		}
 	}
 
 	public static class NoCommentsInsert extends IdentifierGeneratingInsert {
 		public NoCommentsInsert(Dialect dialect) {
 			super( dialect );
 		}
 
 		public Insert setComment(String comment) {
 			// don't allow comments on these insert statements as comments totally
 			// blow up the Oracle getGeneratedKeys "support" :(
 			log.info( "disallowing insert statement comment for select-identity due to Oracle driver bug" );
 			return this;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java b/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java
index d946d2cf1e..5b2ac14c9c 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.id.enhanced;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.HibernateException;
 import org.hibernate.id.IdentifierGeneratorHelper;
 import org.hibernate.id.IntegralDataTypeHolder;
 
 /**
  * Describes a sequence.
  *
  * @author Steve Ebersole
  */
 public class SequenceStructure implements DatabaseStructure {
 	private static final Logger log = LoggerFactory.getLogger( SequenceStructure.class );
 
 	private final String sequenceName;
 	private final int initialValue;
 	private final int incrementSize;
 	private final Class numberType;
 	private final String sql;
 	private boolean applyIncrementSizeToSourceValues;
 	private int accessCounter;
 
 	public SequenceStructure(
 			Dialect dialect,
 			String sequenceName,
 			int initialValue,
 			int incrementSize,
 			Class numberType) {
 		this.sequenceName = sequenceName;
 		this.initialValue = initialValue;
 		this.incrementSize = incrementSize;
 		this.numberType = numberType;
 		sql = dialect.getSequenceNextValString( sequenceName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String getName() {
 		return sequenceName;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public int getIncrementSize() {
 		return incrementSize;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public int getTimesAccessed() {
 		return accessCounter;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public int getInitialValue() {
 		return initialValue;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public AccessCallback buildCallback(final SessionImplementor session) {
 		return new AccessCallback() {
 			public IntegralDataTypeHolder getNextValue() {
 				accessCounter++;
 				try {
-					PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+					PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 					try {
 						ResultSet rs = st.executeQuery();
 						try {
 							rs.next();
 							IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( numberType );
 							value.initialize( rs, 1 );
 							if ( log.isDebugEnabled() ) {
 								log.debug( "Sequence value obtained: " + value.makeValue() );
 							}
 							return value;
 						}
 						finally {
 							try {
 								rs.close();
 							}
 							catch( Throwable ignore ) {
 								// intentionally empty
 							}
 						}
 					}
 					finally {
 						st.close();
 					}
 
 				}
 				catch ( SQLException sqle) {
 					throw session.getFactory().getSQLExceptionHelper().convert(
 							sqle,
 							"could not get next sequence value",
 							sql
 					);
 				}
 			}
 		};
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void prepare(Optimizer optimizer) {
 		applyIncrementSizeToSourceValues = optimizer.applyIncrementSizeToSourceValues();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		int sourceIncrementSize = applyIncrementSizeToSourceValues ? incrementSize : 1;
 		return dialect.getCreateSequenceStrings( sequenceName, initialValue, sourceIncrementSize );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return dialect.getDropSequenceStrings( sequenceName );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/insert/AbstractSelectingDelegate.java b/hibernate-core/src/main/java/org/hibernate/id/insert/AbstractSelectingDelegate.java
index 9b93eab5d7..ca9c3a978c 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/insert/AbstractSelectingDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/insert/AbstractSelectingDelegate.java
@@ -1,134 +1,140 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.id.insert;
 
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.id.PostInsertIdentityPersister;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.ResultSet;
 import java.io.Serializable;
 
 /**
  * Abstract InsertGeneratedIdentifierDelegate implementation where the
  * underlying strategy requires an subsequent select after the insert
  * to determine the generated identifier.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractSelectingDelegate implements InsertGeneratedIdentifierDelegate {
 	private final PostInsertIdentityPersister persister;
 
 	protected AbstractSelectingDelegate(PostInsertIdentityPersister persister) {
 		this.persister = persister;
 	}
 
 	public final Serializable performInsert(String insertSQL, SessionImplementor session, Binder binder) {
 		try {
 			// prepare and execute the insert
-			PreparedStatement insert = session.getJDBCContext().getConnectionManager().prepareStatement( insertSQL, PreparedStatement.NO_GENERATED_KEYS );
+			PreparedStatement insert = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( insertSQL, PreparedStatement.NO_GENERATED_KEYS );
 			try {
 				binder.bindValues( insert );
 				insert.executeUpdate();
 			}
 			finally {
 				insert.close();
 			}
 		}
 		catch ( SQLException sqle ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not insert: " + MessageHelper.infoString( persister ),
 			        insertSQL
 				);
 		}
 
 		final String selectSQL = getSelectSQL();
 
 		try {
 			//fetch the generated id in a separate query
-			PreparedStatement idSelect = session.getJDBCContext().getConnectionManager().prepareStatement( selectSQL, false );
+			PreparedStatement idSelect = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( selectSQL, false );
 			try {
 				bindParameters( session, idSelect, binder.getEntity() );
 				ResultSet rs = idSelect.executeQuery();
 				try {
 					return getResult( session, rs, binder.getEntity() );
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				idSelect.close();
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not retrieve generated id after insert: " + MessageHelper.infoString( persister ),
 			        insertSQL
 			);
 		}
 	}
 
 	/**
 	 * Get the SQL statement to be used to retrieve generated key values.
 	 *
 	 * @return The SQL command string
 	 */
 	protected abstract String getSelectSQL();
 
 	/**
 	 * Bind any required parameter values into the SQL command {@link #getSelectSQL}.
 	 *
 	 * @param session The session
 	 * @param ps The prepared {@link #getSelectSQL SQL} command
 	 * @param entity The entity being saved.
 	 * @throws SQLException
 	 */
 	protected void bindParameters(
 			SessionImplementor session,
 	        PreparedStatement ps,
 	        Object entity) throws SQLException {
 	}
 
 	/**
 	 * Extract the generated key value from the given result set.
 	 *
 	 * @param session The session
 	 * @param rs The result set containing the generated primay key values.
 	 * @param entity The entity being saved.
 	 * @return The generated identifier
 	 * @throws SQLException
 	 */
 	protected abstract Serializable getResult(
 			SessionImplementor session,
 	        ResultSet rs,
 	        Object entity) throws SQLException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/AbstractSessionImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/AbstractSessionImpl.java
index ea7e1cbdbe..bc017b1a27 100755
--- a/hibernate-core/src/main/java/org/hibernate/impl/AbstractSessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/AbstractSessionImpl.java
@@ -1,173 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.impl;
 
 import org.hibernate.MappingException;
 import org.hibernate.Query;
 import org.hibernate.SQLQuery;
 import org.hibernate.HibernateException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.SessionException;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.NamedQueryDefinition;
 import org.hibernate.engine.NamedSQLQueryDefinition;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.query.HQLQueryPlan;
 import org.hibernate.engine.query.NativeSQLQueryPlan;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 
 import java.util.List;
 
 /**
  * Functionality common to stateless and stateful sessions
  * 
  * @author Gavin King
  */
-public abstract class AbstractSessionImpl implements SessionImplementor {
+public abstract class AbstractSessionImpl implements SessionImplementor, TransactionContext {
 
 	protected transient SessionFactoryImpl factory;
 	private boolean closed = false;
 
 	protected AbstractSessionImpl(SessionFactoryImpl factory) {
 		this.factory = factory;
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
+	@Override
+	public TransactionEnvironment getTransactionEnvironment() {
+		return factory.getTransactionEnvironment();
+	}
+
 	public boolean isClosed() {
 		return closed;
 	}
 
 	protected void setClosed() {
 		closed = true;
 	}
 
 	protected void errorIfClosed() {
 		if ( closed ) {
 			throw new SessionException( "Session is closed!" );
 		}
 	}
 
 	public Query getNamedQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedQueryDefinition nqd = factory.getNamedQuery( queryName );
 		final Query query;
 		if ( nqd != null ) {
 			String queryString = nqd.getQueryString();
 			query = new QueryImpl(
 					queryString,
 			        nqd.getFlushMode(),
 			        this,
 			        getHQLQueryPlan( queryString, false ).getParameterMetadata()
 			);
 			query.setComment( "named HQL query " + queryName );
 		}
 		else {
 			NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 			if ( nsqlqd==null ) {
 				throw new MappingException( "Named query not known: " + queryName );
 			}
 			query = new SQLQueryImpl(
 					nsqlqd,
 			        this,
 			        factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() )
 			);
 			query.setComment( "named native SQL query " + queryName );
 			nqd = nsqlqd;
 		}
 		initQuery( query, nqd );
 		return query;
 	}
 
 	public Query getNamedSQLQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 		if ( nsqlqd==null ) {
 			throw new MappingException( "Named SQL query not known: " + queryName );
 		}
 		Query query = new SQLQueryImpl(
 				nsqlqd,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() )
 		);
 		query.setComment( "named native SQL query " + queryName );
 		initQuery( query, nsqlqd );
 		return query;
 	}
 
 	private void initQuery(Query query, NamedQueryDefinition nqd) {
 		query.setCacheable( nqd.isCacheable() );
 		query.setCacheRegion( nqd.getCacheRegion() );
 		if ( nqd.getTimeout()!=null ) query.setTimeout( nqd.getTimeout().intValue() );
 		if ( nqd.getFetchSize()!=null ) query.setFetchSize( nqd.getFetchSize().intValue() );
 		if ( nqd.getCacheMode() != null ) query.setCacheMode( nqd.getCacheMode() );
 		query.setReadOnly( nqd.isReadOnly() );
 		if ( nqd.getComment() != null ) query.setComment( nqd.getComment() );
 	}
 
 	public Query createQuery(String queryString) {
 		errorIfClosed();
 		QueryImpl query = new QueryImpl(
 				queryString,
 		        this,
 		        getHQLQueryPlan( queryString, false ).getParameterMetadata()
 		);
 		query.setComment( queryString );
 		return query;
 	}
 
 	public SQLQuery createSQLQuery(String sql) {
 		errorIfClosed();
 		SQLQueryImpl query = new SQLQueryImpl(
 				sql,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
 		);
 		query.setComment( "dynamic native SQL query" );
 		return query;
 	}
 
 	protected HQLQueryPlan getHQLQueryPlan(String query, boolean shallow) throws HibernateException {
 		return factory.getQueryPlanCache().getHQLQueryPlan( query, shallow, getEnabledFilters() );
 	}
 
 	protected NativeSQLQueryPlan getNativeSQLQueryPlan(NativeSQLQuerySpecification spec) throws HibernateException {
 		return factory.getQueryPlanCache().getNativeSQLQueryPlan( spec );
 	}
 
 	public List list(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return listCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 	public ScrollableResults scroll(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return scrollCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/ConnectionObserverStatsBridge.java b/hibernate-core/src/main/java/org/hibernate/impl/ConnectionObserverStatsBridge.java
new file mode 100644
index 0000000000..cbfb318576
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/impl/ConnectionObserverStatsBridge.java
@@ -0,0 +1,59 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.impl;
+
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.spi.ConnectionObserver;
+
+import java.io.Serializable;
+import java.sql.Connection;
+
+/**
+ * @author Steve Ebersole
+ */
+public class ConnectionObserverStatsBridge implements ConnectionObserver, Serializable {
+	private final SessionFactoryImplementor sessionFactory;
+
+	public ConnectionObserverStatsBridge(SessionFactoryImplementor sessionFactory) {
+		this.sessionFactory = sessionFactory;
+	}
+
+	@Override
+	public void physicalConnectionObtained(Connection connection) {
+		sessionFactory.getStatisticsImplementor().connect();
+	}
+
+	@Override
+	public void physicalConnectionReleased() {
+	}
+
+	@Override
+	public void logicalConnectionClosed() {
+	}
+
+	@Override
+	public void statementPrepared() {
+		sessionFactory.getStatisticsImplementor().prepareStatement();
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
index 6a004835ca..3a7dedf62d 100644
--- a/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
@@ -1,1330 +1,1336 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.impl;
 
-import java.io.IOException;
-import java.io.InvalidObjectException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.sql.Connection;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import javax.naming.NamingException;
-import javax.naming.Reference;
-import javax.naming.StringRefAddr;
-import javax.transaction.TransactionManager;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.TypeHelper;
 import org.hibernate.cache.CacheKey;
 import org.hibernate.cache.CollectionRegion;
 import org.hibernate.cache.EntityRegion;
 import org.hibernate.cache.QueryCache;
 import org.hibernate.cache.Region;
 import org.hibernate.cache.UpdateTimestampsCache;
 import org.hibernate.cache.access.AccessType;
 import org.hibernate.cache.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.impl.CacheDataDescriptionImpl;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
-import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.exception.SQLExceptionConverter;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.context.CurrentSessionContext;
 import org.hibernate.context.JTASessionContext;
 import org.hibernate.context.ManagedSessionContext;
 import org.hibernate.context.ThreadLocalSessionContext;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.FilterDefinition;
 import org.hibernate.engine.Mapping;
 import org.hibernate.engine.NamedQueryDefinition;
 import org.hibernate.engine.NamedSQLQueryDefinition;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.QueryPlanCache;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.event.EventListeners;
+import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.persister.PersisterFactory;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
+import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.stat.ConcurrentStatisticsImpl;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
-import org.hibernate.transaction.TransactionFactory;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.util.CollectionHelper;
 import org.hibernate.util.EmptyIterator;
 import org.hibernate.util.ReflectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.naming.NamingException;
+import javax.naming.Reference;
+import javax.naming.StringRefAddr;
+import javax.transaction.TransactionManager;
+import java.io.IOException;
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.sql.Connection;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
  * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider
  * @see org.hibernate.classic.Session
  * @see org.hibernate.hql.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
-public final class SessionFactoryImpl implements SessionFactory, SessionFactoryImplementor {
+public final class SessionFactoryImpl
+		implements SessionFactory, SessionFactoryImplementor {
 
 	private static final Logger log = LoggerFactory.getLogger(SessionFactoryImpl.class);
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map collectionPersisters;
 	private final transient Map collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map identifierGenerators;
 	private final transient Map namedQueries;
 	private final transient Map namedSqlQueries;
 	private final transient Map sqlResultSetMappings;
 	private final transient Map filters;
 	private final transient Map fetchProfiles;
 	private final transient Map imports;
 	private final transient Interceptor interceptor;
 	private final transient ServiceRegistry serviceRegistry;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
-	private final transient TransactionManager transactionManager;
 	private final transient QueryCache queryCache;
 	private final transient UpdateTimestampsCache updateTimestampsCache;
 	private final transient Map<String,QueryCache> queryCaches;
 	private final transient ConcurrentMap<String,Region> allCacheRegions = new ConcurrentHashMap<String, Region>();
 	private final transient Statistics statistics;
 	private final transient EventListeners eventListeners;
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient EntityNotFoundDelegate entityNotFoundDelegate;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserver observer;
 	private final transient HashMap entityNameResolvers = new HashMap();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient Cache cacheAccess = new CacheImpl();
 	private transient boolean isClosed = false;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
+	private final transient TransactionEnvironment transactionEnvironment;
 
 	public SessionFactoryImpl(
 			Configuration cfg,
 	        Mapping mapping,
 			ServiceRegistry serviceRegistry,
 	        Settings settings,
 	        EventListeners listeners,
 			SessionFactoryObserver observer) throws HibernateException {
 		log.info("building session factory");
 
 		this.statistics = new ConcurrentStatisticsImpl( this );
 		getStatistics().setStatisticsEnabled( settings.isStatisticsEnabled() );
 		log.debug( "Statistics initialized [enabled={}]}", settings.isStatisticsEnabled() );
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 		this.interceptor = cfg.getInterceptor();
 		this.serviceRegistry = serviceRegistry;
 		this.settings = settings;
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
         this.eventListeners = listeners;
 		this.observer = observer != null ? observer : new SessionFactoryObserver() {
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 			public void sessionFactoryClosed(SessionFactory factory) {
 			}
 		};
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
 		if ( log.isDebugEnabled() ) {
 			log.debug("Session factory constructed with filter configurations : " + filters);
 		}
 
 		if ( log.isDebugEnabled() ) {
 			log.debug(
 					"instantiating session factory with properties: " + properties
 			);
 		}
 
 		// Caches
 		settings.getRegionFactory().start( settings, properties );
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
 					log.trace( "Building cache for entity data [" + model.getEntityName() + "]" );
 					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					allCacheRegions.put( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = PersisterFactory.createClassPersister( model, accessStrategy, this, mapping );
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
 				log.trace( "Building cache for collection data [" + model.getRole() + "]" );
 				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				allCacheRegions.put( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = PersisterFactory.createCollectionPersister( cfg, model, accessStrategy, this) ;
 			collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap( cfg.getNamedQueries() );
 		namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
 		sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
 		imports = new HashMap( cfg.getImports() );
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryObjectFactory.addInstance(uuid, name, this, properties);
 
 		log.debug("instantiated session factory");
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( getJdbcServices(), cfg ).create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( getJdbcServices(), cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( getJdbcServices(), cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( getJdbcServices(), cfg );
 		}
 
-		if ( settings.getTransactionManagerLookup()!=null ) {
-			log.debug("obtaining JTA TransactionManager");
-			transactionManager = settings.getTransactionManagerLookup().getTransactionManager(properties);
-		}
-		else {
-			if ( settings.getTransactionFactory().isTransactionManagerRequired() ) {
-				throw new HibernateException("The chosen transaction strategy requires access to the JTA TransactionManager");
-			}
-			transactionManager = null;
-		}
-
 		currentSessionContext = buildCurrentSessionContext();
 
 		if ( settings.isQueryCacheEnabled() ) {
 			updateTimestampsCache = new UpdateTimestampsCache(settings, properties);
 			queryCache = settings.getQueryCacheFactory()
 			        .getQueryCache(null, updateTimestampsCache, settings, properties);
 			queryCaches = new HashMap<String,QueryCache>();
 			allCacheRegions.put( updateTimestampsCache.getRegion().getName(), updateTimestampsCache.getRegion() );
 			allCacheRegions.put( queryCache.getRegion().getName(), queryCache.getRegion() );
 		}
 		else {
 			updateTimestampsCache = null;
 			queryCache = null;
 			queryCaches = null;
 		}
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			Map errors = checkNamedQueries();
 			if ( !errors.isEmpty() ) {
 				Set keys = errors.keySet();
 				StringBuffer failingQueries = new StringBuffer( "Errors in named queries: " );
 				for ( Iterator iterator = keys.iterator() ; iterator.hasNext() ; ) {
 					String queryName = ( String ) iterator.next();
 					HibernateException e = ( HibernateException ) errors.get( queryName );
 					failingQueries.append( queryName );
 					if ( iterator.hasNext() ) {
 						failingQueries.append( ", " );
 					}
 					log.error( "Error in named query: " + queryName, e );
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// EntityNotFoundDelegate
 		EntityNotFoundDelegate entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 		if ( entityNotFoundDelegate == null ) {
 			entityNotFoundDelegate = new EntityNotFoundDelegate() {
 				public void handleEntityNotFound(String entityName, Serializable id) {
 					throw new ObjectNotFoundException( id, entityName );
 				}
 			};
 		}
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			Iterator fetches = mappingProfile.getFetches().iterator();
 			while ( fetches.hasNext() ) {
 				final org.hibernate.mapping.FetchProfile.Fetch mappingFetch =
 						( org.hibernate.mapping.FetchProfile.Fetch ) fetches.next();
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = ( EntityPersister ) ( entityName == null ? null : entityPersisters.get( entityName ) );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
+		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
+	public TransactionEnvironment getTransactionEnvironment() {
+		return transactionEnvironment;
+	}
+
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizerMapping() == null ) {
 			return;
 		}
 		Iterator itr = persister.getEntityMetamodel().getTuplizerMapping().iterateTuplizers();
 		while ( itr.hasNext() ) {
 			final EntityTuplizer tuplizer = ( EntityTuplizer ) itr.next();
 			registerEntityNameResolvers( tuplizer );
 		}
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( int i = 0; i < resolvers.length; i++ ) {
 			registerEntityNameResolver( resolvers[i], tuplizer.getEntityMode() );
 		}
 	}
 
 	public void registerEntityNameResolver(EntityNameResolver resolver, EntityMode entityMode) {
 		LinkedHashSet resolversForMode = ( LinkedHashSet ) entityNameResolvers.get( entityMode );
 		if ( resolversForMode == null ) {
 			resolversForMode = new LinkedHashSet();
 			entityNameResolvers.put( entityMode, resolversForMode );
 		}
 		resolversForMode.add( resolver );
 	}
 
 	public Iterator iterateEntityNameResolvers(EntityMode entityMode) {
 		Set actualEntityNameResolvers = ( Set ) entityNameResolvers.get( entityMode );
 		return actualEntityNameResolvers == null
 				? EmptyIterator.INSTANCE
 				: actualEntityNameResolvers.iterator();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	private Map checkNamedQueries() throws HibernateException {
 		Map errors = new HashMap();
 
 		// Check named HQL queries
 		log.debug("Checking " + namedQueries.size() + " named HQL queries");
 		Iterator itr = namedQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedQueryDefinition qd = ( NamedQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
 				log.debug("Checking named query: " + queryName);
 				//TODO: BUG! this currently fails for named queries for non-POJO entities
 				queryPlanCache.getHQLQueryPlan( qd.getQueryString(), false, CollectionHelper.EMPTY_MAP );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
 		log.debug("Checking " + namedSqlQueries.size() + " named SQL queries");
 		itr = namedSqlQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedSQLQueryDefinition qd = ( NamedSQLQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
 				log.debug("Checking named SQL query: " + queryName);
 				// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash;
 				// currently not doable though because of the resultset-ref stuff...
 				NativeSQLQuerySpecification spec;
 				if ( qd.getResultSetRef() != null ) {
 					ResultSetMappingDefinition definition = ( ResultSetMappingDefinition ) sqlResultSetMappings.get( qd.getResultSetRef() );
 					if ( definition == null ) {
 						throw new MappingException( "Unable to find resultset-ref definition: " + qd.getResultSetRef() );
 					}
 					spec = new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        definition.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				else {
 					spec =  new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        qd.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				queryPlanCache.getNativeSQLQueryPlan( spec );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
 		return errors;
 	}
 
 	public StatelessSession openStatelessSession() {
 		return new StatelessSessionImpl( null, this );
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return new StatelessSessionImpl( connection, this );
 	}
 
 	private SessionImpl openSession(
 		Connection connection,
 	    boolean autoClose,
 	    long timestamp,
 	    Interceptor sessionLocalInterceptor
 	) {
 		return new SessionImpl(
 		        connection,
 		        this,
 		        autoClose,
 		        timestamp,
 		        sessionLocalInterceptor == null ? interceptor : sessionLocalInterceptor,
 		        settings.getDefaultEntityMode(),
 		        settings.isFlushBeforeCompletionEnabled(),
 		        settings.isAutoCloseSessionEnabled(),
 		        settings.getConnectionReleaseMode()
 			);
 	}
 
 	public org.hibernate.classic.Session openSession(Connection connection, Interceptor sessionLocalInterceptor) {
 		return openSession(connection, false, Long.MIN_VALUE, sessionLocalInterceptor);
 	}
 
 	public org.hibernate.classic.Session openSession(Interceptor sessionLocalInterceptor)
 	throws HibernateException {
 		// note that this timestamp is not correct if the connection provider
 		// returns an older JDBC connection that was associated with a
 		// transaction that was already begun before openSession() was called
 		// (don't know any possible solution to this!)
 		long timestamp = settings.getRegionFactory().nextTimestamp();
 		return openSession( null, true, timestamp, sessionLocalInterceptor );
 	}
 
 	public org.hibernate.classic.Session openSession(Connection connection) {
 		return openSession(connection, interceptor); //prevents this session from adding things to cache
 	}
 
 	public org.hibernate.classic.Session openSession() throws HibernateException {
 		return openSession(interceptor);
 	}
 
 	public org.hibernate.classic.Session openTemporarySession() throws HibernateException {
 		return new SessionImpl(
 				null,
 		        this,
 		        true,
 		        settings.getRegionFactory().nextTimestamp(),
 		        interceptor,
 		        settings.getDefaultEntityMode(),
 		        false,
 		        false,
 		        ConnectionReleaseMode.AFTER_STATEMENT
 			);
 	}
 
 	public org.hibernate.classic.Session openSession(
 			final Connection connection,
 	        final boolean flushBeforeCompletionEnabled,
 	        final boolean autoCloseSessionEnabled,
 	        final ConnectionReleaseMode connectionReleaseMode) throws HibernateException {
 		return new SessionImpl(
 				connection,
 		        this,
 		        true,
 		        settings.getRegionFactory().nextTimestamp(),
 		        interceptor,
 		        settings.getDefaultEntityMode(),
 		        flushBeforeCompletionEnabled,
 		        autoCloseSessionEnabled,
 		        connectionReleaseMode
 			);
 	}
 
 	public org.hibernate.classic.Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = (EntityPersister) entityPersisters.get(entityName);
 		if (result==null) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = (CollectionPersister) collectionPersisters.get(role);
 		if (result==null) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return serviceRegistry.getService( JdbcServices.class );
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return getJdbcServices().getDialect();
 	}
 
 	public Interceptor getInterceptor()
 	{
 		return interceptor;
 	}
 
-	public TransactionFactory getTransactionFactory() {
-		return settings.getTransactionFactory();
-	}
-
-	public TransactionManager getTransactionManager() {
-		return transactionManager;
-	}
-
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SQLExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	// from javax.naming.Referenceable
 	public Reference getReference() throws NamingException {
 		log.debug("Returning a Reference to the SessionFactory");
 		return new Reference(
 			SessionFactoryImpl.class.getName(),
 		    new StringRefAddr("uuid", uuid),
 		    SessionFactoryObjectFactory.class.getName(),
 		    null
 		);
 	}
 
 	private Object readResolve() throws ObjectStreamException {
 		log.trace("Resolving serialized SessionFactory");
 		// look for the instance by uuid
 		Object result = SessionFactoryObjectFactory.getInstance(uuid);
 		if (result==null) {
 			// in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryObjectFactory.getNamedInstance(name);
 			if (result==null) {
 				throw new InvalidObjectException("Could not find a SessionFactory named: " + name);
 			}
 			else {
 				log.debug("resolved SessionFactory by name");
 			}
 		}
 		else {
 			log.debug("resolved SessionFactory by uid");
 		}
 		return result;
 	}
 
 	public NamedQueryDefinition getNamedQuery(String queryName) {
 		return (NamedQueryDefinition) namedQueries.get(queryName);
 	}
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName) {
 		return (NamedSQLQueryDefinition) namedSqlQueries.get(queryName);
 	}
 
 	public ResultSetMappingDefinition getResultSetMapping(String resultSetName) {
 		return (ResultSetMappingDefinition) sqlResultSetMappings.get(resultSetName);
 	}
 
 	public Type getIdentifierType(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierType();
 	}
 	public String getIdentifierPropertyName(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierPropertyName();
 	}
 
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 		log.trace("deserializing");
 		in.defaultReadObject();
 		log.debug("deserialized: " + uuid);
 	}
 
 	private void writeObject(ObjectOutputStream out) throws IOException {
 		log.debug("serializing: " + uuid);
 		out.defaultWriteObject();
 		log.trace("serialized");
 	}
 
 	public Type[] getReturnTypes(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnTypes();
 	}
 
 	public String[] getReturnAliases(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnAliases();
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getClassMetadata( persistentClass.getName() );
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return (CollectionMetadata) collectionMetadata.get(roleName);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName) throws HibernateException {
 		return (ClassMetadata) classMetadata.get(entityName);
 	}
 
 	/**
 	 * Return the names of all persistent (mapped) classes that extend or implement the
 	 * given class or interface, accounting for implicit/explicit polymorphism settings
 	 * and excluding mapped subclasses/joined-subclasses of other classes in the result.
 	 */
 	public String[] getImplementors(String className) throws MappingException {
 
 		final Class clazz;
 		try {
 			clazz = ReflectHelper.classForName(className);
 		}
 		catch (ClassNotFoundException cnfe) {
 			return new String[] { className }; //for a dynamic-class
 		}
 
 		ArrayList results = new ArrayList();
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			//test this entity to see if we must query it
 			EntityPersister testPersister = (EntityPersister) iter.next();
 			if ( testPersister instanceof Queryable ) {
 				Queryable testQueryable = (Queryable) testPersister;
 				String testClassName = testQueryable.getEntityName();
 				boolean isMappedClass = className.equals(testClassName);
 				if ( testQueryable.isExplicitPolymorphism() ) {
 					if ( isMappedClass ) {
 						return new String[] {className}; //NOTE EARLY EXIT
 					}
 				}
 				else {
 					if (isMappedClass) {
 						results.add(testClassName);
 					}
 					else {
 						final Class mappedClass = testQueryable.getMappedClass( EntityMode.POJO );
 						if ( mappedClass!=null && clazz.isAssignableFrom( mappedClass ) ) {
 							final boolean assignableSuperclass;
 							if ( testQueryable.isInherited() ) {
 								Class mappedSuperclass = getEntityPersister( testQueryable.getMappedSuperclass() ).getMappedClass( EntityMode.POJO);
 								assignableSuperclass = clazz.isAssignableFrom(mappedSuperclass);
 							}
 							else {
 								assignableSuperclass = false;
 							}
 							if ( !assignableSuperclass ) {
 								results.add( testClassName );
 							}
 						}
 					}
 				}
 			}
 		}
 		return (String[]) results.toArray( new String[ results.size() ] );
 	}
 
 	public String getImportedClassName(String className) {
 		String result = (String) imports.get(className);
 		if (result==null) {
 			try {
 				ReflectHelper.classForName(className);
 				return className;
 			}
 			catch (ClassNotFoundException cnfe) {
 				return null;
 			}
 		}
 		else {
 			return result;
 		}
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return classMetadata;
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return collectionMetadata;
 	}
 
 	public Type getReferencedPropertyType(String className, String propertyName)
 		throws MappingException {
 		return getEntityPersister(className).getPropertyType(propertyName);
 	}
 
 	public ConnectionProvider getConnectionProvider() {
 		return serviceRegistry.getService( JdbcServices.class ).getConnectionProvider();
 	}
 
 	/**
 	 * Closes the session factory, releasing all held resources.
 	 *
 	 * <ol>
 	 * <li>cleans up used cache regions and "stops" the cache provider.
 	 * <li>close the JDBC connection
 	 * <li>remove the JNDI binding
 	 * </ol>
 	 *
 	 * Note: Be aware that the sessionfactory instance still can
 	 * be a "heavy" object memory wise after close() has been called.  Thus
 	 * it is important to not keep referencing the instance to let the garbage
 	 * collector release the memory.
 	 */
 	public void close() throws HibernateException {
 
 		if ( isClosed ) {
 			log.trace( "already closed" );
 			return;
 		}
 
 		log.info("closing");
 
 		isClosed = true;
 
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			EntityPersister p = (EntityPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = (CollectionPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		if ( settings.isQueryCacheEnabled() )  {
 			queryCache.destroy();
 
 			iter = queryCaches.values().iterator();
 			while ( iter.hasNext() ) {
 				QueryCache cache = (QueryCache) iter.next();
 				cache.destroy();
 			}
 			updateTimestampsCache.destroy();
 		}
 
 		settings.getRegionFactory().stop();
 
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport.drop( false, true );
 		}
 
 		SessionFactoryObjectFactory.removeInstance(uuid, name, properties);
 
 		observer.sessionFactoryClosed( this );
 		eventListeners.destroyListeners();
 	}
 
 	private class CacheImpl implements Cache {
 		public boolean containsEntity(Class entityClass, Serializable identifier) {
 			return containsEntity( entityClass.getName(), identifier );
 		}
 
 		public boolean containsEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( identifier, p ) );
 		}
 
 		public void evictEntity(Class entityClass, Serializable identifier) {
 			evictEntity( entityClass.getName(), identifier );
 		}
 
 		public void evictEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
 				if ( log.isDebugEnabled() ) {
 					log.debug( 
 							"evicting second-level cache: " +
 									MessageHelper.infoString( p, identifier, SessionFactoryImpl.this )
 					);
 				}
 				p.getCacheAccessStrategy().evict( buildCacheKey( identifier, p ) );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable identifier, EntityPersister p) {
 			return new CacheKey(
 					identifier,
 					p.getIdentifierType(),
 					p.getRootEntityName(),
 					EntityMode.POJO,
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictEntityRegion(Class entityClass) {
 			evictEntityRegion( entityClass.getName() );
 		}
 
 		public void evictEntityRegion(String entityName) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
 				if ( log.isDebugEnabled() ) {
 					log.debug( "evicting second-level cache: " + p.getEntityName() );
 				}
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictEntityRegions() {
 			Iterator entityNames = entityPersisters.keySet().iterator();
 			while ( entityNames.hasNext() ) {
 				evictEntityRegion( ( String ) entityNames.next() );
 			}
 		}
 
 		public boolean containsCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( ownerIdentifier, p ) );
 		}
 
 		public void evictCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
 				if ( log.isDebugEnabled() ) {
 					log.debug(
 							"evicting second-level cache: " +
 									MessageHelper.collectionInfoString(p, ownerIdentifier, SessionFactoryImpl.this)
 					);
 				}
 				CacheKey cacheKey = buildCacheKey( ownerIdentifier, p );
 				p.getCacheAccessStrategy().evict( cacheKey );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable ownerIdentifier, CollectionPersister p) {
 			return new CacheKey(
 					ownerIdentifier,
 					p.getKeyType(),
 					p.getRole(),
 					EntityMode.POJO,
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictCollectionRegion(String role) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
 				if ( log.isDebugEnabled() ) {
 					log.debug( "evicting second-level cache: " + p.getRole() );
 				}
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictCollectionRegions() {
 			Iterator collectionRoles = collectionPersisters.keySet().iterator();
 			while ( collectionRoles.hasNext() ) {
 				evictCollectionRegion( ( String ) collectionRoles.next() );
 			}
 		}
 
 		public boolean containsQuery(String regionName) {
 			return queryCaches.get( regionName ) != null;
 		}
 
 		public void evictDefaultQueryRegion() {
 			if ( settings.isQueryCacheEnabled() ) {
 				queryCache.clear();
 			}
 		}
 
 		public void evictQueryRegion(String regionName) {
 			if ( regionName == null ) {
 				throw new NullPointerException(
 						"Region-name cannot be null (use Cache#evictDefaultQueryRegion to evict the default query cache)"
 				);
 			}
 			else {
 				if ( settings.isQueryCacheEnabled() ) {
 					QueryCache namedQueryCache = queryCaches.get( regionName );
 					if ( namedQueryCache != null ) {
 						namedQueryCache.clear();
 						// TODO : cleanup entries in queryCaches + allCacheRegions ?
 					}
 				}
 			}
 		}
 
 		public void evictQueryRegions() {
 			for ( QueryCache queryCache : queryCaches.values() ) {
 				queryCache.clear();
 				// TODO : cleanup entries in queryCaches + allCacheRegions ?
 			}
 		}
 	}
 
 	public Cache getCache() {
 		return cacheAccess;
 	}
 
 	public void evictEntity(String entityName, Serializable id) throws HibernateException {
 		getCache().evictEntity( entityName, id );
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getCache().evictEntityRegion( entityName );
 	}
 
 	public void evict(Class persistentClass, Serializable id) throws HibernateException {
 		getCache().evictEntity( persistentClass, id );
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getCache().evictEntityRegion( persistentClass );
 	}
 
 	public void evictCollection(String roleName, Serializable id) throws HibernateException {
 		getCache().evictCollection( roleName, id );
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getCache().evictCollectionRegion( roleName );
 	}
 
 	public void evictQueries() throws HibernateException {
 		if ( settings.isQueryCacheEnabled() ) {
 			queryCache.clear();
 		}
 	}
 
 	public void evictQueries(String regionName) throws HibernateException {
 		getCache().evictQueryRegion( regionName );
 	}
 
 	public UpdateTimestampsCache getUpdateTimestampsCache() {
 		return updateTimestampsCache;
 	}
 
 	public QueryCache getQueryCache() {
 		return queryCache;
 	}
 
 	public QueryCache getQueryCache(String regionName) throws HibernateException {
 		if ( regionName == null ) {
 			return getQueryCache();
 		}
 
 		if ( !settings.isQueryCacheEnabled() ) {
 			return null;
 		}
 
 		QueryCache currentQueryCache = queryCaches.get( regionName );
 		if ( currentQueryCache == null ) {
 			currentQueryCache = settings.getQueryCacheFactory().getQueryCache( regionName, updateTimestampsCache, settings, properties );
 			queryCaches.put( regionName, currentQueryCache );
 			allCacheRegions.put( currentQueryCache.getRegion().getName(), currentQueryCache.getRegion() );
 		}
 
 		return currentQueryCache;
 	}
 
 	public Region getSecondLevelCacheRegion(String regionName) {
 		return allCacheRegions.get( regionName );
 	}
 
 	public Map getAllSecondLevelCacheRegions() {
 		return new HashMap( allCacheRegions );
 	}
 
 	public boolean isClosed() {
 		return isClosed;
 	}
 
 	public Statistics getStatistics() {
 		return statistics;
 	}
 
 	public StatisticsImplementor getStatisticsImplementor() {
 		return (StatisticsImplementor) statistics;
 	}
 
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException {
 		FilterDefinition def = ( FilterDefinition ) filters.get( filterName );
 		if ( def == null ) {
 			throw new HibernateException( "No such filter configured [" + filterName + "]" );
 		}
 		return def;
 	}
 
 	public boolean containsFetchProfileDefinition(String name) {
 		return fetchProfiles.containsKey( name );
 	}
 
 	public Set getDefinedFilterNames() {
 		return filters.keySet();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {
 		return (IdentifierGenerator) identifierGenerators.get(rootEntityName);
 	}
 
-	private CurrentSessionContext buildCurrentSessionContext() {
-		String impl = properties.getProperty( Environment.CURRENT_SESSION_CONTEXT_CLASS );
-		// for backward-compatability
-		if ( impl == null && transactionManager != null ) {
-			impl = "jta";
+	private org.hibernate.engine.transaction.spi.TransactionFactory transactionFactory() {
+		return serviceRegistry.getService( org.hibernate.engine.transaction.spi.TransactionFactory.class );
+	}
+
+	private boolean canAccessTransactionManager() {
+		try {
+			return serviceRegistry.getService( JtaPlatform.class ).retrieveTransactionManager() != null;
 		}
+		catch (Exception e) {
+			return false;
+		}
+	}
 
+	private CurrentSessionContext buildCurrentSessionContext() {
+		String impl = properties.getProperty( Environment.CURRENT_SESSION_CONTEXT_CLASS );
+		// for backward-compatibility
 		if ( impl == null ) {
-			return null;
+			if ( canAccessTransactionManager() ) {
+				impl = "jta";
+			}
+			else {
+				return null;
+			}
 		}
-		else if ( "jta".equals( impl ) ) {
-			if ( settings.getTransactionFactory().areCallbacksLocalToHibernateTransactions() ) {
-				log.warn( "JTASessionContext being used with JDBCTransactionFactory; auto-flush will not operate correctly with getCurrentSession()" );
+
+		if ( "jta".equals( impl ) ) {
+			if ( ! transactionFactory().compatibleWithJtaSynchronization() ) {
+				log.warn( "JTASessionContext being used with JdbcTransactionFactory; auto-flush will not operate correctly with getCurrentSession()" );
 			}
 			return new JTASessionContext( this );
 		}
 		else if ( "thread".equals( impl ) ) {
 			return new ThreadLocalSessionContext( this );
 		}
 		else if ( "managed".equals( impl ) ) {
 			return new ManagedSessionContext( this );
 		}
 		else {
 			try {
 				Class implClass = ReflectHelper.classForName( impl );
 				return ( CurrentSessionContext ) implClass
 						.getConstructor( new Class[] { SessionFactoryImplementor.class } )
-						.newInstance( new Object[] { this } );
+						.newInstance( this );
 			}
 			catch( Throwable t ) {
 				log.error( "Unable to construct current session context [" + impl + "]", t );
 				return null;
 			}
 		}
 	}
 
-	public EventListeners getEventListeners()
-	{
+	public EventListeners getEventListeners() {
 		return eventListeners;
 	}
 
+	@Override
+	public ServiceRegistry getServiceRegistry() {
+		return serviceRegistry;
+	}
+
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	public SQLFunctionRegistry getSqlFunctionRegistry() {
 		return sqlFunctionRegistry;
 	}
 
 	public FetchProfile getFetchProfile(String name) {
 		return ( FetchProfile ) fetchProfiles.get( name );
 	}
 
 	public TypeHelper getTypeHelper() {
 		return typeHelper;
 	}
 
 	/**
 	 * Custom serialization hook used during Session serialization.
 	 *
 	 * @param oos The stream to which to write the factory
 	 * @throws IOException Indicates problems writing out the serial data stream
 	 */
 	void serialize(ObjectOutputStream oos) throws IOException {
 		oos.writeUTF( uuid );
 		oos.writeBoolean( name != null );
 		if ( name != null ) {
 			oos.writeUTF( name );
 		}
 	}
 
 	/**
 	 * Custom deserialization hook used during Session deserialization.
 	 *
 	 * @param ois The stream from which to "read" the factory
 	 * @return The deserialized factory
 	 * @throws IOException indicates problems reading back serial data stream
 	 * @throws ClassNotFoundException indicates problems reading back serial data stream
 	 */
 	static SessionFactoryImpl deserialize(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		String uuid = ois.readUTF();
 		boolean isNamed = ois.readBoolean();
 		String name = null;
 		if ( isNamed ) {
 			name = ois.readUTF();
 		}
 		Object result = SessionFactoryObjectFactory.getInstance( uuid );
 		if ( result == null ) {
 			log.trace( "could not locate session factory by uuid [" + uuid + "] during session deserialization; trying name" );
 			if ( isNamed ) {
 				result = SessionFactoryObjectFactory.getNamedInstance( name );
 			}
 			if ( result == null ) {
 				throw new InvalidObjectException( "could not resolve session factory during session deserialization [uuid=" + uuid + ", name=" + name + "]" );
 			}
 		}
 		return ( SessionFactoryImpl ) result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
index 25b99c52b2..32749877d2 100644
--- a/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
@@ -1,2361 +1,2366 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2005-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.impl;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Reader;
-import java.io.Serializable;
-import java.io.ByteArrayOutputStream;
-import java.io.ByteArrayInputStream;
-import java.sql.Blob;
-import java.sql.Clob;
-import java.sql.Connection;
-import java.sql.SQLException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import org.hibernate.CacheMode;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Criteria;
 import org.hibernate.EntityMode;
+import org.hibernate.EntityNameResolver;
 import org.hibernate.Filter;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.LobHelper;
 import org.hibernate.LockMode;
+import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ReplicationMode;
 import org.hibernate.SQLQuery;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.SessionException;
-import org.hibernate.SessionFactory;
 import org.hibernate.Transaction;
 import org.hibernate.TransientObjectException;
 import org.hibernate.TypeHelper;
-import org.hibernate.UnresolvableObjectException;
 import org.hibernate.UnknownProfileException;
-import org.hibernate.EntityNameResolver;
-import org.hibernate.LockOptions;
+import org.hibernate.UnresolvableObjectException;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.engine.ActionQueue;
 import org.hibernate.engine.CollectionEntry;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
+import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.NonFlushedChanges;
 import org.hibernate.engine.PersistenceContext;
 import org.hibernate.engine.QueryParameters;
+import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.StatefulPersistenceContext;
 import org.hibernate.engine.Status;
-import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
-import org.hibernate.engine.jdbc.internal.JDBCContextImpl;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
 import org.hibernate.engine.query.FilterQueryPlan;
 import org.hibernate.engine.query.HQLQueryPlan;
 import org.hibernate.engine.query.NativeSQLQueryPlan;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.engine.transaction.spi.TransactionObserver;
 import org.hibernate.event.AutoFlushEvent;
 import org.hibernate.event.AutoFlushEventListener;
 import org.hibernate.event.DeleteEvent;
 import org.hibernate.event.DeleteEventListener;
 import org.hibernate.event.DirtyCheckEvent;
 import org.hibernate.event.DirtyCheckEventListener;
 import org.hibernate.event.EventListeners;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.EvictEvent;
 import org.hibernate.event.EvictEventListener;
 import org.hibernate.event.FlushEvent;
 import org.hibernate.event.FlushEventListener;
 import org.hibernate.event.InitializeCollectionEvent;
 import org.hibernate.event.InitializeCollectionEventListener;
 import org.hibernate.event.LoadEvent;
 import org.hibernate.event.LoadEventListener;
 import org.hibernate.event.LoadEventListener.LoadType;
 import org.hibernate.event.LockEvent;
 import org.hibernate.event.LockEventListener;
 import org.hibernate.event.MergeEvent;
 import org.hibernate.event.MergeEventListener;
 import org.hibernate.event.PersistEvent;
 import org.hibernate.event.PersistEventListener;
 import org.hibernate.event.RefreshEvent;
 import org.hibernate.event.RefreshEventListener;
 import org.hibernate.event.ReplicateEvent;
 import org.hibernate.event.ReplicateEventListener;
 import org.hibernate.event.SaveOrUpdateEvent;
 import org.hibernate.event.SaveOrUpdateEventListener;
 import org.hibernate.jdbc.Work;
 import org.hibernate.loader.criteria.CriteriaLoader;
 import org.hibernate.loader.custom.CustomLoader;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.stat.SessionStatistics;
 import org.hibernate.stat.SessionStatisticsImpl;
-import org.hibernate.type.Type;
 import org.hibernate.type.SerializationException;
+import org.hibernate.type.Type;
 import org.hibernate.util.ArrayHelper;
 import org.hibernate.util.CollectionHelper;
 import org.hibernate.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Reader;
+import java.io.Serializable;
+import java.sql.Blob;
+import java.sql.Clob;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /**
- * Concrete implementation of a Session, and also the central, organizing component
- * of Hibernate's internal implementation. As such, this class exposes two interfaces;
- * Session itself, to the application, and SessionImplementor, to other components
- * of Hibernate. This class is not threadsafe.
+ * Concrete implementation of a Session.
+ * 
+ * Exposes two interfaces:<ul>
+ *     <li>{@link Session} to the application</li>
+ *     <li>{@link org.hibernate.engine.SessionImplementor} to other Hibernate components (SPI)</li>
+ * </ul>
+ *
+ * This class is not thread-safe.
  *
  * @author Gavin King
  */
-public final class SessionImpl extends AbstractSessionImpl 
-		implements EventSource, org.hibernate.classic.Session, JDBCContext.Context, LobCreationContext {
+public final class SessionImpl
+		extends AbstractSessionImpl
+		implements EventSource,
+				   org.hibernate.classic.Session,
+				   TransactionContext,
+				   LobCreationContext {
 
 	// todo : need to find a clean way to handle the "event source" role
-	// a seperate classs responsible for generating/dispatching events just duplicates most of the Session methods...
-	// passing around seperate reto interceptor, factory, actionQueue, and persistentContext is not manageable...
+	// a separate class responsible for generating/dispatching events just duplicates most of the Session methods...
+	// passing around separate interceptor, factory, actionQueue, and persistentContext is not manageable...
 
 	private static final Logger log = LoggerFactory.getLogger(SessionImpl.class);
 
-	private transient EntityMode entityMode = EntityMode.POJO;
-	private transient boolean autoClear; //for EJB3
-	
 	private transient long timestamp;
-	private transient FlushMode flushMode = FlushMode.AUTO;
-	private transient CacheMode cacheMode = CacheMode.NORMAL;
-
-	private transient Interceptor interceptor;
-
-	private transient int dontFlushFromFind = 0;
 
 	private transient ActionQueue actionQueue;
 	private transient StatefulPersistenceContext persistenceContext;
-	private transient JDBCContextImpl jdbcContext;
+	private transient TransactionCoordinatorImpl transactionCoordinator;
 	private transient EventListeners listeners;
+	private transient Interceptor interceptor;
+	private transient EntityNameResolver entityNameResolver = new CoordinatingEntityNameResolver();
 
+	private transient ConnectionReleaseMode connectionReleaseMode;
+	private transient FlushMode flushMode = FlushMode.AUTO;
+	private transient CacheMode cacheMode = CacheMode.NORMAL;
+	private transient EntityMode entityMode = EntityMode.POJO;
+	private transient boolean autoClear; //for EJB3
+
+	private transient int dontFlushFromFind = 0;
 	private transient boolean flushBeforeCompletionEnabled;
 	private transient boolean autoCloseSessionEnabled;
-	private transient ConnectionReleaseMode connectionReleaseMode;
 
 	private transient LoadQueryInfluencers loadQueryInfluencers;
 
 	private transient Session rootSession;
 	private transient Map childSessionsByEntityMode;
 
-	private transient EntityNameResolver entityNameResolver = new CoordinatingEntityNameResolver();
-
 	/**
 	 * Constructor used in building "child sessions".
 	 *
 	 * @param parent The parent session
 	 * @param entityMode
 	 */
 	private SessionImpl(SessionImpl parent, EntityMode entityMode) {
 		super( parent.factory );
 		this.rootSession = parent;
 		this.timestamp = parent.timestamp;
-		this.jdbcContext = parent.jdbcContext;
+		this.transactionCoordinator = parent.transactionCoordinator;
 		this.interceptor = parent.interceptor;
 		this.listeners = parent.listeners;
 		this.actionQueue = new ActionQueue( this );
 		this.entityMode = entityMode;
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = false;
 		this.autoCloseSessionEnabled = false;
 		this.connectionReleaseMode = null;
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().openSession();
 		}
 
 		log.debug( "opened session [" + entityMode + "]" );
 	}
 
 	/**
 	 * Constructor used for openSession(...) processing, as well as construction
 	 * of sessions for getCurrentSession().
 	 *
 	 * @param connection The user-supplied connection to use for this session.
 	 * @param factory The factory from which this session was obtained
 	 * @param autoclose NOT USED
 	 * @param timestamp The timestamp for this session
 	 * @param interceptor The interceptor to be applied to this session
 	 * @param entityMode The entity-mode for this session
 	 * @param flushBeforeCompletionEnabled Should we auto flush before completion of transaction
 	 * @param autoCloseSessionEnabled Should we auto close after completion of transaction
 	 * @param connectionReleaseMode The mode by which we should release JDBC connections.
 	 */
 	SessionImpl(
 			final Connection connection,
 			final SessionFactoryImpl factory,
 			final boolean autoclose,
 			final long timestamp,
 			final Interceptor interceptor,
 			final EntityMode entityMode,
 			final boolean flushBeforeCompletionEnabled,
 			final boolean autoCloseSessionEnabled,
 			final ConnectionReleaseMode connectionReleaseMode) {
 		super( factory );
 		this.rootSession = null;
 		this.timestamp = timestamp;
 		this.entityMode = entityMode;
 		this.interceptor = interceptor;
 		this.listeners = factory.getEventListeners();
 		this.actionQueue = new ActionQueue( this );
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 		this.connectionReleaseMode = connectionReleaseMode;
-		this.jdbcContext = new JDBCContextImpl( this, connection, interceptor );
+
+		this.transactionCoordinator = new TransactionCoordinatorImpl( connection, this );
+		this.transactionCoordinator.getJdbcCoordinator().getLogicalConnection().addObserver(
+				new ConnectionObserverStatsBridge( factory )
+		);
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().openSession();
 		}
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( "opened session at timestamp: " + timestamp );
 		}
 	}
 
 	public Session getSession(EntityMode entityMode) {
 		if ( this.entityMode == entityMode ) {
 			return this;
 		}
 
 		if ( rootSession != null ) {
 			return rootSession.getSession( entityMode );
 		}
 
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
 		SessionImpl rtn = null;
 		if ( childSessionsByEntityMode == null ) {
 			childSessionsByEntityMode = new HashMap();
 		}
 		else {
 			rtn = (SessionImpl) childSessionsByEntityMode.get( entityMode );
 		}
 
 		if ( rtn == null ) {
 			rtn = new SessionImpl( this, entityMode );
 			childSessionsByEntityMode.put( entityMode, rtn );
 		}
 
 		return rtn;
 	}
 
 	public void clear() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		persistenceContext.clear();
 		actionQueue.clear();
 	}
 
 	public long getTimestamp() {
 		checkTransactionSynchStatus();
 		return timestamp;
 	}
 
 	public Connection close() throws HibernateException {
 		log.trace( "closing session" );
 		if ( isClosed() ) {
 			throw new SessionException( "Session was already closed" );
 		}
 		
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().closeSession();
 		}
 
 		try {
 			try {
 				if ( childSessionsByEntityMode != null ) {
 					Iterator childSessions = childSessionsByEntityMode.values().iterator();
 					while ( childSessions.hasNext() ) {
 						final SessionImpl child = ( SessionImpl ) childSessions.next();
 						child.close();
 					}
 				}
 			}
 			catch( Throwable t ) {
 				// just ignore
 			}
 
 			if ( rootSession == null ) {
-				return jdbcContext.getConnectionManager().close();
+				return transactionCoordinator.close();
 			}
 			else {
 				return null;
 			}
 		}
 		finally {
 			setClosed();
 			cleanup();
 		}
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
-		checkTransactionSynchStatus();
 		return connectionReleaseMode;
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public boolean isOpen() {
 		checkTransactionSynchStatus();
 		return !isClosed();
 	}
 
 	public boolean isFlushModeNever() {
 		return FlushMode.isManualFlushMode( getFlushMode() );
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
 	public void managedFlush() {
 		if ( isClosed() ) {
 			log.trace( "skipping auto-flush due to session closed" );
 			return;
 		}
 		log.trace("automatically flushing session");
 		flush();
 		
 		if ( childSessionsByEntityMode != null ) {
 			Iterator iter = childSessionsByEntityMode.values().iterator();
 			while ( iter.hasNext() ) {
 				( (Session) iter.next() ).flush();
 			}
 		}
 	}
 
 	/**
 	 * Return changes to this session and its child sessions that have not been flushed yet.
 	 * <p/>
 	 * @return The non-flushed changes.
 	 */
 	public NonFlushedChanges getNonFlushedChanges() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		NonFlushedChanges nonFlushedChanges = new NonFlushedChangesImpl( this );
 		if ( childSessionsByEntityMode != null ) {
 			Iterator it = childSessionsByEntityMode.values().iterator();
 			while ( it.hasNext() ) {
 				nonFlushedChanges.extractFromSession( ( EventSource ) it.next() );
 			}
 		}
 		return nonFlushedChanges;
 	}
 
 	/**
 	 * Apply non-flushed changes from a different session to this session. It is assumed
 	 * that this SessionImpl is "clean" (e.g., has no non-flushed changes, no cached entities,
 	 * no cached collections, no queued actions). The specified NonFlushedChanges object cannot
 	 * be bound to any session.
 	 * <p/>
 	 * @param nonFlushedChanges the non-flushed changes
 	 */
 	public void applyNonFlushedChanges(NonFlushedChanges nonFlushedChanges) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		replacePersistenceContext( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getPersistenceContext( entityMode) );
 		replaceActionQueue( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getActionQueue( entityMode ) );
 		if ( childSessionsByEntityMode != null ) {
 			for ( Iterator it = childSessionsByEntityMode.values().iterator(); it.hasNext(); ) {
 				( ( SessionImpl ) it.next() ).applyNonFlushedChanges( nonFlushedChanges );
 			}
 		}
 	}
 
 	private void replacePersistenceContext(StatefulPersistenceContext persistenceContextNew) {
 		if ( persistenceContextNew.getSession() != null ) {
 			throw new IllegalStateException( "new persistence context is already connected to a session " );
 		}
 		persistenceContext.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializePersistenceContext( persistenceContextNew ) ) );
 			this.persistenceContext = StatefulPersistenceContext.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the persistence context",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the persistence context", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializePersistenceContext(StatefulPersistenceContext pc) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			( ( StatefulPersistenceContext ) pc ).serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize persistence context", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	private void replaceActionQueue(ActionQueue actionQueueNew) {
 		if ( actionQueue.hasAnyQueuedActions() ) {
 			throw new IllegalStateException( "cannot replace an ActionQueue with queued actions " );
 		}
 		actionQueue.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializeActionQueue( actionQueueNew ) ) );
 			actionQueue = ActionQueue.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the action queue",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the action queue", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializeActionQueue(ActionQueue actionQueue) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			actionQueue.serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize action queue", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	public boolean shouldAutoClose() {
 		return isAutoCloseSessionEnabled() && !isClosed();
 	}
 
 	public void managedClose() {
 		log.trace( "automatically closing session" );
 		close();
 	}
 
 	public Connection connection() throws HibernateException {
 		errorIfClosed();
-		return jdbcContext.borrowConnection();
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getDistinctConnectionProxy();
 	}
 
 	public boolean isConnected() {
 		checkTransactionSynchStatus();
-		return !isClosed() && jdbcContext.getConnectionManager().isCurrentlyConnected();
+		return !isClosed() && transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isOpen();
 	}
-	
+
 	public boolean isTransactionInProgress() {
 		checkTransactionSynchStatus();
-		return !isClosed() && jdbcContext.isTransactionInProgress();
+		return !isClosed() && transactionCoordinator.isTransactionInProgress();
 	}
 
 	public Connection disconnect() throws HibernateException {
 		errorIfClosed();
 		log.debug( "disconnecting session" );
-		return jdbcContext.getConnectionManager().manualDisconnect();
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualDisconnect();
 	}
 
 	public void reconnect() throws HibernateException {
 		errorIfClosed();
 		log.debug( "reconnecting session" );
 		checkTransactionSynchStatus();
-		jdbcContext.getConnectionManager().manualReconnect();
+		transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualReconnect( null );
 	}
 
 	public void reconnect(Connection conn) throws HibernateException {
 		errorIfClosed();
 		log.debug( "reconnecting session" );
 		checkTransactionSynchStatus();
-		jdbcContext.getConnectionManager().manualReconnect( conn );
+		transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualReconnect( conn );
 	}
 
-	public void beforeTransactionCompletion(Transaction tx) {
-		log.trace( "before transaction completion" );
-		actionQueue.beforeTransactionCompletion();
-		if ( rootSession == null ) {
-			try {
-				interceptor.beforeTransactionCompletion(tx);
-			}
-			catch (Throwable t) {
-				log.error("exception in interceptor beforeTransactionCompletion()", t);
-			}
-		}
-	}
-	
 	public void setAutoClear(boolean enabled) {
 		errorIfClosed();
 		autoClear = enabled;
 	}
-	
+
 	/**
-	 * Check if there is a Hibernate or JTA transaction in progress and, 
-	 * if there is not, flush if necessary, make sure the connection has 
-	 * been committed (if it is not in autocommit mode) and run the after 
+	 * Check if there is a Hibernate or JTA transaction in progress and,
+	 * if there is not, flush if necessary, make sure the connection has
+	 * been committed (if it is not in autocommit mode) and run the after
 	 * completion processing
 	 */
 	public void afterOperation(boolean success) {
-		if ( !jdbcContext.isTransactionInProgress() ) {
-			jdbcContext.afterNontransactionalQuery( success );
+		if ( ! transactionCoordinator.isTransactionInProgress() ) {
+			transactionCoordinator.afterNonTransactionalQuery( success );
+		}
+	}
+
+	@Override
+	public void afterTransactionBegin(TransactionImplementor hibernateTransaction) {
+		errorIfClosed();
+		interceptor.afterTransactionBegin( hibernateTransaction );
+	}
+
+	@Override
+	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction) {
+		log.trace( "before transaction completion" );
+		actionQueue.beforeTransactionCompletion();
+		if ( rootSession == null ) {
+			try {
+				interceptor.beforeTransactionCompletion( hibernateTransaction );
+			}
+			catch (Throwable t) {
+				log.error( "exception in interceptor beforeTransactionCompletion()", t );
+			}
 		}
 	}
 
-	public void afterTransactionCompletion(boolean success, Transaction tx) {
+	@Override
+	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful) {
 		log.trace( "after transaction completion" );
 		persistenceContext.afterTransactionCompletion();
-		actionQueue.afterTransactionCompletion(success);
-		if ( rootSession == null && tx != null ) {
+		actionQueue.afterTransactionCompletion( successful );
+		if ( rootSession == null && hibernateTransaction != null ) {
 			try {
-				interceptor.afterTransactionCompletion(tx);
+				interceptor.afterTransactionCompletion( hibernateTransaction );
 			}
 			catch (Throwable t) {
 				log.error("exception in interceptor afterTransactionCompletion()", t);
 			}
 		}
 		if ( autoClear ) {
 			clear();
 		}
 	}
 
 	/**
 	 * clear all the internal collections, just 
 	 * to help the garbage collector, does not
 	 * clear anything that is needed during the
 	 * afterTransactionCompletion() phase
 	 */
 	private void cleanup() {
 		persistenceContext.clear();
 	}
 
 	public LockMode getCurrentLockMode(Object object) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object == null ) {
 			throw new NullPointerException( "null object passed to getCurrentLockMode()" );
 		}
 		if ( object instanceof HibernateProxy ) {
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation(this);
 			if ( object == null ) {
 				return LockMode.NONE;
 			}
 		}
 		EntityEntry e = persistenceContext.getEntry(object);
 		if ( e == null ) {
 			throw new TransientObjectException( "Given object not associated with the session" );
 		}
 		if ( e.getStatus() != Status.MANAGED ) {
 			throw new ObjectDeletedException( 
 					"The given object was deleted", 
 					e.getId(), 
 					e.getPersister().getEntityName() 
 				);
 		}
 		return e.getLockMode();
 	}
 
 	public Object getEntityUsingInterceptor(EntityKey key) throws HibernateException {
 		errorIfClosed();
 		// todo : should this get moved to PersistentContext?
 		// logically, is PersistentContext the "thing" to which an interceptor gets attached?
 		final Object result = persistenceContext.getEntity(key);
 		if ( result == null ) {
 			final Object newObject = interceptor.getEntity( key.getEntityName(), key.getIdentifier() );
 			if ( newObject != null ) {
 				lock( newObject, LockMode.NONE );
 			}
 			return newObject;
 		}
 		else {
 			return result;
 		}
 	}
 
 
 	// saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void saveOrUpdate(Object object) throws HibernateException {
-		saveOrUpdate(null, object);
+		saveOrUpdate( null, object );
 	}
 
 	public void saveOrUpdate(String entityName, Object obj) throws HibernateException {
-		fireSaveOrUpdate( new SaveOrUpdateEvent(entityName, obj, this) );
+		fireSaveOrUpdate( new SaveOrUpdateEvent( entityName, obj, this ) );
 	}
 
 	private void fireSaveOrUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] saveOrUpdateEventListener = listeners.getSaveOrUpdateEventListeners();
 		for ( int i = 0; i < saveOrUpdateEventListener.length; i++ ) {
 			saveOrUpdateEventListener[i].onSaveOrUpdate(event);
 		}
 	}
 
 
 	// save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void save(Object obj, Serializable id) throws HibernateException {
 		save(null, obj, id);
 	}
 
 	public Serializable save(Object obj) throws HibernateException {
-		return save(null, obj);
+		return save( null, obj );
 	}
 
 	public Serializable save(String entityName, Object object) throws HibernateException {
-		return fireSave( new SaveOrUpdateEvent(entityName, object, this) );
+		return fireSave( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
 	public void save(String entityName, Object object, Serializable id) throws HibernateException {
-		fireSave( new SaveOrUpdateEvent(entityName, object, id, this) );
+		fireSave( new SaveOrUpdateEvent( entityName, object, id, this ) );
 	}
 
 	private Serializable fireSave(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] saveEventListener = listeners.getSaveEventListeners();
 		for ( int i = 0; i < saveEventListener.length; i++ ) {
 			saveEventListener[i].onSaveOrUpdate(event);
 		}
 		return event.getResultId();
 	}
 
 
 	// update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void update(Object obj) throws HibernateException {
 		update(null, obj);
 	}
 
 	public void update(Object obj, Serializable id) throws HibernateException {
-		update(null, obj, id);
+		update( null, obj, id );
 	}
 
 	public void update(String entityName, Object object) throws HibernateException {
-		fireUpdate( new SaveOrUpdateEvent(entityName, object, this) );
+		fireUpdate( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
 	public void update(String entityName, Object object, Serializable id) throws HibernateException {
-		fireUpdate(new SaveOrUpdateEvent(entityName, object, id, this));
+		fireUpdate( new SaveOrUpdateEvent( entityName, object, id, this ) );
 	}
 
 	private void fireUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] updateEventListener = listeners.getUpdateEventListeners();
 		for ( int i = 0; i < updateEventListener.length; i++ ) {
 			updateEventListener[i].onSaveOrUpdate(event);
 		}
 	}
 
 
 	// lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void lock(String entityName, Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(entityName, object, lockMode, this) );
 	}
 
 	public LockRequest buildLockRequest(LockOptions lockOptions) {
 		return new LockRequestImpl(lockOptions);
 	}
 
 	public void lock(Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(object, lockMode, this) );
 	}
 
 	private void fireLock(String entityName, Object object, LockOptions options) {
 		fireLock( new LockEvent( entityName, object, options, this) );
 	}
 
 	private void fireLock( Object object, LockOptions options) {
-		fireLock( new LockEvent( object, options, this) );
+		fireLock( new LockEvent( object, options, this ) );
 	}
 
 	private void fireLock(LockEvent lockEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		LockEventListener[] lockEventListener = listeners.getLockEventListeners();
 		for ( int i = 0; i < lockEventListener.length; i++ ) {
 			lockEventListener[i].onLock( lockEvent );
 		}
 	}
 
 
 	// persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persist(String entityName, Object object) throws HibernateException {
-		firePersist( new PersistEvent(entityName, object, this) );
+		firePersist( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persist(Object object) throws HibernateException {
-		persist(null, object);
+		persist( null, object );
 	}
 
 	public void persist(String entityName, Object object, Map copiedAlready)
 	throws HibernateException {
-		firePersist( copiedAlready, new PersistEvent(entityName, object, this) );
+		firePersist( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersist(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] persistEventListener = listeners.getPersistEventListeners();
 		for ( int i = 0; i < persistEventListener.length; i++ ) {
 			persistEventListener[i].onPersist(event, copiedAlready);
 		}
 	}
 
 	private void firePersist(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] createEventListener = listeners.getPersistEventListeners();
 		for ( int i = 0; i < createEventListener.length; i++ ) {
 			createEventListener[i].onPersist(event);
 		}
 	}
 
 
 	// persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persistOnFlush(String entityName, Object object)
 			throws HibernateException {
-		firePersistOnFlush( new PersistEvent(entityName, object, this) );
+		firePersistOnFlush( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persistOnFlush(Object object) throws HibernateException {
-		persist(null, object);
+		persist( null, object );
 	}
 
 	public void persistOnFlush(String entityName, Object object, Map copiedAlready)
 			throws HibernateException {
-		firePersistOnFlush( copiedAlready, new PersistEvent(entityName, object, this) );
+		firePersistOnFlush( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersistOnFlush(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] persistEventListener = listeners.getPersistOnFlushEventListeners();
 		for ( int i = 0; i < persistEventListener.length; i++ ) {
 			persistEventListener[i].onPersist(event, copiedAlready);
 		}
 	}
 
 	private void firePersistOnFlush(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] createEventListener = listeners.getPersistOnFlushEventListeners();
 		for ( int i = 0; i < createEventListener.length; i++ ) {
 			createEventListener[i].onPersist(event);
 		}
 	}
 
 
 	// merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object merge(String entityName, Object object) throws HibernateException {
-		return fireMerge( new MergeEvent(entityName, object, this) );
+		return fireMerge( new MergeEvent( entityName, object, this ) );
 	}
 
 	public Object merge(Object object) throws HibernateException {
-		return merge(null, object);
+		return merge( null, object );
 	}
 
 	public void merge(String entityName, Object object, Map copiedAlready) throws HibernateException {
-		fireMerge( copiedAlready, new MergeEvent(entityName, object, this) );
+		fireMerge( copiedAlready, new MergeEvent( entityName, object, this ) );
 	}
 
 	private Object fireMerge(MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] mergeEventListener = listeners.getMergeEventListeners();
 		for ( int i = 0; i < mergeEventListener.length; i++ ) {
 			mergeEventListener[i].onMerge(event);
 		}
 		return event.getResult();
 	}
 
 	private void fireMerge(Map copiedAlready, MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] mergeEventListener = listeners.getMergeEventListeners();
 		for ( int i = 0; i < mergeEventListener.length; i++ ) {
 			mergeEventListener[i].onMerge(event, copiedAlready);
 		}
 	}
 
 
 	// saveOrUpdateCopy() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object saveOrUpdateCopy(String entityName, Object object)
 			throws HibernateException {
-		return fireSaveOrUpdateCopy( new MergeEvent(entityName, object, this) );
+		return fireSaveOrUpdateCopy( new MergeEvent( entityName, object, this ) );
 	}
 
 	public Object saveOrUpdateCopy(Object object) throws HibernateException {
 		return saveOrUpdateCopy( null, object );
 	}
 
 	public Object saveOrUpdateCopy(String entityName, Object object, Serializable id)
 			throws HibernateException {
-		return fireSaveOrUpdateCopy( new MergeEvent(entityName, object, id, this) );
+		return fireSaveOrUpdateCopy( new MergeEvent( entityName, object, id, this ) );
 	}
 
 	public Object saveOrUpdateCopy(Object object, Serializable id)
 			throws HibernateException {
 		return saveOrUpdateCopy( null, object, id );
 	}
 
 	public void saveOrUpdateCopy(String entityName, Object object, Map copiedAlready)
 			throws HibernateException {
 		fireSaveOrUpdateCopy( copiedAlready, new MergeEvent( entityName, object, this ) );
 	}
 
 	private void fireSaveOrUpdateCopy(Map copiedAlready, MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] saveOrUpdateCopyEventListener = listeners.getSaveOrUpdateCopyEventListeners();
 		for ( int i = 0; i < saveOrUpdateCopyEventListener.length; i++ ) {
 			saveOrUpdateCopyEventListener[i].onMerge(event, copiedAlready);
 		}
 	}
 
 	private Object fireSaveOrUpdateCopy(MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] saveOrUpdateCopyEventListener = listeners.getSaveOrUpdateCopyEventListeners();
 		for ( int i = 0; i < saveOrUpdateCopyEventListener.length; i++ ) {
 			saveOrUpdateCopyEventListener[i].onMerge(event);
 		}
 		return event.getResult();
 	}
 
 
 	// delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(Object object) throws HibernateException {
 		fireDelete( new DeleteEvent(object, this) );
 	}
 
 	/**
 	 * Delete a persistent object (by explicit entity name)
 	 */
 	public void delete(String entityName, Object object) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, this ) );
 	}
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(String entityName, Object object, boolean isCascadeDeleteEnabled, Set transientEntities) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, isCascadeDeleteEnabled, this ), transientEntities );
 	}
 
 	private void fireDelete(DeleteEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		DeleteEventListener[] deleteEventListener = listeners.getDeleteEventListeners();
 		for ( int i = 0; i < deleteEventListener.length; i++ ) {
 			deleteEventListener[i].onDelete( event );
 		}
 	}
 
 	private void fireDelete(DeleteEvent event, Set transientEntities) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		DeleteEventListener[] deleteEventListener = listeners.getDeleteEventListeners();
 		for ( int i = 0; i < deleteEventListener.length; i++ ) {
 			deleteEventListener[i].onDelete( event, transientEntities );
 		}
 	}
 
 
 	// load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void load(Object object, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, object, this);
 		fireLoad( event, LoadEventListener.RELOAD );
 	}
 
 	public Object load(Class entityClass, Serializable id) throws HibernateException {
 		return load( entityClass.getName(), id );
 	}
 
 	public Object load(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad( event, LoadEventListener.LOAD );
 			if ( event.getResult() == null ) {
 				getFactory().getEntityNotFoundDelegate().handleEntityNotFound( entityName, id );
 			}
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	public Object get(Class entityClass, Serializable id) throws HibernateException {
 		return get( entityClass.getName(), id );
 	}
 
 	public Object get(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad(event, LoadEventListener.GET);
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	/**
 	 * Load the data for the object with the specified id into a newly created object.
 	 * This is only called when lazily initializing a proxy.
 	 * Do NOT return a proxy.
 	 */
 	public Object immediateLoad(String entityName, Serializable id) throws HibernateException {
 		if ( log.isDebugEnabled() ) {
 			EntityPersister persister = getFactory().getEntityPersister(entityName);
 			log.debug( "initializing proxy: " + MessageHelper.infoString( persister, id, getFactory() ) );
 		}
 		
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, LoadEventListener.IMMEDIATE_LOAD);
 		return event.getResult();
 	}
 
 	public Object internalLoad(String entityName, Serializable id, boolean eager, boolean nullable) throws HibernateException {
 		// todo : remove
 		LoadEventListener.LoadType type = nullable
 				? LoadEventListener.INTERNAL_LOAD_NULLABLE
 				: eager
 						? LoadEventListener.INTERNAL_LOAD_EAGER
 						: LoadEventListener.INTERNAL_LOAD_LAZY;
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, type);
 		if ( !nullable ) {
 			UnresolvableObjectException.throwIfNull( event.getResult(), id, entityName );
 		}
 		return event.getResult();
 	}
 
 	public Object load(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return load( entityClass.getName(), id, lockMode );
 	}
 
 	public Object load(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
-		return load( entityClass.getName(), id, lockOptions);
+		return load( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object load(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object load(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object get(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return get( entityClass.getName(), id, lockMode );
 	}
 
 	public Object get(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
-		return get( entityClass.getName(), id, lockOptions);
+		return get( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object get(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 	   	fireLoad(event, LoadEventListener.GET);
 		return event.getResult();
 	}
 
 	public Object get(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
-	   	fireLoad(event, LoadEventListener.GET);
+	   	fireLoad( event, LoadEventListener.GET );
 		return event.getResult();
 	}
 	
 	private void fireLoad(LoadEvent event, LoadType loadType) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		LoadEventListener[] loadEventListener = listeners.getLoadEventListeners();
 		for ( int i = 0; i < loadEventListener.length; i++ ) {
 			loadEventListener[i].onLoad(event, loadType);
 		}
 	}
 
 
 	// refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void refresh(Object object) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, this) );
 	}
 
 	public void refresh(Object object, LockMode lockMode) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockMode, this) );
 	}
 
 	public void refresh(Object object, LockOptions lockOptions) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockOptions, this) );
 	}
 
 	public void refresh(Object object, Map refreshedAlready) throws HibernateException {
-		fireRefresh( refreshedAlready, new RefreshEvent(object, this) );
+		fireRefresh( refreshedAlready, new RefreshEvent( object, this ) );
 	}
 
 	private void fireRefresh(RefreshEvent refreshEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		RefreshEventListener[] refreshEventListener = listeners.getRefreshEventListeners();
 		for ( int i = 0; i < refreshEventListener.length; i++ ) {
 			refreshEventListener[i].onRefresh( refreshEvent );
 		}
 	}
 
 	private void fireRefresh(Map refreshedAlready, RefreshEvent refreshEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		RefreshEventListener[] refreshEventListener = listeners.getRefreshEventListeners();
 		for ( int i = 0; i < refreshEventListener.length; i++ ) {
 			refreshEventListener[i].onRefresh( refreshEvent, refreshedAlready );
 		}
 	}
 
 
 	// replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void replicate(Object obj, ReplicationMode replicationMode) throws HibernateException {
 		fireReplicate( new ReplicateEvent(obj, replicationMode, this) );
 	}
 
 	public void replicate(String entityName, Object obj, ReplicationMode replicationMode)
 	throws HibernateException {
-		fireReplicate( new ReplicateEvent(entityName, obj, replicationMode, this) );
+		fireReplicate( new ReplicateEvent( entityName, obj, replicationMode, this ) );
 	}
 
 	private void fireReplicate(ReplicateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		ReplicateEventListener[] replicateEventListener = listeners.getReplicateEventListeners();
 		for ( int i = 0; i < replicateEventListener.length; i++ ) {
 			replicateEventListener[i].onReplicate(event);
 		}
 	}
 
 
 	// evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * remove any hard references to the entity that are held by the infrastructure
 	 * (references held by application or other persistant instances are okay)
 	 */
 	public void evict(Object object) throws HibernateException {
-		fireEvict( new EvictEvent(object, this) );
+		fireEvict( new EvictEvent( object, this ) );
 	}
 
 	private void fireEvict(EvictEvent evictEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		EvictEventListener[] evictEventListener = listeners.getEvictEventListeners();
 		for ( int i = 0; i < evictEventListener.length; i++ ) {
 			evictEventListener[i].onEvict( evictEvent );
 		}
 	}
 
 	/**
 	 * detect in-memory changes, determine if the changes are to tables
 	 * named in the query and, if so, complete execution the flush
 	 */
 	protected boolean autoFlushIfRequired(Set querySpaces) throws HibernateException {
 		errorIfClosed();
 		if ( ! isTransactionInProgress() ) {
 			// do not auto-flush while outside a transaction
 			return false;
 		}
 		AutoFlushEvent event = new AutoFlushEvent(querySpaces, this);
 		AutoFlushEventListener[] autoFlushEventListener = listeners.getAutoFlushEventListeners();
 		for ( int i = 0; i < autoFlushEventListener.length; i++ ) {
 			autoFlushEventListener[i].onAutoFlush(event);
 		}
 		return event.isFlushRequired();
 	}
 
 	public boolean isDirty() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		log.debug("checking session dirtiness");
 		if ( actionQueue.areInsertionsOrDeletionsQueued() ) {
 			log.debug("session dirty (scheduled updates and insertions)");
 			return true;
 		}
 		else {
 			DirtyCheckEvent event = new DirtyCheckEvent(this);
 			DirtyCheckEventListener[] dirtyCheckEventListener = listeners.getDirtyCheckEventListeners();
 			for ( int i = 0; i < dirtyCheckEventListener.length; i++ ) {
 				dirtyCheckEventListener[i].onDirtyCheck(event);
 			}
 			return event.isDirty();
 		}
 	}
 
 	public void flush() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( persistenceContext.getCascadeLevel() > 0 ) {
 			throw new HibernateException("Flush during cascade is dangerous");
 		}
 		FlushEventListener[] flushEventListener = listeners.getFlushEventListeners();
 		for ( int i = 0; i < flushEventListener.length; i++ ) {
 			flushEventListener[i].onFlush( new FlushEvent(this) );
 		}
 	}
 
 	public void forceFlush(EntityEntry entityEntry) throws HibernateException {
 		errorIfClosed();
 		if ( log.isDebugEnabled() ) {
 			log.debug(
 				"flushing to force deletion of re-saved object: " +
 				MessageHelper.infoString( entityEntry.getPersister(), entityEntry.getId(), getFactory() )
 			);
 		}
 
 		if ( persistenceContext.getCascadeLevel() > 0 ) {
 			throw new ObjectDeletedException(
 				"deleted object would be re-saved by cascade (remove deleted object from associations)",
 				entityEntry.getId(),
 				entityEntry.getPersister().getEntityName()
 			);
 		}
 
 		flush();
 	}
 
 
 	/**
 	 * Retrieve a list of persistent objects using a hibernate query
 	 */
 	public List find(String query) throws HibernateException {
 		return list( query, new QueryParameters() );
 	}
 
 	public List find(String query, Object value, Type type) throws HibernateException {
 		return list( query, new QueryParameters(type, value) );
 	}
 
 	public List find(String query, Object[] values, Type[] types) throws HibernateException {
 		return list( query, new QueryParameters(types, values) );
 	}
 
 	public List list(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		List results = CollectionHelper.EMPTY_LIST;
 		boolean success = false;
 
 		dontFlushFromFind++;   //stops flush being called multiple times if this method is recursively called
 		try {
 			results = plan.performList( queryParameters, this );
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 		return results;
 	}
 
 	public int executeUpdate(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		boolean success = false;
 		int result = 0;
 		try {
 			result = plan.performExecuteUpdate( queryParameters, this );
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		return result;
 	}
 
     public int executeNativeUpdate(NativeSQLQuerySpecification nativeQuerySpecification,
             QueryParameters queryParameters) throws HibernateException {
         errorIfClosed();
         checkTransactionSynchStatus();
         queryParameters.validateParameters();
-        NativeSQLQueryPlan plan = getNativeSQLQueryPlan(nativeQuerySpecification);
+        NativeSQLQueryPlan plan = getNativeSQLQueryPlan( nativeQuerySpecification );
 
         
         autoFlushIfRequired( plan.getCustomQuery().getQuerySpaces() );
         
         boolean success = false;
         int result = 0;
         try {
             result = plan.performExecuteUpdate(queryParameters, this);
             success = true;
         } finally {
             afterOperation(success);
         }
         return result;
     }
 
 	public Iterator iterate(String query) throws HibernateException {
 		return iterate( query, new QueryParameters() );
 	}
 
 	public Iterator iterate(String query, Object value, Type type) throws HibernateException {
 		return iterate( query, new QueryParameters(type, value) );
 	}
 
 	public Iterator iterate(String query, Object[] values, Type[] types) throws HibernateException {
 		return iterate( query, new QueryParameters(types, values) );
 	}
 
 	public Iterator iterate(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, true );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		dontFlushFromFind++; //stops flush being called multiple times if this method is recursively called
 		try {
 			return plan.performIterate( queryParameters, this );
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	public ScrollableResults scroll(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 		dontFlushFromFind++;
 		try {
 			return plan.performScroll( queryParameters, this );
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	public int delete(String query) throws HibernateException {
 		return delete( query, ArrayHelper.EMPTY_OBJECT_ARRAY, ArrayHelper.EMPTY_TYPE_ARRAY );
 	}
 
 	public int delete(String query, Object value, Type type) throws HibernateException {
 		return delete( query, new Object[]{value}, new Type[]{type} );
 	}
 
 	public int delete(String query, Object[] values, Type[] types) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( query == null ) {
 			throw new IllegalArgumentException("attempt to doAfterTransactionCompletion delete-by-query with null query");
 		}
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "delete: " + query );
 			if ( values.length != 0 ) {
 				log.trace( "parameters: " + StringHelper.toString( values ) );
 			}
 		}
 
 		List list = find( query, values, types );
 		int deletionCount = list.size();
 		for ( int i = 0; i < deletionCount; i++ ) {
 			delete( list.get( i ) );
 		}
 
 		return deletionCount;
 	}
 
 	public Query createFilter(Object collection, String queryString) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		CollectionFilterImpl filter = new CollectionFilterImpl(
 				queryString,
 		        collection,
 		        this,
 		        getFilterQueryPlan( collection, queryString, null, false ).getParameterMetadata()
 		);
 		filter.setComment( queryString );
 		return filter;
 	}
 	
 	public Query getNamedQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
-		return super.getNamedQuery(queryName);
+		return super.getNamedQuery( queryName );
 	}
 
 	public Object instantiate(String entityName, Serializable id) throws HibernateException {
-		return instantiate( factory.getEntityPersister(entityName), id );
+		return instantiate( factory.getEntityPersister( entityName ), id );
 	}
 
 	/**
 	 * give the interceptor an opportunity to override the default instantiation
 	 */
 	public Object instantiate(EntityPersister persister, Serializable id) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		Object result = interceptor.instantiate( persister.getEntityName(), entityMode, id );
 		if ( result == null ) {
 			result = persister.instantiate( id, this );
 		}
 		return result;
 	}
 
 	public EntityMode getEntityMode() {
 		checkTransactionSynchStatus();
 		return entityMode;
 	}
 
 	public void setFlushMode(FlushMode flushMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( log.isTraceEnabled() ) {
 			log.trace("setting flush mode to: " + flushMode);
 		}
 		this.flushMode = flushMode;
 	}
 	
 	public FlushMode getFlushMode() {
 		checkTransactionSynchStatus();
 		return flushMode;
 	}
 
 	public CacheMode getCacheMode() {
 		checkTransactionSynchStatus();
 		return cacheMode;
 	}
 	
 	public void setCacheMode(CacheMode cacheMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( log.isTraceEnabled() ) {
 			log.trace("setting cache mode to: " + cacheMode);
 		}
 		this.cacheMode= cacheMode; 
 	}
 
 	public Transaction getTransaction() throws HibernateException {
 		errorIfClosed();
-		return jdbcContext.getTransaction();
+		return transactionCoordinator.getTransaction();
 	}
 	
 	public Transaction beginTransaction() throws HibernateException {
 		errorIfClosed();
 		if ( rootSession != null ) {
 			// todo : should seriously consider not allowing a txn to begin from a child session
 			//      can always route the request to the root session...
 			log.warn( "Transaction started on non-root session" );
 		}
 		Transaction result = getTransaction();
 		result.begin();
 		return result;
 	}
-	
-	public void afterTransactionBegin(Transaction tx) {
-		errorIfClosed();
-		interceptor.afterTransactionBegin(tx);
-	}
 
 	public EntityPersister getEntityPersister(final String entityName, final Object object) {
 		errorIfClosed();
 		if (entityName==null) {
 			return factory.getEntityPersister( guessEntityName( object ) );
 		}
 		else {
 			// try block is a hack around fact that currently tuplizers are not
 			// given the opportunity to resolve a subclass entity name.  this
 			// allows the (we assume custom) interceptor the ability to
 			// influence this decision if we were not able to based on the
 			// given entityName
 			try {
 				return factory.getEntityPersister( entityName )
 						.getSubclassEntityPersister( object, getFactory(), entityMode );
 			}
 			catch( HibernateException e ) {
 				try {
 					return getEntityPersister( null, object );
 				}
 				catch( HibernateException e2 ) {
 					throw e;
 				}
 			}
 		}
 	}
 
 	// not for internal use:
 	public Serializable getIdentifier(Object object) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object instanceof HibernateProxy ) {
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			if ( li.getSession() != this ) {
 				throw new TransientObjectException( "The proxy was not associated with this session" );
 			}
 			return li.getIdentifier();
 		}
 		else {
 			EntityEntry entry = persistenceContext.getEntry(object);
 			if ( entry == null ) {
 				throw new TransientObjectException( "The instance was not associated with this session" );
 			}
 			return entry.getId();
 		}
 	}
 
 	/**
 	 * Get the id value for an object that is actually associated with the session. This
 	 * is a bit stricter than getEntityIdentifierIfNotUnsaved().
 	 */
 	public Serializable getContextEntityIdentifier(Object object) {
 		errorIfClosed();
 		if ( object instanceof HibernateProxy ) {
-			return getProxyIdentifier(object);
+			return getProxyIdentifier( object );
 		}
 		else {
 			EntityEntry entry = persistenceContext.getEntry(object);
 			return entry != null ? entry.getId() : null;
 		}
 	}
 	
 	private Serializable getProxyIdentifier(Object proxy) {
 		return ( (HibernateProxy) proxy ).getHibernateLazyInitializer().getIdentifier();
 	}
 
 	public Collection filter(Object collection, String filter) throws HibernateException {
 		return listFilter( collection, filter, new QueryParameters( new Type[1], new Object[1] ) );
 	}
 
 	public Collection filter(Object collection, String filter, Object value, Type type) throws HibernateException {
 		return listFilter( collection, filter, new QueryParameters( new Type[]{null, type}, new Object[]{null, value} ) );
 	}
 
 	public Collection filter(Object collection, String filter, Object[] values, Type[] types)
 	throws HibernateException {
 		Object[] vals = new Object[values.length + 1];
 		Type[] typs = new Type[types.length + 1];
 		System.arraycopy( values, 0, vals, 1, values.length );
 		System.arraycopy( types, 0, typs, 1, types.length );
 		return listFilter( collection, filter, new QueryParameters( typs, vals ) );
 	}
 
 	private FilterQueryPlan getFilterQueryPlan(
 			Object collection,
 			String filter,
 			QueryParameters parameters,
 			boolean shallow) throws HibernateException {
 		if ( collection == null ) {
 			throw new NullPointerException( "null collection passed to filter" );
 		}
 
 		CollectionEntry entry = persistenceContext.getCollectionEntryOrNull( collection );
 		final CollectionPersister roleBeforeFlush = (entry == null) ? null : entry.getLoadedPersister();
 
 		FilterQueryPlan plan = null;
 		if ( roleBeforeFlush == null ) {
 			// if it was previously unreferenced, we need to flush in order to
 			// get its state into the database in order to execute query
 			flush();
 			entry = persistenceContext.getCollectionEntryOrNull( collection );
 			CollectionPersister roleAfterFlush = (entry == null) ? null : entry.getLoadedPersister();
 			if ( roleAfterFlush == null ) {
 				throw new QueryException( "The collection was unreferenced" );
 			}
 			plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleAfterFlush.getRole(), shallow, getEnabledFilters() );
 		}
 		else {
 			// otherwise, we only need to flush if there are in-memory changes
 			// to the queried tables
 			plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleBeforeFlush.getRole(), shallow, getEnabledFilters() );
 			if ( autoFlushIfRequired( plan.getQuerySpaces() ) ) {
 				// might need to run a different filter entirely after the flush
 				// because the collection role may have changed
 				entry = persistenceContext.getCollectionEntryOrNull( collection );
 				CollectionPersister roleAfterFlush = (entry == null) ? null : entry.getLoadedPersister();
 				if ( roleBeforeFlush != roleAfterFlush ) {
 					if ( roleAfterFlush == null ) {
 						throw new QueryException( "The collection was dereferenced" );
 					}
 					plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleAfterFlush.getRole(), shallow, getEnabledFilters() );
 				}
 			}
 		}
 
 		if ( parameters != null ) {
 			parameters.getPositionalParameterValues()[0] = entry.getLoadedKey();
 			parameters.getPositionalParameterTypes()[0] = entry.getLoadedPersister().getKeyType();
 		}
 
 		return plan;
 	}
 
 	public List listFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		FilterQueryPlan plan = getFilterQueryPlan( collection, filter, queryParameters, false );
 		List results = CollectionHelper.EMPTY_LIST;
 
 		boolean success = false;
 		dontFlushFromFind++;   //stops flush being called multiple times if this method is recursively called
 		try {
 			results = plan.performList( queryParameters, this );
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 		return results;
 	}
 
 	public Iterator iterateFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		FilterQueryPlan plan = getFilterQueryPlan( collection, filter, queryParameters, true );
 		return plan.performIterate( queryParameters, this );
 	}
 
 	public Criteria createCriteria(Class persistentClass, String alias) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl( persistentClass.getName(), alias, this );
 	}
 
 	public Criteria createCriteria(String entityName, String alias) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl(entityName, alias, this);
 	}
 
 	public Criteria createCriteria(Class persistentClass) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl( persistentClass.getName(), this );
 	}
 
 	public Criteria createCriteria(String entityName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl(entityName, this);
 	}
 
 	public ScrollableResults scroll(CriteriaImpl criteria, ScrollMode scrollMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		String entityName = criteria.getEntityOrClassName();
 		CriteriaLoader loader = new CriteriaLoader(
 				getOuterJoinLoadable(entityName),
 				factory,
 				criteria,
 				entityName,
 				getLoadQueryInfluencers()
 		);
 		autoFlushIfRequired( loader.getQuerySpaces() );
 		dontFlushFromFind++;
 		try {
 			return loader.scroll(this, scrollMode);
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	public List list(CriteriaImpl criteria) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		String[] implementors = factory.getImplementors( criteria.getEntityOrClassName() );
 		int size = implementors.length;
 
 		CriteriaLoader[] loaders = new CriteriaLoader[size];
 		Set spaces = new HashSet();
 		for( int i=0; i <size; i++ ) {
 
 			loaders[i] = new CriteriaLoader(
 					getOuterJoinLoadable( implementors[i] ),
 					factory,
 					criteria,
 					implementors[i],
 					getLoadQueryInfluencers()
 				);
 
 			spaces.addAll( loaders[i].getQuerySpaces() );
 
 		}
 
 		autoFlushIfRequired(spaces);
 
 		List results = Collections.EMPTY_LIST;
 		dontFlushFromFind++;
 		boolean success = false;
 		try {
 			for( int i=0; i<size; i++ ) {
 				final List currentResults = loaders[i].list(this);
 				currentResults.addAll(results);
 				results = currentResults;
 			}
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 
 		return results;
 	}
 
 	private OuterJoinLoadable getOuterJoinLoadable(String entityName) throws MappingException {
 		EntityPersister persister = factory.getEntityPersister(entityName);
 		if ( !(persister instanceof OuterJoinLoadable) ) {
 			throw new MappingException( "class persister is not OuterJoinLoadable: " + entityName );
 		}
 		return ( OuterJoinLoadable ) persister;
 	}
 
 	public boolean contains(Object object) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object instanceof HibernateProxy ) {
 			//do not use proxiesByKey, since not all
 			//proxies that point to this session's
 			//instances are in that collection!
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			if ( li.isUninitialized() ) {
 				//if it is an uninitialized proxy, pointing
 				//with this session, then when it is accessed,
 				//the underlying instance will be "contained"
 				return li.getSession()==this;
 			}
 			else {
 				//if it is initialized, see if the underlying
 				//instance is contained, since we need to 
 				//account for the fact that it might have been
 				//evicted
 				object = li.getImplementation();
 			}
 		}
 		// A session is considered to contain an entity only if the entity has
 		// an entry in the session's persistence context and the entry reports
 		// that the entity has not been removed
 		EntityEntry entry = persistenceContext.getEntry( object );
 		return entry != null && entry.getStatus() != Status.DELETED && entry.getStatus() != Status.GONE;
 	}
 	
 	public Query createQuery(String queryString) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
-		return super.createQuery(queryString);
+		return super.createQuery( queryString );
 	}
 	
 	public SQLQuery createSQLQuery(String sql) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
-		return super.createSQLQuery(sql);
+		return super.createSQLQuery( sql );
 	}
 
 	public Query createSQLQuery(String sql, String returnAlias, Class returnClass) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new SQLQueryImpl(
 				sql,
 		        new String[] { returnAlias },
 		        new Class[] { returnClass },
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
 		);
 	}
 
 	public Query createSQLQuery(String sql, String returnAliases[], Class returnClasses[]) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new SQLQueryImpl(
 				sql,
 		        returnAliases,
 		        returnClasses,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
 		);
 	}
 
 	public ScrollableResults scrollCustomQuery(CustomQuery customQuery, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "scroll SQL query: " + customQuery.getSQL() );
 		}
 
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
 
 		autoFlushIfRequired( loader.getQuerySpaces() );
 
 		dontFlushFromFind++; //stops flush being called multiple times if this method is recursively called
 		try {
 			return loader.scroll(queryParameters, this);
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	// basically just an adapted copy of find(CriteriaImpl)
 	public List listCustomQuery(CustomQuery customQuery, QueryParameters queryParameters) 
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "SQL query: " + customQuery.getSQL() );
 		}
 		
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
 
 		autoFlushIfRequired( loader.getQuerySpaces() );
 
 		dontFlushFromFind++;
 		boolean success = false;
 		try {
 			List results = loader.list(this, queryParameters);
 			success = true;
 			return results;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 	}
 
-	public SessionFactory getSessionFactory() {
+	public SessionFactoryImplementor getSessionFactory() {
 		checkTransactionSynchStatus();
 		return factory;
 	}
-	
+
 	public void initializeCollection(PersistentCollection collection, boolean writing)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		InitializeCollectionEventListener[] listener = listeners.getInitializeCollectionEventListeners();
 		for ( int i = 0; i < listener.length; i++ ) {
 			listener[i].onInitializeCollection( new InitializeCollectionEvent(collection, this) );
 		}
 	}
 
 	public String bestGuessEntityName(Object object) {
 		if (object instanceof HibernateProxy) {
 			LazyInitializer initializer = ( ( HibernateProxy ) object ).getHibernateLazyInitializer();
 			// it is possible for this method to be called during flush processing,
-			// so make certain that we do not accidently initialize an uninitialized proxy
+			// so make certain that we do not accidentally initialize an uninitialized proxy
 			if ( initializer.isUninitialized() ) {
 				return initializer.getEntityName();
 			}
 			object = initializer.getImplementation();
 		}
 		EntityEntry entry = persistenceContext.getEntry(object);
 		if (entry==null) {
 			return guessEntityName(object);
 		}
 		else {
 			return entry.getPersister().getEntityName();
 		}
 	}
 	
 	public String getEntityName(Object object) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if (object instanceof HibernateProxy) {
 			if ( !persistenceContext.containsProxy( object ) ) {
 				throw new TransientObjectException("proxy was not associated with the session");
 			}
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation();
 		}
 
 		EntityEntry entry = persistenceContext.getEntry(object);
 		if ( entry == null ) {
 			throwTransientObjectException( object );
 		}
 		return entry.getPersister().getEntityName();
 	}
 
 	private void throwTransientObjectException(Object object) throws HibernateException {
 		throw new TransientObjectException(
 				"object references an unsaved transient instance - save the transient instance before flushing: " +
 				guessEntityName(object)
 			);
 	}
 
 	public String guessEntityName(Object object) throws HibernateException {
 		errorIfClosed();
 		return entityNameResolver.resolveEntityName( object );
 	}
 
 	public void cancelQuery() throws HibernateException {
 		errorIfClosed();
-		getJDBCContext().getConnectionManager().cancelLastQuery();
+		getTransactionCoordinator().getJdbcCoordinator().cancelLastQuery();
 	}
 
 	public Interceptor getInterceptor() {
 		checkTransactionSynchStatus();
 		return interceptor;
 	}
 
 	public int getDontFlushFromFind() {
 		return dontFlushFromFind;
 	}
 
 	public String toString() {
 		StringBuffer buf = new StringBuffer(500)
 			.append( "SessionImpl(" );
 		if ( !isClosed() ) {
 			buf.append(persistenceContext)
 				.append(";")
 				.append(actionQueue);
 		}
 		else {
 			buf.append("<closed>");
 		}
 		return buf.append(')').toString();
 	}
 
 	public EventListeners getListeners() {
 		return listeners;
 	}
 
 	public ActionQueue getActionQueue() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return actionQueue;
 	}
 	
 	public PersistenceContext getPersistenceContext() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return persistenceContext;
 	}
 	
 	public SessionStatistics getStatistics() {
 		checkTransactionSynchStatus();
 		return new SessionStatisticsImpl(this);
 	}
 
 	public boolean isEventSource() {
 		checkTransactionSynchStatus();
 		return true;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isDefaultReadOnly() {
 		return persistenceContext.isDefaultReadOnly();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setDefaultReadOnly(boolean defaultReadOnly) {
 		persistenceContext.setDefaultReadOnly( defaultReadOnly );
 	}
 
 	public boolean isReadOnly(Object entityOrProxy) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return persistenceContext.isReadOnly( entityOrProxy );	
 	}
 
 	public void setReadOnly(Object entity, boolean readOnly) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		persistenceContext.setReadOnly(entity, readOnly);
 	}
 
 	public void doWork(Work work) throws HibernateException {
-		try {
-			work.execute( jdbcContext.getConnectionManager().getConnection() );
-			jdbcContext.getConnectionManager().afterStatement();
-		}
-		catch ( SQLException e ) {
-			throw factory.getSQLExceptionHelper().convert( e, "error executing work" );
-		}
+		transactionCoordinator.getJdbcCoordinator().coordinateWork( work );
 	}
 
 	public void afterScrollOperation() {
 		// nothing to do in a stateful session
 	}
 
-	public JDBCContext getJDBCContext() {
+	@Override
+	public TransactionCoordinator getTransactionCoordinator() {
 		errorIfClosed();
-		checkTransactionSynchStatus();
-		return jdbcContext;
+		return transactionCoordinator;
 	}
 
 	public LoadQueryInfluencers getLoadQueryInfluencers() {
 		return loadQueryInfluencers;
 	}
 
 	// filter support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Filter getEnabledFilter(String filterName) {
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getEnabledFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Filter enableFilter(String filterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.enableFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void disableFilter(String filterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		loadQueryInfluencers.disableFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object getFilterParameterValue(String filterParameterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getFilterParameterValue( filterParameterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Type getFilterParameterType(String filterParameterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getFilterParameterType( filterParameterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Map getEnabledFilters() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getEnabledFilters();
 	}
 
 
 	// internal fetch profile support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String getFetchProfile() {
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getInternalFetchProfile();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setFetchProfile(String fetchProfile) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		loadQueryInfluencers.setInternalFetchProfile( fetchProfile );
 	}
 
 
 	// fetch profile support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public boolean isFetchProfileEnabled(String name) throws UnknownProfileException {
 		return loadQueryInfluencers.isFetchProfileEnabled( name );
 	}
 
 	public void enableFetchProfile(String name) throws UnknownProfileException {
 		loadQueryInfluencers.enableFetchProfile( name );
 	}
 
 	public void disableFetchProfile(String name) throws UnknownProfileException {
 		loadQueryInfluencers.disableFetchProfile( name );
 	}
 
 
 	private void checkTransactionSynchStatus() {
-		if ( jdbcContext != null && !isClosed() ) {
-			jdbcContext.registerSynchronizationIfPossible();
+		if ( !isClosed() ) {
+			transactionCoordinator.pulse();
 		}
 	}
 
 	/**
 	 * Used by JDK serialization...
 	 *
 	 * @param ois The input stream from which we are being read...
 	 * @throws IOException Indicates a general IO stream exception
 	 * @throws ClassNotFoundException Indicates a class resolution issue
 	 */
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		log.trace( "deserializing session" );
 
 		ois.defaultReadObject();
 
 		entityNameResolver = new CoordinatingEntityNameResolver();
 
 		boolean isRootSession = ois.readBoolean();
 		connectionReleaseMode = ConnectionReleaseMode.parse( ( String ) ois.readObject() );
 		entityMode = EntityMode.parse( ( String ) ois.readObject() );
 		autoClear = ois.readBoolean();
 		flushMode = FlushMode.parse( ( String ) ois.readObject() );
 		cacheMode = CacheMode.parse( ( String ) ois.readObject() );
 		flushBeforeCompletionEnabled = ois.readBoolean();
 		autoCloseSessionEnabled = ois.readBoolean();
 		interceptor = ( Interceptor ) ois.readObject();
 
 		factory = SessionFactoryImpl.deserialize( ois );
 		listeners = factory.getEventListeners();
 
 		if ( isRootSession ) {
-			jdbcContext = JDBCContextImpl.deserialize( ois, this, interceptor );
+			transactionCoordinator = TransactionCoordinatorImpl.deserialize( ois, this );
 		}
 
 		persistenceContext = StatefulPersistenceContext.deserialize( ois, this );
 		actionQueue = ActionQueue.deserialize( ois, this );
 
 		loadQueryInfluencers = ( LoadQueryInfluencers ) ois.readObject();
 
 		childSessionsByEntityMode = ( Map ) ois.readObject();
 
 		// LoadQueryInfluencers.getEnabledFilters() tries to validate each enabled
 		// filter, which will fail when called before FilterImpl.afterDeserialize( factory );
 		// Instead lookup the filter by name and then call FilterImpl.afterDeserialize( factory ).
 		Iterator iter = loadQueryInfluencers.getEnabledFilterNames().iterator();
 		while ( iter.hasNext() ) {
 			String filterName = ( String ) iter.next();
 			 ( ( FilterImpl ) loadQueryInfluencers.getEnabledFilter( filterName )  )
 					.afterDeserialize( factory );
 		}
 
 		if ( isRootSession && childSessionsByEntityMode != null ) {
 			iter = childSessionsByEntityMode.values().iterator();
 			while ( iter.hasNext() ) {
 				final SessionImpl child = ( ( SessionImpl ) iter.next() );
 				child.rootSession = this;
-				child.jdbcContext = this.jdbcContext;
+				child.transactionCoordinator = this.transactionCoordinator;
 			}
 		}
 	}
 
 	/**
 	 * Used by JDK serialization...
 	 *
 	 * @param oos The output stream to which we are being written...
 	 * @throws IOException Indicates a general IO stream exception
 	 */
 	private void writeObject(ObjectOutputStream oos) throws IOException {
-		if ( !jdbcContext.isReadyForSerialization() ) {
+		if ( ! transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isReadyForSerialization() ) {
 			throw new IllegalStateException( "Cannot serialize a session while connected" );
 		}
 
 		log.trace( "serializing session" );
 
 		oos.defaultWriteObject();
 
 		oos.writeBoolean( rootSession == null );
 		oos.writeObject( connectionReleaseMode.toString() );
 		oos.writeObject( entityMode.toString() );
 		oos.writeBoolean( autoClear );
 		oos.writeObject( flushMode.toString() );
 		oos.writeObject( cacheMode.toString() );
 		oos.writeBoolean( flushBeforeCompletionEnabled );
 		oos.writeBoolean( autoCloseSessionEnabled );
 		// we need to writeObject() on this since interceptor is user defined
 		oos.writeObject( interceptor );
 
 		factory.serialize( oos );
 
 		if ( rootSession == null ) {
-			jdbcContext.serialize( oos );
+			transactionCoordinator.serialize( oos );
 		}
 
 		persistenceContext.serialize( oos );
 		actionQueue.serialize( oos );
 
 		// todo : look at optimizing these...
 		oos.writeObject( loadQueryInfluencers );
 		oos.writeObject( childSessionsByEntityMode );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
-	public Object execute(Callback callback) {
-		Connection connection = jdbcContext.getConnectionManager().getConnection();
+	public Object execute(LobCreationContext.Callback callback) {
+		Connection connection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getConnection();
 		try {
 			return callback.executeOnConnection( connection );
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"Error creating contextual LOB : " + e.getMessage()
 			);
 		}
 		finally {
-			jdbcContext.getConnectionManager().afterStatement();
+			transactionCoordinator.getJdbcCoordinator().getLogicalConnection().afterStatementExecution();
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypeHelper getTypeHelper() {
 		return getSessionFactory().getTypeHelper();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public LobHelper getLobHelper() {
 		if ( lobHelper == null ) {
 			lobHelper = new LobHelperImpl( this );
 		}
 		return lobHelper;
 	}
 
 	private transient LobHelperImpl lobHelper;
 
 	private static class LobHelperImpl implements LobHelper {
 		private final SessionImpl session;
 
 		private LobHelperImpl(SessionImpl session) {
 			this.session = session;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Blob createBlob(byte[] bytes) {
 			return lobCreator().createBlob( bytes );
 		}
 
 		private LobCreator lobCreator() {
 			return session.getFactory().getSettings().getJdbcSupport().getLobCreator( session );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Blob createBlob(InputStream stream, long length) {
 			return lobCreator().createBlob( stream, length );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createClob(String string) {
 			return lobCreator().createClob( string );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createClob(Reader reader, long length) {
 			return lobCreator().createClob( reader, length );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createNClob(String string) {
 			return lobCreator().createNClob( string );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createNClob(Reader reader, long length) {
 			return lobCreator().createNClob( reader, length );
 		}
 	}
 
 	private class CoordinatingEntityNameResolver implements EntityNameResolver {
 		public String resolveEntityName(Object entity) {
 			String entityName = interceptor.getEntityName( entity );
 			if ( entityName != null ) {
 				return entityName;
 			}
 
 			Iterator itr = factory.iterateEntityNameResolvers( entityMode );
 			while ( itr.hasNext() ) {
 				final EntityNameResolver resolver = ( EntityNameResolver ) itr.next();
 				entityName = resolver.resolveEntityName( entity );
 				if ( entityName != null ) {
 					break;
 				}
 			}
 			if ( entityName != null ) {
 				return entityName;
 			}
 
 			// the old-time stand-by...
 			return entity.getClass().getName();
 		}
 	}
 
 	private class LockRequestImpl implements LockRequest {
 		private final LockOptions lockOptions;
 		private LockRequestImpl(LockOptions lo) {
 			lockOptions = new LockOptions();
 			LockOptions.copy(lo, lockOptions);
 		}
 
 		public LockMode getLockMode() {
 			return lockOptions.getLockMode();
 		}
 
 		public LockRequest setLockMode(LockMode lockMode) {
 			lockOptions.setLockMode(lockMode);
 			return this;
 		}
 
 		public int getTimeOut() {
 			return lockOptions.getTimeOut();
 		}
 
 		public LockRequest setTimeOut(int timeout) {
 			lockOptions.setTimeOut(timeout);
 			return this;
 		}
 
 		public boolean getScope() {
 			return lockOptions.getScope();
 		}
 
 		public LockRequest setScope(boolean scope) {
 			lockOptions.setScope(scope);
 			return this;
 		}
 
 		public void lock(String entityName, Object object) throws HibernateException {
 			fireLock( entityName, object, lockOptions );
 		}
 		public void lock(Object object) throws HibernateException {
 			fireLock( object, lockOptions );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/StatelessSessionImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/StatelessSessionImpl.java
index c18b38f2fd..a564766587 100755
--- a/hibernate-core/src/main/java/org/hibernate/impl/StatelessSessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/StatelessSessionImpl.java
@@ -1,695 +1,711 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.impl;
 
-import java.io.Serializable;
-import java.sql.Connection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.hibernate.CacheMode;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Criteria;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.LockMode;
 import org.hibernate.MappingException;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.SessionException;
 import org.hibernate.StatelessSession;
 import org.hibernate.Transaction;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.cache.CacheKey;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.engine.EntityKey;
+import org.hibernate.engine.LoadQueryInfluencers;
+import org.hibernate.engine.NonFlushedChanges;
 import org.hibernate.engine.PersistenceContext;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.StatefulPersistenceContext;
 import org.hibernate.engine.Versioning;
-import org.hibernate.engine.LoadQueryInfluencers;
-import org.hibernate.engine.NonFlushedChanges;
-import org.hibernate.engine.jdbc.internal.JDBCContextImpl;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
 import org.hibernate.engine.query.HQLQueryPlan;
 import org.hibernate.engine.query.NativeSQLQueryPlan;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.spi.TransactionCoordinator;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.event.EventListeners;
 import org.hibernate.id.IdentifierGeneratorHelper;
 import org.hibernate.loader.criteria.CriteriaLoader;
 import org.hibernate.loader.custom.CustomLoader;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.type.Type;
 import org.hibernate.util.CollectionHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.Serializable;
+import java.sql.Connection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * @author Gavin King
  */
-public class StatelessSessionImpl extends AbstractSessionImpl
-		implements JDBCContext.Context, StatelessSession {
-
+public class StatelessSessionImpl extends AbstractSessionImpl implements StatelessSession {
 	private static final Logger log = LoggerFactory.getLogger( StatelessSessionImpl.class );
 
-	private JDBCContextImpl jdbcContext;
+	private TransactionCoordinator transactionCoordinator;
 	private PersistenceContext temporaryPersistenceContext = new StatefulPersistenceContext( this );
 
 	StatelessSessionImpl(Connection connection, SessionFactoryImpl factory) {
 		super( factory );
-		this.jdbcContext = new JDBCContextImpl( this, connection, EmptyInterceptor.INSTANCE );
+		this.transactionCoordinator = new TransactionCoordinatorImpl( connection, this );
+	}
+
+	// TransactionContext ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+	@Override
+	public TransactionCoordinator getTransactionCoordinator() {
+		return transactionCoordinator;
 	}
 
+	@Override
+	public TransactionEnvironment getTransactionEnvironment() {
+		return factory.getTransactionEnvironment();
+	}
 
 	// inserts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Serializable insert(Object entity) {
 		errorIfClosed();
 		return insert(null, entity);
 	}
 
 	public Serializable insert(String entityName, Object entity) {
 		errorIfClosed();
 		EntityPersister persister = getEntityPersister(entityName, entity);
 		Serializable id = persister.getIdentifierGenerator().generate(this, entity);
 		Object[] state = persister.getPropertyValues(entity, EntityMode.POJO);
 		if ( persister.isVersioned() ) {
 			boolean substitute = Versioning.seedVersion(state, persister.getVersionProperty(), persister.getVersionType(), this);
 			if ( substitute ) {
 				persister.setPropertyValues( entity, state, EntityMode.POJO );
 			}
 		}
 		if ( id == IdentifierGeneratorHelper.POST_INSERT_INDICATOR ) {
 			id = persister.insert(state, entity, this);
 		}
 		else {
 			persister.insert(id, state, entity, this);
 		}
 		persister.setIdentifier( entity, id, this );
 		return id;
 	}
 
 
 	// deletes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void delete(Object entity) {
 		errorIfClosed();
 		delete(null, entity);
 	}
 
 	public void delete(String entityName, Object entity) {
 		errorIfClosed();
 		EntityPersister persister = getEntityPersister(entityName, entity);
 		Serializable id = persister.getIdentifier( entity, this );
 		Object version = persister.getVersion(entity, EntityMode.POJO);
 		persister.delete(id, version, entity, this);
 	}
 
 
 	// updates ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void update(Object entity) {
 		errorIfClosed();
 		update(null, entity);
 	}
 
 	public void update(String entityName, Object entity) {
 		errorIfClosed();
 		EntityPersister persister = getEntityPersister(entityName, entity);
 		Serializable id = persister.getIdentifier( entity, this );
 		Object[] state = persister.getPropertyValues(entity, EntityMode.POJO);
 		Object oldVersion;
 		if ( persister.isVersioned() ) {
 			oldVersion = persister.getVersion(entity, EntityMode.POJO);
 			Object newVersion = Versioning.increment( oldVersion, persister.getVersionType(), this );
 			Versioning.setVersion(state, newVersion, persister);
 			persister.setPropertyValues(entity, state, EntityMode.POJO);
 		}
 		else {
 			oldVersion = null;
 		}
 		persister.update(id, state, null, false, null, oldVersion, entity, null, this);
 	}
 
 
 	// loading ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object get(Class entityClass, Serializable id) {
 		return get( entityClass.getName(), id );
 	}
 
 	public Object get(Class entityClass, Serializable id, LockMode lockMode) {
 		return get( entityClass.getName(), id, lockMode );
 	}
 
 	public Object get(String entityName, Serializable id) {
 		return get(entityName, id, LockMode.NONE);
 	}
 
 	public Object get(String entityName, Serializable id, LockMode lockMode) {
 		errorIfClosed();
 		Object result = getFactory().getEntityPersister(entityName)
 				.load(id, null, lockMode, this);
 		if ( temporaryPersistenceContext.isLoadFinished() ) {
 			temporaryPersistenceContext.clear();
 		}
 		return result;
 	}
 
 	public void refresh(Object entity) {
 		refresh( bestGuessEntityName( entity ), entity, LockMode.NONE );
 	}
 
 	public void refresh(String entityName, Object entity) {
 		refresh( entityName, entity, LockMode.NONE );
 	}
 
 	public void refresh(Object entity, LockMode lockMode) {
 		refresh( bestGuessEntityName( entity ), entity, lockMode );
 	}
 
 	public void refresh(String entityName, Object entity, LockMode lockMode) {
 		final EntityPersister persister = this.getEntityPersister( entityName, entity );
 		final Serializable id = persister.getIdentifier( entity, this );
 		if ( log.isTraceEnabled() ) {
 			log.trace(
 					"refreshing transient " +
 					MessageHelper.infoString( persister, id, this.getFactory() )
 			);
 		}
 		// TODO : can this ever happen???
 //		EntityKey key = new EntityKey( id, persister, source.getEntityMode() );
 //		if ( source.getPersistenceContext().getEntry( key ) != null ) {
 //			throw new PersistentObjectException(
 //					"attempted to refresh transient instance when persistent " +
 //					"instance was already associated with the Session: " +
 //					MessageHelper.infoString( persister, id, source.getFactory() )
 //			);
 //		}
 
 		if ( persister.hasCache() ) {
 			final CacheKey ck = new CacheKey(
 					id,
 			        persister.getIdentifierType(),
 			        persister.getRootEntityName(),
 			        this.getEntityMode(),
 			        this.getFactory()
 			);
 			persister.getCacheAccessStrategy().evict( ck );
 		}
 
 		String previousFetchProfile = this.getFetchProfile();
 		Object result = null;
 		try {
 			this.setFetchProfile( "refresh" );
 			result = persister.load( id, entity, lockMode, this );
 		}
 		finally {
 			this.setFetchProfile( previousFetchProfile );
 		}
 		UnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );
 	}
 
 	public Object immediateLoad(String entityName, Serializable id)
 			throws HibernateException {
 		throw new SessionException("proxies cannot be fetched by a stateless session");
 	}
 
 	public void initializeCollection(
 			PersistentCollection collection,
 	        boolean writing) throws HibernateException {
 		throw new SessionException("collections cannot be fetched by a stateless session");
 	}
 
 	public Object instantiate(
 			String entityName,
 	        Serializable id) throws HibernateException {
 		errorIfClosed();
 		return getFactory().getEntityPersister( entityName )
 				.instantiate( id, this );
 	}
 
 	public Object internalLoad(
 			String entityName,
 	        Serializable id,
 	        boolean eager,
 	        boolean nullable) throws HibernateException {
 		errorIfClosed();
 		EntityPersister persister = getFactory().getEntityPersister( entityName );
 		// first, try to load it from the temp PC associated to this SS
 		Object loaded = temporaryPersistenceContext.getEntity( new EntityKey( id, persister, getEntityMode() ) );
 		if ( loaded != null ) {
 			// we found it in the temp PC.  Should indicate we are in the midst of processing a result set
 			// containing eager fetches via join fetch
 			return loaded;
 		}
 		if ( !eager && persister.hasProxy() ) {
 			// if the metadata allowed proxy creation and caller did not request forceful eager loading,
 			// generate a proxy
 			return persister.createProxy( id, this );
 		}
 		// otherwise immediately materialize it
 		return get( entityName, id );
 	}
 
 	public Iterator iterate(String query, QueryParameters queryParameters) throws HibernateException {
 		throw new UnsupportedOperationException();
 	}
 
 	public Iterator iterateFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		throw new UnsupportedOperationException();
 	}
 
 	public List listFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		throw new UnsupportedOperationException();
 	}
 
 
 	public boolean isOpen() {
 		return !isClosed();
 	}
 
 	public void close() {
 		managedClose();
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return factory.getSettings().getConnectionReleaseMode();
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return factory.getSettings().isAutoCloseSessionEnabled();
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return true;
 	}
 
 	public boolean isFlushModeNever() {
 		return false;
 	}
 
 	public void managedClose() {
 		if ( isClosed() ) {
 			throw new SessionException( "Session was already closed!" );
 		}
-		jdbcContext.getConnectionManager().close();
+		transactionCoordinator.close();
 		setClosed();
 	}
 
 	public void managedFlush() {
 		errorIfClosed();
-		getJDBCContext().getConnectionManager().executeBatch();
+		getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 	}
 
 	public boolean shouldAutoClose() {
 		return isAutoCloseSessionEnabled() && !isClosed();
 	}
 
-	public void afterTransactionCompletion(boolean successful, Transaction tx) {}
+	@Override
+	public void afterTransactionBegin(TransactionImplementor hibernateTransaction) {
+		// nothing to do here
+	}
 
-	public void beforeTransactionCompletion(Transaction tx) {}
+	@Override
+	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction) {
+		// nothing to do here
+	}
+
+	@Override
+	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful) {
+		// nothing to do here
+	}
 
 	public String bestGuessEntityName(Object object) {
 		if (object instanceof HibernateProxy) {
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation();
 		}
 		return guessEntityName(object);
 	}
 
 	public Connection connection() {
 		errorIfClosed();
-		return jdbcContext.borrowConnection();
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getDistinctConnectionProxy();
 	}
 
 	public int executeUpdate(String query, QueryParameters queryParameters)
 			throws HibernateException {
 		errorIfClosed();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		boolean success = false;
 		int result = 0;
 		try {
 			result = plan.performExecuteUpdate( queryParameters, this );
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		temporaryPersistenceContext.clear();
 		return result;
 	}
 
 	public CacheMode getCacheMode() {
 		return CacheMode.IGNORE;
 	}
 
 	public int getDontFlushFromFind() {
 		return 0;
 	}
 
 	public Map getEnabledFilters() {
 		return CollectionHelper.EMPTY_MAP;
 	}
 
 	public Serializable getContextEntityIdentifier(Object object) {
 		errorIfClosed();
 		return null;
 	}
 
 	public EntityMode getEntityMode() {
 		return EntityMode.POJO;
 	}
 
 	public EntityPersister getEntityPersister(String entityName, Object object)
 			throws HibernateException {
 		errorIfClosed();
 		if ( entityName==null ) {
 			return factory.getEntityPersister( guessEntityName( object ) );
 		}
 		else {
 			return factory.getEntityPersister( entityName )
 					.getSubclassEntityPersister( object, getFactory(), EntityMode.POJO );
 		}
 	}
 
 	public Object getEntityUsingInterceptor(EntityKey key) throws HibernateException {
 		errorIfClosed();
 		return null;
 	}
 
 	public Type getFilterParameterType(String filterParameterName) {
 		throw new UnsupportedOperationException();
 	}
 
 	public Object getFilterParameterValue(String filterParameterName) {
 		throw new UnsupportedOperationException();
 	}
 
 	public FlushMode getFlushMode() {
 		return FlushMode.COMMIT;
 	}
 
 	public Interceptor getInterceptor() {
 		return EmptyInterceptor.INSTANCE;
 	}
 
 	public EventListeners getListeners() {
 		throw new UnsupportedOperationException();
 	}
 
 	public PersistenceContext getPersistenceContext() {
 		return temporaryPersistenceContext;
 	}
 
 	public long getTimestamp() {
 		throw new UnsupportedOperationException();
 	}
 
 	public String guessEntityName(Object entity) throws HibernateException {
 		errorIfClosed();
 		return entity.getClass().getName();
 	}
 
 
 	public boolean isConnected() {
-		return jdbcContext.getConnectionManager().isCurrentlyConnected();
+		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isPhysicallyConnected();
 	}
 
 	public boolean isTransactionInProgress() {
-		return jdbcContext.isTransactionInProgress();
+		return transactionCoordinator.isTransactionInProgress();
 	}
 
 	public void setAutoClear(boolean enabled) {
 		throw new UnsupportedOperationException();
 	}
 
 	public void setCacheMode(CacheMode cm) {
 		throw new UnsupportedOperationException();
 	}
 
 	public void setFlushMode(FlushMode fm) {
 		throw new UnsupportedOperationException();
 	}
 
 	public Transaction getTransaction() throws HibernateException {
 		errorIfClosed();
-		return jdbcContext.getTransaction();
+		return transactionCoordinator.getTransaction();
 	}
 
 	public Transaction beginTransaction() throws HibernateException {
 		errorIfClosed();
 		Transaction result = getTransaction();
 		result.begin();
 		return result;
 	}
 
 	public boolean isEventSource() {
 		return false;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isDefaultReadOnly() {
 		return false;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setDefaultReadOnly(boolean readOnly) throws HibernateException {
 		if ( readOnly == true ) {
 			throw new UnsupportedOperationException();
 		}
 	}
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////
 
 	//TODO: COPY/PASTE FROM SessionImpl, pull up!
 
 	public List list(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		boolean success = false;
 		List results = CollectionHelper.EMPTY_LIST;
 		try {
 			results = plan.performList( queryParameters, this );
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		temporaryPersistenceContext.clear();
 		return results;
 	}
 
 	public void afterOperation(boolean success) {
-		if ( !jdbcContext.isTransactionInProgress() ) {
-			jdbcContext.afterNontransactionalQuery(success);
+		if ( ! transactionCoordinator.isTransactionInProgress() ) {
+			transactionCoordinator.afterNonTransactionalQuery( success );;
 		}
 	}
 
 	public Criteria createCriteria(Class persistentClass, String alias) {
 		errorIfClosed();
 		return new CriteriaImpl( persistentClass.getName(), alias, this );
 	}
 
 	public Criteria createCriteria(String entityName, String alias) {
 		errorIfClosed();
 		return new CriteriaImpl(entityName, alias, this);
 	}
 
 	public Criteria createCriteria(Class persistentClass) {
 		errorIfClosed();
 		return new CriteriaImpl( persistentClass.getName(), this );
 	}
 
 	public Criteria createCriteria(String entityName) {
 		errorIfClosed();
 		return new CriteriaImpl(entityName, this);
 	}
 
 	public ScrollableResults scroll(CriteriaImpl criteria, ScrollMode scrollMode) {
 		errorIfClosed();
 		String entityName = criteria.getEntityOrClassName();
 		CriteriaLoader loader = new CriteriaLoader(
 				getOuterJoinLoadable( entityName ),
 		        factory,
 		        criteria,
 		        entityName,
 		        getLoadQueryInfluencers()
 		);
 		return loader.scroll(this, scrollMode);
 	}
 
 	public List list(CriteriaImpl criteria) throws HibernateException {
 		errorIfClosed();
 		String[] implementors = factory.getImplementors( criteria.getEntityOrClassName() );
 		int size = implementors.length;
 
 		CriteriaLoader[] loaders = new CriteriaLoader[size];
 		for( int i=0; i <size; i++ ) {
 			loaders[i] = new CriteriaLoader(
 					getOuterJoinLoadable( implementors[i] ),
 			        factory,
 			        criteria,
 			        implementors[i],
 			        getLoadQueryInfluencers()
 			);
 		}
 
 
 		List results = Collections.EMPTY_LIST;
 		boolean success = false;
 		try {
 			for( int i=0; i<size; i++ ) {
 				final List currentResults = loaders[i].list(this);
 				currentResults.addAll(results);
 				results = currentResults;
 			}
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		temporaryPersistenceContext.clear();
 		return results;
 	}
 
 	private OuterJoinLoadable getOuterJoinLoadable(String entityName) throws MappingException {
 		EntityPersister persister = factory.getEntityPersister(entityName);
 		if ( !(persister instanceof OuterJoinLoadable) ) {
 			throw new MappingException( "class persister is not OuterJoinLoadable: " + entityName );
 		}
 		return ( OuterJoinLoadable ) persister;
 	}
 
 	public List listCustomQuery(CustomQuery customQuery, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
 
 		boolean success = false;
 		List results;
 		try {
 			results = loader.list(this, queryParameters);
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		temporaryPersistenceContext.clear();
 		return results;
 	}
 
 	public ScrollableResults scrollCustomQuery(CustomQuery customQuery, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
-		return loader.scroll(queryParameters, this);
+		return loader.scroll( queryParameters, this );
 	}
 
 	public ScrollableResults scroll(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		return plan.performScroll( queryParameters, this );
 	}
 
 	public void afterScrollOperation() {
 		temporaryPersistenceContext.clear();
 	}
 
 	public void flush() {}
 
 	public NonFlushedChanges getNonFlushedChanges() {
 		throw new UnsupportedOperationException();
 	}
 
 	public void applyNonFlushedChanges(NonFlushedChanges nonFlushedChanges) {
 		throw new UnsupportedOperationException();
 	}
 
 	public String getFetchProfile() {
 		return null;
 	}
 
-	public JDBCContext getJDBCContext() {
-		return jdbcContext;
-	}
-
 	public LoadQueryInfluencers getLoadQueryInfluencers() {
 		return LoadQueryInfluencers.NONE;
 	}
 
 	public void registerInsertedKey(EntityPersister persister, Serializable id) {
 		errorIfClosed();
 		// nothing to do
 	}
 
 	public boolean wasInsertedDuringTransaction(EntityPersister persister, Serializable id) {
 		errorIfClosed();
 		// not in any meaning we need to worry about here.
 		return false;
 	}
 
 	public void setFetchProfile(String name) {}
 
-	public void afterTransactionBegin(Transaction tx) {}
-
 	protected boolean autoFlushIfRequired(Set querySpaces) throws HibernateException {
 		// no auto-flushing to support in stateless session
 		return false;
 	}
 	
 	public int executeNativeUpdate(NativeSQLQuerySpecification nativeSQLQuerySpecification,
 			QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		queryParameters.validateParameters();
 		NativeSQLQueryPlan plan = getNativeSQLQueryPlan(nativeSQLQuerySpecification);
 
 		boolean success = false;
 		int result = 0;
 		try {
 			result = plan.performExecuteUpdate(queryParameters, this);
 			success = true;
 		} finally {
 			afterOperation(success);
 		}
 		temporaryPersistenceContext.clear();
 		return result;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/TransactionEnvironmentImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/TransactionEnvironmentImpl.java
new file mode 100644
index 0000000000..a3b67f7f5d
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/impl/TransactionEnvironmentImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.impl;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
+
+/**
+ * @author Steve Ebersole
+ */
+public class TransactionEnvironmentImpl implements TransactionEnvironment {
+	private final SessionFactoryImpl sessionFactory;
+
+	public TransactionEnvironmentImpl(SessionFactoryImpl sessionFactory) {
+		this.sessionFactory = sessionFactory;
+	}
+
+	@Override
+	public SessionFactoryImplementor getSessionFactory() {
+		return sessionFactory;
+	}
+
+	protected ServiceRegistry serviceRegistry() {
+		return sessionFactory.getServiceRegistry();
+	}
+
+	@Override
+	public JdbcServices getJdbcServices() {
+		return serviceRegistry().getService( JdbcServices.class );
+	}
+
+	@Override
+	public JtaPlatform getJtaPlatform() {
+		return serviceRegistry().getService( JtaPlatform.class );
+	}
+
+	@Override
+	public TransactionFactory getTransactionFactory() {
+		return serviceRegistry().getService( TransactionFactory.class );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/jdbc/BorrowedConnectionProxy.java b/hibernate-core/src/main/java/org/hibernate/jdbc/BorrowedConnectionProxy.java
deleted file mode 100644
index 3b3ff05b5d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/jdbc/BorrowedConnectionProxy.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.jdbc;
-
-import org.hibernate.HibernateException;
-import org.hibernate.engine.jdbc.internal.LogicalConnectionImpl;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.InvocationTargetException;
-import java.sql.Connection;
-
-/**
- * A proxy for <i>borrowed</i> connections which funnels all requests back
- * into the ConnectionManager from which it was borrowed to be properly
- * handled (in terms of connection release modes).
- * <p/>
- * Note: the term borrowed here refers to connection references obtained
- * via {@link org.hibernate.Session#connection()} for application usage.
- *
- * @author Steve Ebersole
- */
-public class BorrowedConnectionProxy implements InvocationHandler {
-
-	private static final Class[] PROXY_INTERFACES = new Class[] { Connection.class, ConnectionWrapper.class };
-
-	private final LogicalConnectionImpl logicalConnection;
-	private boolean useable = true;
-
-	public BorrowedConnectionProxy(LogicalConnectionImpl logicalConnection) {
-		this.logicalConnection = logicalConnection;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-		if ( "close".equals( method.getName() ) ) {
-			logicalConnection.releaseBorrowedConnection();
-			return null;
-		}
-		// should probably no-op commit/rollback here, at least in JTA scenarios
-		if ( !useable ) {
-			throw new HibernateException( "connnection proxy not usable after transaction completion" );
-		}
-
-		if ( "getWrappedConnection".equals( method.getName() ) ) {
-			return logicalConnection.getConnection();
-		}
-
-		try {
-			return method.invoke( logicalConnection.getConnection(), args );
-		}
-		catch( InvocationTargetException e ) {
-			throw e.getTargetException();
-		}
-	}
-
-	/**
-	 * Generates a Connection proxy wrapping the connection managed by the passed
-	 * connection manager.
-	 *
-	 * @param logicalConnection The logical connection to wrap with the
-	 * connection proxy.
-	 * @return The generated proxy.
-	 */
-	public static Connection generateProxy(LogicalConnectionImpl logicalConnection) {
-		BorrowedConnectionProxy handler = new BorrowedConnectionProxy( logicalConnection );
-		return ( Connection ) Proxy.newProxyInstance(
-				getProxyClassLoader(),
-		        PROXY_INTERFACES,
-		        handler
-		);
-	}
-
-	/**
-	 * Marks a borrowed connection as no longer usable.
-	 *
-	 * @param connection The connection (proxy) to be marked.
-	 */
-	public static void renderUnuseable(Connection connection) {
-		if ( connection != null && Proxy.isProxyClass( connection.getClass() ) ) {
-			InvocationHandler handler = Proxy.getInvocationHandler( connection );
-			if ( BorrowedConnectionProxy.class.isAssignableFrom( handler.getClass() ) ) {
-				( ( BorrowedConnectionProxy ) handler ).useable = false;
-			}
-		}
-	}
-
-	/**
-	 * Convience method for unwrapping a connection proxy and getting a
-	 * handle to an underlying connection.
-	 *
-	 * @param connection The connection (proxy) to be unwrapped.
-	 * @return The unwrapped connection.
-	 */
-	public static Connection getWrappedConnection(Connection connection) {
-		if ( connection != null && connection instanceof ConnectionWrapper ) {
-			return ( ( ConnectionWrapper ) connection ).getWrappedConnection();
-		}
-		else {
-			return connection;
-		}
-	}
-
-	/**
-	 * Determines the appropriate class loader to which the generated proxy
-	 * should be scoped.
-	 *
-	 * @return The class loader appropriate for proxy construction.
-	 */
-	public static ClassLoader getProxyClassLoader() {
-		return ConnectionWrapper.class.getClassLoader();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
index 9b3396b638..68c109f8ff 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
@@ -1,168 +1,196 @@
 //$Id: HibernateService.java 6100 2005-03-17 10:48:03Z turin42 $
 package org.hibernate.jmx;
 
 import java.util.Properties;
 import java.util.Map;
 
 import javax.naming.InitialContext;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.internal.ServiceRegistryImpl;
+import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.internal.util.jndi.JndiHelper;
 import org.hibernate.util.ExternalSessionFactoryConfig;
 
 
 /**
  * Implementation of <tt>HibernateServiceMBean</tt>. Creates a
  * <tt>SessionFactory</tt> and binds it to the specified JNDI name.<br>
  * <br>
  * All mapping documents are loaded as resources by the MBean.
  * @see HibernateServiceMBean
  * @see org.hibernate.SessionFactory
  * @author John Urberg, Gavin King
  */
 public class HibernateService extends ExternalSessionFactoryConfig implements HibernateServiceMBean {
-
-	private static final Logger log = LoggerFactory.getLogger(HibernateServiceMBean.class);
+	private static final Logger log = LoggerFactory.getLogger( HibernateServiceMBean.class );
 
 	private String boundName;
 	private Properties properties = new Properties();
 
+	@Override
 	public void start() throws HibernateException {
 		boundName = getJndiName();
 		try {
 			buildSessionFactory();
 		}
 		catch (HibernateException he) {
 			log.info( "Could not build SessionFactory using the MBean classpath - will try again using client classpath: " + he.getMessage() );
 			log.debug("Error was", he);
 			new SessionFactoryStub(this);
 		}
 	}
 
+	@Override
 	public void stop() {
 		log.info("stopping service");
 		try {
 			InitialContext context = JndiHelper.getInitialContext( buildProperties() );
 			( (SessionFactory) context.lookup(boundName) ).close();
 			//context.unbind(boundName);
 		}
 		catch (Exception e) {
 			log.warn("exception while stopping service", e);
 		}
 	}
 	
 	SessionFactory buildSessionFactory() throws HibernateException {
 		log.info( "starting service at JNDI name: " + boundName );
 		log.info( "service properties: " + properties );
 		return buildConfiguration().buildSessionFactory( new ServiceRegistryImpl( properties ) );
 	}
 
+	@Override
 	protected Map getExtraProperties() {
 		return properties;
 	}
 
+	@Override
 	public String getTransactionStrategy() {
 		return getProperty(Environment.TRANSACTION_STRATEGY);
 	}
 
+	@Override
 	public void setTransactionStrategy(String txnStrategy) {
 		setProperty(Environment.TRANSACTION_STRATEGY, txnStrategy);
 	}
 
+	@Override
 	public String getUserTransactionName() {
 		return getProperty(Environment.USER_TRANSACTION);
 	}
 
+	@Override
 	public void setUserTransactionName(String utName) {
 		setProperty(Environment.USER_TRANSACTION, utName);
 	}
 
-	public String getTransactionManagerLookupStrategy() {
-		return getProperty(Environment.TRANSACTION_MANAGER_STRATEGY);
+	@Override
+	public String getJtaPlatformName() {
+		return getProperty( JtaPlatformInitiator.JTA_PLATFORM );
 	}
 
-	public void setTransactionManagerLookupStrategy(String lkpStrategy) {
-		setProperty(Environment.TRANSACTION_MANAGER_STRATEGY, lkpStrategy);
+	@Override
+	public void setJtaPlatformName(String name) {
+		setProperty( JtaPlatformInitiator.JTA_PLATFORM, name );
 	}
 
+	@Override
 	public String getPropertyList() {
 		return buildProperties().toString();
 	}
 
+	@Override
 	public String getProperty(String property) {
 		return properties.getProperty(property);
 	}
 
+	@Override
 	public void setProperty(String property, String value) {
 		properties.setProperty(property, value);
 	}
 
+	@Override
 	public void dropSchema() {
 		new SchemaExport( buildConfiguration() ).drop(false, true);
 	}
 
+	@Override
 	public void createSchema() {
 		new SchemaExport( buildConfiguration() ).create(false, true);
-	}	public String getName() {
+	}
+
+	public String getName() {
 		return getProperty(Environment.SESSION_FACTORY_NAME);
 	}
 
+	@Override
 	public String getDatasource() {
 		return getProperty(Environment.DATASOURCE);
 	}
 
+	@Override
 	public void setDatasource(String datasource) {
 		setProperty(Environment.DATASOURCE, datasource);
 	}
 
+	@Override
 	public String getJndiName() {
 		return getProperty(Environment.SESSION_FACTORY_NAME);
 	}
 
+	@Override
 	public void setJndiName(String jndiName) {
 		setProperty(Environment.SESSION_FACTORY_NAME, jndiName);
 	}
 
+	@Override
 	public String getUserName() {
 		return getProperty(Environment.USER);
 	}
 
+	@Override
 	public void setUserName(String userName) {
 		setProperty(Environment.USER, userName);
 	}
 
+	@Override
 	public String getPassword() {
 		return getProperty(Environment.PASS);
 	}
 
+	@Override
 	public void setPassword(String password) {
 		setProperty(Environment.PASS, password);
 	}
 
+	@Override
 	public void setFlushBeforeCompletionEnabled(String enabled) {
 		setProperty(Environment.FLUSH_BEFORE_COMPLETION, enabled);
 	}
 
+	@Override
 	public String getFlushBeforeCompletionEnabled() {
 		return getProperty(Environment.FLUSH_BEFORE_COMPLETION);
 	}
 
+	@Override
 	public void setAutoCloseSessionEnabled(String enabled) {
 		setProperty(Environment.AUTO_CLOSE_SESSION, enabled);
 	}
 
+	@Override
 	public String getAutoCloseSessionEnabled() {
 		return getProperty(Environment.AUTO_CLOSE_SESSION);
 	}
 
 	public Properties getProperties() {
 		return buildProperties();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
index d161c7f0cf..13e768405d 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
@@ -1,333 +1,336 @@
 //$Id: HibernateServiceMBean.java 10860 2006-11-22 00:02:55Z steve.ebersole@jboss.com $
 package org.hibernate.jmx;
 
 import org.hibernate.HibernateException;
 
 /**
  * Hibernate JMX Management API
  * @see HibernateService
  * @author John Urberg, Gavin King
  */
 public interface HibernateServiceMBean {
 
 	/**
 	 * The Hibernate mapping files (might be overridden by subclasses
 	 * that want to specify the mapping files by some other mechanism)
 	 * @return String
 	 */
 	public String getMapResources();
 	/**
 	 * Specify the Hibernate mapping files
 	 * @param mappingFiles
 	 */
 	public void setMapResources(String mappingFiles);
 	/**
 	 * Add a mapping file
 	 * @param mapResource
 	 */
 	public void addMapResource(String mapResource);
 
 	/**
 	 * Set a property
 	 * @param property the property name
 	 * @param value the property value
 	 */
 	public void setProperty(String property, String value);
 
 	/**
 	 * Get a property
 	 * @param property the property name
 	 * @return the property value
 	 */
 	public String getProperty(String property);
 
 	/**
 	 * Display the properties
 	 * @return a list of property names and values
 	 */
 	public String getPropertyList();
 
 	/**
 	 * The JNDI name of the datasource to use in this <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getDatasource();
 	/**
 	 * Set the JNDI name of the datasource to use in this <tt>SessionFactory</tt>
 	 * @param datasource
 	 */
 	public void setDatasource(String datasource);
 
 	/**
 	 * Log into the database with this name
 	 * @return String
 	 */
 	public String getUserName();
 	/**
 	 * Log into the database with this name
 	 * @param userName
 	 */
 	public void setUserName(String userName);
 
 	/**
 	 * Log into the database with this password
 	 * @return String
 	 */
 	public String getPassword();
 	/**
 	 * Log into the database with this password
 	 * @param password
 	 */
 	public void setPassword(String password);
 
 	/**
 	 * The JNDI name of the dialect class to use in this <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getDialect();
 	/**
 	 * The name of the dialect class to use in this <tt>SessionFactory</tt>
 	 * @param dialect fully qualified class name of <tt>Dialect</tt> subclass
 	 * @see org.hibernate.dialect.Dialect
 	 */
 	public void setDialect(String dialect);
 
 	/**
 	 * The JNDI name to bind to the <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getJndiName();
 	/**
 	 * The JNDI name to bind to the <tt>SessionFactory</tt>
 	 * @param jndiName
 	 */
 	public void setJndiName(String jndiName);
 
 	/**
-	 * The fully qualified class name of the Hibernate <tt>TransactionFactory</tt> implementation
+	 * The fully qualified class name of the Hibernate {@link org.hibernate.engine.transaction.spi.TransactionFactory}
+	 * implementation to use
+	 *
 	 * @return the class name
-	 * @see org.hibernate.transaction.TransactionFactory
 	 */
 	public String getTransactionStrategy();
 
 	/**
-	 * Set the fully qualified class name of the Hibernate <tt>TransactionFactory</tt> implementation
+	 * Set the fully qualified class name of the Hibernate {@link org.hibernate.engine.transaction.spi.TransactionFactory}
+	 * implementation to use.
+	 *
 	 * @param txnStrategy the class name
-	 * @see org.hibernate.transaction.TransactionFactory
 	 */
 	public void setTransactionStrategy(String txnStrategy);
 
 	/**
-	 * The JNDI name of the JTA UserTransaction object (used only be <tt>JTATransaction</tt>).
+	 * The JNDI name of the JTA UserTransaction object (used only be <tt>JtaTransaction</tt>).
 	 * @return the JNDI name
-	 * @see org.hibernate.transaction.JTATransaction
+	 * @see org.hibernate.engine.transaction.internal.jta.JtaTransaction
 	 */
 	public String getUserTransactionName();
 	/**
-	 * Set the JNDI name of the JTA UserTransaction object (used only by <tt>JTATransaction</tt>).
+	 * Set the JNDI name of the JTA UserTransaction object (used only by <tt>JtaTransaction</tt>).
 	 * @param utName the JNDI name
-	 * @see org.hibernate.transaction.JTATransaction
+	 * @see org.hibernate.engine.transaction.internal.jta.JtaTransaction
 	 */
 	public void setUserTransactionName(String utName);
 
 	/**
-	 * Get the strategy for obtaining the JTA <tt>TransactionManager</tt>
-	 * @return the class name
-	 * @see org.hibernate.transaction.TransactionManagerLookup
+	 * Get the name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
+	 *
+	 * @return The name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
 	 */
-	public String getTransactionManagerLookupStrategy();
+	public String getJtaPlatformName();
+
 	/**
-	 * Set the strategy for obtaining the JTA <tt>TransactionManager</tt>
-	 * @param lkpStrategy the class name
-	 * @see org.hibernate.transaction.TransactionManagerLookup
+	 * Sets the name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
+	 *
+	 * @param name The implementation class name.
 	 */
-	public void setTransactionManagerLookupStrategy(String lkpStrategy);
+	public void setJtaPlatformName(String name);
 
 	/**
 	 * Is SQL logging enabled?
 	 */
 	public String getShowSqlEnabled();
 	/**
 	 * Enable logging of SQL to console
 	 */
 	public void setShowSqlEnabled(String showSql);
 	/**
 	 * Get the maximum outer join fetch depth
 	 */
 	public String getMaximumFetchDepth();
 	/**
 	 * Set the maximum outer join fetch depth
 	 */
 	public void setMaximumFetchDepth(String fetchDepth);
 	/**
 	 * Get the maximum JDBC batch size
 	 */
 	public String getJdbcBatchSize();
 	/**
 	 * Set the maximum JDBC batch size
 	 */
 	public void setJdbcBatchSize(String batchSize);
 	/**
 	 * Get the JDBC fetch size
 	 */
 	public String getJdbcFetchSize();
 	/**
 	 * Set the JDBC fetch size
 	 */
 	public void setJdbcFetchSize(String fetchSize);
 	/**
 	 * Get the query language substitutions
 	 */
 	public String getQuerySubstitutions();
 	/**
 	 * Set the query language substitutions
 	 */
 	public void setQuerySubstitutions(String querySubstitutions);
 	/**
 	 * Get the default schema
 	 */
 	public String getDefaultSchema();
 	/**
 	 * Set the default schema
 	 */
 	public void setDefaultSchema(String schema);
 	/**
 	 * Get the default catalog
 	 */
 	public String getDefaultCatalog();
 	/**
 	 * Set the default catalog
 	 */
 	public void setDefaultCatalog(String catalog);
 	/**
 	 * Is use of scrollable resultsets enabled?
 	 */
 	public String getJdbcScrollableResultSetEnabled();
 	/**
 	 * Enable or disable the use of scrollable resultsets 
 	 */
 	public void setJdbcScrollableResultSetEnabled(String enabled);
 	/**
 	 * Is use of JDBC3 <tt>getGeneratedKeys()</tt> enabled?
 	 */
 	public String getGetGeneratedKeysEnabled();
 	/**
 	 * Enable or disable the use <tt>getGeneratedKeys()</tt> 
 	 */
 	public void setGetGeneratedKeysEnabled(String enabled);
 	/**
 	 * Get the second-level cache provider class name
 	 */
 	public String getCacheProviderClass();
 	/**
 	 * Set the second-level cache provider class name
 	 */
 	public void setCacheProviderClass(String providerClassName);
 	/**
 	 * For cache providers which support this setting, get the
 	 * provider's specific configuration resource.
 	 */
 	public String getCacheProviderConfig();
 	/**
 	 * For cache providers which support this setting, specify the
 	 * provider's specific configuration resource.
 	 */
 	public void setCacheProviderConfig(String cacheProviderConfig);
 	/**
 	 * Is the query cache enabled?
 	 */
 	public String getQueryCacheEnabled();
 	/**
 	 * Enable or disable the query cache
 	 */
 	public void setQueryCacheEnabled(String enabled);
 	/**
 	 * Is the second-level cache enabled?
 	 */
 	public String getSecondLevelCacheEnabled();
 	/**
 	 * Enable or disable the second-level cache
 	 */
 	public void setSecondLevelCacheEnabled(String enabled);
 	/**
 	 * Get the cache region prefix
 	 */
 	public String getCacheRegionPrefix();
 	/**
 	 * Set the cache region prefix
 	 */
 	public void setCacheRegionPrefix(String prefix);
 	/**
 	 * Is the second-level cache optimized for miminal puts?
 	 */
 	public String getMinimalPutsEnabled();
 	/**
 	 * Enable or disable optimization of second-level cache
 	 * for minimal puts 
 	 */
 	public void setMinimalPutsEnabled(String enabled);
 	/**
 	 * Are SQL comments enabled?
 	 */
 	public String getCommentsEnabled();
 	/**
 	 * Enable or disable the inclusion of comments in
 	 * generated SQL
 	 */
 	public void setCommentsEnabled(String enabled);
 	/**
 	 * Is JDBC batch update for versioned entities enabled?
 	 */
 	public String getBatchVersionedDataEnabled();
 	/**
 	 * Enable or disable the use of batch updates for
 	 * versioned entities
 	 */
 	public void setBatchVersionedDataEnabled(String enabled);
 	
 	/**
 	 * Enable automatic flushing of the Session when JTA transaction ends.
 	 */
 	public void setFlushBeforeCompletionEnabled(String enabled);
 	/**
 	 * Is automatic Session flusing enabled?
 	 */
 	public String getFlushBeforeCompletionEnabled();
 
 	/**
 	 * Enable automatic closing of Session when JTA transaction ends.
 	 */
 	public void setAutoCloseSessionEnabled(String enabled);
 	/**
 	 * Is automatic Session closing enabled?
 	 */
 	public String getAutoCloseSessionEnabled();
 
 	/**
 	 * Export the <tt>CREATE</tt> DDL to the database
 	 * @throws HibernateException
 	 */
 	public void createSchema() throws HibernateException;
 	/**
 	 * Export the <tt>DROP</tt> DDL to the database
 	 * @throws HibernateException
 	 */
 	public void dropSchema() throws HibernateException;
 
 
 	/**
 	 * Create the <tt>SessionFactory</tt> and bind to the jndi name on startup
 	 */
 	public void start() throws HibernateException;
 	/**
 	 * Unbind the <tt>SessionFactory</tt> or stub from JNDI
 	 */
 	public void stop();
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
index b0e8d6ca91..2f67dd3e74 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
@@ -734,1910 +734,1916 @@ public abstract class Loader {
 									targetIndex,
 									persisters[targetIndex],
 									keys[targetIndex],
 									object,
 									lockModes[targetIndex],
 									session
 							);
 						}
 						else {
 							object = instanceNotYetLoaded(
 									resultSet,
 									targetIndex,
 									persisters[targetIndex],
 									getEntityAliases()[targetIndex].getRowIdAlias(),
 									keys[targetIndex],
 									lockModes[targetIndex],
 									getOptionalObjectKey( queryParameters, session ),
 									queryParameters.getOptionalObject(),
 									hydratedObjects,
 									session
 							);
 						}
 					}
 				}
 			}
 			final Serializable resolvedId = (Serializable) idType.resolve( hydratedKeyState[i], session, null );
 			keys[i] = resolvedId == null ? null : new EntityKey( resolvedId, persisters[i], session.getEntityMode() );
 		}
 	}
 
 	private Serializable determineResultId(SessionImplementor session, Serializable optionalId, Type idType, Serializable resolvedId) {
 		final boolean idIsResultId = optionalId != null
 				&& resolvedId != null
 				&& idType.isEqual( optionalId, resolvedId, session.getEntityMode(), factory );
 		final Serializable resultId = idIsResultId ? optionalId : resolvedId;
 		return resultId;
 	}
 
 	protected void applyPostLoadLocks(Object[] row, LockMode[] lockModesArray, SessionImplementor session) {
 	}
 
 	/**
 	 * Read any collection elements contained in a single row of the result set
 	 */
 	private void readCollectionElements(Object[] row, ResultSet resultSet, SessionImplementor session)
 			throws SQLException, HibernateException {
 
 		//TODO: make this handle multiple collection roles!
 
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 
 			final CollectionAliases[] descriptors = getCollectionAliases();
 			final int[] collectionOwners = getCollectionOwners();
 
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 
 				final boolean hasCollectionOwners = collectionOwners !=null && 
 						collectionOwners[i] > -1;
 				//true if this is a query and we are loading multiple instances of the same collection role
 				//otherwise this is a CollectionInitializer and we are loading up a single collection or batch
 				
 				final Object owner = hasCollectionOwners ?
 						row[ collectionOwners[i] ] :
 						null; //if null, owner will be retrieved from session
 
 				final CollectionPersister collectionPersister = collectionPersisters[i];
 				final Serializable key;
 				if ( owner == null ) {
 					key = null;
 				}
 				else {
 					key = collectionPersister.getCollectionType().getKeyOfOwner( owner, session );
 					//TODO: old version did not require hashmap lookup:
 					//keys[collectionOwner].getIdentifier()
 				}
 	
 				readCollectionElement( 
 						owner, 
 						key, 
 						collectionPersister, 
 						descriptors[i], 
 						resultSet, 
 						session 
 					);
 				
 			}
 
 		}
 	}
 
 	private List doQuery(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies,
 			final ResultTransformer forcedResultTransformer) throws SQLException, HibernateException {
 
 		final RowSelection selection = queryParameters.getRowSelection();
 		final int maxRows = hasMaxRows( selection ) ?
 				selection.getMaxRows().intValue() :
 				Integer.MAX_VALUE;
 
 		final int entitySpan = getEntityPersisters().length;
 
 		final ArrayList hydratedObjects = entitySpan == 0 ? null : new ArrayList( entitySpan * 10 );
 		final PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 		final ResultSet rs = getResultSet( st, queryParameters.hasAutoDiscoverScalarTypes(), queryParameters.isCallable(), selection, session );
 
 // would be great to move all this below here into another method that could also be used
 // from the new scrolling stuff.
 //
 // Would need to change the way the max-row stuff is handled (i.e. behind an interface) so
 // that I could do the control breaking at the means to know when to stop
 
 		final EntityKey optionalObjectKey = getOptionalObjectKey( queryParameters, session );
 		final LockMode[] lockModesArray = getLockModes( queryParameters.getLockOptions() );
 		final boolean createSubselects = isSubselectLoadingEnabled();
 		final List subselectResultKeys = createSubselects ? new ArrayList() : null;
 		final List results = new ArrayList();
 
 		try {
 
 			handleEmptyCollections( queryParameters.getCollectionKeys(), rs, session );
 
 			EntityKey[] keys = new EntityKey[entitySpan]; //we can reuse it for each row
 
 			if ( log.isTraceEnabled() ) log.trace( "processing result set" );
 
 			int count;
 			for ( count = 0; count < maxRows && rs.next(); count++ ) {
 				
 				if ( log.isTraceEnabled() ) log.debug("result set row: " + count);
 
 				Object result = getRowFromResultSet( 
 						rs,
 						session,
 						queryParameters,
 						lockModesArray,
 						optionalObjectKey,
 						hydratedObjects,
 						keys,
 						returnProxies,
 						forcedResultTransformer
 				);
 				results.add( result );
 
 				if ( createSubselects ) {
 					subselectResultKeys.add(keys);
 					keys = new EntityKey[entitySpan]; //can't reuse in this case
 				}
 				
 			}
 
 			if ( log.isTraceEnabled() ) {
 				log.trace( "done processing result set (" + count + " rows)" );
 			}
 
 		}
 		finally {
 			st.close();
 		}
 
 		initializeEntitiesAndCollections( hydratedObjects, rs, session, queryParameters.isReadOnly( session ) );
 
 		if ( createSubselects ) createSubselects( subselectResultKeys, queryParameters, session );
 
 		return results; //getResultList(results);
 
 	}
 
 	protected boolean isSubselectLoadingEnabled() {
 		return false;
 	}
 	
 	protected boolean hasSubselectLoadableCollections() {
 		final Loadable[] loadables = getEntityPersisters();
 		for (int i=0; i<loadables.length; i++ ) {
 			if ( loadables[i].hasSubselectLoadableCollections() ) return true;
 		}
 		return false;
 	}
 	
 	private static Set[] transpose( List keys ) {
 		Set[] result = new Set[ ( ( EntityKey[] ) keys.get(0) ).length ];
 		for ( int j=0; j<result.length; j++ ) {
 			result[j] = new HashSet( keys.size() );
 			for ( int i=0; i<keys.size(); i++ ) {
 				result[j].add( ( ( EntityKey[] ) keys.get(i) ) [j] );
 			}
 		}
 		return result;
 	}
 
 	private void createSubselects(List keys, QueryParameters queryParameters, SessionImplementor session) {
 		if ( keys.size() > 1 ) { //if we only returned one entity, query by key is more efficient
 			
 			Set[] keySets = transpose(keys);
 			
 			Map namedParameterLocMap = buildNamedParameterLocMap( queryParameters );
 			
 			final Loadable[] loadables = getEntityPersisters();
 			final String[] aliases = getAliases();
 			final Iterator iter = keys.iterator();
 			while ( iter.hasNext() ) {
 				
 				final EntityKey[] rowKeys = (EntityKey[]) iter.next();
 				for ( int i=0; i<rowKeys.length; i++ ) {
 					
 					if ( rowKeys[i]!=null && loadables[i].hasSubselectLoadableCollections() ) {
 						
 						SubselectFetch subselectFetch = new SubselectFetch( 
 								//getSQLString(), 
 								aliases[i], 
 								loadables[i], 
 								queryParameters, 
 								keySets[i],
 								namedParameterLocMap
 							);
 						
 						session.getPersistenceContext()
 								.getBatchFetchQueue()
 								.addSubselect( rowKeys[i], subselectFetch );
 					}
 					
 				}
 				
 			}
 		}
 	}
 
 	private Map buildNamedParameterLocMap(QueryParameters queryParameters) {
 		if ( queryParameters.getNamedParameters()!=null ) {
 			final Map namedParameterLocMap = new HashMap();
 			Iterator piter = queryParameters.getNamedParameters().keySet().iterator();
 			while ( piter.hasNext() ) {
 				String name = (String) piter.next();
 				namedParameterLocMap.put(
 						name,
 						getNamedParameterLocs(name)
 					);
 			}
 			return namedParameterLocMap;
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void initializeEntitiesAndCollections(
 			final List hydratedObjects,
 			final Object resultSetId,
 			final SessionImplementor session,
 			final boolean readOnly) 
 	throws HibernateException {
 		
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( collectionPersisters[i].isArray() ) {
 					//for arrays, we should end the collection load before resolving
 					//the entities, since the actual array instances are not instantiated
 					//during loading
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 
 		//important: reuse the same event instances for performance!
 		final PreLoadEvent pre;
 		final PostLoadEvent post;
 		if ( session.isEventSource() ) {
 			pre = new PreLoadEvent( (EventSource) session );
 			post = new PostLoadEvent( (EventSource) session );
 		}
 		else {
 			pre = null;
 			post = null;
 		}
 		
 		if ( hydratedObjects!=null ) {
 			int hydratedObjectsSize = hydratedObjects.size();
 			if ( log.isTraceEnabled() ) {
 				log.trace( "total objects hydrated: " + hydratedObjectsSize );
 			}
 			for ( int i = 0; i < hydratedObjectsSize; i++ ) {
 				TwoPhaseLoad.initializeEntity( hydratedObjects.get(i), readOnly, session, pre, post );
 			}
 		}
 		
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( !collectionPersisters[i].isArray() ) {
 					//for sets, we should end the collection load after resolving
 					//the entities, since we might call hashCode() on the elements
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 		
 	}
 
 	private void endCollectionLoad(
 			final Object resultSetId, 
 			final SessionImplementor session, 
 			final CollectionPersister collectionPersister) {
 		//this is a query and we are loading multiple instances of the same collection role
 		session.getPersistenceContext()
 				.getLoadContexts()
 				.getCollectionLoadContext( ( ResultSet ) resultSetId )
 				.endLoadingCollections( collectionPersister );
 	}
 
 	/**
 	 * Determine the actual ResultTransformer that will be used to
 	 * transform query results.
 	 *
 	 * @param resultTransformer the specified result transformer
 	 * @return the actual result transformer
 	 */
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return resultTransformer;
 	}
 
 	protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		return results;
 	}
 
 	/**
 	 * Are rows transformed immediately after being read from the ResultSet?
 	 * @return true, if getResultColumnOrRow() transforms the results; false, otherwise
 	 */
 	protected boolean areResultSetRowsTransformedImmediately() {
 		return false;
 	}
 
 	/**
 	 * Returns the aliases that corresponding to a result row.
 	 * @return Returns the aliases that corresponding to a result row.
 	 */
 	protected String[] getResultRowAliases() {
 		 return null;
 	}
 
 	/**
 	 * Get the actual object that is returned in the user-visible result list.
 	 * This empty implementation merely returns its first argument. This is
 	 * overridden by some subclasses.
 	 */
 	protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		return row;
 	}
 
 	protected boolean[] includeInResultRow() {
 		return null;
 	}
 
 	protected Object[] getResultRow(Object[] row,
 														 ResultSet rs,
 														 SessionImplementor session)
 			throws SQLException, HibernateException {
 		return row;
 	}
 	
 	/**
 	 * For missing objects associated by one-to-one with another object in the
 	 * result set, register the fact that the the object is missing with the
 	 * session.
 	 */
 	private void registerNonExists(
 	        final EntityKey[] keys,
 	        final Loadable[] persisters,
 	        final SessionImplementor session) {
 		
 		final int[] owners = getOwners();
 		if ( owners != null ) {
 			
 			EntityType[] ownerAssociationTypes = getOwnerAssociationTypes();
 			for ( int i = 0; i < keys.length; i++ ) {
 				
 				int owner = owners[i];
 				if ( owner > -1 ) {
 					EntityKey ownerKey = keys[owner];
 					if ( keys[i] == null && ownerKey != null ) {
 						
 						final PersistenceContext persistenceContext = session.getPersistenceContext();
 						
 						/*final boolean isPrimaryKey;
 						final boolean isSpecialOneToOne;
 						if ( ownerAssociationTypes == null || ownerAssociationTypes[i] == null ) {
 							isPrimaryKey = true;
 							isSpecialOneToOne = false;
 						}
 						else {
 							isPrimaryKey = ownerAssociationTypes[i].getRHSUniqueKeyPropertyName()==null;
 							isSpecialOneToOne = ownerAssociationTypes[i].getLHSPropertyName()!=null;
 						}*/
 						
 						//TODO: can we *always* use the "null property" approach for everything?
 						/*if ( isPrimaryKey && !isSpecialOneToOne ) {
 							persistenceContext.addNonExistantEntityKey( 
 									new EntityKey( ownerKey.getIdentifier(), persisters[i], session.getEntityMode() ) 
 							);
 						}
 						else if ( isSpecialOneToOne ) {*/
 						boolean isOneToOneAssociation = ownerAssociationTypes!=null && 
 								ownerAssociationTypes[i]!=null && 
 								ownerAssociationTypes[i].isOneToOne();
 						if ( isOneToOneAssociation ) {
 							persistenceContext.addNullProperty( ownerKey, 
 									ownerAssociationTypes[i].getPropertyName() );
 						}
 						/*}
 						else {
 							persistenceContext.addNonExistantEntityUniqueKey( new EntityUniqueKey( 
 									persisters[i].getEntityName(),
 									ownerAssociationTypes[i].getRHSUniqueKeyPropertyName(),
 									ownerKey.getIdentifier(),
 									persisters[owner].getIdentifierType(),
 									session.getEntityMode()
 							) );
 						}*/
 					}
 				}
 			}
 		}
 	}
 
 	/**
 	 * Read one collection element from the current row of the JDBC result set
 	 */
 	private void readCollectionElement(
 	        final Object optionalOwner,
 	        final Serializable optionalKey,
 	        final CollectionPersister persister,
 	        final CollectionAliases descriptor,
 	        final ResultSet rs,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 
 		final Serializable collectionRowKey = (Serializable) persister.readKey( 
 				rs, 
 				descriptor.getSuffixedKeyAliases(), 
 				session 
 			);
 		
 		if ( collectionRowKey != null ) {
 			// we found a collection element in the result set
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"found row of collection: " +
 						MessageHelper.collectionInfoString( persister, collectionRowKey, getFactory() ) 
 					);
 			}
 
 			Object owner = optionalOwner;
 			if ( owner == null ) {
 				owner = persistenceContext.getCollectionOwner( collectionRowKey, persister );
 				if ( owner == null ) {
 					//TODO: This is assertion is disabled because there is a bug that means the
 					//	  original owner of a transient, uninitialized collection is not known
 					//	  if the collection is re-referenced by a different object associated
 					//	  with the current Session
 					//throw new AssertionFailure("bug loading unowned collection");
 				}
 			}
 
 			PersistentCollection rowCollection = persistenceContext.getLoadContexts()
 					.getCollectionLoadContext( rs )
 					.getLoadingCollection( persister, collectionRowKey );
 
 			if ( rowCollection != null ) {
 				rowCollection.readFrom( rs, persister, descriptor, owner );
 			}
 
 		}
 		else if ( optionalKey != null ) {
 			// we did not find a collection element in the result set, so we
 			// ensure that a collection is created with the owner's identifier,
 			// since what we have is an empty collection
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"result set contains (possibly empty) collection: " +
 						MessageHelper.collectionInfoString( persister, optionalKey, getFactory() ) 
 					);
 			}
 
 			persistenceContext.getLoadContexts()
 					.getCollectionLoadContext( rs )
 					.getLoadingCollection( persister, optionalKey ); // handle empty collection
 
 		}
 
 		// else no collection element, but also no owner
 
 	}
 
 	/**
 	 * If this is a collection initializer, we need to tell the session that a collection
 	 * is being initialized, to account for the possibility of the collection having
 	 * no elements (hence no rows in the result set).
 	 */
 	private void handleEmptyCollections(
 	        final Serializable[] keys,
 	        final Object resultSetId,
 	        final SessionImplementor session) {
 
 		if ( keys != null ) {
 			// this is a collection initializer, so we must create a collection
 			// for each of the passed-in keys, to account for the possibility
 			// that the collection is empty and has no rows in the result set
 
 			CollectionPersister[] collectionPersisters = getCollectionPersisters();
 			for ( int j=0; j<collectionPersisters.length; j++ ) {
 				for ( int i = 0; i < keys.length; i++ ) {
 					//handle empty collections
 	
 					if ( log.isDebugEnabled() ) {
 						log.debug( 
 								"result set contains (possibly empty) collection: " +
 								MessageHelper.collectionInfoString( collectionPersisters[j], keys[i], getFactory() ) 
 							);
 					}
 
 					session.getPersistenceContext()
 							.getLoadContexts()
 							.getCollectionLoadContext( ( ResultSet ) resultSetId )
 							.getLoadingCollection( collectionPersisters[j], keys[i] );
 				}
 			}
 		}
 
 		// else this is not a collection initializer (and empty collections will
 		// be detected by looking for the owner's identifier in the result set)
 	}
 
 	/**
 	 * Read a row of <tt>Key</tt>s from the <tt>ResultSet</tt> into the given array.
 	 * Warning: this method is side-effecty.
 	 * <p/>
 	 * If an <tt>id</tt> is given, don't bother going to the <tt>ResultSet</tt>.
 	 */
 	private EntityKey getKeyFromResultSet(
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final ResultSet rs,
 	        final SessionImplementor session) throws HibernateException, SQLException {
 
 		Serializable resultId;
 
 		// if we know there is exactly 1 row, we can skip.
 		// it would be great if we could _always_ skip this;
 		// it is a problem for <key-many-to-one>
 
 		if ( isSingleRowLoader() && id != null ) {
 			resultId = id;
 		}
 		else {
 			
 			Type idType = persister.getIdentifierType();
 			resultId = (Serializable) idType.nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedKeyAliases(),
 					session,
 					null //problematic for <key-many-to-one>!
 				);
 			
 			final boolean idIsResultId = id != null && 
 					resultId != null && 
 					idType.isEqual( id, resultId, session.getEntityMode(), factory );
 			
 			if ( idIsResultId ) resultId = id; //use the id passed in
 		}
 
 		return resultId == null ?
 				null :
 				new EntityKey( resultId, persister, session.getEntityMode() );
 	}
 
 	/**
 	 * Check the version of the object in the <tt>ResultSet</tt> against
 	 * the object version in the session cache, throwing an exception
 	 * if the version numbers are different
 	 */
 	private void checkVersion(
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final Object entity,
 	        final ResultSet rs,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 
 		Object version = session.getPersistenceContext().getEntry( entity ).getVersion();
 
 		if ( version != null ) { //null version means the object is in the process of being loaded somewhere else in the ResultSet
 			VersionType versionType = persister.getVersionType();
 			Object currentVersion = versionType.nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedVersionAliases(),
 					session,
 					null
 				);
 			if ( !versionType.isEqual(version, currentVersion) ) {
 				if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
 					session.getFactory().getStatisticsImplementor()
 							.optimisticFailure( persister.getEntityName() );
 				}
 				throw new StaleObjectStateException( persister.getEntityName(), id );
 			}
 		}
 
 	}
 
 	/**
 	 * Resolve any IDs for currently loaded objects, duplications within the
 	 * <tt>ResultSet</tt>, etc. Instantiate empty objects to be initialized from the
 	 * <tt>ResultSet</tt>. Return an array of objects (a row of results) and an
 	 * array of booleans (by side-effect) that determine whether the corresponding
 	 * object should be initialized.
 	 */
 	private Object[] getRow(
 	        final ResultSet rs,
 	        final Loadable[] persisters,
 	        final EntityKey[] keys,
 	        final Object optionalObject,
 	        final EntityKey optionalObjectKey,
 	        final LockMode[] lockModes,
 	        final List hydratedObjects,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 
 		final int cols = persisters.length;
 		final EntityAliases[] descriptors = getEntityAliases();
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( 
 					"result row: " + 
 					StringHelper.toString( keys ) 
 				);
 		}
 
 		final Object[] rowResults = new Object[cols];
 
 		for ( int i = 0; i < cols; i++ ) {
 
 			Object object = null;
 			EntityKey key = keys[i];
 
 			if ( keys[i] == null ) {
 				//do nothing
 			}
 			else {
 
 				//If the object is already loaded, return the loaded one
 				object = session.getEntityUsingInterceptor( key );
 				if ( object != null ) {
 					//its already loaded so don't need to hydrate it
 					instanceAlreadyLoaded( 
 							rs,
 							i,
 							persisters[i],
 							key,
 							object,
 							lockModes[i],
 							session 
 						);
 				}
 				else {
 					object = instanceNotYetLoaded( 
 							rs,
 							i,
 							persisters[i],
 							descriptors[i].getRowIdAlias(),
 							key,
 							lockModes[i],
 							optionalObjectKey,
 							optionalObject,
 							hydratedObjects,
 							session 
 						);
 				}
 
 			}
 
 			rowResults[i] = object;
 
 		}
 
 		return rowResults;
 	}
 
 	/**
 	 * The entity instance is already in the session cache
 	 */
 	private void instanceAlreadyLoaded(
 	        final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final EntityKey key,
 	        final Object object,
 	        final LockMode lockMode,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 		if ( !persister.isInstance( object, session.getEntityMode() ) ) {
 			throw new WrongClassException( 
 					"loaded object was of wrong class " + object.getClass(), 
 					key.getIdentifier(), 
 					persister.getEntityName() 
 				);
 		}
 
 		if ( LockMode.NONE != lockMode && upgradeLocks() ) { //no point doing this if NONE was requested
 
 			final boolean isVersionCheckNeeded = persister.isVersioned() &&
 					session.getPersistenceContext().getEntry(object)
 							.getLockMode().lessThan( lockMode );
 			// we don't need to worry about existing version being uninitialized
 			// because this block isn't called by a re-entrant load (re-entrant
 			// loads _always_ have lock mode NONE)
 			if (isVersionCheckNeeded) {
 				//we only check the version when _upgrading_ lock modes
 				checkVersion( i, persister, key.getIdentifier(), object, rs, session );
 				//we need to upgrade the lock mode to the mode requested
 				session.getPersistenceContext().getEntry(object)
 						.setLockMode(lockMode);
 			}
 		}
 	}
 
 	/**
 	 * The entity instance is not in the session cache
 	 */
 	private Object instanceNotYetLoaded(
 	        final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final String rowIdAlias,
 	        final EntityKey key,
 	        final LockMode lockMode,
 	        final EntityKey optionalObjectKey,
 	        final Object optionalObject,
 	        final List hydratedObjects,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 		final String instanceClass = getInstanceClass(
 				rs, 
 				i, 
 				persister, 
 				key.getIdentifier(), 
 				session 
 			);
 
 		final Object object;
 		if ( optionalObjectKey != null && key.equals( optionalObjectKey ) ) {
 			//its the given optional object
 			object = optionalObject;
 		}
 		else {
 			// instantiate a new instance
 			object = session.instantiate( instanceClass, key.getIdentifier() );
 		}
 
 		//need to hydrate it.
 
 		// grab its state from the ResultSet and keep it in the Session
 		// (but don't yet initialize the object itself)
 		// note that we acquire LockMode.READ even if it was not requested
 		LockMode acquiredLockMode = lockMode == LockMode.NONE ? LockMode.READ : lockMode;
 		loadFromResultSet( 
 				rs, 
 				i, 
 				object, 
 				instanceClass, 
 				key, 
 				rowIdAlias, 
 				acquiredLockMode, 
 				persister, 
 				session 
 			);
 
 		//materialize associations (and initialize the object) later
 		hydratedObjects.add( object );
 
 		return object;
 	}
 	
 	private boolean isEagerPropertyFetchEnabled(int i) {
 		boolean[] array = getEntityEagerPropertyFetches();
 		return array!=null && array[i];
 	}
 
 
 	/**
 	 * Hydrate the state an object from the SQL <tt>ResultSet</tt>, into
 	 * an array or "hydrated" values (do not resolve associations yet),
 	 * and pass the hydrates state to the session.
 	 */
 	private void loadFromResultSet(
 	        final ResultSet rs,
 	        final int i,
 	        final Object object,
 	        final String instanceEntityName,
 	        final EntityKey key,
 	        final String rowIdAlias,
 	        final LockMode lockMode,
 	        final Loadable rootPersister,
 	        final SessionImplementor session) 
 	throws SQLException, HibernateException {
 
 		final Serializable id = key.getIdentifier();
 
 		// Get the persister for the _subclass_
 		final Loadable persister = (Loadable) getFactory().getEntityPersister( instanceEntityName );
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( 
 					"Initializing object from ResultSet: " + 
 					MessageHelper.infoString( persister, id, getFactory() ) 
 				);
 		}
 		
 		boolean eagerPropertyFetch = isEagerPropertyFetchEnabled(i);
 
 		// add temp entry so that the next step is circular-reference
 		// safe - only needed because some types don't take proper
 		// advantage of two-phase-load (esp. components)
 		TwoPhaseLoad.addUninitializedEntity( 
 				key, 
 				object, 
 				persister, 
 				lockMode, 
 				!eagerPropertyFetch, 
 				session 
 			);
 
 		//This is not very nice (and quite slow):
 		final String[][] cols = persister == rootPersister ?
 				getEntityAliases()[i].getSuffixedPropertyAliases() :
 				getEntityAliases()[i].getSuffixedPropertyAliases(persister);
 
 		final Object[] values = persister.hydrate( 
 				rs, 
 				id, 
 				object, 
 				rootPersister, 
 				cols, 
 				eagerPropertyFetch, 
 				session 
 			);
 
 		final Object rowId = persister.hasRowId() ? rs.getObject(rowIdAlias) : null;
 
 		final AssociationType[] ownerAssociationTypes = getOwnerAssociationTypes();
 		if ( ownerAssociationTypes != null && ownerAssociationTypes[i] != null ) {
 			String ukName = ownerAssociationTypes[i].getRHSUniqueKeyPropertyName();
 			if (ukName!=null) {
 				final int index = ( (UniqueKeyLoadable) persister ).getPropertyIndex(ukName);
 				final Type type = persister.getPropertyTypes()[index];
 	
 				// polymorphism not really handled completely correctly,
 				// perhaps...well, actually its ok, assuming that the
 				// entity name used in the lookup is the same as the
 				// the one used here, which it will be
 	
 				EntityUniqueKey euk = new EntityUniqueKey( 
 						rootPersister.getEntityName(), //polymorphism comment above
 						ukName,
 						type.semiResolve( values[index], session, object ),
 						type,
 						session.getEntityMode(), session.getFactory()
 					);
 				session.getPersistenceContext().addEntity( euk, object );
 			}
 		}
 
 		TwoPhaseLoad.postHydrate( 
 				persister, 
 				id, 
 				values, 
 				rowId, 
 				object, 
 				lockMode, 
 				!eagerPropertyFetch, 
 				session 
 			);
 
 	}
 
 	/**
 	 * Determine the concrete class of an instance in the <tt>ResultSet</tt>
 	 */
 	private String getInstanceClass(
 	        final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final SessionImplementor session) 
 	throws HibernateException, SQLException {
 
 		if ( persister.hasSubclasses() ) {
 
 			// Code to handle subclasses of topClass
 			Object discriminatorValue = persister.getDiscriminatorType().nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedDiscriminatorAlias(),
 					session,
 					null
 				);
 
 			final String result = persister.getSubclassForDiscriminatorValue( discriminatorValue );
 
 			if ( result == null ) {
 				//woops we got an instance of another class hierarchy branch
 				throw new WrongClassException( 
 						"Discriminator: " + discriminatorValue,
 						id,
 						persister.getEntityName() 
 					);
 			}
 
 			return result;
 
 		}
 		else {
 			return persister.getEntityName();
 		}
 	}
 
 	/**
 	 * Advance the cursor to the first required row of the <tt>ResultSet</tt>
 	 */
 	private void advance(final ResultSet rs, final RowSelection selection)
 			throws SQLException {
 
 		final int firstRow = getFirstRow( selection );
 		if ( firstRow != 0 ) {
 			if ( getFactory().getSettings().isScrollableResultSetsEnabled() ) {
 				// we can go straight to the first required row
 				rs.absolute( firstRow );
 			}
 			else {
 				// we need to step through the rows one row at a time (slow)
 				for ( int m = 0; m < firstRow; m++ ) rs.next();
 			}
 		}
 	}
 
 	private static boolean hasMaxRows(RowSelection selection) {
 		return selection != null && selection.getMaxRows() != null;
 	}
 
 	private static int getFirstRow(RowSelection selection) {
 		if ( selection == null || selection.getFirstRow() == null ) {
 			return 0;
 		}
 		else {
 			return selection.getFirstRow().intValue();
 		}
 	}
 
 	private int interpretFirstRow(int zeroBasedFirstResult) {
 		return getFactory().getDialect().convertToFirstRowValue( zeroBasedFirstResult );
 	}
 
 	/**
 	 * Should we pre-process the SQL string, adding a dialect-specific
 	 * LIMIT clause.
 	 */
 	private static boolean useLimit(final RowSelection selection, final Dialect dialect) {
 		return dialect.supportsLimit() && hasMaxRows( selection );
 	}
 
 	/**
 	 * Obtain a <tt>PreparedStatement</tt> with all parameters pre-bound.
 	 * Bind JDBC-style <tt>?</tt> parameters, named parameters, and
 	 * limit parameters.
 	 */
 	protected final PreparedStatement prepareQueryStatement(
 	        final QueryParameters queryParameters,
 	        final boolean scroll,
 	        final SessionImplementor session) throws SQLException, HibernateException {
 
 		queryParameters.processFilters( getSQLString(), session );
 		String sql = queryParameters.getFilteredSQL();
 		final Dialect dialect = getFactory().getDialect();
 		final RowSelection selection = queryParameters.getRowSelection();
 		boolean useLimit = useLimit( selection, dialect );
 		boolean hasFirstRow = getFirstRow( selection ) > 0;
 		boolean useOffset = hasFirstRow && useLimit && dialect.supportsLimitOffset();
 		boolean callable = queryParameters.isCallable();
-		
-		boolean useScrollableResultSetToSkip = hasFirstRow &&
+
+		final boolean canScroll = getFactory().getSettings().isScrollableResultSetsEnabled();
+		final boolean useScrollableResultSetToSkip = hasFirstRow &&
 				!useOffset &&
 				getFactory().getSettings().isScrollableResultSetsEnabled();
-		ScrollMode scrollMode = scroll ? queryParameters.getScrollMode() : ScrollMode.SCROLL_INSENSITIVE;
+		final ScrollMode scrollMode =
+				canScroll
+						? scroll || useScrollableResultSetToSkip
+								? queryParameters.getScrollMode()
+								: ScrollMode.SCROLL_INSENSITIVE
+						: null;
 
 		if ( useLimit ) {
 			sql = dialect.getLimitString( 
 					sql.trim(), //use of trim() here is ugly?
 					useOffset ? getFirstRow(selection) : 0, 
 					getMaxOrLimit(selection, dialect) 
 				);
 		}
 
 		sql = preprocessSQL( sql, queryParameters, dialect );
-		
+
 		PreparedStatement st = null;
 
-		st = session.getJDBCContext().getConnectionManager().prepareQueryStatement( 
+
+		st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareQueryStatement(
 				sql,
-				scroll || useScrollableResultSetToSkip,
-				scrollMode,
-				callable
+				callable,
+				scrollMode
 		);
 
 		try {
 
 			int col = 1;
 			//TODO: can we limit stored procedures ?!
 			if ( useLimit && dialect.bindLimitParametersFirst() ) {
 				col += bindLimitParameters( st, col, selection );
 			}
 			if (callable) {
 				col = dialect.registerResultSetOutParameter( (CallableStatement)st, col );
 			}
 
 			col += bindParameterValues( st, queryParameters, col, session );
 
 			if ( useLimit && !dialect.bindLimitParametersFirst() ) {
 				col += bindLimitParameters( st, col, selection );
 			}
 
 			if ( !useLimit ) {
 				setMaxRows( st, selection );
 			}
 
 			if ( selection != null ) {
 				if ( selection.getTimeout() != null ) {
 					st.setQueryTimeout( selection.getTimeout().intValue() );
 				}
 				if ( selection.getFetchSize() != null ) {
 					st.setFetchSize( selection.getFetchSize().intValue() );
 				}
 			}
 
 			// handle lock timeout...
 			LockOptions lockOptions = queryParameters.getLockOptions();
 			if ( lockOptions != null ) {
 				if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
 					if ( !dialect.supportsLockTimeouts() ) {
 						log.debug(
 								"Lock timeout [" + lockOptions.getTimeOut() +
 										"] requested but dialect reported to not support lock timeouts"
 						);
 					}
 					else if ( dialect.isLockTimeoutParameterized() ) {
 						st.setInt( col++, lockOptions.getTimeOut() );
 					}
 				}
 			}
 
 			log.trace( "Bound [" + col + "] parameters total" );
 		}
 		catch ( SQLException sqle ) {
 			st.close();
 			throw sqle;
 		}
 		catch ( HibernateException he ) {
 			st.close();
 			throw he;
 		}
 
 		return st;
 	}
 
 	/**
 	 * Some dialect-specific LIMIT clauses require the maximum last row number
 	 * (aka, first_row_number + total_row_count), while others require the maximum
 	 * returned row count (the total maximum number of rows to return).
 	 *
 	 * @param selection The selection criteria
 	 * @param dialect The dialect
 	 * @return The appropriate value to bind into the limit clause.
 	 */
 	private static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) {
 		final int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) );
 		final int lastRow = selection.getMaxRows().intValue();
 		if ( dialect.useMaxForLimit() ) {
 			return lastRow + firstRow;
 		}
 		else {
 			return lastRow;
 		}
 	}
 
 	/**
 	 * Bind parameter values needed by the dialect-specific LIMIT clause.
 	 *
 	 * @param statement The statement to which to bind limit param values.
 	 * @param index The bind position from which to start binding
 	 * @param selection The selection object containing the limit information.
 	 * @return The number of parameter values bound.
 	 * @throws java.sql.SQLException Indicates problems binding parameter values.
 	 */
 	private int bindLimitParameters(
 			final PreparedStatement statement,
 			final int index,
 			final RowSelection selection) throws SQLException {
 		Dialect dialect = getFactory().getDialect();
 		if ( !dialect.supportsVariableLimit() ) {
 			return 0;
 		}
 		if ( !hasMaxRows( selection ) ) {
 			throw new AssertionFailure( "no max results set" );
 		}
 		int firstRow = interpretFirstRow( getFirstRow( selection ) );
 		int lastRow = getMaxOrLimit( selection, dialect );
 		boolean hasFirstRow = dialect.supportsLimitOffset() && ( firstRow > 0 || dialect.forceLimitUsage() );
 		boolean reverse = dialect.bindLimitParametersInReverseOrder();
 		if ( hasFirstRow ) {
 			statement.setInt( index + ( reverse ? 1 : 0 ), firstRow );
 		}
 		statement.setInt( index + ( reverse || !hasFirstRow ? 0 : 1 ), lastRow );
 		return hasFirstRow ? 2 : 1;
 	}
 
 	/**
 	 * Use JDBC API to limit the number of rows returned by the SQL query if necessary
 	 */
 	private void setMaxRows(
 			final PreparedStatement st,
 			final RowSelection selection) throws SQLException {
 		if ( hasMaxRows( selection ) ) {
 			st.setMaxRows( selection.getMaxRows().intValue() + interpretFirstRow( getFirstRow( selection ) ) );
 		}
 	}
 
 	/**
 	 * Bind all parameter values into the prepared statement in preparation
 	 * for execution.
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 */
 	protected int bindParameterValues(
 			PreparedStatement statement,
 			QueryParameters queryParameters,
 			int startIndex,
 			SessionImplementor session) throws SQLException {
 		int span = 0;
 		span += bindPositionalParameters( statement, queryParameters, startIndex, session );
 		span += bindNamedParameters( statement, queryParameters.getNamedParameters(), startIndex + span, session );
 		return span;
 	}
 
 	/**
 	 * Bind positional parameter values to the JDBC prepared statement.
 	 * <p/>
 	 * Positional parameters are those specified by JDBC-style ? parameters
 	 * in the source query.  It is (currently) expected that these come
 	 * before any named parameters in the source query.
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 * @throws org.hibernate.HibernateException Indicates problems delegating binding to the types.
 	 */
 	protected int bindPositionalParameters(
 	        final PreparedStatement statement,
 	        final QueryParameters queryParameters,
 	        final int startIndex,
 	        final SessionImplementor session) throws SQLException, HibernateException {
 		final Object[] values = queryParameters.getFilteredPositionalParameterValues();
 		final Type[] types = queryParameters.getFilteredPositionalParameterTypes();
 		int span = 0;
 		for ( int i = 0; i < values.length; i++ ) {
 			types[i].nullSafeSet( statement, values[i], startIndex + span, session );
 			span += types[i].getColumnSpan( getFactory() );
 		}
 		return span;
 	}
 
 	/**
 	 * Bind named parameters to the JDBC prepared statement.
 	 * <p/>
 	 * This is a generic implementation, the problem being that in the
 	 * general case we do not know enough information about the named
 	 * parameters to perform this in a complete manner here.  Thus this
 	 * is generally overridden on subclasses allowing named parameters to
 	 * apply the specific behavior.  The most usual limitation here is that
 	 * we need to assume the type span is always one...
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param namedParams A map of parameter names to values
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 * @throws org.hibernate.HibernateException Indicates problems delegating binding to the types.
 	 */
 	protected int bindNamedParameters(
 			final PreparedStatement statement,
 			final Map namedParams,
 			final int startIndex,
 			final SessionImplementor session) throws SQLException, HibernateException {
 		if ( namedParams != null ) {
 			// assumes that types are all of span 1
 			Iterator iter = namedParams.entrySet().iterator();
 			int result = 0;
 			while ( iter.hasNext() ) {
 				Map.Entry e = ( Map.Entry ) iter.next();
 				String name = ( String ) e.getKey();
 				TypedValue typedval = ( TypedValue ) e.getValue();
 				int[] locs = getNamedParameterLocs( name );
 				for ( int i = 0; i < locs.length; i++ ) {
 					if ( log.isDebugEnabled() ) {
 						log.debug(
 								"bindNamedParameters() " +
 								typedval.getValue() + " -> " + name +
 								" [" + ( locs[i] + startIndex ) + "]"
 							);
 					}
 					typedval.getType().nullSafeSet( statement, typedval.getValue(), locs[i] + startIndex, session );
 				}
 				result += locs.length;
 			}
 			return result;
 		}
 		else {
 			return 0;
 		}
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		throw new AssertionFailure("no named parameters");
 	}
 
 	/**
 	 * Fetch a <tt>PreparedStatement</tt>, call <tt>setMaxRows</tt> and then execute it,
 	 * advance to the first result and return an SQL <tt>ResultSet</tt>
 	 */
 	protected final ResultSet getResultSet(
 	        final PreparedStatement st,
 	        final boolean autodiscovertypes,
 	        final boolean callable,
 	        final RowSelection selection,
 	        final SessionImplementor session) 
 	throws SQLException, HibernateException {
 	
 		ResultSet rs = null;
 		try {
 			Dialect dialect = getFactory().getDialect();
 			rs = st.executeQuery();
 			rs = wrapResultSetIfEnabled( rs , session );
 			
 			if ( !dialect.supportsLimitOffset() || !useLimit( selection, dialect ) ) {
 				advance( rs, selection );
 			}
 			
 			if ( autodiscovertypes ) {
 				autoDiscoverTypes( rs );
 			}
 			return rs;
 		}
 		catch ( SQLException sqle ) {
 			st.close();
 			throw sqle;
 		}
 	}
 
 	protected void autoDiscoverTypes(ResultSet rs) {
 		throw new AssertionFailure("Auto discover types not supported in this loader");
 		
 	}
 
 	private synchronized ResultSet wrapResultSetIfEnabled(final ResultSet rs, final SessionImplementor session) {
 		// synchronized to avoid multi-thread access issues; defined as method synch to avoid
 		// potential deadlock issues due to nature of code.
 		if ( session.getFactory().getSettings().isWrapResultSetsEnabled() ) {
 			try {
 				log.debug("Wrapping result set [" + rs + "]");
 				return session.getFactory()
 						.getSettings()
 						.getJdbcSupport().wrap( rs, retreiveColumnNameToIndexCache( rs ) );
 			}
 			catch(SQLException e) {
 				log.info("Error wrapping result set", e);
 				return rs;
 			}
 		}
 		else {
 			return rs;
 		}
 	}
 
 	private ColumnNameCache retreiveColumnNameToIndexCache(ResultSet rs) throws SQLException {
 		if ( columnNameCache == null ) {
 			log.trace("Building columnName->columnIndex cache");
 			columnNameCache = new ColumnNameCache( rs.getMetaData().getColumnCount() );
 		}
 
 		return columnNameCache;
 	}
 
 	/**
 	 * Called by subclasses that load entities
 	 * @param persister only needed for logging
 	 * @param lockOptions
 	 */
 	protected final List loadEntity(
 			final SessionImplementor session,
 			final Object id,
 			final Type identifierType,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalIdentifier,
 			final EntityPersister persister,
 			LockOptions lockOptions) throws HibernateException {
 		
 		if ( log.isDebugEnabled() ) {
 			log.debug( 
 					"loading entity: " + 
 					MessageHelper.infoString( persister, id, identifierType, getFactory() ) 
 				);
 		}
 
 		List result;
 		try {
 			QueryParameters qp = new QueryParameters();
 			qp.setPositionalParameterTypes( new Type[] { identifierType } );
 			qp.setPositionalParameterValues( new Object[] { id } );
 			qp.setOptionalObject( optionalObject );
 			qp.setOptionalEntityName( optionalEntityName );
 			qp.setOptionalId( optionalIdentifier );
 			qp.setLockOptions( lockOptions );
 			result = doQueryAndInitializeNonLazyCollections( session, qp, false );
 		}
 		catch ( SQLException sqle ) {
 			final Loadable[] persisters = getEntityPersisters();
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load an entity: " + 
 			        MessageHelper.infoString( persisters[persisters.length-1], id, identifierType, getFactory() ),
 			        getSQLString()
 				);
 		}
 
 		log.debug("done entity load");
 		
 		return result;
 		
 	}
 
 	/**
 	 * Called by subclasses that load entities
 	 * @param persister only needed for logging
 	 */
 	protected final List loadEntity(
 	        final SessionImplementor session,
 	        final Object key,
 	        final Object index,
 	        final Type keyType,
 	        final Type indexType,
 	        final EntityPersister persister) throws HibernateException {
 		
 		if ( log.isDebugEnabled() ) {
 			log.debug( "loading collection element by index" );
 		}
 
 		List result;
 		try {
 			result = doQueryAndInitializeNonLazyCollections(
 					session,
 					new QueryParameters(
 							new Type[] { keyType, indexType },
 							new Object[] { key, index }
 					),
 					false
 			);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not collection element by index",
 			        getSQLString()
 				);
 		}
 
 		log.debug("done entity load");
 		
 		return result;
 		
 	}
 
 	/**
 	 * Called by wrappers that batch load entities
 	 * @param persister only needed for logging
 	 * @param lockOptions
 	 */
 	public final List loadEntityBatch(
 			final SessionImplementor session,
 			final Serializable[] ids,
 			final Type idType,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalId,
 			final EntityPersister persister,
 			LockOptions lockOptions) throws HibernateException {
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( 
 					"batch loading entity: " + 
 					MessageHelper.infoString(persister, ids, getFactory() ) 
 				);
 		}
 
 		Type[] types = new Type[ids.length];
 		Arrays.fill( types, idType );
 		List result;
 		try {
 			QueryParameters qp = new QueryParameters();
 			qp.setPositionalParameterTypes( types );
 			qp.setPositionalParameterValues( ids );
 			qp.setOptionalObject( optionalObject );
 			qp.setOptionalEntityName( optionalEntityName );
 			qp.setOptionalId( optionalId );
 			qp.setLockOptions( lockOptions );
 			result = doQueryAndInitializeNonLazyCollections( session, qp, false );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load an entity batch: " + 
 			        MessageHelper.infoString( getEntityPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 
 		log.debug("done entity batch load");
 		
 		return result;
 
 	}
 
 	/**
 	 * Called by subclasses that initialize collections
 	 */
 	public final void loadCollection(
 	        final SessionImplementor session,
 	        final Serializable id,
 	        final Type type) throws HibernateException {
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( 
 					"loading collection: "+ 
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], id, getFactory() )
 				);
 		}
 
 		Serializable[] ids = new Serializable[]{id};
 		try {
 			doQueryAndInitializeNonLazyCollections( 
 					session,
 					new QueryParameters( new Type[]{type}, ids, ids ),
 					true 
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize a collection: " + 
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], id, getFactory() ),
 					getSQLString()
 				);
 		}
 	
 		log.debug("done loading collection");
 
 	}
 
 	/**
 	 * Called by wrappers that batch initialize collections
 	 */
 	public final void loadCollectionBatch(
 	        final SessionImplementor session,
 	        final Serializable[] ids,
 	        final Type type) throws HibernateException {
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( 
 					"batch loading collection: "+ 
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() )
 				);
 		}
 
 		Type[] idTypes = new Type[ids.length];
 		Arrays.fill( idTypes, type );
 		try {
 			doQueryAndInitializeNonLazyCollections( 
 					session,
 					new QueryParameters( idTypes, ids, ids ),
 					true 
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not initialize a collection batch: " + 
 			        MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 		
 		log.debug("done batch load");
 
 	}
 
 	/**
 	 * Called by subclasses that batch initialize collections
 	 */
 	protected final void loadCollectionSubselect(
 	        final SessionImplementor session,
 	        final Serializable[] ids,
 	        final Object[] parameterValues,
 	        final Type[] parameterTypes,
 	        final Map namedParameters,
 	        final Type type) throws HibernateException {
 
 		Type[] idTypes = new Type[ids.length];
 		Arrays.fill( idTypes, type );
 		try {
 			doQueryAndInitializeNonLazyCollections( session,
 					new QueryParameters( parameterTypes, parameterValues, namedParameters, ids ),
 					true 
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load collection by subselect: " + 
 			        MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 	}
 
 	/**
 	 * Return the query results, using the query cache, called
 	 * by subclasses that implement cacheable queries
 	 */
 	protected List list(
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final Set querySpaces,
 	        final Type[] resultTypes) throws HibernateException {
 
 		final boolean cacheable = factory.getSettings().isQueryCacheEnabled() && 
 			queryParameters.isCacheable();
 
 		if ( cacheable ) {
 			return listUsingQueryCache( session, queryParameters, querySpaces, resultTypes );
 		}
 		else {
 			return listIgnoreQueryCache( session, queryParameters );
 		}
 	}
 
 	private List listIgnoreQueryCache(SessionImplementor session, QueryParameters queryParameters) {
 		return getResultList( doList( session, queryParameters ), queryParameters.getResultTransformer() );
 	}
 
 	private List listUsingQueryCache(
 			final SessionImplementor session, 
 			final QueryParameters queryParameters, 
 			final Set querySpaces, 
 			final Type[] resultTypes) {
 	
 		QueryCache queryCache = factory.getQueryCache( queryParameters.getCacheRegion() );
 		
 		QueryKey key = generateQueryKey( session, queryParameters );
 
 		if ( querySpaces == null || querySpaces.size() == 0 ) {
 			log.trace( "unexpected querySpaces is "+( querySpaces == null ? "null" : "empty" ) );
 		}
 		else {
 			log.trace( "querySpaces is "+querySpaces.toString() );
 		}
 
 		List result = getResultFromQueryCache(
 				session, 
 				queryParameters, 
 				querySpaces,
 				resultTypes, 
 				queryCache, 
 				key 
 			);
 
 		if ( result == null ) {
 			result = doList( session, queryParameters, key.getResultTransformer() );
 
 			putResultInQueryCache(
 					session, 
 					queryParameters, 
 					resultTypes,
 					queryCache, 
 					key, 
 					result 
 			);
 		}
 
 		ResultTransformer resolvedTransformer = resolveResultTransformer( queryParameters.getResultTransformer() );
 		if ( resolvedTransformer != null ) {
 			result = (
 					areResultSetRowsTransformedImmediately() ?
 							key.getResultTransformer().retransformResults(
 									result,
 									getResultRowAliases(),
 									queryParameters.getResultTransformer(),
 									includeInResultRow()
 							) :
 							key.getResultTransformer().untransformToTuples(
 									result
 							)
 			);
 		}
 
 		return getResultList( result, queryParameters.getResultTransformer() );
 	}
 
 	private QueryKey generateQueryKey(
 			SessionImplementor session,
 			QueryParameters queryParameters) {
 		return QueryKey.generateQueryKey(
 				getSQLString(),
 				queryParameters,
 				FilterKey.createFilterKeys(
 						session.getLoadQueryInfluencers().getEnabledFilters(),
 						session.getEntityMode()
 				),
 				session,
 				createCacheableResultTransformer( queryParameters )
 		);
 	}
 
 	private CacheableResultTransformer createCacheableResultTransformer(QueryParameters queryParameters) {
 		return CacheableResultTransformer.create(
 				queryParameters.getResultTransformer(),
 				getResultRowAliases(),
 				includeInResultRow()
 		);
 	}
 
 	private List getResultFromQueryCache(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final Set querySpaces,
 			final Type[] resultTypes,
 			final QueryCache queryCache,
 			final QueryKey key) {
 		List result = null;
 
 		if ( session.getCacheMode().isGetEnabled() ) {
 			boolean isImmutableNaturalKeyLookup = queryParameters.isNaturalKeyLookup()
 					&& getEntityPersisters()[0].getEntityMetamodel().hasImmutableNaturalId();
 
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			boolean defaultReadOnlyOrig = persistenceContext.isDefaultReadOnly();
 			if ( queryParameters.isReadOnlyInitialized() ) {
 				// The read-only/modifiable mode for the query was explicitly set.
 				// Temporarily set the default read-only/modifiable setting to the query's setting.
 				persistenceContext.setDefaultReadOnly( queryParameters.isReadOnly() );
 			}
 			else {
 				// The read-only/modifiable setting for the query was not initialized.
 				// Use the default read-only/modifiable from the persistence context instead.
 				queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
 			}
 			try {
 				result = queryCache.get(
 						key,
 						key.getResultTransformer().getCachedResultTypes( resultTypes ),
 						isImmutableNaturalKeyLookup,
 						querySpaces,
 						session
 				);
 			}
 			finally {
 				persistenceContext.setDefaultReadOnly( defaultReadOnlyOrig );
 			}
 
 			if ( factory.getStatistics().isStatisticsEnabled() ) {
 				if ( result == null ) {
 					factory.getStatisticsImplementor()
 							.queryCacheMiss( getQueryIdentifier(), queryCache.getRegion().getName() );
 				}
 				else {
 					factory.getStatisticsImplementor()
 							.queryCacheHit( getQueryIdentifier(), queryCache.getRegion().getName() );
 				}
 			}
 		}
 
 		return result;
 	}
 
 	private void putResultInQueryCache(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final Type[] resultTypes,
 			final QueryCache queryCache,
 			final QueryKey key,
 			final List result) {
 		if ( session.getCacheMode().isPutEnabled() ) {
 			boolean put = queryCache.put(
 					key,
 					key.getResultTransformer().getCachedResultTypes( resultTypes ),
 					result, 
 					queryParameters.isNaturalKeyLookup(),
 					session
 			);
 			if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 				factory.getStatisticsImplementor()
 						.queryCachePut( getQueryIdentifier(), queryCache.getRegion().getName() );
 			}
 		}
 	}
 
 	/**
 	 * Actually execute a query, ignoring the query cache
 	 */
 
 	protected List doList(final SessionImplementor session, final QueryParameters queryParameters)
 			throws HibernateException {
 		return doList( session, queryParameters, null);
 	}
 
 	private List doList(final SessionImplementor session,
 						final QueryParameters queryParameters,
 						final ResultTransformer forcedResultTransformer)
 			throws HibernateException {
 
 		final boolean stats = getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		List result;
 		try {
 			result = doQueryAndInitializeNonLazyCollections( session, queryParameters, true, forcedResultTransformer );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query",
 			        getSQLString()
 				);
 		}
 
 		if ( stats ) {
 			getFactory().getStatisticsImplementor().queryExecuted(
 					getQueryIdentifier(),
 					result.size(),
 					System.currentTimeMillis() - startTime
 				);
 		}
 
 		return result;
 	}
 
 	/**
 	 * Check whether the current loader can support returning ScrollableResults.
 	 *
 	 * @throws HibernateException
 	 */
 	protected void checkScrollability() throws HibernateException {
 		// Allows various loaders (ok mainly the QueryLoader :) to check
 		// whether scrolling of their result set should be allowed.
 		//
 		// By default it is allowed.
 		return;
 	}
 
 	/**
 	 * Does the result set to be scrolled contain collection fetches?
 	 *
 	 * @return True if it does, and thus needs the special fetching scroll
 	 * functionality; false otherwise.
 	 */
 	protected boolean needsFetchingScroll() {
 		return false;
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 *
 	 * @param queryParameters The parameters with which the query should be executed.
 	 * @param returnTypes The expected return types of the query
 	 * @param holderInstantiator If the return values are expected to be wrapped
 	 * in a holder, this is the thing that knows how to wrap them.
 	 * @param session The session from which the scroll request originated.
 	 * @return The ScrollableResults instance.
 	 * @throws HibernateException Indicates an error executing the query, or constructing
 	 * the ScrollableResults.
 	 */
 	protected ScrollableResults scroll(
 	        final QueryParameters queryParameters,
 	        final Type[] returnTypes,
 	        final HolderInstantiator holderInstantiator,
 	        final SessionImplementor session) throws HibernateException {
 
 		checkScrollability();
 
 		final boolean stats = getQueryIdentifier() != null &&
 				getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		try {
 
 			PreparedStatement st = prepareQueryStatement( queryParameters, true, session );
 			ResultSet rs = getResultSet(st, queryParameters.hasAutoDiscoverScalarTypes(), queryParameters.isCallable(), queryParameters.getRowSelection(), session);
 
 			if ( stats ) {
 				getFactory().getStatisticsImplementor().queryExecuted(
 						getQueryIdentifier(),
 						0,
 						System.currentTimeMillis() - startTime
 					);
 			}
 
 			if ( needsFetchingScroll() ) {
 				return new FetchingScrollableResultsImpl(
 						rs,
 						st,
 						session,
 						this,
 						queryParameters,
 						returnTypes,
 						holderInstantiator
 					);
 			}
 			else {
 				return new ScrollableResultsImpl(
 						rs,
 						st,
 						session,
 						this,
 						queryParameters,
 						returnTypes,
 						holderInstantiator
 					);
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query using scroll",
 			        getSQLString()
 				);
 		}
 
 	}
 
 	/**
 	 * Calculate and cache select-clause suffixes. Must be
 	 * called by subclasses after instantiation.
 	 */
 	protected void postInstantiate() {}
 
 	/**
 	 * Get the result set descriptor
 	 */
 	protected abstract EntityAliases[] getEntityAliases();
 
 	protected abstract CollectionAliases[] getCollectionAliases();
 
 	/**
 	 * Identifies the query for statistics reporting, if null,
 	 * no statistics will be reported
 	 */
 	protected String getQueryIdentifier() {
 		return null;
 	}
 
 	public final SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	public String toString() {
 		return getClass().getName() + '(' + getSQLString() + ')';
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/collection/AbstractCollectionPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/collection/AbstractCollectionPersister.java
index cabd43a6bd..9136e97486 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/collection/AbstractCollectionPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/collection/AbstractCollectionPersister.java
@@ -1,1826 +1,1893 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.collection;
 
-import java.io.Serializable;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
 import org.hibernate.AssertionFailure;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.entry.CacheEntryStructure;
 import org.hibernate.cache.entry.StructuredCollectionCacheEntry;
 import org.hibernate.cache.entry.StructuredMapCacheEntry;
 import org.hibernate.cache.entry.UnstructuredCacheEntry;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.PersistenceContext;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SubselectFetch;
+import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.loader.collection.CollectionInitializer;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Formula;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.IndexedCollection;
 import org.hibernate.mapping.List;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Table;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Alias;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.sql.Template;
 import org.hibernate.sql.ordering.antlr.ColumnMapper;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.util.ArrayHelper;
 import org.hibernate.util.FilterHelper;
 import org.hibernate.util.StringHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
 
 /**
  * Base implementation of the <tt>QueryableCollection</tt> interface.
  *
  * @author Gavin King
  * @see BasicCollectionPersister
  * @see OneToManyPersister
  */
 public abstract class AbstractCollectionPersister
 		implements CollectionMetadata, SQLLoadableCollection {
 	// TODO: encapsulate the protected instance variables!
 
 	private final String role;
 
 	//SQL statements
 	private final String sqlDeleteString;
 	private final String sqlInsertRowString;
 	private final String sqlUpdateRowString;
 	private final String sqlDeleteRowString;
 	private final String sqlSelectSizeString;
 	private final String sqlSelectRowByIndexString;
 	private final String sqlDetectRowByIndexString;
 	private final String sqlDetectRowByElementString;
 
 	protected final String sqlWhereString;
 	private final String sqlOrderByStringTemplate;
 	private final String sqlWhereStringTemplate;
 	private final boolean hasOrder;
 	protected final boolean hasWhere;
 	private final int baseIndex;
 	
 	private final String nodeName;
 	private final String elementNodeName;
 	private final String indexNodeName;
 
 	protected final boolean indexContainsFormula;
 	protected final boolean elementIsPureFormula;
 	
 	//types
 	private final Type keyType;
 	private final Type indexType;
 	protected final Type elementType;
 	private final Type identifierType;
 
 	//columns
 	protected final String[] keyColumnNames;
 	protected final String[] indexColumnNames;
 	protected final String[] indexFormulaTemplates;
 	protected final String[] indexFormulas;
 	protected final boolean[] indexColumnIsSettable;
 	protected final String[] elementColumnNames;
 	protected final String[] elementColumnWriters;
 	protected final String[] elementColumnReaders;
 	protected final String[] elementColumnReaderTemplates;
 	protected final String[] elementFormulaTemplates;
 	protected final String[] elementFormulas;
 	protected final boolean[] elementColumnIsSettable;
 	protected final boolean[] elementColumnIsInPrimaryKey;
 	protected final String[] indexColumnAliases;
 	protected final String[] elementColumnAliases;
 	protected final String[] keyColumnAliases;
 	
 	protected final String identifierColumnName;
 	private final String identifierColumnAlias;
 	//private final String unquotedIdentifierColumnName;
 
 	protected final String qualifiedTableName;
 
 	private final String queryLoaderName;
 
 	private final boolean isPrimitiveArray;
 	private final boolean isArray;
 	protected final boolean hasIndex;
 	protected final boolean hasIdentifier;
 	private final boolean isLazy;
 	private final boolean isExtraLazy;
 	private final boolean isInverse;
 	private final boolean isMutable;
 	private final boolean isVersioned;
 	protected final int batchSize;
 	private final FetchMode fetchMode;
 	private final boolean hasOrphanDelete;
 	private final boolean subselectLoadable;
 
 	//extra information about the element type
 	private final Class elementClass;
 	private final String entityName;
 
 	private final Dialect dialect;
 	private final SQLExceptionHelper sqlExceptionHelper;
 	private final SessionFactoryImplementor factory;
 	private final EntityPersister ownerPersister;
 	private final IdentifierGenerator identifierGenerator;
 	private final PropertyMapping elementPropertyMapping;
 	private final EntityPersister elementPersister;
 	private final CollectionRegionAccessStrategy cacheAccessStrategy;
 	private final CollectionType collectionType;
 	private CollectionInitializer initializer;
 	
 	private final CacheEntryStructure cacheEntryStructure;
 
 	// dynamic filters for the collection
 	private final FilterHelper filterHelper;
 
 	// dynamic filters specifically for many-to-many inside the collection
 	private final FilterHelper manyToManyFilterHelper;
 
 	private final String manyToManyWhereString;
 	private final String manyToManyWhereTemplate;
 
 	private final boolean hasManyToManyOrder;
 	private final String manyToManyOrderByTemplate;
 
 	// custom sql
 	private final boolean insertCallable;
 	private final boolean updateCallable;
 	private final boolean deleteCallable;
 	private final boolean deleteAllCallable;
 	private ExecuteUpdateResultCheckStyle insertCheckStyle;
 	private ExecuteUpdateResultCheckStyle updateCheckStyle;
 	private ExecuteUpdateResultCheckStyle deleteCheckStyle;
 	private ExecuteUpdateResultCheckStyle deleteAllCheckStyle;
 
 	private final Serializable[] spaces;
 
 	private Map collectionPropertyColumnAliases = new HashMap();
 	private Map collectionPropertyColumnNames = new HashMap();
 
 	private static final Logger log = LoggerFactory.getLogger( AbstractCollectionPersister.class );
 
 	public AbstractCollectionPersister(
 			final Collection collection,
 			final CollectionRegionAccessStrategy cacheAccessStrategy,
 			final Configuration cfg,
 			final SessionFactoryImplementor factory) throws MappingException, CacheException {
 
 		this.factory = factory;
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		if ( factory.getSettings().isStructuredCacheEntriesEnabled() ) {
 			cacheEntryStructure = collection.isMap() ?
 					( CacheEntryStructure ) new StructuredMapCacheEntry() :
 					( CacheEntryStructure ) new StructuredCollectionCacheEntry();
 		}
 		else {
 			cacheEntryStructure = new UnstructuredCacheEntry();
 		}
 		
 		dialect = factory.getDialect();
 		sqlExceptionHelper = factory.getSQLExceptionHelper();
 		collectionType = collection.getCollectionType();
 		role = collection.getRole();
 		entityName = collection.getOwnerEntityName();
 		ownerPersister = factory.getEntityPersister(entityName);
 		queryLoaderName = collection.getLoaderName();
 		nodeName = collection.getNodeName();
 		isMutable = collection.isMutable();
 
 		Table table = collection.getCollectionTable();
 		fetchMode = collection.getElement().getFetchMode();
 		elementType = collection.getElement().getType();
 		//isSet = collection.isSet();
 		//isSorted = collection.isSorted();
 		isPrimitiveArray = collection.isPrimitiveArray();
 		isArray = collection.isArray();
 		subselectLoadable = collection.isSubselectLoadable();
 		
 		qualifiedTableName = table.getQualifiedName( 
 				dialect,
 				factory.getSettings().getDefaultCatalogName(),
 				factory.getSettings().getDefaultSchemaName() 
 			);
 
 		int spacesSize = 1 + collection.getSynchronizedTables().size();
 		spaces = new String[spacesSize];
 		spaces[0] = qualifiedTableName;
 		Iterator iter = collection.getSynchronizedTables().iterator();
 		for ( int i = 1; i < spacesSize; i++ ) {
 			spaces[i] = (String) iter.next();
 		}
 
 		sqlWhereString = StringHelper.isNotEmpty( collection.getWhere() ) ? "( " + collection.getWhere() + ") " : null;
 		hasWhere = sqlWhereString != null;
 		sqlWhereStringTemplate = hasWhere ?
 				Template.renderWhereStringTemplate(sqlWhereString, dialect, factory.getSqlFunctionRegistry()) :
 				null;
 
 		hasOrphanDelete = collection.hasOrphanDelete();
 
 		int batch = collection.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSettings().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 
 		isVersioned = collection.isOptimisticLocked();
 		
 		// KEY
 
 		keyType = collection.getKey().getType();
 		iter = collection.getKey().getColumnIterator();
 		int keySpan = collection.getKey().getColumnSpan();
 		keyColumnNames = new String[keySpan];
 		keyColumnAliases = new String[keySpan];
 		int k = 0;
 		while ( iter.hasNext() ) {
 			// NativeSQL: collect key column and auto-aliases
 			Column col = ( (Column) iter.next() );
 			keyColumnNames[k] = col.getQuotedName(dialect);
 			keyColumnAliases[k] = col.getAlias(dialect,collection.getOwner().getRootTable());
 			k++;
 		}
 		
 		//unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);
 
 		//ELEMENT
 
 		String elemNode = collection.getElementNodeName();
 		if ( elementType.isEntityType() ) {
 			String entityName = ( (EntityType) elementType ).getAssociatedEntityName();
 			elementPersister = factory.getEntityPersister(entityName);
 			if ( elemNode==null ) {
 				elemNode = cfg.getClassMapping(entityName).getNodeName();
 			}
 			// NativeSQL: collect element column and auto-aliases
 			
 		}
 		else {
 			elementPersister = null;
 		}		
 		elementNodeName = elemNode;
 
 		int elementSpan = collection.getElement().getColumnSpan();
 		elementColumnAliases = new String[elementSpan];
 		elementColumnNames = new String[elementSpan];
 		elementColumnWriters = new String[elementSpan];
 		elementColumnReaders = new String[elementSpan];
 		elementColumnReaderTemplates = new String[elementSpan];
 		elementFormulaTemplates = new String[elementSpan];
 		elementFormulas = new String[elementSpan];
 		elementColumnIsSettable = new boolean[elementSpan];
 		elementColumnIsInPrimaryKey = new boolean[elementSpan];
 		boolean isPureFormula = true;
 		boolean hasNotNullableColumns = false;
 		int j = 0;
 		iter = collection.getElement().getColumnIterator();
 		while ( iter.hasNext() ) {
 			Selectable selectable = (Selectable) iter.next();
 			elementColumnAliases[j] = selectable.getAlias(dialect);
 			if ( selectable.isFormula() ) {
 				Formula form = (Formula) selectable;
 				elementFormulaTemplates[j] = form.getTemplate(dialect, factory.getSqlFunctionRegistry());
 				elementFormulas[j] = form.getFormula();
 			}
 			else {
 				Column col = (Column) selectable;
 				elementColumnNames[j] = col.getQuotedName(dialect);
 				elementColumnWriters[j] = col.getWriteExpr();
 				elementColumnReaders[j] = col.getReadExpr(dialect);
 				elementColumnReaderTemplates[j] = col.getTemplate(dialect, factory.getSqlFunctionRegistry());
 				elementColumnIsSettable[j] = true;
 				elementColumnIsInPrimaryKey[j] = !col.isNullable();
 				if ( !col.isNullable() ) {
 					hasNotNullableColumns = true;
 				}
 				isPureFormula = false;
 			}
 			j++;
 		}
 		elementIsPureFormula = isPureFormula;
 		
 		//workaround, for backward compatibility of sets with no
 		//not-null columns, assume all columns are used in the
 		//row locator SQL
 		if ( !hasNotNullableColumns ) {
 			Arrays.fill( elementColumnIsInPrimaryKey, true );
 		}
 
 
 		// INDEX AND ROW SELECT
 
 		hasIndex = collection.isIndexed();
 		if (hasIndex) {
 			// NativeSQL: collect index column and auto-aliases
 			IndexedCollection indexedCollection = (IndexedCollection) collection;
 			indexType = indexedCollection.getIndex().getType();
 			int indexSpan = indexedCollection.getIndex().getColumnSpan();
 			iter = indexedCollection.getIndex().getColumnIterator();
 			indexColumnNames = new String[indexSpan];
 			indexFormulaTemplates = new String[indexSpan];
 			indexFormulas = new String[indexSpan];
 			indexColumnIsSettable = new boolean[indexSpan];
 			indexColumnAliases = new String[indexSpan];
 			int i = 0;
 			boolean hasFormula = false;
 			while ( iter.hasNext() ) {
 				Selectable s = (Selectable) iter.next();
 				indexColumnAliases[i] = s.getAlias(dialect);
 				if ( s.isFormula() ) {
 					Formula indexForm = (Formula) s;
 					indexFormulaTemplates[i] = indexForm.getTemplate(dialect, factory.getSqlFunctionRegistry());
 					indexFormulas[i] = indexForm.getFormula();
 					hasFormula = true;
 				}
 				else {
 					Column indexCol = (Column) s;
 					indexColumnNames[i] = indexCol.getQuotedName(dialect);
 					indexColumnIsSettable[i] = true;
 				}
 				i++;
 			}
 			indexContainsFormula = hasFormula;
 			baseIndex = indexedCollection.isList() ? 
 					( (List) indexedCollection ).getBaseIndex() : 0;
 
 			indexNodeName = indexedCollection.getIndexNodeName(); 
 
 		}
 		else {
 			indexContainsFormula = false;
 			indexColumnIsSettable = null;
 			indexFormulaTemplates = null;
 			indexFormulas = null;
 			indexType = null;
 			indexColumnNames = null;
 			indexColumnAliases = null;
 			baseIndex = 0;
 			indexNodeName = null;
 		}
 		
 		hasIdentifier = collection.isIdentified();
 		if (hasIdentifier) {
 			if ( collection.isOneToMany() ) {
 				throw new MappingException( "one-to-many collections with identifiers are not supported" );
 			}
 			IdentifierCollection idColl = (IdentifierCollection) collection;
 			identifierType = idColl.getIdentifier().getType();
 			iter = idColl.getIdentifier().getColumnIterator();
 			Column col = ( Column ) iter.next();
 			identifierColumnName = col.getQuotedName(dialect);
 			identifierColumnAlias = col.getAlias(dialect);
 			//unquotedIdentifierColumnName = identifierColumnAlias;
 			identifierGenerator = idColl.getIdentifier().createIdentifierGenerator(
 					cfg.getIdentifierGeneratorFactory(),
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName(),
 					null
 			);
 		}
 		else {
 			identifierType = null;
 			identifierColumnName = null;
 			identifierColumnAlias = null;
 			//unquotedIdentifierColumnName = null;
 			identifierGenerator = null;
 		}
 		
 		//GENERATE THE SQL:
 				
 		//sqlSelectString = sqlSelectString();
 		//sqlSelectRowString = sqlSelectRowString();
 
 		if ( collection.getCustomSQLInsert() == null ) {
 			sqlInsertRowString = generateInsertRowString();
 			insertCallable = false;
 			insertCheckStyle = ExecuteUpdateResultCheckStyle.COUNT;
 		}
 		else {
 			sqlInsertRowString = collection.getCustomSQLInsert();
 			insertCallable = collection.isCustomInsertCallable();
 			insertCheckStyle = collection.getCustomSQLInsertCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( collection.getCustomSQLInsert(), insertCallable )
 		            : collection.getCustomSQLInsertCheckStyle();
 		}
 
 		if ( collection.getCustomSQLUpdate() == null ) {
 			sqlUpdateRowString = generateUpdateRowString();
 			updateCallable = false;
 			updateCheckStyle = ExecuteUpdateResultCheckStyle.COUNT;
 		}
 		else {
 			sqlUpdateRowString = collection.getCustomSQLUpdate();
 			updateCallable = collection.isCustomUpdateCallable();
 			updateCheckStyle = collection.getCustomSQLUpdateCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( collection.getCustomSQLUpdate(), insertCallable )
 		            : collection.getCustomSQLUpdateCheckStyle();
 		}
 
 		if ( collection.getCustomSQLDelete() == null ) {
 			sqlDeleteRowString = generateDeleteRowString();
 			deleteCallable = false;
 			deleteCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
 		}
 		else {
 			sqlDeleteRowString = collection.getCustomSQLDelete();
 			deleteCallable = collection.isCustomDeleteCallable();
 			deleteCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
 		}
 
 		if ( collection.getCustomSQLDeleteAll() == null ) {
 			sqlDeleteString = generateDeleteString();
 			deleteAllCallable = false;
 			deleteAllCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
 		}
 		else {
 			sqlDeleteString = collection.getCustomSQLDeleteAll();
 			deleteAllCallable = collection.isCustomDeleteAllCallable();
 			deleteAllCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
 		}
 
 		sqlSelectSizeString = generateSelectSizeString(  collection.isIndexed() && !collection.isMap() );
 		sqlDetectRowByIndexString = generateDetectRowByIndexString();
 		sqlDetectRowByElementString = generateDetectRowByElementString();
 		sqlSelectRowByIndexString = generateSelectRowByIndexString();
 		
 		logStaticSQL();
 		
 		isLazy = collection.isLazy();
 		isExtraLazy = collection.isExtraLazy();
 
 		isInverse = collection.isInverse();
 
 		if ( collection.isArray() ) {
 			elementClass = ( (org.hibernate.mapping.Array) collection ).getElementClass();
 		}
 		else {
 			// for non-arrays, we don't need to know the element class
 			elementClass = null; //elementType.returnedClass();
 		}
 
 		if ( elementType.isComponentType() ) {
 			elementPropertyMapping = new CompositeElementPropertyMapping( 
 					elementColumnNames,
 					elementColumnReaders,
 					elementColumnReaderTemplates,
 					elementFormulaTemplates,
 					(CompositeType) elementType,
 					factory 
 				);
 		}
 		else if ( !elementType.isEntityType() ) {
 			elementPropertyMapping = new ElementPropertyMapping( 
 					elementColumnNames,
 					elementType 
 				);
 		}
 		else {
 			if ( elementPersister instanceof PropertyMapping ) { //not all classpersisters implement PropertyMapping!
 				elementPropertyMapping = (PropertyMapping) elementPersister;
 			}
 			else {
 				elementPropertyMapping = new ElementPropertyMapping( 
 						elementColumnNames,
 						elementType 
 					);
 			}
 		}
 
 		hasOrder = collection.getOrderBy() != null;
 		if ( hasOrder ) {
 			ColumnMapper mapper = new ColumnMapper() {
 				public String[] map(String reference) {
 					return elementPropertyMapping.toColumns( reference );
 				}
 			};
 			sqlOrderByStringTemplate = Template.renderOrderByStringTemplate(
 					collection.getOrderBy(),
 					mapper,
 					factory,
 					dialect,
 					factory.getSqlFunctionRegistry()
 			);
 		}
 		else {
 			sqlOrderByStringTemplate = null;
 		}
 
 		// Handle any filters applied to this collection
 		filterHelper = new FilterHelper( collection.getFilterMap(), dialect, factory.getSqlFunctionRegistry() );
 
 		// Handle any filters applied to this collection for many-to-many
 		manyToManyFilterHelper = new FilterHelper( collection.getManyToManyFilterMap(), dialect, factory.getSqlFunctionRegistry() );
 		manyToManyWhereString = StringHelper.isNotEmpty( collection.getManyToManyWhere() ) ?
 				"( " + collection.getManyToManyWhere() + ")" :
 				null;
 		manyToManyWhereTemplate = manyToManyWhereString == null ?
 				null :
 				Template.renderWhereStringTemplate( manyToManyWhereString, factory.getDialect(), factory.getSqlFunctionRegistry() );
 
 		hasManyToManyOrder = collection.getManyToManyOrdering() != null;
 		if ( hasManyToManyOrder ) {
 			ColumnMapper mapper = new ColumnMapper() {
 				public String[] map(String reference) {
 					return elementPropertyMapping.toColumns( reference );
 				}
 			};
 			manyToManyOrderByTemplate = Template.renderOrderByStringTemplate(
 					collection.getManyToManyOrdering(),
 					mapper,
 					factory,
 					dialect,
 					factory.getSqlFunctionRegistry()
 			);
 		}
 		else {
 			manyToManyOrderByTemplate = null;
 		}
 
 		initCollectionPropertyMap();
 	}
 
 	public void postInstantiate() throws MappingException {
 		initializer = queryLoaderName == null ?
 				createCollectionInitializer( LoadQueryInfluencers.NONE ) :
 				new NamedQueryCollectionInitializer( queryLoaderName, this );
 	}
 
 	protected void logStaticSQL() {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Static SQL for collection: " + getRole() );
 			if ( getSQLInsertRowString() != null ) {
 				log.debug( " Row insert: " + getSQLInsertRowString() );
 			}
 			if ( getSQLUpdateRowString() != null ) {
 				log.debug( " Row update: " + getSQLUpdateRowString() );
 			}
 			if ( getSQLDeleteRowString() != null ) {
 				log.debug( " Row delete: " + getSQLDeleteRowString() );
 			}
 			if ( getSQLDeleteString() != null ) {
 				log.debug( " One-shot delete: " + getSQLDeleteString() );
 			}
 		}
 	}
 
 	public void initialize(Serializable key, SessionImplementor session) throws HibernateException {
 		getAppropriateInitializer( key, session ).initialize( key, session );
 	}
 
 	protected CollectionInitializer getAppropriateInitializer(Serializable key, SessionImplementor session) {
 		if ( queryLoaderName != null ) {
 			//if there is a user-specified loader, return that
 			//TODO: filters!?
 			return initializer;
 		}
 		CollectionInitializer subselectInitializer = getSubselectInitializer( key, session );
 		if ( subselectInitializer != null ) {
 			return subselectInitializer;
 		}
 		else if ( session.getEnabledFilters().isEmpty() ) {
 			return initializer;
 		}
 		else {
 			return createCollectionInitializer( session.getLoadQueryInfluencers() );
 		}
 	}
 
 	private CollectionInitializer getSubselectInitializer(Serializable key, SessionImplementor session) {
 
 		if ( !isSubselectLoadable() ) {
 			return null;
 		}
 		
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		
 		SubselectFetch subselect = persistenceContext.getBatchFetchQueue()
 			.getSubselect( new EntityKey( key, getOwnerEntityPersister(), session.getEntityMode() ) );
 		
 		if (subselect == null) {
 			return null;
 		}
 		else {
 			
 			// Take care of any entities that might have
 			// been evicted!	
 			Iterator iter = subselect.getResult().iterator();
 			while ( iter.hasNext() ) {
 				if ( !persistenceContext.containsEntity( (EntityKey) iter.next() ) ) {
 					iter.remove();
 				}
 			}	
 			
 			// Run a subquery loader
 			return createSubselectInitializer( subselect, session );
 		}
 	}
 
 	protected abstract CollectionInitializer createSubselectInitializer(SubselectFetch subselect, SessionImplementor session);
 
 	protected abstract CollectionInitializer createCollectionInitializer(LoadQueryInfluencers loadQueryInfluencers)
 			throws MappingException;
 
 	public CollectionRegionAccessStrategy getCacheAccessStrategy() {
 		return cacheAccessStrategy;
 	}
 
 	public boolean hasCache() {
 		return cacheAccessStrategy != null;
 	}
 
 	public CollectionType getCollectionType() {
 		return collectionType;
 	}
 
 	protected String getSQLWhereString(String alias) {
 		return StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );
 	}
 
 	public String getSQLOrderByString(String alias) {
 		return hasOrdering()
 				? StringHelper.replace( sqlOrderByStringTemplate, Template.TEMPLATE, alias )
 				: "";
 	}
 
 	public String getManyToManyOrderByString(String alias) {
 		return hasManyToManyOrdering()
 				? StringHelper.replace( manyToManyOrderByTemplate, Template.TEMPLATE, alias )
 				: "";
 	}
 	public FetchMode getFetchMode() {
 		return fetchMode;
 	}
 
 	public boolean hasOrdering() {
 		return hasOrder;
 	}
 
 	public boolean hasManyToManyOrdering() {
 		return isManyToMany() && hasManyToManyOrder;
 	}
 
 	public boolean hasWhere() {
 		return hasWhere;
 	}
 
 	protected String getSQLDeleteString() {
 		return sqlDeleteString;
 	}
 
 	protected String getSQLInsertRowString() {
 		return sqlInsertRowString;
 	}
 
 	protected String getSQLUpdateRowString() {
 		return sqlUpdateRowString;
 	}
 
 	protected String getSQLDeleteRowString() {
 		return sqlDeleteRowString;
 	}
 
 	public Type getKeyType() {
 		return keyType;
 	}
 
 	public Type getIndexType() {
 		return indexType;
 	}
 
 	public Type getElementType() {
 		return elementType;
 	}
 
 	/**
 	 * Return the element class of an array, or null otherwise
 	 */
 	public Class getElementClass() { //needed by arrays
 		return elementClass;
 	}
 
 	public Object readElement(ResultSet rs, Object owner, String[] aliases, SessionImplementor session) 
 	throws HibernateException, SQLException {
 		return getElementType().nullSafeGet( rs, aliases, session, owner );
 	}
 
 	public Object readIndex(ResultSet rs, String[] aliases, SessionImplementor session) 
 	throws HibernateException, SQLException {
 		Object index = getIndexType().nullSafeGet( rs, aliases, session, null );
 		if ( index == null ) {
 			throw new HibernateException( "null index column for collection: " + role );
 		}
 		index = decrementIndexByBase( index );
 		return index;
 	}
 
 	protected Object decrementIndexByBase(Object index) {
 		if (baseIndex!=0) {
 			index = new Integer( ( (Integer) index ).intValue() - baseIndex );
 		}
 		return index;
 	}
 
 	public Object readIdentifier(ResultSet rs, String alias, SessionImplementor session) 
 	throws HibernateException, SQLException {
 		Object id = getIdentifierType().nullSafeGet( rs, alias, session, null );
 		if ( id == null ) {
 			throw new HibernateException( "null identifier column for collection: " + role );
 		}
 		return id;
 	}
 
 	public Object readKey(ResultSet rs, String[] aliases, SessionImplementor session) 
 	throws HibernateException, SQLException {
 		return getKeyType().nullSafeGet( rs, aliases, session, null );
 	}
 
 	/**
 	 * Write the key to a JDBC <tt>PreparedStatement</tt>
 	 */
 	protected int writeKey(PreparedStatement st, Serializable key, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		
 		if ( key == null ) {
 			throw new NullPointerException( "null key for collection: " + role );  //an assertion
 		}
 		getKeyType().nullSafeSet( st, key, i, session );
 		return i + keyColumnAliases.length;
 	}
 
 	/**
 	 * Write the element to a JDBC <tt>PreparedStatement</tt>
 	 */
 	protected int writeElement(PreparedStatement st, Object elt, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		getElementType().nullSafeSet(st, elt, i, elementColumnIsSettable, session);
 		return i + ArrayHelper.countTrue(elementColumnIsSettable);
 
 	}
 
 	/**
 	 * Write the index to a JDBC <tt>PreparedStatement</tt>
 	 */
 	protected int writeIndex(PreparedStatement st, Object index, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		getIndexType().nullSafeSet( st, incrementIndexByBase(index), i, indexColumnIsSettable, session );
 		return i + ArrayHelper.countTrue(indexColumnIsSettable);
 	}
 
 	protected Object incrementIndexByBase(Object index) {
 		if (baseIndex!=0) {
 			index = new Integer( ( (Integer) index ).intValue() + baseIndex );
 		}
 		return index;
 	}
 
 	/**
 	 * Write the element to a JDBC <tt>PreparedStatement</tt>
 	 */
 	protected int writeElementToWhere(PreparedStatement st, Object elt, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		if (elementIsPureFormula) {
 			throw new AssertionFailure("cannot use a formula-based element in the where condition");
 		}
 		getElementType().nullSafeSet(st, elt, i, elementColumnIsInPrimaryKey, session);
 		return i + elementColumnAliases.length;
 
 	}
 
 	/**
 	 * Write the index to a JDBC <tt>PreparedStatement</tt>
 	 */
 	protected int writeIndexToWhere(PreparedStatement st, Object index, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		if (indexContainsFormula) {
 			throw new AssertionFailure("cannot use a formula-based index in the where condition");
 		}
 		getIndexType().nullSafeSet( st, incrementIndexByBase(index), i, session );
 		return i + indexColumnAliases.length;
 	}
 
 	/**
 	 * Write the identifier to a JDBC <tt>PreparedStatement</tt>
 	 */
 	public int writeIdentifier(PreparedStatement st, Object id, int i, SessionImplementor session)
 			throws HibernateException, SQLException {
 		
 		getIdentifierType().nullSafeSet( st, id, i, session );
 		return i + 1;
 	}
 
 	public boolean isPrimitiveArray() {
 		return isPrimitiveArray;
 	}
 
 	public boolean isArray() {
 		return isArray;
 	}
 
 	public String[] getKeyColumnAliases(String suffix) {
 		return new Alias( suffix ).toAliasStrings( keyColumnAliases );
 	}
 
 	public String[] getElementColumnAliases(String suffix) {
 		return new Alias( suffix ).toAliasStrings( elementColumnAliases );
 	}
 
 	public String[] getIndexColumnAliases(String suffix) {
 		if ( hasIndex ) {
 			return new Alias( suffix ).toAliasStrings( indexColumnAliases );
 		}
 		else {
 			return null;
 		}
 	}
 
 	public String getIdentifierColumnAlias(String suffix) {
 		if ( hasIdentifier ) {
 			return new Alias( suffix ).toAliasString( identifierColumnAlias );
 		}
 		else {
 			return null;
 		}
 	}
 	
 	public String getIdentifierColumnName() {
 		if ( hasIdentifier ) {
 			return identifierColumnName;
 		} else {
 			return null;
 		}
 	}
 
 	/**
 	 * Generate a list of collection index, key and element columns
 	 */
 	public String selectFragment(String alias, String columnSuffix) {
 		SelectFragment frag = generateSelectFragment( alias, columnSuffix );
 		appendElementColumns( frag, alias );
 		appendIndexColumns( frag, alias );
 		appendIdentifierColumns( frag, alias );
 
 		return frag.toFragmentString()
 				.substring( 2 ); //strip leading ','
 	}
 
 	protected String generateSelectSizeString(boolean isIntegerIndexed) {
 		String selectValue = isIntegerIndexed ? 
 			"max(" + getIndexColumnNames()[0] + ") + 1": //lists, arrays
 			"count(" + getElementColumnNames()[0] + ")"; //sets, maps, bags
 		return new SimpleSelect(dialect)
 				.setTableName( getTableName() )
 				.addCondition( getKeyColumnNames(), "=?" )
 				.addColumn(selectValue)
 				.toStatementString();
 	}
 
 	protected String generateDetectRowByIndexString() {
 		if ( !hasIndex() ) {
 			return null;
 		}
 		return new SimpleSelect(dialect)
 				.setTableName( getTableName() )
 				.addCondition( getKeyColumnNames(), "=?" )
 				.addCondition( getIndexColumnNames(), "=?" )
 				.addCondition( indexFormulas, "=?" )
 				.addColumn("1")
 				.toStatementString();
 	}
 
 	protected String generateSelectRowByIndexString() {
 		if ( !hasIndex() ) {
 			return null;
 		}
 		return new SimpleSelect(dialect)
 				.setTableName( getTableName() )
 				.addCondition( getKeyColumnNames(), "=?" )
 				.addCondition( getIndexColumnNames(), "=?" )
 				.addCondition( indexFormulas, "=?" )
 				.addColumns( getElementColumnNames(), elementColumnAliases )
 				.addColumns( indexFormulas, indexColumnAliases )
 				.toStatementString();
 	}
 
 	protected String generateDetectRowByElementString() {
 		return new SimpleSelect(dialect)
 				.setTableName( getTableName() )
 				.addCondition( getKeyColumnNames(), "=?" )
 				.addCondition( getElementColumnNames(), "=?" )
 				.addCondition( elementFormulas, "=?" )
 				.addColumn("1")
 				.toStatementString();
 	}
 
 	protected SelectFragment generateSelectFragment(String alias, String columnSuffix) {
 		return new SelectFragment()
 				.setSuffix( columnSuffix )
 				.addColumns( alias, keyColumnNames, keyColumnAliases );
 	}
 
 	protected void appendElementColumns(SelectFragment frag, String elemAlias) {
 		for ( int i=0; i<elementColumnIsSettable.length; i++ ) {
 			if ( elementColumnIsSettable[i] ) {
 				frag.addColumnTemplate( elemAlias, elementColumnReaderTemplates[i], elementColumnAliases[i] );
 			}
 			else {
 				frag.addFormula( elemAlias, elementFormulaTemplates[i], elementColumnAliases[i] );
 			}
 		}
 	}
 
 	protected void appendIndexColumns(SelectFragment frag, String alias) {
 		if ( hasIndex ) {
 			for ( int i=0; i<indexColumnIsSettable.length; i++ ) {
 				if ( indexColumnIsSettable[i] ) {
 					frag.addColumn( alias, indexColumnNames[i], indexColumnAliases[i] );
 				}
 				else {
 					frag.addFormula( alias, indexFormulaTemplates[i], indexColumnAliases[i] );
 				}
 			}
 		}
 	}
 
 	protected void appendIdentifierColumns(SelectFragment frag, String alias) {
 		if ( hasIdentifier ) {
 			frag.addColumn( alias, identifierColumnName, identifierColumnAlias );
 		}
 	}
 
 	public String[] getIndexColumnNames() {
 		return indexColumnNames;
 	}
 
 	public String[] getIndexFormulas() {
 		return indexFormulas;
 	}
 
 	public String[] getIndexColumnNames(String alias) {
 		return qualify(alias, indexColumnNames, indexFormulaTemplates);
 
 	}
 
 	public String[] getElementColumnNames(String alias) {
 		return qualify(alias, elementColumnNames, elementFormulaTemplates);
 	}
 	
 	private static String[] qualify(String alias, String[] columnNames, String[] formulaTemplates) {
 		int span = columnNames.length;
 		String[] result = new String[span];
 		for (int i=0; i<span; i++) {
 			if ( columnNames[i]==null ) {
 				result[i] = StringHelper.replace( formulaTemplates[i], Template.TEMPLATE, alias );
 			}
 			else {
 				result[i] = StringHelper.qualify( alias, columnNames[i] );
 			}
 		}
 		return result;
 	}
 
 	public String[] getElementColumnNames() {
 		return elementColumnNames; //TODO: something with formulas...
 	}
 
 	public String[] getKeyColumnNames() {
 		return keyColumnNames;
 	}
 
 	public boolean hasIndex() {
 		return hasIndex;
 	}
 
 	public boolean isLazy() {
 		return isLazy;
 	}
 
 	public boolean isInverse() {
 		return isInverse;
 	}
 
 	public String getTableName() {
 		return qualifiedTableName;
 	}
 
-	public void remove(Serializable id, SessionImplementor session) throws HibernateException {
+	private BasicBatchKey removeBatchKey;
 
+	public void remove(Serializable id, SessionImplementor session) throws HibernateException {
 		if ( !isInverse && isRowDeleteEnabled() ) {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"Deleting collection: " + 
 						MessageHelper.collectionInfoString( this, id, getFactory() ) 
 					);
 			}
 
 			// Remove all the old entries
 
 			try {
 				int offset = 1;
 				PreparedStatement st = null;
 				Expectation expectation = Expectations.appropriateExpectation( getDeleteAllCheckStyle() );
 				boolean callable = isDeleteAllCallable();
 				boolean useBatch = expectation.canBeBatched();
 				String sql = getSQLDeleteString();
 				if ( useBatch ) {
-					st = session.getJDBCContext().getConnectionManager().prepareBatchStatement( this, sql, callable );
+					if ( removeBatchKey == null ) {
+						removeBatchKey = new BasicBatchKey(
+								getRole() + "#REMOVE",
+								expectation
+						);
+					}
+					st = session.getTransactionCoordinator()
+							.getJdbcCoordinator()
+							.getBatch( removeBatchKey )
+							.getBatchStatement( sql, callable );
 				}
 				else {
-					st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+					st = session.getTransactionCoordinator()
+							.getJdbcCoordinator()
+							.getStatementPreparer()
+							.prepareStatement( sql, callable );
 				}
 
 
 				try {
 					offset+= expectation.prepare( st );
 
 					writeKey( st, id, offset, session );
 					if ( useBatch ) {
-						session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+						session.getTransactionCoordinator()
+								.getJdbcCoordinator()
+								.getBatch( removeBatchKey )
+								.addToBatch();
 					}
 					else {
 						expectation.verifyOutcome( st.executeUpdate(), st, -1 );
 					}
 				}
 				catch ( SQLException sqle ) {
 					if ( useBatch ) {
-						session.getJDBCContext().getConnectionManager().abortBatch();
+						session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 					}
 					throw sqle;
 				}
 				finally {
 					if ( !useBatch ) {
 						st.close();
 					}
 				}
 
 				if ( log.isDebugEnabled() ) {
 					log.debug( "done deleting collection" );
 				}
 			}
 			catch ( SQLException sqle ) {
 				throw sqlExceptionHelper.convert(
 				        sqle,
 				        "could not delete collection: " + 
 				        MessageHelper.collectionInfoString( this, id, getFactory() ),
 				        getSQLDeleteString()
 					);
 			}
 
 		}
 
 	}
 
+	private BasicBatchKey recreateBatchKey;
+
 	public void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( !isInverse && isRowInsertEnabled() ) {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"Inserting collection: " + 
 						MessageHelper.collectionInfoString( this, id, getFactory() ) 
 					);
 			}
 
 			try {
 				//create all the new entries
 				Iterator entries = collection.entries(this);
 				if ( entries.hasNext() ) {
+					Expectation expectation = Expectations.appropriateExpectation( getInsertCheckStyle() );
 					collection.preInsert( this );
 					int i = 0;
 					int count = 0;
 					while ( entries.hasNext() ) {
 
 						final Object entry = entries.next();
 						if ( collection.entryExists( entry, i ) ) {
 							int offset = 1;
 							PreparedStatement st = null;
-							Expectation expectation = Expectations.appropriateExpectation( getInsertCheckStyle() );
 							boolean callable = isInsertCallable();
 							boolean useBatch = expectation.canBeBatched();
 							String sql = getSQLInsertRowString();
 
 							if ( useBatch ) {
-								st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-										this, sql, callable
-								);
+								if ( recreateBatchKey == null ) {
+									recreateBatchKey = new BasicBatchKey(
+											getRole() + "#RECREATE",
+											expectation
+									);
+								}
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( recreateBatchKey )
+										.getBatchStatement( sql, callable );
 							}
 							else {
-								st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getStatementPreparer()
+										.prepareStatement( sql, callable );
 							}
 
 
 							try {
 								offset+= expectation.prepare( st );
 
 								//TODO: copy/paste from insertRows()
 								int loc = writeKey( st, id, offset, session );
 								if ( hasIdentifier ) {
 									loc = writeIdentifier( st, collection.getIdentifier(entry, i), loc, session );
 								}
 								if ( hasIndex /*&& !indexIsFormula*/ ) {
 									loc = writeIndex( st, collection.getIndex(entry, i, this), loc, session );
 								}
 								loc = writeElement(st, collection.getElement(entry), loc, session );
 
 								if ( useBatch ) {
-									session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+									session.getTransactionCoordinator()
+											.getJdbcCoordinator()
+											.getBatch( recreateBatchKey )
+											.addToBatch();
 								}
 								else {
 									expectation.verifyOutcome( st.executeUpdate(), st, -1 );
 								}
 
 								collection.afterRowInsert( this, entry, i );
 								count++;
 							}
 							catch ( SQLException sqle ) {
 								if ( useBatch ) {
-									session.getJDBCContext().getConnectionManager().abortBatch();
+									session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 								}
 								throw sqle;
 							}
 							finally {
 								if ( !useBatch ) {
 									st.close();
 								}
 							}
 
 						}
 						i++;
 					}
 
 					if ( log.isDebugEnabled() ) {
 						log.debug( "done inserting collection: " + count + " rows inserted" );
 					}
 
 				}
 				else {
 					if ( log.isDebugEnabled() ) {
 						log.debug( "collection was empty" );
 					}
 				}
 			}
 			catch ( SQLException sqle ) {
 				throw sqlExceptionHelper.convert(
 				        sqle,
 				        "could not insert collection: " + 
 				        MessageHelper.collectionInfoString( this, id, getFactory() ),
 				        getSQLInsertRowString()
 					);
 			}
 		}
 	}
 	
 	protected boolean isRowDeleteEnabled() {
 		return true;
 	}
 
+	private BasicBatchKey deleteBatchKey;
+
 	public void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( !isInverse && isRowDeleteEnabled() ) {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"Deleting rows of collection: " + 
 						MessageHelper.collectionInfoString( this, id, getFactory() ) 
 					);
 			}
 			
 			boolean deleteByIndex = !isOneToMany() && hasIndex && !indexContainsFormula;
-			
+			final Expectation expectation = Expectations.appropriateExpectation( getDeleteCheckStyle() );
 			try {
 				//delete all the deleted entries
 				Iterator deletes = collection.getDeletes( this, !deleteByIndex );
 				if ( deletes.hasNext() ) {
 					int offset = 1;
 					int count = 0;
 					while ( deletes.hasNext() ) {
 						PreparedStatement st = null;
-						Expectation expectation = Expectations.appropriateExpectation( getDeleteCheckStyle() );
 						boolean callable = isDeleteCallable();
 						boolean useBatch = expectation.canBeBatched();
 						String sql = getSQLDeleteRowString();
 
 						if ( useBatch ) {
-							st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-									this, sql, callable
-							);
+							if ( deleteBatchKey == null ) {
+								deleteBatchKey = new BasicBatchKey(
+										getRole() + "#DELETE",
+										expectation
+								);
+							}
+							st = session.getTransactionCoordinator()
+									.getJdbcCoordinator()
+									.getBatch( deleteBatchKey )
+									.getBatchStatement( sql, callable );
 						}
 						else {
-							st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+							st = session.getTransactionCoordinator()
+									.getJdbcCoordinator()
+									.getStatementPreparer()
+									.prepareStatement( sql, callable );
 						}
 
 						try {
 							expectation.prepare( st );
 
 							Object entry = deletes.next();
 							int loc = offset;
 							if ( hasIdentifier ) {
 								writeIdentifier( st, entry, loc, session );
 							}
 							else {
 								loc = writeKey( st, id, loc, session );
 								if ( deleteByIndex ) {
 									writeIndexToWhere( st, entry, loc, session );
 								}
 								else {
 									writeElementToWhere( st, entry, loc, session );
 								}
 							}
 
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+								session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( deleteBatchKey )
+										.addToBatch();
 							}
 							else {
 								expectation.verifyOutcome( st.executeUpdate(), st, -1 );
 							}
 							count++;
 						}
 						catch ( SQLException sqle ) {
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().abortBatch();
+								session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 							}
 							throw sqle;
 						}
 						finally {
 							if ( !useBatch ) {
 								st.close();
 							}
 						}
 
 						if ( log.isDebugEnabled() ) {
 							log.debug( "done deleting collection rows: " + count + " deleted" );
 						}
 					}
 				}
 				else {
 					if ( log.isDebugEnabled() ) {
 						log.debug( "no rows to delete" );
 					}
 				}
 			}
 			catch ( SQLException sqle ) {
 				throw sqlExceptionHelper.convert(
 				        sqle,
 				        "could not delete collection rows: " + 
 				        MessageHelper.collectionInfoString( this, id, getFactory() ),
 				        getSQLDeleteRowString()
 					);
 			}
 		}
 	}
 	
 	protected boolean isRowInsertEnabled() {
 		return true;
 	}
 
+	private BasicBatchKey insertBatchKey;
+
 	public void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( !isInverse && isRowInsertEnabled() ) {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( 
 						"Inserting rows of collection: " + 
 						MessageHelper.collectionInfoString( this, id, getFactory() ) 
 					);
 			}
 
 			try {
 				//insert all the new entries
 				collection.preInsert( this );
 				Iterator entries = collection.entries( this );
 				Expectation expectation = Expectations.appropriateExpectation( getInsertCheckStyle() );
 				boolean callable = isInsertCallable();
 				boolean useBatch = expectation.canBeBatched();
 				String sql = getSQLInsertRowString();
 				int i = 0;
 				int count = 0;
 				while ( entries.hasNext() ) {
 					int offset = 1;
 					Object entry = entries.next();
 					PreparedStatement st = null;
 					if ( collection.needsInserting( entry, i, elementType ) ) {
 
 						if ( useBatch ) {
-							if ( st == null ) {
-								st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-										this, sql, callable
+							if ( insertBatchKey == null ) {
+								insertBatchKey = new BasicBatchKey(
+										getRole() + "#INSERT",
+										expectation
 								);
 							}
+							if ( st == null ) {
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( insertBatchKey )
+										.getBatchStatement( sql, callable );
+							}
 						}
 						else {
-							st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+							st = session.getTransactionCoordinator()
+									.getJdbcCoordinator()
+									.getStatementPreparer()
+									.prepareStatement( sql, callable );
 						}
 
 						try {
 							offset += expectation.prepare( st );
 							//TODO: copy/paste from recreate()
 							offset = writeKey( st, id, offset, session );
 							if ( hasIdentifier ) {
 								offset = writeIdentifier( st, collection.getIdentifier(entry, i), offset, session );
 							}
 							if ( hasIndex /*&& !indexIsFormula*/ ) {
 								offset = writeIndex( st, collection.getIndex(entry, i, this), offset, session );
 							}
 							writeElement(st, collection.getElement(entry), offset, session );
 
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+								session.getTransactionCoordinator().getJdbcCoordinator().getBatch( insertBatchKey ).addToBatch();
 							}
 							else {
 								expectation.verifyOutcome( st.executeUpdate(), st, -1 );
 							}
 							collection.afterRowInsert( this, entry, i );
 							count++;
 						}
 						catch ( SQLException sqle ) {
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().abortBatch();
+								session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 							}
 							throw sqle;
 						}
 						finally {
 							if ( !useBatch ) {
 								st.close();
 							}
 						}
 					}
 					i++;
 				}
 				if ( log.isDebugEnabled() ) {
 					log.debug( "done inserting rows: " + count + " inserted" );
 				}
 			}
 			catch ( SQLException sqle ) {
 				throw sqlExceptionHelper.convert(
 				        sqle,
 				        "could not insert collection rows: " + 
 				        MessageHelper.collectionInfoString( this, id, getFactory() ),
 				        getSQLInsertRowString()
 					);
 			}
 
 		}
 	}
 
 
 	public String getRole() {
 		return role;
 	}
 
 	public String getOwnerEntityName() {
 		return entityName;
 	}
 
 	public EntityPersister getOwnerEntityPersister() {
 		return ownerPersister;
 	}
 
 	public IdentifierGenerator getIdentifierGenerator() {
 		return identifierGenerator;
 	}
 
 	public Type getIdentifierType() {
 		return identifierType;
 	}
 
 	public boolean hasOrphanDelete() {
 		return hasOrphanDelete;
 	}
 
 	public Type toType(String propertyName) throws QueryException {
 		if ( "index".equals( propertyName ) ) {
 			return indexType;
 		}
 		return elementPropertyMapping.toType( propertyName );
 	}
 
 	public abstract boolean isManyToMany();
 
 	public String getManyToManyFilterFragment(String alias, Map enabledFilters) {
 		StringBuffer buffer = new StringBuffer();
 		manyToManyFilterHelper.render( buffer, alias, enabledFilters );
 
 		if ( manyToManyWhereString != null ) {
 			buffer.append( " and " )
 					.append( StringHelper.replace( manyToManyWhereTemplate, Template.TEMPLATE, alias ) );
 		}
 
 		return buffer.toString();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		if ( "index".equals( propertyName ) ) {
 			return qualify( alias, indexColumnNames, indexFormulaTemplates );
 		}
 		return elementPropertyMapping.toColumns( alias, propertyName );
 	}
 
 	private String[] indexFragments;
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String[] toColumns(String propertyName) throws QueryException {
 		if ( "index".equals( propertyName ) ) {
 			if ( indexFragments == null ) {
 				String[] tmp = new String[indexColumnNames.length];
 				for ( int i = 0; i < indexColumnNames.length; i++ ) {
 					tmp[i] = indexColumnNames[i] == null
 							? indexFormulas[i]
 							: indexColumnNames[i];
 					indexFragments = tmp;
 				}
 			}
 			return indexFragments;
 		}
 
 		return elementPropertyMapping.toColumns( propertyName );
 	}
 
 	public Type getType() {
 		return elementPropertyMapping.getType(); //==elementType ??
 	}
 
 	public String getName() {
 		return getRole();
 	}
 
 	public EntityPersister getElementPersister() {
 		if ( elementPersister == null ) {
 			throw new AssertionFailure( "not an association" );
 		}
 		return ( Loadable ) elementPersister;
 	}
 
 	public boolean isCollection() {
 		return true;
 	}
 
 	public Serializable[] getCollectionSpaces() {
 		return spaces;
 	}
 
 	protected abstract String generateDeleteString();
 
 	protected abstract String generateDeleteRowString();
 
 	protected abstract String generateUpdateRowString();
 
 	protected abstract String generateInsertRowString();
 
 	public void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session) 
 	throws HibernateException {
 
 		if ( !isInverse && collection.isRowUpdatePossible() ) {
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( "Updating rows of collection: " + role + "#" + id );
 			}
 
 			//update all the modified entries
 			int count = doUpdateRows( id, collection, session );
 
 			if ( log.isDebugEnabled() ) {
 				log.debug( "done updating rows: " + count + " updated" );
 			}
 		}
 	}
 
 	protected abstract int doUpdateRows(Serializable key, PersistentCollection collection, SessionImplementor session) 
 	throws HibernateException;
 
 	public CollectionMetadata getCollectionMetadata() {
 		return this;
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	protected String filterFragment(String alias) throws MappingException {
 		return hasWhere() ? " and " + getSQLWhereString( alias ) : "";
 	}
 
 	public String filterFragment(String alias, Map enabledFilters) throws MappingException {
 
 		StringBuffer sessionFilterFragment = new StringBuffer();
 		filterHelper.render( sessionFilterFragment, alias, enabledFilters );
 
 		return sessionFilterFragment.append( filterFragment( alias ) ).toString();
 	}
 
 	public String oneToManyFilterFragment(String alias) throws MappingException {
 		return "";
 	}
 
 	protected boolean isInsertCallable() {
 		return insertCallable;
 	}
 
 	protected ExecuteUpdateResultCheckStyle getInsertCheckStyle() {
 		return insertCheckStyle;
 	}
 
 	protected boolean isUpdateCallable() {
 		return updateCallable;
 	}
 
 	protected ExecuteUpdateResultCheckStyle getUpdateCheckStyle() {
 		return updateCheckStyle;
 	}
 
 	protected boolean isDeleteCallable() {
 		return deleteCallable;
 	}
 
 	protected ExecuteUpdateResultCheckStyle getDeleteCheckStyle() {
 		return deleteCheckStyle;
 	}
 
 	protected boolean isDeleteAllCallable() {
 		return deleteAllCallable;
 	}
 
 	protected ExecuteUpdateResultCheckStyle getDeleteAllCheckStyle() {
 		return deleteAllCheckStyle;
 	}
 
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + '(' + role + ')';
 	}
 
 	public boolean isVersioned() {
 		return isVersioned && getOwnerEntityPersister().isVersioned();
 	}
 	
 	public String getNodeName() {
 		return nodeName;
 	}
 
 	public String getElementNodeName() {
 		return elementNodeName;
 	}
 
 	public String getIndexNodeName() {
 		return indexNodeName;
 	}
 
 	// TODO: deprecate???
 	protected SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	// TODO: needed???
 	protected SQLExceptionHelper getSQLExceptionHelper() {
 		return sqlExceptionHelper;
 	}
 
 	public CacheEntryStructure getCacheEntryStructure() {
 		return cacheEntryStructure;
 	}
 
 	public boolean isAffectedByEnabledFilters(SessionImplementor session) {
 		return filterHelper.isAffectedBy( session.getEnabledFilters() ) ||
 		        ( isManyToMany() && manyToManyFilterHelper.isAffectedBy( session.getEnabledFilters() ) );
 	}
 
 	public boolean isSubselectLoadable() {
 		return subselectLoadable;
 	}
 	
 	public boolean isMutable() {
 		return isMutable;
 	}
 
 	public String[] getCollectionPropertyColumnAliases(String propertyName, String suffix) {
 		String rawAliases[] = (String[]) collectionPropertyColumnAliases.get(propertyName);
 
 		if ( rawAliases == null ) {
 			return null;
 		}
 		
 		String result[] = new String[rawAliases.length];
 		for ( int i=0; i<rawAliases.length; i++ ) {
 			result[i] = new Alias(suffix).toUnquotedAliasString( rawAliases[i] );
 		}
 		return result;
 	}
 	
 	//TODO: formulas ?
 	public void initCollectionPropertyMap() {
 
 		initCollectionPropertyMap( "key", keyType, keyColumnAliases, keyColumnNames );
 		initCollectionPropertyMap( "element", elementType, elementColumnAliases, elementColumnNames );
 		if (hasIndex) {
 			initCollectionPropertyMap( "index", indexType, indexColumnAliases, indexColumnNames );
 		}
 		if (hasIdentifier) {
 			initCollectionPropertyMap( 
 					"id", 
 					identifierType, 
 					new String[] { identifierColumnAlias }, 
 					new String[] { identifierColumnName } 
 				);
 		}
 	}
 
 	private void initCollectionPropertyMap(String aliasName, Type type, String[] columnAliases, String[] columnNames) {
 		
 		collectionPropertyColumnAliases.put(aliasName, columnAliases);
 		collectionPropertyColumnNames.put(aliasName, columnNames);
 	
 		if( type.isComponentType() ) {
 			CompositeType ct = (CompositeType) type;
 			String[] propertyNames = ct.getPropertyNames();
 			for (int i = 0; i < propertyNames.length; i++) {
 				String name = propertyNames[i];
 				collectionPropertyColumnAliases.put( aliasName + "." + name, columnAliases[i] );
 				collectionPropertyColumnNames.put( aliasName + "." + name, columnNames[i] );
 			}
 		} 
 		
 	}
 
 	public int getSize(Serializable key, SessionImplementor session) {
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement(sqlSelectSizeString);
+			PreparedStatement st = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( sqlSelectSizeString );
 			try {
 				getKeyType().nullSafeSet(st, key, 1, session);
 				ResultSet rs = st.executeQuery();
 				try {
 					return rs.next() ? rs.getInt(1) - baseIndex : 0;
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch (SQLException sqle) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not retrieve collection size: " + 
 					MessageHelper.collectionInfoString( this, key, getFactory() ),
 					sqlSelectSizeString
 				);
 		}
 	}
 	
 	public boolean indexExists(Serializable key, Object index, SessionImplementor session) {
 		return exists(key, incrementIndexByBase(index), getIndexType(), sqlDetectRowByIndexString, session);
 	}
 
 	public boolean elementExists(Serializable key, Object element, SessionImplementor session) {
 		return exists(key, element, getElementType(), sqlDetectRowByElementString, session);
 	}
 
 	private boolean exists(Serializable key, Object indexOrElement, Type indexOrElementType, String sql, SessionImplementor session) {
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement(sql);
+			PreparedStatement st = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( sql );
 			try {
 				getKeyType().nullSafeSet(st, key, 1, session);
 				indexOrElementType.nullSafeSet( st, indexOrElement, keyColumnNames.length + 1, session );
 				ResultSet rs = st.executeQuery();
 				try {
 					return rs.next();
 				}
 				finally {
 					rs.close();
 				}
 			}
 			catch( TransientObjectException e ) {
 				return false;
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch (SQLException sqle) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not check row existence: " + 
 					MessageHelper.collectionInfoString( this, key, getFactory() ),
 					sqlSelectSizeString
 				);
 		}
 	}
 
 	public Object getElementByIndex(Serializable key, Object index, SessionImplementor session, Object owner) {
 		try {
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement(sqlSelectRowByIndexString);
+			PreparedStatement st = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( sqlSelectRowByIndexString );
 			try {
 				getKeyType().nullSafeSet(st, key, 1, session);
 				getIndexType().nullSafeSet( st, incrementIndexByBase(index), keyColumnNames.length + 1, session );
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( rs.next() ) {
 						return getElementType().nullSafeGet(rs, elementColumnAliases, session, owner);
 					}
 					else {
 						return null;
 					}
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch (SQLException sqle) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not read row: " + 
 					MessageHelper.collectionInfoString( this, key, getFactory() ),
 					sqlSelectSizeString
 				);
 		}
 	}
 
 	public boolean isExtraLazy() {
 		return isExtraLazy;
 	}
 	
 	protected Dialect getDialect() {
 		return dialect;
 	}
 
 	/**
 	 * Intended for internal use only.  In fact really only currently used from 
 	 * test suite for assertion purposes.
 	 *
 	 * @return The default collection initializer for this persister/collection.
 	 */
 	public CollectionInitializer getInitializer() {
 		return initializer;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/collection/BasicCollectionPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/collection/BasicCollectionPersister.java
index 4fa624149b..80e5c73487 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/collection/BasicCollectionPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/collection/BasicCollectionPersister.java
@@ -1,336 +1,350 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.collection;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.access.CollectionRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SubselectFetch;
 import org.hibernate.engine.LoadQueryInfluencers;
+import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.loader.collection.BatchingCollectionInitializer;
 import org.hibernate.loader.collection.CollectionInitializer;
 import org.hibernate.loader.collection.SubselectCollectionLoader;
 import org.hibernate.mapping.Collection;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Delete;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.Update;
 import org.hibernate.type.AssociationType;
 import org.hibernate.util.ArrayHelper;
 
 /**
  * Collection persister for collections of values and many-to-many associations.
  *
  * @author Gavin King
  */
 public class BasicCollectionPersister extends AbstractCollectionPersister {
 
 	public boolean isCascadeDeleteEnabled() {
 		return false;
 	}
 
 	public BasicCollectionPersister(
 			Collection collection,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			Configuration cfg,
 			SessionFactoryImplementor factory) throws MappingException, CacheException {
 		super( collection, cacheAccessStrategy, cfg, factory );
 	}
 
 	/**
 	 * Generate the SQL DELETE that deletes all rows
 	 */
 	protected String generateDeleteString() {
 		
 		Delete delete = new Delete()
 				.setTableName( qualifiedTableName )
 				.addPrimaryKeyColumns( keyColumnNames );
 		
 		if ( hasWhere ) delete.setWhere( sqlWhereString );
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			delete.setComment( "delete collection " + getRole() );
 		}
 		
 		return delete.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL INSERT that creates a new row
 	 */
 	protected String generateInsertRowString() {
 		
 		Insert insert = new Insert( getDialect() )
 				.setTableName( qualifiedTableName )
 				.addColumns( keyColumnNames );
 		
 		if ( hasIdentifier) insert.addColumn( identifierColumnName );
 		
 		if ( hasIndex /*&& !indexIsFormula*/ ) {
 			insert.addColumns( indexColumnNames, indexColumnIsSettable );
 		}
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert collection row " + getRole() );
 		}
 		
 		//if ( !elementIsFormula ) {
 			insert.addColumns( elementColumnNames, elementColumnIsSettable, elementColumnWriters );
 		//}
 		
 		return insert.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL UPDATE that updates a row
 	 */
 	protected String generateUpdateRowString() {
 		
 		Update update = new Update( getDialect() )
 			.setTableName( qualifiedTableName );
 		
 		//if ( !elementIsFormula ) {
 			update.addColumns( elementColumnNames, elementColumnIsSettable, elementColumnWriters );
 		//}
 		
 		if ( hasIdentifier ) {
 			update.addPrimaryKeyColumns( new String[]{ identifierColumnName } );
 		}
 		else if ( hasIndex && !indexContainsFormula ) {
 			update.addPrimaryKeyColumns( ArrayHelper.join( keyColumnNames, indexColumnNames ) );
 		}
 		else {
 			update.addPrimaryKeyColumns( keyColumnNames );
 			update.addPrimaryKeyColumns( elementColumnNames, elementColumnIsInPrimaryKey, elementColumnWriters );
 		}
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "update collection row " + getRole() );
 		}
 		
 		return update.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL DELETE that deletes a particular row
 	 */
 	protected String generateDeleteRowString() {
 		
 		Delete delete = new Delete()
 			.setTableName( qualifiedTableName );
 		
 		if ( hasIdentifier ) {
 			delete.addPrimaryKeyColumns( new String[]{ identifierColumnName } );
 		}
 		else if ( hasIndex && !indexContainsFormula ) {
 			delete.addPrimaryKeyColumns( ArrayHelper.join( keyColumnNames, indexColumnNames ) );
 		}
 		else {
 			delete.addPrimaryKeyColumns( keyColumnNames );
 			delete.addPrimaryKeyColumns( elementColumnNames, elementColumnIsInPrimaryKey, elementColumnWriters );
 		}
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			delete.setComment( "delete collection row " + getRole() );
 		}
 		
 		return delete.toStatementString();
 	}
 
 	public boolean consumesEntityAlias() {
 		return false;
 	}
 
 	public boolean consumesCollectionAlias() {
 //		return !isOneToMany();
 		return true;
 	}
 
 	public boolean isOneToMany() {
 		return false;
 	}
 
 	public boolean isManyToMany() {
 		return elementType.isEntityType(); //instanceof AssociationType;
 	}
 
+	private BasicBatchKey updateBatchKey;
+
 	protected int doUpdateRows(Serializable id, PersistentCollection collection, SessionImplementor session)
 			throws HibernateException {
 		
 		if ( ArrayHelper.isAllFalse(elementColumnIsSettable) ) return 0;
 
 		try {
 			PreparedStatement st = null;
 			Expectation expectation = Expectations.appropriateExpectation( getUpdateCheckStyle() );
 			boolean callable = isUpdateCallable();
 			boolean useBatch = expectation.canBeBatched();
 			Iterator entries = collection.entries( this );
 			String sql = getSQLUpdateRowString();
 			int i = 0;
 			int count = 0;
 			while ( entries.hasNext() ) {
 				Object entry = entries.next();
 				if ( collection.needsUpdating( entry, i, elementType ) ) {
 					int offset = 1;
 
 					if ( useBatch ) {
-						if ( st == null ) {
-							st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-									this, sql, callable
+						if ( updateBatchKey == null ) {
+							updateBatchKey = new BasicBatchKey(
+									getRole() + "#UPDATE",
+									expectation
 							);
 						}
+						st = session.getTransactionCoordinator()
+								.getJdbcCoordinator()
+								.getBatch( updateBatchKey )
+								.getBatchStatement( sql, callable );
 					}
 					else {
-						st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+						st = session.getTransactionCoordinator()
+								.getJdbcCoordinator()
+								.getStatementPreparer()
+								.prepareStatement( sql, callable );
 					}
 
 					try {
 						offset+= expectation.prepare( st );
 						int loc = writeElement( st, collection.getElement( entry ), offset, session );
 						if ( hasIdentifier ) {
 							writeIdentifier( st, collection.getIdentifier( entry, i ), loc, session );
 						}
 						else {
 							loc = writeKey( st, id, loc, session );
 							if ( hasIndex && !indexContainsFormula ) {
 								writeIndexToWhere( st, collection.getIndex( entry, i, this ), loc, session );
 							}
 							else {
 								writeElementToWhere( st, collection.getSnapshotElement( entry, i ), loc, session );
 							}
 						}
 
 						if ( useBatch ) {
-							session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+							session.getTransactionCoordinator()
+									.getJdbcCoordinator()
+									.getBatch( updateBatchKey )
+									.addToBatch();
 						}
 						else {
 							expectation.verifyOutcome( st.executeUpdate(), st, -1 );
 						}
 					}
 					catch ( SQLException sqle ) {
 						if ( useBatch ) {
-							session.getJDBCContext().getConnectionManager().abortBatch();
+							session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 						}
 						throw sqle;
 					}
 					finally {
 						if ( !useBatch ) {
 							st.close();
 						}
 					}
 					count++;
 				}
 				i++;
 			}
 			return count;
 		}
 		catch ( SQLException sqle ) {
 			throw getSQLExceptionHelper().convert(
 					sqle,
 					"could not update collection rows: " + MessageHelper.collectionInfoString( this, id, getFactory() ),
 					getSQLUpdateRowString()
 				);
 		}
 	}
 
 	public String selectFragment(
 	        Joinable rhs,
 	        String rhsAlias,
 	        String lhsAlias,
 	        String entitySuffix,
 	        String collectionSuffix,
 	        boolean includeCollectionColumns) {
 		// we need to determine the best way to know that two joinables
 		// represent a single many-to-many...
 		if ( rhs != null && isManyToMany() && !rhs.isCollection() ) {
 			AssociationType elementType = ( ( AssociationType ) getElementType() );
 			if ( rhs.equals( elementType.getAssociatedJoinable( getFactory() ) ) ) {
 				return manyToManySelectFragment( rhs, rhsAlias, lhsAlias, collectionSuffix );
 			}
 		}
 		return includeCollectionColumns ? selectFragment( lhsAlias, collectionSuffix ) : "";
 	}
 
 	private String manyToManySelectFragment(
 	        Joinable rhs,
 	        String rhsAlias,
 	        String lhsAlias,
 	        String collectionSuffix) {
 		SelectFragment frag = generateSelectFragment( lhsAlias, collectionSuffix );
 
 		String[] elementColumnNames = rhs.getKeyColumnNames();
 		frag.addColumns( rhsAlias, elementColumnNames, elementColumnAliases );
 		appendIndexColumns( frag, lhsAlias );
 		appendIdentifierColumns( frag, lhsAlias );
 
 		return frag.toFragmentString()
 				.substring( 2 ); //strip leading ','
 	}
 
 	/**
 	 * Create the <tt>CollectionLoader</tt>
 	 *
 	 * @see org.hibernate.loader.collection.BasicCollectionLoader
 	 */
 	protected CollectionInitializer createCollectionInitializer(LoadQueryInfluencers loadQueryInfluencers)
 			throws MappingException {
 		return BatchingCollectionInitializer.createBatchingCollectionInitializer( this, batchSize, getFactory(), loadQueryInfluencers );
 	}
 
 	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return "";
 	}
 
 	public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return "";
 	}
 
 	protected CollectionInitializer createSubselectInitializer(SubselectFetch subselect, SessionImplementor session) {
 		return new SubselectCollectionLoader( 
 				this,
 				subselect.toSubselectString( getCollectionType().getLHSPropertyName() ),
 				subselect.getResult(),
 				subselect.getQueryParameters(),
 				subselect.getNamedParameterLocMap(),
 				session.getFactory(),
 				session.getLoadQueryInfluencers() 
 		);
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java
index 2057a92cd6..64978a4af9 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java
@@ -1,381 +1,397 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.collection;
 
-import java.io.Serializable;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.util.Iterator;
-
-import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.access.CollectionRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.collection.PersistentCollection;
+import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.SubselectFetch;
-import org.hibernate.engine.LoadQueryInfluencers;
+import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.loader.collection.BatchingCollectionInitializer;
 import org.hibernate.loader.collection.CollectionInitializer;
 import org.hibernate.loader.collection.SubselectOneToManyLoader;
 import org.hibernate.loader.entity.CollectionElementLoader;
 import org.hibernate.mapping.Collection;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.sql.Update;
 import org.hibernate.util.ArrayHelper;
 
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.Iterator;
+
 /**
  * Collection persister for one-to-many associations.
  *
  * @author Gavin King
  */
 public class OneToManyPersister extends AbstractCollectionPersister {
 
 	private final boolean cascadeDeleteEnabled;
 	private final boolean keyIsNullable;
 	private final boolean keyIsUpdateable;
 
 	protected boolean isRowDeleteEnabled() {
 		return keyIsUpdateable && keyIsNullable;
 	}
 
 	protected boolean isRowInsertEnabled() {
 		return keyIsUpdateable;
 	}
 
 	public boolean isCascadeDeleteEnabled() {
 		return cascadeDeleteEnabled;
 	}
 
 	public OneToManyPersister(
 			Collection collection,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			Configuration cfg,
 			SessionFactoryImplementor factory) throws MappingException, CacheException {
 		super( collection, cacheAccessStrategy, cfg, factory );
 		cascadeDeleteEnabled = collection.getKey().isCascadeDeleteEnabled() &&
 				factory.getDialect().supportsCascadeDelete();
 		keyIsNullable = collection.getKey().isNullable();
 		keyIsUpdateable = collection.getKey().isUpdateable();
 	}
 
 	/**
 	 * Generate the SQL UPDATE that updates all the foreign keys to null
 	 */
 	protected String generateDeleteString() {
 		
 		Update update = new Update( getDialect() )
 				.setTableName( qualifiedTableName )
 				.addColumns( keyColumnNames, "null" )
 				.addPrimaryKeyColumns( keyColumnNames );
 		
 		if ( hasIndex && !indexContainsFormula ) update.addColumns( indexColumnNames, "null" );
 		
 		if ( hasWhere ) update.setWhere( sqlWhereString );
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "delete one-to-many " + getRole() );
 		}
 		
 		return update.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL UPDATE that updates a foreign key to a value
 	 */
 	protected String generateInsertRowString() {
 		
 		Update update = new Update( getDialect() )
 				.setTableName( qualifiedTableName )
 				.addColumns( keyColumnNames );
 		
 		if ( hasIndex && !indexContainsFormula ) update.addColumns( indexColumnNames );
 		
 		//identifier collections not supported for 1-to-many
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "create one-to-many row " + getRole() );
 		}
 		
 		return update.addPrimaryKeyColumns( elementColumnNames, elementColumnWriters )
 				.toStatementString();
 	}
 
 	/**
 	 * Not needed for one-to-many association
 	 */
 	protected String generateUpdateRowString() {
 		return null;
 	}
 
 	/**
 	 * Generate the SQL UPDATE that updates a particular row's foreign
 	 * key to null
 	 */
 	protected String generateDeleteRowString() {
 		
 		Update update = new Update( getDialect() )
 				.setTableName( qualifiedTableName )
 				.addColumns( keyColumnNames, "null" );
 		
 		if ( hasIndex && !indexContainsFormula ) update.addColumns( indexColumnNames, "null" );
 		
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "delete one-to-many row " + getRole() );
 		}
 		
 		//use a combination of foreign key columns and pk columns, since
 		//the ordering of removal and addition is not guaranteed when
 		//a child moves from one parent to another
 		String[] rowSelectColumnNames = ArrayHelper.join(keyColumnNames, elementColumnNames);
 		return update.addPrimaryKeyColumns( rowSelectColumnNames )
 				.toStatementString();
 	}
 
 	public boolean consumesEntityAlias() {
 		return true;
 	}
 	public boolean consumesCollectionAlias() {
 		return true;
 	}
 
 	public boolean isOneToMany() {
 		return true;
 	}
 
 	public boolean isManyToMany() {
 		return false;
 	}
 
-	protected int doUpdateRows(Serializable id, PersistentCollection collection, SessionImplementor session)
-			throws HibernateException {
+	private BasicBatchKey deleteRowBatchKey;
+	private BasicBatchKey insertRowBatchKey;
+
+	protected int doUpdateRows(Serializable id, PersistentCollection collection, SessionImplementor session) {
 
 		// we finish all the "removes" first to take care of possible unique
 		// constraints and so that we can take better advantage of batching
 		
 		try {
 			int count = 0;
 			if ( isRowDeleteEnabled() ) {
-				boolean useBatch = true;
+				final Expectation deleteExpectation = Expectations.appropriateExpectation( getDeleteCheckStyle() );
+				final boolean useBatch = deleteExpectation.canBeBatched();
+				if ( useBatch && deleteRowBatchKey == null ) {
+					deleteRowBatchKey = new BasicBatchKey(
+							getRole() + "#DELETEROW",
+							deleteExpectation
+					);
+				}
+				final String sql = getSQLDeleteRowString();
+
 				PreparedStatement st = null;
 				// update removed rows fks to null
 				try {
 					int i = 0;
-	
 					Iterator entries = collection.entries( this );
 					int offset = 1;
-					Expectation expectation = Expectations.NONE;
 					while ( entries.hasNext() ) {
-	
 						Object entry = entries.next();
 						if ( collection.needsUpdating( entry, i, elementType ) ) {  // will still be issued when it used to be null
-							String sql = getSQLDeleteRowString();
-							if ( st == null ) {
-								if ( isDeleteCallable() ) {
-									expectation = Expectations.appropriateExpectation( getDeleteCheckStyle() );
-									useBatch = expectation.canBeBatched();
-									st = useBatch
-											? session.getJDBCContext().getConnectionManager().prepareBatchStatement( this, sql, true )
-								            : session.getJDBCContext().getConnectionManager().prepareStatement( sql, true );
-									offset += expectation.prepare( st );
-								}
-								else {
-									st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-											this, sql, false
-									);
-								}
+							if ( useBatch ) {
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( deleteRowBatchKey )
+										.getBatchStatement( sql, isDeleteCallable() );
+							}
+							else {
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getStatementPreparer()
+										.prepareStatement( sql, isDeleteCallable() );
 							}
 							int loc = writeKey( st, id, offset, session );
 							writeElementToWhere( st, collection.getSnapshotElement(entry, i), loc, session );
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+								session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( deleteRowBatchKey )
+										.addToBatch();
 							}
 							else {
-								expectation.verifyOutcome( st.executeUpdate(), st, -1 );
+								deleteExpectation.verifyOutcome( st.executeUpdate(), st, -1 );
 							}
 							count++;
 						}
 						i++;
 					}
 				}
-				catch ( SQLException sqle ) {
+				catch ( SQLException e ) {
 					if ( useBatch ) {
-						session.getJDBCContext().getConnectionManager().abortBatch();
+						session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 					}
-					throw sqle;
+					throw e;
 				}
 				finally {
 					if ( !useBatch ) {
 						st.close();
 					}
 				}
 			}
 			
 			if ( isRowInsertEnabled() ) {
-				Expectation expectation = Expectations.appropriateExpectation( getInsertCheckStyle() );
+				final Expectation insertExpectation = Expectations.appropriateExpectation( getInsertCheckStyle() );
+				boolean useBatch = insertExpectation.canBeBatched();
 				boolean callable = isInsertCallable();
-				boolean useBatch = expectation.canBeBatched();
-				String sql = getSQLInsertRowString();
+				if ( useBatch && insertRowBatchKey == null ) {
+					insertRowBatchKey = new BasicBatchKey(
+							getRole() + "#INSERTROW",
+							insertExpectation
+					);
+				}
+				final String sql = getSQLInsertRowString();
+
 				PreparedStatement st = null;
 				// now update all changed or added rows fks
 				try {
 					int i = 0;
 					Iterator entries = collection.entries( this );
 					while ( entries.hasNext() ) {
 						Object entry = entries.next();
 						int offset = 1;
 						if ( collection.needsUpdating( entry, i, elementType ) ) {
 							if ( useBatch ) {
-								if ( st == null ) {
-									st = session.getJDBCContext().getConnectionManager().prepareBatchStatement(
-											this, sql, callable
-									);
-								}
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getBatch( insertRowBatchKey )
+										.getBatchStatement( sql, callable );
 							}
 							else {
-								st = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+								st = session.getTransactionCoordinator()
+										.getJdbcCoordinator()
+										.getStatementPreparer()
+										.prepareStatement( sql, callable );
 							}
 
-							offset += expectation.prepare( st );
+							offset += insertExpectation.prepare( st );
 
 							int loc = writeKey( st, id, offset, session );
 							if ( hasIndex && !indexContainsFormula ) {
 								loc = writeIndexToWhere( st, collection.getIndex( entry, i, this ), loc, session );
 							}
 
 							writeElementToWhere( st, collection.getElement( entry ), loc, session );
 
 							if ( useBatch ) {
-								session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+								session.getTransactionCoordinator().getJdbcCoordinator().getBatch( insertRowBatchKey ).addToBatch();
 							}
 							else {
-								expectation.verifyOutcome( st.executeUpdate(), st, -1 );
+								insertExpectation.verifyOutcome( st.executeUpdate(), st, -1 );
 							}
 							count++;
 						}
 						i++;
 					}
 				}
 				catch ( SQLException sqle ) {
 					if ( useBatch ) {
-						session.getJDBCContext().getConnectionManager().abortBatch();
+						session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 					}
 					throw sqle;
 				}
 				finally {
 					if ( !useBatch ) {
 						st.close();
 					}
 				}
 			}
 
 			return count;
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not update collection rows: " + 
 					MessageHelper.collectionInfoString( this, id, getFactory() ),
 					getSQLInsertRowString()
 			);
 		}
 	}
 
 	public String selectFragment(
 	        Joinable rhs,
 	        String rhsAlias,
 	        String lhsAlias,
 	        String entitySuffix,
 	        String collectionSuffix,
 	        boolean includeCollectionColumns) {
 		StringBuffer buf = new StringBuffer();
 		if ( includeCollectionColumns ) {
 //			buf.append( selectFragment( lhsAlias, "" ) )//ignore suffix for collection columns!
 			buf.append( selectFragment( lhsAlias, collectionSuffix ) )
 					.append( ", " );
 		}
 		OuterJoinLoadable ojl = ( OuterJoinLoadable ) getElementPersister();
 		return buf.append( ojl.selectFragment( lhsAlias, entitySuffix ) )//use suffix for the entity columns
 				.toString();
 	}
 
 	/**
 	 * Create the <tt>OneToManyLoader</tt>
 	 *
 	 * @see org.hibernate.loader.collection.OneToManyLoader
 	 */
 	protected CollectionInitializer createCollectionInitializer(LoadQueryInfluencers loadQueryInfluencers) 
 			throws MappingException {
 		return BatchingCollectionInitializer.createBatchingOneToManyInitializer( this, batchSize, getFactory(), loadQueryInfluencers );
 	}
 
 	public String fromJoinFragment(String alias,
 								   boolean innerJoin,
 								   boolean includeSubclasses) {
 		return ( ( Joinable ) getElementPersister() ).fromJoinFragment( alias, innerJoin, includeSubclasses );
 	}
 
 	public String whereJoinFragment(String alias,
 									boolean innerJoin,
 									boolean includeSubclasses) {
 		return ( ( Joinable ) getElementPersister() ).whereJoinFragment( alias, innerJoin, includeSubclasses );
 	}
 
 	public String getTableName() {
 		return ( ( Joinable ) getElementPersister() ).getTableName();
 	}
 
 	public String filterFragment(String alias) throws MappingException {
 		String result = super.filterFragment( alias );
 		if ( getElementPersister() instanceof Joinable ) {
 			result += ( ( Joinable ) getElementPersister() ).oneToManyFilterFragment( alias );
 		}
 		return result;
 
 	}
 
 	protected CollectionInitializer createSubselectInitializer(SubselectFetch subselect, SessionImplementor session) {
 		return new SubselectOneToManyLoader( 
 				this,
 				subselect.toSubselectString( getCollectionType().getLHSPropertyName() ),
 				subselect.getResult(),
 				subselect.getQueryParameters(),
 				subselect.getNamedParameterLocMap(),
 				session.getFactory(),
 				session.getLoadQueryInfluencers()
 			);
 	}
 
 	public Object getElementByIndex(Serializable key, Object index, SessionImplementor session, Object owner) {
 		return new CollectionElementLoader( this, getFactory(), session.getLoadQueryInfluencers() )
 				.loadElement( session, key, incrementIndexByBase(index) );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
index 612ed153fb..22b6f8dcab 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
@@ -1,4115 +1,4166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
-import java.io.Serializable;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.cache.CacheKey;
 import org.hibernate.cache.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.entry.CacheEntry;
 import org.hibernate.cache.entry.CacheEntryStructure;
 import org.hibernate.cache.entry.StructuredCacheEntry;
 import org.hibernate.cache.entry.UnstructuredCacheEntry;
 import org.hibernate.dialect.lock.LockingStrategy;
 import org.hibernate.engine.CascadeStyle;
 import org.hibernate.engine.CascadingAction;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.Mapping;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.ValueInclusion;
 import org.hibernate.engine.Versioning;
+import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.id.PostInsertIdentityPersister;
 import org.hibernate.id.insert.Binder;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.intercept.FieldInterceptionHelper;
 import org.hibernate.intercept.FieldInterceptor;
 import org.hibernate.intercept.LazyPropertyInitializer;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.jdbc.TooManyRowsAffectedException;
 import org.hibernate.loader.entity.BatchingEntityLoader;
 import org.hibernate.loader.entity.CascadeEntityLoader;
 import org.hibernate.loader.entity.EntityLoader;
 import org.hibernate.loader.entity.UniqueEntityLoader;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.property.BackrefPropertyAccessor;
 import org.hibernate.sql.Alias;
 import org.hibernate.sql.Delete;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.sql.Template;
 import org.hibernate.sql.Update;
 import org.hibernate.tuple.Tuplizer;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 import org.hibernate.type.VersionType;
 import org.hibernate.util.ArrayHelper;
 import org.hibernate.util.FilterHelper;
 import org.hibernate.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * Basic functionality for persisting an entity via JDBC
  * through either generated or custom SQL
  *
  * @author Gavin King
  */
 public abstract class AbstractEntityPersister
 		implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
 		SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
 
 	private static final Logger log = LoggerFactory.getLogger( AbstractEntityPersister.class );
 
 	public static final String ENTITY_CLASS = "class";
 
 	// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final SessionFactoryImplementor factory;
 	private final EntityRegionAccessStrategy cacheAccessStrategy;
 	private final boolean isLazyPropertiesCacheable;
 	private final CacheEntryStructure cacheEntryStructure;
 	private final EntityMetamodel entityMetamodel;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final String[] rootTableKeyColumnNames;
 	private final String[] rootTableKeyColumnReaders;
 	private final String[] rootTableKeyColumnReaderTemplates;
 	private final String[] identifierAliases;
 	private final int identifierColumnSpan;
 	private final String versionColumnName;
 	private final boolean hasFormulaProperties;
 	private final int batchSize;
 	private final boolean hasSubselectLoadableCollections;
 	protected final String rowIdName;
 
 	private final Set lazyProperties;
 
 	// The optional SQL string defined in the where attribute
 	private final String sqlWhereString;
 	private final String sqlWhereStringTemplate;
 
 	//information about properties of this class,
 	//including inherited properties
 	//(only really needed for updatable/insertable properties)
 	private final int[] propertyColumnSpans;
 	private final String[] propertySubclassNames;
 	private final String[][] propertyColumnAliases;
 	private final String[][] propertyColumnNames;
 	private final String[][] propertyColumnFormulaTemplates;
 	private final String[][] propertyColumnReaderTemplates;
 	private final String[][] propertyColumnWriters;
 	private final boolean[][] propertyColumnUpdateable;
 	private final boolean[][] propertyColumnInsertable;
 	private final boolean[] propertyUniqueness;
 	private final boolean[] propertySelectable;
 
 	//information about lazy properties of this class
 	private final String[] lazyPropertyNames;
 	private final int[] lazyPropertyNumbers;
 	private final Type[] lazyPropertyTypes;
 	private final String[][] lazyPropertyColumnAliases;
 
 	//information about all properties in class hierarchy
 	private final String[] subclassPropertyNameClosure;
 	private final String[] subclassPropertySubclassNameClosure;
 	private final Type[] subclassPropertyTypeClosure;
 	private final String[][] subclassPropertyFormulaTemplateClosure;
 	private final String[][] subclassPropertyColumnNameClosure;
 	private final String[][] subclassPropertyColumnReaderClosure;
 	private final String[][] subclassPropertyColumnReaderTemplateClosure;
 	private final FetchMode[] subclassPropertyFetchModeClosure;
 	private final boolean[] subclassPropertyNullabilityClosure;
 	private final boolean[] propertyDefinedOnSubclass;
 	private final int[][] subclassPropertyColumnNumberClosure;
 	private final int[][] subclassPropertyFormulaNumberClosure;
 	private final CascadeStyle[] subclassPropertyCascadeStyleClosure;
 
 	//information about all columns/formulas in class hierarchy
 	private final String[] subclassColumnClosure;
 	private final boolean[] subclassColumnLazyClosure;
 	private final String[] subclassColumnAliasClosure;
 	private final boolean[] subclassColumnSelectableClosure;
 	private final String[] subclassColumnReaderTemplateClosure;
 	private final String[] subclassFormulaClosure;
 	private final String[] subclassFormulaTemplateClosure;
 	private final String[] subclassFormulaAliasClosure;
 	private final boolean[] subclassFormulaLazyClosure;
 
 	// dynamic filters attached to the class-level
 	private final FilterHelper filterHelper;
 
 	private final Set affectingFetchProfileNames = new HashSet();
 
 	private final Map uniqueKeyLoaders = new HashMap();
 	private final Map lockers = new HashMap();
 	private final Map loaders = new HashMap();
 
 	// SQL strings
 	private String sqlVersionSelectString;
 	private String sqlSnapshotSelectString;
 	private String sqlLazySelectString;
 
 	private String sqlIdentityInsertString;
 	private String sqlUpdateByRowIdString;
 	private String sqlLazyUpdateByRowIdString;
 
 	private String[] sqlDeleteStrings;
 	private String[] sqlInsertStrings;
 	private String[] sqlUpdateStrings;
 	private String[] sqlLazyUpdateStrings;
 
 	private String sqlInsertGeneratedValuesSelectString;
 	private String sqlUpdateGeneratedValuesSelectString;
 
 	//Custom SQL (would be better if these were private)
 	protected boolean[] insertCallable;
 	protected boolean[] updateCallable;
 	protected boolean[] deleteCallable;
 	protected String[] customSQLInsert;
 	protected String[] customSQLUpdate;
 	protected String[] customSQLDelete;
 	protected ExecuteUpdateResultCheckStyle[] insertResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] updateResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] deleteResultCheckStyles;
 
 	private InsertGeneratedIdentifierDelegate identityDelegate;
 
 	private boolean[] tableHasColumns;
 
 	private final String loaderName;
 
 	private UniqueEntityLoader queryLoader;
 
 	private final String temporaryIdTableName;
 	private final String temporaryIdTableDDL;
 
 	private final Map subclassPropertyAliases = new HashMap();
 	private final Map subclassPropertyColumnNames = new HashMap();
 
 	protected final BasicEntityPropertyMapping propertyMapping;
 
 	protected void addDiscriminatorToInsert(Insert insert) {}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {}
 
 	protected abstract int[] getSubclassColumnTableNumberClosure();
 
 	protected abstract int[] getSubclassFormulaTableNumberClosure();
 
 	public abstract String getSubclassTableName(int j);
 
 	protected abstract String[] getSubclassTableKeyColumns(int j);
 
 	protected abstract boolean isClassOrSuperclassTable(int j);
 
 	protected abstract int getSubclassTableSpan();
 
 	protected abstract int getTableSpan();
 
 	protected abstract boolean isTableCascadeDeleteEnabled(int j);
 
 	protected abstract String getTableName(int j);
 
 	protected abstract String[] getKeyColumns(int j);
 
 	protected abstract boolean isPropertyOfTable(int property, int j);
 
 	protected abstract int[] getPropertyTableNumbersInSelect();
 
 	protected abstract int[] getPropertyTableNumbers();
 
 	protected abstract int getSubclassPropertyTableNumber(int i);
 
 	protected abstract String filterFragment(String alias) throws MappingException;
 
 	private static final String DISCRIMINATOR_ALIAS = "clazz_";
 
 	public String getDiscriminatorColumnName() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaders() {
 		return DISCRIMINATOR_ALIAS;
 	}	
 	
 	public String getDiscriminatorColumnReaderTemplate() {
 		return DISCRIMINATOR_ALIAS;
 	}	
 	
 	protected String getDiscriminatorAlias() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorFormulaTemplate() {
 		return null;
 	}
 
 	protected boolean isInverseTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableSubclassTable(int j) {
 		return false;
 	}
 
 	protected boolean isInverseSubclassTable(int j) {
 		return false;
 	}
 
 	public boolean isSubclassEntityName(String entityName) {
 		return entityMetamodel.getSubclassEntityNames().contains(entityName);
 	}
 
 	private boolean[] getTableHasColumns() {
 		return tableHasColumns;
 	}
 
 	public String[] getRootTableKeyColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	protected String[] getSQLUpdateByRowIdStrings() {
 		if ( sqlUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan() + 1];
 		result[0] = sqlUpdateByRowIdString;
 		System.arraycopy( sqlUpdateStrings, 0, result, 1, getTableSpan() );
 		return result;
 	}
 
 	protected String[] getSQLLazyUpdateByRowIdStrings() {
 		if ( sqlLazyUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan()];
 		result[0] = sqlLazyUpdateByRowIdString;
 		for ( int i = 1; i < getTableSpan(); i++ ) {
 			result[i] = sqlLazyUpdateStrings[i];
 		}
 		return result;
 	}
 
 	protected String getSQLSnapshotSelectString() {
 		return sqlSnapshotSelectString;
 	}
 
 	protected String getSQLLazySelectString() {
 		return sqlLazySelectString;
 	}
 
 	protected String[] getSQLDeleteStrings() {
 		return sqlDeleteStrings;
 	}
 
 	protected String[] getSQLInsertStrings() {
 		return sqlInsertStrings;
 	}
 
 	protected String[] getSQLUpdateStrings() {
 		return sqlUpdateStrings;
 	}
 
 	protected String[] getSQLLazyUpdateStrings() {
 		return sqlLazyUpdateStrings;
 	}
 
 	/**
 	 * The query that inserts a row, letting the database generate an id
 	 * 
 	 * @return The IDENTITY-based insertion query.
 	 */
 	protected String getSQLIdentityInsertString() {
 		return sqlIdentityInsertString;
 	}
 
 	protected String getVersionSelectString() {
 		return sqlVersionSelectString;
 	}
 
 	protected boolean isInsertCallable(int j) {
 		return insertCallable[j];
 	}
 
 	protected boolean isUpdateCallable(int j) {
 		return updateCallable[j];
 	}
 
 	protected boolean isDeleteCallable(int j) {
 		return deleteCallable[j];
 	}
 
 	protected boolean isSubclassPropertyDeferred(String propertyName, String entityName) {
 		return false;
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return false;
 	}
 
 	public boolean hasSequentialSelect() {
 		return false;
 	}
 
 	/**
 	 * Decide which tables need to be updated.
 	 * <p/>
 	 * The return here is an array of boolean values with each index corresponding
 	 * to a given table in the scope of this persister.
 	 *
 	 * @param dirtyProperties The indices of all the entity properties considered dirty.
 	 * @param hasDirtyCollection Whether any collections owned by the entity which were considered dirty.
 	 *
 	 * @return Array of booleans indicating which table require updating.
 	 */
 	protected boolean[] getTableUpdateNeeded(final int[] dirtyProperties, boolean hasDirtyCollection) {
 
 		if ( dirtyProperties == null ) {
 			return getTableHasColumns(); // for objects that came in via update()
 		}
 		else {
 			boolean[] updateability = getPropertyUpdateability();
 			int[] propertyTableNumbers = getPropertyTableNumbers();
 			boolean[] tableUpdateNeeded = new boolean[ getTableSpan() ];
 			for ( int i = 0; i < dirtyProperties.length; i++ ) {
 				int property = dirtyProperties[i];
 				int table = propertyTableNumbers[property];
 				tableUpdateNeeded[table] = tableUpdateNeeded[table] ||
 						( getPropertyColumnSpan(property) > 0 && updateability[property] );
 			}
 			if ( isVersioned() ) {
 				tableUpdateNeeded[0] = tableUpdateNeeded[0] ||
 					Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 			}
 			return tableUpdateNeeded;
 		}
 	}
 
 	public boolean hasRowId() {
 		return rowIdName != null;
 	}
 
 	protected boolean[][] getPropertyColumnUpdateable() {
 		return propertyColumnUpdateable;
 	}
 
 	protected boolean[][] getPropertyColumnInsertable() {
 		return propertyColumnInsertable;
 	}
 
 	protected boolean[] getPropertySelectable() {
 		return propertySelectable;
 	}
 
 	public AbstractEntityPersister(
 			final PersistentClass persistentClass,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final SessionFactoryImplementor factory) throws HibernateException {
 
 		// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		this.factory = factory;
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		isLazyPropertiesCacheable = persistentClass.isLazyPropertiesCacheable();
 		this.cacheEntryStructure = factory.getSettings().isStructuredCacheEntriesEnabled() ?
 				(CacheEntryStructure) new StructuredCacheEntry(this) :
 				(CacheEntryStructure) new UnstructuredCacheEntry();
 
 		this.entityMetamodel = new EntityMetamodel( persistentClass, factory );
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		int batch = persistentClass.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSettings().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 		hasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();
 
 		propertyMapping = new BasicEntityPropertyMapping( this );
 
 		// IDENTIFIER
 
 		identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
 		rootTableKeyColumnNames = new String[identifierColumnSpan];
 		rootTableKeyColumnReaders = new String[identifierColumnSpan];
 		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
 		identifierAliases = new String[identifierColumnSpan];
 
 		rowIdName = persistentClass.getRootTable().getRowId();
 
 		loaderName = persistentClass.getLoaderName();
 
 		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Column col = ( Column ) iter.next();
 			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
 			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
 			rootTableKeyColumnReaderTemplates[i] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 			i++;
 		}
 
 		// VERSION
 
 		if ( persistentClass.isVersioned() ) {
 			versionColumnName = ( ( Column ) persistentClass.getVersion().getColumnIterator().next() ).getQuotedName( factory.getDialect() );
 		}
 		else {
 			versionColumnName = null;
 		}
 
 		//WHERE STRING
 
 		sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
 		sqlWhereStringTemplate = sqlWhereString == null ?
 				null :
 				Template.renderWhereStringTemplate( sqlWhereString, factory.getDialect(), factory.getSqlFunctionRegistry() );
 
 		// PROPERTIES
 
 		final boolean lazyAvailable = isInstrumented(EntityMode.POJO);
 
 		int hydrateSpan = entityMetamodel.getPropertySpan();
 		propertyColumnSpans = new int[hydrateSpan];
 		propertySubclassNames = new String[hydrateSpan];
 		propertyColumnAliases = new String[hydrateSpan][];
 		propertyColumnNames = new String[hydrateSpan][];
 		propertyColumnFormulaTemplates = new String[hydrateSpan][];
 		propertyColumnReaderTemplates = new String[hydrateSpan][];
 		propertyColumnWriters = new String[hydrateSpan][];
 		propertyUniqueness = new boolean[hydrateSpan];
 		propertySelectable = new boolean[hydrateSpan];
 		propertyColumnUpdateable = new boolean[hydrateSpan][];
 		propertyColumnInsertable = new boolean[hydrateSpan][];
 		HashSet thisClassProperties = new HashSet();
 
 		lazyProperties = new HashSet();
 		ArrayList lazyNames = new ArrayList();
 		ArrayList lazyNumbers = new ArrayList();
 		ArrayList lazyTypes = new ArrayList();
 		ArrayList lazyColAliases = new ArrayList();
 
 		iter = persistentClass.getPropertyClosureIterator();
 		i = 0;
 		boolean foundFormula = false;
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			thisClassProperties.add( prop );
 
 			int span = prop.getColumnSpan();
 			propertyColumnSpans[i] = span;
 			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
 			String[] colNames = new String[span];
 			String[] colAliases = new String[span];
 			String[] colReaderTemplates = new String[span];
 			String[] colWriters = new String[span];
 			String[] formulaTemplates = new String[span];
 			Iterator colIter = prop.getColumnIterator();
 			int k = 0;
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
 				if ( thing.isFormula() ) {
 					foundFormula = true;
 					formulaTemplates[k] = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				}
 				else {
 					Column col = (Column)thing;
 					colNames[k] = col.getQuotedName( factory.getDialect() );
 					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					colWriters[k] = col.getWriteExpr();
 				}
 				k++;
 			}
 			propertyColumnNames[i] = colNames;
 			propertyColumnFormulaTemplates[i] = formulaTemplates;
 			propertyColumnReaderTemplates[i] = colReaderTemplates;
 			propertyColumnWriters[i] = colWriters;
 			propertyColumnAliases[i] = colAliases;
 
 			if ( lazyAvailable && prop.isLazy() ) {
 				lazyProperties.add( prop.getName() );
 				lazyNames.add( prop.getName() );
 				lazyNumbers.add( new Integer( i ) );
 				lazyTypes.add( prop.getValue().getType() );
 				lazyColAliases.add( colAliases );
 			}
 
 			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
 			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
 
 			propertySelectable[i] = prop.isSelectable();
 
 			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
 
 			i++;
 
 		}
 		hasFormulaProperties = foundFormula;
 		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
 		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
 		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
 		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
 
 		// SUBCLASS PROPERTY CLOSURE
 
 		ArrayList columns = new ArrayList();
 		ArrayList columnsLazy = new ArrayList();
 		ArrayList columnReaderTemplates = new ArrayList();
 		ArrayList aliases = new ArrayList();
 		ArrayList formulas = new ArrayList();
 		ArrayList formulaAliases = new ArrayList();
 		ArrayList formulaTemplates = new ArrayList();
 		ArrayList formulasLazy = new ArrayList();
 		ArrayList types = new ArrayList();
 		ArrayList names = new ArrayList();
 		ArrayList classes = new ArrayList();
 		ArrayList templates = new ArrayList();
 		ArrayList propColumns = new ArrayList();
 		ArrayList propColumnReaders = new ArrayList();
 		ArrayList propColumnReaderTemplates = new ArrayList();
 		ArrayList joinedFetchesList = new ArrayList();
 		ArrayList cascades = new ArrayList();
 		ArrayList definedBySubclass = new ArrayList();
 		ArrayList propColumnNumbers = new ArrayList();
 		ArrayList propFormulaNumbers = new ArrayList();
 		ArrayList columnSelectables = new ArrayList();
 		ArrayList propNullables = new ArrayList();
 
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			names.add( prop.getName() );
 			classes.add( prop.getPersistentClass().getEntityName() );
 			boolean isDefinedBySubclass = !thisClassProperties.contains( prop );
 			definedBySubclass.add( Boolean.valueOf( isDefinedBySubclass ) );
 			propNullables.add( Boolean.valueOf( prop.isOptional() || isDefinedBySubclass ) ); //TODO: is this completely correct?
 			types.add( prop.getType() );
 
 			Iterator colIter = prop.getColumnIterator();
 			String[] cols = new String[prop.getColumnSpan()];
 			String[] readers = new String[prop.getColumnSpan()];
 			String[] readerTemplates = new String[prop.getColumnSpan()];
 			String[] forms = new String[prop.getColumnSpan()];
 			int[] colnos = new int[prop.getColumnSpan()];
 			int[] formnos = new int[prop.getColumnSpan()];
 			int l = 0;
 			Boolean lazy = Boolean.valueOf( prop.isLazy() && lazyAvailable );
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				if ( thing.isFormula() ) {
 					String template = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					formnos[l] = formulaTemplates.size();
 					colnos[l] = -1;
 					formulaTemplates.add( template );
 					forms[l] = template;
 					formulas.add( thing.getText( factory.getDialect() ) );
 					formulaAliases.add( thing.getAlias( factory.getDialect() ) );
 					formulasLazy.add( lazy );
 				}
 				else {
 					Column col = (Column)thing;
 					String colName = col.getQuotedName( factory.getDialect() );
 					colnos[l] = columns.size(); //before add :-)
 					formnos[l] = -1;
 					columns.add( colName );
 					cols[l] = colName;
 					aliases.add( thing.getAlias( factory.getDialect(), prop.getValue().getTable() ) );
 					columnsLazy.add( lazy );
 					columnSelectables.add( Boolean.valueOf( prop.isSelectable() ) );
 					
 					readers[l] = col.getReadExpr( factory.getDialect() );
 					String readerTemplate = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					readerTemplates[l] = readerTemplate;
 					columnReaderTemplates.add( readerTemplate );
 				}
 				l++;
 			}
 			propColumns.add( cols );
 			propColumnReaders.add( readers );
 			propColumnReaderTemplates.add( readerTemplates );
 			templates.add( forms );
 			propColumnNumbers.add( colnos );
 			propFormulaNumbers.add( formnos );
 
 			joinedFetchesList.add( prop.getValue().getFetchMode() );
 			cascades.add( prop.getCascadeStyle() );
 		}
 		subclassColumnClosure = ArrayHelper.toStringArray( columns );
 		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
 		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
 		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
 		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
 
 		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
 		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
 		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
 		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
 
 		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
 		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
 		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
 		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
 		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
 		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
 		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
 		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
 		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
 		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
 
 		subclassPropertyCascadeStyleClosure = new CascadeStyle[cascades.size()];
 		iter = cascades.iterator();
 		int j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyCascadeStyleClosure[j++] = ( CascadeStyle ) iter.next();
 		}
 		subclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];
 		iter = joinedFetchesList.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyFetchModeClosure[j++] = ( FetchMode ) iter.next();
 		}
 
 		propertyDefinedOnSubclass = new boolean[definedBySubclass.size()];
 		iter = definedBySubclass.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			propertyDefinedOnSubclass[j++] = ( ( Boolean ) iter.next() ).booleanValue();
 		}
 
 		// Handle any filters applied to the class level
 		filterHelper = new FilterHelper( persistentClass.getFilterMap(), factory.getDialect(), factory.getSqlFunctionRegistry() );
 
 		temporaryIdTableName = persistentClass.getTemporaryIdTableName();
 		temporaryIdTableDDL = persistentClass.getTemporaryIdTableDDL();
 	}
 
 	protected String generateLazySelectString() {
 
 		if ( !entityMetamodel.hasLazyProperties() ) {
 			return null;
 		}
 
 		HashSet tableNumbers = new HashSet();
 		ArrayList columnNumbers = new ArrayList();
 		ArrayList formulaNumbers = new ArrayList();
 		for ( int i = 0; i < lazyPropertyNames.length; i++ ) {
 			// all this only really needs to consider properties
 			// of this class, not its subclasses, but since we
 			// are reusing code used for sequential selects, we
 			// use the subclass closure
 			int propertyNumber = getSubclassPropertyIndex( lazyPropertyNames[i] );
 
 			int tableNumber = getSubclassPropertyTableNumber( propertyNumber );
 			tableNumbers.add( new Integer( tableNumber ) );
 
 			int[] colNumbers = subclassPropertyColumnNumberClosure[propertyNumber];
 			for ( int j = 0; j < colNumbers.length; j++ ) {
 				if ( colNumbers[j]!=-1 ) {
 					columnNumbers.add( new Integer( colNumbers[j] ) );
 				}
 			}
 			int[] formNumbers = subclassPropertyFormulaNumberClosure[propertyNumber];
 			for ( int j = 0; j < formNumbers.length; j++ ) {
 				if ( formNumbers[j]!=-1 ) {
 					formulaNumbers.add( new Integer( formNumbers[j] ) );
 				}
 			}
 		}
 
 		if ( columnNumbers.size()==0 && formulaNumbers.size()==0 ) {
 			// only one-to-one is lazy fetched
 			return null;
 		}
 
 		return renderSelect( ArrayHelper.toIntArray( tableNumbers ),
 				ArrayHelper.toIntArray( columnNumbers ),
 				ArrayHelper.toIntArray( formulaNumbers ) );
 
 	}
 
 	public Object initializeLazyProperty(String fieldName, Object entity, SessionImplementor session)
 			throws HibernateException {
 
 		final Serializable id = session.getContextEntityIdentifier( entity );
 
 		final EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			throw new HibernateException( "entity is not associated with the session: " + id );
 		}
 
 		if ( log.isTraceEnabled() ) {
 			log.trace(
 					"initializing lazy properties of: " +
 					MessageHelper.infoString( this, id, getFactory() ) +
 					", field access: " + fieldName
 				);
 		}
 
 		if ( hasCache() ) {
 			CacheKey cacheKey = new CacheKey(id, getIdentifierType(), getEntityName(), session.getEntityMode(), getFactory() );
 			Object ce = getCacheAccessStrategy().get( cacheKey, session.getTimestamp() );
 			if (ce!=null) {
 				CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure(ce, factory);
 				if ( !cacheEntry.areLazyPropertiesUnfetched() ) {
 					//note early exit here:
 					return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
 				}
 			}
 		}
 
 		return initializeLazyPropertiesFromDatastore( fieldName, entity, session, id, entry );
 
 	}
 
 	private Object initializeLazyPropertiesFromDatastore(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Serializable id,
 			final EntityEntry entry) {
 
 		if ( !hasLazyProperties() ) {
 			throw new AssertionFailure("no lazy properties");
 		}
 
 		log.trace("initializing lazy properties from datastore");
 
 		try {
 
 			Object result = null;
 			PreparedStatement ps = null;
 			try {
 				final String lazySelect = getSQLLazySelectString();
 				ResultSet rs = null;
 				try {
 					if ( lazySelect != null ) {
 						// null sql means that the only lazy properties
 						// are shared PK one-to-one associations which are
 						// handled differently in the Type#nullSafeGet code...
-						ps = session.getJDBCContext().getConnectionManager().prepareSelectStatement(lazySelect);
+						ps = session.getTransactionCoordinator()
+								.getJdbcCoordinator()
+								.getStatementPreparer()
+								.prepareStatement( lazySelect );
 						getIdentifierType().nullSafeSet( ps, id, 1, session );
 						rs = ps.executeQuery();
 						rs.next();
 					}
 					final Object[] snapshot = entry.getLoadedState();
 					for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 						Object propValue = lazyPropertyTypes[j].nullSafeGet( rs, lazyPropertyColumnAliases[j], session, entity );
 						if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 							result = propValue;
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						rs.close();
 					}
 				}
 			}
 			finally {
 				if ( ps != null ) {
 					ps.close();
 				}
 			}
 
 			log.trace( "done initializing lazy properties" );
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize lazy properties: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					getSQLLazySelectString()
 				);
 		}
 	}
 
 	private Object initializeLazyPropertiesFromCache(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final EntityEntry entry,
 			final CacheEntry cacheEntry
 	) {
 
 		log.trace("initializing lazy properties from second-level cache");
 
 		Object result = null;
 		Serializable[] disassembledValues = cacheEntry.getDisassembledState();
 		final Object[] snapshot = entry.getLoadedState();
 		for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 			final Object propValue = lazyPropertyTypes[j].assemble(
 					disassembledValues[ lazyPropertyNumbers[j] ],
 					session,
 					entity
 				);
 			if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 				result = propValue;
 			}
 		}
 
 		log.trace( "done initializing lazy properties" );
 
 		return result;
 	}
 
 	private boolean initializeLazyProperty(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Object[] snapshot,
 			final int j,
 			final Object propValue) {
 		setPropertyValue( entity, lazyPropertyNumbers[j], propValue, session.getEntityMode() );
 		if (snapshot != null) {
 			// object have been loaded with setReadOnly(true); HHH-2236
 			snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, session.getEntityMode(), factory );
 		}
 		return fieldName.equals( lazyPropertyNames[j] );
 	}
 
 	public boolean isBatchable() {
 		return optimisticLockMode()==Versioning.OPTIMISTIC_LOCK_NONE ||
 			( !isVersioned() && optimisticLockMode()==Versioning.OPTIMISTIC_LOCK_VERSION ) ||
 			getFactory().getSettings().isJdbcBatchVersionedData();
 	}
 
 	public Serializable[] getQuerySpaces() {
 		return getPropertySpaces();
 	}
 
 	protected Set getLazyProperties() {
 		return lazyProperties;
 	}
 
 	public boolean isBatchLoadable() {
 		return batchSize > 1;
 	}
 
 	public String[] getIdentifierColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	public String[] getIdentifierColumnReaders() {
 		return rootTableKeyColumnReaders;
 	}	
 
 	public String[] getIdentifierColumnReaderTemplates() {
 		return rootTableKeyColumnReaderTemplates;
 	}	
 	
 	protected int getIdentifierColumnSpan() {
 		return identifierColumnSpan;
 	}
 
 	protected String[] getIdentifierAliases() {
 		return identifierAliases;
 	}
 
 	public String getVersionColumnName() {
 		return versionColumnName;
 	}
 
 	protected String getVersionedTableName() {
 		return getTableName( 0 );
 	}
 
 	protected boolean[] getSubclassColumnLazyiness() {
 		return subclassColumnLazyClosure;
 	}
 
 	protected boolean[] getSubclassFormulaLazyiness() {
 		return subclassFormulaLazyClosure;
 	}
 
 	/**
 	 * We can't immediately add to the cache if we have formulas
 	 * which must be evaluated, or if we have the possibility of
 	 * two concurrent updates to the same item being merged on
 	 * the database. This can happen if (a) the item is not
 	 * versioned and either (b) we have dynamic update enabled
 	 * or (c) we have multiple tables holding the state of the
 	 * item.
 	 */
 	public boolean isCacheInvalidationRequired() {
 		return hasFormulaProperties() ||
 				( !isVersioned() && ( entityMetamodel.isDynamicUpdate() || getTableSpan() > 1 ) );
 	}
 
 	public boolean isLazyPropertiesCacheable() {
 		return isLazyPropertiesCacheable;
 	}
 
 	public String selectFragment(String alias, String suffix) {
 		return identifierSelectFragment( alias, suffix ) +
 				propertySelectFragment( alias, suffix, false );
 	}
 
 	public String[] getIdentifierAliases(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );
 	}
 
 	public String[] getPropertyAliases(String suffix, int i) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		return new Alias( suffix ).toUnquotedAliasStrings( propertyColumnAliases[i] );
 	}
 
 	public String getDiscriminatorAlias(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return entityMetamodel.hasSubclasses() ?
 				new Alias( suffix ).toAliasString( getDiscriminatorAlias() ) :
 				null;
 	}
 
 	public String identifierSelectFragment(String name, String suffix) {
 		return new SelectFragment()
 				.setSuffix( suffix )
 				.addColumns( name, getIdentifierColumnNames(), getIdentifierAliases() )
 				.toFragmentString()
 				.substring( 2 ); //strip leading ", "
 	}
 
 
 	public String propertySelectFragment(String tableAlias, String suffix, boolean allProperties) {
 		return propertySelectFragmentFragment( tableAlias, suffix, allProperties ).toFragmentString();
 	}
 
 	public SelectFragment propertySelectFragmentFragment(
 			String tableAlias,
 			String suffix,
 			boolean allProperties) {
 		SelectFragment select = new SelectFragment()
 				.setSuffix( suffix )
 				.setUsedAliases( getIdentifierAliases() );
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < getSubclassColumnClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassColumnLazyClosure[i] ) &&
 				!isSubclassTableSequentialSelect( columnTableNumbers[i] ) &&
 				subclassColumnSelectableClosure[i];
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, columnTableNumbers[i] );
 				select.addColumnTemplate( subalias, columnReaderTemplates[i], columnAliases[i] );
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < getSubclassFormulaTemplateClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassFormulaLazyClosure[i] )
 				&& !isSubclassTableSequentialSelect( formulaTableNumbers[i] );
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, formulaTableNumbers[i] );
 				select.addFormula( subalias, formulaTemplates[i], formulaAliases[i] );
 			}
 		}
 
 		if ( entityMetamodel.hasSubclasses() ) {
 			addDiscriminatorToSelect( select, tableAlias, suffix );
 		}
 
 		if ( hasRowId() ) {
 			select.addColumn( tableAlias, rowIdName, ROWID_ALIAS );
 		}
 
 		return select;
 	}
 
 	public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Getting current persistent state for: " + MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		try {
-			PreparedStatement ps = session.getJDBCContext().getConnectionManager().prepareSelectStatement( getSQLSnapshotSelectString() );
+			PreparedStatement ps = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( getSQLSnapshotSelectString() );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				//if ( isVersioned() ) getVersionType().nullSafeSet( ps, version, getIdentifierColumnSpan()+1, session );
 				ResultSet rs = ps.executeQuery();
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
-
 					//otherwise return the "hydrated" state (ie. associations are not resolved)
 					Type[] types = getPropertyTypes();
 					Object[] values = new Object[types.length];
 					boolean[] includeProperty = getPropertyUpdateability();
 					for ( int i = 0; i < types.length; i++ ) {
 						if ( includeProperty[i] ) {
 							values[i] = types[i].hydrate( rs, getPropertyAliases( "", i ), session, null ); //null owner ok??
 						}
 					}
 					return values;
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				ps.close();
 			}
 		}
-		catch ( SQLException sqle ) {
+		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
-					"could not retrieve snapshot: " +
-					MessageHelper.infoString( this, id, getFactory() ),
+					e,
+					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        getSQLSnapshotSelectString()
-				);
+			);
 		}
 
 	}
 
 	/**
 	 * Generate the SQL that selects the version number by id
 	 */
 	protected String generateSelectVersionString() {
 		SimpleSelect select = new SimpleSelect( getFactory().getDialect() )
 				.setTableName( getVersionedTableName() );
 		if ( isVersioned() ) {
 			select.addColumn( versionColumnName );
 		}
 		else {
 			select.addColumns( rootTableKeyColumnNames );
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get version " + getEntityName() );
 		}
 		return select.addCondition( rootTableKeyColumnNames, "=?" ).toStatementString();
 	}
 
 	public boolean[] getPropertyUniqueness() {
 		return propertyUniqueness;
 	}
 
 	protected String generateInsertGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( getPropertyInsertGenerationInclusions() );
 	}
 
 	protected String generateUpdateGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( getPropertyUpdateGenerationInclusions() );
 	}
 
 	private String generateGeneratedValuesSelectString(ValueInclusion[] inclusions) {
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get generated state " + getEntityName() );
 		}
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 
 		// Here we render the select column list based on the properties defined as being generated.
 		// For partial component generation, we currently just re-select the whole component
 		// rather than trying to handle the individual generated portions.
 		String selectClause = concretePropertySelectFragment( getRootAlias(), inclusions );
 		selectClause = selectClause.substring( 2 );
 
 		String fromClause = fromTableFragment( getRootAlias() ) +
 				fromJoinFragment( getRootAlias(), true, false );
 
 		String whereClause = new StringBuffer()
 			.append( StringHelper.join( "=? and ", aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		return select.setSelectClause( selectClause )
 				.setFromClause( fromClause )
 				.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 	}
 
 	protected static interface InclusionChecker {
 		public boolean includeProperty(int propertyNumber);
 	}
 
 	protected String concretePropertySelectFragment(String alias, final ValueInclusion[] inclusions) {
 		return concretePropertySelectFragment(
 				alias,
 				new InclusionChecker() {
 					// TODO : currently we really do not handle ValueInclusion.PARTIAL...
 					// ValueInclusion.PARTIAL would indicate parts of a component need to
 					// be included in the select; currently we then just render the entire
 					// component into the select clause in that case.
 					public boolean includeProperty(int propertyNumber) {
 						return inclusions[propertyNumber] != ValueInclusion.NONE;
 					}
 				}
 		);
 	}
 
 	protected String concretePropertySelectFragment(String alias, final boolean[] includeProperty) {
 		return concretePropertySelectFragment(
 				alias,
 				new InclusionChecker() {
 					public boolean includeProperty(int propertyNumber) {
 						return includeProperty[propertyNumber];
 					}
 				}
 		);
 	}
 
 	protected String concretePropertySelectFragment(String alias, InclusionChecker inclusionChecker) {
 		int propertyCount = getPropertyNames().length;
 		int[] propertyTableNumbers = getPropertyTableNumbersInSelect();
 		SelectFragment frag = new SelectFragment();
 		for ( int i = 0; i < propertyCount; i++ ) {
 			if ( inclusionChecker.includeProperty( i ) ) {
 				frag.addColumnTemplates(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnReaderTemplates[i],
 						propertyColumnAliases[i]
 				);
 				frag.addFormulas(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnFormulaTemplates[i],
 						propertyColumnAliases[i]
 				);
 			}
 		}
 		return frag.toFragmentString();
 	}
 
 	protected String generateSnapshotSelectString() {
 
 		//TODO: should we use SELECT .. FOR UPDATE?
 
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current state " + getEntityName() );
 		}
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 		String selectClause = StringHelper.join( ", ", aliasedIdColumns ) +
 				concretePropertySelectFragment( getRootAlias(), getPropertyUpdateability() );
 
 		String fromClause = fromTableFragment( getRootAlias() ) +
 				fromJoinFragment( getRootAlias(), true, false );
 
 		String whereClause = new StringBuffer()
 			.append( StringHelper.join( "=? and ",
 					aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		/*if ( isVersioned() ) {
 			where.append(" and ")
 				.append( getVersionColumnName() )
 				.append("=?");
 		}*/
 
 		return select.setSelectClause( selectClause )
 				.setFromClause( fromClause )
 				.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 	}
 
 	public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session) {
 		if ( !isVersioned() ) {
 			throw new AssertionFailure( "cannot force version increment on non-versioned entity" );
 		}
 
 		if ( isVersionPropertyGenerated() ) {
 			// the difficulty here is exactly what do we update in order to
 			// force the version to be incremented in the db...
 			throw new HibernateException( "LockMode.FORCE is currently not supported for generated version properties" );
 		}
 
 		Object nextVersion = getVersionType().next( currentVersion, session );
 		if ( log.isTraceEnabled() ) {
 			log.trace(
 					"Forcing version increment [" + MessageHelper.infoString( this, id, getFactory() ) +
 					"; " + getVersionType().toLoggableString( currentVersion, getFactory() ) +
 					" -> " + getVersionType().toLoggableString( nextVersion, getFactory() ) + "]"
 			);
 		}
 
 		// todo : cache this sql...
 		String versionIncrementString = generateVersionIncrementUpdateString();
 		PreparedStatement st = null;
 		try {
+			st = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( versionIncrementString, false );
 			try {
-				st = session.getJDBCContext().getConnectionManager().prepareStatement( versionIncrementString, false );
 				getVersionType().nullSafeSet( st, nextVersion, 1, session );
 				getIdentifierType().nullSafeSet( st, id, 2, session );
 				getVersionType().nullSafeSet( st, currentVersion, 2 + getIdentifierColumnSpan(), session );
 				int rows = st.executeUpdate();
 				if ( rows != 1 ) {
 					throw new StaleObjectStateException( getEntityName(), id );
 				}
 			}
 			finally {
 				st.close();
 			}
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not retrieve version: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					getVersionSelectString()
 				);
 		}
 
 		return nextVersion;
 	}
 
 	private String generateVersionIncrementUpdateString() {
 		Update update = new Update( getFactory().getDialect() );
 		update.setTableName( getTableName( 0 ) );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "forced version increment" );
 		}
 		update.addColumn( getVersionColumnName() );
 		update.addPrimaryKeyColumns( getIdentifierColumnNames() );
 		update.setVersionColumnName( getVersionColumnName() );
 		return update.toStatementString();
 	}
 
 	/**
 	 * Retrieve the version number
 	 */
 	public Object getCurrentVersion(Serializable id, SessionImplementor session) throws HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Getting version: " + MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		try {
-
-			PreparedStatement st = session.getJDBCContext().getConnectionManager().prepareSelectStatement( getVersionSelectString() );
+			PreparedStatement st = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( getVersionSelectString() );
 			try {
 				getIdentifierType().nullSafeSet( st, id, 1, session );
-
 				ResultSet rs = st.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						return null;
 					}
 					if ( !isVersioned() ) {
 						return this;
 					}
 					return getVersionType().nullSafeGet( rs, getVersionColumnName(), session, null );
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				st.close();
 			}
-
 		}
-		catch ( SQLException sqle ) {
+		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
-					"could not retrieve version: " +
-					MessageHelper.infoString( this, id, getFactory() ),
+					e,
+					"could not retrieve version: " + MessageHelper.infoString( this, id, getFactory() ),
 					getVersionSelectString()
-				);
+			);
 		}
-
 	}
 
 	protected void initLockers() {
 		lockers.put( LockMode.READ, generateLocker( LockMode.READ ) );
 		lockers.put( LockMode.UPGRADE, generateLocker( LockMode.UPGRADE ) );
 		lockers.put( LockMode.UPGRADE_NOWAIT, generateLocker( LockMode.UPGRADE_NOWAIT ) );
 		lockers.put( LockMode.FORCE, generateLocker( LockMode.FORCE ) );
 		lockers.put( LockMode.PESSIMISTIC_READ, generateLocker( LockMode.PESSIMISTIC_READ ) );
 		lockers.put( LockMode.PESSIMISTIC_WRITE, generateLocker( LockMode.PESSIMISTIC_WRITE ) );
 		lockers.put( LockMode.PESSIMISTIC_FORCE_INCREMENT, generateLocker( LockMode.PESSIMISTIC_FORCE_INCREMENT ) );
 		lockers.put( LockMode.OPTIMISTIC, generateLocker( LockMode.OPTIMISTIC ) );
 		lockers.put( LockMode.OPTIMISTIC_FORCE_INCREMENT, generateLocker( LockMode.OPTIMISTIC_FORCE_INCREMENT ) );
 	}
 
 	protected LockingStrategy generateLocker(LockMode lockMode) {
 		return factory.getDialect().getLockingStrategy( this, lockMode );
 	}
 
 	private LockingStrategy getLocker(LockMode lockMode) {
 		return ( LockingStrategy ) lockers.get( lockMode );
 	}
 
 	public void lock(
 			Serializable id,
 	        Object version,
 	        Object object,
 	        LockMode lockMode,
 	        SessionImplementor session) throws HibernateException {
 		getLocker( lockMode ).lock( id, version, object, LockOptions.WAIT_FOREVER, session );
 	}
 	
 	public void lock(
 			Serializable id,
 	        Object version,
 	        Object object,
 	        LockOptions lockOptions,
 	        SessionImplementor session) throws HibernateException {
 		getLocker( lockOptions.getLockMode() ).lock( id, version, object, lockOptions.getTimeOut(), session );
 	}
 
 	public String getRootTableName() {
 		return getSubclassTableName( 0 );
 	}
 
 	public String getRootTableAlias(String drivingAlias) {
 		return drivingAlias;
 	}
 
 	public String[] getRootTableIdentifierColumnNames() {
 		return getRootTableKeyColumnNames();
 	}
 
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		return propertyMapping.toColumns( alias, propertyName );
 	}
 
 	public String[] toColumns(String propertyName) throws QueryException {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	public Type toType(String propertyName) throws QueryException {
 		return propertyMapping.toType( propertyName );
 	}
 
 	public String[] getPropertyColumnNames(String propertyName) {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	/**
 	 * Warning:
 	 * When there are duplicated property names in the subclasses
 	 * of the class, this method may return the wrong table
 	 * number for the duplicated subclass property (note that
 	 * SingleTableEntityPersister defines an overloaded form
 	 * which takes the entity name.
 	 */
 	public int getSubclassPropertyTableNumber(String propertyPath) {
 		String rootPropertyName = StringHelper.root(propertyPath);
 		Type type = propertyMapping.toType(rootPropertyName);
 		if ( type.isAssociationType() ) {
 			AssociationType assocType = ( AssociationType ) type;
 			if ( assocType.useLHSPrimaryKey() ) {
 				// performance op to avoid the array search
 				return 0;
 			}
 			else if ( type.isCollectionType() ) {
 				// properly handle property-ref-based associations
 				rootPropertyName = assocType.getLHSPropertyName();
 			}
 		}
 		//Enable for HHH-440, which we don't like:
 		/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {
 			String unrooted = StringHelper.unroot(propertyName);
 			int idx = ArrayHelper.indexOf( getSubclassColumnClosure(), unrooted );
 			if ( idx != -1 ) {
 				return getSubclassColumnTableNumberClosure()[idx];
 			}
 		}*/
 		int index = ArrayHelper.indexOf( getSubclassPropertyNameClosure(), rootPropertyName); //TODO: optimize this better!
 		return index==-1 ? 0 : getSubclassPropertyTableNumber(index);
 	}
 
 	public Declarer getSubclassPropertyDeclarer(String propertyPath) {
 		int tableIndex = getSubclassPropertyTableNumber( propertyPath );
 		if ( tableIndex == 0 ) {
 			return Declarer.CLASS;
 		}
 		else if ( isClassOrSuperclassTable( tableIndex ) ) {
 			return Declarer.SUPERCLASS;
 		}
 		else {
 			return Declarer.SUBCLASS;
 		}
 	}
 
 	private DiscriminatorMetadata discriminatorMetadata;
 
 	public DiscriminatorMetadata getTypeDiscriminatorMetadata() {
 		if ( discriminatorMetadata == null ) {
 			discriminatorMetadata = buildTypeDiscriminatorMetadata();
 		}
 		return discriminatorMetadata;
 	}
 
 	private DiscriminatorMetadata buildTypeDiscriminatorMetadata() {
 		return new DiscriminatorMetadata() {
 			public String getSqlFragment(String sqlQualificationAlias) {
 				return toColumns( sqlQualificationAlias, ENTITY_CLASS )[0];
 			}
 
 			public Type getResolutionType() {
 				return new DiscriminatorType( getDiscriminatorType(), AbstractEntityPersister.this );
 			}
 		};
 	}
 
 	protected String generateTableAlias(String rootAlias, int tableNumber) {
 		if ( tableNumber == 0 ) {
 			return rootAlias;
 		}
 		StringBuffer buf = new StringBuffer().append( rootAlias );
 		if ( !rootAlias.endsWith( "_" ) ) {
 			buf.append( '_' );
 		}
 		return buf.append( tableNumber ).append( '_' ).toString();
 	}
 
 	public String[] toColumns(String name, final int i) {
 		final String alias = generateTableAlias( name, getSubclassPropertyTableNumber( i ) );
 		String[] cols = getSubclassPropertyColumnNames( i );
 		String[] templates = getSubclassPropertyFormulaTemplateClosure()[i];
 		String[] result = new String[cols.length];
 		for ( int j = 0; j < cols.length; j++ ) {
 			if ( cols[j] == null ) {
 				result[j] = StringHelper.replace( templates[j], Template.TEMPLATE, alias );
 			}
 			else {
 				result[j] = StringHelper.qualify( alias, cols[j] );
 			}
 		}
 		return result;
 	}
 
 	private int getSubclassPropertyIndex(String propertyName) {
 		return ArrayHelper.indexOf(subclassPropertyNameClosure, propertyName);
 	}
 
 	protected String[] getPropertySubclassNames() {
 		return propertySubclassNames;
 	}
 
 	public String[] getPropertyColumnNames(int i) {
 		return propertyColumnNames[i];
 	}
 	
 	public String[] getPropertyColumnWriters(int i) {
 		return propertyColumnWriters[i];
 	}	
 
 	protected int getPropertyColumnSpan(int i) {
 		return propertyColumnSpans[i];
 	}
 
 	protected boolean hasFormulaProperties() {
 		return hasFormulaProperties;
 	}
 
 	public FetchMode getFetchMode(int i) {
 		return subclassPropertyFetchModeClosure[i];
 	}
 
 	public CascadeStyle getCascadeStyle(int i) {
 		return subclassPropertyCascadeStyleClosure[i];
 	}
 
 	public Type getSubclassPropertyType(int i) {
 		return subclassPropertyTypeClosure[i];
 	}
 
 	public String getSubclassPropertyName(int i) {
 		return subclassPropertyNameClosure[i];
 	}
 
 	public int countSubclassProperties() {
 		return subclassPropertyTypeClosure.length;
 	}
 
 	public String[] getSubclassPropertyColumnNames(int i) {
 		return subclassPropertyColumnNameClosure[i];
 	}
 
 	public boolean isDefinedOnSubclass(int i) {
 		return propertyDefinedOnSubclass[i];
 	}
 
 	protected String[][] getSubclassPropertyFormulaTemplateClosure() {
 		return subclassPropertyFormulaTemplateClosure;
 	}
 
 	protected Type[] getSubclassPropertyTypeClosure() {
 		return subclassPropertyTypeClosure;
 	}
 
 	protected String[][] getSubclassPropertyColumnNameClosure() {
 		return subclassPropertyColumnNameClosure;
 	}
 	
 	public String[][] getSubclassPropertyColumnReaderClosure() {
 		return subclassPropertyColumnReaderClosure;
 	}
 
 	public String[][] getSubclassPropertyColumnReaderTemplateClosure() {
 		return subclassPropertyColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassPropertyNameClosure() {
 		return subclassPropertyNameClosure;
 	}
 
 	protected String[] getSubclassPropertySubclassNameClosure() {
 		return subclassPropertySubclassNameClosure;
 	}
 
 	protected String[] getSubclassColumnClosure() {
 		return subclassColumnClosure;
 	}
 
 	protected String[] getSubclassColumnAliasClosure() {
 		return subclassColumnAliasClosure;
 	}
 
 	public String[] getSubclassColumnReaderTemplateClosure() {
 		return subclassColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaClosure() {
 		return subclassFormulaClosure;
 	}
 
 	protected String[] getSubclassFormulaTemplateClosure() {
 		return subclassFormulaTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaAliasClosure() {
 		return subclassFormulaAliasClosure;
 	}
 
 	public String[] getSubclassPropertyColumnAliases(String propertyName, String suffix) {
 		String rawAliases[] = ( String[] ) subclassPropertyAliases.get( propertyName );
 
 		if ( rawAliases == null ) {
 			return null;
 		}
 
 		String result[] = new String[rawAliases.length];
 		for ( int i = 0; i < rawAliases.length; i++ ) {
 			result[i] = new Alias( suffix ).toUnquotedAliasString( rawAliases[i] );
 		}
 		return result;
 	}
 
 	public String[] getSubclassPropertyColumnNames(String propertyName) {
 		//TODO: should we allow suffixes on these ?
 		return ( String[] ) subclassPropertyColumnNames.get( propertyName );
 	}
 
 
 
 	//This is really ugly, but necessary:
 	/**
 	 * Must be called by subclasses, at the end of their constructors
 	 */
 	protected void initSubclassPropertyAliasesMap(PersistentClass model) throws MappingException {
 
 		// ALIASES
 		internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
 
 		// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'
 		if ( ! entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			subclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );
 			subclassPropertyColumnNames.put( ENTITY_ID, getIdentifierColumnNames() );
 		}
 
 		// aliases named identifier ( alias.idname )
 		if ( hasIdentifierProperty() ) {
 			subclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );
 			subclassPropertyColumnNames.put( getIdentifierPropertyName(), getIdentifierColumnNames() );
 		}
 
 		// aliases for composite-id's
 		if ( getIdentifierType().isComponentType() ) {
 			// Fetch embedded identifiers propertynames from the "virtual" identifier component
 			CompositeType componentId = ( CompositeType ) getIdentifierType();
 			String[] idPropertyNames = componentId.getPropertyNames();
 			String[] idAliases = getIdentifierAliases();
 			String[] idColumnNames = getIdentifierColumnNames();
 
 			for ( int i = 0; i < idPropertyNames.length; i++ ) {
 				if ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 					subclassPropertyAliases.put(
 							ENTITY_ID + "." + idPropertyNames[i],
 							new String[] { idAliases[i] }
 					);
 					subclassPropertyColumnNames.put(
 							ENTITY_ID + "." + getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idColumnNames[i] }
 					);
 				}
 //				if (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyName() ) ) {
 				if ( hasIdentifierProperty() ) {
 					subclassPropertyAliases.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idAliases[i] }
 					);
 					subclassPropertyColumnNames.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idColumnNames[i] }
 					);
 				}
 				else {
 					// embedded composite ids ( alias.idname1, alias.idname2 )
 					subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );
 					subclassPropertyColumnNames.put( idPropertyNames[i],  new String[] { idColumnNames[i] } );
 				}
 			}
 		}
 
 		if ( entityMetamodel.isPolymorphic() ) {
 			subclassPropertyAliases.put( ENTITY_CLASS, new String[] { getDiscriminatorAlias() } );
 			subclassPropertyColumnNames.put( ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
 		}
 
 	}
 
 	private void internalInitSubclassPropertyAliasesMap(String path, Iterator propertyIterator) {
 		while ( propertyIterator.hasNext() ) {
 
 			Property prop = ( Property ) propertyIterator.next();
 			String propname = path == null ? prop.getName() : path + "." + prop.getName();
 			if ( prop.isComposite() ) {
 				Component component = ( Component ) prop.getValue();
 				Iterator compProps = component.getPropertyIterator();
 				internalInitSubclassPropertyAliasesMap( propname, compProps );
 			}
 			else {
 				String[] aliases = new String[prop.getColumnSpan()];
 				String[] cols = new String[prop.getColumnSpan()];
 				Iterator colIter = prop.getColumnIterator();
 				int l = 0;
 				while ( colIter.hasNext() ) {
 					Selectable thing = ( Selectable ) colIter.next();
 					aliases[l] = thing.getAlias( getFactory().getDialect(), prop.getValue().getTable() );
 					cols[l] = thing.getText( getFactory().getDialect() ); // TODO: skip formulas?
 					l++;
 				}
 
 				subclassPropertyAliases.put( propname, aliases );
 				subclassPropertyColumnNames.put( propname, cols );
 			}
 		}
 
 	}
 
 	public Object loadByUniqueKey(
 			String propertyName,
 			Object uniqueKey,
 			SessionImplementor session) throws HibernateException {
 		return getAppropriateUniqueKeyLoader( propertyName, session ).loadByUniqueKey( session, uniqueKey );
 	}
 
 	private EntityLoader getAppropriateUniqueKeyLoader(String propertyName, SessionImplementor session) {
 		final boolean useStaticLoader = !session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& !session.getLoadQueryInfluencers().hasEnabledFetchProfiles()
 				&& propertyName.indexOf('.')<0; //ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties
 
 		if ( useStaticLoader ) {
 			return ( EntityLoader ) uniqueKeyLoaders.get( propertyName );
 		}
 		else {
 			return createUniqueKeyLoader(
 					propertyMapping.toType( propertyName ),
 					propertyMapping.toColumns( propertyName ),
 					session.getLoadQueryInfluencers()
 			);
 		}
 	}
 
 	public int getPropertyIndex(String propertyName) {
 		return entityMetamodel.getPropertyIndex(propertyName);
 	}
 
 	protected void createUniqueKeyLoaders() throws MappingException {
 		Type[] propertyTypes = getPropertyTypes();
 		String[] propertyNames = getPropertyNames();
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( propertyUniqueness[i] ) {
 				//don't need filters for the static loaders
 				uniqueKeyLoaders.put(
 						propertyNames[i],
 						createUniqueKeyLoader(
 								propertyTypes[i],
 								getPropertyColumnNames( i ),
 								LoadQueryInfluencers.NONE
 						)
 				);
 				//TODO: create uk loaders for component properties
 			}
 		}
 	}
 
 	private EntityLoader createUniqueKeyLoader(
 			Type uniqueKeyType,
 			String[] columns,
 			LoadQueryInfluencers loadQueryInfluencers) {
 		if ( uniqueKeyType.isEntityType() ) {
 			String className = ( ( EntityType ) uniqueKeyType ).getAssociatedEntityName();
 			uniqueKeyType = getFactory().getEntityPersister( className ).getIdentifierType();
 		}
 		return new EntityLoader(
 				this,
 				columns,
 				uniqueKeyType,
 				1,
 				LockMode.NONE,
 				getFactory(),
 				loadQueryInfluencers
 		);
 	}
 
 	protected String getSQLWhereString(String alias) {
 		return StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );
 	}
 
 	protected boolean hasWhere() {
 		return sqlWhereString != null;
 	}
 
 	private void initOrdinaryPropertyPaths(Mapping mapping) throws MappingException {
 		for ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {
 			propertyMapping.initPropertyPaths( getSubclassPropertyNameClosure()[i],
 					getSubclassPropertyTypeClosure()[i],
 					getSubclassPropertyColumnNameClosure()[i],
 					getSubclassPropertyColumnReaderClosure()[i],
 					getSubclassPropertyColumnReaderTemplateClosure()[i],
 					getSubclassPropertyFormulaTemplateClosure()[i],
 					mapping );
 		}
 	}
 
 	private void initIdentifierPropertyPaths(Mapping mapping) throws MappingException {
 		String idProp = getIdentifierPropertyName();
 		if ( idProp != null ) {
 			propertyMapping.initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			propertyMapping.initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 		if ( ! entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			propertyMapping.initPropertyPaths( ENTITY_ID, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 	}
 
 	private void initDiscriminatorPropertyPath(Mapping mapping) throws MappingException {
 		propertyMapping.initPropertyPaths( ENTITY_CLASS,
 				getDiscriminatorType(),
 				new String[]{getDiscriminatorColumnName()},
 				new String[]{getDiscriminatorColumnReaders()},
 				new String[]{getDiscriminatorColumnReaderTemplate()},
 				new String[]{getDiscriminatorFormulaTemplate()},
 				getFactory() );
 	}
 
 	protected void initPropertyPaths(Mapping mapping) throws MappingException {
 		initOrdinaryPropertyPaths(mapping);
 		initOrdinaryPropertyPaths(mapping); //do two passes, for collection property-ref!
 		initIdentifierPropertyPaths(mapping);
 		if ( entityMetamodel.isPolymorphic() ) {
 			initDiscriminatorPropertyPath( mapping );
 		}
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockMode lockMode,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoader.createBatchingEntityLoader(
 				this,
 				batchSize,
 				lockMode,
 				getFactory(),
 				loadQueryInfluencers
 		);
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockOptions lockOptions,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoader.createBatchingEntityLoader(
 				this,
 				batchSize,
 			lockOptions,
 				getFactory(),
 				loadQueryInfluencers
 		);
 	}
 
 	protected UniqueEntityLoader createEntityLoader(LockMode lockMode) throws MappingException {
 		return createEntityLoader( lockMode, LoadQueryInfluencers.NONE );
 	}
 
 	protected boolean check(int rows, Serializable id, int tableNumber, Expectation expectation, PreparedStatement statement) throws HibernateException {
 		try {
 			expectation.verifyOutcome( rows, statement, -1 );
 		}
 		catch( StaleStateException e ) {
 			if ( !isNullableTable( tableNumber ) ) {
 				if ( getFactory().getStatistics().isStatisticsEnabled() ) {
 					getFactory().getStatisticsImplementor()
 							.optimisticFailure( getEntityName() );
 				}
 				throw new StaleObjectStateException( getEntityName(), id );
 			}
 			return false;
 		}
 		catch( TooManyRowsAffectedException e ) {
 			throw new HibernateException(
 					"Duplicate identifier in table for: " +
 					MessageHelper.infoString( this, id, getFactory() )
 			);
 		}
 		catch ( Throwable t ) {
 			return false;
 		}
 		return true;
 	}
 
 	protected String generateUpdateString(boolean[] includeProperty, int j, boolean useRowId) {
 		return generateUpdateString( includeProperty, j, null, useRowId );
 	}
 
 	/**
 	 * Generate the SQL that updates a row by id (and version)
 	 */
 	protected String generateUpdateString(final boolean[] includeProperty,
 										  final int j,
 										  final Object[] oldFields,
 										  final boolean useRowId) {
 
 		Update update = new Update( getFactory().getDialect() ).setTableName( getTableName( j ) );
 
 		// select the correct row by either pk or rowid
 		if ( useRowId ) {
 			update.addPrimaryKeyColumns( new String[]{rowIdName} ); //TODO: eventually, rowIdName[j]
 		}
 		else {
 			update.addPrimaryKeyColumns( getKeyColumns( j ) );
 		}
 
 		boolean hasColumns = false;
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this is a property of the table, which we are updating
 				update.addColumns( getPropertyColumnNames(i), propertyColumnUpdateable[i], propertyColumnWriters[i] );
 				hasColumns = hasColumns || getPropertyColumnSpan( i ) > 0;
 			}
 		}
 
 		if ( j == 0 && isVersioned() && entityMetamodel.getOptimisticLockMode() == Versioning.OPTIMISTIC_LOCK_VERSION ) {
 			// this is the root (versioned) table, and we are using version-based
 			// optimistic locking;  if we are not updating the version, also don't
 			// check it (unless this is a "generated" version column)!
 			if ( checkVersion( includeProperty ) ) {
 				update.setVersionColumnName( getVersionColumnName() );
 				hasColumns = true;
 			}
 		}
 		else if ( entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION && oldFields != null ) {
 			// we are using "all" or "dirty" property-based optimistic locking
 
 			boolean[] includeInWhere = entityMetamodel.getOptimisticLockMode() == Versioning.OPTIMISTIC_LOCK_ALL ?
 					getPropertyUpdateability() : //optimistic-lock="all", include all updatable properties
 					includeProperty; //optimistic-lock="dirty", include all properties we are updating this time
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				boolean include = includeInWhere[i] &&
 						isPropertyOfTable( i, j ) &&
 						versionability[i];
 				if ( include ) {
 					// this property belongs to the table, and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					String[] propertyColumnWriters = getPropertyColumnWriters( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( oldFields[i], getFactory() );
 					for ( int k=0; k<propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							update.addWhereColumn( propertyColumnNames[k], "=" + propertyColumnWriters[k] );
 						}
 						else {
 							update.addWhereColumn( propertyColumnNames[k], " is null" );
 						}
 					}
 				}
 			}
 
 		}
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "update " + getEntityName() );
 		}
 
 		return hasColumns ? update.toStatementString() : null;
 	}
 
 	private boolean checkVersion(final boolean[] includeProperty) {
         return includeProperty[ getVersionProperty() ] ||
 				entityMetamodel.getPropertyUpdateGenerationInclusions()[ getVersionProperty() ] != ValueInclusion.NONE;
 	}
 
 	protected String generateInsertString(boolean[] includeProperty, int j) {
 		return generateInsertString( false, includeProperty, j );
 	}
 
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty) {
 		return generateInsertString( identityInsert, includeProperty, 0 );
 	}
 
 	/**
 	 * Generate the SQL that inserts a row
 	 */
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty, int j) {
 
 		// todo : remove the identityInsert param and variations;
 		//   identity-insert strings are now generated from generateIdentityInsertString()
 
 		Insert insert = new Insert( getFactory().getDialect() )
 				.setTableName( getTableName( j ) );
 
 		// add normal properties
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// add the discriminator
 		if ( j == 0 ) {
 			addDiscriminatorToInsert( insert );
 		}
 
 		// add the primary key
 		if ( j == 0 && identityInsert ) {
 			insert.addIdentityColumn( getKeyColumns( 0 )[0] );
 		}
 		else {
 			insert.addColumns( getKeyColumns( j ) );
 		}
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 
 		String result = insert.toStatementString();
 
 		// append the SQL to return the generated identifier
 		if ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert
 			result = getFactory().getDialect().appendIdentitySelectToInsert( result );
 		}
 
 		return result;
 	}
 
 	/**
 	 * Used to generate an insery statement against the root table in the
 	 * case of identifier generation strategies where the insert statement
 	 * executions actually generates the identifier value.
 	 *
 	 * @param includeProperty indices of the properties to include in the
 	 * insert statement.
 	 * @return The insert SQL statement string
 	 */
 	protected String generateIdentityInsertString(boolean[] includeProperty) {
 		Insert insert = identityDelegate.prepareIdentifierGeneratingInsert();
 		insert.setTableName( getTableName( 0 ) );
 
 		// add normal properties
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, 0 ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// add the discriminator
 		addDiscriminatorToInsert( insert );
 
 		// delegate already handles PK columns
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 
 		return insert.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL that deletes a row by id (and version)
 	 */
 	protected String generateDeleteString(int j) {
 		Delete delete = new Delete()
 				.setTableName( getTableName( j ) )
 				.addPrimaryKeyColumns( getKeyColumns( j ) );
 		if ( j == 0 ) {
 			delete.setVersionColumnName( getVersionColumnName() );
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			delete.setComment( "delete " + getEntityName() );
 		}
 		return delete.toStatementString();
 	}
 
 	protected int dehydrate(
 			Serializable id,
 			Object[] fields,
 			boolean[] includeProperty,
 			boolean[][] includeColumns,
 			int j,
 			PreparedStatement st,
 			SessionImplementor session) throws HibernateException, SQLException {
 		return dehydrate( id, fields, null, includeProperty, includeColumns, j, st, session, 1 );
 	}
 
 	/**
 	 * Marshall the fields of a persistent instance to a prepared statement
 	 */
 	protected int dehydrate(
 			final Serializable id,
 	        final Object[] fields,
 	        final Object rowId,
 	        final boolean[] includeProperty,
 	        final boolean[][] includeColumns,
 	        final int j,
 	        final PreparedStatement ps,
 	        final SessionImplementor session,
 	        int index) throws SQLException, HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Dehydrating entity: " + MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
 				//index += getPropertyColumnSpan( i );
 				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
 			}
 		}
 
 		if ( rowId != null ) {
 			ps.setObject( index, rowId );
 			index += 1;
 		}
 		else if ( id != null ) {
 			getIdentifierType().nullSafeSet( ps, id, index, session );
 			index += getIdentifierColumnSpan();
 		}
 
 		return index;
 
 	}
 
 	/**
 	 * Unmarshall the fields of a persistent instance from a result set,
 	 * without resolving associations or collections. Question: should
 	 * this really be here, or should it be sent back to Loader?
 	 */
 	public Object[] hydrate(
 			final ResultSet rs,
 	        final Serializable id,
 	        final Object object,
 	        final Loadable rootLoadable,
 	        final String[][] suffixedPropertyColumns,
 	        final boolean allProperties,
 	        final SessionImplementor session) throws SQLException, HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Hydrating entity: " + MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		final AbstractEntityPersister rootPersister = (AbstractEntityPersister) rootLoadable;
 
 		final boolean hasDeferred = rootPersister.hasSequentialSelect();
 		PreparedStatement sequentialSelect = null;
 		ResultSet sequentialResultSet = null;
 		boolean sequentialSelectEmpty = false;
 		try {
 
 			if ( hasDeferred ) {
 				final String sql = rootPersister.getSequentialSelect( getEntityName() );
 				if ( sql != null ) {
 					//TODO: I am not so sure about the exception handling in this bit!
-					sequentialSelect = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+					sequentialSelect = session.getTransactionCoordinator()
+							.getJdbcCoordinator()
+							.getStatementPreparer()
+							.prepareStatement( sql );
 					rootPersister.getIdentifierType().nullSafeSet( sequentialSelect, id, 1, session );
 					sequentialResultSet = sequentialSelect.executeQuery();
 					if ( !sequentialResultSet.next() ) {
 						// TODO: Deal with the "optional" attribute in the <join> mapping;
 						// this code assumes that optional defaults to "true" because it
 						// doesn't actually seem to work in the fetch="join" code
 						//
 						// Note that actual proper handling of optional-ality here is actually
 						// more involved than this patch assumes.  Remember that we might have
 						// multiple <join/> mappings associated with a single entity.  Really
 						// a couple of things need to happen to properly handle optional here:
 						//  1) First and foremost, when handling multiple <join/>s, we really
 						//      should be using the entity root table as the driving table;
 						//      another option here would be to choose some non-optional joined
 						//      table to use as the driving table.  In all likelihood, just using
 						//      the root table is much simplier
 						//  2) Need to add the FK columns corresponding to each joined table
 						//      to the generated select list; these would then be used when
 						//      iterating the result set to determine whether all non-optional
 						//      data is present
 						// My initial thoughts on the best way to deal with this would be
 						// to introduce a new SequentialSelect abstraction that actually gets
 						// generated in the persisters (ok, SingleTable...) and utilized here.
 						// It would encapsulated all this required optional-ality checking...
 						sequentialSelectEmpty = true;
 					}
 				}
 			}
 
 			final String[] propNames = getPropertyNames();
 			final Type[] types = getPropertyTypes();
 			final Object[] values = new Object[types.length];
 			final boolean[] laziness = getPropertyLaziness();
 			final String[] propSubclassNames = getSubclassPropertySubclassNameClosure();
 
 			for ( int i = 0; i < types.length; i++ ) {
 				if ( !propertySelectable[i] ) {
 					values[i] = BackrefPropertyAccessor.UNKNOWN;
 				}
 				else if ( allProperties || !laziness[i] ) {
 					//decide which ResultSet to get the property value from:
 					final boolean propertyIsDeferred = hasDeferred &&
 							rootPersister.isSubclassPropertyDeferred( propNames[i], propSubclassNames[i] );
 					if ( propertyIsDeferred && sequentialSelectEmpty ) {
 						values[i] = null;
 					}
 					else {
 						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
 						final String[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];
 						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );
 					}
 				}
 				else {
 					values[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 				}
 			}
 
 			if ( sequentialResultSet != null ) {
 				sequentialResultSet.close();
 			}
 
 			return values;
 
 		}
 		finally {
 			if ( sequentialSelect != null ) {
 				sequentialSelect.close();
 			}
 		}
 	}
 
 	protected boolean useInsertSelectIdentity() {
 		return !useGetGeneratedKeys() && getFactory().getDialect().supportsInsertSelectIdentity();
 	}
 
 	protected boolean useGetGeneratedKeys() {
 		return getFactory().getSettings().isGetGeneratedKeysEnabled();
 	}
 
 	protected String getSequentialSelect(String entityName) {
 		throw new UnsupportedOperationException("no sequential selects");
 	}
 
 	/**
 	 * Perform an SQL INSERT, and then retrieve a generated identifier.
 	 * <p/>
 	 * This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY,
 	 * select, etc).
 	 */
 	protected Serializable insert(
 			final Object[] fields,
 	        final boolean[] notNull,
 	        String sql,
 	        final Object object,
 	        final SessionImplementor session) throws HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Inserting entity: " + getEntityName() + " (native id)" );
 			if ( isVersioned() ) {
 				log.trace( "Version: " + Versioning.getVersion( fields, this ) );
 			}
 		}
 
 		Binder binder = new Binder() {
 			public void bindValues(PreparedStatement ps) throws SQLException {
 				dehydrate( null, fields, notNull, propertyColumnInsertable, 0, ps, session );
 			}
 			public Object getEntity() {
 				return object;
 			}
 		};
 		return identityDelegate.performInsert( sql, session, binder );
 	}
 
 	public String getIdentitySelectString() {
 		//TODO: cache this in an instvar
 		return getFactory().getDialect().getIdentitySelectString(
 				getTableName(0),
 				getKeyColumns(0)[0],
 				getIdentifierType().sqlTypes( getFactory() )[0]
 		);
 	}
 
 	public String getSelectByUniqueKeyString(String propertyName) {
 		return new SimpleSelect( getFactory().getDialect() )
 			.setTableName( getTableName(0) )
 			.addColumns( getKeyColumns(0) )
 			.addCondition( getPropertyColumnNames(propertyName), "=?" )
 			.toStatementString();
 	}
 
+	private BasicBatchKey inserBatchKey;
+
 	/**
 	 * Perform an SQL INSERT.
 	 * <p/>
 	 * This for is used for all non-root tables as well as the root table
 	 * in cases where the identifier value is known before the insert occurs.
 	 */
 	protected void insert(
 			final Serializable id,
 	        final Object[] fields,
 	        final boolean[] notNull,
 	        final int j,
 	        final String sql,
 	        final Object object,
 	        final SessionImplementor session) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		//note: it is conceptually possible that a UserType could map null to
 		//	  a non-null value, so the following is arguable:
 		if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 			return;
 		}
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Inserting entity: " + MessageHelper.infoString( this, id, getFactory() ) );
 			if ( j == 0 && isVersioned() ) {
 				log.trace( "Version: " + Versioning.getVersion( fields, this ) );
 			}
 		}
 
-		Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
-		boolean callable = isInsertCallable( j );
+		// TODO : shouldn't inserts be Expectations.NONE?
+		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
 		// we can't batch joined inserts, *especially* not if it is an identity insert;
 		// nor can we batch statements where the expectation is based on an output param
 		final boolean useBatch = j == 0 && expectation.canBeBatched();
-		try {
+		if ( useBatch && inserBatchKey == null ) {
+			inserBatchKey = new BasicBatchKey(
+					getEntityName() + "#INSERT",
+					expectation
+			);
+		}
+		final boolean callable = isInsertCallable( j );
 
+		try {
 			// Render the SQL query
 			final PreparedStatement insert;
 			if ( useBatch ) {
-				insert = session.getJDBCContext().getConnectionManager().prepareBatchStatement( this, sql, callable );
+				insert = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getBatch( inserBatchKey )
+						.getBatchStatement( sql, callable );
 			}
 			else {
-				insert = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+				insert = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getStatementPreparer()
+						.prepareStatement( sql, callable );
 			}
 
 			try {
 				int index = 1;
 				index += expectation.prepare( insert );
 
 				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
 				// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
 
 				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index );
 
 				if ( useBatch ) {
-					// TODO : shouldnt inserts be Expectations.NONE?
-					session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
 				}
 				else {
 					expectation.verifyOutcome( insert.executeUpdate(), insert, -1 );
 				}
 
 			}
-			catch ( SQLException sqle ) {
+			catch ( SQLException e ) {
 				if ( useBatch ) {
-					session.getJDBCContext().getConnectionManager().abortBatch();
+					session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 				}
-				throw sqle;
+				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					insert.close();
 				}
 			}
 		}
-		catch ( SQLException sqle ) {
+		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
+					e,
 					"could not insert: " + MessageHelper.infoString( this ),
 					sql
-				);
+			);
 		}
 
 	}
 
 	/**
 	 * Perform an SQL UPDATE or SQL INSERT
 	 */
 	protected void updateOrInsert(
 			final Serializable id,
 	        final Object[] fields,
 	        final Object[] oldFields,
 	        final Object rowId,
 	        final boolean[] includeProperty,
 	        final int j,
 	        final Object oldVersion,
 	        final Object object,
 	        final String sql,
 	        final SessionImplementor session) throws HibernateException {
 
 		if ( !isInverseTable( j ) ) {
 
 			final boolean isRowToUpdate;
 			if ( isNullableTable( j ) && oldFields != null && isAllNull( oldFields, j ) ) {
 				//don't bother trying to update, we know there is no row there yet
 				isRowToUpdate = false;
 			}
 			else if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 				//if all fields are null, we might need to delete existing row
 				isRowToUpdate = true;
 				delete( id, oldVersion, j, object, getSQLDeleteStrings()[j], session, null );
 			}
 			else {
 				//there is probably a row there, so try to update
 				//if no rows were updated, we will find out
 				isRowToUpdate = update( id, fields, oldFields, rowId, includeProperty, j, oldVersion, object, sql, session );
 			}
 
 			if ( !isRowToUpdate && !isAllNull( fields, j ) ) {
 				// assume that the row was not there since it previously had only null
 				// values, so do an INSERT instead
 				//TODO: does not respect dynamic-insert
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 
 		}
 
 	}
 
+	private BasicBatchKey updateBatchKey;
+
 	protected boolean update(
 			final Serializable id,
 	        final Object[] fields,
 	        final Object[] oldFields,
 	        final Object rowId,
 	        final boolean[] includeProperty,
 	        final int j,
 	        final Object oldVersion,
 	        final Object object,
 	        final String sql,
 	        final SessionImplementor session) throws HibernateException {
 
-		final boolean useVersion = j == 0 && isVersioned();
 		final Expectation expectation = Expectations.appropriateExpectation( updateResultCheckStyles[j] );
-		final boolean callable = isUpdateCallable( j );
 		final boolean useBatch = j == 0 && expectation.canBeBatched() && isBatchable(); //note: updates to joined tables can't be batched...
+		if ( useBatch && updateBatchKey == null ) {
+			updateBatchKey = new BasicBatchKey(
+					getEntityName() + "#UPDATE",
+					expectation
+			);
+		}
+		final boolean callable = isUpdateCallable( j );
+		final boolean useVersion = j == 0 && isVersioned();
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Updating entity: " + MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion ) {
 				log.trace( "Existing version: " + oldVersion + " -> New version: " + fields[getVersionProperty()] );
 			}
 		}
 
 		try {
-
 			int index = 1; // starting index
 			final PreparedStatement update;
 			if ( useBatch ) {
-				update = session.getJDBCContext().getConnectionManager().prepareBatchStatement( this, sql, callable );
+				update = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getBatch( updateBatchKey )
+						.getBatchStatement( sql, callable );
 			}
 			else {
-				update = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+				update = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getStatementPreparer()
+						.prepareStatement( sql, callable );
 			}
 
 			try {
-
 				index+= expectation.prepare( update );
 
 				//Now write the values of fields onto the prepared statement
 				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index );
 
 				// Write any appropriate versioning conditional parameters
 				if ( useVersion && Versioning.OPTIMISTIC_LOCK_VERSION == entityMetamodel.getOptimisticLockMode() ) {
 					if ( checkVersion( includeProperty ) ) {
 						getVersionType().nullSafeSet( update, oldVersion, index, session );
 					}
 				}
 				else if ( entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION && oldFields != null ) {
 					boolean[] versionability = getPropertyVersionability(); //TODO: is this really necessary????
 					boolean[] includeOldField = entityMetamodel.getOptimisticLockMode() == Versioning.OPTIMISTIC_LOCK_ALL ?
 							getPropertyUpdateability() : includeProperty;
 					Type[] types = getPropertyTypes();
 					for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 						boolean include = includeOldField[i] &&
 								isPropertyOfTable( i, j ) &&
 								versionability[i]; //TODO: is this really necessary????
 						if ( include ) {
 							boolean[] settable = types[i].toColumnNullness( oldFields[i], getFactory() );
 							types[i].nullSafeSet(
 									update,
 									oldFields[i],
 									index,
 									settable,
 									session
 								);
 							index += ArrayHelper.countTrue(settable);
 						}
 					}
 				}
 
 				if ( useBatch ) {
-					session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( updateBatchKey ).addToBatch();
 					return true;
 				}
 				else {
 					return check( update.executeUpdate(), id, j, expectation, update );
 				}
 
 			}
-			catch ( SQLException sqle ) {
+			catch ( SQLException e ) {
 				if ( useBatch ) {
-					session.getJDBCContext().getConnectionManager().abortBatch();
+					session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 				}
-				throw sqle;
+				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					update.close();
 				}
 			}
 
 		}
-		catch ( SQLException sqle ) {
+		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
+					e,
 					"could not update: " + MessageHelper.infoString( this, id, getFactory() ),
 					sql
 				);
 		}
 	}
 
+	private BasicBatchKey deleteBatchKey;
+
 	/**
 	 * Perform an SQL DELETE
 	 */
 	protected void delete(
 			final Serializable id,
 			final Object version,
 			final int j,
 			final Object object,
 			final String sql,
 			final SessionImplementor session,
 			final Object[] loadedState) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		final boolean useVersion = j == 0 && isVersioned();
 		final boolean callable = isDeleteCallable( j );
 		final Expectation expectation = Expectations.appropriateExpectation( deleteResultCheckStyles[j] );
 		final boolean useBatch = j == 0 && isBatchable() && expectation.canBeBatched();
+		if ( useBatch && deleteBatchKey == null ) {
+			deleteBatchKey = new BasicBatchKey(
+					getEntityName() + "#DELETE",
+					expectation
+			);
+		}
 
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Deleting entity: " + MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion ) {
 				log.trace( "Version: " + version );
 			}
 		}
 
 		if ( isTableCascadeDeleteEnabled( j ) ) {
 			if ( log.isTraceEnabled() ) {
 				log.trace( "delete handled by foreign key constraint: " + getTableName( j ) );
 			}
 			return; //EARLY EXIT!
 		}
 
 		try {
-
 			//Render the SQL query
 			PreparedStatement delete;
 			int index = 1;
 			if ( useBatch ) {
-				delete = session.getJDBCContext().getConnectionManager().prepareBatchStatement( this, sql, callable );
+				delete = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getBatch( deleteBatchKey )
+						.getBatchStatement( sql, callable );
 			}
 			else {
-				delete = session.getJDBCContext().getConnectionManager().prepareStatement( sql, callable );
+				delete = session.getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getStatementPreparer()
+						.prepareStatement( sql, callable );
 			}
 
 			try {
 
 				index += expectation.prepare( delete );
 
 				// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
 				// the state at the time the delete was issued
 				getIdentifierType().nullSafeSet( delete, id, index, session );
 				index += getIdentifierColumnSpan();
 
 				// We should use the _current_ object state (ie. after any updates that occurred during flush)
 
 				if ( useVersion ) {
 					getVersionType().nullSafeSet( delete, version, index, session );
 				}
 				else if ( entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION && loadedState != null ) {
 					boolean[] versionability = getPropertyVersionability();
 					Type[] types = getPropertyTypes();
 					for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 						if ( isPropertyOfTable( i, j ) && versionability[i] ) {
 							// this property belongs to the table and it is not specifically
 							// excluded from optimistic locking by optimistic-lock="false"
 							boolean[] settable = types[i].toColumnNullness( loadedState[i], getFactory() );
 							types[i].nullSafeSet( delete, loadedState[i], index, settable, session );
 							index += ArrayHelper.countTrue( settable );
 						}
 					}
 				}
 
 				if ( useBatch ) {
-					session.getJDBCContext().getConnectionManager().addToBatch( this, sql, expectation );
+					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( deleteBatchKey ).addToBatch();
 				}
 				else {
 					check( delete.executeUpdate(), id, j, expectation, delete );
 				}
 
 			}
 			catch ( SQLException sqle ) {
 				if ( useBatch ) {
-					session.getJDBCContext().getConnectionManager().abortBatch();
+					session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 				}
 				throw sqle;
 			}
 			finally {
 				if ( !useBatch ) {
 					delete.close();
 				}
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not delete: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					sql
 				);
 
 		}
 
 	}
 
 	private String[] getUpdateStrings(boolean byRowId, boolean lazy) {
 		if ( byRowId ) {
 			return lazy ? getSQLLazyUpdateByRowIdStrings() : getSQLUpdateByRowIdStrings();
 		}
 		else {
 			return lazy ? getSQLLazyUpdateStrings() : getSQLUpdateStrings();
 		}
 	}
 
 	/**
 	 * Update an object
 	 */
 	public void update(
 			final Serializable id,
 	        final Object[] fields,
 	        final int[] dirtyFields,
 	        final boolean hasDirtyCollection,
 	        final Object[] oldFields,
 	        final Object oldVersion,
 	        final Object object,
 	        final Object rowId,
 	        final SessionImplementor session) throws HibernateException {
 
 		//note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update
 		//	  oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)
 
 		final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );
 		final int span = getTableSpan();
 
 		final boolean[] propsToUpdate;
 		final String[] updateStrings;
 		EntityEntry entry = session.getPersistenceContext().getEntry( object );
 
 		// Ensure that an immutable or non-modifiable entity is not being updated unless it is
 		// in the process of being deleted.
 		if ( entry == null && ! isMutable() ) {
 			throw new IllegalStateException( "Updating immutable entity that is not in session yet!" );
 		}
 		if ( ( entityMetamodel.isDynamicUpdate() && dirtyFields != null ) ) {
 			// We need to generate the UPDATE SQL when dynamic-update="true"
 			propsToUpdate = getPropertiesToUpdate( dirtyFields, hasDirtyCollection );
 			// don't need to check laziness (dirty checking algorithm handles that)
 			updateStrings = new String[span];
 			for ( int j = 0; j < span; j++ ) {
 				updateStrings[j] = tableUpdateNeeded[j] ?
 						generateUpdateString( propsToUpdate, j, oldFields, j == 0 && rowId != null ) :
 						null;
 			}
 		}
 		else if ( ! isModifiableEntity( entry ) ) {
 			// We need to generate UPDATE SQL when a non-modifiable entity (e.g., read-only or immutable)
 			// needs:
 			// - to have references to transient entities set to null before being deleted
 			// - to have version incremented do to a "dirty" association
 			// If dirtyFields == null, then that means that there are no dirty properties to
 			// to be updated; an empty array for the dirty fields needs to be passed to
 			// getPropertiesToUpdate() instead of null.
 			propsToUpdate = getPropertiesToUpdate(
 					( dirtyFields == null ? ArrayHelper.EMPTY_INT_ARRAY : dirtyFields ),
 					hasDirtyCollection
 			);
 			// don't need to check laziness (dirty checking algorithm handles that)
 			updateStrings = new String[span];
 			for ( int j = 0; j < span; j++ ) {
 				updateStrings[j] = tableUpdateNeeded[j] ?
 						generateUpdateString( propsToUpdate, j, oldFields, j == 0 && rowId != null ) :
 						null;
 			}
 		}
 		else {
 			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
 			updateStrings = getUpdateStrings(
 					rowId != null,
 					hasUninitializedLazyProperties( object, session.getEntityMode() )
 				);
 			propsToUpdate = getPropertyUpdateability( object, session.getEntityMode() );
 		}
 
 		for ( int j = 0; j < span; j++ ) {
 			// Now update only the tables with dirty properties (and the table with the version number)
 			if ( tableUpdateNeeded[j] ) {
 				updateOrInsert(
 						id,
 						fields,
 						oldFields,
 						j == 0 ? rowId : null,
 						propsToUpdate,
 						j,
 						oldVersion,
 						object,
 						updateStrings[j],
 						session
 					);
 			}
 		}
 	}
 
 	public Serializable insert(Object[] fields, Object object, SessionImplementor session)
 			throws HibernateException {
 
 		final int span = getTableSpan();
 		final Serializable id;
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			id = insert( fields, notNull, generateInsertString( true, notNull ), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			id = insert( fields, getPropertyInsertability(), getSQLIdentityInsertString(), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 		return id;
 	}
 
 	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session)
 			throws HibernateException {
 
 		final int span = getTableSpan();
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 	}
 
 	/**
 	 * Delete an object
 	 */
 	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
 			throws HibernateException {
 		final int span = getTableSpan();
 		boolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION;
 		Object[] loadedState = null;
 		if ( isImpliedOptimisticLocking ) {
 			// need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense);
 			// first we need to locate the "loaded" state
 			//
 			// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
 			EntityKey key = new EntityKey( id, this, session.getEntityMode() );
 			Object entity = session.getPersistenceContext().getEntity( key );
 			if ( entity != null ) {
 				EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 				loadedState = entry.getLoadedState();
 			}
 		}
 
 		final String[] deleteStrings;
 		if ( isImpliedOptimisticLocking && loadedState != null ) {
 			// we need to utilize dynamic delete statements
 			deleteStrings = generateSQLDeletStrings( loadedState );
 		}
 		else {
 			// otherwise, utilize the static delete statements
 			deleteStrings = getSQLDeleteStrings();
 		}
 
 		for ( int j = span - 1; j >= 0; j-- ) {
 			delete( id, version, j, object, deleteStrings[j], session, loadedState );
 		}
 
 	}
 
 	private String[] generateSQLDeletStrings(Object[] loadedState) {
 		int span = getTableSpan();
 		String[] deleteStrings = new String[span];
 		for ( int j = span - 1; j >= 0; j-- ) {
 			Delete delete = new Delete()
 					.setTableName( getTableName( j ) )
 					.addPrimaryKeyColumns( getKeyColumns( j ) );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				delete.setComment( "delete " + getEntityName() + " [" + j + "]" );
 			}
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				if ( isPropertyOfTable( i, j ) && versionability[i] ) {
 					// this property belongs to the table and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( loadedState[i], getFactory() );
 					for ( int k = 0; k < propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							delete.addWhereFragment( propertyColumnNames[k] + " = ?" );
 						}
 						else {
 							delete.addWhereFragment( propertyColumnNames[k] + " is null" );
 						}
 					}
 				}
 			}
 			deleteStrings[j] = delete.toStatementString();
 		}
 		return deleteStrings;
 	}
 
 	protected void logStaticSQL() {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Static SQL for entity: " + getEntityName() );
 			if ( sqlLazySelectString != null ) {
 				log.debug( " Lazy select: " + sqlLazySelectString );
 			}
 			if ( sqlVersionSelectString != null ) {
 				log.debug( " Version select: " + sqlVersionSelectString );
 			}
 			if ( sqlSnapshotSelectString != null ) {
 				log.debug( " Snapshot select: " + sqlSnapshotSelectString );
 			}
 			for ( int j = 0; j < getTableSpan(); j++ ) {
 				log.debug( " Insert " + j + ": " + getSQLInsertStrings()[j] );
 				log.debug( " Update " + j + ": " + getSQLUpdateStrings()[j] );
 				log.debug( " Delete " + j + ": " + getSQLDeleteStrings()[j] );
 
 			}
 			if ( sqlIdentityInsertString != null ) {
 				log.debug( " Identity insert: " + sqlIdentityInsertString );
 			}
 			if ( sqlUpdateByRowIdString != null ) {
 				log.debug( " Update by row id (all fields): " + sqlUpdateByRowIdString );
 			}
 			if ( sqlLazyUpdateByRowIdString != null ) {
 				log.debug( " Update by row id (non-lazy fields): " + sqlLazyUpdateByRowIdString );
 			}
 			if ( sqlInsertGeneratedValuesSelectString != null ) {
 				log.debug( "Insert-generated property select: " + sqlInsertGeneratedValuesSelectString );
 			}
 			if ( sqlUpdateGeneratedValuesSelectString != null ) {
 				log.debug( "Update-generated property select: " + sqlUpdateGeneratedValuesSelectString );
 			}
 		}
 	}
 
 	public String filterFragment(String alias, Map enabledFilters) throws MappingException {
 		final StringBuffer sessionFilterFragment = new StringBuffer();
 		filterHelper.render( sessionFilterFragment, generateFilterConditionAlias( alias ), enabledFilters );
 
 		return sessionFilterFragment.append( filterFragment( alias ) ).toString();
 	}
 
 	public String generateFilterConditionAlias(String rootAlias) {
 		return rootAlias;
 	}
 
 	public String oneToManyFilterFragment(String alias) throws MappingException {
 		return "";
 	}
 
 	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return getSubclassTableSpan() == 1 ?
 				"" : //just a performance opt!
 				createJoin( alias, innerJoin, includeSubclasses ).toFromFragmentString();
 	}
 
 	public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return getSubclassTableSpan() == 1 ?
 				"" : //just a performance opt!
 				createJoin( alias, innerJoin, includeSubclasses ).toWhereFragmentString();
 	}
 
 	protected boolean isSubclassTableLazy(int j) {
 		return false;
 	}
 
 	protected JoinFragment createJoin(String name, boolean innerJoin, boolean includeSubclasses) {
 		final String[] idCols = StringHelper.qualify( name, getIdentifierColumnNames() ); //all joins join to the pk of the driving table
 		final JoinFragment join = getFactory().getDialect().createOuterJoinFragment();
 		final int tableSpan = getSubclassTableSpan();
 		for ( int j = 1; j < tableSpan; j++ ) { //notice that we skip the first table; it is the driving table!
 			final boolean joinIsIncluded = isClassOrSuperclassTable( j ) ||
 					( includeSubclasses && !isSubclassTableSequentialSelect( j ) && !isSubclassTableLazy( j ) );
 			if ( joinIsIncluded ) {
 				join.addJoin( getSubclassTableName( j ),
 						generateTableAlias( name, j ),
 						idCols,
 						getSubclassTableKeyColumns( j ),
 						innerJoin && isClassOrSuperclassTable( j ) && !isInverseTable( j ) && !isNullableTable( j ) ?
 						JoinFragment.INNER_JOIN : //we can inner join to superclass tables (the row MUST be there)
 						JoinFragment.LEFT_OUTER_JOIN //we can never inner join to subclass tables
 					);
 			}
 		}
 		return join;
 	}
 
 	protected JoinFragment createJoin(int[] tableNumbers, String drivingAlias) {
 		final String[] keyCols = StringHelper.qualify( drivingAlias, getSubclassTableKeyColumns( tableNumbers[0] ) );
 		final JoinFragment jf = getFactory().getDialect().createOuterJoinFragment();
 		for ( int i = 1; i < tableNumbers.length; i++ ) { //skip the driving table
 			final int j = tableNumbers[i];
 			jf.addJoin( getSubclassTableName( j ),
 					generateTableAlias( getRootAlias(), j ),
 					keyCols,
 					getSubclassTableKeyColumns( j ),
 					isInverseSubclassTable( j ) || isNullableSubclassTable( j ) ?
 					JoinFragment.LEFT_OUTER_JOIN :
 					JoinFragment.INNER_JOIN );
 		}
 		return jf;
 	}
 
 	protected SelectFragment createSelect(final int[] subclassColumnNumbers,
 										  final int[] subclassFormulaNumbers) {
 
 		SelectFragment selectFragment = new SelectFragment();
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < subclassColumnNumbers.length; i++ ) {
 			int columnNumber = subclassColumnNumbers[i];
 			if ( subclassColumnSelectableClosure[columnNumber] ) {
 				final String subalias = generateTableAlias( getRootAlias(), columnTableNumbers[columnNumber] );
 				selectFragment.addColumnTemplate( subalias, columnReaderTemplates[columnNumber], columnAliases[columnNumber] );
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < subclassFormulaNumbers.length; i++ ) {
 			int formulaNumber = subclassFormulaNumbers[i];
 			final String subalias = generateTableAlias( getRootAlias(), formulaTableNumbers[formulaNumber] );
 			selectFragment.addFormula( subalias, formulaTemplates[formulaNumber], formulaAliases[formulaNumber] );
 		}
 
 		return selectFragment;
 	}
 
 	protected String createFrom(int tableNumber, String alias) {
 		return getSubclassTableName( tableNumber ) + ' ' + alias;
 	}
 
 	protected String createWhereByKey(int tableNumber, String alias) {
 		//TODO: move to .sql package, and refactor with similar things!
 		return StringHelper.join( "=? and ",
 				StringHelper.qualify( alias, getSubclassTableKeyColumns( tableNumber ) ) ) + "=?";
 	}
 
 	protected String renderSelect(
 			final int[] tableNumbers,
 	        final int[] columnNumbers,
 	        final int[] formulaNumbers) {
 
 		Arrays.sort( tableNumbers ); //get 'em in the right order (not that it really matters)
 
 		//render the where and from parts
 		int drivingTable = tableNumbers[0];
 		final String drivingAlias = generateTableAlias( getRootAlias(), drivingTable ); //we *could* regerate this inside each called method!
 		final String where = createWhereByKey( drivingTable, drivingAlias );
 		final String from = createFrom( drivingTable, drivingAlias );
 
 		//now render the joins
 		JoinFragment jf = createJoin( tableNumbers, drivingAlias );
 
 		//now render the select clause
 		SelectFragment selectFragment = createSelect( columnNumbers, formulaNumbers );
 
 		//now tie it all together
 		Select select = new Select( getFactory().getDialect() );
 		select.setSelectClause( selectFragment.toFragmentString().substring( 2 ) );
 		select.setFromClause( from );
 		select.setWhereClause( where );
 		select.setOuterJoins( jf.toFromFragmentString(), jf.toWhereFragmentString() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "sequential select " + getEntityName() );
 		}
 		return select.toStatementString();
 	}
 
 	private String getRootAlias() {
 		return StringHelper.generateAlias( getEntityName() );
 	}
 
 	protected void postConstruct(Mapping mapping) throws MappingException {
 		initPropertyPaths(mapping);
 
 		//insert/update/delete SQL
 		final int joinSpan = getTableSpan();
 		sqlDeleteStrings = new String[joinSpan];
 		sqlInsertStrings = new String[joinSpan];
 		sqlUpdateStrings = new String[joinSpan];
 		sqlLazyUpdateStrings = new String[joinSpan];
 
 		sqlUpdateByRowIdString = rowIdName == null ?
 				null :
 				generateUpdateString( getPropertyUpdateability(), 0, true );
 		sqlLazyUpdateByRowIdString = rowIdName == null ?
 				null :
 				generateUpdateString( getNonLazyPropertyUpdateability(), 0, true );
 
 		for ( int j = 0; j < joinSpan; j++ ) {
 			sqlInsertStrings[j] = customSQLInsert[j] == null ?
 					generateInsertString( getPropertyInsertability(), j ) :
 					customSQLInsert[j];
 			sqlUpdateStrings[j] = customSQLUpdate[j] == null ?
 					generateUpdateString( getPropertyUpdateability(), j, false ) :
 					customSQLUpdate[j];
 			sqlLazyUpdateStrings[j] = customSQLUpdate[j] == null ?
 					generateUpdateString( getNonLazyPropertyUpdateability(), j, false ) :
 					customSQLUpdate[j];
 			sqlDeleteStrings[j] = customSQLDelete[j] == null ?
 					generateDeleteString( j ) :
 					customSQLDelete[j];
 		}
 
 		tableHasColumns = new boolean[joinSpan];
 		for ( int j = 0; j < joinSpan; j++ ) {
 			tableHasColumns[j] = sqlUpdateStrings[j] != null;
 		}
 
 		//select SQL
 		sqlSnapshotSelectString = generateSnapshotSelectString();
 		sqlLazySelectString = generateLazySelectString();
 		sqlVersionSelectString = generateSelectVersionString();
 		if ( hasInsertGeneratedProperties() ) {
 			sqlInsertGeneratedValuesSelectString = generateInsertGeneratedValuesSelectString();
 		}
 		if ( hasUpdateGeneratedProperties() ) {
 			sqlUpdateGeneratedValuesSelectString = generateUpdateGeneratedValuesSelectString();
 		}
 		if ( isIdentifierAssignedByInsert() ) {
 			identityDelegate = ( ( PostInsertIdentifierGenerator ) getIdentifierGenerator() )
 					.getInsertGeneratedIdentifierDelegate( this, getFactory().getDialect(), useGetGeneratedKeys() );
 			sqlIdentityInsertString = customSQLInsert[0] == null
 					? generateIdentityInsertString( getPropertyInsertability() )
 					: customSQLInsert[0];
 		}
 		else {
 			sqlIdentityInsertString = null;
 		}
 
 		logStaticSQL();
 
 	}
 
 	public void postInstantiate() throws MappingException {
 
 		createLoaders();
 		createUniqueKeyLoaders();
 		createQueryLoader();
 
 	}
 
 	//needed by subclasses to override the createLoader strategy
 	protected Map getLoaders() {
 		return loaders;
 	}
 
 	//Relational based Persisters should be content with this implementation
 	protected void createLoaders() {
 		final Map loaders = getLoaders();
 		loaders.put( LockMode.NONE, createEntityLoader( LockMode.NONE ) );
 
 		UniqueEntityLoader readLoader = createEntityLoader( LockMode.READ );
 		loaders.put( LockMode.READ, readLoader );
 
 		//TODO: inexact, what we really need to know is: are any outer joins used?
 		boolean disableForUpdate = getSubclassTableSpan() > 1 &&
 				hasSubclasses() &&
 				!getFactory().getDialect().supportsOuterJoinForUpdate();
 
 		loaders.put(
 				LockMode.UPGRADE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.UPGRADE )
 			);
 		loaders.put(
 				LockMode.UPGRADE_NOWAIT,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.UPGRADE_NOWAIT )
 			);
 		loaders.put(
 				LockMode.FORCE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.FORCE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_READ,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_READ )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_WRITE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_WRITE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_FORCE_INCREMENT,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_FORCE_INCREMENT )
 			);
 		loaders.put( LockMode.OPTIMISTIC, createEntityLoader( LockMode.OPTIMISTIC) );
 		loaders.put( LockMode.OPTIMISTIC_FORCE_INCREMENT, createEntityLoader(LockMode.OPTIMISTIC_FORCE_INCREMENT) );
 	
 		loaders.put(
 				"merge",
 				new CascadeEntityLoader( this, CascadingAction.MERGE, getFactory() )
 			);
 		loaders.put(
 				"refresh",
 				new CascadeEntityLoader( this, CascadingAction.REFRESH, getFactory() )
 			);
 	}
 
 	protected void createQueryLoader() {
 		if ( loaderName != null ) {
 			queryLoader = new NamedQueryLoader( loaderName, this );
 		}
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session) {
 		return load( id, optionalObject, new LockOptions().setLockMode(lockMode), session );
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session)
 			throws HibernateException {
 
 		if ( log.isTraceEnabled() ) {
 			log.trace(
 					"Fetching entity: " +
 					MessageHelper.infoString( this, id, getFactory() )
 				);
 		}
 
 		final UniqueEntityLoader loader = getAppropriateLoader(lockOptions, session );
 		return loader.load( id, optionalObject, session, lockOptions );
 	}
 
 	public void registerAffectingFetchProfile(String fetchProfileName) {
 		affectingFetchProfileNames.add( fetchProfileName );
 	}
 
 	private boolean isAffectedByEnabledFetchProfiles(SessionImplementor session) {
 		Iterator itr = session.getLoadQueryInfluencers().getEnabledFetchProfileNames().iterator();
 		while ( itr.hasNext() ) {
 			if ( affectingFetchProfileNames.contains( itr.next() ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private boolean isAffectedByEnabledFilters(SessionImplementor session) {
 		return session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& filterHelper.isAffectedBy( session.getLoadQueryInfluencers().getEnabledFilters() );
 	}
 
 	private UniqueEntityLoader getAppropriateLoader(LockOptions lockOptions, SessionImplementor session) {
 		if ( queryLoader != null ) {
 			// if the user specified a custom query loader we need to that
 			// regardless of any other consideration
 			return queryLoader;
 		}
 		else if ( isAffectedByEnabledFilters( session ) ) {
 			// because filters affect the rows returned (because they add
 			// restirctions) these need to be next in precendence
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( session.getLoadQueryInfluencers().getInternalFetchProfile() != null && LockMode.UPGRADE.greaterThan( lockOptions.getLockMode() ) ) {
 			// Next, we consider whether an 'internal' fetch profile has been set.
 			// This indicates a special fetch profile Hibernate needs applied
 			// (for its merge loading process e.g.).
 			return ( UniqueEntityLoader ) getLoaders().get( session.getLoadQueryInfluencers().getInternalFetchProfile() );
 		}
 		else if ( isAffectedByEnabledFetchProfiles( session ) ) {
 			// If the session has associated influencers we need to adjust the
 			// SQL query used for loading based on those influencers
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
 			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else {
 			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
 		}
 	}
 
 	private boolean isAllNull(Object[] array, int tableNumber) {
 		for ( int i = 0; i < array.length; i++ ) {
 			if ( isPropertyOfTable( i, tableNumber ) && array[i] != null ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	public boolean isSubclassPropertyNullable(int i) {
 		return subclassPropertyNullabilityClosure[i];
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is dirty
 	 */
 	protected final boolean[] getPropertiesToUpdate(final int[] dirtyProperties, final boolean hasDirtyCollection) {
 		final boolean[] propsToUpdate = new boolean[ entityMetamodel.getPropertySpan() ];
 		final boolean[] updateability = getPropertyUpdateability(); //no need to check laziness, dirty checking handles that
 		for ( int j = 0; j < dirtyProperties.length; j++ ) {
 			int property = dirtyProperties[j];
 			if ( updateability[property] ) {
 				propsToUpdate[property] = true;
 			}
 		}
 		if ( isVersioned() && updateability[getVersionProperty() ]) {
 			propsToUpdate[ getVersionProperty() ] =
 				Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 		}
 		return propsToUpdate;
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is insertable and non-null
 	 */
 	protected boolean[] getPropertiesToInsert(Object[] fields) {
 		boolean[] notNull = new boolean[fields.length];
 		boolean[] insertable = getPropertyInsertability();
 		for ( int i = 0; i < fields.length; i++ ) {
 			notNull[i] = insertable[i] && fields[i] != null;
 		}
 		return notNull;
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param currentState The current state of the entity (the state to be checked).
 	 * @param previousState The previous state of the entity (the state to be checked against).
 	 * @param entity The entity for which we are checking state dirtiness.
 	 * @param session The session in which the check is ccurring.
 	 * @return <tt>null</tt> or the indices of the dirty properties
 	 * @throws HibernateException
 	 */
 	public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findDirty(
 				entityMetamodel.getProperties(),
 				currentState,
 				previousState,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity, session.getEntityMode() ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param old The old state of the entity.
 	 * @param current The current state of the entity.
 	 * @param entity The entity for which we are checking state modification.
 	 * @param session The session in which the check is ccurring.
 	 * @return <tt>null</tt> or the indices of the modified properties
 	 * @throws HibernateException
 	 */
 	public int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findModified(
 				entityMetamodel.getProperties(),
 				current,
 				old,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity, session.getEntityMode() ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Which properties appear in the SQL update?
 	 * (Initialized, updateable ones!)
 	 */
 	protected boolean[] getPropertyUpdateability(Object entity, EntityMode entityMode) {
 		return hasUninitializedLazyProperties( entity, entityMode ) ?
 				getNonLazyPropertyUpdateability() :
 				getPropertyUpdateability();
 	}
 
 	private void logDirtyProperties(int[] props) {
 		if ( log.isTraceEnabled() ) {
 			for ( int i = 0; i < props.length; i++ ) {
 				String propertyName = entityMetamodel.getProperties()[ props[i] ].getName();
 				log.trace( StringHelper.qualify( getEntityName(), propertyName ) + " is dirty" );
 			}
 		}
 	}
 
 	protected EntityTuplizer getTuplizer(SessionImplementor session) {
 		return getTuplizer( session.getEntityMode() );
 	}
 
 	protected EntityTuplizer getTuplizer(EntityMode entityMode) {
 		return entityMetamodel.getTuplizer( entityMode );
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	public EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	public boolean hasCache() {
 		return cacheAccessStrategy != null;
 	}
 
 	public EntityRegionAccessStrategy getCacheAccessStrategy() {
 		return cacheAccessStrategy;
 	}
 
 	public CacheEntryStructure getCacheEntryStructure() {
 		return cacheEntryStructure;
 	}
 
 	public Comparator getVersionComparator() {
 		return isVersioned() ? getVersionType().getComparator() : null;
 	}
 
 	// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	public final String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	public EntityType getEntityType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isPolymorphic() {
 		return entityMetamodel.isPolymorphic();
 	}
 
 	public boolean isInherited() {
 		return entityMetamodel.isInherited();
 	}
 
 	public boolean hasCascades() {
 		return entityMetamodel.hasCascades();
 	}
 
 	public boolean hasIdentifierProperty() {
 		return !entityMetamodel.getIdentifierProperty().isVirtual();
 	}
 
 	public VersionType getVersionType() {
 		return ( VersionType ) locateVersionType();
 	}
 
 	private Type locateVersionType() {
 		return entityMetamodel.getVersionProperty() == null ?
 				null :
 				entityMetamodel.getVersionProperty().getType();
 	}
 
 	public int getVersionProperty() {
 		return entityMetamodel.getVersionPropertyIndex();
 	}
 
 	public boolean isVersioned() {
 		return entityMetamodel.isVersioned();
 	}
 
 	public boolean isIdentifierAssignedByInsert() {
 		return entityMetamodel.getIdentifierProperty().isIdentifierAssignedByInsert();
 	}
 
 	public boolean hasLazyProperties() {
 		return entityMetamodel.hasLazyProperties();
 	}
 
 //	public boolean hasUninitializedLazyProperties(Object entity) {
 //		if ( hasLazyProperties() ) {
 //			InterceptFieldCallback callback = ( ( InterceptFieldEnabled ) entity ).getInterceptFieldCallback();
 //			return callback != null && !( ( FieldInterceptor ) callback ).isInitialized();
 //		}
 //		else {
 //			return false;
 //		}
 //	}
 
 	public void afterReassociate(Object entity, SessionImplementor session) {
 		//if ( hasLazyProperties() ) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			if ( interceptor != null ) {
 				interceptor.setSession( session );
 			}
 			else {
 				FieldInterceptor fieldInterceptor = FieldInterceptionHelper.injectFieldInterceptor(
 						entity,
 						getEntityName(),
 						null,
 						session
 				);
 				fieldInterceptor.dirty();
 			}
 		}
 	}
 
 	public Boolean isTransient(Object entity, SessionImplementor session) throws HibernateException {
 		final Serializable id;
 		if ( canExtractIdOutOfEntity() ) {
 			id = getIdentifier( entity, session );
 		}
 		else {
 			id = null;
 		}
 		// we *always* assume an instance with a null
 		// identifier or no identifier property is unsaved!
 		if ( id == null ) {
 			return Boolean.TRUE;
 		}
 
 		// check the version unsaved-value, if appropriate
 		final Object version = getVersion( entity, session.getEntityMode() );
 		if ( isVersioned() ) {
 			// let this take precedence if defined, since it works for
 			// assigned identifiers
 			Boolean result = entityMetamodel.getVersionProperty()
 					.getUnsavedValue().isUnsaved( version );
 			if ( result != null ) {
 				return result;
 			}
 		}
 
 		// check the id unsaved-value
 		Boolean result = entityMetamodel.getIdentifierProperty()
 				.getUnsavedValue().isUnsaved( id );
 		if ( result != null ) {
 			return result;
 		}
 
 		// check to see if it is in the second-level cache
 		if ( hasCache() ) {
 			CacheKey ck = new CacheKey(
 					id,
 					getIdentifierType(),
 					getRootEntityName(),
 					session.getEntityMode(),
 					session.getFactory()
 				);
 			if ( getCacheAccessStrategy().get( ck, session.getTimestamp() ) != null ) {
 				return Boolean.FALSE;
 			}
 		}
 
 		return null;
 	}
 
 	public boolean hasCollections() {
 		return entityMetamodel.hasCollections();
 	}
 
 	public boolean hasMutableProperties() {
 		return entityMetamodel.hasMutableProperties();
 	}
 
 	public boolean isMutable() {
 		return entityMetamodel.isMutable();
 	}
 
 	private boolean isModifiableEntity(EntityEntry entry) {
 
 		return ( entry == null ? isMutable() : entry.isModifiableEntity() );
 	}
 
 	public boolean isAbstract() {
 		return entityMetamodel.isAbstract();
 	}
 
 	public boolean hasSubclasses() {
 		return entityMetamodel.hasSubclasses();
 	}
 
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator() throws HibernateException {
 		return entityMetamodel.getIdentifierProperty().getIdentifierGenerator();
 	}
 
 	public String getRootEntityName() {
 		return entityMetamodel.getRootName();
 	}
 
 	public ClassMetadata getClassMetadata() {
 		return this;
 	}
 
 	public String getMappedSuperclass() {
 		return entityMetamodel.getSuperclass();
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return entityMetamodel.isExplicitPolymorphism();
 	}
 
 	protected boolean useDynamicUpdate() {
 		return entityMetamodel.isDynamicUpdate();
 	}
 
 	protected boolean useDynamicInsert() {
 		return entityMetamodel.isDynamicInsert();
 	}
 
 	protected boolean hasEmbeddedCompositeIdentifier() {
 		return entityMetamodel.getIdentifierProperty().isEmbedded();
 	}
 
 	public boolean canExtractIdOutOfEntity() {
 		return hasIdentifierProperty() || hasEmbeddedCompositeIdentifier() || hasIdentifierMapper();
 	}
 
 	private boolean hasIdentifierMapper() {
 		return entityMetamodel.getIdentifierProperty().hasIdentifierMapper();
 	}
 
 	public String[] getKeyColumnNames() {
 		return getIdentifierColumnNames();
 	}
 
 	public String getName() {
 		return getEntityName();
 	}
 
 	public boolean isCollection() {
 		return false;
 	}
 
 	public boolean consumesEntityAlias() {
 		return true;
 	}
 
 	public boolean consumesCollectionAlias() {
 		return false;
 	}
 
 	public Type getPropertyType(String propertyName) throws MappingException {
 		return propertyMapping.toType(propertyName);
 	}
 
 	public Type getType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isSelectBeforeUpdateRequired() {
 		return entityMetamodel.isSelectBeforeUpdate();
 	}
 
 	protected final int optimisticLockMode() {
 		return entityMetamodel.getOptimisticLockMode();
 	}
 
 	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException {
 		return entityMetamodel.getTuplizer( session.getEntityMode() )
 				.createProxy( id, session );
 	}
 
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) +
 				'(' + entityMetamodel.getName() + ')';
 	}
 
 	public final String selectFragment(
 			Joinable rhs,
 			String rhsAlias,
 			String lhsAlias,
 			String entitySuffix,
 			String collectionSuffix,
 			boolean includeCollectionColumns) {
 		return selectFragment( lhsAlias, entitySuffix );
 	}
 
 	public boolean isInstrumented(EntityMode entityMode) {
 		EntityTuplizer tuplizer = entityMetamodel.getTuplizerOrNull(entityMode);
 		return tuplizer!=null && tuplizer.isInstrumented();
 	}
 
 	public boolean hasInsertGeneratedProperties() {
 		return entityMetamodel.hasInsertGeneratedValues();
 	}
 
 	public boolean hasUpdateGeneratedProperties() {
 		return entityMetamodel.hasUpdateGeneratedValues();
 	}
 
 	public boolean isVersionPropertyGenerated() {
 		return isVersioned() && ( getPropertyUpdateGenerationInclusions() [ getVersionProperty() ] != ValueInclusion.NONE );
 	}
 
 	public boolean isVersionPropertyInsertable() {
 		return isVersioned() && getPropertyInsertability() [ getVersionProperty() ];
 	}
 
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		getTuplizer( session ).afterInitialize( entity, lazyPropertiesAreUnfetched, session );
 	}
 
 	public String[] getPropertyNames() {
 		return entityMetamodel.getPropertyNames();
 	}
 
 	public Type[] getPropertyTypes() {
 		return entityMetamodel.getPropertyTypes();
 	}
 
 	public boolean[] getPropertyLaziness() {
 		return entityMetamodel.getPropertyLaziness();
 	}
 
 	public boolean[] getPropertyUpdateability() {
 		return entityMetamodel.getPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyCheckability() {
 		return entityMetamodel.getPropertyCheckability();
 	}
 
 	public boolean[] getNonLazyPropertyUpdateability() {
 		return entityMetamodel.getNonlazyPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyInsertability() {
 		return entityMetamodel.getPropertyInsertability();
 	}
 
 	public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 		return entityMetamodel.getPropertyInsertGenerationInclusions();
 	}
 
 	public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 		return entityMetamodel.getPropertyUpdateGenerationInclusions();
 	}
 
 	public boolean[] getPropertyNullability() {
 		return entityMetamodel.getPropertyNullability();
 	}
 
 	public boolean[] getPropertyVersionability() {
 		return entityMetamodel.getPropertyVersionability();
 	}
 
 	public CascadeStyle[] getPropertyCascadeStyles() {
 		return entityMetamodel.getCascadeStyles();
 	}
 
 	public final Class getMappedClass(EntityMode entityMode) {
 		Tuplizer tup = entityMetamodel.getTuplizerOrNull(entityMode);
 		return tup==null ? null : tup.getMappedClass();
 	}
 
 	public boolean implementsLifecycle(EntityMode entityMode) {
 		return getTuplizer( entityMode ).isLifecycleImplementor();
 	}
 
 	public boolean implementsValidatable(EntityMode entityMode) {
 		return getTuplizer( entityMode ).isValidatableImplementor();
 	}
 
 	public Class getConcreteProxyClass(EntityMode entityMode) {
 		return getTuplizer( entityMode ).getConcreteProxyClass();
 	}
 
 	public void setPropertyValues(Object object, Object[] values, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValues( object, values );
 	}
 
 	public void setPropertyValue(Object object, int i, Object value, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValue( object, i, value );
 	}
 
 	public Object[] getPropertyValues(Object object, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValues( object );
 	}
 
 	public Object getPropertyValue(Object object, int i, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValue( object , i );
 	}
 
 	public Object getPropertyValue(Object object, String propertyName, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValue( object, propertyName );
 	}
 
 	public Serializable getIdentifier(Object object, EntityMode entityMode) throws HibernateException {
 		return getTuplizer( entityMode ).getIdentifier( object, null );
 	}
 
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		return getTuplizer( session.getEntityMode() ).getIdentifier( entity, session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setIdentifier( entity, id, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		getTuplizer( session ).setIdentifier( entity, id, session );
 	}
 
 	public Object getVersion(Object object, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getVersion( object );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object instantiate(Serializable id, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).instantiate( id, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object instantiate(Serializable id, SessionImplementor session)
 			throws HibernateException {
 		return getTuplizer( session ).instantiate( id, session );
 	}
 
 	public boolean isInstance(Object object, EntityMode entityMode) {
 		return getTuplizer( entityMode ).isInstance( object );
 	}
 
 	public boolean hasUninitializedLazyProperties(Object object, EntityMode entityMode) {
 		return getTuplizer( entityMode ).hasUninitializedLazyProperties( object );
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, EntityMode entityMode) {
 		getTuplizer( entityMode ).resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		getTuplizer( session ).resetIdentifier( entity, currentId, currentVersion, session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityPersister getSubclassEntityPersister(
 			Object instance,
 			SessionFactoryImplementor factory,
 			EntityMode entityMode) {
 		if ( !hasSubclasses() ) {
 			return this;
 		}
 		else {
 			final String concreteEntityName = getTuplizer( entityMode )
 					.determineConcreteSubclassEntityName( instance, factory );
 			if ( concreteEntityName == null || getEntityName().equals( concreteEntityName ) ) {
 				// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null
 				// is an indication that the specified entity-name (this.getEntityName) should be used.
 				return this;
 			}
 			else {
 				return factory.getEntityPersister( concreteEntityName );
 			}
 		}
 	}
 
 	public EntityMode guessEntityMode(Object object) {
 		return entityMetamodel.guessEntityMode(object);
 	}
 
 	public boolean isMultiTable() {
 		return false;
 	}
 
 	public String getTemporaryIdTableName() {
 		return temporaryIdTableName;
 	}
 
 	public String getTemporaryIdTableDDL() {
 		return temporaryIdTableDDL;
 	}
 
 	protected int getPropertySpan() {
 		return entityMetamodel.getPropertySpan();
 	}
 
 	public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) throws HibernateException {
 		return getTuplizer( session.getEntityMode() ).getPropertyValuesToInsert( object, mergeMap, session );
 	}
 
 	public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasInsertGeneratedProperties() ) {
 			throw new AssertionFailure("no insert-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlInsertGeneratedValuesSelectString, getPropertyInsertGenerationInclusions() );
 	}
 
 	public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasUpdateGeneratedProperties() ) {
 			throw new AssertionFailure("no update-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlUpdateGeneratedValuesSelectString, getPropertyUpdateGenerationInclusions() );
 	}
 
 	private void processGeneratedProperties(
 			Serializable id,
 	        Object entity,
 	        Object[] state,
 	        SessionImplementor session,
 	        String selectionSQL,
 	        ValueInclusion[] includeds) {
-
-		session.getJDBCContext().getConnectionManager().executeBatch(); //force immediate execution of the insert
+		// force immediate execution of the insert batch (if one)
+		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 
 		try {
-			PreparedStatement ps = session.getJDBCContext().getConnectionManager().prepareSelectStatement( selectionSQL );
+			PreparedStatement ps = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( selectionSQL );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = ps.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						throw new HibernateException(
 								"Unable to locate row for retrieval of generated properties: " +
 								MessageHelper.infoString( this, id, getFactory() )
 							);
 					}
 					for ( int i = 0; i < getPropertySpan(); i++ ) {
 						if ( includeds[i] != ValueInclusion.NONE ) {
 							Object hydratedState = getPropertyTypes()[i].hydrate( rs, getPropertyAliases( "", i ), session, entity );
 							state[i] = getPropertyTypes()[i].resolve( hydratedState, session, entity );
 							setPropertyValue( entity, i, state[i], session.getEntityMode() );
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						rs.close();
 					}
 				}
 			}
 			finally {
 				ps.close();
 			}
 		}
-		catch( SQLException sqle ) {
+		catch( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
+					e,
 					"unable to select generated column values",
 					selectionSQL
 			);
 		}
 
 	}
 
 	public String getIdentifierPropertyName() {
 		return entityMetamodel.getIdentifierProperty().getName();
 	}
 
 	public Type getIdentifierType() {
 		return entityMetamodel.getIdentifierProperty().getType();
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 
 	public int[] getNaturalIdentifierProperties() {
 		return entityMetamodel.getNaturalIdentifierProperties();
 	}
 
 	public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 		if ( !hasNaturalIdentifier() ) {
 			throw new MappingException( "persistent class did not define a natural-id : " + MessageHelper.infoString( this ) );
 		}
 		if ( log.isTraceEnabled() ) {
 			log.trace( "Getting current natural-id snapshot state for: " + MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		int[] naturalIdPropertyIndexes = getNaturalIdentifierProperties();
 		int naturalIdPropertyCount = naturalIdPropertyIndexes.length;
 		boolean[] naturalIdMarkers = new boolean[ getPropertySpan() ];
 		Type[] extractionTypes = new Type[ naturalIdPropertyCount ];
 		for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 			extractionTypes[i] = getPropertyTypes()[ naturalIdPropertyIndexes[i] ];
 			naturalIdMarkers[ naturalIdPropertyIndexes[i] ] = true;
 		}
 
 		///////////////////////////////////////////////////////////////////////
 		// TODO : look at perhaps caching this...
 		Select select = new Select( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current natural-id state " + getEntityName() );
 		}
 		select.setSelectClause( concretePropertySelectFragmentSansLeadingComma( getRootAlias(), naturalIdMarkers ) );
 		select.setFromClause( fromTableFragment( getRootAlias() ) + fromJoinFragment( getRootAlias(), true, false ) );
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 		String whereClause = new StringBuffer()
 			.append( StringHelper.join( "=? and ",
 					aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		String sql = select.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 		///////////////////////////////////////////////////////////////////////
 
 		Object[] snapshot = new Object[ naturalIdPropertyCount ];
 		try {
-			PreparedStatement ps = session.getJDBCContext().getConnectionManager().prepareSelectStatement( sql );
+			PreparedStatement ps = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( sql );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = ps.executeQuery();
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
-
 					final EntityKey key = new EntityKey( id, this, session.getEntityMode() );
 					Object owner = session.getPersistenceContext().getEntity( key );
 					for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 						snapshot[i] = extractionTypes[i].hydrate( rs, getPropertyAliases( "", naturalIdPropertyIndexes[i] ), session, null );
 						if (extractionTypes[i].isEntityType()) {
 							snapshot[i] = extractionTypes[i].resolve(snapshot[i], session, owner);
 						}
 					}
 					return snapshot;
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				ps.close();
 			}
 		}
-		catch ( SQLException sqle ) {
+		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
-					sqle,
-					"could not retrieve snapshot: " +
-					MessageHelper.infoString( this, id, getFactory() ),
+					e,
+					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        sql
-				);
+			);
 		}
 	}
 
 	protected String concretePropertySelectFragmentSansLeadingComma(String alias, boolean[] include) {
 		String concretePropertySelectFragment = concretePropertySelectFragment( alias, include );
 		int firstComma = concretePropertySelectFragment.indexOf( ", " );
 		if ( firstComma == 0 ) {
 			concretePropertySelectFragment = concretePropertySelectFragment.substring( 2 );
 		}
 		return concretePropertySelectFragment;
 	}
 	public boolean hasNaturalIdentifier() {
 		return entityMetamodel.hasNaturalIdentifier();
 	}
 
 	public void setPropertyValue(Object object, String propertyName, Object value, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValue( object, propertyName, value );
 	}
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceInitializer.java b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceInitializer.java
index 48002ff973..4917e50c6f 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceInitializer.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceInitializer.java
@@ -1,202 +1,210 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.service.jmx.spi.JmxService;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.InjectService;
 import org.hibernate.service.spi.Manageable;
 import org.hibernate.service.spi.Service;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.Startable;
 import org.hibernate.service.spi.UnknownServiceException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 /**
  * Delegate responsible for initializing services
  *
  * @author Steve Ebersole
  */
 public class ServiceInitializer {
 	private static final Logger log = LoggerFactory.getLogger( ServiceInitializer.class );
 
 	private final ServiceRegistryImpl servicesRegistry;
 	private final Map<Class,ServiceInitiator> serviceInitiatorMap;
 	private final Map configurationValues;
 
 	public ServiceInitializer(
 			ServiceRegistryImpl servicesRegistry,
 			List<ServiceInitiator> serviceInitiators,
 			Map configurationValues) {
 		this.servicesRegistry = servicesRegistry;
 		this.serviceInitiatorMap = toMap( serviceInitiators );
 		this.configurationValues = configurationValues;
 	}
 
 	/**
 	 * We convert the incoming list of initiators to a map for 2 reasons:<ul>
 	 * <li>to make it easier to look up the initiator we need for a given service role</li>
 	 * <li>to make sure there is only one initiator for a given service role (last wins)</li>
 	 * </ul>
 	 *
 	 * @param serviceInitiators The list of individual initiators
 	 *
 	 * @return The map of initiators keyed by the service rle they initiate.
 	 */
 	private static Map<Class, ServiceInitiator> toMap(List<ServiceInitiator> serviceInitiators) {
 		final Map<Class, ServiceInitiator> result = new HashMap<Class, ServiceInitiator>();
 		for ( ServiceInitiator initiator : serviceInitiators ) {
 			result.put( initiator.getServiceInitiated(), initiator );
 		}
 		return result;
 	}
 
 	void registerServiceInitiator(ServiceInitiator serviceInitiator) {
 		final Object previous = serviceInitiatorMap.put( serviceInitiator.getServiceInitiated(), serviceInitiator );
 		final boolean overwritten = previous != null;
 		if ( overwritten ) {
 			log.debug( "Over-wrote existing service initiator [role={}]", serviceInitiator.getServiceInitiated().getName() );
 		}
 	}
 
 	/**
 	 * The main function of this delegate.  Used to initialize the service of a given role.
 	 *
 	 * @param serviceRole The service role
 	 * @param <T> The type of service role
 	 *
 	 * @return The intiialized instance of the service
 	 */
 	public <T extends Service> T initializeService(Class<T> serviceRole) {
 		log.trace( "Initializing service [role=" + serviceRole.getName() + "]" );
 
 		// PHASE 1 : create service
 		T service = createService( serviceRole );
+		if ( service == null ) {
+			return null;
+		}
 
 		// PHASE 2 : configure service (***potentially recursive***)
 		configureService( service );
 
 		// PHASE 3 : Start service
 		startService( service, serviceRole );
 
 		return service;
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private <T extends Service> T createService(Class<T> serviceRole) {
 		ServiceInitiator<T> initiator = (ServiceInitiator<T>) serviceInitiatorMap.get( serviceRole );
 		if ( initiator == null ) {
 			throw new UnknownServiceException( serviceRole );
 		}
 		try {
 			T service = initiator.initiateService( configurationValues, servicesRegistry );
 			// IMPL NOTE : the register call here is important to avoid potential stack overflow issues
 			//		from recursive calls through #configureService
 			servicesRegistry.registerService( serviceRole, service );
 			return service;
 		}
 		catch ( ServiceException e ) {
 			throw e;
 		}
 		catch ( Exception e ) {
 			throw new ServiceException( "Unable to create requested service [" + serviceRole.getName() + "]", e );
 		}
 	}
 
 	private <T extends Service> void configureService(T service) {
 		applyInjections( service );
 
 		if ( Configurable.class.isInstance( service ) ) {
 			( (Configurable) service ).configure( configurationValues );
 		}
 
 		if ( ServiceRegistryAwareService.class.isInstance( service ) ) {
 			( (ServiceRegistryAwareService) service ).injectServices( servicesRegistry );
 		}
 	}
 
 	private <T extends Service> void applyInjections(T service) {
-		for ( Method method : service.getClass().getMethods() ) {
-			InjectService injectService = method.getAnnotation( InjectService.class );
-			if ( injectService == null ) {
-				continue;
-			}
+		try {
+			for ( Method method : service.getClass().getMethods() ) {
+				InjectService injectService = method.getAnnotation( InjectService.class );
+				if ( injectService == null ) {
+					continue;
+				}
 
-			applyInjection( service, method, injectService );
+				applyInjection( service, method, injectService );
+			}
+		}
+		catch (NullPointerException e) {
+			log.error( "NPE injecting service deps : " + service.getClass().getName() );
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private <T extends Service> void applyInjection(T service, Method injectionMethod, InjectService injectService) {
 		if ( injectionMethod.getParameterTypes() == null || injectionMethod.getParameterTypes().length != 1 ) {
 			throw new ServiceDependencyException(
 					"Encountered @InjectService on method with unexpected number of parameters"
 			);
 		}
 
 		Class dependentServiceRole = injectService.serviceRole();
 		if ( dependentServiceRole == null || dependentServiceRole.equals( Void.class ) ) {
 			dependentServiceRole = injectionMethod.getParameterTypes()[0];
 		}
 
 		// todo : because of the use of proxies, this is no longer returning null here...
 
 		final Service dependantService = servicesRegistry.getService( dependentServiceRole );
 		if ( dependantService == null ) {
 			if ( injectService.required() ) {
 				throw new ServiceDependencyException(
 						"Dependency [" + dependentServiceRole + "] declared by service [" + service + "] not found"
 				);
 			}
 		}
 		else {
 			try {
 				injectionMethod.invoke( service, dependantService );
 			}
 			catch ( Exception e ) {
 				throw new ServiceDependencyException( "Cannot inject dependency service", e );
 			}
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private <T extends Service> void startService(T service, Class serviceRole) {
 		if ( Startable.class.isInstance( service ) ) {
 			( (Startable) service ).start();
 		}
 
 		if ( Manageable.class.isInstance( service ) ) {
 			servicesRegistry.getService( JmxService.class ).registerService( (Manageable) service, serviceRole );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceRegistryImpl.java
index 65f8e094cf..bb53ab4a03 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceRegistryImpl.java
@@ -1,170 +1,171 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.HibernateException;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.internal.proxy.javassist.ServiceProxyFactoryFactoryImpl;
 import org.hibernate.service.spi.Service;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.service.spi.StandardServiceInitiators;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.service.spi.UnknownServiceException;
 import org.hibernate.service.spi.proxy.ServiceProxyFactory;
 import org.hibernate.service.spi.proxy.ServiceProxyTargetSource;
 import org.hibernate.util.CollectionHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Standard Hibernate implementation of the service registry.
  *
  * @author Steve Ebersole
  */
 public class ServiceRegistryImpl implements ServiceRegistry, ServiceProxyTargetSource {
 	private static final Logger log = LoggerFactory.getLogger( ServiceRegistryImpl.class );
 
 	private final ServiceInitializer initializer;
 	// for now just hardcode the javassist factory
 	private ServiceProxyFactory serviceProxyFactory = new ServiceProxyFactoryFactoryImpl().makeServiceProxyFactory( this );
 
 	private ConcurrentHashMap<Class,ServiceBinding> serviceBindingMap;
 	// IMPL NOTE : the list used for ordered destruction.  Cannot used ordered map above because we need to
 	// iterate it in reverse order which is only available through ListIterator
 	private List<Service> serviceList = new ArrayList<Service>();
 
 	public ServiceRegistryImpl(Map configurationValues) {
 		this( StandardServiceInitiators.LIST, configurationValues );
 	}
 
 	public ServiceRegistryImpl(List<ServiceInitiator> serviceInitiators, Map configurationValues) {
 		this.initializer = new ServiceInitializer( this, serviceInitiators, ConfigurationHelper.clone( configurationValues ) );
 		final int anticipatedSize = serviceInitiators.size() + 5; // allow some growth
 		serviceBindingMap = CollectionHelper.concurrentMap( anticipatedSize );
 		serviceList = CollectionHelper.arrayList( anticipatedSize );
 	}
 
 	public void destroy() {
-		ListIterator<Service> serviceIterator = serviceList.listIterator();
+		ListIterator<Service> serviceIterator = serviceList.listIterator( serviceList.size() );
 		while ( serviceIterator.hasPrevious() ) {
 			final Service service = serviceIterator.previous();
 			if ( Stoppable.class.isInstance( service ) ) {
 				try {
 					( (Stoppable) service ).stop();
 				}
 				catch ( Exception e ) {
 					log.info( "Error stopping service [" + service.getClass() + "] : " + e.toString() );
 				}
 			}
 		}
 		serviceList.clear();
 		serviceList = null;
 		serviceBindingMap.clear();
 		serviceBindingMap = null;
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public <T extends Service> T getService(Class<T> serviceRole) {
 		return locateOrCreateServiceBinding( serviceRole ).getProxy();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private <T extends Service> ServiceBinding<T> locateOrCreateServiceBinding(Class<T> serviceRole) {
 		ServiceBinding<T> serviceBinding = serviceBindingMap.get( serviceRole );
 		if ( serviceBinding == null ) {
 			T proxy = serviceProxyFactory.makeProxy( serviceRole );
 			serviceBinding = new ServiceBinding<T>( proxy );
 			serviceBindingMap.put( serviceRole, serviceBinding );
 		}
 		return serviceBinding;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T extends Service> T getServiceInternal(Class<T> serviceRole) {
 		ServiceBinding<T> serviceBinding = serviceBindingMap.get( serviceRole );
 		if ( serviceBinding == null ) {
 			throw new HibernateException( "Only proxies should invoke #getServiceInternal" );
 		}
 		T service = serviceBinding.getTarget();
 		if ( service == null ) {
 			service = initializer.initializeService( serviceRole );
 			serviceBinding.setTarget( service );
 		}
 		if ( service == null ) {
 			throw new UnknownServiceException( serviceRole );
 		}
 		return service;
 	}
 
 	@Override
 	public <T extends Service> void registerService(Class<T> serviceRole, T service) {
 		ServiceBinding<T> serviceBinding = locateOrCreateServiceBinding( serviceRole );
 		T priorServiceInstance = serviceBinding.getTarget();
 		serviceBinding.setTarget( service );
 		if ( priorServiceInstance != null ) {
 			serviceList.remove( priorServiceInstance );
 		}
 		serviceList.add( service );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public void registerServiceInitiator(ServiceInitiator initiator) {
 		ServiceBinding serviceBinding = serviceBindingMap.get( initiator.getServiceInitiated() );
 		if ( serviceBinding != null ) {
 			serviceBinding.setTarget( null );
 		}
 		initializer.registerServiceInitiator( initiator );
 	}
 
 	private static final class ServiceBinding<T> {
 		private final T proxy;
 		private T target;
 
 		private ServiceBinding(T proxy) {
 			this.proxy = proxy;
 		}
 
 		public T getProxy() {
 			return proxy;
 		}
 
 		public T getTarget() {
 			return target;
 		}
 
 		public void setTarget(T target) {
 			this.target = target;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
index 8ce96e19c9..de059feb8d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
@@ -1,215 +1,222 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.Properties;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.spi.UnknownUnwrapTypeException;
 import org.hibernate.util.ReflectHelper;
 
 /**
  * A connection provider that uses the {@link java.sql.DriverManager} directly to open connections and provides
  * a very rudimentary connection pool.
  * <p/>
  * IMPL NOTE : not intended for production use!
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
+@SuppressWarnings( {"UnnecessaryUnboxing"})
 public class DriverManagerConnectionProviderImpl implements ConnectionProvider, Configurable, Stoppable {
 	private static final Logger log = LoggerFactory.getLogger( DriverManagerConnectionProviderImpl.class );
 
 	private String url;
 	private Properties connectionProps;
 	private Integer isolation;
 	private int poolSize;
 	private boolean autocommit;
 
 	private final ArrayList<Connection> pool = new ArrayList<Connection>();
 	private int checkedOut = 0;
 
+	private boolean stopped;
+
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	public void configure(Map configurationValues) {
 		log.info( "Using Hibernate built-in connection pool (not for production use!)" );
 
 		String driverClassName = (String) configurationValues.get( Environment.DRIVER );
 		if ( driverClassName == null ) {
 			log.warn( "no JDBC Driver class was specified by property " + Environment.DRIVER );
 		}
 		else {
 			try {
 				// trying via forName() first to be as close to DriverManager's semantics
 				Class.forName( driverClassName );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				try {
 					ReflectHelper.classForName( driverClassName );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new HibernateException( "Specified JDBC Driver " + driverClassName + " class not found", e );
 				}
 			}
 		}
 
 		poolSize = ConfigurationHelper.getInt( Environment.POOL_SIZE, configurationValues, 20 ); // default pool size 20
 		log.info( "Hibernate connection pool size: " + poolSize );
 
 		autocommit = ConfigurationHelper.getBoolean( Environment.AUTOCOMMIT, configurationValues );
 		log.info("autocommit mode: " + autocommit);
 
 		isolation = ConfigurationHelper.getInteger( Environment.ISOLATION, configurationValues );
 		if (isolation!=null)
 		log.info( "JDBC isolation level: " + Environment.isolationLevelToString( isolation.intValue() ) );
 
 		url = (String) configurationValues.get( Environment.URL );
 		if ( url == null ) {
 			String msg = "JDBC URL was not specified by property " + Environment.URL;
 			log.error( msg );
 			throw new HibernateException( msg );
 		}
 
 		connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
 
 		log.info( "using driver [" + driverClassName + "] at URL [" + url + "]" );
 		// if debug level is enabled, then log the password, otherwise mask it
 		if ( log.isDebugEnabled() ) {
 			log.info( "connection properties: " + connectionProps );
 		}
 		else if ( log.isInfoEnabled() ) {
 			log.info( "connection properties: " + ConfigurationHelper.maskOut( connectionProps, "password" ) );
 		}
 	}
 
 	public void stop() {
 		log.info( "cleaning up connection pool [" + url + "]" );
 
 		for ( Connection connection : pool ) {
 			try {
 				connection.close();
 			}
 			catch (SQLException sqle) {
 				log.warn( "problem closing pooled connection", sqle );
 			}
 		}
 		pool.clear();
+		stopped = true;
 	}
 
 	public Connection getConnection() throws SQLException {
 		log.trace( "total checked-out connections: " + checkedOut );
 
 		// essentially, if we have available connections in the pool, use one...
 		synchronized (pool) {
 			if ( !pool.isEmpty() ) {
 				int last = pool.size() - 1;
 				if ( log.isTraceEnabled() ) {
 					log.trace( "using pooled JDBC connection, pool size: " + last );
 					checkedOut++;
 				}
-				Connection pooled = (Connection) pool.remove(last);
+				Connection pooled = pool.remove(last);
 				if ( isolation != null ) {
 					pooled.setTransactionIsolation( isolation.intValue() );
 				}
 				if ( pooled.getAutoCommit() != autocommit ) {
 					pooled.setAutoCommit( autocommit );
 				}
 				return pooled;
 			}
 		}
 
 		// otherwise we open a new connection...
 
 		log.debug( "opening new JDBC connection" );
 		Connection conn = DriverManager.getConnection( url, connectionProps );
 		if ( isolation != null ) {
 			conn.setTransactionIsolation( isolation.intValue() );
 		}
 		if ( conn.getAutoCommit() != autocommit ) {
 			conn.setAutoCommit(autocommit);
 		}
 
 		if ( log.isDebugEnabled() ) {
 			log.debug( "created connection to: " + url + ", Isolation Level: " + conn.getTransactionIsolation() );
 		}
 
 		checkedOut++;
 
 		return conn;
 	}
 
 	public void closeConnection(Connection conn) throws SQLException {
 		checkedOut--;
 
 		// add to the pool if the max size is not yet reached.
 		synchronized (pool) {
 			int currentSize = pool.size();
 			if ( currentSize < poolSize ) {
 				if ( log.isTraceEnabled() ) log.trace("returning connection to pool, pool size: " + (currentSize + 1) );
 				pool.add(conn);
 				return;
 			}
 		}
 
 		log.debug("closing JDBC connection");
 		conn.close();
 	}
 
-	protected void finalize() {
-		stop();
+	protected void finalize() throws Throwable {
+		if ( !stopped ) {
+			stop();
+		}
+		super.finalize();
 	}
 
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java
new file mode 100644
index 0000000000..8a6f696b17
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java
@@ -0,0 +1,133 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.Configurable;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.ServiceRegistryAwareService;
+
+import javax.transaction.Synchronization;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.util.Map;
+
+/**
+ * @author Steve Ebersole
+ */
+public abstract class AbstractJtaPlatform
+		implements JtaPlatform, Configurable, ServiceRegistryAwareService, TransactionManagerAccess {
+	private boolean cacheTransactionManager;
+	private boolean cacheUserTransaction;
+	private ServiceRegistry serviceRegistry;
+
+	@Override
+	public void injectServices(ServiceRegistry serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
+	}
+
+	protected ServiceRegistry serviceRegistry() {
+		return serviceRegistry;
+	}
+
+	protected JndiService jndiService() {
+		return serviceRegistry().getService( JndiService.class );
+	}
+
+	protected abstract TransactionManager locateTransactionManager();
+	protected abstract UserTransaction locateUserTransaction();
+
+	public void configure(Map configValues) {
+		cacheTransactionManager = ConfigurationHelper.getBoolean( CACHE_TM, configValues, true );
+		cacheUserTransaction = ConfigurationHelper.getBoolean( CACHE_UT, configValues, false );
+	}
+
+	protected boolean canCacheTransactionManager() {
+		return cacheTransactionManager;
+	}
+
+	protected boolean canCacheUserTransaction() {
+		return cacheUserTransaction;
+	}
+
+	private TransactionManager transactionManager;
+
+	@Override
+	public TransactionManager retrieveTransactionManager() {
+		if ( canCacheTransactionManager() ) {
+			if ( transactionManager == null ) {
+				transactionManager = locateTransactionManager();
+			}
+			return transactionManager;
+		}
+		else {
+			return locateTransactionManager();
+		}
+	}
+
+	@Override
+	public TransactionManager getTransactionManager() {
+		return retrieveTransactionManager();
+	}
+
+	private UserTransaction userTransaction;
+
+	@Override
+	public UserTransaction retrieveUserTransaction() {
+		if ( canCacheUserTransaction() ) {
+			if ( userTransaction == null ) {
+				userTransaction = locateUserTransaction();
+			}
+			return userTransaction;
+		}
+		return locateUserTransaction();
+	}
+
+	@Override
+	public Object getTransactionIdentifier(Transaction transaction) {
+		// generally we use the transaction itself.
+		return transaction;
+	}
+
+	protected abstract JtaSynchronizationStrategy getSynchronizationStrategy();
+
+	@Override
+	public void registerSynchronization(Synchronization synchronization) {
+		getSynchronizationStrategy().registerSynchronization( synchronization );
+	}
+
+	@Override
+	public boolean canRegisterSynchronization() {
+		return getSynchronizationStrategy().canRegisterSynchronization();
+	}
+
+	@Override
+	public int getCurrentStatus() throws SystemException {
+		return retrieveTransactionManager().getStatus();
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/BTMTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java
similarity index 51%
rename from hibernate-core/src/main/java/org/hibernate/transaction/BTMTransactionManagerLookup.java
rename to hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java
index e59ed39a9e..f8c2978fa9 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/BTMTransactionManagerLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java
@@ -1,71 +1,62 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.transaction;
-
-import java.lang.reflect.Method;
-import java.util.Properties;
-
-import javax.transaction.TransactionManager;
-import javax.transaction.Transaction;
-
-import org.hibernate.HibernateException;
-
-/**
- * TransactionManager lookup strategy for BTM
- *
- * @author Ludovic Orban
- */
-@SuppressWarnings( {"UnusedDeclaration"})
-public class BTMTransactionManagerLookup implements TransactionManagerLookup {
-
-	private static final String TM_CLASS_NAME = "bitronix.tm.TransactionManagerServices";
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		try {
-			final Class clazz = Class.forName( TM_CLASS_NAME );
-			final Method method = clazz.getMethod( "getTransactionManager", (Class[]) null );
-			return (TransactionManager) method.invoke( null, (Object[]) null );
-		}
-		catch (Exception e) {
-			throw new HibernateException( "Could not obtain BTM transaction manager instance", e );
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Object getTransactionIdentifier(Transaction transaction) {
-		return transaction;
-	}
-}
\ No newline at end of file
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.lang.reflect.Method;
+
+/**
+ * @author Steve Ebersole
+ */
+public class BitronixJtaPlatform extends AbstractJtaPlatform {
+	private static final String TM_CLASS_NAME = "bitronix.tm.TransactionManagerServices";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		try {
+			Class transactionManagerServicesClass = serviceRegistry().getService( ClassLoaderService.class ).classForName( TM_CLASS_NAME );
+			final Method getTransactionManagerMethod = transactionManagerServicesClass.getMethod( "getTransactionManager" );
+			return (TransactionManager) getTransactionManagerMethod.invoke( null );
+		}
+		catch (Exception e) {
+			throw new JtaPlatformException( "Could not locate Bitronix TransactionManager", e );
+		}
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( "java:comp/UserTransaction" );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
new file mode 100644
index 0000000000..4a6c0770e7
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
@@ -0,0 +1,52 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * @author Steve Ebersole
+ */
+public class BorlandEnterpriseServerJtaPlatform extends AbstractJtaPlatform {
+	protected static final String TM_NAME = "java:pm/TransactionManager";
+	protected static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerPlatform.java
index 6250106a95..c3202f8d23 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerPlatform.java
@@ -1,94 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jta.platform.internal;
 
-import java.util.Map;
-import javax.transaction.Synchronization;
 import javax.transaction.TransactionManager;
 import javax.transaction.TransactionSynchronizationRegistry;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.internal.util.jta.JtaStatusHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
-import org.hibernate.service.spi.Configurable;
-import org.hibernate.service.spi.InjectService;
-import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.jndi.spi.JndiService;
-
-
 /**
- * TODO : javadoc
+ * JtaPlatform definition for JBoss Application Server.
  *
  * @author Steve Ebersole
  */
-public class JBossAppServerPlatform implements JtaPlatform, Configurable {
+public class JBossAppServerPlatform extends AbstractJtaPlatform implements SynchronizationRegistryAccess {
 	public static final String TM_NAME = "java:/TransactionManager";
 	public static final String UT_NAME = "UserTransaction";
 	public static final String REG_NAME = "java:comp/TransactionSynchronizationRegistry";
 
-	private JndiService jndiService;
-
-	@InjectService
-	public void setJndiService(JndiService jndiService) {
-		this.jndiService = jndiService;
-	}
-
-	private boolean cacheTransactionManager;
-
-	public void configure(Map configValues) {
-		cacheTransactionManager = ConfigurationHelper.getBoolean( CACHE_TM, configValues, true );
-	}
-
-	private TransactionManager transactionManager;
-
-	public TransactionManager resolveTransactionManager() {
-		if ( cacheTransactionManager ) {
-			if ( transactionManager == null ) {
-				transactionManager = (TransactionManager) jndiService.locate( TM_NAME );
-			}
-			return transactionManager;
-		}
-		else {
-			return (TransactionManager) jndiService.locate( TM_NAME );
-		}
-	}
-
-	public UserTransaction resolveUserTransaction() {
-		return (UserTransaction) jndiService.locate( UT_NAME );
+	private final JtaSynchronizationStrategy synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy( this );
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
-	public void registerSynchronization(Synchronization synchronization) {
-		getTransactionSynchronizationRegistry().registerInterposedSynchronization( synchronization );
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 
-	private TransactionSynchronizationRegistry getTransactionSynchronizationRegistry() {
-		return (TransactionSynchronizationRegistry) jndiService.locate( REG_NAME );
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
 	}
 
-	public boolean canRegisterSynchronization() {
-		TransactionSynchronizationRegistry registry = getTransactionSynchronizationRegistry();
-		int status = registry.getTransactionStatus();
-		return JtaStatusHelper.isActive( status ) && ! registry.getRollbackOnly();
+	@Override
+	public TransactionSynchronizationRegistry getSynchronizationRegistry() {
+		return (TransactionSynchronizationRegistry) jndiService().locate( REG_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java
new file mode 100644
index 0000000000..01f48e49fe
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java
@@ -0,0 +1,70 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.lang.reflect.Method;
+
+/**
+ * Return a standalone JTA transaction manager for JBoss Transactions
+ * Known to work for org.jboss.jbossts:jbossjta:4.11.0.Final
+ *
+ * @author Emmanuel Bernard
+ * @author Steve Ebersole
+ */
+public class JBossStandAloneJtaPlatform extends AbstractJtaPlatform {
+	private static final String PROPERTY_MANAGER_CLASS_NAME = "com.arjuna.ats.jta.common.jtaPropertyManager";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		try {
+			final Class propertyManagerClass = serviceRegistry()
+					.getService( ClassLoaderService.class )
+					.classForName( PROPERTY_MANAGER_CLASS_NAME );
+			final Method getJTAEnvironmentBeanMethod = propertyManagerClass.getMethod( "getJTAEnvironmentBean" );
+			final Object jtaEnvironmentBean = getJTAEnvironmentBeanMethod.invoke( null );
+			final Method getTransactionManagerMethod = jtaEnvironmentBean.getClass().getMethod( "getTransactionManager" );
+			return ( TransactionManager ) getTransactionManagerMethod.invoke( jtaEnvironmentBean );
+		}
+		catch ( Exception e ) {
+			throw new JtaPlatformException( "Could not obtain JBoss Transactions transaction manager instance", e );
+		}
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return null;
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java
new file mode 100644
index 0000000000..6360d3fb82
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java
@@ -0,0 +1,63 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.lang.reflect.Method;
+
+/**
+ * @author Steve Ebersole
+ */
+public class JOTMJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_CLASS_NAME = "org.objectweb.jotm.Current";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		try {
+			final Class tmClass = serviceRegistry().getService( ClassLoaderService.class ).classForName( TM_CLASS_NAME );
+			final Method getTransactionManagerMethod = tmClass.getMethod( "getTransactionManager" );
+			return (TransactionManager) getTransactionManagerMethod.invoke( null, (Object[]) null );
+		}
+		catch (Exception e) {
+			throw new JtaPlatformException( "Could not obtain JOTM transaction manager instance", e );
+		}
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JOnASTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java
similarity index 55%
rename from hibernate-core/src/main/java/org/hibernate/transaction/JOnASTransactionManagerLookup.java
rename to hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java
index 063033bf1d..617cdf4b90 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JOnASTransactionManagerLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java
@@ -1,70 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction;
+package org.hibernate.service.jta.platform.internal;
 
-import java.lang.reflect.Method;
-import java.util.Properties;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
 
 import javax.transaction.TransactionManager;
-import javax.transaction.Transaction;
-
-import org.hibernate.HibernateException;
+import javax.transaction.UserTransaction;
+import java.lang.reflect.Method;
 
 /**
- * {@link TransactionManagerLookup} strategy for JOnAS
+ * JTA platform implementation for JOnAS
+ *
+ * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnusedDeclaration"})
-public class JOnASTransactionManagerLookup implements TransactionManagerLookup {
-
+public class JOnASJtaPlatform extends AbstractJtaPlatform {
+	public static final String UT_NAME = "java:comp/UserTransaction";
 	private static final String TM_CLASS_NAME = "org.objectweb.jonas_tm.Current";
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
 		try {
 			final Class clazz = Class.forName( TM_CLASS_NAME );
-			final Method method = clazz.getMethod( "getTransactionManager", (Class[]) null );
-			return (TransactionManager) method.invoke( null, (Object[]) null );
+			final Method getTransactionManagerMethod = clazz.getMethod( "getTransactionManager" );
+			return (TransactionManager) getTransactionManagerMethod.invoke( null );
 		}
 		catch (Exception e) {
-			throw new HibernateException( "Could not obtain JOnAS transaction manager instance", e );
+			throw new JtaPlatformException( "Could not obtain JOnAS transaction manager instance", e );
 		}
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public Object getTransactionIdentifier(Transaction transaction) {
-		return transaction;
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
 	}
 }
-
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java
new file mode 100644
index 0000000000..fde0d6eecd
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java
@@ -0,0 +1,55 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for JRun4 AS
+ *
+ * @author Joseph Bissen
+ * @author Steve Ebersole
+ */
+public class JRun4JtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "java:/TransactionManager";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java
index 5e548dbee6..9254eb76a7 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java
@@ -1,74 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jta.platform.internal;
 
 import java.util.Map;
 
 import org.hibernate.HibernateException;
+import org.hibernate.cfg.Environment;
+import org.hibernate.internal.util.jndi.JndiHelper;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.transaction.TransactionManagerLookup;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Standard initiator for the standard {@link org.hibernate.service.jta.platform.spi.JtaPlatform}
  *
  * @author Steve Ebersole
  */
 public class JtaPlatformInitiator implements ServiceInitiator<JtaPlatform> {
 	public static final JtaPlatformInitiator INSTANCE = new JtaPlatformInitiator();
-
 	public static final String JTA_PLATFORM = "hibernate.jta.platform";
 
-	/**
-	 * {@inheritDoc}
-	 */
+	private static final Logger log = LoggerFactory.getLogger( JtaPlatformInitiator.class );
+
+	@Override
 	public Class<JtaPlatform> getServiceInitiated() {
 		return JtaPlatform.class;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public JtaPlatform initiateService(Map configVales, ServiceRegistry registry) {
-		final Object platform = configVales.get( JTA_PLATFORM );
-		if ( JtaPlatform.class.isInstance( platform ) ) {
-			return (JtaPlatform) platform;
+		final Object platform = getConfiguredPlatform( configVales, registry );
+		if ( platform == null ) {
+			return new NoJtaPlatform();
 		}
 
-		if ( platform == null ) {
-			return null;
+		if ( JtaPlatform.class.isInstance( platform ) ) {
+			return (JtaPlatform) platform;
 		}
 
 		final String platformImplName = platform.toString();
 
 		ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 		try {
 			return (JtaPlatform) classLoaderService.classForName( platformImplName ).newInstance();
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Unable to create specified JtaPlatform class [" + platformImplName + "]", e );
 		}
 	}
+
+	private Object getConfiguredPlatform(Map configVales, ServiceRegistry registry) {
+		Object platform = configVales.get( JTA_PLATFORM );
+		if ( platform == null ) {
+			final String transactionManagerLookupImplName = (String) configVales.get( Environment.TRANSACTION_MANAGER_STRATEGY );
+			if ( transactionManagerLookupImplName != null ) {
+				log.warn(
+						"Using deprecated " + TransactionManagerLookup.class.getName() + " strategy [" +
+								Environment.TRANSACTION_MANAGER_STRATEGY +
+								"], use newer " + JtaPlatform.class.getName() +
+								" strategy instead [" + JTA_PLATFORM + "]"
+				);
+				platform = mapLegacyClasses( transactionManagerLookupImplName, configVales, registry );
+				log.debug( "Mapped {} -> {}", transactionManagerLookupImplName, platform );
+			}
+		}
+		return platform;
+	}
+
+	private JtaPlatform mapLegacyClasses(
+			String transactionManagerLookupImplName,
+			Map configVales,
+			ServiceRegistry registry) {
+		if ( transactionManagerLookupImplName == null ) {
+			return null;
+		}
+
+		log.info(
+				"Encountered legacy TransactionManagerLookup specified; convert to newer " +
+						JtaPlatform.class.getName() + " contract specified via " +
+						JTA_PLATFORM + "setting"
+		);
+
+		if ( "org.hibernate.transaction.BESTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new BorlandEnterpriseServerJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.BTMTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new BitronixJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.JBossTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new JBossAppServerPlatform();
+		}
+
+		if ( "org.hibernate.transaction.JBossTSStandaloneTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new JBossStandAloneJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.JOnASTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new JOnASJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.JOTMTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new JOTMJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.JRun4TransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new JRun4JtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.OC4JTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new OC4JJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.OrionTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new OrionJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.ResinTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new ResinJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.SunONETransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new SunOneJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.WeblogicTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new WeblogicJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.WebSphereTransactionManagerLookup".equals( transactionManagerLookupImplName ) ) {
+			return new WebSphereJtaPlatform();
+		}
+
+		if ( "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup".equals( transactionManagerLookupImplName ) ) {
+			return new WebSphereExtendedJtaPlatform();
+		}
+
+		try {
+			TransactionManagerLookup lookup = (TransactionManagerLookup) registry.getService( ClassLoaderService.class )
+					.classForName( transactionManagerLookupImplName )
+					.newInstance();
+			return new TransactionManagerLookupBridge( lookup, JndiHelper.extractJndiProperties( configVales ) );
+		}
+		catch ( Exception e ) {
+			throw new JtaPlatformException(
+					"Unable to build " + TransactionManagerLookupBridge.class.getName() + " from specified " +
+							TransactionManagerLookup.class.getName() + " implementation: " +
+							transactionManagerLookupImplName
+			);
+		}
+	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java
new file mode 100644
index 0000000000..64d89e8bb8
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java
@@ -0,0 +1,48 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.Synchronization;
+import java.io.Serializable;
+
+/**
+ * Contract used to centralize {@link Synchronization} handling logic.
+ *
+ * @author Steve Ebersole
+ */
+public interface JtaSynchronizationStrategy extends Serializable {
+	/**
+	 * Register a synchronization
+	 *
+	 * @param synchronization The synchronization to register.
+	 */
+	public void registerSynchronization(Synchronization synchronization);
+
+	/**
+	 * Can a synchronization be registered?
+	 *
+	 * @return {@literal true}/{@literal false}
+	 */
+	public boolean canRegisterSynchronization();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JOTMTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java
similarity index 53%
rename from hibernate-core/src/main/java/org/hibernate/transaction/JOTMTransactionManagerLookup.java
rename to hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java
index 23a6ec967f..6d60fe198b 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JOTMTransactionManagerLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java
@@ -1,77 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction;
+package org.hibernate.service.jta.platform.internal;
 
-import java.lang.reflect.Method;
-import java.util.Properties;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
 
-import javax.transaction.TransactionManager;
+import javax.transaction.Status;
+import javax.transaction.Synchronization;
+import javax.transaction.SystemException;
 import javax.transaction.Transaction;
-
-import org.hibernate.HibernateException;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
 
 /**
- * {@link TransactionManagerLookup} strategy for JOTM
+ * The non-configured form of JTA platform.  This is what is used if none was set up.
  *
- * @author Low Heng Sin
+ * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnusedDeclaration"})
-public class JOTMTransactionManagerLookup implements TransactionManagerLookup {
-
-	private static final String TM_CLASS_NAME = "org.objectweb.jotm.Current";
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		try {
-			final Class clazz = Class.forName( TM_CLASS_NAME );
-			final Method method = clazz.getMethod( "getTransactionManager", (Class[]) null );
-			return (TransactionManager) method.invoke( null, (Object[]) null );
-		}
-		catch (Exception e) {
-			throw new HibernateException( "Could not obtain JOTM transaction manager instance", e );
-		}
+public class NoJtaPlatform implements JtaPlatform {
+	@Override
+	public TransactionManager retrieveTransactionManager() {
+		return null;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
+	@Override
+	public UserTransaction retrieveUserTransaction() {
+		return null;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
-		return transaction;
+		return null;
 	}
-}
-
-
-
 
+	@Override
+	public void registerSynchronization(Synchronization synchronization) {
+	}
 
+	@Override
+	public boolean canRegisterSynchronization() {
+		return false;
+	}
 
+	@Override
+	public int getCurrentStatus() throws SystemException {
+		return Status.STATUS_UNKNOWN;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java
new file mode 100644
index 0000000000..4112ebdf4d
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java
@@ -0,0 +1,55 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for the OC4J (Oracle) AS.
+ *
+ * @author Stijn Janssens
+ * @author Steve Ebersole
+ */
+public class OC4JJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "java:comp/pm/TransactionManager";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java
new file mode 100644
index 0000000000..44b862c6c4
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java
@@ -0,0 +1,55 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Orion
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class OrionJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "java:comp/UserTransaction";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java
new file mode 100644
index 0000000000..6b44cc305e
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java
@@ -0,0 +1,55 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Resin
+ *
+ * @author Aapo Laakkonen
+ * @author Steve Ebersole
+ */
+public class ResinJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "java:comp/TransactionManager";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java
new file mode 100644
index 0000000000..0213b9e52a
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java
@@ -0,0 +1,57 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Sun ONE Application Server 7 and above
+ *
+ * @author Robert Davidson
+ * @author Sanjeev Krishnan
+ * @author Emmanuel Bernard
+ * @author Steve Ebersole
+ */
+public class SunOneJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "java:appserver/TransactionManager";
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java
new file mode 100644
index 0000000000..2f7698f0fd
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java
@@ -0,0 +1,42 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionSynchronizationRegistry;
+import java.io.Serializable;
+
+/**
+ * Provides access to a {@link TransactionSynchronizationRegistry} for use by {@link TransactionSynchronizationRegistry}-based
+ * {@link JtaSynchronizationStrategy} implementations.
+ *
+ * @author Steve Ebersole
+ */
+public interface SynchronizationRegistryAccess extends Serializable {
+	/**
+	 * Obtain the synchronization registry
+	 *
+	 * @return the synchronization registry
+	 */
+	public TransactionSynchronizationRegistry getSynchronizationRegistry();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
new file mode 100644
index 0000000000..c735ec7cf5
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
@@ -0,0 +1,56 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
+
+import javax.transaction.Synchronization;
+import javax.transaction.TransactionSynchronizationRegistry;
+
+/**
+ * Implementation of the {@link JtaSynchronizationStrategy} contract based on using a
+ * {@link TransactionSynchronizationRegistry}
+ *
+ * @author Steve Ebersole
+ */
+public class SynchronizationRegistryBasedSynchronizationStrategy implements JtaSynchronizationStrategy {
+	private final SynchronizationRegistryAccess synchronizationRegistryAccess;
+
+	public SynchronizationRegistryBasedSynchronizationStrategy(SynchronizationRegistryAccess synchronizationRegistryAccess) {
+		this.synchronizationRegistryAccess = synchronizationRegistryAccess;
+	}
+
+	@Override
+	public void registerSynchronization(Synchronization synchronization) {
+		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
+				synchronization
+		);
+	}
+
+	@Override
+	public boolean canRegisterSynchronization() {
+		final TransactionSynchronizationRegistry registry = synchronizationRegistryAccess.getSynchronizationRegistry();
+		return JtaStatusHelper.isActive( registry.getTransactionStatus() ) && ! registry.getRollbackOnly();
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/IsolatedWork.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java
similarity index 61%
rename from hibernate-core/src/main/java/org/hibernate/engine/transaction/IsolatedWork.java
rename to hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java
index 94269d99f4..788c8cc7c3 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/IsolatedWork.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java
@@ -1,46 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.engine.transaction;
-
-import org.hibernate.HibernateException;
+package org.hibernate.service.jta.platform.internal;
 
-import java.sql.Connection;
+import javax.transaction.TransactionManager;
+import java.io.Serializable;
 
 /**
- * Represents work that needs to be performed in a manner
- * which isolates it from any current application unit of
- * work transaction.
+ * Provides access to a {@link TransactionManager} for use by {@link TransactionManager}-based
+ * {@link JtaSynchronizationStrategy} implementations.
  *
  * @author Steve Ebersole
  */
-public interface IsolatedWork {
+public interface TransactionManagerAccess extends Serializable {
 	/**
-	 * Perform the actual work to be done.
+	 * Obtain the transaction manager
 	 *
-	 * @param connection The JDBC connection to use.
-	 * @throws HibernateException
+	 * @return The transaction manager.
 	 */
-	public void doWork(Connection connection) throws HibernateException;
+	public TransactionManager getTransactionManager();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
new file mode 100644
index 0000000000..45f25531d8
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
@@ -0,0 +1,58 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+
+import javax.transaction.Synchronization;
+
+/**
+ * Implementation of the {@link JtaSynchronizationStrategy} contract based on using a
+ * {@link javax.transaction.TransactionManager}
+ * 
+ * @author Steve Ebersole
+ */
+public class TransactionManagerBasedSynchronizationStrategy implements JtaSynchronizationStrategy {
+	private final TransactionManagerAccess transactionManagerAccess;
+
+	public TransactionManagerBasedSynchronizationStrategy(TransactionManagerAccess transactionManagerAccess) {
+		this.transactionManagerAccess = transactionManagerAccess;
+	}
+
+	@Override
+	public void registerSynchronization(Synchronization synchronization) {
+		try {
+			transactionManagerAccess.getTransactionManager().getTransaction().registerSynchronization( synchronization );
+		}
+		catch (Exception e) {
+			throw new JtaPlatformException( "Could not access JTA Transaction to register synchronization", e );
+		}
+	}
+
+	@Override
+	public boolean canRegisterSynchronization() {
+		return JtaStatusHelper.isActive( transactionManagerAccess.getTransactionManager() );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java
new file mode 100644
index 0000000000..5d90ea8368
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java
@@ -0,0 +1,67 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.transaction.TransactionManagerLookup;
+
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.util.Properties;
+
+/**
+ * @author Steve Ebersole
+ */
+public class TransactionManagerLookupBridge extends AbstractJtaPlatform {
+	private final TransactionManagerLookup lookup;
+	private final Properties jndiProperties;
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	public TransactionManagerLookupBridge(TransactionManagerLookup lookup, Properties jndiProperties) {
+		this.lookup = lookup;
+		this.jndiProperties = jndiProperties;
+	}
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return lookup.getTransactionManager( jndiProperties );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) serviceRegistry().getService( JndiService.class ).locate( lookup.getUserTransactionName() );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+
+	@Override
+	public Object getTransactionIdentifier(Transaction transaction) {
+		return lookup.getTransactionIdentifier( transaction );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/WebSphereExtendedJTATransactionLookup.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java
old mode 100755
new mode 100644
similarity index 73%
rename from hibernate-core/src/main/java/org/hibernate/transaction/WebSphereExtendedJTATransactionLookup.java
rename to hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java
index 300ae58a06..3449efbd0b
--- a/hibernate-core/src/main/java/org/hibernate/transaction/WebSphereExtendedJTATransactionLookup.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java
@@ -1,304 +1,262 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.transaction;
+package org.hibernate.service.jta.platform.internal;
 
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.Properties;
+import org.hibernate.HibernateException;
 
-import javax.naming.NamingException;
 import javax.transaction.NotSupportedException;
 import javax.transaction.RollbackException;
 import javax.transaction.Status;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
 import javax.transaction.xa.XAResource;
-
-import org.hibernate.HibernateException;
-import org.hibernate.internal.util.jndi.JndiHelper;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
 
 /**
- * TransactionManagerLookup implementation intended for use with WebSphere
- * Application Server (WAS).
+ * JTA platform implementation intended for use with WebSphere Application Server (WAS).
  * <p/>
- * WAS, unlike every other app server on the planet, does not allow direct
- * access to the JTS TransactionManager.  Instead, for common transaction-
- * related tasks users must utilize a proprietary API known as
- * ExtendedJTATransaction.
+ * WAS, unlike every other app server on the planet, does not allow direct access to the JTS TransactionManager.
+ * Instead, for common transaction-related tasks users must utilize a proprietary API known as ExtendedJTATransaction.
  * <p/>
- * Even more unfortunate, the exact TransactionManagerLookup to use inside of
- * WAS is highly dependent upon (1) WAS version as well as (2) the WAS
- * container in which Hibernate will be utilized.
+ * Even more unfortunate, the exact TransactionManagerLookup to use inside of WAS is highly dependent upon<ul>
+ *     <li>WAS version</li>
+ *     <li>the WAS container in which Hibernate will be utilized</li>
+ * </ul>
  * <p/>
- * WebSphereExtendedJTATransactionLookup is reported to work on WAS version 6
- * in any of the standard J2EE/JEE component containers.
+ * This class is reported to work on WAS version 6 in any of the standard J2EE/JEE component containers.
  *
  * @author Gavin King
  * @author <a href="mailto:jesper@udby.com>Jesper Udby</a>
+ * @author Steve Ebersole
  */
-public class WebSphereExtendedJTATransactionLookup implements TransactionManagerLookup {
+public class WebSphereExtendedJtaPlatform extends AbstractJtaPlatform {
+	public static final String UT_NAME = "java:comp/UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) {
-		return new TransactionManagerAdapter( props );
+	@Override
+	protected boolean canCacheTransactionManager() {
+		return true;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return new TransactionManagerAdapter();
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public Object getTransactionIdentifier(Transaction transaction) {
 		// WebSphere, however, is not a sane JEE/JTA container...
 		return Integer.valueOf( transaction.hashCode() );
 	}
 
-	public static class TransactionManagerAdapter implements TransactionManager {
-		private final Properties properties;
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+
+	public class TransactionManagerAdapter implements TransactionManager {
 		private final Class synchronizationCallbackClass;
 		private final Method registerSynchronizationMethod;
 		private final Method getLocalIdMethod;
 		private Object extendedJTATransaction;
 
-		private TransactionManagerAdapter(Properties props) throws HibernateException {
-			this.properties = props;
+		private TransactionManagerAdapter() throws HibernateException {
 			try {
 				synchronizationCallbackClass = Class.forName( "com.ibm.websphere.jtaextensions.SynchronizationCallback" );
 				Class extendedJTATransactionClass = Class.forName( "com.ibm.websphere.jtaextensions.ExtendedJTATransaction" );
 				registerSynchronizationMethod = extendedJTATransactionClass.getMethod(
 						"registerSynchronizationCallbackForCurrentTran",
 						new Class[] { synchronizationCallbackClass }
 				);
 				getLocalIdMethod = extendedJTATransactionClass.getMethod( "getLocalId", (Class[]) null );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				throw new HibernateException( cnfe );
 			}
 			catch ( NoSuchMethodException nsme ) {
 				throw new HibernateException( nsme );
 			}
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void begin() throws NotSupportedException, SystemException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void commit() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public int getStatus() throws SystemException {
 			return getTransaction() == null ? Status.STATUS_NO_TRANSACTION : getTransaction().getStatus();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public Transaction getTransaction() throws SystemException {
-			return new TransactionAdapter( properties );
+			return new TransactionAdapter();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void resume(Transaction txn) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void rollback() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void setRollbackOnly() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public void setTransactionTimeout(int i) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
-		/**
-		 * {@inheritDoc}
-		 */
+		@Override
 		public Transaction suspend() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		public class TransactionAdapter implements Transaction {
 
-			private TransactionAdapter(Properties props) {
-				try {
-					if ( extendedJTATransaction == null ) {
-						extendedJTATransaction = JndiHelper.getInitialContext( props )
-								.lookup( "java:comp/websphere/ExtendedJTATransaction" );
-					}
-				}
-				catch (NamingException ne) {
-					throw new HibernateException(ne);
+			private TransactionAdapter() {
+				if ( extendedJTATransaction == null ) {
+					extendedJTATransaction = jndiService().locate( "java:comp/websphere/ExtendedJTATransaction" );
 				}
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public void registerSynchronization(final Synchronization synchronization)
 					throws RollbackException, IllegalStateException,
 					SystemException {
 
 				final InvocationHandler ih = new InvocationHandler() {
 
+					@Override
 					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 						if ( "afterCompletion".equals( method.getName() ) ) {
 							int status = args[2].equals(Boolean.TRUE) ?
 									Status.STATUS_COMMITTED :
 									Status.STATUS_UNKNOWN;
 							synchronization.afterCompletion(status);
 						}
 						else if ( "beforeCompletion".equals( method.getName() ) ) {
 							synchronization.beforeCompletion();
 						}
 						else if ( "toString".equals( method.getName() ) ) {
 							return synchronization.toString();
 						}
 						return null;
 					}
 
 				};
 
 				final Object synchronizationCallback = Proxy.newProxyInstance(
 						getClass().getClassLoader(),
-						new Class[] { synchronizationCallbackClass },
+						new Class[] {synchronizationCallbackClass},
 						ih
-					);
+				);
 
 				try {
 					registerSynchronizationMethod.invoke( extendedJTATransaction, synchronizationCallback );
 				}
 				catch (Exception e) {
 					throw new HibernateException(e);
 				}
 
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public int hashCode() {
 				return getLocalId().hashCode();
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public boolean equals(Object other) {
 				if ( !(other instanceof TransactionAdapter) ) return false;
 				TransactionAdapter that = (TransactionAdapter) other;
 				return getLocalId().equals( that.getLocalId() );
 			}
 
 			private Object getLocalId() throws HibernateException {
 				try {
 					return getLocalIdMethod.invoke( extendedJTATransaction, (Object[]) null );
 				}
 				catch ( Exception e ) {
 					throw new HibernateException( e );
 				}
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public void commit() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public boolean delistResource(XAResource resource, int i) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public boolean enlistResource(XAResource resource) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public int getStatus() {
 				return new Integer(0).equals( getLocalId() ) ?
 						Status.STATUS_NO_TRANSACTION : Status.STATUS_ACTIVE;
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public void rollback() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
-			/**
-			 * {@inheritDoc}
-			 */
+			@Override
 			public void setRollbackOnly() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 		}
-
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java
new file mode 100644
index 0000000000..3d53f3590c
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java
@@ -0,0 +1,103 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+import java.lang.reflect.Method;
+
+/**
+ * JTA platform implementation for WebSphere (versions 4, 5.0 and 5.1)
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class WebSphereJtaPlatform extends AbstractJtaPlatform {
+	private static final Logger log = LoggerFactory.getLogger( WebSphereJtaPlatform.class );
+
+	public static final String VERSION_5_UT_NAME = "java:comp/UserTransaction";
+	public static final String VERSION_4_UT_NAME = "jta/usertransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	private final Class transactionManagerAccessClass;
+	private final int webSphereVersion;
+
+	public WebSphereJtaPlatform() {
+		try {
+			Class clazz;
+			int version;
+			try {
+				clazz = Class.forName( "com.ibm.ws.Transaction.TransactionManagerFactory" );
+				version = 5;
+				log.debug( "WebSphere 5.1" );
+			}
+			catch ( Exception e ) {
+				try {
+					clazz = Class.forName( "com.ibm.ejs.jts.jta.TransactionManagerFactory" );
+					version = 5;
+					log.debug( "WebSphere 5.0" );
+				}
+				catch ( Exception e2 ) {
+					clazz = Class.forName( "com.ibm.ejs.jts.jta.JTSXA" );
+					version = 4;
+					log.debug( "WebSphere 4" );
+				}
+			}
+
+			transactionManagerAccessClass = clazz;
+			webSphereVersion = version;
+		}
+		catch ( Exception e ) {
+			throw new JtaPlatformException( "Could not locate WebSphere TransactionManager access class", e );
+		}
+	}
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		try {
+			final Method method = transactionManagerAccessClass.getMethod( "getTransactionManager" );
+			return ( TransactionManager ) method.invoke( null );
+		}
+		catch ( Exception e ) {
+			throw new JtaPlatformException( "Could not obtain WebSphere TransactionManager", e );
+		}
+
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		final String utName = webSphereVersion == 5 ? VERSION_5_UT_NAME : VERSION_4_UT_NAME;
+		return (UserTransaction) jndiService().locate( utName );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java
new file mode 100644
index 0000000000..1cbe3a221f
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java
@@ -0,0 +1,55 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.internal;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Weblogic
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class WeblogicJtaPlatform extends AbstractJtaPlatform {
+	public static final String TM_NAME = "javax.transaction.TransactionManager";
+	public static final String UT_NAME = "javax.transaction.UserTransaction";
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return (TransactionManager) jndiService().locate( TM_NAME );
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return (UserTransaction) jndiService().locate( UT_NAME );
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java
index a6e23eb5b0..4f81875f18 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java
@@ -1,74 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jta.platform.spi;
 
 import javax.transaction.Synchronization;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.service.spi.Service;
 
 /**
  * Defines how we interact with various JTA services on the given platform/environment.
  *
  * @author Steve Ebersole
  */
 public interface JtaPlatform extends Service {
 	/**
 	 * A configuration value key used to indicate that it is safe to cache
 	 * {@link TransactionManager} references.
-	 *
-	 * @todo add to Environment.
-	 * @todo same for UserTransaction too?  On many platforms UserTransaction and TransactionManager are the same
 	 */
 	public static final String CACHE_TM = "hibernate.jta.cacheTransactionManager";
+	/**
+	 * A configuration value key used to indicate that it is safe to cache
+	 * {@link UserTransaction} references.
+	 */
+	public static final String CACHE_UT = "hibernate.jta.cacheUserTransaction";
 
 	/**
 	 * Locate the {@link TransactionManager}
 	 *
 	 * @return The {@link TransactionManager}
 	 */
-	public TransactionManager resolveTransactionManager();
+	public TransactionManager retrieveTransactionManager();
 
 	/**
 	 * Locate the {@link UserTransaction}
 	 *
 	 * @return The {@link UserTransaction}
 	 */
-	public UserTransaction resolveUserTransaction();
+	public UserTransaction retrieveUserTransaction();
+
+	/**
+	 * Determine an identifier for the given transaction appropriate for use in caching/lookup usages.
+	 * <p/>
+	 * Generally speaking the transaction itself will be returned here.  This method was added specifically
+	 * for use in WebSphere and other unfriendly JEE containers (although WebSphere is still the only known
+	 * such brain-dead, sales-driven impl).
+	 *
+	 * @param transaction The transaction to be identified.
+	 * @return An appropriate identifier
+	 */
+	public Object getTransactionIdentifier(Transaction transaction);
+
+	/**
+	 * Can we currently register a {@link Synchronization}?
+	 *
+	 * @return True if registering a {@link Synchronization} is currently allowed; false otherwise.
+	 */
+	public boolean canRegisterSynchronization();
 
 	/**
 	 * Register a JTA {@link Synchronization} in the means defined by the platform.
 	 *
 	 * @param synchronization The synchronization to register
 	 */
 	public void registerSynchronization(Synchronization synchronization);
 
 	/**
-	 * Can we currently regsiter a {@link Synchronization}?
+	 * Obtain the current transaction status using whatever means is preferred for this platform
+	 *
+	 * @return The current status.
 	 *
-	 * @return True if regsitering a {@link Synchronization} is currently allowed; false otherwise.
+	 * @throws SystemException Indicates a problem access the underlying status
 	 */
-	public boolean canRegisterSynchronization();
+	public int getCurrentStatus() throws SystemException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java
new file mode 100644
index 0000000000..abc7f31d79
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java
@@ -0,0 +1,41 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.service.jta.platform.spi;
+
+import org.hibernate.HibernateException;
+
+/**
+ * Indicates a problem interacting with the underlying JTA platform.
+ *
+ * @author Steve Ebersole
+ */
+public class JtaPlatformException extends HibernateException {
+	public JtaPlatformException(String s) {
+		super( s );
+	}
+
+	public JtaPlatformException(String string, Throwable root) {
+		super( string, root );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/Service.java b/hibernate-core/src/main/java/org/hibernate/service/spi/Service.java
index 134f3e5836..796e1afd83 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/Service.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/Service.java
@@ -1,32 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
+import java.io.Serializable;
+
 /**
  * Marker interface for services.
+ * <p/>
+ * NOTE : All services must be {@link Serializable}!
  *
  * @author Steve Ebersole
  */
-public interface Service {
+public interface Service extends Serializable {
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/StandardServiceInitiators.java b/hibernate-core/src/main/java/org/hibernate/service/spi/StandardServiceInitiators.java
index 06ea81e9e7..a6b8a545e7 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/StandardServiceInitiators.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/StandardServiceInitiators.java
@@ -1,61 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
+import org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator;
 import org.hibernate.engine.jdbc.internal.JdbcServicesInitiator;
+import org.hibernate.engine.transaction.internal.TransactionFactoryInitiator;
 import org.hibernate.service.classloading.internal.ClassLoaderServiceInitiator;
 import org.hibernate.service.jdbc.connections.internal.ConnectionProviderInitiator;
 import org.hibernate.service.jdbc.dialect.internal.DialectFactoryInitiator;
 import org.hibernate.service.jdbc.dialect.internal.DialectResolverInitiator;
 import org.hibernate.service.jmx.internal.JmxServiceInitiator;
 import org.hibernate.service.jndi.internal.JndiServiceInitiator;
 import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Steve Ebersole
  */
 public class StandardServiceInitiators {
 	public static List<ServiceInitiator> LIST = buildStandardServiceInitiatorList();
 
 	private static List<ServiceInitiator> buildStandardServiceInitiatorList() {
 		final List<ServiceInitiator> serviceInitiators = new ArrayList<ServiceInitiator>();
 
 		serviceInitiators.add( ClassLoaderServiceInitiator.INSTANCE );
 		serviceInitiators.add( JndiServiceInitiator.INSTANCE );
 		serviceInitiators.add( JmxServiceInitiator.INSTANCE );
 
 		serviceInitiators.add( ConnectionProviderInitiator.INSTANCE );
 		serviceInitiators.add( DialectResolverInitiator.INSTANCE );
 		serviceInitiators.add( DialectFactoryInitiator.INSTANCE );
+		serviceInitiators.add( BatchBuilderInitiator.INSTANCE );
 		serviceInitiators.add( JdbcServicesInitiator.INSTANCE );
 
 		serviceInitiators.add( JtaPlatformInitiator.INSTANCE );
-		//serviceInitiators.add( TransactionFactoryInitiator.INSTANCE );
+		serviceInitiators.add( TransactionFactoryInitiator.INSTANCE );
 
 		return serviceInitiators;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/BESTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/BESTransactionManagerLookup.java
deleted file mode 100644
index 0d1e235f5d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/BESTransactionManagerLookup.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-/**
- * A <tt>TransactionManager</tt> lookup strategy for Borland ES.
- *
- * @author Etienne Hardy
- */
-public final class BESTransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	protected String getName() {
-		return "java:pm/TransactionManager";
-	}
-
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-
-}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/CMTTransaction.java b/hibernate-core/src/main/java/org/hibernate/transaction/CMTTransaction.java
deleted file mode 100755
index ab56daed6d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/CMTTransaction.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import javax.transaction.Status;
-import javax.transaction.Synchronization;
-import javax.transaction.SystemException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.util.JTAHelper;
-
-/**
- * Implements a basic transaction strategy for CMT transactions. All work is
- * done in the context of the container managed transaction.
- * <p/>
- * The term 'CMT' is potentially misleading here; the pertinent point simply
- * being that the transactions are being managed by something other than the
- * Hibernate transaction mechanism.
- *
- * @author Gavin King
- */
-public class CMTTransaction implements Transaction {
-
-	private static final Logger log = LoggerFactory.getLogger(CMTTransaction.class);
-
-	protected final JDBCContext jdbcContext;
-	protected final TransactionFactory.Context transactionContext;
-
-	private boolean begun;
-
-	public CMTTransaction(JDBCContext jdbcContext, TransactionFactory.Context transactionContext) {
-		this.jdbcContext = jdbcContext;
-		this.transactionContext = transactionContext;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void begin() throws HibernateException {
-		if (begun) {
-			return;
-		}
-
-		log.debug("begin");
-		
-		boolean synchronization = jdbcContext.registerSynchronizationIfPossible();
-
-		if ( !synchronization ) {
-			throw new TransactionException("Could not register synchronization for container transaction");
-		}
-
-		begun = true;
-		
-		jdbcContext.afterTransactionBegin(this);
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void commit() throws HibernateException {
-		if (!begun) {
-			throw new TransactionException("Transaction not successfully started");
-		}
-
-		log.debug("commit");
-
-		boolean flush = !transactionContext.isFlushModeNever() &&
-		        !transactionContext.isFlushBeforeCompletionEnabled();
-
-		if (flush) {
-			transactionContext.managedFlush(); //if an exception occurs during flush, user must call rollback()
-		}
-
-		begun = false;
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void rollback() throws HibernateException {
-		if (!begun) {
-			throw new TransactionException("Transaction not successfully started");
-		}
-
-		log.debug("rollback");
-
-		try {
-			getTransaction().setRollbackOnly();
-		}
-		catch (SystemException se) {
-			log.error("Could not set transaction to rollback only", se);
-			throw new TransactionException("Could not set transaction to rollback only", se);
-		}
-
-		begun = false;
-
-	}
-
-	/**
-	 * Getter for property 'transaction'.
-	 *
-	 * @return Value for property 'transaction'.
-	 */
-	public javax.transaction.Transaction getTransaction() throws SystemException {
-		return transactionContext.getFactory().getTransactionManager().getTransaction();
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isActive() throws TransactionException {
-
-		if (!begun) return false;
-
-		final int status;
-		try {
-			status = getTransaction().getStatus();
-		}
-		catch (SystemException se) {
-			log.error("Could not determine transaction status", se);
-			throw new TransactionException("Could not determine transaction status: ", se);
-		}
-		if (status==Status.STATUS_UNKNOWN) {
-			throw new TransactionException("Could not determine transaction status");
-		}
-		else {
-			return status==Status.STATUS_ACTIVE;
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasRolledBack() throws TransactionException {
-
-		if (!begun) return false;
-
-		final int status;
-		try {
-			status = getTransaction().getStatus();
-		}
-		catch (SystemException se) {
-			log.error("Could not determine transaction status", se);
-			throw new TransactionException("Could not determine transaction status", se);
-		}
-		if (status==Status.STATUS_UNKNOWN) {
-			throw new TransactionException("Could not determine transaction status");
-		}
-		else {
-			return JTAHelper.isRollback(status);
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasCommitted() throws TransactionException {
-
-		if ( !begun ) return false;
-
-		final int status;
-		try {
-			status = getTransaction().getStatus();
-		}
-		catch (SystemException se) {
-			log.error("Could not determine transaction status", se);
-			throw new TransactionException("Could not determine transaction status: ", se);
-		}
-		if (status==Status.STATUS_UNKNOWN) {
-			throw new TransactionException("Could not determine transaction status");
-		}
-		else {
-			return status==Status.STATUS_COMMITTED;
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void registerSynchronization(Synchronization sync) throws HibernateException {
-		try {
-			getTransaction().registerSynchronization(sync);
-		}
-		catch (Exception e) {
-			throw new TransactionException("Could not register synchronization", e);
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void setTimeout(int seconds) {
-		throw new UnsupportedOperationException("cannot set transaction timeout in CMT");
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/CacheSynchronization.java b/hibernate-core/src/main/java/org/hibernate/transaction/CacheSynchronization.java
deleted file mode 100644
index 885443f9f3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/CacheSynchronization.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import javax.transaction.Status;
-import javax.transaction.Synchronization;
-import javax.transaction.SystemException;
-import javax.transaction.Transaction;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.util.JTAHelper;
-
-/**
- * A JTA transaction synch used to allow the {@link org.hibernate.Session} to know about transaction
- * events.
- *
- * @author Gavin King
- */
-public final class CacheSynchronization implements Synchronization {
-
-	private static final Logger log = LoggerFactory.getLogger(CacheSynchronization.class);
-
-	private final TransactionFactory.Context ctx;
-	private JDBCContext jdbcContext;
-	private final Transaction transaction;
-	private final org.hibernate.Transaction hibernateTransaction;
-
-	public CacheSynchronization(
-			TransactionFactory.Context ctx, 
-			JDBCContext jdbcContext,
-			Transaction transaction, 
-			org.hibernate.Transaction tx) {
-		this.ctx = ctx;
-		this.jdbcContext = jdbcContext;
-		this.transaction = transaction;
-		this.hibernateTransaction = tx;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void beforeCompletion() {
-		log.trace("transaction before completion callback");
-
-		boolean flush;
-		try {
-			flush = !ctx.isFlushModeNever() &&
-			        ctx.isFlushBeforeCompletionEnabled() && 
-			        !JTAHelper.isRollback( transaction.getStatus() ); 
-					//actually, this last test is probably unnecessary, since 
-					//beforeCompletion() doesn't get called during rollback
-		}
-		catch (SystemException se) {
-			log.error("could not determine transaction status", se);
-			setRollbackOnly();
-			throw new TransactionException("could not determine transaction status in beforeCompletion()", se);
-		}
-		
-		try {
-			if (flush) {
-				log.trace("automatically flushing session");
-				ctx.managedFlush();
-			}
-		}
-		catch (RuntimeException re) {
-			setRollbackOnly();
-			throw re;
-		}
-		finally {
-			jdbcContext.beforeTransactionCompletion(hibernateTransaction);
-		}
-	}
-
-	private void setRollbackOnly() {
-		try {
-			transaction.setRollbackOnly();
-		}
-		catch (SystemException se) {
-			log.error("could not set transaction to rollback only", se);
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void afterCompletion(int status) {
-		if ( log.isTraceEnabled() ) {
-			log.trace("transaction after completion callback, status: " + status);
-		}
-		try {
-			jdbcContext.afterTransactionCompletion(status==Status.STATUS_COMMITTED, hibernateTransaction);
-		}
-		finally {
-			if ( ctx.shouldAutoClose() && !ctx.isClosed() ) {
-				log.trace("automatically closing session");
-				ctx.managedClose();
-			}
-		}
-	}
-	
-	/**
-	 * {@inheritDoc}
-	 */
-	public String toString() {
-		return CacheSynchronization.class.getName();
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JBossTSStandaloneTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/JBossTSStandaloneTransactionManagerLookup.java
deleted file mode 100644
index 380e10bf5e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JBossTSStandaloneTransactionManagerLookup.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.lang.reflect.Method;
-import java.util.Properties;
-import javax.transaction.Transaction;
-import javax.transaction.TransactionManager;
-
-import org.hibernate.HibernateException;
-
-/**
- * Return a standalone JTA transaction manager for JBoss Transactions
- * Known to work for org.jboss.jbossts:jbossjta:4.11.0.Final
- *
- * @author Emmanuel Bernard
- */
-public class JBossTSStandaloneTransactionManagerLookup implements TransactionManagerLookup {
-
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		try {
-			//Call jtaPropertyManager.getJTAEnvironmentBean().getTransactionManager();
-
-			//improper camel case name for the class
-			Class<?> propertyManager = Class.forName( "com.arjuna.ats.jta.common.jtaPropertyManager" );
-			final Method getJTAEnvironmentBean = propertyManager.getMethod( "getJTAEnvironmentBean" );
-			//static method
-			final Object jtaEnvironmentBean = getJTAEnvironmentBean.invoke( null );
-			final Method getTransactionManager = jtaEnvironmentBean.getClass().getMethod( "getTransactionManager" );
-			return ( TransactionManager ) getTransactionManager.invoke( jtaEnvironmentBean );
-		}
-		catch ( Exception e ) {
-			throw new HibernateException( "Could not obtain JBoss Transactions transaction manager instance", e );
-		}
-	}
-
-	public String getUserTransactionName() {
-		return null;
-	}
-
-	public Object getTransactionIdentifier(Transaction transaction) {
-		return transaction;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransaction.java b/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransaction.java
deleted file mode 100644
index f89813b646..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransaction.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.transaction;
-
-import java.sql.SQLException;
-import javax.transaction.Status;
-import javax.transaction.Synchronization;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.engine.transaction.SynchronizationRegistry;
-
-/**
- * {@link Transaction} implementation based on transaction management through a JDBC {@link java.sql.Connection}.
- * <p/>
- * This the Hibernate's default transaction strategy.
- *
- * @author Anton van Straaten
- * @author Gavin King
- */
-public class JDBCTransaction implements Transaction {
-	private static final Logger log = LoggerFactory.getLogger(JDBCTransaction.class);
-
-	private final SynchronizationRegistry synchronizationRegistry = new SynchronizationRegistry();
-	private final JDBCContext jdbcContext;
-	private final TransactionFactory.Context transactionContext;
-
-	private boolean toggleAutoCommit;
-	private boolean begun;
-	private boolean rolledBack;
-	private boolean committed;
-	private boolean commitFailed;
-	private boolean callback;
-	private int timeout = -1;
-
-	public JDBCTransaction(JDBCContext jdbcContext, TransactionFactory.Context transactionContext) {
-		this.jdbcContext = jdbcContext;
-		this.transactionContext = transactionContext;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void begin() throws HibernateException {
-		if (begun) {
-			return;
-		}
-		if (commitFailed) {
-			throw new TransactionException("cannot re-start transaction after failed commit");
-		}
-
-		log.debug("begin");
-
-		try {
-			toggleAutoCommit = jdbcContext.connection().getAutoCommit();
-			if ( log.isDebugEnabled() ) {
-				log.debug("current autocommit status: " + toggleAutoCommit);
-			}
-			if (toggleAutoCommit) {
-				log.debug("disabling autocommit");
-				jdbcContext.connection().setAutoCommit(false);
-			}
-		}
-		catch (SQLException e) {
-			log.error("JDBC begin failed", e);
-			throw new TransactionException("JDBC begin failed: ", e);
-		}
-
-		callback = jdbcContext.registerCallbackIfNecessary();
-
-		begun = true;
-		committed = false;
-		rolledBack = false;
-
-		if ( timeout>0 ) {
-			jdbcContext.getConnectionManager()
-					.setTransactionTimeout(timeout);
-		}
-
-		jdbcContext.afterTransactionBegin(this);
-	}
-
-	private void closeIfRequired() throws HibernateException {
-		if ( callback && transactionContext.shouldAutoClose() && !transactionContext.isClosed() ) {
-			try {
-				transactionContext.managedClose();
-			}
-			catch (HibernateException he) {
-				log.error("Could not close session", he);
-				//swallow, the transaction was finished
-			}
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void commit() throws HibernateException {
-		if (!begun) {
-			throw new TransactionException("Transaction not successfully started");
-		}
-
-		log.debug("commit");
-
-		if ( !transactionContext.isFlushModeNever() && callback ) {
-			transactionContext.managedFlush(); //if an exception occurs during flush, user must call rollback()
-		}
-
-		notifySynchronizationsBeforeTransactionCompletion();
-		if ( callback ) {
-			jdbcContext.beforeTransactionCompletion( this );
-		}
-
-		try {
-			commitAndResetAutoCommit();
-			log.debug("committed JDBC Connection");
-			committed = true;
-			if ( callback ) {
-				jdbcContext.afterTransactionCompletion( true, this );
-			}
-			notifySynchronizationsAfterTransactionCompletion( Status.STATUS_COMMITTED );
-		}
-		catch (SQLException e) {
-			log.error("JDBC commit failed", e);
-			commitFailed = true;
-			if ( callback ) {
-				jdbcContext.afterTransactionCompletion( false, this );
-			}
-			notifySynchronizationsAfterTransactionCompletion( Status.STATUS_UNKNOWN );
-			throw new TransactionException("JDBC commit failed", e);
-		}
-		finally {
-			closeIfRequired();
-		}
-	}
-
-	private void commitAndResetAutoCommit() throws SQLException {
-		try {
-			jdbcContext.connection().commit();
-		}
-		finally {
-			toggleAutoCommit();
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void rollback() throws HibernateException {
-
-		if (!begun && !commitFailed) {
-			throw new TransactionException("Transaction not successfully started");
-		}
-
-		log.debug("rollback");
-
-		if (!commitFailed) {
-
-			/*notifyLocalSynchsBeforeTransactionCompletion();
-			if ( callback ) {
-				jdbcContext.notifyLocalSynchsBeforeTransactionCompletion( this );
-			}*/
-
-			try {
-				rollbackAndResetAutoCommit();
-				log.debug("rolled back JDBC Connection");
-				rolledBack = true;
-				notifySynchronizationsAfterTransactionCompletion(Status.STATUS_ROLLEDBACK);
-			}
-			catch (SQLException e) {
-				log.error("JDBC rollback failed", e);
-				notifySynchronizationsAfterTransactionCompletion(Status.STATUS_UNKNOWN);
-				throw new TransactionException("JDBC rollback failed", e);
-			}
-			finally {
-				if ( callback ) {
-					jdbcContext.afterTransactionCompletion( false, this );
-				}
-				closeIfRequired();
-			}
-		}
-	}
-
-	private void rollbackAndResetAutoCommit() throws SQLException {
-		try {
-			jdbcContext.connection().rollback();
-		}
-		finally {
-			toggleAutoCommit();
-		}
-	}
-
-	private void toggleAutoCommit() {
-		try {
-			if (toggleAutoCommit) {
-				log.debug("re-enabling autocommit");
-				jdbcContext.connection().setAutoCommit( true );
-			}
-		}
-		catch (Exception sqle) {
-			log.error("Could not toggle autocommit", sqle);
-			//swallow it (the transaction _was_ successful or successfully rolled back)
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasRolledBack() {
-		return rolledBack;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasCommitted() {
-		return committed;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isActive() {
-		return begun && ! ( rolledBack || committed | commitFailed );
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void registerSynchronization(Synchronization sync) {
-		synchronizationRegistry.registerSynchronization( sync );
-	}
-
-	private void notifySynchronizationsBeforeTransactionCompletion() {
-		synchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();
-	}
-
-	private void notifySynchronizationsAfterTransactionCompletion(int status) {
-		begun = false;
-		synchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( status );
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void setTimeout(int seconds) {
-		timeout = seconds;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransactionFactory.java
deleted file mode 100644
index a0f6136550..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JDBCTransactionFactory.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-
-/**
- * Factory for {@link JDBCTransaction} instances.
- *
- * @author Anton van Straaten
- */
-public final class JDBCTransactionFactory implements TransactionFactory {
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public ConnectionReleaseMode getDefaultReleaseMode() {
-		return ConnectionReleaseMode.AFTER_TRANSACTION;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Transaction createTransaction(JDBCContext jdbcContext, Context transactionContext)
-	throws HibernateException {
-		return new JDBCTransaction( jdbcContext, transactionContext );
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void configure(Properties props) throws HibernateException {}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isTransactionManagerRequired() {
-		return false;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean areCallbacksLocalToHibernateTransactions() {
-		return true;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isTransactionInProgress(
-			JDBCContext jdbcContext,
-	        Context transactionContext,
-	        Transaction transaction) {
-//		try {
-//			// for JDBC-based transactions, we only want to return true
-//			// here if we (this transaction) are managing the transaction
-//			return transaction != null &&
-//			       transaction.isActive() &&
-//			       !jdbcContext.getConnectionManager().isAutoCommit();
-//		}
-//		catch ( SQLException e ) {
-//			// assume we are in auto-commit!
-//			return false;
-//		}
-		return transaction != null && transaction.isActive();
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JNDITransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/JNDITransactionManagerLookup.java
deleted file mode 100644
index 78b0a71bfc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JNDITransactionManagerLookup.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import javax.naming.NamingException;
-import javax.transaction.TransactionManager;
-import javax.transaction.Transaction;
-
-import org.hibernate.HibernateException;
-import org.hibernate.internal.util.jndi.JndiHelper;
-
-/**
- * Template implementation of {@link TransactionManagerLookup} where the
- * underlying {@link TransactionManager} is available via JNDI lookup at the
- * specified location - {@link #getName}.
- *
- * @author Gavin King
- */
-public abstract class JNDITransactionManagerLookup implements TransactionManagerLookup {
-
-	/**
-	 * Get the JNDI namespace under wich we can locate the {@link TransactionManager}.
-	 *
-	 * @return The {@link TransactionManager} JNDI namespace
-	 */
-	protected abstract String getName();
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		try {
-			return (TransactionManager) JndiHelper.getInitialContext(props).lookup( getName() );
-		}
-		catch (NamingException ne) {
-			throw new HibernateException( "Could not locate TransactionManager", ne );
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Object getTransactionIdentifier(Transaction transaction) {
-		// for sane JEE/JTA containers, the transaction itself functions as its identifier...
-		return transaction;
-	}
-}
-
-
-
-
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JTATransaction.java b/hibernate-core/src/main/java/org/hibernate/transaction/JTATransaction.java
deleted file mode 100644
index 856362414e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JTATransaction.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import javax.transaction.Status;
-import javax.transaction.Synchronization;
-import javax.transaction.SystemException;
-import javax.transaction.TransactionManager;
-import javax.transaction.UserTransaction;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.util.JTAHelper;
-
-/**
- * {@link Transaction} implementation based on transaction management through
- * a JTA {@link UserTransaction}.  Similar to {@link CMTTransaction}, except
- * here we are actually managing the transactions through the Hibernate
- * transaction mechanism.
- *
- * @author Gavin King
- * @author Steve Ebersole
- * @author Les Hazlewood
- */
-public class JTATransaction implements Transaction {
-
-	private static final Logger log = LoggerFactory.getLogger( JTATransaction.class );
-
-	private final JDBCContext jdbcContext;
-	private final TransactionFactory.Context transactionContext;
-
-	private UserTransaction userTransaction;
-	private boolean newTransaction;
-	private boolean begun;
-	private boolean commitFailed;
-	private boolean commitSucceeded;
-	private boolean callback;
-
-	public JTATransaction(
-			UserTransaction userTransaction,
-			JDBCContext jdbcContext,
-			TransactionFactory.Context transactionContext) {
-		this.jdbcContext = jdbcContext;
-		this.transactionContext = transactionContext;
-		this.userTransaction = userTransaction;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void begin() throws HibernateException {
-		if ( begun ) {
-			return;
-		}
-		if ( commitFailed ) {
-			throw new TransactionException( "cannot re-start transaction after failed commit" );
-		}
-
-		log.debug( "begin" );
-
-		try {
-			newTransaction = userTransaction.getStatus() == Status.STATUS_NO_TRANSACTION;
-			if ( newTransaction ) {
-				userTransaction.begin();
-				log.debug( "Began a new JTA transaction" );
-			}
-		}
-		catch ( Exception e ) {
-			log.error( "JTA transaction begin failed", e );
-			throw new TransactionException( "JTA transaction begin failed", e );
-		}
-
-		/*if (newTransaction) {
-			// don't need a synchronization since we are committing
-			// or rolling back the transaction ourselves - assuming
-			// that we do no work in beforeTransactionCompletion()
-			synchronization = false;
-		}*/
-
-		boolean synchronization = jdbcContext.registerSynchronizationIfPossible();
-
-		if ( !newTransaction && !synchronization ) {
-			log.warn( "You should set hibernate.transaction.manager_lookup_class if cache is enabled" );
-		}
-
-		if ( !synchronization ) {
-			//if we could not register a synchronization,
-			//do the before/after completion callbacks
-			//ourself (but we need to let jdbcContext
-			//know that this is what we are going to
-			//do, so it doesn't keep trying to register
-			//synchronizations)
-			callback = jdbcContext.registerCallbackIfNecessary();
-		}
-
-		begun = true;
-		commitSucceeded = false;
-
-		jdbcContext.afterTransactionBegin( this );
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void commit() throws HibernateException {
-		if ( !begun ) {
-			throw new TransactionException( "Transaction not successfully started" );
-		}
-
-		log.debug( "commit" );
-
-		boolean flush = !transactionContext.isFlushModeNever()
-				&& ( callback || !transactionContext.isFlushBeforeCompletionEnabled() );
-
-		if ( flush ) {
-			transactionContext.managedFlush(); //if an exception occurs during flush, user must call rollback()
-		}
-
-		if ( callback && newTransaction ) {
-			jdbcContext.beforeTransactionCompletion( this );
-		}
-
-		closeIfRequired();
-
-		if ( newTransaction ) {
-			try {
-				userTransaction.commit();
-				commitSucceeded = true;
-				log.debug( "Committed JTA UserTransaction" );
-			}
-			catch ( Exception e ) {
-				commitFailed = true; // so the transaction is already rolled back, by JTA spec
-				log.error( "JTA commit failed", e );
-				throw new TransactionException( "JTA commit failed: ", e );
-			}
-			finally {
-				afterCommitRollback();
-			}
-		}
-		else {
-			// this one only really needed for badly-behaved applications!
-			// (if the TransactionManager has a Sychronization registered,
-			// its a noop)
-			// (actually we do need it for downgrading locks)
-			afterCommitRollback();
-		}
-
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void rollback() throws HibernateException {
-		if ( !begun && !commitFailed ) {
-			throw new TransactionException( "Transaction not successfully started" );
-		}
-
-		log.debug( "rollback" );
-
-		try {
-			closeIfRequired();
-		}
-		catch ( Exception e ) {
-			// swallow it, and continue to roll back JTA transaction
-			log.error( "could not close session during rollback", e );
-		}
-
-		try {
-			if ( newTransaction ) {
-				if ( !commitFailed ) {
-					userTransaction.rollback();
-					log.debug( "Rolled back JTA UserTransaction" );
-				}
-			}
-			else {
-				userTransaction.setRollbackOnly();
-				log.debug( "set JTA UserTransaction to rollback only" );
-			}
-		}
-		catch ( Exception e ) {
-			log.error( "JTA rollback failed", e );
-			throw new TransactionException( "JTA rollback failed", e );
-		}
-		finally {
-			afterCommitRollback();
-		}
-	}
-
-	private static final int NULL = Integer.MIN_VALUE;
-
-	private void afterCommitRollback() throws TransactionException {
-
-		begun = false;
-		// this method is a noop if there is a Synchronization!
-		if ( callback ) {
-			if ( !newTransaction ) {
-				log.warn( "You should set hibernate.transaction.manager_lookup_class if cache is enabled" );
-			}
-			int status = NULL;
-			try {
-				status = userTransaction.getStatus();
-			}
-			catch ( Exception e ) {
-				log.error( "Could not determine transaction status after commit", e );
-				throw new TransactionException( "Could not determine transaction status after commit", e );
-			}
-			finally {
-				jdbcContext.afterTransactionCompletion( status == Status.STATUS_COMMITTED, this );
-			}
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasRolledBack() throws TransactionException {
-		final int status;
-		try {
-			status = userTransaction.getStatus();
-		}
-		catch ( SystemException se ) {
-			log.error( "Could not determine transaction status", se );
-			throw new TransactionException( "Could not determine transaction status", se );
-		}
-		if ( status == Status.STATUS_UNKNOWN ) {
-			throw new TransactionException( "Could not determine transaction status" );
-		}
-		else {
-			return JTAHelper.isRollback( status );
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean wasCommitted() throws TransactionException {
-		final int status;
-		try {
-			status = userTransaction.getStatus();
-		}
-		catch ( SystemException se ) {
-			log.error( "Could not determine transaction status", se );
-			throw new TransactionException( "Could not determine transaction status: ", se );
-		}
-		if ( status == Status.STATUS_UNKNOWN ) {
-			throw new TransactionException( "Could not determine transaction status" );
-		}
-		else {
-			return status == Status.STATUS_COMMITTED;
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isActive() throws TransactionException {
-		if ( !begun || commitFailed || commitSucceeded ) {
-			return false;
-		}
-
-		final int status;
-		try {
-			status = userTransaction.getStatus();
-		}
-		catch ( SystemException se ) {
-			log.error( "Could not determine transaction status", se );
-			throw new TransactionException( "Could not determine transaction status: ", se );
-		}
-		if ( status == Status.STATUS_UNKNOWN ) {
-			throw new TransactionException( "Could not determine transaction status" );
-		}
-		else {
-			return status == Status.STATUS_ACTIVE;
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void registerSynchronization(Synchronization sync) throws HibernateException {
-		if ( getTransactionManager() == null ) {
-			throw new IllegalStateException( "JTA TransactionManager not available" );
-		}
-		else {
-			try {
-				getTransactionManager().getTransaction().registerSynchronization( sync );
-			}
-			catch ( Exception e ) {
-				throw new TransactionException( "could not register synchronization", e );
-			}
-		}
-	}
-
-	/**
-	 * Getter for property 'transactionManager'.
-	 *
-	 * @return Value for property 'transactionManager'.
-	 */
-	private TransactionManager getTransactionManager() {
-		return transactionContext.getFactory().getTransactionManager();
-	}
-
-	private void closeIfRequired() throws HibernateException {
-		boolean close = callback &&
-				transactionContext.shouldAutoClose() &&
-				!transactionContext.isClosed();
-		if ( close ) {
-			transactionContext.managedClose();
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public void setTimeout(int seconds) {
-		try {
-			userTransaction.setTransactionTimeout( seconds );
-		}
-		catch ( SystemException se ) {
-			throw new TransactionException( "could not set transaction timeout", se );
-		}
-	}
-
-	/**
-	 * Getter for property 'userTransaction'.
-	 *
-	 * @return Value for property 'userTransaction'.
-	 */
-	protected UserTransaction getUserTransaction() {
-		return userTransaction;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/JTATransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/transaction/JTATransactionFactory.java
deleted file mode 100644
index 82b2713545..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/JTATransactionFactory.java
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import javax.naming.InitialContext;
-import javax.naming.NamingException;
-import javax.transaction.SystemException;
-import javax.transaction.UserTransaction;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.TransactionException;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-import org.hibernate.internal.util.jndi.JndiHelper;
-import org.hibernate.cfg.Environment;
-import org.hibernate.util.JTAHelper;
-
-/**
- * Factory for {@link JTATransaction} instances.
- * <p/>
- * To be completely accurate to the JTA spec, JTA implementations should
- * publish their contextual {@link UserTransaction} reference into JNDI.
- * However, in practice there are quite a few <tt>stand-alone</tt>
- * implementations intended for use outside of J2EE/JEE containers and
- * which therefore do not publish their {@link UserTransaction} references
- * into JNDI but which otherwise follow the aspects of the JTA specification.
- * This {@link TransactionFactory} implementation can support both models.
- * <p/>
- * For complete JTA implementations (including dependence on JNDI), the
- * {@link UserTransaction} reference is obtained by a call to
- * {@link #resolveInitialContext}.  Hibernate will then attempt to locate the
- * {@link UserTransaction} within this resolved
- * {@link InitialContext} based on the namespace returned by
- * {@link #resolveUserTransactionName}.
- * <p/>
- * For the so-called <tt>stand-alone</tt> implementations, we do not care at
- * all about the JNDI aspects just described.  Here, the implementation would
- * have a specific manner to obtain a reference to its contextual
- * {@link UserTransaction}; usually this would be a static code reference, but
- * again it varies.  Anyway, for each implementation the integration would need
- * to override the {@link #getUserTransaction} method and return the appropriate
- * thing.
- *
- * @author Gavin King
- * @author Steve Ebersole
- * @author Les Hazlewood
- */
-public class JTATransactionFactory implements TransactionFactory {
-	public static final String DEFAULT_USER_TRANSACTION_NAME = "java:comp/UserTransaction";
-	private static final Logger log = LoggerFactory.getLogger( JTATransactionFactory.class );
-
-	protected InitialContext initialContext;
-	protected String userTransactionName;
-
-	/**
-	 * Configure this transaction factory.  Specifically here we are attempting to
-	 * resolve both an {@link #getInitialContext InitialContext} as well as the
-	 * {@link #getUserTransactionName() JNDI namespace} for the {@link UserTransaction}.
-	 *
-	 * @param props The configuration properties
-	 *
-	 * @exception HibernateException
-	 */
-	public void configure(Properties props) throws HibernateException {
-		this.initialContext = resolveInitialContext( props );
-		this.userTransactionName = resolveUserTransactionName( props );
-		log.trace( "Configured JTATransactionFactory to use [{}] for UserTransaction JDNI namespace", userTransactionName );
-	}
-
-	/**
-	 * Given the lot of Hibernate configuration properties, resolve appropriate
-	 * reference to JNDI {@link InitialContext}.
-	 * <p/>
-	 * In general, the properties in which we are interested here all begin with
-	 * <tt>hibernate.jndi</tt>.  Especially important depending on your
-	 * environment are {@link Environment#JNDI_URL hibernate.jndi.url} and
-	 *  {@link Environment#JNDI_CLASS hibernate.jndi.class}
-	 *
-	 * @param properties The Hibernate config properties.
-	 * @return The resolved InitialContext.
-	 */
-	protected final InitialContext resolveInitialContext(Properties properties) {
-		try {
-			return JndiHelper.getInitialContext( properties );
-		}
-		catch ( NamingException ne ) {
-			throw new HibernateException( "Could not obtain initial context", ne );
-		}
-	}
-
-	/**
-	 * Given the lot of Hibernate configuration properties, resolve appropriate
-	 * JNDI namespace to use for {@link UserTransaction} resolution.
-	 * <p/>
-	 * We determine the namespace to use by<ol>
-	 * <li>Any specified {@link Environment#USER_TRANSACTION jta.UserTransaction} config property</li>
-	 * <li>If a {@link TransactionManagerLookup} was indicated, use its
-	 * {@link TransactionManagerLookup#getUserTransactionName}</li>
-	 * <li>finally, as a last resort, we use {@link #DEFAULT_USER_TRANSACTION_NAME}</li>
-	 * </ol>
-	 *
-	 * @param properties The Hibernate config properties.
-	 * @return The resolved {@link UserTransaction} namespace
-	 */
-	protected final String resolveUserTransactionName(Properties properties) {
-		String utName = properties.getProperty( Environment.USER_TRANSACTION );
-		if ( utName == null ) {
-			TransactionManagerLookup lookup = TransactionManagerLookupFactory.getTransactionManagerLookup( properties );
-			if ( lookup != null ) {
-				utName = lookup.getUserTransactionName();
-			}
-		}
-		return utName == null ? DEFAULT_USER_TRANSACTION_NAME : utName;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Transaction createTransaction(JDBCContext jdbcContext, Context transactionContext)
-			throws HibernateException {
-		UserTransaction ut = getUserTransaction();
-		return new JTATransaction( ut, jdbcContext, transactionContext );
-	}
-
-	/**
-	 * Get the {@link UserTransaction} reference.
-	 *
-	 * @return The appropriate {@link UserTransaction} reference.
-	 */
-	protected UserTransaction getUserTransaction() {
-		final String utName = getUserTransactionName();
-		log.trace( "Attempting to locate UserTransaction via JNDI [{}]", utName );
-
-		try {
-			UserTransaction ut = ( UserTransaction ) getInitialContext().lookup( utName );
-			if ( ut == null ) {
-				throw new TransactionException( "Naming service lookup for UserTransaction returned null [" + utName +"]" );
-			}
-
-			log.trace( "Obtained UserTransaction" );
-
-			return ut;
-		}
-		catch ( NamingException ne ) {
-			throw new TransactionException( "Could not find UserTransaction in JNDI [" + utName + "]", ne );
-		}
-	}
-
-	/**
-	 * Getter for property 'initialContext'.
-	 *
-	 * @return Value for property 'initialContext'.
-	 */
-	protected InitialContext getInitialContext() {
-		return initialContext;
-	}
-
-	/**
-	 * Getter for property 'userTransactionName'.
-	 * The algorithm here is
-	 *
-	 * @return Value for property 'userTransactionName'.
-	 */
-	protected String getUserTransactionName() {
-		return userTransactionName;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public ConnectionReleaseMode getDefaultReleaseMode() {
-		return ConnectionReleaseMode.AFTER_STATEMENT;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isTransactionManagerRequired() {
-		return false;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean areCallbacksLocalToHibernateTransactions() {
-		return false;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public boolean isTransactionInProgress(
-			JDBCContext jdbcContext,
-			Context transactionContext,
-			Transaction transaction) {
-		try {
-			// Essentially:
-			// 1) If we have a local (Hibernate) transaction in progress
-			//      and it already has the UserTransaction cached, use that
-			//      UserTransaction to determine the status.
-			// 2) If a transaction manager has been located, use
-			//      that transaction manager to determine the status.
-			// 3) Finally, as the last resort, try to lookup the
-			//      UserTransaction via JNDI and use that to determine the
-			//      status.
-			if ( transaction != null ) {
-				UserTransaction ut = ( ( JTATransaction ) transaction ).getUserTransaction();
-				if ( ut != null ) {
-					return JTAHelper.isInProgress( ut.getStatus() );
-				}
-			}
-
-			if ( jdbcContext.getFactory().getTransactionManager() != null ) {
-				return JTAHelper.isInProgress( jdbcContext.getFactory().getTransactionManager().getStatus() );
-			}
-			else {
-				UserTransaction ut = getUserTransaction();
-				return ut != null && JTAHelper.isInProgress( ut.getStatus() );
-			}
-		}
-		catch ( SystemException se ) {
-			throw new TransactionException( "Unable to check transaction status", se );
-		}
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/OC4JTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/OC4JTransactionManagerLookup.java
deleted file mode 100644
index f71e290c82..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/OC4JTransactionManagerLookup.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-/**
- * {@link TransactionManagerLookup} for the OC4J (Oracle) AS.
- * 
- * @author Stijn Janssens
- */
-public class OC4JTransactionManagerLookup extends JNDITransactionManagerLookup {
-	protected String getName() {
-		return "java:comp/pm/TransactionManager";
-	}
-
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/OrionTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/OrionTransactionManagerLookup.java
deleted file mode 100644
index 6960405c77..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/OrionTransactionManagerLookup.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-/**
- * {@link TransactionManagerLookup} strategy for Orion
- *
- * @author Gavin King
- */
-public class OrionTransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	/**
-	 * {@inheritDoc}
-	 */
-	protected String getName() {
-		return "java:comp/UserTransaction";
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-
-}
-
-
-
-
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/ResinTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/ResinTransactionManagerLookup.java
deleted file mode 100644
index c1c157c761..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/ResinTransactionManagerLookup.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-/**
- * {@link TransactionManagerLookup} strategy for Resin
- *
- * @author Aapo Laakkonen
- */
-public class ResinTransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	/**
-	 * {@inheritDoc}
-	 */
-	protected String getName() {
-		return "java:comp/TransactionManager";
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/SunONETransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/SunONETransactionManagerLookup.java
deleted file mode 100644
index 0bfd3283ce..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/SunONETransactionManagerLookup.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-/**
- * {@link TransactionManagerLookup} strategy for Sun ONE Application Server 7 and above
- * 
- * @author Robert Davidson
- * @author Sanjeev Krishnan
- * @author Emmanuel Bernard
- */
-public class SunONETransactionManagerLookup extends JNDITransactionManagerLookup {
-
-	/**
-	 * {@inheritDoc}
-	 */
-	protected String getName() {
-		return "java:appserver/TransactionManager";
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return "java:comp/UserTransaction";
-	}
-	
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactory.java
deleted file mode 100644
index 1f55957649..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactory.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.HibernateException;
-import org.hibernate.Transaction;
-import org.hibernate.engine.SessionFactoryImplementor;
-import org.hibernate.engine.jdbc.spi.JDBCContext;
-
-/**
- * Contract for generating Hibernate {@link Transaction} instances.
- * <p/>
- * The concrete implementation to be used is specified by the
- * {@link org.hibernate.cfg.Environment#TRANSACTION_STRATEGY} configuration
- * setting.
- * <p/>
- * Implementors must be threadsafe and should declare a public default constructor.
- *
- * @see Transaction
- *
- * @author Anton van Straaten
- * @author Gavin King
- */
-public interface TransactionFactory {
-
-	/**
-	 * Callback mechanism; a context is always a {@link org.hibernate.Session}
-	 * in the Hibernate usage.
-	 */
-	public static interface Context {
-		public SessionFactoryImplementor getFactory();
-		public boolean isClosed();
-
-		public boolean isFlushModeNever();
-		public boolean isFlushBeforeCompletionEnabled();
-		public void managedFlush();
-
-		public boolean shouldAutoClose();
-		public void managedClose();
-	}
-
-	/**
-	 * Begin a transaction and return the associated <tt>Transaction</tt> instance.
-	 *
-	 * @param jdbcContext  The jdbc context to which the transaction belongs
-	 * @param context The contract regarding the context in which this transaction will operate.
-	 * @return Transaction
-	 * @throws HibernateException Indicates a problem generating a transaction instance
-	 */
-	public Transaction createTransaction(JDBCContext jdbcContext, Context context) throws HibernateException;
-
-	/**
-	 * Configure from the given properties.
-	 *
-	 * @param props The configuration properties.
-	 * @throws HibernateException Indicates a problem configuring this factory.
-	 */
-	public void configure(Properties props) throws HibernateException;
-	
-	/**
-	 * Get the default connection release mode.
-	 *
-	 * @return The default release mode associated with this strategy
-	 */
-	public ConnectionReleaseMode getDefaultReleaseMode();
-	
-	/**
-	 * Do we require access to the JTA TransactionManager for
-	 * this strategy?
-	 *
-	 * @return True if this strategy requires access to the JTA TransactionManager;
-	 * false otherwise.
-	 */
-	public boolean isTransactionManagerRequired();
-
-	/**
-	 * Are all transaction callbacks local to Hibernate Transactions?
-	 * Or can the callbacks originate from some other source (e.g. a JTA
-	 * Synchronization).
-	 *
-	 * @return true if callbacks only ever originate from the Hibernate
-	 * {@link Transaction}; false otherwise.
-	 */
-	public boolean areCallbacksLocalToHibernateTransactions();
-
-	/**
-	 * Determine whether an underlying transaction is in progress.
-	 * <p/>
-	 * Mainly this is used in determining whether to register a
-	 * synchronization as well as whether or not to circumvent
-	 * auto flushing outside transactions.
-	 *
-	 * @param jdbcContext The JDBC context
-	 * @param transactionContext The transaction context
-	 * @param transaction The Hibernate transaction
-	 * @return true if an underlying transaction is know to be in effect.
-	 */
-	public boolean isTransactionInProgress(JDBCContext jdbcContext, Context transactionContext, Transaction transaction);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactoryFactory.java b/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactoryFactory.java
deleted file mode 100644
index 903ae90faa..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionFactoryFactory.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.HibernateException;
-import org.hibernate.cfg.Environment;
-import org.hibernate.util.ReflectHelper;
-
-/**
- * Helper for creating {@link TransactionFactory} instances.
- *
- * @author Gavin King
- */
-public final class TransactionFactoryFactory {
-
-	private static final Logger log = LoggerFactory.getLogger( TransactionFactoryFactory.class );
-
-	/**
-	 * Create an appropriate transaction factory based on the given configuration
-	 * properties.
-	 *
-	 * @param transactionProps transaction properties
-	 *
-	 * @return The appropriate transaction factory.
-	 *
-	 * @throws HibernateException Indicates a problem creating the appropriate
-	 * transaction factory.
-	 */
-	public static TransactionFactory buildTransactionFactory(Properties transactionProps) throws HibernateException {
-		String strategyClassName = transactionProps.getProperty( Environment.TRANSACTION_STRATEGY );
-		if ( strategyClassName == null ) {
-			log.info( "Using default transaction strategy (direct JDBC transactions)" );
-			return new JDBCTransactionFactory();
-		}
-		log.info( "Transaction strategy: " + strategyClassName );
-		TransactionFactory factory;
-		try {
-			factory = ( TransactionFactory ) ReflectHelper.classForName( strategyClassName ).newInstance();
-		}
-		catch ( ClassNotFoundException e ) {
-			log.error( "TransactionFactory class not found", e );
-			throw new HibernateException( "TransactionFactory class not found: " + strategyClassName );
-		}
-		catch ( IllegalAccessException e ) {
-			log.error( "Failed to instantiate TransactionFactory", e );
-			throw new HibernateException( "Failed to instantiate TransactionFactory: " + e );
-		}
-		catch ( java.lang.InstantiationException e ) {
-			log.error( "Failed to instantiate TransactionFactory", e );
-			throw new HibernateException( "Failed to instantiate TransactionFactory: " + e );
-		}
-		factory.configure( transactionProps );
-		return factory;
-	}
-
-	/**
-	 * Disallow instantiation
-	 */
-	private TransactionFactoryFactory() {
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionManagerLookupFactory.java b/hibernate-core/src/main/java/org/hibernate/transaction/TransactionManagerLookupFactory.java
deleted file mode 100644
index 11509cd508..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/TransactionManagerLookupFactory.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.util.Properties;
-
-import javax.transaction.TransactionManager;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.HibernateException;
-import org.hibernate.cfg.Environment;
-import org.hibernate.util.ReflectHelper;
-
-/**
- * Helper for generating {@link TransactionManagerLookup} instances.
- *
- * @author Gavin King
- */
-public final class TransactionManagerLookupFactory {
-
-	private static final Logger log = LoggerFactory.getLogger(TransactionManagerLookupFactory.class);
-
-	/**
-	 * Disallow instantiation
-	 */
-	private TransactionManagerLookupFactory() {
-	}
-
-	/**
-	 * Convenience method for locating the JTA {@link TransactionManager} from the
-	 * given platform config.
-	 * <p/>
-	 * Same as calling {@link #getTransactionManager}.getTransactionManager( props )
-	 *
-	 * @param props The properties representing the platform config
-	 * @return The located {@link TransactionManager}
-	 * @throws HibernateException Indicates a problem either (a) generatng the
-	 * {@link TransactionManagerLookup} or (b) asking it to locate the {@link TransactionManager}.
-	 */
-	public static TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		log.info( "obtaining TransactionManager" );
-		return getTransactionManagerLookup( props ).getTransactionManager( props );
-	}
-
-	/**
-	 * Generate the appropriate {@link TransactionManagerLookup} given the
-	 * config settings being passed.
-	 *
-	 * @param props The config settings
-	 * @return The appropriate {@link TransactionManagerLookup}
-	 * @throws HibernateException Indicates problem generating {@link TransactionManagerLookup}
-	 */
-	public static TransactionManagerLookup getTransactionManagerLookup(Properties props) throws HibernateException {
-		String tmLookupClass = props.getProperty( Environment.TRANSACTION_MANAGER_STRATEGY );
-		if ( tmLookupClass == null ) {
-			log.info( "No TransactionManagerLookup configured (in JTA environment, use of read-write or transactional second-level cache is not recommended)" );
-			return null;
-		}
-		else {
-			log.info( "instantiating TransactionManagerLookup: " + tmLookupClass );
-			try {
-				TransactionManagerLookup lookup = ( TransactionManagerLookup )
-						ReflectHelper.classForName( tmLookupClass ).newInstance();
-				log.info( "instantiated TransactionManagerLookup" );
-				return lookup;
-			}
-			catch ( Exception e ) {
-				log.error( "Could not instantiate TransactionManagerLookup", e );
-				throw new HibernateException( "Could not instantiate TransactionManagerLookup '" + tmLookupClass + "'" );
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/WebSphereTransactionManagerLookup.java b/hibernate-core/src/main/java/org/hibernate/transaction/WebSphereTransactionManagerLookup.java
deleted file mode 100644
index 713a916a47..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/transaction/WebSphereTransactionManagerLookup.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.transaction;
-
-import java.lang.reflect.Method;
-import java.util.Properties;
-
-import javax.transaction.TransactionManager;
-import javax.transaction.Transaction;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.hibernate.HibernateException;
-
-/**
- * {@link TransactionManagerLookup} strategy for WebSphere (versions 4, 5.0 and 5.1)
- *
- * @author Gavin King
- */
-@SuppressWarnings( {"UnusedDeclaration"})
-public class WebSphereTransactionManagerLookup implements TransactionManagerLookup {
-
-	private static final Logger log = LoggerFactory.getLogger(WebSphereTransactionManagerLookup.class);
-	private final int wsVersion;
-	private final Class tmfClass;
-	
-	/**
-	 * Constructs a new WebSphereTransactionManagerLookup.
-	 */
-	public WebSphereTransactionManagerLookup() {
-		try {
-			Class clazz;
-			int version;
-			try {
-				clazz = Class.forName( "com.ibm.ws.Transaction.TransactionManagerFactory" );
-				version = 5;
-				log.info( "WebSphere 5.1" );
-			}
-			catch ( Exception e ) {
-				try {
-					clazz = Class.forName( "com.ibm.ejs.jts.jta.TransactionManagerFactory" );
-					version = 5;
-					log.info( "WebSphere 5.0" );
-				} 
-				catch ( Exception e2 ) {
-					clazz = Class.forName( "com.ibm.ejs.jts.jta.JTSXA" );
-					version = 4;
-					log.info( "WebSphere 4" );
-				}
-			}
-
-			tmfClass = clazz;
-			wsVersion = version;
-		}
-		catch ( Exception e ) {
-			throw new HibernateException( "Could not obtain WebSphere TransactionManagerFactory instance", e );
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public TransactionManager getTransactionManager(Properties props) throws HibernateException {
-		try {
-			final Method method = tmfClass.getMethod( "getTransactionManager", (Class[]) null );
-			return ( TransactionManager ) method.invoke( null, (Object[]) null );
-		}
-		catch ( Exception e ) {
-			throw new HibernateException( "Could not obtain WebSphere TransactionManager", e );
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public String getUserTransactionName() {
-		return wsVersion == 5
-				? "java:comp/UserTransaction"
-				: "jta/usertransaction";
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public Object getTransactionIdentifier(Transaction transaction) {
-		return transaction;
-	}
-}
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/type/DbTimestampType.java b/hibernate-core/src/main/java/org/hibernate/type/DbTimestampType.java
index 46df7b29c0..316048d320 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/DbTimestampType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/DbTimestampType.java
@@ -1,158 +1,164 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.sql.Timestamp;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.ResultSet;
 import java.sql.CallableStatement;
 import java.util.Date;
 
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.dialect.Dialect;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * <tt>dbtimestamp</tt>: An extension of {@link TimestampType} which
  * maps to the database's current timestamp, rather than the jvm's
  * current timestamp.
  * <p/>
  * Note: May/may-not cause issues on dialects which do not properly support
  * a true notion of timestamp (Oracle < 8, for example, where only its DATE
  * datatype is supported).  Depends on the frequency of DML operations...
  *
  * @author Steve Ebersole
  */
 public class DbTimestampType extends TimestampType {
 	public static final DbTimestampType INSTANCE = new DbTimestampType();
 
 	private static final Logger log = LoggerFactory.getLogger( DbTimestampType.class );
 	
 	public String getName() {
 		return "dbtimestamp";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName() };
 	}
 
 	public Date seed(SessionImplementor session) {
 		if ( session == null ) {
 			log.trace( "incoming session was null; using current jvm time" );
 			return super.seed( session );
 		}
 		else if ( !session.getFactory().getDialect().supportsCurrentTimestampSelection() ) {
 			log.debug( "falling back to vm-based timestamp, as dialect does not support current timestamp selection" );
 			return super.seed( session );
 		}
 		else {
 			return getCurrentTimestamp( session );
 		}
 	}
 
 	private Date getCurrentTimestamp(SessionImplementor session) {
 		Dialect dialect = session.getFactory().getDialect();
 		String timestampSelectString = dialect.getCurrentTimestampSelectString();
 		if ( dialect.isCurrentTimestampSelectStringCallable() ) {
 			return useCallableStatement( timestampSelectString, session );
 		}
 		else {
 			return usePreparedStatement( timestampSelectString, session );
 		}
 	}
 
 	private Timestamp usePreparedStatement(String timestampSelectString, SessionImplementor session) {
 		PreparedStatement ps = null;
 		try {
-			ps = session.getJDBCContext().getConnectionManager().prepareStatement( timestampSelectString, false );
+			ps = session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( timestampSelectString, false );
 			ResultSet rs = ps.executeQuery();
 			rs.next();
 			Timestamp ts = rs.getTimestamp( 1 );
 			if ( log.isTraceEnabled() ) {
 				log.trace(
 				        "current timestamp retreived from db : " + ts +
 				        " (nanos=" + ts.getNanos() +
 				        ", time=" + ts.getTime() + ")"
 					);
 			}
 			return ts;
 		}
-		catch( SQLException sqle ) {
+		catch( SQLException e ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
-			        sqle,
+			        e,
 			        "could not select current db timestamp",
 			        timestampSelectString
-				);
+			);
 		}
 		finally {
 			if ( ps != null ) {
 				try {
 					ps.close();
 				}
 				catch( SQLException sqle ) {
 					log.warn( "unable to clean up prepared statement", sqle );
 				}
 			}
 		}
 	}
 
 	private Timestamp useCallableStatement(String callString, SessionImplementor session) {
 		CallableStatement cs = null;
 		try {
-			cs = session.getJDBCContext().getConnectionManager().prepareCallableStatement( callString );
+			cs = (CallableStatement) session.getTransactionCoordinator()
+					.getJdbcCoordinator()
+					.getStatementPreparer()
+					.prepareStatement( callString, true );
 			cs.registerOutParameter( 1, java.sql.Types.TIMESTAMP );
 			cs.execute();
 			Timestamp ts = cs.getTimestamp( 1 );
 			if ( log.isTraceEnabled() ) {
 				log.trace(
 				        "current timestamp retreived from db : " + ts +
 				        " (nanos=" + ts.getNanos() +
 				        ", time=" + ts.getTime() + ")"
 					);
 			}
 			return ts;
 		}
-		catch( SQLException sqle ) {
+		catch( SQLException e ) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
-			        sqle,
+			        e,
 			        "could not call current db timestamp function",
 			        callString
-				);
+			);
 		}
 		finally {
 			if ( cs != null ) {
 				try {
 					cs.close();
 				}
 				catch( SQLException sqle ) {
 					log.warn( "unable to clean up callable statement", sqle );
 				}
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/util/JTAHelper.java b/hibernate-core/src/main/java/org/hibernate/util/JTAHelper.java
index 68b75da64f..8267d93b74 100755
--- a/hibernate-core/src/main/java/org/hibernate/util/JTAHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/util/JTAHelper.java
@@ -1,77 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.util;
 
 import javax.transaction.Status;
 import javax.transaction.SystemException;
 import javax.transaction.TransactionManager;
 
 import org.hibernate.TransactionException;
 import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
 
 /**
  * @author Gavin King
  */
 public final class JTAHelper {
 
 	private JTAHelper() {}
 
 	public static boolean isRollback(int status) {
 		return status==Status.STATUS_MARKED_ROLLBACK ||
 		       status==Status.STATUS_ROLLING_BACK ||
 		       status==Status.STATUS_ROLLEDBACK;
 	}
 
 	public static boolean isInProgress(int status) {
 		return status==Status.STATUS_ACTIVE ||
 		       status==Status.STATUS_MARKED_ROLLBACK;
 	}
 
 	/**
 	 * Return true if a JTA transaction is in progress
 	 * and false in *every* other cases (including in a JDBC transaction).
 	 */
 	public static boolean isTransactionInProgress(SessionFactoryImplementor factory) {
-		TransactionManager tm = factory.getTransactionManager();
+		TransactionManager tm = factory.getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager();
 		try {
 			return tm != null && isTransactionInProgress( tm.getTransaction() );
 		}
 		catch (SystemException se) {
 			throw new TransactionException( "could not obtain JTA Transaction", se );
 		}
 	}
 
 	public static boolean isTransactionInProgress(javax.transaction.Transaction tx) throws SystemException {
 		return tx != null && JTAHelper.isInProgress( tx.getStatus() );
 	}
 
 	public static boolean isMarkedForRollback(int status) {
 		return status == Status.STATUS_MARKED_ROLLBACK;
 	}
 
 	public static boolean isMarkedForRollback(javax.transaction.Transaction tx) throws SystemException {
 		return isMarkedForRollback( tx.getStatus() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
index 31300f24ea..206a7e96a3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
@@ -1,776 +1,774 @@
 //$Id$
 //$Id$
 package org.hibernate.test.annotations.manytomany;
 
 
+import org.hibernate.Hibernate;
+import org.hibernate.JDBCException;
+import org.hibernate.Session;
+import org.hibernate.Transaction;
+import org.hibernate.criterion.Restrictions;
+import org.hibernate.test.annotations.TestCase;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
-import org.hibernate.Hibernate;
-import org.hibernate.JDBCException;
-import org.hibernate.Session;
-import org.hibernate.Transaction;
-import org.hibernate.criterion.Restrictions;
-import org.hibernate.test.annotations.TestCase;
-
 /**
  * Many to many tests
  *
  * @author Emmanuel Bernard
  */
 @SuppressWarnings("unchecked")
 public class ManyToManyTest extends TestCase {
 
 	public ManyToManyTest(String x) {
 		super( x );
 	}
 
 	public void testDefault() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		KnownClient emmanuel = new KnownClient();
 		emmanuel.setName( "Emmanuel" );
 		emmanuel.setStores( new HashSet<Store>() );
 		fnac.setCustomers( new HashSet<KnownClient>() );
 		fnac.getCustomers().add( emmanuel );
 		emmanuel.getStores().add( fnac );
 		fnac.setImplantedIn( new HashSet<City>() );
 		City paris = new City();
 		fnac.getImplantedIn().add( paris );
 		paris.setName( "Paris" );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Store store;
 		KnownClient knownClient;
 		City city;
 		store = (Store) s.get( Store.class, fnac.getId() );
 		assertNotNull( store );
 		assertNotNull( store.getCustomers() );
 		assertEquals( 1, store.getCustomers().size() );
 		knownClient = (KnownClient) store.getCustomers().iterator().next();
 		assertEquals( emmanuel.getName(), knownClient.getName() );
 		assertNotNull( store.getImplantedIn() );
 		assertEquals( 1, store.getImplantedIn().size() );
 		city = (City) store.getImplantedIn().iterator().next();
 		assertEquals( paris.getName(), city.getName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		knownClient = (KnownClient) s.get( KnownClient.class, emmanuel.getId() );
 		assertNotNull( knownClient );
 		assertNotNull( knownClient.getStores() );
 		assertEquals( 1, knownClient.getStores().size() );
 		store = (Store) knownClient.getStores().iterator().next();
 		assertEquals( fnac.getName(), store.getName() );
 		tx.commit();
 		s.close();
 	}
 
 	public void testCanUseCriteriaQuery() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		Supplier emi = new Supplier();
 		emi.setName( "Emmanuel" );
 		emi.setSuppStores( new HashSet<Store>() );
 		fnac.setSuppliers( new HashSet<Supplier>() );
 		fnac.getSuppliers().add( emi );
 		emi.getSuppStores().add( fnac );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		List result = s.createCriteria( Supplier.class ).createAlias( "suppStores", "s" ).add(
 				Restrictions.eq( "s.name", "Fnac" ) ).list();
 		assertEquals( 1, result.size() );
 		tx.commit();
 		s.close();
 	}
 	public void testDefaultCompositePk() throws Exception {
 		Session s;
 		Transaction tx;
 
 		s = openSession();
 		tx = s.beginTransaction();
 		CatPk catPk = new CatPk();
 		catPk.setName( "Minou" );
 		catPk.setThoroughbred( "Persan" );
 		Cat cat = new Cat();
 		cat.setId( catPk );
 		cat.setAge( 32 );
 		Woman woman = new Woman();
 		WomanPk womanPk = new WomanPk();
 		womanPk.setFirstName( "Emma" );
 		womanPk.setLastName( "Peel" );
 		woman.setId( womanPk );
 		woman.setCats( new HashSet<Cat>() );
 		woman.getCats().add( cat );
 		cat.setHumanContacts( new HashSet<Woman>() );
 		cat.getHumanContacts().add( woman );
 		s.persist( woman );
 		s.persist( cat );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Cat sameCat = (Cat) s.get( Cat.class, cat.getId() );
 		assertNotNull( sameCat );
 		assertNotNull( sameCat.getHumanContacts() );
 		assertEquals( 1, sameCat.getHumanContacts().size() );
 		Woman sameWoman = sameCat.getHumanContacts().iterator().next();
 		assertEquals( sameWoman.getId().getLastName(), woman.getId().getLastName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		sameWoman = (Woman) s.get( Woman.class, woman.getId() );
 		assertNotNull( sameWoman );
 		assertNotNull( sameWoman.getCats() );
 		assertEquals( 1, sameWoman.getCats().size() );
 		sameCat = sameWoman.getCats().iterator().next();
 		assertEquals( cat.getAge(), sameCat.getAge() );
 		tx.commit();
 		s.close();
 	}
 
 	public void testMappedBy() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		Supplier emi = new Supplier();
 		emi.setName( "Emmanuel" );
 		emi.setSuppStores( new HashSet<Store>() );
 		fnac.setSuppliers( new HashSet<Supplier>() );
 		fnac.getSuppliers().add( emi );
 		emi.getSuppStores().add( fnac );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Store store;
 		Supplier supplier;
 		store = (Store) s.get( Store.class, fnac.getId() );
 		assertNotNull( store );
 		assertNotNull( store.getSuppliers() );
 		assertEquals( 1, store.getSuppliers().size() );
 		supplier = (Supplier) store.getSuppliers().iterator().next();
 		assertEquals( emi.getName(), supplier.getName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		supplier = (Supplier) s.get( Supplier.class, emi.getId() );
 		assertNotNull( supplier );
 		assertNotNull( supplier.getSuppStores() );
 		assertEquals( 1, supplier.getSuppStores().size() );
 		store = (Store) supplier.getSuppStores().iterator().next();
 		assertEquals( fnac.getName(), store.getName() );
 		tx.commit();
 		s.close();
 	}
 
 	public void testBasic() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		s.persist( ee );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		erColl.add( ee );
 		eeColl.add( er );
 		er.setEmployees( erColl );
 		ee.setEmployers( eeColl );
 		//s.persist(ee);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load( Employer.class, er.getId() );
 		assertNotNull( er );
 		assertNotNull( er.getEmployees() );
 		assertEquals( 1, er.getEmployees().size() );
 		Employee eeFromDb = (Employee) er.getEmployees().iterator().next();
 		assertEquals( ee.getId(), eeFromDb.getId() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		tx.commit();
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		er = ee.getEmployers().iterator().next();
 		assertTrue( "second join non lazy", Hibernate.isInitialized( er ) );
 		s.delete( er );
 		s.delete( ee );
 		tx.commit();
 		s.close();
 	}
 
 	public void testOrderByEmployee() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer employer = new Employer();
 		Employee employee1 = new Employee();
 		employee1.setName( "Emmanuel" );
 		Employee employee2 = new Employee();
 		employee2.setName( "Alice" );
 		s.persist( employee1 );
 		s.persist( employee2 );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		Collection eeColl2 = new ArrayList();
 		erColl.add( employee1 );
 		erColl.add( employee2 );
 		eeColl.add( employer );
 		eeColl2.add( employer );
 		employer.setEmployees( erColl );
 		employee1.setEmployers( eeColl );
 		employee2.setEmployers( eeColl2 );
 
 		s.flush();
 		s.clear();
 
 		employer = (Employer) s.get( Employer.class, employer.getId() );
 		assertNotNull( employer );
 		assertNotNull( employer.getEmployees() );
 		assertEquals( 2, employer.getEmployees().size() );
 		Employee eeFromDb = (Employee) employer.getEmployees().iterator().next();
 		assertEquals( employee2.getName(), eeFromDb.getName() );
 		tx.rollback();
 		s.close();
 
 	}
 	
 	/**
 	 * ANN-625
 	 * 
 	 * @throws Exception in case the test fails.
 	 * 
 	 * This test only works against databases which allow a mixed usage of
      * table names and table aliases. The generated SQL for this test is:
 	 * 
 	 * 	   select
 	 *         contractor0_.EMPLOYER_ID as EMPLOYER1_1_,
 	 *         contractor0_.CONTRACTOR_ID as CONTRACTOR2_1_,
 	 *         contractor1_.id as id2_0_,
 	 *         contractor1_.fld_name as fld3_2_0_,
 	 *         contractor1_.hourlyRate as hourlyRate2_0_ 
 	 *     from
 	 *         EMPLOYER_CONTRACTOR contractor0_ 
 	 *     left outer join
 	 *         Employee contractor1_ 
 	 *             on contractor0_.CONTRACTOR_ID=contractor1_.id 
 	 *     where
 	 *         contractor0_.EMPLOYER_ID=? 
 	 *     order by
 	 *         Employee.fld_name desc
 	 * 
 	 * 
 	 */
 // HHH-3577
 //	public void testOrderByContractor() throws Exception {
 //
 //		Session s;
 //		Transaction tx;
 //		s = openSession();
 //		tx = s.beginTransaction();
 //
 //		// create some test entities
 //		Employer employer = new Employer();
 //		Contractor contractor1 = new Contractor();
 //		contractor1.setName( "Emmanuel" );
 //		contractor1.setHourlyRate(100.0f);
 //		Contractor contractor2 = new Contractor();
 //		contractor2.setName( "Hardy" );
 //		contractor2.setHourlyRate(99.99f);
 //		s.persist( contractor1 );
 //		s.persist( contractor2 );
 //
 //		// add contractors to employer
 //		List setOfContractors = new ArrayList();
 //		setOfContractors.add( contractor1 );
 //		setOfContractors.add( contractor2 );
 //		employer.setContractors( setOfContractors );
 //
 //		// add employer to contractors
 //		Collection employerListContractor1 = new ArrayList();
 //		employerListContractor1.add( employer );
 //		contractor1.setEmployers( employerListContractor1 );
 //
 //		Collection employerListContractor2 = new ArrayList();
 //		employerListContractor2.add( employer );
 //		contractor2.setEmployers( employerListContractor2 );
 //
 //		s.flush();
 //		s.clear();
 //
 //		// assertions
 //		employer = (Employer) s.get( Employer.class, employer.getId() );
 //		assertNotNull( employer );
 //		assertNotNull( employer.getContractors() );
 //		assertEquals( 2, employer.getContractors().size() );
 //		Contractor firstContractorFromDb = (Contractor) employer.getContractors().iterator().next();
 //		assertEquals( contractor2.getName(), firstContractorFromDb.getName() );
 //		tx.rollback();
 //		s.close();
 //	}
 
 	public void testRemoveInBetween() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		Employee ee2 = new Employee();
 		s.persist( ee );
 		s.persist( ee2 );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		erColl.add( ee );
 		erColl.add( ee2 );
 		eeColl.add( er );
 		er.setEmployees( erColl );
 		ee.setEmployers( eeColl );
 		//s.persist(ee);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load( Employer.class, er.getId() );
 		assertNotNull( er );
 		assertNotNull( er.getEmployees() );
 		assertEquals( 2, er.getEmployees().size() );
 		Iterator iterator = er.getEmployees().iterator();
 		Employee eeFromDb = (Employee) iterator.next();
 		if ( eeFromDb.getId().equals( ee.getId() ) ) {
 			eeFromDb = (Employee) iterator.next();
 		}
 		assertEquals( ee2.getId(), eeFromDb.getId() );
 		er.getEmployees().remove( eeFromDb );
 		eeFromDb.getEmployers().remove( er );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		tx.commit();
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		er = ee.getEmployers().iterator().next();
 		assertTrue( "second join non lazy", Hibernate.isInitialized( er ) );
 		assertEquals( 1, er.getEmployees().size() );
 		s.delete( er );
 		s.delete( ee );
 		tx.commit();
 		s.close();
 	}
 
 	public void testSelf() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Friend f = new Friend();
 		Friend sndF = new Friend();
 		f.setName( "Starsky" );
 		sndF.setName( "Hutch" );
 		Set frnds = new HashSet();
 		frnds.add( sndF );
 		f.setFriends( frnds );
 		//Starsky is a friend of Hutch but hutch is not
 		s.persist( f );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		f = (Friend) s.load( Friend.class, f.getId() );
 		assertNotNull( f );
 		assertNotNull( f.getFriends() );
 		assertEquals( 1, f.getFriends().size() );
 		Friend fromDb2ndFrnd = (Friend) f.getFriends().iterator().next();
 		assertEquals( fromDb2ndFrnd.getId(), sndF.getId() );
 		assertEquals( 0, fromDb2ndFrnd.getFriends().size() );
 		tx.commit();
 		s.close();
 	}
 
 	public void testCompositePk() throws Exception {
 		Session s;
 		Transaction tx;
 
 		ManPk m1pk = new ManPk();
 		m1pk.setElder( true );
 		m1pk.setFirstName( "Lucky" );
 		m1pk.setLastName( "Luke" );
 		ManPk m2pk = new ManPk();
 		m2pk.setElder( false );
 		m2pk.setFirstName( "Joe" );
 		m2pk.setLastName( "Dalton" );
 
 		Man m1 = new Man();
 		m1.setId( m1pk );
 		m1.setCarName( "Jolly Jumper" );
 		Man m2 = new Man();
 		m2.setId( m2pk );
 
 		WomanPk w1pk = new WomanPk();
 		w1pk.setFirstName( "Ma" );
 		w1pk.setLastName( "Dalton" );
 		WomanPk w2pk = new WomanPk();
 		w2pk.setFirstName( "Carla" );
 		w2pk.setLastName( "Bruni" );
 
 		Woman w1 = new Woman();
 		w1.setId( w1pk );
 		Woman w2 = new Woman();
 		w2.setId( w2pk );
 
 		Set<Woman> womens = new HashSet<Woman>();
 		womens.add( w1 );
 		m1.setWomens( womens );
 		Set<Woman> womens2 = new HashSet<Woman>();
 		womens2.add( w1 );
 		womens2.add( w2 );
 		m2.setWomens( womens2 );
 
 		Set<Man> mens = new HashSet<Man>();
 		mens.add( m1 );
 		mens.add( m2 );
 		w1.setMens( mens );
 		Set<Man> mens2 = new HashSet<Man>();
 		mens2.add( m2 );
 		w2.setMens( mens2 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist( m1 );
 		s.persist( m2 );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		m1 = (Man) s.load( Man.class, m1pk );
 		assertFalse( m1.getWomens().isEmpty() );
 		assertEquals( 1, m1.getWomens().size() );
 		w1 = (Woman) s.load( Woman.class, w1pk );
 		assertFalse( w1.getMens().isEmpty() );
 		assertEquals( 2, w1.getMens().size() );
 
 		tx.commit();
 		s.close();
 	}
 
 	public void testAssociationTableUniqueConstraints() throws Exception {
 		Session s = openSession();
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		Collection<Permission> coll = new ArrayList<Permission>( 2 );
 		coll.add( readAccess );
 		coll.add( readAccess );
 		Group group = new Group();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		try {
 			s.persist( group );
 			s.getTransaction().commit();
 			fail( "Unique constraints not applied on association table" );
 		}
 		catch (JDBCException e) {
 			//success
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	public void testAssociationTableAndOrderBy() throws Exception {
 		Session s = openSession();
 		s.enableFilter( "Groupfilter" );
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		Permission writeAccess = new Permission();
 		writeAccess.setPermission( "write" );
 		writeAccess.setExpirationDate( new Date( new Date().getTime() - 10*60*1000 ) );
 		Collection<Permission> coll = new ArrayList<Permission>( 2 );
 		coll.add( readAccess );
 		coll.add( writeAccess );
 		Group group = new Group();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		s.persist( group );
 		s.flush();
 		s.clear();
 		group = (Group) s.get( Group.class, group.getId() );
 		s.createQuery( "select g from Group g join fetch g.permissions").list();
 		assertEquals( "write", group.getPermissions().iterator().next().getPermission() );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	public void testAssociationTableAndOrderByWithSet() throws Exception {
 		Session s = openSession();
 		s.enableFilter( "Groupfilter" );
 
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		
 		Permission writeAccess = new Permission();
 		writeAccess.setPermission( "write" );
 		writeAccess.setExpirationDate( new Date( new Date().getTime() - 10*60*1000 ) );
 		
 		Permission executeAccess = new Permission();
 		executeAccess.setPermission( "execute" );
 		executeAccess.setExpirationDate( new Date( new Date().getTime() - 5*60*1000 ) );
 		
 		Set<Permission> coll = new HashSet<Permission>( 3 );
 		coll.add( readAccess );
 		coll.add( writeAccess );
 		coll.add( executeAccess );
 
 		GroupWithSet group = new GroupWithSet();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		s.persist( group );
 		s.flush();
 		s.clear();
 
 		group = (GroupWithSet) s.get( GroupWithSet.class, group.getId() );
 		s.createQuery( "select g from Group g join fetch g.permissions").list();
 		Iterator<Permission> permIter = group.getPermissions().iterator();
 		assertEquals( "write", permIter.next().getPermission() );
 		assertEquals( "execute", permIter.next().getPermission() );
 		assertEquals( "read", permIter.next().getPermission() );
 		s.getTransaction().rollback();
 		s.close();
 	}
 	
 	public void testJoinedSubclassManyToMany() throws Exception {
 		Session s = openSession();
 		Zone a = new Zone();
 		InspectorPrefixes ip = new InspectorPrefixes( "dgi" );
 		Transaction tx = s.beginTransaction();
 		s.save( a );
 		s.save( ip );
 		ip.getAreas().add( a );
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		ip = (InspectorPrefixes) s.get( InspectorPrefixes.class, ip.getId() );
 		assertNotNull( ip );
 		assertEquals( 1, ip.getAreas().size() );
 		assertEquals( a.getId(), ip.getAreas().get( 0 ).getId() );
 		s.delete( ip );
 		s.delete( ip.getAreas().get( 0 ) );
 		tx.commit();
 		s.close();
 	}
 
 	public void testJoinedSubclassManyToManyWithNonPkReference() throws Exception {
 		Session s = openSession();
 		Zone a = new Zone();
 		InspectorPrefixes ip = new InspectorPrefixes( "dgi" );
 		ip.setName( "Inspector" );
 		Transaction tx = s.beginTransaction();
 		s.save( a );
 		s.save( ip );
 		ip.getDesertedAreas().add( a );
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		ip = (InspectorPrefixes) s.get( InspectorPrefixes.class, ip.getId() );
 		assertNotNull( ip );
 		assertEquals( 1, ip.getDesertedAreas().size() );
 		assertEquals( a.getId(), ip.getDesertedAreas().get( 0 ).getId() );
 		s.delete( ip );
 		s.delete( ip.getDesertedAreas().get( 0 ) );
 		tx.commit();
 		s.close();
 	}
 
 	public void testReferencedColumnNameToSuperclass() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		BuildingCompany comp = new BuildingCompany();
 		comp.setFoundedIn( new Date() );
 		comp.setName( "Builder century corp.");
 		s.persist( comp );
 		Building building = new Building();
 		building.setCompany( comp );
 		s.persist( building );
 		s.flush();
 		s.clear();
 		building = (Building) s.get( Building.class, building.getId() );
 		assertEquals( comp.getName(), building.getCompany().getName() );
 		tx.rollback();
 		s.close();
 	}
 
 	// Test for HHH-4685
 	// Section 11.1.25
 	// The ManyToMany annotation may be used within an embeddable class contained within an entity class to specify a
 	// relationship to a collection of entities[101]. If the relationship is bidirectional and the entity containing
 	// the embeddable class is the owner of the relationship, the non-owning side must use the mappedBy element of the
 	// ManyToMany annotation to specify the relationship field or property of the embeddable class. The dot (".")
 	// notation syntax must be used in the mappedBy element to indicate the relationship attribute within the embedded
 	// attribute. The value of each identifier used with the dot notation is the name of the respective embedded field
 	// or property.
 	public void testManyToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
 		Session s;
-		Transaction tx;
 		s = openSession();
-		tx = s.beginTransaction();
+		s.getTransaction().begin();
 		Employee e = new Employee();
 		e.setName( "Sharon" );
 		List<PhoneNumber> phoneNumbers = new ArrayList<PhoneNumber>();
 		Collection<Employee> employees = new ArrayList<Employee>();
 		employees.add( e );
-	   ContactInfo contactInfo = new ContactInfo();
+		ContactInfo contactInfo = new ContactInfo();
 		PhoneNumber number = new PhoneNumber();
 		number.setEmployees( employees );
 		phoneNumbers.add( number );
 		contactInfo.setPhoneNumbers( phoneNumbers );
 		e.setContactInfo( contactInfo );
 		s.persist( e );
-		s.flush();
-		s.clear();
-		tx.commit();
+		s.getTransaction().commit();
+		s.close();
 
-		tx.begin();
+		s = openSession();
+		s.getTransaction().begin();
 		e = (Employee)s.get( e.getClass(),e.getId() );
 		// follow both directions of many to many association 
 		assertEquals("same employee", e.getName(), e.getContactInfo().getPhoneNumbers().get(0).getEmployees().iterator().next().getName());
-		tx.commit();
+		s.getTransaction().commit();
 
 		s.close();
 	}
 
 	// Test for HHH-4685
 	// Section 11.1.26
 	// The ManyToOne annotation may be used within an embeddable class to specify a relationship from the embeddable
 	// class to an entity class. If the relationship is bidirectional, the non-owning OneToMany entity side must use the
 	// mappedBy element of the OneToMany annotation to specify the relationship field or property of the embeddable field
 	// or property on the owning side of the relationship. The dot (".") notation syntax must be used in the mappedBy
 	// element to indicate the relationship attribute within the embedded attribute. The value of each identifier used
 	// with the dot notation is the name of the respective embedded field or property.
 	public void testOneToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
 		Session s;
-		Transaction tx;
 		s = openSession();
-		tx = s.beginTransaction();
+		s.getTransaction().begin();
 		Employee e = new Employee();
 		JobInfo job = new JobInfo();
 		job.setJobDescription( "Sushi Chef" );
 		ProgramManager pm = new ProgramManager();
 		Collection<Employee> employees = new ArrayList<Employee>();
 		employees.add(e);
 		pm.setManages( employees );
 		job.setPm(pm);
 		e.setJobInfo( job );
 		s.persist( e );
-		s.flush();
-		s.clear();
-		tx.commit();
+		s.getTransaction().commit();
+		s.close();
 
-		tx.begin();
+		s = openSession();
+		s.getTransaction().begin();
 		e = (Employee) s.get( e.getClass(), e.getId() );
 		assertEquals( "same job in both directions", 
 			e.getJobInfo().getJobDescription(),
 			e.getJobInfo().getPm().getManages().iterator().next().getJobInfo().getJobDescription()  );
-		tx.commit();
+		s.getTransaction().commit();
 		s.close();
 	}
 
 	/**
 	 * @see org.hibernate.test.annotations.TestCase#getAnnotatedClasses()
 	 */
 	protected Class[] getAnnotatedClasses() {
 		return new Class[]{
 				Friend.class,
 				Employer.class,
 				Employee.class,
 				Contractor.class,
 				Man.class,
 				Woman.class,
 				Store.class,
 				KnownClient.class,
 				Supplier.class,
 				City.class,
 				Cat.class,
 				Group.class,
 				GroupWithSet.class,
 				Permission.class,
 				Zone.class,
 				Inspector.class,
 				InspectorPrefixes.class,
 				BuildingCompany.class,
 				Building.class,
 				PhoneNumber.class,
 				ProgramManager.class
 		};
 	}
 
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/polymorphism/PolymorphismTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/polymorphism/PolymorphismTest.java
index 0929a56ff6..1b1acda0b3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/polymorphism/PolymorphismTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/polymorphism/PolymorphismTest.java
@@ -1,37 +1,36 @@
 //$Id$
 package org.hibernate.test.annotations.polymorphism;
 
 import org.hibernate.test.annotations.TestCase;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 
 /**
  * @author Emmanuel Bernard
  */
 public class PolymorphismTest extends TestCase {
 
 	public void testPolymorphism() throws Exception {
 		Car car = new Car();
 		car.setModel( "SUV" );
 		SportCar car2 = new SportCar();
 		car2.setModel( "350Z" );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
-		tx.begin();
 		s.persist( car );
 		s.persist( car2 );
 		s.flush();
 		assertEquals( 2, s.createQuery( "select car from Car car").list().size() );
 		assertEquals( 0, s.createQuery( "select count(m) from " + MovingThing.class.getName() + " m").list().size() );
 		tx.rollback();
 		s.close();
 
 	}
 
 	protected Class[] getAnnotatedClasses() {
 		return new Class[] {
 				Car.class,
 				SportCar.class
 		};
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/subselect/SubselectTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/subselect/SubselectTest.java
index 4614022d36..bf095d0692 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/subselect/SubselectTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/subselect/SubselectTest.java
@@ -1,89 +1,88 @@
 /*
   * Hibernate, Relational Persistence for Idiomatic Java
   *
   * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-
   * party contributors as indicated by the @author tags or express 
   * copyright attribution statements applied by the authors.  
   * All third-party contributions are distributed under license by 
   * Red Hat, Inc.
   *
   * This copyrighted material is made available to anyone wishing to 
   * use, modify, copy, or redistribute it subject to the terms and 
   * conditions of the GNU Lesser General Public License, as published 
   * by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of 
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   * Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public 
   * License along with this distribution; if not, write to:
   * 
   * Free Software Foundation, Inc.
   * 51 Franklin Street, Fifth Floor
   * Boston, MA  02110-1301  USA
   */
 
 package org.hibernate.test.annotations.subselect;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.test.annotations.TestCase;
 
 
 /**
  * @author Sharath Reddy
  */
 public class SubselectTest extends TestCase {
 
 	public void testSubselectWithSynchronize() {
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
-		tx.begin();
-		
+
 		//We don't use auto-generated ids because these seem to cause the session to flush.
 		//We want to test that the session flushes because of the 'synchronize' annotation
 		long itemId = 1;
 		Item item = new Item();
 		item.setName("widget");
 		item.setId(itemId);
 		s.save(item);
 		
 		Bid bid1 = new Bid();
 		bid1.setAmount(100.0);
 		bid1.setItemId(itemId);
 		bid1.setId(1);
 		s.save(bid1);
 		
 		Bid bid2 = new Bid();
 		bid2.setAmount(200.0);
 		bid2.setItemId(itemId);
 		bid2.setId(2);
 		s.save(bid2);
 		
 		//Because we use 'synchronize' annotation, this query should trigger session flush
 		Query query = s.createQuery("from HighestBid b where b.name = :name");
 		query.setParameter("name", "widget", Hibernate.STRING);
 		HighestBid highestBid = (HighestBid) query.list().iterator().next();
 		
 		assertEquals(200.0, highestBid.getAmount());
 		tx.rollback();		
 		s.close();	
 		
 		
 	}
 	
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[]{
 				Item.class,
 				Bid.class,
 				HighestBid.class
 		};
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/JournalingBatchObserver.java b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingBatchObserver.java
new file mode 100644
index 0000000000..bf9edee45e
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingBatchObserver.java
@@ -0,0 +1,57 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common;
+
+import org.hibernate.engine.jdbc.batch.spi.BatchObserver;
+
+/**
+ * @author Steve Ebersole
+ */
+public class JournalingBatchObserver implements BatchObserver {
+	private int implicitExecutionCount;
+	private int explicitExecutionCount;
+
+	@Override
+	public void batchExplicitlyExecuted() {
+		explicitExecutionCount++;
+	}
+
+	@Override
+	public void batchImplicitlyExecuted() {
+		implicitExecutionCount++;
+	}
+
+	public int getImplicitExecutionCount() {
+		return implicitExecutionCount;
+	}
+
+	public int getExplicitExecutionCount() {
+		return explicitExecutionCount;
+	}
+
+	public void reset() {
+		explicitExecutionCount = 0;
+		implicitExecutionCount = 0;
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/JournalingConnectionObserver.java b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingConnectionObserver.java
new file mode 100644
index 0000000000..d804d8fc68
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingConnectionObserver.java
@@ -0,0 +1,74 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common;
+
+import org.hibernate.engine.jdbc.spi.ConnectionObserver;
+
+import java.sql.Connection;
+
+/**
+ * @author Steve Ebersole
+ */
+public class JournalingConnectionObserver implements ConnectionObserver {
+	private int physicalConnectionObtainedCount = 0;
+	private int physicalConnectionReleasedCount = 0;
+	private int logicalConnectionClosedCount = 0;
+	private int statementPreparedCount = 0;
+
+	@Override
+	public void physicalConnectionObtained(Connection connection) {
+		physicalConnectionObtainedCount++;
+	}
+
+	@Override
+	public void physicalConnectionReleased() {
+		physicalConnectionReleasedCount++;
+	}
+
+	@Override
+	public void logicalConnectionClosed() {
+		logicalConnectionClosedCount++;
+	}
+
+	@Override
+	public void statementPrepared() {
+		statementPreparedCount++;
+	}
+
+	public int getPhysicalConnectionObtainedCount() {
+		return physicalConnectionObtainedCount;
+	}
+
+	public int getPhysicalConnectionReleasedCount() {
+		return physicalConnectionReleasedCount;
+	}
+
+	public int getLogicalConnectionClosedCount() {
+		return logicalConnectionClosedCount;
+	}
+
+	public int getStatementPreparedCount() {
+		return statementPreparedCount;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transaction/WeblogicTransactionManagerLookup.java b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingTransactionObserver.java
similarity index 50%
rename from hibernate-core/src/main/java/org/hibernate/transaction/WeblogicTransactionManagerLookup.java
rename to hibernate-core/src/test/java/org/hibernate/test/common/JournalingTransactionObserver.java
index de500b64ff..68dd256e87 100644
--- a/hibernate-core/src/main/java/org/hibernate/transaction/WeblogicTransactionManagerLookup.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/JournalingTransactionObserver.java
@@ -1,50 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.transaction;
+package org.hibernate.test.common;
 
-/**
- * TransactionManager lookup strategy for WebLogic
- * @author Gavin King
- */
-public final class WeblogicTransactionManagerLookup extends JNDITransactionManagerLookup {
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.engine.transaction.spi.TransactionObserver;
 
-	/**
-	 * @see org.hibernate.transaction.JNDITransactionManagerLookup#getName()
-	 */
-	protected String getName() {
-		return "javax.transaction.TransactionManager";
+/**
+* @author Steve Ebersole
+*/
+public class JournalingTransactionObserver implements TransactionObserver {
+	private int begins = 0;
+	private int beforeCompletions = 0;
+	private int afterCompletions = 0;
+
+	public void afterBegin(TransactionImplementor transaction) {
+		begins++;
 	}
 
-	public String getUserTransactionName() {
-		return "javax.transaction.UserTransaction";
+	public void beforeCompletion(TransactionImplementor transaction) {
+		beforeCompletions++;
 	}
 
-}
-
-
-
+	public void afterCompletion(boolean successful, TransactionImplementor transaction) {
+		afterCompletions++;
+	}
 
+	public int getBegins() {
+		return begins;
+	}
 
+	public int getBeforeCompletions() {
+		return beforeCompletions;
+	}
 
+	public int getAfterCompletions() {
+		return afterCompletions;
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/TransactionContextImpl.java b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionContextImpl.java
new file mode 100644
index 0000000000..1557f81995
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionContextImpl.java
@@ -0,0 +1,95 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+
+/**
+ * @author Steve Ebersole
+ */
+public class TransactionContextImpl implements TransactionContext {
+	private final TransactionEnvironment transactionEnvironment;
+
+	public TransactionContextImpl(TransactionEnvironment transactionEnvironment) {
+		this.transactionEnvironment = transactionEnvironment;
+	}
+
+	@Override
+	public TransactionEnvironment getTransactionEnvironment() {
+		return transactionEnvironment;
+	}
+
+	@Override
+	public ConnectionReleaseMode getConnectionReleaseMode() {
+		return transactionEnvironment.getTransactionFactory().getDefaultReleaseMode();
+	}
+
+	@Override
+	public boolean isAutoCloseSessionEnabled() {
+		return false;
+	}
+
+	@Override
+	public boolean isClosed() {
+		return false;
+	}
+
+	@Override
+	public boolean isFlushModeNever() {
+		return false;
+	}
+
+	@Override
+	public boolean isFlushBeforeCompletionEnabled() {
+		return true;
+	}
+
+	@Override
+	public void managedFlush() {
+	}
+
+	@Override
+	public boolean shouldAutoClose() {
+		return false;
+	}
+
+	@Override
+	public void managedClose() {
+	}
+
+	@Override
+	public void afterTransactionBegin(TransactionImplementor hibernateTransaction) {
+	}
+
+	@Override
+	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction) {
+	}
+
+	@Override
+	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful) {
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java
new file mode 100644
index 0000000000..82a3b2ba5d
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java
@@ -0,0 +1,63 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common;
+
+import org.hibernate.cfg.NotYetImplementedException;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
+import org.hibernate.engine.transaction.spi.TransactionEnvironment;
+import org.hibernate.engine.transaction.spi.TransactionFactory;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
+
+/**
+ * @author Steve Ebersole
+ */
+public class TransactionEnvironmentImpl implements TransactionEnvironment {
+	private final ServiceRegistry serviceRegistry;
+
+	public TransactionEnvironmentImpl(ServiceRegistry serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
+	}
+
+	@Override
+	public SessionFactoryImplementor getSessionFactory() {
+		throw new NotYetImplementedException( "Not available in this context" );
+	}
+
+	@Override
+	public JdbcServices getJdbcServices() {
+		return serviceRegistry.getService( JdbcServices.class );
+	}
+
+	@Override
+	public JtaPlatform getJtaPlatform() {
+		return serviceRegistry.getService( JtaPlatform.class );
+	}
+
+	@Override
+	public TransactionFactory getTransactionFactory() {
+		return serviceRegistry.getService( TransactionFactory.class );
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosDataSourceConnectionProvider.java b/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosDataSourceConnectionProvider.java
new file mode 100644
index 0000000000..bbb0fcbdda
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosDataSourceConnectionProvider.java
@@ -0,0 +1,82 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common.jta;
+
+import org.hibernate.service.internal.ServiceProxy;
+import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.ServiceRegistryAwareService;
+import org.hibernate.service.spi.UnknownUnwrapTypeException;
+
+import javax.sql.DataSource;
+import java.sql.Connection;
+import java.sql.SQLException;
+
+/**
+ * @author Steve Ebersole
+ */
+public class AtomikosDataSourceConnectionProvider implements ConnectionProvider, ServiceRegistryAwareService {
+	private DataSource dataSource;
+
+	@Override
+	public Connection getConnection() throws SQLException {
+		return dataSource.getConnection();
+	}
+
+	@Override
+	public void closeConnection(Connection conn) throws SQLException {
+		conn.close();
+	}
+
+	@Override
+	public boolean supportsAggressiveRelease() {
+		return true;
+	}
+
+	@Override
+	public boolean isUnwrappableAs(Class unwrapType) {
+		return ConnectionProvider.class.equals( unwrapType )
+				|| unwrapType.isInstance( this )
+				|| DataSource.class.isAssignableFrom( unwrapType );
+	}
+
+	@Override
+	@SuppressWarnings( {"unchecked"})
+	public <T> T unwrap(Class<T> unwrapType) {
+		if ( ConnectionProvider.class.equals( unwrapType ) || unwrapType.isInstance( this ) ) {
+			return (T) this;
+		}
+		if ( DataSource.class.isAssignableFrom( unwrapType ) ) {
+			return (T) dataSource;
+		}
+		throw new UnknownUnwrapTypeException( unwrapType );
+	}
+
+	@Override
+	public void injectServices(ServiceRegistry serviceRegistry) {
+		AtomikosJtaPlatform jtaPlatform = (AtomikosJtaPlatform) ( (ServiceProxy) serviceRegistry.getService( JtaPlatform.class ) ).getTargetInstance();
+		dataSource = jtaPlatform.getDataSource();
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosJtaPlatform.java b/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosJtaPlatform.java
new file mode 100644
index 0000000000..9a41bb6752
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/jta/AtomikosJtaPlatform.java
@@ -0,0 +1,129 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.common.jta;
+
+import com.atomikos.icatch.jta.UserTransactionImp;
+import com.atomikos.icatch.jta.UserTransactionManager;
+import com.atomikos.jdbc.nonxa.AtomikosNonXADataSourceBean;
+
+import org.hibernate.service.internal.ServiceProxy;
+import org.hibernate.service.jta.platform.internal.AbstractJtaPlatform;
+import org.hibernate.service.jta.platform.internal.JtaSynchronizationStrategy;
+import org.hibernate.service.jta.platform.internal.TransactionManagerBasedSynchronizationStrategy;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.Startable;
+import org.hibernate.service.spi.Stoppable;
+import org.hibernate.test.common.ConnectionProviderBuilder;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.sql.DataSource;
+import javax.transaction.SystemException;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+/**
+ * @author Steve Ebersole
+ */
+public class AtomikosJtaPlatform extends AbstractJtaPlatform implements Startable, Stoppable {
+	private static final Logger log = LoggerFactory.getLogger( AtomikosJtaPlatform.class );
+
+	private final JtaSynchronizationStrategy synchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
+
+	private UserTransactionManager transactionManager;
+	private AtomikosNonXADataSourceBean dataSourceBean;
+
+	public DataSource getDataSource() {
+		return dataSourceBean;
+	}
+
+	@Override
+	protected TransactionManager locateTransactionManager() {
+		return transactionManager;
+	}
+
+	@Override
+	protected UserTransaction locateUserTransaction() {
+		return new UserTransactionImp();
+	}
+
+	@Override
+	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
+		return synchronizationStrategy;
+	}
+
+	@Override
+	public void start() {
+		if ( transactionManager == null ) {
+			transactionManager = new UserTransactionManager();
+			try {
+				transactionManager.init();
+			}
+			catch (Exception e) {
+				throw new JtaPlatformException( "Unable to init Atomikos UserTransactionManager", e );
+			}
+		}
+
+		if ( dataSourceBean == null ) {
+			// todo : extract sys props to handle functional testing...
+			dataSourceBean = new AtomikosNonXADataSourceBean();
+			dataSourceBean.setUniqueResourceName( "h2" );
+			dataSourceBean.setDriverClassName( ConnectionProviderBuilder.DRIVER );
+			dataSourceBean.setUrl( ConnectionProviderBuilder.URL );
+			dataSourceBean.setUser( ConnectionProviderBuilder.USER );
+			dataSourceBean.setPassword( ConnectionProviderBuilder.PASS );
+			dataSourceBean.setPoolSize( 3 );
+			try {
+				dataSourceBean.init();
+			}
+			catch (Exception e) {
+				throw new JtaPlatformException( "Unable to init Atomikos DataSourceBean", e );
+			}
+		}
+	}
+
+	@Override
+	public void stop() {
+		if ( dataSourceBean != null ) {
+			try {
+				dataSourceBean.close();
+			}
+			catch (Exception e) {
+				log.debug( "Error closing DataSourceBean", e );
+			}
+		}
+
+		if ( transactionManager != null ) {
+			try {
+				transactionManager.close();
+			}
+			catch (Exception e) {
+				log.debug( "Error closing UserTransactionManager", e );
+			}
+		}
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java b/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
index a46f1a10f3..a5bb35f5c1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
@@ -1,255 +1,276 @@
 // $Id: AggressiveReleaseTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.connections;
 
-import java.sql.Connection;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
 import junit.framework.Test;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Hibernate;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
+import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.impl.SessionImpl;
+import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.test.common.jta.AtomikosDataSourceConnectionProvider;
+import org.hibernate.test.common.jta.AtomikosJtaPlatform;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
-import org.hibernate.testing.tm.ConnectionProviderImpl;
-import org.hibernate.testing.tm.SimpleJtaTransactionManagerImpl;
-import org.hibernate.testing.tm.TransactionManagerLookupImpl;
-import org.hibernate.transaction.CMTTransactionFactory;
 import org.hibernate.util.SerializationHelper;
 
+import java.sql.Connection;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 /**
  * Implementation of AggressiveReleaseTest.
  *
  * @author Steve Ebersole
  */
 public class AggressiveReleaseTest extends ConnectionManagementTestCase {
 
 	public AggressiveReleaseTest(String name) {
 		super( name );
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( AggressiveReleaseTest.class );
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
-		cfg.setProperty( Environment.CONNECTION_PROVIDER, ConnectionProviderImpl.class.getName() );
-		cfg.setProperty( Environment.TRANSACTION_MANAGER_STRATEGY, TransactionManagerLookupImpl.class.getName() );
+		cfg.getProperties().put( JtaPlatformInitiator.JTA_PLATFORM, AtomikosJtaPlatform.class.getName() );
+		cfg.getProperties().put( Environment.CONNECTION_PROVIDER, AtomikosDataSourceConnectionProvider.class.getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
 		cfg.setProperty( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.AFTER_STATEMENT.toString() );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	protected Session getSessionUnderTest() throws Throwable {
 		return openSession();
 	}
 
 	protected void reconnect(Session session) {
 		session.reconnect();
 	}
 
 	protected void prepare() throws Throwable {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 	}
 
 	protected void done() throws Throwable {
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	// Some additional tests specifically for the aggressive-release functionality...
 
 	public void testSerializationOnAfterStatementAggressiveRelease() throws Throwable {
 		prepare();
-		Session s = getSessionUnderTest();
-		Silly silly = new Silly( "silly" );
-		s.save( silly );
+		try {
+			Session s = getSessionUnderTest();
+			Silly silly = new Silly( "silly" );
+			s.save( silly );
 
-		// this should cause the CM to obtain a connection, and then release it
-		s.flush();
+			// this should cause the CM to obtain a connection, and then release it
+			s.flush();
 
-		// We should be able to serialize the session at this point...
-		SerializationHelper.serialize( s );
+			// We should be able to serialize the session at this point...
+			SerializationHelper.serialize( s );
 
-		s.delete( silly );
-		s.flush();
+			s.delete( silly );
+			s.flush();
 
-		release( s );
-		done();
+			release( s );
+		}
+		finally {
+			done();
+		}
 	}
 
 	public void testSerializationFailsOnAfterStatementAggressiveReleaseWithOpenResources() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 
 		// this should cause the CM to obtain a connection, and then release it
 		s.flush();
 
 		// both scroll() and iterate() cause the batcher to hold on
 		// to resources, which should make aggresive-release not release
 		// the connection (and thus cause serialization to fail)
 		ScrollableResults sr = s.createQuery( "from Silly" ).scroll();
 
 		try {
 			SerializationHelper.serialize( s );
 			fail( "Serialization allowed on connected session; or aggressive release released connection with open resources" );
 		}
 		catch( IllegalStateException e ) {
 			// expected behavior
 		}
 
 		// getting the first row only because SybaseASE15Dialect throws NullPointerException
 		// if data is not read before closing the ResultSet
 		sr.next();
 
 		// Closing the ScrollableResults does currently force the batcher to
 		// aggressively release the connection
 		sr.close();
 		SerializationHelper.serialize( s );
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	public void testQueryIteration() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 		s.flush();
 
 		Iterator itr = s.createQuery( "from Silly" ).iterate();
 		assertTrue( itr.hasNext() );
 		Silly silly2 = ( Silly ) itr.next();
 		assertEquals( silly, silly2 );
 		Hibernate.close( itr );
 
 		itr = s.createQuery( "from Silly" ).iterate();
 		Iterator itr2 = s.createQuery( "from Silly where name = 'silly'" ).iterate();
 
 		assertTrue( itr.hasNext() );
 		assertEquals( silly, itr.next() );
 		assertTrue( itr2.hasNext() );
 		assertEquals( silly, itr2.next() );
 
 		Hibernate.close( itr );
 		Hibernate.close( itr2 );
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	public void testQueryScrolling() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 		s.flush();
 
 		ScrollableResults sr = s.createQuery( "from Silly" ).scroll();
 		assertTrue( sr.next() );
 		Silly silly2 = ( Silly ) sr.get( 0 );
 		assertEquals( silly, silly2 );
 		sr.close();
 
 		sr = s.createQuery( "from Silly" ).scroll();
 		ScrollableResults sr2 = s.createQuery( "from Silly where name = 'silly'" ).scroll();
 
 		assertTrue( sr.next() );
 		assertEquals( silly, sr.get( 0 ) );
 		assertTrue( sr2.next() );
 		assertEquals( silly, sr2.get( 0 ) );
 
 		sr.close();
 		sr2.close();
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	public void testSuppliedConnection() throws Throwable {
 		prepare();
 
-		Connection originalConnection = ConnectionProviderImpl.getActualConnectionProvider().getConnection();
+		Connection originalConnection = sfi().getServiceRegistry().getService( ConnectionProvider.class ).getConnection();
 		Session session = getSessions().openSession( originalConnection );
 
 		Silly silly = new Silly( "silly" );
 		session.save( silly );
 
 		// this will cause the connection manager to cycle through the aggressive release logic;
 		// it should not release the connection since we explicitly suplied it ourselves.
 		session.flush();
-
-		assertTrue( "Different connections", originalConnection == session.connection() );
+		assertTrue( session.isConnected() );
 
 		session.delete( silly );
 		session.flush();
 
 		release( session );
 		done();
 
-		ConnectionProviderImpl.getActualConnectionProvider().closeConnection( originalConnection );
+		sfi().getServiceRegistry().getService( ConnectionProvider.class ).closeConnection( originalConnection );
 	}
 
 	public void testBorrowedConnections() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 
+		// todo : may need to come back here and make sure that closing the connection handles do not close the physical cached connection on LogicalConnection...
+
 		Connection conn = s.connection();
-		assertTrue( ( ( SessionImpl ) s ).getJDBCContext().getConnectionManager().hasBorrowedConnection() );
+		assertFalse( conn.isClosed() );
+		assertFalse(
+				((SessionImpl) s).getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getLogicalConnection()
+						.isPhysicallyConnected()
+		);
+		conn.getCatalog();
+		assertTrue(
+				((SessionImpl) s).getTransactionCoordinator()
+						.getJdbcCoordinator()
+						.getLogicalConnection()
+						.isPhysicallyConnected()
+		);
 		conn.close();
-		assertFalse( ( ( SessionImpl ) s ).getJDBCContext().getConnectionManager().hasBorrowedConnection() );
+		assertTrue( conn.isClosed() );
+		assertTrue( ( ( SessionImpl ) s ).getTransactionCoordinator().getJdbcCoordinator().getLogicalConnection().isPhysicallyConnected() );
 
 		release( s );
 		done();
 	}
 
 	public void testConnectionMaintanenceDuringFlush() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		s.beginTransaction();
 
 		List entities = new ArrayList();
 		for ( int i = 0; i < 10; i++ ) {
 			Other other = new Other( "other-" + i );
 			Silly silly = new Silly( "silly-" + i, other );
 			entities.add( silly );
 			s.save( silly );
 		}
 		s.flush();
 
 		Iterator itr = entities.iterator();
 		while ( itr.hasNext() ) {
 			Silly silly = ( Silly ) itr.next();
 			silly.setName( "new-" + silly.getName() );
 			silly.getOther().setName( "new-" + silly.getOther().getName() );
 		}
 		long initialCount = getSessions().getStatistics().getConnectCount();
 		s.flush();
 		assertEquals( "connection not maintained through flush", initialCount + 1, getSessions().getStatistics().getConnectCount() );
 
 		s.createQuery( "delete from Silly" ).executeUpdate();
 		s.createQuery( "delete from Other" ).executeUpdate();
 		s.getTransaction().commit();
 		release( s );
 		done();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/connections/CurrentSessionConnectionTest.java b/hibernate-core/src/test/java/org/hibernate/test/connections/CurrentSessionConnectionTest.java
index c570ad657f..de6adf5511 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/connections/CurrentSessionConnectionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/connections/CurrentSessionConnectionTest.java
@@ -1,31 +1,36 @@
 // $Id: CurrentSessionConnectionTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.connections;
 
 import junit.framework.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
 
 /**
  * Implementation of CurrentSessionConnectionTest.
  *
  * @author Steve Ebersole
  */
 public class CurrentSessionConnectionTest extends AggressiveReleaseTest {
 
 	public CurrentSessionConnectionTest(String name) {
 		super( name );
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( CurrentSessionConnectionTest.class );
 	}
 
 	protected Session getSessionUnderTest() throws Throwable {
 		return getSessions().getCurrentSession();
 	}
 
 	protected void release(Session session) {
 		// do nothing, txn synch should release session as part of current-session definition
 	}
+
+	@Override
+	public void testSerializationOnAfterStatementAggressiveRelease() throws Throwable {
+		super.testSerializationOnAfterStatementAggressiveRelease();
+	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/exception/SQLExceptionConversionTest.java b/hibernate-core/src/test/java/org/hibernate/test/exception/SQLExceptionConversionTest.java
index 5fd330f94e..be245432a0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/exception/SQLExceptionConversionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/exception/SQLExceptionConversionTest.java
@@ -1,114 +1,108 @@
 // $Id: SQLExceptionConversionTest.java 11339 2007-03-23 12:51:38Z steve.ebersole@jboss.com $
 package org.hibernate.test.exception;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
 import junit.framework.Test;
 
 import org.hibernate.JDBCException;
 import org.hibernate.Session;
 import org.hibernate.dialect.MySQLMyISAMDialect;
 import org.hibernate.exception.ConstraintViolationException;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.exception.SQLGrammarException;
 import org.hibernate.testing.junit.functional.FunctionalTestCase;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
 import org.hibernate.util.JDBCExceptionReporter;
 
 /**
  * Implementation of SQLExceptionConversionTest.
  *
  * @author Steve Ebersole
  */
 public class SQLExceptionConversionTest extends FunctionalTestCase {
 
 	public SQLExceptionConversionTest(String name) {
 		super(name);
 	}
 
 	public String[] getMappings() {
 		return new String[] {"exception/User.hbm.xml", "exception/Group.hbm.xml"};
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite(SQLExceptionConversionTest.class);
 	}
 
 	public void testIntegrityViolation() throws Exception {
 		if ( getDialect() instanceof MySQLMyISAMDialect ) {
 			reportSkip( "MySQL (ISAM) does not support FK violation checking", "exception conversion" );
 			return;
 		}
 
 		SQLExceptionConverter converter = getDialect().buildSQLExceptionConverter();
 
 		Session session = openSession();
 		session.beginTransaction();
 		Connection connection = session.connection();
 
 		// Attempt to insert some bad values into the T_MEMBERSHIP table that should
 		// result in a constraint violation
 		PreparedStatement ps = null;
 		try {
 			ps = connection.prepareStatement("INSERT INTO T_MEMBERSHIP (user_id, group_id) VALUES (?, ?)");
 			ps.setLong(1, 52134241);    // Non-existent user_id
 			ps.setLong(2, 5342);        // Non-existent group_id
 			ps.executeUpdate();
 
 			fail("INSERT should have failed");
 		}
-		catch(SQLException sqle) {
-			JDBCExceptionReporter.logExceptions(sqle, "Just output!!!!");
-			JDBCException jdbcException = converter.convert(sqle, null, null);
-			assertEquals( "Bad conversion [" + sqle.getMessage() + "]", ConstraintViolationException.class , jdbcException.getClass() );
-			ConstraintViolationException ex = (ConstraintViolationException) jdbcException;
-			System.out.println("Violated constraint name: " + ex.getConstraintName());
+		catch (ConstraintViolationException expected) {
 		}
 		finally {
 			if ( ps != null ) {
 				try {
 					ps.close();
 				}
 				catch( Throwable ignore ) {
 					// ignore...
 				}
 			}
 		}
 
 		session.getTransaction().rollback();
 		session.close();
 	}
 
 	public void testBadGrammar() throws Exception {
 		SQLExceptionConverter converter = getDialect().buildSQLExceptionConverter();
 
 		Session session = openSession();
 		Connection connection = session.connection();
 
         // prepare/execute a query against a non-existent table
 		PreparedStatement ps = null;
 		try {
 			ps = connection.prepareStatement("SELECT user_id, user_name FROM tbl_no_there");
 			ps.executeQuery();
 
 			fail("SQL compilation should have failed");
 		}
-		catch( SQLException sqle ) {
-			assertEquals( "Bad conversion [" + sqle.getMessage() + "]", SQLGrammarException.class, converter.convert(sqle, null, null).getClass() );
+		catch (SQLGrammarException expected) {
 		}
 		finally {
 			if ( ps != null ) {
 				try {
 					ps.close();
 				}
 				catch( Throwable ignore ) {
 					// ignore...
 				}
 			}
 		}
 
 		session.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/insertordering/InsertOrderingTest.java b/hibernate-core/src/test/java/org/hibernate/test/insertordering/InsertOrderingTest.java
index 4df42c0a47..b5130784eb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/insertordering/InsertOrderingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/insertordering/InsertOrderingTest.java
@@ -1,128 +1,122 @@
 package org.hibernate.test.insertordering;
 
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.sql.PreparedStatement;
-
 import junit.framework.Test;
 
-import org.hibernate.engine.jdbc.batch.internal.BatchBuilder;
+import org.hibernate.Session;
+import org.hibernate.cfg.Configuration;
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;
+import org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator;
 import org.hibernate.engine.jdbc.batch.internal.BatchingBatch;
 import org.hibernate.engine.jdbc.batch.spi.Batch;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.test.common.JournalingBatchObserver;
 import org.hibernate.testing.junit.functional.FunctionalTestCase;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.Session;
-import org.hibernate.jdbc.Expectation;
+
+import java.sql.PreparedStatement;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
 
 /**
- * {@inheritDoc}
- *
  * @author Steve Ebersole
  */
 public class InsertOrderingTest extends FunctionalTestCase {
 	public InsertOrderingTest(String string) {
 		super( string );
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( InsertOrderingTest.class );
 	}
 
 	public String[] getMappings() {
 		return new String[] { "insertordering/Mapping.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.ORDER_INSERTS, "true" );
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "10" );
-		cfg.setProperty( Environment.BATCH_STRATEGY, StatsBatchBuilder.class.getName() );
+		cfg.setProperty( BatchBuilderInitiator.BUILDER, StatsBatchBuilder.class.getName() );
 	}
 
 	public void testBatchOrdering() {
 		Session s = openSession();
 		s.beginTransaction();
 		int iterations = 12;
 		for ( int i = 0; i < iterations; i++ ) {
 			User user = new User( "user-" + i );
 			Group group = new Group( "group-" + i );
 			s.save( user );
 			s.save( group );
 			user.addMembership( group );
 		}
 		StatsBatch.reset();
 		s.getTransaction().commit();
 		s.close();
 
 		assertEquals( 3, StatsBatch.batchSizes.size() );
 
 		s = openSession();
 		s.beginTransaction();
 		Iterator users = s.createQuery( "from User u left join fetch u.memberships m left join fetch m.group" ).list().iterator();
 		while ( users.hasNext() ) {
 			s.delete( users.next() );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public static class Counter {
 		public int count = 0;
 	}
 
 	public static class StatsBatch extends BatchingBatch {
 		private static String batchSQL;
 		private static List batchSizes = new ArrayList();
 		private static int currentBatch = -1;
 
-		public StatsBatch(Object key, SQLStatementLogger statementLogger, SQLExceptionHelper exceptionHelper, int jdbcBatchSize) {
-			super( key, statementLogger, exceptionHelper, jdbcBatchSize );
+		public StatsBatch(BatchKey key, JdbcCoordinator jdbcCoordinator, int jdbcBatchSize) {
+			super( key, jdbcCoordinator, jdbcBatchSize );
 		}
 
 		static void reset() {
 			batchSizes = new ArrayList();
 			currentBatch = -1;
 			batchSQL = null;
 		}
 
-		public void addBatchStatement(Object key, String sql, PreparedStatement ps) {
+		@Override
+		public PreparedStatement getBatchStatement(String sql, boolean callable) {
 			if ( batchSQL == null || ! batchSQL.equals( sql ) ) {
 				currentBatch++;
 				batchSQL = sql;
 				batchSizes.add( currentBatch, new Counter() );
-				System.out.println( "--------------------------------------------------------" );
-				System.out.println( "Preparing statement [" + sql + "]" );
 			}
-			super.addBatchStatement( key, sql, ps );
+			return super.getBatchStatement( sql, callable );
 		}
 
-		public void addToBatch(Object key, String sql, Expectation expectation) {
+		@Override
+		public void addToBatch() {
 			Counter counter = ( Counter ) batchSizes.get( currentBatch );
 			counter.count++;
-			System.out.println( "Adding to batch [" + batchSQL + "]" );
-			super.addToBatch( key, sql, expectation );
-		}
-
-		protected void doExecuteBatch() {
-			System.out.println( "executing batch [" + batchSQL + "]" );
-			System.out.println( "--------------------------------------------------------" );
-			super.doExecuteBatch();
+			super.addToBatch();
 		}
 	}
 
-	public static class StatsBatchBuilder extends BatchBuilder {
+	public static class StatsBatchBuilder extends BatchBuilderImpl {
 		private int jdbcBatchSize;
 
 		public void setJdbcBatchSize(int jdbcBatchSize) {
 			this.jdbcBatchSize = jdbcBatchSize;
 		}
-		public Batch buildBatch(Object key, SQLStatementLogger statementLogger, SQLExceptionHelper exceptionHelper) {
-			return new StatsBatch(key, statementLogger, exceptionHelper, jdbcBatchSize );
+
+		@Override
+		public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {
+			return new StatsBatch( key, jdbcCoordinator, jdbcBatchSize );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/AggressiveReleaseTest.java b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/AggressiveReleaseTest.java
index e32122b4ed..1acde23ec7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/AggressiveReleaseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/AggressiveReleaseTest.java
@@ -1,278 +1,245 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jdbc.proxies;
 
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.engine.jdbc.internal.LogicalConnectionImpl;
-import org.hibernate.engine.jdbc.spi.ConnectionObserver;
 import org.hibernate.engine.jdbc.internal.proxy.ProxyBuilder;
 import org.hibernate.test.common.BasicTestingJdbcServiceImpl;
+import org.hibernate.test.common.JournalingConnectionObserver;
 import org.hibernate.testing.junit.UnitTestCase;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class AggressiveReleaseTest extends UnitTestCase {
 
 	private static final Logger log = LoggerFactory.getLogger( AggressiveReleaseTest.class );
 	private BasicTestingJdbcServiceImpl services = new BasicTestingJdbcServiceImpl();
 
-	private static class ConnectionCounter implements ConnectionObserver {
-		public int obtainCount = 0;
-		public int releaseCount = 0;
-
-		public void physicalConnectionObtained(Connection connection) {
-			obtainCount++;
-		}
-
-		public void physicalConnectionReleased() {
-			releaseCount++;
-		}
-
-		public void logicalConnectionClosed() {
-		}
-	}
-
 	public AggressiveReleaseTest(String string) {
 		super( string );
 	}
 
 	public void setUp() throws SQLException {
 		services.prepare( true );
 
 		Connection connection = null;
 		Statement stmnt = null;
 		try {
 			connection = services.getConnectionProvider().getConnection();
 			stmnt = connection.createStatement();
 			stmnt.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			stmnt.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 		}
 		finally {
 			if ( stmnt != null ) {
 				try {
 					stmnt.close();
 				}
 				catch ( SQLException ignore ) {
 					log.warn( "could not close statement used to set up schema", ignore );
 				}
 			}
 			if ( connection != null ) {
 				try {
 					connection.close();
 				}
 				catch ( SQLException ignore ) {
 					log.warn( "could not close connection used to set up schema", ignore );
 				}
 			}
 		}
 	}
 
 	public void tearDown() throws SQLException {
 		Connection connection = null;
 		Statement stmnt = null;
 		try {
 			connection = services.getConnectionProvider().getConnection();
 			stmnt = connection.createStatement();
 			stmnt.execute( "drop table SANDBOX_JDBC_TST if exists" );
 		}
 		finally {
 			if ( stmnt != null ) {
 				try {
 					stmnt.close();
 				}
 				catch ( SQLException ignore ) {
 					log.warn( "could not close statement used to set up schema", ignore );
 				}
 			}
 			if ( connection != null ) {
 				try {
 					connection.close();
 				}
 				catch ( SQLException ignore ) {
 					log.warn( "could not close connection used to set up schema", ignore );
 				}
 			}
 		}
 
 		services.release();
 	}
 
 	public void testBasicRelease() {
-		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
-				null,
-				ConnectionReleaseMode.AFTER_STATEMENT,
-				services,
-				null
-		);
+		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl( null, ConnectionReleaseMode.AFTER_STATEMENT, services );
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
-		ConnectionCounter observer = new ConnectionCounter();
+		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 		logicalConnection.addObserver( observer );
 
 		try {
 			PreparedStatement ps = proxiedConnection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 0, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		finally {
 			logicalConnection.close();
 		}
 
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 	}
 
 	public void testReleaseCircumventedByHeldResources() {
-		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
-				null,
-				ConnectionReleaseMode.AFTER_STATEMENT,
-				services,
-				null
-		);
+		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl( null, ConnectionReleaseMode.AFTER_STATEMENT, services );
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
-		ConnectionCounter observer = new ConnectionCounter();
+		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 		logicalConnection.addObserver( observer );
 
 		try {
 			PreparedStatement ps = proxiedConnection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 0, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 
 			// open a result set and hold it open...
 			ps = proxiedConnection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 2, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 
 			// open a second result set
 			PreparedStatement ps2 = proxiedConnection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps2.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 2, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 			// and close it...
 			ps2.close();
 			// the release should be circumvented...
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 2, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 
 			// let the close of the logical connection below release all resources (hopefully)...
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		finally {
 			logicalConnection.close();
 		}
 
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-		assertEquals( 2, observer.obtainCount );
-		assertEquals( 2, observer.releaseCount );
+		assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+		assertEquals( 2, observer.getPhysicalConnectionReleasedCount() );
 	}
 
 	public void testReleaseCircumventedManually() {
-		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
-				null,
-				ConnectionReleaseMode.AFTER_STATEMENT,
-				services,
-				null
-		);
+		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl( null, ConnectionReleaseMode.AFTER_STATEMENT, services );
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
-		ConnectionCounter observer = new ConnectionCounter();
+		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 		logicalConnection.addObserver( observer );
 
 		try {
 			PreparedStatement ps = proxiedConnection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 0, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 1, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 
 			// disable releases...
 			logicalConnection.disableReleases();
 
 			// open a result set...
 			ps = proxiedConnection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 2, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 			// and close it...
 			ps.close();
 			// the release should be circumvented...
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-			assertEquals( 2, observer.obtainCount );
-			assertEquals( 1, observer.releaseCount );
+			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 
 			// let the close of the logical connection below release all resources (hopefully)...
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		finally {
 			logicalConnection.close();
 		}
 
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
-		assertEquals( 2, observer.obtainCount );
-		assertEquals( 2, observer.releaseCount );
+		assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
+		assertEquals( 2, observer.getPhysicalConnectionReleasedCount() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BasicConnectionProxyTest.java b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BasicConnectionProxyTest.java
index 8107c1ea0b..30ba84c132 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BasicConnectionProxyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BasicConnectionProxyTest.java
@@ -1,148 +1,145 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jdbc.proxies;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.JDBCException;
 import org.hibernate.engine.jdbc.internal.LogicalConnectionImpl;
 import org.hibernate.engine.jdbc.internal.proxy.ProxyBuilder;
 import org.hibernate.test.common.BasicTestingJdbcServiceImpl;
 import org.hibernate.testing.junit.UnitTestCase;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class BasicConnectionProxyTest extends UnitTestCase {
 	private BasicTestingJdbcServiceImpl services = new BasicTestingJdbcServiceImpl();
 
 	public BasicConnectionProxyTest(String string) {
 		super( string );
 	}
 
 	public void setUp() {
 		services.prepare( false );
 	}
 
 	public void tearDown() {
 		services.release();
 	}
 
 	public void testDatabaseMetaDataHandling() throws Throwable {
 		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
 				null,
 				ConnectionReleaseMode.AFTER_TRANSACTION,
-				services,
-				null
+				services
 		);
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
 		try {
 			DatabaseMetaData metaData = proxiedConnection.getMetaData();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			ResultSet rs1 = metaData.getCatalogs();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			rs1.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			metaData.getCatalogs();
 			metaData.getSchemas();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		finally {
 			logicalConnection.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		}
 	}
 
 	public void testExceptionHandling() {
 		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
 				null,
 				ConnectionReleaseMode.AFTER_TRANSACTION,
-				services,
-				null
+				services
 		);
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
 		try {
 			proxiedConnection.prepareStatement( "select count(*) from NON_EXISTENT" ).executeQuery();
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		catch ( JDBCException ok ) {
 			// expected outcome
 		}
 		finally {
 			logicalConnection.close();
 		}
 	}
 
 	public void testBasicJdbcUsage() throws JDBCException {
 		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl(
 				null,
 				ConnectionReleaseMode.AFTER_TRANSACTION,
-				services,
-				null
+				services
 		);
 		Connection proxiedConnection = ProxyBuilder.buildConnection( logicalConnection );
 
 		try {
 			Statement stmnt = proxiedConnection.createStatement();
 			stmnt.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			stmnt.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 			stmnt.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
 
 			PreparedStatement ps = proxiedConnection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 
 			ps = proxiedConnection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : sqlexception" );
 		}
 		finally {
 			logicalConnection.close();
 		}
 
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java
new file mode 100644
index 0000000000..9fee757052
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java
@@ -0,0 +1,213 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.jdbc.proxies;
+
+import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
+import org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;
+import org.hibernate.engine.jdbc.batch.internal.BatchingBatch;
+import org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;
+import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.jdbc.Expectation;
+import org.hibernate.jdbc.Expectations;
+import org.hibernate.service.internal.ServiceRegistryImpl;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.StandardServiceInitiators;
+import org.hibernate.test.common.ConnectionProviderBuilder;
+import org.hibernate.test.common.JournalingBatchObserver;
+import org.hibernate.test.common.JournalingTransactionObserver;
+import org.hibernate.test.common.TransactionContextImpl;
+import org.hibernate.test.common.TransactionEnvironmentImpl;
+import org.hibernate.testing.junit.UnitTestCase;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.Statement;
+
+/**
+ * @author Steve Ebersole
+ */
+public class BatchingTest extends UnitTestCase implements BatchKey {
+	private ServiceRegistry serviceRegistry;
+
+	public BatchingTest(String string) {
+		super( string );
+	}
+
+	public void setUp() throws Exception {
+		super.setUp();
+		serviceRegistry = new ServiceRegistryImpl(
+				StandardServiceInitiators.LIST,
+				ConnectionProviderBuilder.getConnectionProviderProperties()
+		);
+	}
+
+	public void tearDown() throws Exception {
+		( (ServiceRegistryImpl) serviceRegistry).destroy();
+		super.tearDown();
+	}
+
+	@Override
+	public int getBatchedStatementCount() {
+		return 1;
+	}
+
+	@Override
+	public Expectation getExpectation() {
+		return Expectations.BASIC;
+	}
+
+	public void testNonBatchingUsage() throws Exception {
+		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) );
+
+		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
+		JournalingTransactionObserver observer = new JournalingTransactionObserver();
+		transactionCoordinator.addObserver( observer );
+
+		final JdbcCoordinator jdbcCoordinator = transactionCoordinator.getJdbcCoordinator();
+		LogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();
+		Connection connection = logicalConnection.getShareableConnectionProxy();
+
+		// set up some tables to use
+		Statement statement = connection.createStatement();
+		statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
+		statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
+		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+		assertTrue( logicalConnection.isPhysicallyConnected() );
+		statement.close();
+		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+		assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
+
+		// ok, now we can get down to it...
+		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
+		txn.begin();
+		assertEquals( 1, observer.getBegins() );
+
+		final String insertSql = "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )";
+
+		final BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );
+		final BatchKey batchKey = new BasicBatchKey( "this", Expectations.BASIC );
+		final Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );
+
+		final JournalingBatchObserver batchObserver = new JournalingBatchObserver();
+		insertBatch.addObserver( batchObserver );
+
+		assertTrue( "unexpected Batch impl", NonBatchingBatch.class.isInstance( insertBatch ) );
+		PreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );
+		insert.setLong( 1, 1 );
+		insert.setString( 2, "name" );
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
+		insertBatch.addToBatch();
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
+		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+		insertBatch.execute();
+		assertEquals( 1, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
+		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+		insertBatch.release();
+
+		txn.commit();
+		logicalConnection.close();
+	}
+
+	public void testBatchingUsage() throws Exception {
+		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) );
+
+		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
+		JournalingTransactionObserver transactionObserver = new JournalingTransactionObserver();
+		transactionCoordinator.addObserver( transactionObserver );
+
+		final JdbcCoordinator jdbcCoordinator = transactionCoordinator.getJdbcCoordinator();
+		LogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();
+		Connection connection = logicalConnection.getShareableConnectionProxy();
+
+		// set up some tables to use
+		Statement statement = connection.createStatement();
+		statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
+		statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
+		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+		assertTrue( logicalConnection.isPhysicallyConnected() );
+		statement.close();
+		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+		assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
+
+		// ok, now we can get down to it...
+		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
+		txn.begin();
+		assertEquals( 1, transactionObserver.getBegins() );
+
+		final BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );
+		final BatchKey batchKey = new BasicBatchKey( "this", Expectations.BASIC );
+		final Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );
+		assertTrue( "unexpected Batch impl", BatchingBatch.class.isInstance( insertBatch ) );
+
+		final JournalingBatchObserver batchObserver = new JournalingBatchObserver();
+		insertBatch.addObserver( batchObserver );
+
+		final String insertSql = "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )";
+
+		PreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );
+		insert.setLong( 1, 1 );
+		insert.setString( 2, "name" );
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
+		insertBatch.addToBatch();
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
+		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+		PreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );
+		assertSame( insert, insert2 );
+		insert = insert2;
+		insert.setLong( 1, 2 );
+		insert.setString( 2, "another name" );
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
+		insertBatch.addToBatch();
+		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
+		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+		insertBatch.execute();
+		assertEquals( 1, batchObserver.getExplicitExecutionCount() );
+		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
+		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+		insertBatch.release();
+
+		txn.commit();
+		logicalConnection.close();
+	}
+
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/manytomany/batchload/BatchedManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/manytomany/batchload/BatchedManyToManyTest.java
index ca66ad9aa1..1ce6885626 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/manytomany/batchload/BatchedManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/manytomany/batchload/BatchedManyToManyTest.java
@@ -1,181 +1,178 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.manytomany.batchload;
 
-import java.util.List;
-
-import junit.framework.Test;
 import junit.framework.Assert;
+import junit.framework.Test;
 
-import org.hibernate.engine.jdbc.batch.internal.BatchBuilder;
-import org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;
-import org.hibernate.engine.jdbc.batch.spi.Batch;
-import org.hibernate.engine.jdbc.spi.SQLExceptionHelper;
-import org.hibernate.engine.jdbc.spi.SQLStatementLogger;
-import org.hibernate.testing.junit.functional.FunctionalTestCase;
-import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.Session;
+import org.hibernate.EmptyInterceptor;
 import org.hibernate.Hibernate;
 import org.hibernate.Interceptor;
-import org.hibernate.EmptyInterceptor;
-import org.hibernate.stat.CollectionStatistics;
+import org.hibernate.Session;
+import org.hibernate.cfg.Configuration;
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;
+import org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;
+import org.hibernate.engine.jdbc.batch.spi.Batch;
+import org.hibernate.engine.jdbc.batch.spi.BatchKey;
+import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
+import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.loader.collection.BatchingCollectionInitializer;
 import org.hibernate.persister.collection.AbstractCollectionPersister;
+import org.hibernate.stat.CollectionStatistics;
+import org.hibernate.testing.junit.functional.FunctionalTestCase;
+import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
+
+import java.util.List;
 
 /**
  * Tests loading of many-to-many collection which should trigger
  * a batch load.
  *
  * @author Steve Ebersole
  */
 public class BatchedManyToManyTest extends FunctionalTestCase {
 	public BatchedManyToManyTest(String string) {
 		super( string );
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( BatchedManyToManyTest.class );
 	}
 
 	public String[] getMappings() {
 		return new String[] { "manytomany/batchload/UserGroupBatchLoad.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "false" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.BATCH_STRATEGY, TestingBatchBuilder.class.getName() );
 	}
 
-	public static class TestingBatchBuilder extends BatchBuilder {
-		private int jdbcBatchSize;
-
-		public void setJdbcBatchSize(int jdbcBatchSize) {
-			this.jdbcBatchSize = jdbcBatchSize;
-		}
-		public Batch buildBatch(Object key, SQLStatementLogger statementLogger, SQLExceptionHelper exceptionHelper) {
-			return new TestingBatch(key, statementLogger, exceptionHelper, jdbcBatchSize );
+	public static class TestingBatchBuilder extends BatchBuilderImpl {
+		@Override
+		public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {
+			return new TestingBatch( key, jdbcCoordinator );
 		}
 	}
 
 	public static class TestingBatch extends NonBatchingBatch {
-		public TestingBatch(Object key, SQLStatementLogger statementLogger, SQLExceptionHelper exceptionHelper, int jdbcBatchSize) {
-			super( key, statementLogger, exceptionHelper );
+		public TestingBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {
+			super( key, jdbcCoordinator );
 		}
 	}
 
 	public void testProperLoaderSetup() {
 		AbstractCollectionPersister cp = ( AbstractCollectionPersister )
 				sfi().getCollectionPersister( User.class.getName() + ".groups" );
 		assertClassAssignability( BatchingCollectionInitializer.class, cp.getInitializer().getClass() );
 		BatchingCollectionInitializer initializer = ( BatchingCollectionInitializer ) cp.getInitializer();
 		assertEquals( 50, findMaxBatchSize( initializer.getBatchSizes() ) );
 	}
 
 	private int findMaxBatchSize(int[] batchSizes) {
 		int max = 0;
 		for ( int size : batchSizes ) {
 			if ( size > max ) {
 				max = size;
 			}
 		}
 		return max;
 	}
 
 	public void testLoadingNonInverseSide() {
 		prepareTestData();
 
 		sfi().getStatistics().clear();
 		CollectionStatistics userGroupStats = sfi().getStatistics()
 				.getCollectionStatistics( User.class.getName() + ".groups" );
 		CollectionStatistics groupUserStats = sfi().getStatistics()
 				.getCollectionStatistics( Group.class.getName() + ".users" );
 
 		Interceptor testingInterceptor = new EmptyInterceptor() {
 			public String onPrepareStatement(String sql) {
 				// ugh, this is the best way I could come up with to assert this.
 				// unfortunately, this is highly dependent on the dialect and its
 				// outer join fragment.  But at least this wil fail on the majority
 				// of dialects...
 				Assert.assertFalse(
 						"batch load of many-to-many should use inner join",
 						sql.toLowerCase().contains( "left outer join" )
 				);
 				return super.onPrepareStatement( sql );
 			}
 		};
 
 		Session s = openSession( testingInterceptor );
 		s.beginTransaction();
 		List users = s.createQuery( "from User u" ).list();
 		User user = ( User ) users.get( 0 );
 		assertTrue( Hibernate.isInitialized( user ) );
 		assertTrue( Hibernate.isInitialized( user.getGroups() ) );
 		user = ( User ) users.get( 1 );
 		assertTrue( Hibernate.isInitialized( user ) );
 		assertTrue( Hibernate.isInitialized( user.getGroups() ) );
 		assertEquals( 1, userGroupStats.getFetchCount() ); // should have been just one fetch (the batch fetch)
 		assertEquals( 1, groupUserStats.getFetchCount() ); // should have been just one fetch (the batch fetch)
 		s.getTransaction().commit();
 		s.close();
 
 		cleanupTestData();
 	}
 
 	protected void prepareTestData() {
 		// set up the test data
 		User me = new User( "steve" );
 		User you = new User( "not steve" );
 		Group developers = new Group( "developers" );
 		Group translators = new Group( "translators" );
 		Group contributors = new Group( "contributors" );
 		me.getGroups().add( developers );
 		developers.getUsers().add( me );
 		you.getGroups().add( translators );
 		translators.getUsers().add( you );
 		you.getGroups().add( contributors );
 		contributors.getUsers().add( you );
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( me );
 		s.save( you );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	protected void cleanupTestData() {
 		// clean up the test data
 		Session s = openSession();
 		s.beginTransaction();
 		// User is the non-inverse side...
 		List<User> users = s.createQuery( "from User" ).list();
 		for ( User user : users ) {
 			s.delete( user );
 		}
 		s.flush();
 		s.createQuery( "delete Group" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/AbstractOperationTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/AbstractOperationTestCase.java
index 03bb8d760f..ffef92bea2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/AbstractOperationTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/AbstractOperationTestCase.java
@@ -1,130 +1,130 @@
 package org.hibernate.test.nonflushedchanges;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.NonFlushedChanges;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.StatefulPersistenceContext;
+import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.testing.junit.functional.FunctionalTestCase;
 import org.hibernate.testing.tm.ConnectionProviderImpl;
 import org.hibernate.testing.tm.TransactionManagerLookupImpl;
-import org.hibernate.transaction.CMTTransactionFactory;
 import org.hibernate.util.SerializationHelper;
 
 /**
  * {@inheritDoc}
  *
  * @author Steve Ebersole, Gail Badner (adapted this from "ops" tests version)
  */
 public abstract class AbstractOperationTestCase extends FunctionalTestCase {
 	private Map oldToNewEntityRefs = new HashMap();
 
 	public AbstractOperationTestCase(String name) {
 		super( name );
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, ConnectionProviderImpl.class.getName() );
 		cfg.setProperty( Environment.TRANSACTION_MANAGER_STRATEGY, TransactionManagerLookupImpl.class.getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
 		cfg.setProperty( Environment.AUTO_CLOSE_SESSION, "true" );
 		cfg.setProperty( Environment.FLUSH_BEFORE_COMPLETION, "true" );
 		cfg.setProperty( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.AFTER_STATEMENT.toString() );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	public String[] getMappings() {
 		return new String[] {
 				"nonflushedchanges/Node.hbm.xml",
 				"nonflushedchanges/Employer.hbm.xml",
 				"nonflushedchanges/OptLockEntity.hbm.xml",
 				"nonflushedchanges/OneToOne.hbm.xml",
 				"nonflushedchanges/Competition.hbm.xml"
 		};
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	protected void clearCounts() {
 		getSessions().getStatistics().clear();
 	}
 
 	protected void assertInsertCount(int expected) {
 		int inserts = ( int ) getSessions().getStatistics().getEntityInsertCount();
 		assertEquals( "unexpected insert count", expected, inserts );
 	}
 
 	protected void assertUpdateCount(int expected) {
 		int updates = ( int ) getSessions().getStatistics().getEntityUpdateCount();
 		assertEquals( "unexpected update counts", expected, updates );
 	}
 
 	protected void assertDeleteCount(int expected) {
 		int deletes = ( int ) getSessions().getStatistics().getEntityDeleteCount();
 		assertEquals( "unexpected delete counts", expected, deletes );
 	}
 
 	protected void assertFetchCount(int count) {
 		int fetches = ( int ) getSessions().getStatistics().getEntityFetchCount();
 		assertEquals( count, fetches );
 	}
 
 	protected Session applyNonFlushedChangesToNewSessionCloseOldSession(Session oldSession) {
 		NonFlushedChanges nfc = ( ( SessionImplementor ) oldSession ).getNonFlushedChanges();
 		byte[] bytes = SerializationHelper.serialize( nfc );
 		NonFlushedChanges nfc2 = ( NonFlushedChanges ) SerializationHelper.deserialize( bytes );
 		Session newSession = openSession();
 		( ( SessionImplementor ) newSession ).applyNonFlushedChanges( nfc2 );
 		oldToNewEntityRefs.clear();
 		for ( Iterator it = ( ( SessionImplementor ) oldSession ).getPersistenceContext()
 				.getEntitiesByKey()
 				.entrySet()
 				.iterator(); it.hasNext(); ) {
 			Map.Entry entry = ( Map.Entry ) it.next();
 			EntityKey entityKey = ( EntityKey ) entry.getKey();
 			Object oldEntityRef = entry.getValue();
 			oldToNewEntityRefs.put(
 					oldEntityRef, ( ( SessionImplementor ) newSession ).getPersistenceContext().getEntity( entityKey )
 			);
 		}
 		for ( Iterator it = ( ( StatefulPersistenceContext ) ( ( SessionImplementor ) oldSession ).getPersistenceContext() )
 				.getProxiesByKey()
 				.entrySet()
 				.iterator(); it.hasNext(); ) {
 			Map.Entry entry = ( Map.Entry ) it.next();
 			EntityKey entityKey = ( EntityKey ) entry.getKey();
 			Object oldProxyRef = entry.getValue();
 			oldToNewEntityRefs.put(
 					oldProxyRef, ( ( SessionImplementor ) newSession ).getPersistenceContext().getProxy( entityKey )
 			);
 		}
 
 		oldSession.clear();
 		oldSession.close();
 		return newSession;
 	}
 
 	protected void applyNonFlushedChangesToClearedSession(Session s) {
 		NonFlushedChanges nfc = ( ( SessionImplementor ) s ).getNonFlushedChanges();
 		byte[] bytes = SerializationHelper.serialize( nfc );
 		NonFlushedChanges nfc2 = ( NonFlushedChanges ) SerializationHelper.deserialize( bytes );
 		s.clear();
 		( ( SessionImplementor ) s ).applyNonFlushedChanges( nfc2 );
 	}
 
 	protected Map getOldToNewEntityRefMap() {
 		return Collections.unmodifiableMap( oldToNewEntityRefs );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java b/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
index 1f46942b64..7e1ca35733 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
@@ -1,218 +1,218 @@
 //$Id: CreateTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.ops;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
 import junit.framework.Test;
 
 import org.hibernate.PersistentObjectException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
 import org.hibernate.exception.ConstraintViolationException;
 
 /**
  * @author Gavin King
  */
 public class CreateTest extends AbstractOperationTestCase {
 
 	public CreateTest(String str) {
 		super( str );
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( CreateTest.class );
 	}
 
 	public void testNoUpdatesOnCreateVersionedWithCollection() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		VersionedEntity root = new VersionedEntity( "root", "root" );
 		VersionedEntity child = new VersionedEntity( "c1", "child-1" );
 		root.getChildren().add( child );
 		child.setParent( root );
 		s.save(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.delete( root );
 		tx.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	public void testCreateTree() {
 
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node root = new Node("root");
 		Node child = new Node("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		System.out.println("getting");
 		root = (Node) s.get(Node.class, "root");
 		Node child2 = new Node("child2");
 		root.addChild(child2);
 		System.out.println("committing");
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 	}
 
 	public void testCreateTreeWithGeneratedId() {
 
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode("root");
 		NumberedNode child = new NumberedNode("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = (NumberedNode) s.get( NumberedNode.class, new Long( root.getId() ) );
 		NumberedNode child2 = new NumberedNode("child2");
 		root.addChild(child2);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 	}
 
 	public void testCreateException() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node dupe = new Node("dupe");
 		s.persist(dupe);
 		s.persist(dupe);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist(dupe);
 		try {
 			tx.commit();
-			assertFalse(true);
+			fail( "Expecting constraint failure" );
 		}
 		catch (ConstraintViolationException cve) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 
 		Node nondupe = new Node("nondupe");
 		nondupe.addChild(dupe);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist(nondupe);
 		try {
 			tx.commit();
 			assertFalse(true);
 		}
 		catch (ConstraintViolationException cve) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	public void testCreateExceptionWithGeneratedId() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode dupe = new NumberedNode("dupe");
 		s.persist(dupe);
 		s.persist(dupe);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		try {
 			s.persist(dupe);
 			assertFalse(true);
 		}
 		catch (PersistentObjectException poe) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 
 		NumberedNode nondupe = new NumberedNode("nondupe");
 		nondupe.addChild(dupe);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		try {
 			s.persist(nondupe);
 			assertFalse(true);
 		}
 		catch (PersistentObjectException poe) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	public void testBasic() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		s.persist(ee);
 		Collection erColl = new ArrayList();
 		Collection eeColl = new ArrayList();
 		erColl.add(ee);
 		eeColl.add(er);
 		er.setEmployees(erColl);
 		ee.setEmployers(eeColl);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load(Employer.class, er.getId() );
 		assertNotNull(er);
 		assertNotNull( er.getEmployees() );
 		assertEquals( 1, er.getEmployees().size() );
 		Employee eeFromDb = (Employee) er.getEmployees().iterator().next();
 		assertEquals( ee.getId(), eeFromDb.getId() );
 		tx.commit();
 		s.close();
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlyProxyTest.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlyProxyTest.java
index 22e1b7a527..e2cba3b811 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlyProxyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlyProxyTest.java
@@ -498,1192 +498,1190 @@ public class ReadOnlyProxyTest extends AbstractReadOnlyTest {
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 
 	public void testReadOnlyViaLazyInitializerAfterInit() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		LazyInitializer dpLI = ( ( HibernateProxy ) dp ).getHibernateLazyInitializer();
 		assertTrue( dpLI.isUninitialized() );
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed" );
 		assertFalse( dpLI.isUninitialized() );
 		assertEquals( "changed", dp.getDescription() );
 		checkReadOnly( s, dp, false );
 		dpLI.setReadOnly( true );
 		checkReadOnly( s, dp, true );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testModifiableViaLazyInitializerAfterInit() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		LazyInitializer dpLI = ( ( HibernateProxy ) dp ).getHibernateLazyInitializer();
 		assertTrue( dpLI.isUninitialized() );
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed" );
 		assertFalse( dpLI.isUninitialized() );
 		assertEquals( "changed", dp.getDescription() );
 		checkReadOnly( s, dp, false );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testModifyToReadOnlyToModifiableIsUpdatedFailureExpected() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ));
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		s.setReadOnly( dp, false );
 		checkReadOnly( s, dp, false );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		try {
 			assertEquals( "changed", dp.getDescription() );
 			// should fail due to HHH-4642
 		}
 		finally {
 			s.getTransaction().rollback();
 			s.close();
 			s = openSession();
 			s.beginTransaction();			
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testReadOnlyModifiedToModifiableIsUpdatedFailureExpected() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ));
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.setReadOnly( dp, false );
 		checkReadOnly( s, dp, false );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		try {
 			assertEquals( "changed", dp.getDescription() );
 			// should fail due to HHH-4642
 		}
 		finally {
 			s.getTransaction().rollback();
 			s.close();
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testReadOnlyChangedEvictedUpdate() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ));
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.evict( dp );
 		assertFalse( s.contains( dp ) );
 		s.update( dp );
 		checkReadOnly( s, dp, false );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}	
 
 	public void testReadOnlyToModifiableInitWhenModifiedIsUpdated() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		s.setReadOnly( dp, false );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyInitToModifiableModifiedIsUpdated() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ));
 		checkReadOnly( s, dp,true );
 		s.setReadOnly( dp, false );
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyModifiedUpdate() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		assertFalse( Hibernate.isInitialized( dp ));
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		checkReadOnly( s, dp,true );
 		s.update( dp );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyDelete() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp,true );
 		assertFalse( Hibernate.isInitialized( dp ));
 		s.delete( dp );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertNull( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyRefresh() {
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		Transaction t = s.beginTransaction();
 		DataPoint dp = new DataPoint();
 		dp.setDescription( "original" );
 		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
 		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
 		s.save(dp);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		t = s.beginTransaction();
 		dp = ( DataPoint ) s.load( DataPoint.class, dp.getId() );
 		s.setReadOnly( dp, true );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		s.refresh( dp );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		assertEquals( "original", dp.getDescription() );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		dp.setDescription( "changed" );
 		assertEquals( "changed", dp.getDescription() );
 		assertTrue( s.isReadOnly( dp ) );
 		assertTrue( s.isReadOnly( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getImplementation() ) );
 		s.refresh( dp );
 		assertEquals( "original", dp.getDescription() );
 		dp.setDescription( "changed" );
 		assertEquals( "changed", dp.getDescription() );
 		assertTrue( s.isReadOnly( dp ) );
 		assertTrue( s.isReadOnly( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getImplementation() ) );
 		t.commit();
 
 		s.clear();
 		t = s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
 		assertEquals( "original", dp.getDescription() );
 		s.delete( dp );
 		t.commit();
 		s.close();
 	}
 
 
 	public void testReadOnlyRefreshDeleted() {
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		Transaction t = s.beginTransaction();
 		DataPoint dp = new DataPoint();
 		dp.setDescription( "original" );
 		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
 		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
 		s.save(dp);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		t = s.beginTransaction();
 		HibernateProxy dpProxy = ( HibernateProxy ) s.load( DataPoint.class, dp.getId() );
 		assertFalse( Hibernate.isInitialized( dpProxy ) );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		t = s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
 		s.delete( dp );
 		s.flush();
 		try {
 			s.refresh( dp );
 			fail( "should have thrown UnresolvableObjectException" );
 		}
 		catch ( UnresolvableObjectException ex ) {
 			// expected
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setCacheMode(CacheMode.IGNORE);
 		DataPoint dpProxyInit = ( DataPoint ) s.load( DataPoint.class, dp.getId() );
 		assertEquals( "original", dp.getDescription() );
 		s.delete( dpProxyInit );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( dpProxyInit instanceof HibernateProxy );
 		assertTrue( Hibernate.isInitialized( dpProxyInit ) );
 		try {
 			s.refresh( dpProxyInit );
 			fail( "should have thrown UnresolvableObjectException" );
 		}
 		catch ( UnresolvableObjectException ex ) {
 			// expected
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( dpProxy instanceof HibernateProxy );
 		try {
 			s.refresh( dpProxy );
 			assertFalse( Hibernate.isInitialized( dpProxy ) );
 			Hibernate.initialize( dpProxy );
 			fail( "should have thrown UnresolvableObjectException" );
 		}
 		catch ( UnresolvableObjectException ex ) {
 			// expected
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 	}
 
 	public void testReadOnlyRefreshDetached() {
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		Transaction t = s.beginTransaction();
 		DataPoint dp = new DataPoint();
 		dp.setDescription( "original" );
 		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
 		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
 		s.save(dp);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		t = s.beginTransaction();
 		dp = ( DataPoint ) s.load( DataPoint.class, dp.getId() );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		assertFalse( s.isReadOnly( dp ) );
 		s.setReadOnly( dp, true );
 		assertTrue( s.isReadOnly( dp ) );
 		s.evict( dp );
 		s.refresh( dp );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		assertFalse( s.isReadOnly( dp ) );
 		dp.setDescription( "changed" );
 		assertEquals( "changed", dp.getDescription() );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.setReadOnly( dp, true );
 		s.evict( dp );
 		s.refresh( dp );
 		assertEquals( "original", dp.getDescription() );
 		assertFalse( s.isReadOnly( dp ) );
 		t.commit();
 
 		s.clear();
 		t = s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
 		assertEquals( "original", dp.getDescription() );
 		s.delete( dp );
 		t.commit();
 		s.close();
 	}
 
 	public void testReadOnlyProxyMergeDetachedProxyWithChange() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.getTransaction().commit();
 		s.close();
 
 		// modify detached proxy
 		dp.setDescription( "changed" );
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dpLoaded = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dpLoaded instanceof HibernateProxy );
 		checkReadOnly( s, dpLoaded, false );
 		s.setReadOnly( dpLoaded, true );
 		checkReadOnly( s, dpLoaded,true );
 		assertFalse( Hibernate.isInitialized( dpLoaded ) );
 		DataPoint dpMerged = ( DataPoint ) s.merge( dp );
 		assertSame( dpLoaded, dpMerged );
 		assertTrue( Hibernate.isInitialized( dpLoaded ) );
 		assertEquals( "changed", dpLoaded.getDescription() );
 		checkReadOnly( s, dpLoaded, true );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyProxyInitMergeDetachedProxyWithChange() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.getTransaction().commit();
 		s.close();
 
 		// modify detached proxy
 		dp.setDescription( "changed" );
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dpLoaded = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dpLoaded instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dpLoaded ) );
 		Hibernate.initialize( dpLoaded );
 		assertTrue( Hibernate.isInitialized( dpLoaded ) );
 		checkReadOnly( s, dpLoaded, false );
 		s.setReadOnly( dpLoaded, true );
 		checkReadOnly( s, dpLoaded,true );
 		DataPoint dpMerged = ( DataPoint ) s.merge( dp );
 		assertSame( dpLoaded, dpMerged );
 		assertEquals( "changed", dpLoaded.getDescription() );
 		checkReadOnly( s, dpLoaded, true );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyProxyMergeDetachedEntityWithChange() {
 
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.getTransaction().commit();
 		s.close();
 
 		// modify detached proxy target
 		DataPoint dpEntity = ( DataPoint ) ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getImplementation();
 		dpEntity.setDescription( "changed" );
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dpLoaded = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dpLoaded instanceof HibernateProxy );
 		checkReadOnly( s, dpLoaded, false );
 		s.setReadOnly( dpLoaded, true );
 		checkReadOnly( s, dpLoaded,true );
 		assertFalse( Hibernate.isInitialized( dpLoaded ) );
 		DataPoint dpMerged = ( DataPoint ) s.merge( dpEntity );
 		assertSame( dpLoaded, dpMerged );
 		assertTrue( Hibernate.isInitialized( dpLoaded ) );
 		assertEquals( "changed", dpLoaded.getDescription() );
 		checkReadOnly( s, dpLoaded, true );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyProxyInitMergeDetachedEntityWithChange() {
 
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.getTransaction().commit();
 		s.close();
 
 		// modify detached proxy target
 		DataPoint dpEntity = ( DataPoint ) ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getImplementation();
 		dpEntity.setDescription( "changed" );
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dpLoaded = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dpLoaded instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dpLoaded ) );
 		Hibernate.initialize( dpLoaded );
 		assertTrue( Hibernate.isInitialized( dpLoaded ) );
 		checkReadOnly( s, dpLoaded, false );
 		s.setReadOnly( dpLoaded, true );
 		checkReadOnly( s, dpLoaded,true );
 		DataPoint dpMerged = ( DataPoint ) s.merge( dpEntity );
 		assertSame( dpLoaded, dpMerged );
 		assertEquals( "changed", dpLoaded.getDescription() );
 		checkReadOnly( s, dpLoaded, true );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testReadOnlyEntityMergeDetachedProxyWithChange() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		checkReadOnly( s, dp, false );
 		assertFalse( Hibernate.isInitialized( dp ));
 		Hibernate.initialize( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		s.getTransaction().commit();
 		s.close();
 
 		// modify detached proxy
 		dp.setDescription( "changed" );
 
 		s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 		s.beginTransaction();
 		DataPoint dpEntity = ( DataPoint ) s.get( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertFalse( dpEntity instanceof HibernateProxy );
 		assertFalse( s.isReadOnly( dpEntity ) );
 		s.setReadOnly( dpEntity, true );
 		assertTrue( s.isReadOnly( dpEntity ) );
 		DataPoint dpMerged = ( DataPoint ) s.merge( dp );
 		assertSame( dpEntity, dpMerged );
 		assertEquals( "changed", dpEntity.getDescription() );
 		assertTrue( s.isReadOnly( dpEntity ) );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testSetReadOnlyInTwoTransactionsSameSession() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp, true );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 
 		checkReadOnly( s, dp, true );
 
 		s.beginTransaction();
 		checkReadOnly( s, dp, true );
 		dp.setDescription( "changed again" );
 		assertEquals( "changed again", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testSetReadOnlyBetweenTwoTransactionsSameSession() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		checkReadOnly( s, dp, false );
 		s.flush();
 		s.getTransaction().commit();
 
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp, true );
 
 		s.beginTransaction();
 		checkReadOnly( s, dp, true );
 		dp.setDescription( "changed again" );
 		assertEquals( "changed again", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testSetModifiableBetweenTwoTransactionsSameSession() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.setReadOnly( dp, true );
 		checkReadOnly( s, dp, true );
 		dp.setDescription( "changed" );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "changed", dp.getDescription() );
 		checkReadOnly( s, dp, true );
 		s.flush();
 		s.getTransaction().commit();
 
 		checkReadOnly( s, dp, true );
 		s.setReadOnly( dp, false );
 		checkReadOnly( s, dp, false );
 
 		s.beginTransaction();
 		checkReadOnly( s, dp, false );
 		assertEquals( "changed", dp.getDescription() );
 		s.refresh( dp );
 		assertEquals( dpOrig.getDescription(), dp.getDescription() );
 		checkReadOnly( s, dp, false );
 		dp.setDescription( "changed again" );
 		assertEquals( "changed again", dp.getDescription() );
 		s.flush();
 		s.getTransaction().commit();
 
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		dp = ( DataPoint ) s.get( DataPoint.class, dpOrig.getId() );
 		assertEquals( dpOrig.getId(), dp.getId() );
 		assertEquals( "changed again", dp.getDescription() );
 		assertEquals( dpOrig.getX(), dp.getX() );
 		assertEquals( dpOrig.getY(), dp.getY() );
 		s.delete( dp );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void testIsReadOnlyAfterSessionClosed() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.getTransaction().commit();
 		s.close();
 
 		try {
  			s.isReadOnly( dp );
 			fail( "should have failed because session was closed" );
 		}
 		catch ( SessionException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testIsReadOnlyAfterSessionClosedViaLazyInitializer() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.getTransaction().commit();
 		assertTrue( s.contains( dp ) );
 		s.close();
 
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 		try {
  			( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnly();
 			fail( "should have failed because session was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 
 	public void testDetachedIsReadOnlyAfterEvictViaSession() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		assertTrue( s.contains( dp ) );
 		s.evict( dp );
 		assertFalse( s.contains( dp ) );
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 
 		try {
  			s.isReadOnly( dp );
 			fail( "should have failed because proxy was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testDetachedIsReadOnlyAfterEvictViaLazyInitializer() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.evict( dp );
 		assertFalse( s.contains( dp ) );
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 		try {
  			( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnly();
 			fail( "should have failed because proxy was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
-			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testSetReadOnlyAfterSessionClosed() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.getTransaction().commit();
 		s.close();
 
 		try {
  			s.setReadOnly( dp, true );
 			fail( "should have failed because session was closed" );
 		}
 		catch ( SessionException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testSetReadOnlyAfterSessionClosedViaLazyInitializer() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.getTransaction().commit();
 		assertTrue( s.contains( dp ) );
 		s.close();
 
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 		try {
  			( ( HibernateProxy ) dp ).getHibernateLazyInitializer().setReadOnly( true );
 			fail( "should have failed because session was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testSetClosedSessionInLazyInitializer() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.getTransaction().commit();
 		assertTrue( s.contains( dp ) );
 		s.close();
 
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 		assertTrue( ( ( SessionImplementor ) s ).isClosed() );
 		try {
 			( ( HibernateProxy ) dp ).getHibernateLazyInitializer().setSession( ( SessionImplementor ) s );			
 			fail( "should have failed because session was closed" );
 		}
 		catch ( SessionException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s = openSession();
 			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testDetachedSetReadOnlyAfterEvictViaSession() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		assertTrue( s.contains( dp ) );
 		s.evict( dp );
 		assertFalse( s.contains( dp ) );
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 
 		try {
  			s.setReadOnly( dp, true );
 			fail( "should have failed because proxy was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	public void testDetachedSetReadOnlyAfterEvictViaLazyInitializer() {
 		DataPoint dpOrig = createDataPoint( CacheMode.IGNORE );
 
 		Session s = openSession();
 		s.setCacheMode(CacheMode.IGNORE);
 
 		s.beginTransaction();
 		DataPoint dp = ( DataPoint ) s.load( DataPoint.class, new Long( dpOrig.getId() ) );
 		assertTrue( dp instanceof HibernateProxy );
 		assertFalse( Hibernate.isInitialized( dp ) );
 		checkReadOnly( s, dp, false );
 		s.evict( dp );
 		assertFalse( s.contains( dp ) );
 		assertNull( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().getSession() );
 		try {
  			( ( HibernateProxy ) dp ).getHibernateLazyInitializer().setReadOnly( true );
 			fail( "should have failed because proxy was detached" );
 		}
 		catch ( TransientObjectException ex) {
 			// expected
 			assertFalse( ( ( HibernateProxy ) dp ).getHibernateLazyInitializer().isReadOnlySettingAvailable() );
 		}
 		finally {
-			s.beginTransaction();
 			s.delete( dp );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	private DataPoint createDataPoint(CacheMode cacheMode) {
 		Session s = openSession();
 		s.setCacheMode( cacheMode );
 		s.beginTransaction();
 		DataPoint dp = new DataPoint();
 		dp.setX( new BigDecimal( 0.1d ).setScale(19, BigDecimal.ROUND_DOWN) );
 		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
 		dp.setDescription( "original" );
 		s.save( dp );
 		s.getTransaction().commit();
 		s.close();
 		return dp;
 	}
 
 	private void checkReadOnly(Session s, Object proxy, boolean expectedReadOnly) {
 		assertTrue( proxy instanceof HibernateProxy );
 		LazyInitializer li = ( ( HibernateProxy ) proxy ).getHibernateLazyInitializer();
 		assertSame( s, li.getSession() );
 		assertEquals( expectedReadOnly, s.isReadOnly( proxy ) );
 		assertEquals( expectedReadOnly, li.isReadOnly() );
 		assertEquals( Hibernate.isInitialized( proxy ), ! li.isUninitialized() );
 		if ( Hibernate.isInitialized( proxy ) ) {
 			assertEquals( expectedReadOnly, s.isReadOnly( li.getImplementation() ) );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/tm/CMTTest.java b/hibernate-core/src/test/java/org/hibernate/test/tm/CMTTest.java
index ee4c15e577..67c52d680e 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/tm/CMTTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/tm/CMTTest.java
@@ -1,517 +1,518 @@
 //$Id: CMTTest.java 11303 2007-03-19 22:06:14Z steve.ebersole@jboss.com $
 package org.hibernate.test.tm;
 
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import javax.transaction.Transaction;
-
 import junit.framework.Test;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.criterion.Order;
+import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
+import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.test.common.jta.AtomikosDataSourceConnectionProvider;
+import org.hibernate.test.common.jta.AtomikosJtaPlatform;
 import org.hibernate.testing.junit.functional.FunctionalTestCase;
 import org.hibernate.testing.junit.functional.FunctionalTestClassTestSuite;
-import org.hibernate.testing.tm.ConnectionProviderImpl;
-import org.hibernate.testing.tm.SimpleJtaTransactionManagerImpl;
-import org.hibernate.testing.tm.TransactionManagerLookupImpl;
-import org.hibernate.transaction.CMTTransactionFactory;
 import org.hibernate.util.SerializationHelper;
 
+import javax.transaction.Transaction;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
 /**
  * @author Gavin King
  */
 public class CMTTest extends FunctionalTestCase {
 
 	public CMTTest(String str) {
 		super( str );
 	}
 
 	public String[] getMappings() {
 		return new String[] { "tm/Item.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
-		cfg.setProperty( Environment.CONNECTION_PROVIDER, ConnectionProviderImpl.class.getName() );
-		cfg.setProperty( Environment.TRANSACTION_MANAGER_STRATEGY, TransactionManagerLookupImpl.class.getName() );
+		cfg.getProperties().put( JtaPlatformInitiator.JTA_PLATFORM, AtomikosJtaPlatform.class.getName() );
+		cfg.getProperties().put( Environment.CONNECTION_PROVIDER, AtomikosDataSourceConnectionProvider.class.getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
 		cfg.setProperty( Environment.AUTO_CLOSE_SESSION, "true" );
 		cfg.setProperty( Environment.FLUSH_BEFORE_COMPLETION, "true" );
 		cfg.setProperty( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.AFTER_STATEMENT.toString() );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "true" );
 		cfg.setProperty( Environment.DEFAULT_ENTITY_MODE, EntityMode.MAP.toString() );
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return "transactional";
 	}
 
 	public static Test suite() {
 		return new FunctionalTestClassTestSuite( CMTTest.class );
 	}
 
 	public void testConcurrent() throws Exception {
 		getSessions().getStatistics().clear();
 		assertNotNull( sfi().getEntityPersister( "Item" ).getCacheAccessStrategy() );
 		assertEquals( 0, getSessions().getStatistics().getEntityLoadCount() );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
 		Map foo = new HashMap();
 		foo.put( "name", "Foo" );
 		foo.put( "description", "a big foo" );
 		s.persist( "Item", foo );
 		Map bar = new HashMap();
 		bar.put( "name", "Bar" );
 		bar.put( "description", "a small bar" );
 		s.persist( "Item", bar );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		getSessions().evictEntity( "Item" );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s1 = openSession();
 		foo = ( Map ) s1.get( "Item", "Foo" );
 		//foo.put("description", "a big red foo");
 		//s1.flush();
-		Transaction tx1 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		Transaction tx1 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s2 = openSession();
 		foo = ( Map ) s2.get( "Item", "Foo" );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx1 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx1 );
 		tx1.commit();
 
 		getSessions().evictEntity( "Item" );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s1 = openSession();
 		s1.createCriteria( "Item" ).list();
 		//foo.put("description", "a big red foo");
 		//s1.flush();
-		tx1 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		tx1 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s2 = openSession();
 		s2.createCriteria( "Item" ).list();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx1 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx1 );
 		tx1.commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s2 = openSession();
 		s2.createCriteria( "Item" ).list();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		assertEquals( 7, getSessions().getStatistics().getEntityLoadCount() );
 		assertEquals( 0, getSessions().getStatistics().getEntityFetchCount() );
 		assertEquals( 3, getSessions().getStatistics().getQueryExecutionCount() );
 		assertEquals( 0, getSessions().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 0, getSessions().getStatistics().getQueryCacheMissCount() );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testConcurrentCachedQueries() throws Exception {
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
 		Map foo = new HashMap();
 		foo.put( "name", "Foo" );
 		foo.put( "description", "a big foo" );
 		s.persist( "Item", foo );
 		Map bar = new HashMap();
 		bar.put( "name", "Bar" );
 		bar.put( "description", "a small bar" );
 		s.persist( "Item", bar );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		synchronized ( this ) {
 			wait( 1000 );
 		}
 
 		getSessions().getStatistics().clear();
 
 		getSessions().evictEntity( "Item" );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s4 = openSession();
-		Transaction tx4 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		Transaction tx4 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s1 = openSession();
 		List r1 = s1.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r1.size(), 2 );
-		Transaction tx1 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		Transaction tx1 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s2 = openSession();
 		List r2 = s2.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r2.size(), 2 );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 2 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 2 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 1 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx1 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx1 );
 		tx1.commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s3 = openSession();
 		s3.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 4 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 2 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 2 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 1 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx4 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx4 );
 		List r4 = s4.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r4.size(), 2 );
 		tx4.commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 6 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 2 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 3 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 1 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testConcurrentCachedDirtyQueries() throws Exception {
 		if ( getDialect().doesReadCommittedCauseWritersToBlockReaders() ) {
 			reportSkip( "write locks block readers", "concurrent queries" );
 			return;
 		}
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
 		Map foo = new HashMap();
 		foo.put( "name", "Foo" );
 		foo.put( "description", "a big foo" );
 		s.persist( "Item", foo );
 		Map bar = new HashMap();
 		bar.put( "name", "Bar" );
 		bar.put( "description", "a small bar" );
 		s.persist( "Item", bar );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		synchronized ( this ) {
 			wait( 1000 );
 		}
 
 		getSessions().getStatistics().clear();
 
 		getSessions().evictEntity( "Item" );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s4 = openSession();
-		Transaction tx4 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		Transaction tx4 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s1 = openSession();
 		List r1 = s1.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r1.size(), 2 );
 		foo = ( Map ) r1.get( 0 );
 		foo.put( "description", "a big red foo" );
 		s1.flush();
-		Transaction tx1 = SimpleJtaTransactionManagerImpl.getInstance().suspend();
+		Transaction tx1 = sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().suspend();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s2 = openSession();
 		List r2 = s2.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r2.size(), 2 );
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 0 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 4 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 2 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 2 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 2 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx1 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx1 );
 		tx1.commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s3 = openSession();
 		s3.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 0 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 6 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 3 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 3 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 3 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().resume( tx4 );
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().resume( tx4 );
 		List r4 = s4.createCriteria( "Item" ).addOrder( Order.asc( "description" ) )
 				.setCacheable( true ).list();
 		assertEquals( r4.size(), 2 );
 		tx4.commit();
 
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheHitCount(), 2 );
 		assertEquals( getSessions().getStatistics().getSecondLevelCacheMissCount(), 0 );
 		assertEquals( getSessions().getStatistics().getEntityLoadCount(), 6 );
 		assertEquals( getSessions().getStatistics().getEntityFetchCount(), 0 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 3 );
 		assertEquals( getSessions().getStatistics().getQueryCachePutCount(), 3 );
 		assertEquals( getSessions().getStatistics().getQueryCacheHitCount(), 1 );
 		assertEquals( getSessions().getStatistics().getQueryCacheMissCount(), 3 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testCMT() throws Exception {
 		getSessions().getStatistics().clear();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		assertFalse( s.isOpen() );
 
 		assertEquals( getSessions().getStatistics().getFlushCount(), 0 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().rollback();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().rollback();
 		assertFalse( s.isOpen() );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		Map item = new HashMap();
 		item.put( "name", "The Item" );
 		item.put( "description", "The only item we have" );
 		s.persist( "Item", item );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		assertFalse( s.isOpen() );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		item = ( Map ) s.createQuery( "from Item" ).uniqueResult();
 		assertNotNull( item );
 		s.delete( item );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		assertFalse( s.isOpen() );
 
 		assertEquals( getSessions().getStatistics().getTransactionCount(), 4 );
 		assertEquals( getSessions().getStatistics().getSuccessfulTransactionCount(), 3 );
 		assertEquals( getSessions().getStatistics().getEntityDeleteCount(), 1 );
 		assertEquals( getSessions().getStatistics().getEntityInsertCount(), 1 );
 		assertEquals( getSessions().getStatistics().getSessionOpenCount(), 4 );
 		assertEquals( getSessions().getStatistics().getSessionCloseCount(), 4 );
 		assertEquals( getSessions().getStatistics().getQueryExecutionCount(), 1 );
 		assertEquals( getSessions().getStatistics().getFlushCount(), 2 );
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 	}
 
 	public void testCurrentSession() throws Exception {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = getSessions().getCurrentSession();
 		Session s2 = getSessions().getCurrentSession();
 		assertSame( s, s2 );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		assertFalse( s.isOpen() );
 
 		// TODO : would be nice to automate-test that the SF internal map actually gets cleaned up
 		//      i verified that is does currently in my debugger...
 	}
 
 	public void testCurrentSessionWithIterate() throws Exception {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
 		Map item1 = new HashMap();
 		item1.put( "name", "Item - 1" );
 		item1.put( "description", "The first item" );
 		s.persist( "Item", item1 );
 
 		Map item2 = new HashMap();
 		item2.put( "name", "Item - 2" );
 		item2.put( "description", "The second item" );
 		s.persist( "Item", item2 );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// First, test iterating the partial iterator; iterate to past
 		// the first, but not the second, item
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		Iterator itr = s.createQuery( "from Item" ).iterate();
 		if ( !itr.hasNext() ) {
 			fail( "No results in iterator" );
 		}
 		itr.next();
 		if ( !itr.hasNext() ) {
 			fail( "Only one result in iterator" );
 		}
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// Next, iterate the entire result
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		itr = s.createQuery( "from Item" ).iterate();
 		if ( !itr.hasNext() ) {
 			fail( "No results in iterator" );
 		}
 		while ( itr.hasNext() ) {
 			itr.next();
 		}
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testCurrentSessionWithScroll() throws Exception {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = getSessions().getCurrentSession();
 		Map item1 = new HashMap();
 		item1.put( "name", "Item - 1" );
 		item1.put( "description", "The first item" );
 		s.persist( "Item", item1 );
 
 		Map item2 = new HashMap();
 		item2.put( "name", "Item - 2" );
 		item2.put( "description", "The second item" );
 		s.persist( "Item", item2 );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// First, test partially scrolling the result with out closing
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		ScrollableResults results = s.createQuery( "from Item" ).scroll();
 		results.next();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// Next, test partially scrolling the result with closing
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		results = s.createQuery( "from Item" ).scroll();
 		results.next();
 		results.close();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// Next, scroll the entire result (w/o closing)
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		results = s.createQuery( "from Item" ).scroll();
 		while ( results.next() ) {
 			// do nothing
 		}
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		// Next, scroll the entire result (closing)
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		results = s.createQuery( "from Item" ).scroll();
 		while ( results.next() ) {
 			// do nothing
 		}
 		results.close();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		s = getSessions().getCurrentSession();
 		s.createQuery( "delete from Item" ).executeUpdate();
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testAggressiveReleaseWithExplicitDisconnectReconnect() throws Exception {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = getSessions().getCurrentSession();
 
 		s.createQuery( "from Item" ).list();
 
 		s.disconnect();
 		byte[] bytes = SerializationHelper.serialize( s );
 		s = ( Session ) SerializationHelper.deserialize( bytes );
 		s.reconnect();
 
 		s.createQuery( "from Item" ).list();
 
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 	}
 
 	public void testAggressiveReleaseWithConnectionRetreival() throws Exception {
-		SimpleJtaTransactionManagerImpl.getInstance().begin();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 		Session s = openSession();
 		Map item1 = new HashMap();
 		item1.put( "name", "Item - 1" );
 		item1.put( "description", "The first item" );
 		s.save( "Item", item1 );
 
 		Map item2 = new HashMap();
 		item2.put( "name", "Item - 2" );
 		item2.put( "description", "The second item" );
 		s.save( "Item", item2 );
-		SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+		sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 
 		try {
-			SimpleJtaTransactionManagerImpl.getInstance().begin();
+			sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 			s = getSessions().getCurrentSession();
 			s.createQuery( "from Item" ).scroll().next();
 			s.connection();
-			SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+			sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		}
 		finally {
-			SimpleJtaTransactionManagerImpl.getInstance().begin();
+			sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().begin();
 			s = openSession();
 			s.createQuery( "delete from Item" ).executeUpdate();
-			SimpleJtaTransactionManagerImpl.getInstance().getTransaction().commit();
+			sfi().getServiceRegistry().getService( JtaPlatform.class ).retrieveTransactionManager().commit();
 		}
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java
new file mode 100644
index 0000000000..871f544f9c
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java
@@ -0,0 +1,139 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.transaction.jdbc;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.service.internal.ServiceRegistryImpl;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.StandardServiceInitiators;
+import org.hibernate.test.common.ConnectionProviderBuilder;
+import org.hibernate.test.common.JournalingTransactionObserver;
+import org.hibernate.test.common.TransactionContextImpl;
+import org.hibernate.test.common.TransactionEnvironmentImpl;
+import org.hibernate.testing.junit.UnitTestCase;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+/**
+ * TODO : javadoc
+ *
+ * @author Steve Ebersole
+ */
+public class TestExpectedUsage extends UnitTestCase {
+	private ServiceRegistry serviceRegistry;
+
+	public TestExpectedUsage(String string) {
+		super( string );
+	}
+
+	public void setUp() throws Exception {
+		super.setUp();
+		serviceRegistry = new ServiceRegistryImpl(
+				StandardServiceInitiators.LIST,
+				ConnectionProviderBuilder.getConnectionProviderProperties()
+		);
+	}
+
+	public void tearDown() throws Exception {
+		( (ServiceRegistryImpl) serviceRegistry).destroy();
+		super.tearDown();
+	}
+
+	public void testBasicUsage() {
+		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) ) {
+			@Override
+			public ConnectionReleaseMode getConnectionReleaseMode() {
+				return ConnectionReleaseMode.AFTER_TRANSACTION;
+			}
+		};
+
+		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
+		JournalingTransactionObserver observer = new JournalingTransactionObserver();
+		transactionCoordinator.addObserver( observer );
+
+		LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
+		Connection connection = logicalConnection.getShareableConnectionProxy();
+
+		// set up some tables to use
+		try {
+			Statement statement = connection.createStatement();
+			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
+			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+			statement.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
+		}
+		catch ( SQLException sqle ) {
+			fail( "incorrect exception type : SQLException" );
+		}
+
+		// ok, now we can get down to it...
+		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
+		txn.begin();
+		assertEquals( 1, observer.getBegins() );
+		try {
+			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
+			ps.setLong( 1, 1 );
+			ps.setString( 2, "name" );
+			ps.execute();
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			ps.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
+			ps.executeQuery();
+			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
+			// lets forget to close these...
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+			// and commit the transaction...
+			txn.commit();
+
+			// we should now have:
+			//		1) no resources because of after_transaction release mode
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			//		2) non-physically connected logical connection, again because of after_transaction release mode
+			assertFalse( logicalConnection.isPhysicallyConnected() );
+			//		3) transaction observer callbacks
+			assertEquals( 1, observer.getBeforeCompletions() );
+			assertEquals( 1, observer.getAfterCompletions() );
+		}
+		catch ( SQLException sqle ) {
+			fail( "incorrect exception type : SQLException" );
+		}
+		finally {
+			logicalConnection.close();
+		}
+	}
+
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java
new file mode 100644
index 0000000000..d38a056c02
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java
@@ -0,0 +1,162 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.transaction.jta;
+
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.service.internal.ServiceProxy;
+import org.hibernate.service.internal.ServiceRegistryImpl;
+import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.StandardServiceInitiators;
+import org.hibernate.test.common.ConnectionProviderBuilder;
+import org.hibernate.test.common.JournalingTransactionObserver;
+import org.hibernate.test.common.TransactionContextImpl;
+import org.hibernate.test.common.TransactionEnvironmentImpl;
+import org.hibernate.test.common.jta.AtomikosDataSourceConnectionProvider;
+import org.hibernate.test.common.jta.AtomikosJtaPlatform;
+import org.hibernate.testing.junit.UnitTestCase;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Testing transaction handling when the JTA transaction facade is the driver.
+ *
+ * @author Steve Ebersole
+ */
+public class BasicDrivingTest extends UnitTestCase {
+	private ServiceRegistry serviceRegistry;
+
+	public BasicDrivingTest(String string) {
+		super( string );
+	}
+
+	public void setUp() throws Exception {
+		super.setUp();
+
+		Map configValues = new HashMap();
+		configValues.putAll( ConnectionProviderBuilder.getConnectionProviderProperties() );
+		configValues.put( Environment.TRANSACTION_STRATEGY, JtaTransactionFactory.class.getName() );
+		configValues.put( JtaPlatformInitiator.JTA_PLATFORM, AtomikosJtaPlatform.class.getName() );
+		configValues.put( Environment.CONNECTION_PROVIDER, AtomikosDataSourceConnectionProvider.class.getName() );
+		serviceRegistry = new ServiceRegistryImpl( StandardServiceInitiators.LIST, configValues );
+	}
+
+	public void tearDown() throws Exception {
+		( (ServiceRegistryImpl) serviceRegistry).destroy();
+		super.tearDown();
+	}
+
+	public void testBasicUsage() throws Throwable {
+		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) );
+
+		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
+		JournalingTransactionObserver observer = new JournalingTransactionObserver();
+		transactionCoordinator.addObserver( observer );
+
+		LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
+		Connection connection = logicalConnection.getShareableConnectionProxy();
+
+		// set up some tables to use
+		try {
+			Statement statement = connection.createStatement();
+			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
+			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+			statement.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertFalse( logicalConnection.isPhysicallyConnected() ); // after_statement specified
+		}
+		catch ( SQLException sqle ) {
+			fail( "incorrect exception type : SQLException" );
+		}
+
+		// ok, now we can get down to it...
+		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
+		txn.begin();
+		assertEquals( 1, observer.getBegins() );
+		assertTrue( txn.isInitiator() );
+		try {
+			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
+			ps.setLong( 1, 1 );
+			ps.setString( 2, "name" );
+			ps.execute();
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			ps.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
+			ps.executeQuery();
+			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
+			// lets forget to close these...
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+
+			// and commit the transaction...
+			txn.commit();
+
+			// we should now have:
+			//		1) no resources because of after_transaction release mode
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			//		2) non-physically connected logical connection, again because of after_transaction release mode
+			assertFalse( logicalConnection.isPhysicallyConnected() );
+			//		3) transaction observer callbacks
+			assertEquals( 1, observer.getBeforeCompletions() );
+			assertEquals( 1, observer.getAfterCompletions() );
+		}
+		catch ( SQLException sqle ) {
+			try {
+				JtaPlatform instance = ( (ServiceProxy) serviceRegistry.getService( JtaPlatform.class ) ).getTargetInstance();
+				instance.retrieveTransactionManager().rollback();
+			}
+			catch (Exception ignore) {
+			}
+			fail( "incorrect exception type : SQLException" );
+		}
+		catch (Throwable reThrowable) {
+			try {
+				JtaPlatform instance = ( (ServiceProxy) serviceRegistry.getService( JtaPlatform.class ) ).getTargetInstance();
+				instance.retrieveTransactionManager().rollback();
+			}
+			catch (Exception ignore) {
+			}
+			throw reThrowable;
+		}
+		finally {
+			logicalConnection.close();
+		}
+	}
+
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java
new file mode 100644
index 0000000000..746497f89a
--- /dev/null
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java
@@ -0,0 +1,178 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.test.transaction.jta;
+
+import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
+import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
+import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
+import org.hibernate.engine.transaction.spi.TransactionContext;
+import org.hibernate.engine.transaction.spi.TransactionImplementor;
+import org.hibernate.service.internal.ServiceProxy;
+import org.hibernate.service.internal.ServiceRegistryImpl;
+import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
+import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.service.spi.ServiceRegistry;
+import org.hibernate.service.spi.StandardServiceInitiators;
+import org.hibernate.test.common.ConnectionProviderBuilder;
+import org.hibernate.test.common.JournalingTransactionObserver;
+import org.hibernate.test.common.TransactionContextImpl;
+import org.hibernate.test.common.TransactionEnvironmentImpl;
+import org.hibernate.test.common.jta.AtomikosDataSourceConnectionProvider;
+import org.hibernate.test.common.jta.AtomikosJtaPlatform;
+import org.hibernate.testing.junit.UnitTestCase;
+
+import javax.transaction.TransactionManager;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Testing transaction facacde handling when the transaction is being driven by somethign other than the facade.
+ *
+ * @author Steve Ebersole
+ */
+public class ManagedDrivingTest extends UnitTestCase {
+	private ServiceRegistry serviceRegistry;
+
+	public ManagedDrivingTest(String string) {
+		super( string );
+	}
+
+	public void setUp() throws Exception {
+		super.setUp();
+
+		Map configValues = new HashMap();
+		configValues.putAll( ConnectionProviderBuilder.getConnectionProviderProperties() );
+		configValues.put( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
+		configValues.put( JtaPlatformInitiator.JTA_PLATFORM, AtomikosJtaPlatform.class.getName() );
+		configValues.put( Environment.CONNECTION_PROVIDER, AtomikosDataSourceConnectionProvider.class.getName() );
+
+		serviceRegistry = new ServiceRegistryImpl( StandardServiceInitiators.LIST, configValues );
+	}
+
+
+	public void tearDown() throws Exception {
+		( (ServiceRegistryImpl) serviceRegistry).destroy();
+		super.tearDown();
+	}
+
+	public void testBasicUsage() throws Throwable {
+		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) ) {
+			@Override
+			public ConnectionReleaseMode getConnectionReleaseMode() {
+				return ConnectionReleaseMode.AFTER_STATEMENT;
+			}
+		};
+
+		final TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
+		final JournalingTransactionObserver transactionObserver = new JournalingTransactionObserver();
+		transactionCoordinator.addObserver( transactionObserver );
+
+		final LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
+		Connection connection = logicalConnection.getShareableConnectionProxy();
+
+		// set up some tables to use
+		try {
+			Statement statement = connection.createStatement();
+			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
+			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+			statement.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertFalse( logicalConnection.isPhysicallyConnected() ); // after_statement specified
+		}
+		catch ( SQLException sqle ) {
+			fail( "incorrect exception type : SQLException" );
+		}
+
+		JtaPlatform instance = ( (ServiceProxy) serviceRegistry.getService( JtaPlatform.class ) ).getTargetInstance();
+		TransactionManager transactionManager = instance.retrieveTransactionManager();
+
+		// start the cmt
+		transactionManager.begin();
+
+		// ok, now we can get down to it...
+		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
+		txn.begin();
+		assertEquals( 1, transactionObserver.getBegins() );
+		assertFalse( txn.isInitiator() );
+		connection = logicalConnection.getShareableConnectionProxy();
+		try {
+			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
+			ps.setLong( 1, 1 );
+			ps.setString( 2, "name" );
+			ps.execute();
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			ps.close();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+
+			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
+			ps.executeQuery();
+			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
+			// lets forget to close these...
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+
+			// and commit the transaction...
+			txn.commit();
+
+			// since txn is not a driver, nothing should have changed...
+			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertTrue( logicalConnection.isPhysicallyConnected() );
+			assertEquals( 0, transactionObserver.getBeforeCompletions() );
+			assertEquals( 0, transactionObserver.getAfterCompletions() );
+
+			transactionManager.commit();
+			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
+			assertFalse( logicalConnection.isPhysicallyConnected() );
+			assertEquals( 1, transactionObserver.getBeforeCompletions() );
+			assertEquals( 1, transactionObserver.getAfterCompletions() );
+		}
+		catch ( SQLException sqle ) {
+			try {
+				transactionManager.rollback();
+			}
+			catch (Exception ignore) {
+			}
+			fail( "incorrect exception type : SQLException" );
+		}
+		catch (Throwable reThrowable) {
+			try {
+				transactionManager.rollback();
+			}
+			catch (Exception ignore) {
+			}
+			throw reThrowable;
+		}
+		finally {
+			logicalConnection.close();
+		}
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/testing/cache/BaseCacheProviderTestCase.java b/hibernate-core/src/test/java/org/hibernate/testing/cache/BaseCacheProviderTestCase.java
index 8b5dbff242..58f8f0b5e4 100644
--- a/hibernate-core/src/test/java/org/hibernate/testing/cache/BaseCacheProviderTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/testing/cache/BaseCacheProviderTestCase.java
@@ -1,243 +1,243 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.cache;
 
 import java.util.Map;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cache.ReadWriteCache;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
+import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.testing.junit.functional.FunctionalTestCase;
 import org.hibernate.stat.SecondLevelCacheStatistics;
 import org.hibernate.stat.Statistics;
 import org.hibernate.testing.tm.ConnectionProviderImpl;
 import org.hibernate.testing.tm.TransactionManagerLookupImpl;
-import org.hibernate.transaction.JDBCTransactionFactory;
 
 /**
  * Common requirement testing for each {@link org.hibernate.cache.CacheProvider} impl.
  *
  * @author Steve Ebersole
  */
 public abstract class BaseCacheProviderTestCase extends FunctionalTestCase {
 
 	// note that a lot of the fucntionality here is intended to be used
 	// in creating specific tests for each CacheProvider that would extend
 	// from a base test case (this) for common requirement testing...
 
 	public BaseCacheProviderTestCase(String x) {
 		super( x );
 	}
 
 	@Override
 	public String getBaseForMappings() {
 		return "org/hibernate/testing/";
 	}
 
 	public String[] getMappings() {
 		return new String[] { "cache/Item.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CACHE_REGION_PREFIX, "" );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.USE_STRUCTURED_CACHE, "true" );
 		cfg.setProperty( Environment.CACHE_PROVIDER, getCacheProvider().getName() );
 
 		if ( getConfigResourceKey() != null ) {
 			cfg.setProperty( getConfigResourceKey(), getConfigResourceLocation() );
 		}
 
 		if ( useTransactionManager() ) {
 			cfg.setProperty( Environment.CONNECTION_PROVIDER, ConnectionProviderImpl.class.getName() );
 			cfg.setProperty( Environment.TRANSACTION_MANAGER_STRATEGY, TransactionManagerLookupImpl.class.getName() );
 		}
 		else {
-			cfg.setProperty( Environment.TRANSACTION_STRATEGY, JDBCTransactionFactory.class.getName() );
+			cfg.setProperty( Environment.TRANSACTION_STRATEGY, JdbcTransactionFactory.class.getName() );
 		}
 	}
 
 	/**
 	 * The cache provider to be tested.
 	 *
 	 * @return The cache provider.
 	 */
 	protected abstract Class getCacheProvider();
 
 	/**
 	 * For provider-specific configuration, the name of the property key the
 	 * provider expects.
 	 *
 	 * @return The provider-specific config key.
 	 */
 	protected abstract String getConfigResourceKey();
 
 	/**
 	 * For provider-specific configuration, the resource location of that
 	 * config resource.
 	 *
 	 * @return The config resource location.
 	 */
 	protected abstract String getConfigResourceLocation();
 
 	/**
 	 * Should we use a transaction manager for transaction management.
 	 *
 	 * @return True if we should use a RM; false otherwise.
 	 */
 	protected abstract boolean useTransactionManager();
 
 
 	public void testQueryCacheInvalidation() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Item i = new Item();
 		i.setName("widget");
 		i.setDescription("A really top-quality, full-featured widget.");
 		s.persist(i);
 		t.commit();
 		s.close();
 
 		SecondLevelCacheStatistics slcs = s.getSessionFactory().getStatistics()
 				.getSecondLevelCacheStatistics( Item.class.getName() );
 
 		assertEquals( slcs.getPutCount(), 1 );
 		assertEquals( slcs.getElementCountInMemory(), 1 );
 		assertEquals( slcs.getEntries().size(), 1 );
 
 		s = openSession();
 		t = s.beginTransaction();
 		i = (Item) s.get( Item.class, i.getId() );
 
 		assertEquals( slcs.getHitCount(), 1 );
 		assertEquals( slcs.getMissCount(), 0 );
 
 		i.setDescription("A bog standard item");
 
 		t.commit();
 		s.close();
 
 		assertEquals( slcs.getPutCount(), 2 );
 
 		Object entry = slcs.getEntries().get( i.getId() );
 		Map map;
 		if ( entry instanceof ReadWriteCache.Item ) {
 			map = (Map) ( (ReadWriteCache.Item) entry ).getValue();
 		}
 		else {
 			map = (Map) entry;
 		}
 		assertTrue( map.get("description").equals("A bog standard item") );
 		assertTrue( map.get("name").equals("widget") );
 
 		// cleanup
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( i );
 		t.commit();
 		s.close();
 	}
 
 	public void testEmptySecondLevelCacheEntry() throws Exception {
 		getSessions().evictEntity( Item.class.getName() );
 		Statistics stats = getSessions().getStatistics();
 		stats.clear();
 		SecondLevelCacheStatistics statistics = stats.getSecondLevelCacheStatistics( Item.class.getName() );
         Map cacheEntries = statistics.getEntries();
 		assertEquals( 0, cacheEntries.size() );
 	}
 
 	public void testStaleWritesLeaveCacheConsistent() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		VersionedItem item = new VersionedItem();
 		item.setName( "steve" );
 		item.setDescription( "steve's item" );
 		s.save( item );
 		txn.commit();
 		s.close();
 
 		Long initialVersion = item.getVersion();
 
 		// manually revert the version property
 		item.setVersion( new Long( item.getVersion().longValue() - 1 ) );
 
 		try {
 			s = openSession();
 			txn = s.beginTransaction();
 			s.update( item );
 			txn.commit();
 			s.close();
 			fail( "expected stale write to fail" );
 		}
 		catch( Throwable expected ) {
 			// expected behavior here
 			if ( txn != null ) {
 				try {
 					txn.rollback();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		finally {
 			if ( s != null && s.isOpen() ) {
 				try {
 					s.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 
 		// check the version value in the cache...
 		SecondLevelCacheStatistics slcs = sfi().getStatistics()
 				.getSecondLevelCacheStatistics( VersionedItem.class.getName() );
 
 		Object entry = slcs.getEntries().get( item.getId() );
 		Long cachedVersionValue;
 		if ( entry instanceof ReadWriteCache.Lock ) {
 			//FIXME don't know what to test here
 			cachedVersionValue = new Long( ( (ReadWriteCache.Lock) entry).getUnlockTimestamp() );
 		}
 		else {
 			cachedVersionValue = ( Long ) ( (Map) entry ).get( "_version" );
 			assertEquals( initialVersion.longValue(), cachedVersionValue.longValue() );
 		}
 
 
 		// cleanup
 		s = openSession();
 		txn = s.beginTransaction();
 		item = ( VersionedItem ) s.load( VersionedItem.class, item.getId() );
 		s.delete( item );
 		txn.commit();
 		s.close();
 
 	}
 }
diff --git a/hibernate-core/src/test/resources/log4j.properties b/hibernate-core/src/test/resources/log4j.properties
index cd9c5224cf..c13e5d4f48 100644
--- a/hibernate-core/src/test/resources/log4j.properties
+++ b/hibernate-core/src/test/resources/log4j.properties
@@ -1,19 +1,20 @@
 log4j.appender.stdout=org.apache.log4j.ConsoleAppender
 log4j.appender.stdout.Target=System.out
 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
 log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n
 
 
 log4j.rootLogger=info, stdout
 
 log4j.logger.org.hibernate.test=info
 log4j.logger.org.hibernate.tool.hbm2ddl=debug
 log4j.logger.org.hibernate.engine.jdbc.internal=trace
 log4j.logger.org.hibernate.engine.jdbc.internal.proxy=trace
 log4j.logger.org.hibernate.engine.jdbc.batch.internal=trace
 log4j.logger.org.hibernate.hql.ast.QueryTranslatorImpl=trace
 log4j.logger.org.hibernate.hql.ast.HqlSqlWalker=trace
 log4j.logger.org.hibernate.hql.ast.SqlGenerator=trace
 log4j.logger.org.hibernate.hql.ast.AST=trace
 log4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=trace
 log4j.logger.org.hibernate.type.BasicTypeRegistry=trace
+
