diff --git a/documentation/src/main/docbook/manual/en-US/content/events.xml b/documentation/src/main/docbook/manual/en-US/content/events.xml
index 156419c80f..17b9325e09 100755
--- a/documentation/src/main/docbook/manual/en-US/content/events.xml
+++ b/documentation/src/main/docbook/manual/en-US/content/events.xml
@@ -1,296 +1,296 @@
 <?xml version='1.0' encoding="UTF-8"?>
 <!--
   ~ Hibernate, Relational Persistence for Idiomatic Java
   ~
   ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
   ~ indicated by the @author tags or express copyright attribution
   ~ statements applied by the authors.  All third-party contributions are
   ~ distributed under license by Red Hat Middleware LLC.
   ~
   ~ This copyrighted material is made available to anyone wishing to use, modify,
   ~ copy, or redistribute it subject to the terms and conditions of the GNU
   ~ Lesser General Public License, as published by the Free Software Foundation.
   ~
   ~ This program is distributed in the hope that it will be useful,
   ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
   ~ for more details.
   ~
   ~ You should have received a copy of the GNU Lesser General Public License
   ~ along with this distribution; if not, write to:
   ~ Free Software Foundation, Inc.
   ~ 51 Franklin Street, Fifth Floor
   ~ Boston, MA  02110-1301  USA
   -->
 
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
 <!ENTITY % BOOK_ENTITIES SYSTEM "../HIBERNATE_-_Relational_Persistence_for_Idiomatic_Java.ent">
 %BOOK_ENTITIES;
 
 ]>
 
 <chapter id="events">
     <title>Interceptors and events</title>
 
     <para>
         It is useful for the application to react to certain events that occur
         inside Hibernate. This allows for the implementation of generic 
         functionality and the extension of Hibernate functionality.
     </para>
 
     <section id="objectstate-interceptors" revision="3">
         <title>Interceptors</title>
 
         <para>
             The <literal>Interceptor</literal> interface provides callbacks from the session to the 
             application, allowing the application to inspect and/or manipulate properties of a
             persistent object before it is saved, updated, deleted or loaded. One 
             possible use for this is to track auditing information. For example, the following 
             <literal>Interceptor</literal> automatically sets the  <literal>createTimestamp</literal> 
             when an <literal>Auditable</literal> is created and updates the 
             <literal>lastUpdateTimestamp</literal> property when an <literal>Auditable</literal> is 
             updated.
         </para>
 
         <para>
             You can either implement <literal>Interceptor</literal> directly or extend
             <literal>EmptyInterceptor</literal>.
         </para>
 
         <programlisting role="JAVA"><![CDATA[package org.hibernate.test;
 
 import java.io.Serializable;
 import java.util.Date;
 import java.util.Iterator;
 
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.Transaction;
 import org.hibernate.type.Type;
 
 public class AuditInterceptor extends EmptyInterceptor {
 
     private int updates;
     private int creates;
     private int loads;
 
     public void onDelete(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
         // do nothing
     }
 
     public boolean onFlushDirty(Object entity,
                                 Serializable id,
                                 Object[] currentState,
                                 Object[] previousState,
                                 String[] propertyNames,
                                 Type[] types) {
 
         if ( entity instanceof Auditable ) {
             updates++;
             for ( int i=0; i < propertyNames.length; i++ ) {
                 if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                     currentState[i] = new Date();
                     return true;
                 }
             }
         }
         return false;
     }
 
     public boolean onLoad(Object entity,
                           Serializable id,
                           Object[] state,
                           String[] propertyNames,
                           Type[] types) {
         if ( entity instanceof Auditable ) {
             loads++;
         }
         return false;
     }
 
     public boolean onSave(Object entity,
                           Serializable id,
                           Object[] state,
                           String[] propertyNames,
                           Type[] types) {
 
         if ( entity instanceof Auditable ) {
             creates++;
             for ( int i=0; i<propertyNames.length; i++ ) {
                 if ( "createTimestamp".equals( propertyNames[i] ) ) {
                     state[i] = new Date();
                     return true;
                 }
             }
         }
         return false;
     }
 
     public void afterTransactionCompletion(Transaction tx) {
         if ( tx.wasCommitted() ) {
             System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
         }
         updates=0;
         creates=0;
         loads=0;
     }
 
 }]]></programlisting>
 
         <para>
             There are two kinds of inteceptors: <literal>Session</literal>-scoped and
             <literal>SessionFactory</literal>-scoped.
         </para>
 
         <para>
             A <literal>Session</literal>-scoped interceptor is specified
             when a session is opened using one of the overloaded SessionFactory.openSession()
             methods accepting an <literal>Interceptor</literal>.
         </para>
 
         <programlisting role="JAVA"><![CDATA[Session session = sf.openSession( new AuditInterceptor() );]]></programlisting>
 
         <para>
             A <literal>SessionFactory</literal>-scoped interceptor is registered with the <literal>Configuration</literal>
             object prior to building the <literal>SessionFactory</literal>.  Unless
             a session is opened explicitly specifying the interceptor to use, the supplied interceptor
             will be applied to all sessions opened from that <literal>SessionFactory</literal>.  <literal>SessionFactory</literal>-scoped
             interceptors must be thread safe. Ensure that you do not store session-specific states, since multiple
             sessions will use this interceptor potentially concurrently.
         </para>
     
         <programlisting role="JAVA"><![CDATA[new Configuration().setInterceptor( new AuditInterceptor() );]]></programlisting>
 
     </section>
 
      <section id="objectstate-events" revision="4">
         <title>Event system</title>
 
         <para>
             If you have to react to particular events in your persistence layer, you can
             also use the Hibernate3 <emphasis>event</emphasis> architecture. The event
             system can be used in addition, or as a replacement, for interceptors.
         </para>
 
         <para>
             All the methods of the <literal>Session</literal> interface correlate
             to an event. You have a <literal>LoadEvent</literal>, a <literal>FlushEvent</literal>, etc.
             Consult the XML configuration-file DTD or the <literal>org.hibernate.event</literal>
             package for the full list of defined event types. When a request is made of one of
             these methods, the Hibernate <literal>Session</literal> generates an appropriate
             event and passes it to the configured event listeners for that type. Out-of-the-box,
             these listeners implement the same processing in which those methods always resulted.
             However, you are free to implement a customization of one of the listener interfaces
             (i.e., the <literal>LoadEvent</literal> is processed by the registered implementation
             of the <literal>LoadEventListener</literal> interface), in which case their
             implementation would be responsible for processing any <literal>load()</literal> requests
             made of the <literal>Session</literal>.
         </para>
 
         <para>
             The listeners should be considered singletons. This means they are shared between
             requests, and should not save any state as instance variables.
         </para>
 
         <para>
             A custom listener implements the appropriate interface for the event it wants to
             process and/or extend one of the convenience base classes (or even the default event
             listeners used by Hibernate out-of-the-box as these are declared non-final for this
             purpose). Custom listeners can either be registered programmatically through the
             <literal>Configuration</literal> object, or specified in the Hibernate configuration
             XML. Declarative configuration through the properties file is not supported. Here is an
             example of a custom load event listener:
         </para>
 
         <programlisting role="JAVA"><![CDATA[public class MyLoadListener implements LoadEventListener {
     // this is the single method defined by the LoadEventListener interface
     public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
             throws HibernateException {
         if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
             throw MySecurityException("Unauthorized access");
         }
     }
 }]]></programlisting>
 
         <para>
             You also need a configuration entry telling Hibernate to use the listener in addition
             to the default listener:
         </para>
 
 <programlisting role="XML"><![CDATA[<hibernate-configuration>
     <session-factory>
         ...
         <event type="load">
             <listener class="com.eg.MyLoadListener"/>
             <listener class="org.hibernate.event.def.DefaultLoadEventListener"/>
         </event>
     </session-factory>
 </hibernate-configuration>]]></programlisting>
 
         <para>
             Instead, you can register it programmatically:
         </para>
 
         <programlisting role="JAVA"><![CDATA[Configuration cfg = new Configuration();
 LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };
 cfg.EventListeners().setLoadEventListeners(stack);]]></programlisting>
 
         <para>
             Listeners registered declaratively cannot share instances. If the same class name is
             used in multiple <literal>&lt;listener/&gt;</literal> elements, each reference will
             result in a separate instance of that class. If you need to share
             listener instances between listener types you must use the programmatic registration
             approach.
         </para>
 
         <para>
             Why implement an interface and define the specific type during configuration? A
             listener implementation could implement multiple event listener interfaces. Having the
             type additionally defined during registration makes it easier to turn custom listeners on
             or off during configuration.
         </para>
 
     </section>
     
     <section id="objectstate-decl-security" revision="2">
         <title>Hibernate declarative security</title>
         <para>
             Usually, declarative security in Hibernate applications is managed in a session facade
             layer. Hibernate3 allows certain actions to be permissioned via JACC, and authorized 
             via JAAS. This is an optional functionality that is built on top of the event architecture.
         </para>
         
         <para>
             First, you must configure the appropriate event listeners, to enable the use of JAAS
             authorization.
         </para>
         
-        <programlisting role="XML"><![CDATA[<listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/>
-<listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/>
-<listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/>
-<listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/>]]></programlisting>
+        <programlisting role="XML"><![CDATA[<listener type="pre-delete" class="org.hibernate.secure.internal.JACCPreDeleteEventListener"/>
+<listener type="pre-update" class="org.hibernate.secure.internal.JACCPreUpdateEventListener"/>
+<listener type="pre-insert" class="org.hibernate.secure.internal.JACCPreInsertEventListener"/>
+<listener type="pre-load" class="org.hibernate.secure.internal.JACCPreLoadEventListener"/>]]></programlisting>
 
         <para>
             Note that <literal>&lt;listener type="..." class="..."/&gt;</literal> is shorthand
             for <literal>&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</literal>
             when there is exactly one listener for a particular event type.
         </para>
 
         <para>
             Next, while still in <literal>hibernate.cfg.xml</literal>, bind the permissions to roles:
         </para>
         
         <programlisting role="XML"><![CDATA[<grant role="admin" entity-name="User" actions="insert,update,read"/>
 <grant role="su" entity-name="User" actions="*"/>]]></programlisting>
         
         <para>
             The role names are the roles understood by your JACC provider.
         </para>
        
     </section>
 
 </chapter>
 
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionAction.java
index 2737bfafbe..acb6520346 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionAction.java
@@ -1,216 +1,216 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.action.spi.AfterTransactionCompletionProcess;
 import org.hibernate.action.spi.BeforeTransactionCompletionProcess;
 import org.hibernate.action.spi.Executable;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.SoftLock;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * Any action relating to insert/update/delete of a collection
  *
  * @author Gavin King
  */
 public abstract class CollectionAction implements Executable, Serializable, Comparable {
 	private transient CollectionPersister persister;
 	private transient SessionImplementor session;
 	private final PersistentCollection collection;
 
 	private final Serializable key;
 	private final String collectionRole;
 
 	public CollectionAction(
 			final CollectionPersister persister, 
 			final PersistentCollection collection, 
 			final Serializable key, 
 			final SessionImplementor session) {
 		this.persister = persister;
 		this.session = session;
 		this.key = key;
 		this.collectionRole = persister.getRole();
 		this.collection = collection;
 	}
 
 	protected PersistentCollection getCollection() {
 		return collection;
 	}
 
 	/**
 	 * Reconnect to session after deserialization...
 	 *
 	 * @param session The session being deserialized
 	 */
 	public void afterDeserialize(SessionImplementor session) {
 		if ( this.session != null || this.persister != null ) {
 			throw new IllegalStateException( "already attached to a session." );
 		}
 		// IMPL NOTE: non-flushed changes code calls this method with session == null...
 		// guard against NullPointerException
 		if ( session != null ) {
 			this.session = session;
 			this.persister = session.getFactory().getCollectionPersister( collectionRole );
 		}
 	}
 
 	@Override
 	public final void beforeExecutions() throws CacheException {
 		// we need to obtain the lock before any actions are executed, since this may be an inverse="true"
 		// bidirectional association and it is one of the earlier entity actions which actually updates
 		// the database (this action is responsible for second-level cache invalidation only)
 		if ( persister.hasCache() ) {
 			final CacheKey ck = session.generateCacheKey(
 					key,
 					persister.getKeyType(),
 					persister.getRole()
 			);
 			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );
 			// the old behavior used key as opposed to getKey()
 			afterTransactionProcess = new CacheCleanupProcess( key, persister, lock );
 		}
 	}
 
 	@Override
 	public BeforeTransactionCompletionProcess getBeforeTransactionCompletionProcess() {
 		return null;
 	}
 
 	private AfterTransactionCompletionProcess afterTransactionProcess;
 
 	@Override
 	public AfterTransactionCompletionProcess getAfterTransactionCompletionProcess() {
 		return afterTransactionProcess;
 	}
 
 	@Override
 	public Serializable[] getPropertySpaces() {
 		return persister.getCollectionSpaces();
 	}
 
 	protected final CollectionPersister getPersister() {
 		return persister;
 	}
 
 	protected final Serializable getKey() {
 		Serializable finalKey = key;
 		if ( key instanceof DelayedPostInsertIdentifier ) {
 			// need to look it up from the persistence-context
 			finalKey = session.getPersistenceContext().getEntry( collection.getOwner() ).getId();
 			if ( finalKey == key ) {
 				// we may be screwed here since the collection action is about to execute
 				// and we do not know the final owner key value
 			}
 		}
 		return finalKey;
 	}
 
 	protected final SessionImplementor getSession() {
 		return session;
 	}
 
 	protected final void evict() throws CacheException {
 		if ( persister.hasCache() ) {
 			CacheKey ck = session.generateCacheKey(
 					key, 
 					persister.getKeyType(), 
 					persister.getRole()
 			);
 			persister.getCacheAccessStrategy().remove( ck );
 		}
 	}
 
 	@Override
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + 
 				MessageHelper.infoString( collectionRole, key );
 	}
 
 	@Override
 	public int compareTo(Object other) {
 		CollectionAction action = ( CollectionAction ) other;
 		//sort first by role name
 		int roleComparison = collectionRole.compareTo( action.collectionRole );
 		if ( roleComparison != 0 ) {
 			return roleComparison;
 		}
 		else {
 			//then by fk
 			return persister.getKeyType()
 					.compare( key, action.key, session.getEntityMode() );
 		}
 	}
 
 	private static class CacheCleanupProcess implements AfterTransactionCompletionProcess {
 		private final Serializable key;
 		private final CollectionPersister persister;
 		private final SoftLock lock;
 
 		private CacheCleanupProcess(Serializable key, CollectionPersister persister, SoftLock lock) {
 			this.key = key;
 			this.persister = persister;
 			this.lock = lock;
 		}
 
 		@Override
 		public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {
 			final CacheKey ck = session.generateCacheKey(
 					key,
 					persister.getKeyType(),
 					persister.getRole()
 			);
 			persister.getCacheAccessStrategy().unlockItem( ck, lock );
 		}
 	}
 
 	protected <T> EventListenerGroup<T> listenerGroup(EventType<T> eventType) {
 		return getSession()
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( eventType );
 	}
 
 	protected EventSource eventSource() {
 		return (EventSource) getSession();
 	}
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRecreateAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRecreateAction.java
index 087edeebec..0f7ed8aebe 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRecreateAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRecreateAction.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostCollectionRecreateEvent;
-import org.hibernate.event.PostCollectionRecreateEventListener;
-import org.hibernate.event.PreCollectionRecreateEvent;
-import org.hibernate.event.PreCollectionRecreateEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostCollectionRecreateEvent;
+import org.hibernate.event.spi.PostCollectionRecreateEventListener;
+import org.hibernate.event.spi.PreCollectionRecreateEvent;
+import org.hibernate.event.spi.PreCollectionRecreateEventListener;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class CollectionRecreateAction extends CollectionAction {
 
 	public CollectionRecreateAction(
 			final PersistentCollection collection,
 			final CollectionPersister persister,
 			final Serializable id,
 			final SessionImplementor session) throws CacheException {
 		super( persister, collection, id, session );
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		// this method is called when a new non-null collection is persisted
 		// or when an existing (non-null) collection is moved to a new owner
 		final PersistentCollection collection = getCollection();
 		
 		preRecreate();
 
 		getPersister().recreate( collection, getKey(), getSession() );
 		
 		getSession().getPersistenceContext()
 				.getCollectionEntry(collection)
 				.afterAction(collection);
 		
 		evict();
 
 		postRecreate();
 
 		if ( getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
 			getSession().getFactory().getStatisticsImplementor()
 					.recreateCollection( getPersister().getRole() );
 		}
 	}
 
 	private void preRecreate() {
 		EventListenerGroup<PreCollectionRecreateEventListener> listenerGroup = listenerGroup( EventType.PRE_COLLECTION_RECREATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PreCollectionRecreateEvent event = new PreCollectionRecreateEvent( getPersister(), getCollection(), eventSource() );
 		for ( PreCollectionRecreateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPreRecreateCollection( event );
 		}
 	}
 
 	private void postRecreate() {
 		EventListenerGroup<PostCollectionRecreateEventListener> listenerGroup = listenerGroup( EventType.POST_COLLECTION_RECREATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostCollectionRecreateEvent event = new PostCollectionRecreateEvent( getPersister(), getCollection(), eventSource() );
 		for ( PostCollectionRecreateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostRecreateCollection( event );
 		}
 	}
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRemoveAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRemoveAction.java
index d8c484186f..21889580a3 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRemoveAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionRemoveAction.java
@@ -1,162 +1,162 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostCollectionRemoveEvent;
-import org.hibernate.event.PostCollectionRemoveEventListener;
-import org.hibernate.event.PreCollectionRemoveEvent;
-import org.hibernate.event.PreCollectionRemoveEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostCollectionRemoveEvent;
+import org.hibernate.event.spi.PostCollectionRemoveEventListener;
+import org.hibernate.event.spi.PreCollectionRemoveEvent;
+import org.hibernate.event.spi.PreCollectionRemoveEventListener;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class CollectionRemoveAction extends CollectionAction {
 
 	private boolean emptySnapshot;
 	private final Object affectedOwner;
 	
 	/**
 	 * Removes a persistent collection from its loaded owner.
 	 *
 	 * Use this constructor when the collection is non-null.
 	 *
 	 * @param collection The collection to to remove; must be non-null
 	 * @param persister  The collection's persister
 	 * @param id The collection key
 	 * @param emptySnapshot Indicates if the snapshot is empty
 	 * @param session The session
 	 *
 	 * @throws AssertionFailure if collection is null.
 	 */
 	public CollectionRemoveAction(
 				final PersistentCollection collection,
 				final CollectionPersister persister,
 				final Serializable id,
 				final boolean emptySnapshot,
 				final SessionImplementor session) {
 		super( persister, collection, id, session );
 		if (collection == null) {
 			throw new AssertionFailure("collection == null");
 		}
 		this.emptySnapshot = emptySnapshot;
 		// the loaded owner will be set to null after the collection is removed,
 		// so capture its value as the affected owner so it is accessible to
 		// both pre- and post- events
 		this.affectedOwner = session.getPersistenceContext().getLoadedCollectionOwnerOrNull( collection );
 	}
 
 	/**
 	 * Removes a persistent collection from a specified owner.
 	 *
 	 * Use this constructor when the collection to be removed has not been loaded.
 	 *
 	 * @param affectedOwner The collection's owner; must be non-null
 	 * @param persister  The collection's persister
 	 * @param id The collection key
 	 * @param emptySnapshot Indicates if the snapshot is empty
 	 * @param session The session
 	 *
 	 * @throws AssertionFailure if affectedOwner is null.
 	 */
 	public CollectionRemoveAction(
 				final Object affectedOwner,
 				final CollectionPersister persister,
 				final Serializable id,
 				final boolean emptySnapshot,
 				final SessionImplementor session) {
 		super( persister, null, id, session );
 		if (affectedOwner == null) {
 			throw new AssertionFailure("affectedOwner == null");
 		}
 		this.emptySnapshot = emptySnapshot;
 		this.affectedOwner = affectedOwner;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		preRemove();
 
 		if ( !emptySnapshot ) {
 			// an existing collection that was either non-empty or uninitialized
 			// is replaced by null or a different collection
 			// (if the collection is uninitialized, hibernate has no way of
 			// knowing if the collection is actually empty without querying the db)
 			getPersister().remove( getKey(), getSession() );
 		}
 		
 		final PersistentCollection collection = getCollection();
 		if (collection!=null) {
 			getSession().getPersistenceContext()
 				.getCollectionEntry(collection)
 				.afterAction(collection);
 		}
 		
 		evict();
 
 		postRemove();		
 
 		if ( getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
 			getSession().getFactory().getStatisticsImplementor()
 					.removeCollection( getPersister().getRole() );
 		}
 	}
 
 	private void preRemove() {
 		EventListenerGroup<PreCollectionRemoveEventListener> listenerGroup = listenerGroup( EventType.PRE_COLLECTION_REMOVE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PreCollectionRemoveEvent event = new PreCollectionRemoveEvent(
 				getPersister(),
 				getCollection(),
 				eventSource(),
 				affectedOwner
 		);
 		for ( PreCollectionRemoveEventListener listener : listenerGroup.listeners() ) {
 			listener.onPreRemoveCollection( event );
 		}
 	}
 
 	private void postRemove() {
 		EventListenerGroup<PostCollectionRemoveEventListener> listenerGroup = listenerGroup( EventType.POST_COLLECTION_REMOVE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostCollectionRemoveEvent event = new PostCollectionRemoveEvent(
 				getPersister(),
 				getCollection(),
 				eventSource(),
 				affectedOwner
 		);
 		for ( PostCollectionRemoveEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostRemoveCollection( event );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionUpdateAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionUpdateAction.java
index 9d48a2546e..cda33b5305 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionUpdateAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/CollectionUpdateAction.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostCollectionUpdateEvent;
-import org.hibernate.event.PostCollectionUpdateEventListener;
-import org.hibernate.event.PreCollectionUpdateEvent;
-import org.hibernate.event.PreCollectionUpdateEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostCollectionUpdateEvent;
+import org.hibernate.event.spi.PostCollectionUpdateEventListener;
+import org.hibernate.event.spi.PreCollectionUpdateEvent;
+import org.hibernate.event.spi.PreCollectionUpdateEventListener;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class CollectionUpdateAction extends CollectionAction {
 
 	private final boolean emptySnapshot;
 
 	public CollectionUpdateAction(
 				final PersistentCollection collection,
 				final CollectionPersister persister,
 				final Serializable id,
 				final boolean emptySnapshot,
 				final SessionImplementor session) {
 		super( persister, collection, id, session );
 		this.emptySnapshot = emptySnapshot;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		final Serializable id = getKey();
 		final SessionImplementor session = getSession();
 		final CollectionPersister persister = getPersister();
 		final PersistentCollection collection = getCollection();
 		boolean affectedByFilters = persister.isAffectedByEnabledFilters(session);
 
 		preUpdate();
 
 		if ( !collection.wasInitialized() ) {
 			if ( !collection.hasQueuedOperations() ) throw new AssertionFailure( "no queued adds" );
 			//do nothing - we only need to notify the cache...
 		}
 		else if ( !affectedByFilters && collection.empty() ) {
 			if ( !emptySnapshot ) persister.remove( id, session );
 		}
 		else if ( collection.needsRecreate(persister) ) {
 			if (affectedByFilters) {
 				throw new HibernateException(
 					"cannot recreate collection while filter is enabled: " + 
 					MessageHelper.collectionInfoString( persister, id, persister.getFactory() )
 				);
 			}
 			if ( !emptySnapshot ) persister.remove( id, session );
 			persister.recreate( collection, id, session );
 		}
 		else {
 			persister.deleteRows( collection, id, session );
 			persister.updateRows( collection, id, session );
 			persister.insertRows( collection, id, session );
 		}
 
 		getSession().getPersistenceContext()
 			.getCollectionEntry(collection)
 			.afterAction(collection);
 
 		evict();
 
 		postUpdate();
 
 		if ( getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
 			getSession().getFactory().getStatisticsImplementor().
 					updateCollection( getPersister().getRole() );
 		}
 	}
 	
 	private void preUpdate() {
 		EventListenerGroup<PreCollectionUpdateEventListener> listenerGroup = listenerGroup( EventType.PRE_COLLECTION_UPDATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PreCollectionUpdateEvent event = new PreCollectionUpdateEvent(
 				getPersister(),
 				getCollection(),
 				eventSource()
 		);
 		for ( PreCollectionUpdateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPreUpdateCollection( event );
 		}
 	}
 
 	private void postUpdate() {
 		EventListenerGroup<PostCollectionUpdateEventListener> listenerGroup = listenerGroup( EventType.POST_COLLECTION_UPDATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostCollectionUpdateEvent event = new PostCollectionUpdateEvent(
 				getPersister(),
 				getCollection(),
 				eventSource()
 		);
 		for ( PostCollectionUpdateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostUpdateCollection( event );
 		}
 	}
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityAction.java
index 8dae5c8ddc..001690f694 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityAction.java
@@ -1,205 +1,205 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.action.spi.AfterTransactionCompletionProcess;
 import org.hibernate.action.spi.BeforeTransactionCompletionProcess;
 import org.hibernate.action.spi.Executable;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * Base class for actions relating to insert/update/delete of an entity
  * instance.
  *
  * @author Gavin King
  */
 public abstract class EntityAction
 		implements Executable, Serializable, Comparable, AfterTransactionCompletionProcess {
 
 	private final String entityName;
 	private final Serializable id;
 
 	private transient Object instance;
 	private transient SessionImplementor session;
 	private transient EntityPersister persister;
 
 	/**
 	 * Instantiate an action.
 	 *
 	 * @param session The session from which this action is coming.
 	 * @param id The id of the entity
 	 * @param instance The entity instance
 	 * @param persister The entity persister
 	 */
 	protected EntityAction(SessionImplementor session, Serializable id, Object instance, EntityPersister persister) {
 		this.entityName = persister.getEntityName();
 		this.id = id;
 		this.instance = instance;
 		this.session = session;
 		this.persister = persister;
 	}
 
 	@Override
 	public BeforeTransactionCompletionProcess getBeforeTransactionCompletionProcess() {
 		return null;
 	}
 
 	@Override
 	public AfterTransactionCompletionProcess getAfterTransactionCompletionProcess() {
 		return needsAfterTransactionCompletion()
 				? this
 				: null;
 	}
 
 	protected abstract boolean hasPostCommitEventListeners();
 
 	public boolean needsAfterTransactionCompletion() {
 		return persister.hasCache() || hasPostCommitEventListeners();
 	}
 
 	/**
 	 * entity name accessor
 	 *
 	 * @return The entity name
 	 */
 	public String getEntityName() {
 		return entityName;
 	}
 
 	/**
 	 * entity id accessor
 	 *
 	 * @return The entity id
 	 */
 	public final Serializable getId() {
 		if ( id instanceof DelayedPostInsertIdentifier ) {
 			Serializable eeId = session.getPersistenceContext().getEntry( instance ).getId();
 			return eeId instanceof DelayedPostInsertIdentifier ? null : eeId;
 		}
 		return id;
 	}
 
 	public final DelayedPostInsertIdentifier getDelayedId() {
 		return DelayedPostInsertIdentifier.class.isInstance( id ) ?
 				DelayedPostInsertIdentifier.class.cast( id ) :
 				null;
 	}
 
 	/**
 	 * entity instance accessor
 	 *
 	 * @return The entity instance
 	 */
 	public final Object getInstance() {
 		return instance;
 	}
 
 	/**
 	 * originating session accessor
 	 *
 	 * @return The session from which this action originated.
 	 */
 	public final SessionImplementor getSession() {
 		return session;
 	}
 
 	/**
 	 * entity persister accessor
 	 *
 	 * @return The entity persister
 	 */
 	public final EntityPersister getPersister() {
 		return persister;
 	}
 
 	@Override
 	public final Serializable[] getPropertySpaces() {
 		return persister.getPropertySpaces();
 	}
 
 	@Override
 	public void beforeExecutions() {
 		throw new AssertionFailure( "beforeExecutions() called for non-collection action" );
 	}
 
 	@Override
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + MessageHelper.infoString( entityName, id );
 	}
 
 	@Override
 	public int compareTo(Object other) {
 		EntityAction action = ( EntityAction ) other;
 		//sort first by entity name
 		int roleComparison = entityName.compareTo( action.entityName );
 		if ( roleComparison != 0 ) {
 			return roleComparison;
 		}
 		else {
 			//then by id
 			return persister.getIdentifierType().compare( id, action.id, session.getEntityMode() );
 		}
 	}
 
 	/**
 	 * Reconnect to session after deserialization...
 	 *
 	 * @param session The session being deserialized
 	 */
 	public void afterDeserialize(SessionImplementor session) {
 		if ( this.session != null || this.persister != null ) {
 			throw new IllegalStateException( "already attached to a session." );
 		}
 		// IMPL NOTE: non-flushed changes code calls this method with session == null...
 		// guard against NullPointerException
 		if ( session != null ) {
 			this.session = session;
 			this.persister = session.getFactory().getEntityPersister( entityName );
 			this.instance = session.getPersistenceContext().getEntity( session.generateEntityKey( id, persister ) );
 		}
 	}
 
 	protected <T> EventListenerGroup<T> listenerGroup(EventType<T> eventType) {
 		return getSession()
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( eventType );
 	}
 
 	protected EventSource eventSource() {
 		return (EventSource) getSession();
 	}
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityDeleteAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityDeleteAction.java
index 8e7bd5f058..341518bc58 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityDeleteAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityDeleteAction.java
@@ -1,180 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.SoftLock;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostDeleteEvent;
-import org.hibernate.event.PostDeleteEventListener;
-import org.hibernate.event.PreDeleteEvent;
-import org.hibernate.event.PreDeleteEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostDeleteEvent;
+import org.hibernate.event.spi.PostDeleteEventListener;
+import org.hibernate.event.spi.PreDeleteEvent;
+import org.hibernate.event.spi.PreDeleteEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class EntityDeleteAction extends EntityAction {
 	private final Object version;
 	private final boolean isCascadeDeleteEnabled;
 	private final Object[] state;
 
 	private SoftLock lock;
 
 	public EntityDeleteAction(
 			final Serializable id,
 	        final Object[] state,
 	        final Object version,
 	        final Object instance,
 	        final EntityPersister persister,
 	        final boolean isCascadeDeleteEnabled,
 	        final SessionImplementor session) {
 		super( session, id, instance, persister );
 		this.version = version;
 		this.isCascadeDeleteEnabled = isCascadeDeleteEnabled;
 		this.state = state;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		Serializable id = getId();
 		EntityPersister persister = getPersister();
 		SessionImplementor session = getSession();
 		Object instance = getInstance();
 
 		boolean veto = preDelete();
 
 		Object version = this.version;
 		if ( persister.isVersionPropertyGenerated() ) {
 			// we need to grab the version value from the entity, otherwise
 			// we have issues with generated-version entities that may have
 			// multiple actions queued during the same flush
 			version = persister.getVersion( instance, session.getEntityMode() );
 		}
 
 		final CacheKey ck;
 		if ( persister.hasCache() ) {
 			ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
 			lock = persister.getCacheAccessStrategy().lockItem( ck, version );
 		}
 		else {
 			ck = null;
 		}
 
 		if ( !isCascadeDeleteEnabled && !veto ) {
 			persister.delete( id, version, instance, session );
 		}
 		
 		//postDelete:
 		// After actually deleting a row, record the fact that the instance no longer 
 		// exists on the database (needed for identity-column key generation), and
 		// remove it from the session cache
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		EntityEntry entry = persistenceContext.removeEntry( instance );
 		if ( entry == null ) {
 			throw new AssertionFailure( "possible nonthreadsafe access to session" );
 		}
 		entry.postDelete();
 
 		persistenceContext.removeEntity( entry.getEntityKey() );
 		persistenceContext.removeProxy( entry.getEntityKey() );
 		
 		if ( persister.hasCache() ) {
 			persister.getCacheAccessStrategy().remove( ck );
 		}
 
 		postDelete();
 
 		if ( getSession().getFactory().getStatistics().isStatisticsEnabled() && !veto ) {
 			getSession().getFactory().getStatisticsImplementor().deleteEntity( getPersister().getEntityName() );
 		}
 	}
 
 	private boolean preDelete() {
 		boolean veto = false;
 		EventListenerGroup<PreDeleteEventListener> listenerGroup = listenerGroup( EventType.PRE_DELETE );
 		if ( listenerGroup.isEmpty() ) {
 			return veto;
 		}
 		final PreDeleteEvent event = new PreDeleteEvent( getInstance(), getId(), state, getPersister(), eventSource() );
 		for ( PreDeleteEventListener listener : listenerGroup.listeners() ) {
 			veto |= listener.onPreDelete( event );
 		}
 		return veto;
 	}
 
 	private void postDelete() {
 		EventListenerGroup<PostDeleteEventListener> listenerGroup = listenerGroup( EventType.POST_DELETE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostDeleteEvent event = new PostDeleteEvent(
 				getInstance(),
 				getId(),
 				state,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostDeleteEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostDelete( event );
 		}
 	}
 
 	private void postCommitDelete() {
 		EventListenerGroup<PostDeleteEventListener> listenerGroup = listenerGroup( EventType.POST_COMMIT_DELETE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostDeleteEvent event = new PostDeleteEvent(
 				getInstance(),
 				getId(),
 				state,
 				getPersister(),
 				eventSource()
 		);
 	}
 
 	@Override
 	public void doAfterTransactionCompletion(boolean success, SessionImplementor session) throws HibernateException {
 		if ( getPersister().hasCache() ) {
 			final CacheKey ck = getSession().generateCacheKey(
 					getId(),
 					getPersister().getIdentifierType(),
 					getPersister().getRootEntityName()
 			);
 			getPersister().getCacheAccessStrategy().unlockItem( ck, lock );
 		}
 		postCommitDelete();
 	}
 
 	@Override
 	protected boolean hasPostCommitEventListeners() {
 		return ! listenerGroup( EventType.POST_COMMIT_DELETE ).isEmpty();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityIdentityInsertAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityIdentityInsertAction.java
index 419253692d..b38843bce5 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityIdentityInsertAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityIdentityInsertAction.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostInsertEvent;
-import org.hibernate.event.PostInsertEventListener;
-import org.hibernate.event.PreInsertEvent;
-import org.hibernate.event.PreInsertEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostInsertEvent;
+import org.hibernate.event.spi.PostInsertEventListener;
+import org.hibernate.event.spi.PreInsertEvent;
+import org.hibernate.event.spi.PreInsertEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class EntityIdentityInsertAction extends EntityAction  {
 
 	private transient Object[] state;
 	private final boolean isDelayed;
 	private final EntityKey delayedEntityKey;
 	//private CacheEntry cacheEntry;
 	private Serializable generatedId;
 
 	public EntityIdentityInsertAction(
 			Object[] state,
 	        Object instance,
 	        EntityPersister persister,
 	        SessionImplementor session,
 	        boolean isDelayed) throws HibernateException {
 		super(
 				session,
 				( isDelayed ? generateDelayedPostInsertIdentifier() : null ),
 				instance,
 				persister
 		);
 		this.state = state;
 		this.isDelayed = isDelayed;
 		this.delayedEntityKey = isDelayed ? generateDelayedEntityKey() : null;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		final EntityPersister persister = getPersister();
 		final SessionImplementor session = getSession();
 		final Object instance = getInstance();
 
 		boolean veto = preInsert();
 
 		// Don't need to lock the cache here, since if someone
 		// else inserted the same pk first, the insert would fail
 
 		if ( !veto ) {
 			generatedId = persister.insert( state, instance, session );
 			if ( persister.hasInsertGeneratedProperties() ) {
 				persister.processInsertGeneratedProperties( generatedId, instance, state, session );
 			}
 			//need to do that here rather than in the save event listener to let
 			//the post insert events to have a id-filled entity when IDENTITY is used (EJB3)
 			persister.setIdentifier( instance, generatedId, session );
 			getSession().getPersistenceContext().registerInsertedKey( getPersister(), generatedId );
 		}
 
 
 		//TODO: this bit actually has to be called after all cascades!
 		//      but since identity insert is called *synchronously*,
 		//      instead of asynchronously as other actions, it isn't
 		/*if ( persister.hasCache() && !persister.isCacheInvalidationRequired() ) {
 			cacheEntry = new CacheEntry(object, persister, session);
 			persister.getCache().insert(generatedId, cacheEntry);
 		}*/
 
 		postInsert();
 
 		if ( session.getFactory().getStatistics().isStatisticsEnabled() && !veto ) {
 			session.getFactory().getStatisticsImplementor().insertEntity( getPersister().getEntityName() );
 		}
 
 	}
 
 	@Override
     public boolean needsAfterTransactionCompletion() {
 		//TODO: simply remove this override if we fix the above todos
 		return hasPostCommitEventListeners();
 	}
 
 	@Override
     protected boolean hasPostCommitEventListeners() {
 		return ! listenerGroup( EventType.POST_COMMIT_INSERT ).isEmpty();
 	}
 
 	@Override
 	public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {
 		//TODO: reenable if we also fix the above todo
 		/*EntityPersister persister = getEntityPersister();
 		if ( success && persister.hasCache() && !persister.isCacheInvalidationRequired() ) {
 			persister.getCache().afterInsert( getGeneratedId(), cacheEntry );
 		}*/
 		postCommitInsert();
 	}
 
 	private void postInsert() {
 		if ( isDelayed ) {
 			getSession().getPersistenceContext().replaceDelayedEntityIdentityInsertKeys( delayedEntityKey, generatedId );
 		}
 
 		EventListenerGroup<PostInsertEventListener> listenerGroup = listenerGroup( EventType.POST_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostInsertEvent event = new PostInsertEvent(
 				getInstance(),
 				generatedId,
 				state,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostInsertEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostInsert( event );
 		}
 	}
 
 	private void postCommitInsert() {
 		EventListenerGroup<PostInsertEventListener> listenerGroup = listenerGroup( EventType.POST_COMMIT_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostInsertEvent event = new PostInsertEvent(
 				getInstance(),
 				generatedId,
 				state,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostInsertEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostInsert( event );
 		}
 	}
 
 	private boolean preInsert() {
 		EventListenerGroup<PreInsertEventListener> listenerGroup = listenerGroup( EventType.PRE_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return false; // NO_VETO
 		}
 		boolean veto = false;
 		final PreInsertEvent event = new PreInsertEvent( getInstance(), null, state, getPersister(), eventSource() );
 		for ( PreInsertEventListener listener : listenerGroup.listeners() ) {
 			veto |= listener.onPreInsert( event );
 		}
 		return veto;
 	}
 
 	public final Serializable getGeneratedId() {
 		return generatedId;
 	}
 
 	public EntityKey getDelayedEntityKey() {
 		return delayedEntityKey;
 	}
 
 	private synchronized static DelayedPostInsertIdentifier generateDelayedPostInsertIdentifier() {
 		return new DelayedPostInsertIdentifier();
 	}
 
 	private EntityKey generateDelayedEntityKey() {
 		if ( !isDelayed ) {
 			throw new AssertionFailure( "cannot request delayed entity-key for non-delayed post-insert-id generation" );
 		}
 		return getSession().generateEntityKey( getDelayedId(), getPersister() );
 	}
 
 	@Override
     public void afterDeserialize(SessionImplementor session) {
 		super.afterDeserialize( session );
 		// IMPL NOTE: non-flushed changes code calls this method with session == null...
 		// guard against NullPointerException
 		if ( session != null ) {
 			EntityEntry entityEntry = session.getPersistenceContext().getEntry( getInstance() );
 			this.state = entityEntry.getLoadedState();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityInsertAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityInsertAction.java
index 6d71c65bdd..1c324947da 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityInsertAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityInsertAction.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostInsertEvent;
-import org.hibernate.event.PostInsertEventListener;
-import org.hibernate.event.PreInsertEvent;
-import org.hibernate.event.PreInsertEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostInsertEvent;
+import org.hibernate.event.spi.PostInsertEventListener;
+import org.hibernate.event.spi.PreInsertEvent;
+import org.hibernate.event.spi.PreInsertEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 
 public final class EntityInsertAction extends EntityAction {
 
 	private Object[] state;
 	private Object version;
 	private Object cacheEntry;
 
 	public EntityInsertAction(
 	        Serializable id,
 	        Object[] state,
 	        Object instance,
 	        Object version,
 	        EntityPersister persister,
 	        SessionImplementor session) throws HibernateException {
 		super( session, id, instance, persister );
 		this.state = state;
 		this.version = version;
 	}
 
 	public Object[] getState() {
 		return state;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		EntityPersister persister = getPersister();
 		SessionImplementor session = getSession();
 		Object instance = getInstance();
 		Serializable id = getId();
 
 		boolean veto = preInsert();
 
 		// Don't need to lock the cache here, since if someone
 		// else inserted the same pk first, the insert would fail
 
 		if ( !veto ) {
 			
 			persister.insert( id, state, instance, session );
 		
 			EntityEntry entry = session.getPersistenceContext().getEntry( instance );
 			if ( entry == null ) {
 				throw new AssertionFailure( "possible nonthreadsafe access to session" );
 			}
 			
 			entry.postInsert();
 	
 			if ( persister.hasInsertGeneratedProperties() ) {
 				persister.processInsertGeneratedProperties( id, instance, state, session );
 				if ( persister.isVersionPropertyGenerated() ) {
 					version = Versioning.getVersion( state, persister );
 				}
 				entry.postUpdate(instance, state, version);
 			}
 
 			getSession().getPersistenceContext().registerInsertedKey( getPersister(), getId() );
 		}
 
 		final SessionFactoryImplementor factory = getSession().getFactory();
 
 		if ( isCachePutEnabled( persister, session ) ) {
 			
 			CacheEntry ce = new CacheEntry(
 					state,
 					persister, 
 					persister.hasUninitializedLazyProperties( instance, session.getEntityMode() ),
 					version,
 					session,
 					instance
 				);
 			
 			cacheEntry = persister.getCacheEntryStructure().structure(ce);
 			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
 			boolean put = persister.getCacheAccessStrategy().insert( ck, cacheEntry, version );
 			
 			if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 				factory.getStatisticsImplementor().secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
 			}
 			
 		}
 
 		postInsert();
 
 		if ( factory.getStatistics().isStatisticsEnabled() && !veto ) {
 			factory.getStatisticsImplementor()
 					.insertEntity( getPersister().getEntityName() );
 		}
 
 	}
 
 	private void postInsert() {
 		EventListenerGroup<PostInsertEventListener> listenerGroup = listenerGroup( EventType.POST_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostInsertEvent event = new PostInsertEvent(
 				getInstance(),
 				getId(),
 				state,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostInsertEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostInsert( event );
 		}
 	}
 
 	private void postCommitInsert() {
 		EventListenerGroup<PostInsertEventListener> listenerGroup = listenerGroup( EventType.POST_COMMIT_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostInsertEvent event = new PostInsertEvent(
 				getInstance(),
 				getId(),
 				state,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostInsertEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostInsert( event );
 		}
 	}
 
 	private boolean preInsert() {
 		boolean veto = false;
 
 		EventListenerGroup<PreInsertEventListener> listenerGroup = listenerGroup( EventType.PRE_INSERT );
 		if ( listenerGroup.isEmpty() ) {
 			return veto;
 		}
 		final PreInsertEvent event = new PreInsertEvent( getInstance(), getId(), state, getPersister(), eventSource() );
 		for ( PreInsertEventListener listener : listenerGroup.listeners() ) {
 			veto |= listener.onPreInsert( event );
 		}
 		return veto;
 	}
 
 	@Override
 	public void doAfterTransactionCompletion(boolean success, SessionImplementor session) throws HibernateException {
 		EntityPersister persister = getPersister();
 		if ( success && isCachePutEnabled( persister, getSession() ) ) {
 			final CacheKey ck = getSession().generateCacheKey( getId(), persister.getIdentifierType(), persister.getRootEntityName() );
 			boolean put = persister.getCacheAccessStrategy().afterInsert( ck, cacheEntry, version );
 			
 			if ( put && getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
 				getSession().getFactory().getStatisticsImplementor()
 						.secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
 			}
 		}
 		postCommitInsert();
 	}
 
 	@Override
 	protected boolean hasPostCommitEventListeners() {
 		return ! listenerGroup( EventType.POST_COMMIT_INSERT ).isEmpty();
 	}
 	
 	private boolean isCachePutEnabled(EntityPersister persister, SessionImplementor session) {
 		return persister.hasCache()
 				&& !persister.isCacheInvalidationRequired()
 				&& session.getCacheMode().isPutEnabled();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityUpdateAction.java b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityUpdateAction.java
index 4b82309206..cc4f441cc6 100644
--- a/hibernate-core/src/main/java/org/hibernate/action/internal/EntityUpdateAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/action/internal/EntityUpdateAction.java
@@ -1,274 +1,274 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.action.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.SoftLock;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostUpdateEvent;
-import org.hibernate.event.PostUpdateEventListener;
-import org.hibernate.event.PreUpdateEvent;
-import org.hibernate.event.PreUpdateEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostUpdateEvent;
+import org.hibernate.event.spi.PostUpdateEventListener;
+import org.hibernate.event.spi.PreUpdateEvent;
+import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.type.TypeHelper;
 
 public final class EntityUpdateAction extends EntityAction {
 	private final Object[] state;
 	private final Object[] previousState;
 	private final Object previousVersion;
 	private final int[] dirtyFields;
 	private final boolean hasDirtyCollection;
 	private final Object rowId;
 	private Object nextVersion;
 	private Object cacheEntry;
 	private SoftLock lock;
 
 	public EntityUpdateAction(
 	        final Serializable id,
 	        final Object[] state,
 	        final int[] dirtyProperties,
 	        final boolean hasDirtyCollection,
 	        final Object[] previousState,
 	        final Object previousVersion,
 	        final Object nextVersion,
 	        final Object instance,
 	        final Object rowId,
 	        final EntityPersister persister,
 	        final SessionImplementor session) throws HibernateException {
 		super( session, id, instance, persister );
 		this.state = state;
 		this.previousState = previousState;
 		this.previousVersion = previousVersion;
 		this.nextVersion = nextVersion;
 		this.dirtyFields = dirtyProperties;
 		this.hasDirtyCollection = hasDirtyCollection;
 		this.rowId = rowId;
 	}
 
 	@Override
 	public void execute() throws HibernateException {
 		Serializable id = getId();
 		EntityPersister persister = getPersister();
 		SessionImplementor session = getSession();
 		Object instance = getInstance();
 
 		boolean veto = preUpdate();
 
 		final SessionFactoryImplementor factory = getSession().getFactory();
 		Object previousVersion = this.previousVersion;
 		if ( persister.isVersionPropertyGenerated() ) {
 			// we need to grab the version value from the entity, otherwise
 			// we have issues with generated-version entities that may have
 			// multiple actions queued during the same flush
 			previousVersion = persister.getVersion( instance, session.getEntityMode() );
 		}
 		
 		final CacheKey ck;
 		if ( persister.hasCache() ) {
 			ck = session.generateCacheKey(
 					id, 
 					persister.getIdentifierType(), 
 					persister.getRootEntityName()
 			);
 			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );
 		}
 		else {
 			ck = null;
 		}
 
 		if ( !veto ) {
 			persister.update( 
 					id, 
 					state, 
 					dirtyFields, 
 					hasDirtyCollection, 
 					previousState, 
 					previousVersion, 
 					instance, 
 					rowId, 
 					session 
 			);
 		}
 
 		EntityEntry entry = getSession().getPersistenceContext().getEntry( instance );
 		if ( entry == null ) {
 			throw new AssertionFailure( "possible nonthreadsafe access to session" );
 		}
 		
 		if ( entry.getStatus()==Status.MANAGED || persister.isVersionPropertyGenerated() ) {
 			// get the updated snapshot of the entity state by cloning current state;
 			// it is safe to copy in place, since by this time no-one else (should have)
 			// has a reference  to the array
 			TypeHelper.deepCopy(
 					state,
 					persister.getPropertyTypes(),
 					persister.getPropertyCheckability(),
 					state,
 					session
 			);
 			if ( persister.hasUpdateGeneratedProperties() ) {
 				// this entity defines proeprty generation, so process those generated
 				// values...
 				persister.processUpdateGeneratedProperties( id, instance, state, session );
 				if ( persister.isVersionPropertyGenerated() ) {
 					nextVersion = Versioning.getVersion( state, persister );
 				}
 			}
 			// have the entity entry doAfterTransactionCompletion post-update processing, passing it the
 			// update state and the new version (if one).
 			entry.postUpdate( instance, state, nextVersion );
 		}
 
 		if ( persister.hasCache() ) {
 			if ( persister.isCacheInvalidationRequired() || entry.getStatus()!= Status.MANAGED ) {
 				persister.getCacheAccessStrategy().remove( ck );
 			}
 			else {
 				//TODO: inefficient if that cache is just going to ignore the updated state!
 				CacheEntry ce = new CacheEntry(
 						state, 
 						persister, 
 						persister.hasUninitializedLazyProperties( instance, session.getEntityMode() ), 
 						nextVersion,
 						getSession(),
 						instance
 				);
 				cacheEntry = persister.getCacheEntryStructure().structure( ce );
 				boolean put = persister.getCacheAccessStrategy().update( ck, cacheEntry, nextVersion, previousVersion );
 				if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 					factory.getStatisticsImplementor().secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
 				}
 			}
 		}
 
 		postUpdate();
 
 		if ( factory.getStatistics().isStatisticsEnabled() && !veto ) {
 			factory.getStatisticsImplementor()
 					.updateEntity( getPersister().getEntityName() );
 		}
 	}
 
 	private boolean preUpdate() {
 		boolean veto = false;
 		EventListenerGroup<PreUpdateEventListener> listenerGroup = listenerGroup( EventType.PRE_UPDATE );
 		if ( listenerGroup.isEmpty() ) {
 			return veto;
 		}
 		final PreUpdateEvent event = new PreUpdateEvent(
 				getInstance(),
 				getId(),
 				state,
 				previousState,
 				getPersister(),
 				eventSource()
 		);
 		for ( PreUpdateEventListener listener : listenerGroup.listeners() ) {
 			veto |= listener.onPreUpdate( event );
 		}
 		return veto;
 	}
 
 	private void postUpdate() {
 		EventListenerGroup<PostUpdateEventListener> listenerGroup = listenerGroup( EventType.POST_UPDATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostUpdateEvent event = new PostUpdateEvent(
 				getInstance(),
 				getId(),
 				state,
 				previousState,
 				dirtyFields,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostUpdateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostUpdate( event );
 		}
 	}
 
 	private void postCommitUpdate() {
 		EventListenerGroup<PostUpdateEventListener> listenerGroup = listenerGroup( EventType.POST_COMMIT_UPDATE );
 		if ( listenerGroup.isEmpty() ) {
 			return;
 		}
 		final PostUpdateEvent event = new PostUpdateEvent(
 				getInstance(),
 				getId(),
 				state,
 				previousState,
 				dirtyFields,
 				getPersister(),
 				eventSource()
 		);
 		for ( PostUpdateEventListener listener : listenerGroup.listeners() ) {
 			listener.onPostUpdate( event );
 		}
 	}
 
 	@Override
 	protected boolean hasPostCommitEventListeners() {
 		return ! listenerGroup( EventType.POST_COMMIT_UPDATE ).isEmpty();
 	}
 
 	@Override
 	public void doAfterTransactionCompletion(boolean success, SessionImplementor session) throws CacheException {
 		EntityPersister persister = getPersister();
 		if ( persister.hasCache() ) {
 			
 			final CacheKey ck = getSession().generateCacheKey(
 					getId(), 
 					persister.getIdentifierType(), 
 					persister.getRootEntityName()
 				);
 			
 			if ( success && cacheEntry!=null /*!persister.isCacheInvalidationRequired()*/ ) {
 				boolean put = persister.getCacheAccessStrategy().afterUpdate( ck, cacheEntry, nextVersion, previousVersion, lock );
 				
 				if ( put && getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
 					getSession().getFactory().getStatisticsImplementor().secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
 				}
 			}
 			else {
 				persister.getCacheAccessStrategy().unlockItem( ck, lock );
 			}
 		}
 		postCommitUpdate();
 	}
 
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/CacheEntry.java b/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/CacheEntry.java
index d8d3a2a7ad..667643fab7 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/CacheEntry.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/CacheEntry.java
@@ -1,171 +1,171 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.spi.entry;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PreLoadEvent;
-import org.hibernate.event.PreLoadEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PreLoadEvent;
+import org.hibernate.event.spi.PreLoadEventListener;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.type.TypeHelper;
 
 /**
  * A cached instance of a persistent class
  *
  * @author Gavin King
  */
 public final class CacheEntry implements Serializable {
 
 	private final Serializable[] disassembledState;
 	private final String subclass;
 	private final boolean lazyPropertiesAreUnfetched;
 	private final Object version;
 	
 	public String getSubclass() {
 		return subclass;
 	}
 	
 	public boolean areLazyPropertiesUnfetched() {
 		return lazyPropertiesAreUnfetched;
 	}
 	
 	public CacheEntry(
 			final Object[] state, 
 			final EntityPersister persister, 
 			final boolean unfetched, 
 			final Object version,
 			final SessionImplementor session, 
 			final Object owner) 
 	throws HibernateException {
 		//disassembled state gets put in a new array (we write to cache by value!)
 		this.disassembledState = TypeHelper.disassemble(
 				state, 
 				persister.getPropertyTypes(), 
 				persister.isLazyPropertiesCacheable() ? 
 					null : persister.getPropertyLaziness(),
 				session, 
 				owner 
 			);
 		subclass = persister.getEntityName();
 		lazyPropertiesAreUnfetched = unfetched || !persister.isLazyPropertiesCacheable();
 		this.version = version;
 	}
 	
 	public Object getVersion() {
 		return version;
 	}
 
 	CacheEntry(Serializable[] state, String subclass, boolean unfetched, Object version) {
 		this.disassembledState = state;
 		this.subclass = subclass;
 		this.lazyPropertiesAreUnfetched = unfetched;
 		this.version = version;
 	}
 
 	public Object[] assemble(
 			final Object instance, 
 			final Serializable id, 
 			final EntityPersister persister, 
 			final Interceptor interceptor, 
 			final EventSource session) 
 	throws HibernateException {
 
 		if ( !persister.getEntityName().equals(subclass) ) {
 			throw new AssertionFailure("Tried to assemble a different subclass instance");
 		}
 
 		return assemble(disassembledState, instance, id, persister, interceptor, session);
 
 	}
 
 	private static Object[] assemble(
 			final Serializable[] values, 
 			final Object result, 
 			final Serializable id, 
 			final EntityPersister persister, 
 			final Interceptor interceptor, 
 			final EventSource session) throws HibernateException {
 			
 		//assembled state gets put in a new array (we read from cache by value!)
 		Object[] assembledProps = TypeHelper.assemble(
 				values, 
 				persister.getPropertyTypes(), 
 				session, result 
 			);
 
 		//persister.setIdentifier(result, id); //before calling interceptor, for consistency with normal load
 
 		//TODO: reuse the PreLoadEvent
 		final PreLoadEvent preLoadEvent = new PreLoadEvent( session )
 				.setEntity( result )
 				.setState( assembledProps )
 				.setId( id )
 				.setPersister( persister );
 
 		final EventListenerGroup<PreLoadEventListener> listenerGroup = session
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( EventType.PRE_LOAD );
 		for ( PreLoadEventListener listener : listenerGroup.listeners() ) {
 			listener.onPreLoad( preLoadEvent );
 		}
 
 		persister.setPropertyValues( 
 				result, 
 				assembledProps, 
 				session.getEntityMode() 
 			);
 
 		return assembledProps;
 	}
 
     public Serializable[] getDisassembledState() {
 	    // todo: this was added to support initializing an entity's EntityEntry snapshot during reattach;
 	    // this should be refactored to instead expose a method to assemble a EntityEntry based on this
 	    // state for return.
 	    return disassembledState;
     }
 
 	public String toString() {
 		return "CacheEntry(" + subclass + ')' + 
 				ArrayHelper.toString(disassembledState);
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index be0cc13139..7a6e922abc 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -1,1131 +1,1131 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.MapsId;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.io.StringReader;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
 import org.dom4j.Attribute;
 import org.dom4j.Document;
 import org.dom4j.DocumentException;
 import org.dom4j.Element;
 import org.jboss.logging.Logger;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.Interceptor;
 import org.hibernate.InvalidMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.common.reflection.MetadataProvider;
 import org.hibernate.annotations.common.reflection.MetadataProviderInjector;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentifierGeneratorAggregator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.DefaultIdentifierGeneratorFactory;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.internal.util.xml.MappingReader;
 import org.hibernate.internal.util.xml.Origin;
 import org.hibernate.internal.util.xml.OriginImpl;
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.internal.util.xml.XmlDocumentImpl;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.FetchProfile;
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.IdGenerator;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.Index;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.MappedSuperclass;
 import org.hibernate.mapping.MetadataSource;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.TypeDef;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.proxy.EntityNotFoundDelegate;
-import org.hibernate.secure.JACCConfiguration;
+import org.hibernate.secure.internal.JACCConfiguration;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
 import org.hibernate.tool.hbm2ddl.IndexMetadata;
 import org.hibernate.tool.hbm2ddl.TableMetadata;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 /**
  * An instance of <tt>Configuration</tt> allows the application
  * to specify properties and mapping documents to be used when
  * creating a <tt>SessionFactory</tt>. Usually an application will create
  * a single <tt>Configuration</tt>, build a single instance of
  * <tt>SessionFactory</tt> and then instantiate <tt>Session</tt>s in
  * threads servicing client requests. The <tt>Configuration</tt> is meant
  * only as an initialization-time object. <tt>SessionFactory</tt>s are
  * immutable and do not retain any association back to the
  * <tt>Configuration</tt>.<br>
  * <br>
  * A new <tt>Configuration</tt> will use the properties specified in
  * <tt>hibernate.properties</tt> by default.
  *
  * @author Gavin King
  * @see org.hibernate.SessionFactory
  *
  * @deprecated use {@link ServiceRegistryBuilder} and {@link org.hibernate.metamodel.MetadataSources} instead.  See
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6183">HHH-6183</a> and
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-2578">HHH-2578</a> for details
  */
 @Deprecated
 public class Configuration implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Configuration.class.getName());
 
 	public static final String DEFAULT_CACHE_CONCURRENCY_STRATEGY = AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 
 	public static final String USE_NEW_ID_GENERATOR_MAPPINGS = AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS;
 
 	public static final String ARTEFACT_PROCESSING_ORDER = "hibernate.mapping.precedence";
 
 	/**
 	 * Class name of the class needed to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_CLASS = "org.hibernate.search.event.EventListenerRegister";
 
 	/**
 	 * Method to call to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_METHOD = "enableHibernateSearch";
 
 	protected MetadataSourceQueue metadataSourceQueue;
 	private transient ReflectionManager reflectionManager;
 
 	protected Map<String, PersistentClass> classes;
 	protected Map<String, String> imports;
 	protected Map<String, Collection> collections;
 	protected Map<String, Table> tables;
 	protected List<AuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
 
 	protected Map<String, NamedQueryDefinition> namedQueries;
 	protected Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	protected Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 
 	protected Map<String, TypeDef> typeDefs;
 	protected Map<String, FilterDefinition> filterDefinitions;
 	protected Map<String, FetchProfile> fetchProfiles;
 
 	protected Map tableNameBinding;
 	protected Map columnNameBindingPerTable;
 
 	protected List<SecondPass> secondPasses;
 	protected List<Mappings.PropertyReference> propertyReferences;
 	protected Map<ExtendsQueueEntry, ?> extendsQueue;
 
 	protected Map<String, SQLFunction> sqlFunctions;
 	private TypeResolver typeResolver = new TypeResolver();
 
 	private EntityTuplizerFactory entityTuplizerFactory;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 
 	private Interceptor interceptor;
 	private Properties properties;
 	private EntityResolver entityResolver;
 	private EntityNotFoundDelegate entityNotFoundDelegate;
 
 	protected transient XMLHelper xmlHelper;
 	protected NamingStrategy namingStrategy;
 	private SessionFactoryObserver sessionFactoryObserver;
 
 	protected final SettingsFactory settingsFactory;
 
 	private transient Mapping mapping = buildMapping();
 
 	private DefaultIdentifierGeneratorFactory identifierGeneratorFactory;
 
 	private Map<Class<?>, org.hibernate.mapping.MappedSuperclass> mappedSuperClasses;
 
 	private Map<String, IdGenerator> namedGenerators;
 	private Map<String, Map<String, Join>> joins;
 	private Map<String, AnnotatedClassType> classTypes;
 	private Set<String> defaultNamedQueryNames;
 	private Set<String> defaultNamedNativeQueryNames;
 	private Set<String> defaultSqlResultSetMappingNames;
 	private Set<String> defaultNamedGenerators;
 	private Map<String, Properties> generatorTables;
 	private Map<Table, List<UniqueConstraintHolder>> uniqueConstraintHoldersByTable;
 	private Map<String, String> mappedByResolver;
 	private Map<String, String> propertyRefResolver;
 	private Map<String, AnyMetaDef> anyMetaDefs;
 	private List<CacheHolder> caches;
 	private boolean inSecondPass = false;
 	private boolean isDefaultProcessed = false;
 	private boolean isValidatorNotPresentLogged;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithMapsId;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithIdAndToOne;
 	private boolean specjProprietarySyntaxEnabled;
 
 
 	protected Configuration(SettingsFactory settingsFactory) {
 		this.settingsFactory = settingsFactory;
 		reset();
 	}
 
 	public Configuration() {
 		this( new SettingsFactory() );
 	}
 
 	protected void reset() {
 		metadataSourceQueue = new MetadataSourceQueue();
 		createReflectionManager();
 
 		classes = new HashMap<String,PersistentClass>();
 		imports = new HashMap<String,String>();
 		collections = new HashMap<String,Collection>();
 		tables = new TreeMap<String,Table>();
 
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		namedSqlQueries = new HashMap<String,NamedSQLQueryDefinition>();
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 
 		typeDefs = new HashMap<String,TypeDef>();
 		filterDefinitions = new HashMap<String, FilterDefinition>();
 		fetchProfiles = new HashMap<String, FetchProfile>();
 		auxiliaryDatabaseObjects = new ArrayList<AuxiliaryDatabaseObject>();
 
 		tableNameBinding = new HashMap();
 		columnNameBindingPerTable = new HashMap();
 
 		secondPasses = new ArrayList<SecondPass>();
 		propertyReferences = new ArrayList<Mappings.PropertyReference>();
 		extendsQueue = new HashMap<ExtendsQueueEntry, String>();
 
 		xmlHelper = new XMLHelper();
 		interceptor = EmptyInterceptor.INSTANCE;
 		properties = Environment.getProperties();
 		entityResolver = XMLHelper.DEFAULT_DTD_RESOLVER;
 
 		sqlFunctions = new HashMap<String, SQLFunction>();
 
 		entityTuplizerFactory = new EntityTuplizerFactory();
 //		componentTuplizerFactory = new ComponentTuplizerFactory();
 
 		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
 
 		mappedSuperClasses = new HashMap<Class<?>, MappedSuperclass>();
 
 		metadataSourcePrecedence = Collections.emptyList();
 
 		namedGenerators = new HashMap<String, IdGenerator>();
 		joins = new HashMap<String, Map<String, Join>>();
 		classTypes = new HashMap<String, AnnotatedClassType>();
 		generatorTables = new HashMap<String, Properties>();
 		defaultNamedQueryNames = new HashSet<String>();
 		defaultNamedNativeQueryNames = new HashSet<String>();
 		defaultSqlResultSetMappingNames = new HashSet<String>();
 		defaultNamedGenerators = new HashSet<String>();
 		uniqueConstraintHoldersByTable = new HashMap<Table, List<UniqueConstraintHolder>>();
 		mappedByResolver = new HashMap<String, String>();
 		propertyRefResolver = new HashMap<String, String>();
 		caches = new ArrayList<CacheHolder>();
 		namingStrategy = EJB3NamingStrategy.INSTANCE;
 		setEntityResolver( new EJB3DTDEntityResolver() );
 		anyMetaDefs = new HashMap<String, AnyMetaDef>();
 		propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		propertiesAnnotatedWithIdAndToOne = new HashMap<XClass, Map<String, PropertyData>>();
 		specjProprietarySyntaxEnabled = System.getProperty( "hibernate.enable_specj_proprietary_syntax" ) != null;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 	public ReflectionManager getReflectionManager() {
 		return reflectionManager;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	/**
 	 * Iterate the entity mappings
 	 *
 	 * @return Iterator of the entity mappings currently contained in the configuration.
 	 */
 	public Iterator<PersistentClass> getClassMappings() {
 		return classes.values().iterator();
 	}
 
 	/**
 	 * Iterate the collection mappings
 	 *
 	 * @return Iterator of the collection mappings currently contained in the configuration.
 	 */
 	public Iterator getCollectionMappings() {
 		return collections.values().iterator();
 	}
 
 	/**
 	 * Iterate the table mappings
 	 *
 	 * @return Iterator of the table mappings currently contained in the configuration.
 	 */
 	public Iterator<Table> getTableMappings() {
 		return tables.values().iterator();
 	}
 
 	/**
 	 * Iterate the mapped super class mappings
 	 * EXPERIMENTAL Consider this API as PRIVATE
 	 *
 	 * @return iterator over the MappedSuperclass mapping currently contained in the configuration.
 	 */
 	public Iterator<MappedSuperclass> getMappedSuperclassMappings() {
 		return mappedSuperClasses.values().iterator();
 	}
 
 	/**
 	 * Get the mapping for a particular entity
 	 *
 	 * @param entityName An entity name.
 	 * @return the entity mapping information
 	 */
 	public PersistentClass getClassMapping(String entityName) {
 		return classes.get( entityName );
 	}
 
 	/**
 	 * Get the mapping for a particular collection role
 	 *
 	 * @param role a collection role
 	 * @return The collection mapping information
 	 */
 	public Collection getCollectionMapping(String role) {
 		return collections.get( role );
 	}
 
 	/**
 	 * Set a custom entity resolver. This entity resolver must be
 	 * set before addXXX(misc) call.
 	 * Default value is {@link org.hibernate.internal.util.xml.DTDEntityResolver}
 	 *
 	 * @param entityResolver entity resolver to use
 	 */
 	public void setEntityResolver(EntityResolver entityResolver) {
 		this.entityResolver = entityResolver;
 	}
 
 	public EntityResolver getEntityResolver() {
 		return entityResolver;
 	}
 
 	/**
 	 * Retrieve the user-supplied delegate to handle non-existent entity
 	 * scenarios.  May be null.
 	 *
 	 * @return The user-supplied delegate
 	 */
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	/**
 	 * Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
 	 * located by specified id.  This is mainly intended for EJB3 implementations to be able to
 	 * control how proxy initialization errors should be handled...
 	 *
 	 * @param entityNotFoundDelegate The delegate to use
 	 */
 	public void setEntityNotFoundDelegate(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates inability to locate or parse
 	 * the specified mapping file.
 	 * @see #addFile(java.io.File)
 	 */
 	public Configuration addFile(String xmlFile) throws MappingException {
 		return addFile( new File( xmlFile ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates inability to locate the specified mapping file.  Historically this could
 	 * have indicated a problem parsing the XML document, but that is now delayed until after {@link #buildMappings}
 	 */
 	public Configuration addFile(final File xmlFile) throws MappingException {
         LOG.readingMappingsFromFile(xmlFile.getPath());
 		final String name =  xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 		add( inputSource, "file", name );
 		return this;
 	}
 
 	private XmlDocument add(InputSource inputSource, String originType, String originName) {
 		return add( inputSource, new OriginImpl( originType, originName ) );
 	}
 
 	private XmlDocument add(InputSource inputSource, Origin origin) {
 		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );
 		add( metadataXml );
 		return metadataXml;
 	}
 
 	public void add(XmlDocument metadataXml) {
 		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
 			metadataSourceQueue.add( metadataXml );
 		}
 		else {
 			final MetadataProvider metadataProvider = ( (MetadataProviderInjector) reflectionManager ).getMetadataProvider();
 			JPAMetadataProvider jpaMetadataProvider = ( JPAMetadataProvider ) metadataProvider;
 			List<String> classNames = jpaMetadataProvider.getXMLContext().addDocument( metadataXml.getDocumentTree() );
 			for ( String className : classNames ) {
 				try {
 					metadataSourceQueue.add( reflectionManager.classForName( className, this.getClass() ) );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new AnnotationException( "Unable to load class defined in XML: " + className, e );
 				}
 			}
 		}
 	}
 
 	private static boolean isOrmXml(XmlDocument xmlDocument) {
 		return "entity-mappings".equals( xmlDocument.getDocumentTree().getRootElement().getName() );
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation
 	 * of the DOM structure of a particular mapping.  It is saved from a previous
 	 * call as a file with the name <tt>xmlFile + ".bin"</tt> where xmlFile is
 	 * the name of the original mapping file.
 	 * </p>
 	 * If a cached <tt>xmlFile + ".bin"</tt> exists and is newer than
 	 * <tt>xmlFile</tt> the <tt>".bin"</tt> file will be read directly. Otherwise
 	 * xmlFile is read and then serialized to <tt>xmlFile + ".bin"</tt> for use
 	 * the next time.
 	 *
 	 * @param xmlFile The cacheable mapping file to be added.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 */
 	public Configuration addCacheableFile(File xmlFile) throws MappingException {
 		File cachedFile = determineCachedDomFile( xmlFile );
 
 		try {
 			return addCacheableFileStrictly( xmlFile );
 		}
 		catch ( SerializationException e ) {
             LOG.unableToDeserializeCache(cachedFile.getPath(), e);
 		}
 		catch ( FileNotFoundException e ) {
             LOG.cachedFileNotFound( cachedFile.getPath(), e );
 		}
 
 		final String name = xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 
         LOG.readingMappingsFromFile(xmlFile.getPath());
 		XmlDocument metadataXml = add( inputSource, "file", name );
 
 		try {
             LOG.debugf("Writing cache file for: %s to: %s", xmlFile, cachedFile);
 			SerializationHelper.serialize( ( Serializable ) metadataXml.getDocumentTree(), new FileOutputStream( cachedFile ) );
         } catch (Exception e) {
             LOG.unableToWriteCachedFile(cachedFile.getPath(), e.getMessage());
 		}
 
 		return this;
 	}
 
 	private File determineCachedDomFile(File xmlFile) {
 		return new File( xmlFile.getAbsolutePath() + ".bin" );
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param xmlFile The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public Configuration addCacheableFileStrictly(File xmlFile) throws SerializationException, FileNotFoundException {
 		final File cachedFile = determineCachedDomFile( xmlFile );
 
 		final boolean useCachedFile = xmlFile.exists()
 				&& cachedFile.exists()
 				&& xmlFile.lastModified() < cachedFile.lastModified();
 
 		if ( ! useCachedFile ) {
 			throw new FileNotFoundException( "Cached file could not be found or could not be used" );
 		}
 
         LOG.readingCachedMappings(cachedFile);
 		Document document = ( Document ) SerializationHelper.deserialize( new FileInputStream( cachedFile ) );
 		add( new XmlDocumentImpl( document, "file", xmlFile.getAbsolutePath() ) );
 		return this;
 	}
 
 	/**
 	 * Add a cacheable mapping file.
 	 *
 	 * @param xmlFile The name of the file to be added.  This must be in a form
 	 * useable to simply construct a {@link java.io.File} instance.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public Configuration addCacheableFile(String xmlFile) throws MappingException {
 		return addCacheableFile( new File( xmlFile ) );
 	}
 
 
 	/**
 	 * Read mappings from a <tt>String</tt>
 	 *
 	 * @param xml an XML string
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates problems parsing the
 	 * given XML string
 	 */
 	public Configuration addXML(String xml) throws MappingException {
         LOG.debugf("Mapping XML:\n%s", xml);
 		final InputSource inputSource = new InputSource( new StringReader( xml ) );
 		add( inputSource, "string", "XML String" );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a <tt>URL</tt>
 	 *
 	 * @param url The url for the mapping document to be read.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the URL or processing
 	 * the mapping document.
 	 */
 	public Configuration addURL(URL url) throws MappingException {
 		final String urlExternalForm = url.toExternalForm();
 
         LOG.debugf("Reading mapping document from URL : %s", urlExternalForm);
 
 		try {
 			add( url.openStream(), "URL", urlExternalForm );
 		}
 		catch ( IOException e ) {
 			throw new InvalidMappingException( "Unable to open url stream [" + urlExternalForm + "]", "URL", urlExternalForm, e );
 		}
 		return this;
 	}
 
 	private XmlDocument add(InputStream inputStream, final String type, final String name) {
 		final InputSource inputSource = new InputSource( inputStream );
 		try {
 			return add( inputSource, type, name );
 		}
 		finally {
 			try {
 				inputStream.close();
 			}
 			catch ( IOException ignore ) {
                 LOG.trace("Was unable to close input stream");
 			}
 		}
 	}
 
 	/**
 	 * Read mappings from a DOM <tt>Document</tt>
 	 *
 	 * @param doc The DOM document
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the DOM or processing
 	 * the mapping document.
 	 */
 	public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
         LOG.debugf("Mapping Document:\n%s", doc);
 
 		final Document document = xmlHelper.createDOMReader().read( doc );
 		add( new XmlDocumentImpl( document, "unknown", null ) );
 
 		return this;
 	}
 
 	/**
 	 * Read mappings from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the stream, or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addInputStream(InputStream xmlInputStream) throws MappingException {
 		add( xmlInputStream, "input stream", null );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resource (i.e. classpath lookup).
 	 *
 	 * @param resourceName The resource name
 	 * @param classLoader The class loader to use.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName, ClassLoader classLoader) throws MappingException {
         LOG.readingMappingsFromResource(resourceName);
 		InputStream resourceInputStream = classLoader.getResourceAsStream( resourceName );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup)
 	 * trying different class loaders.
 	 *
 	 * @param resourceName The resource name
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName) throws MappingException {
         LOG.readingMappingsFromResource(resourceName);
 		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
 		InputStream resourceInputStream = null;
 		if ( contextClassLoader != null ) {
 			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			resourceInputStream = Environment.class.getClassLoader().getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class
 	 * named <tt>foo.bar.Foo</tt> is mapped by a file <tt>foo/bar/Foo.hbm.xml</tt>
 	 * which can be resolved as a classpath resource.
 	 *
 	 * @param persistentClass The mapped class
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addClass(Class persistentClass) throws MappingException {
 		String mappingResourceName = persistentClass.getName().replace( '.', '/' ) + ".hbm.xml";
         LOG.readingMappingsFromResource(mappingResourceName);
 		return addResource( mappingResourceName, persistentClass.getClassLoader() );
 	}
 
 	/**
 	 * Read metadata from the annotations associated with this class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Configuration addAnnotatedClass(Class annotatedClass) {
 		XClass xClass = reflectionManager.toXClass( annotatedClass );
 		metadataSourceQueue.add( xClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name
 	 *
 	 * @return this (for method chaining)
 	 *
 	 * @throws MappingException in case there is an error in the mapping data
 	 */
 	public Configuration addPackage(String packageName) throws MappingException {
         LOG.debugf( "Mapping Package %s", packageName );
 		try {
 			AnnotationBinder.bindPackage( packageName, createMappings() );
 			return this;
 		}
 		catch ( MappingException me ) {
             LOG.unableToParseMetadata(packageName);
 			throw me;
 		}
 	}
 
 	/**
 	 * Read all mappings from a jar file
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addJar(File jar) throws MappingException {
         LOG.searchingForMappingDocuments(jar.getName());
 		JarFile jarFile = null;
 		try {
 			try {
 				jarFile = new JarFile( jar );
 			}
 			catch (IOException ioe) {
 				throw new InvalidMappingException(
 						"Could not read mapping documents from jar: " + jar.getName(), "jar", jar.getName(),
 						ioe
 				);
 			}
 			Enumeration jarEntries = jarFile.entries();
 			while ( jarEntries.hasMoreElements() ) {
 				ZipEntry ze = (ZipEntry) jarEntries.nextElement();
 				if ( ze.getName().endsWith( ".hbm.xml" ) ) {
                     LOG.foundMappingDocument(ze.getName());
 					try {
 						addInputStream( jarFile.getInputStream( ze ) );
 					}
 					catch (Exception e) {
 						throw new InvalidMappingException(
 								"Could not read mapping documents from jar: " + jar.getName(),
 								"jar",
 								jar.getName(),
 								e
 						);
 					}
 				}
 			}
 		}
 		finally {
 			try {
 				if ( jarFile != null ) {
 					jarFile.close();
 				}
 			}
 			catch (IOException ioe) {
                 LOG.unableToCloseJar(ioe.getMessage());
 			}
 		}
 
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		File[] files = dir.listFiles();
 		for ( File file : files ) {
 			if ( file.isDirectory() ) {
 				addDirectory( file );
 			}
 			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 				addFile( file );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Create a new <tt>Mappings</tt> to add class and collection mappings to.
 	 *
 	 * @return The created mappings
 	 */
 	public Mappings createMappings() {
 		return new MappingsImpl();
 	}
 
 
 	@SuppressWarnings({ "unchecked" })
 	private Iterator<IdentifierGenerator> iterateGenerators(Dialect dialect) throws MappingException {
 
 		TreeMap generators = new TreeMap();
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		for ( PersistentClass pc : classes.values() ) {
 			if ( !pc.isInherited() ) {
 				IdentifierGenerator ig = pc.getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						(RootClass) pc
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 				else if ( ig instanceof IdentifierGeneratorAggregator ) {
 					( (IdentifierGeneratorAggregator) ig ).registerPersistentGenerators( generators );
 				}
 			}
 		}
 
 		for ( Collection collection : collections.values() ) {
 			if ( collection.isIdentified() ) {
 				IdentifierGenerator ig = ( ( IdentifierCollection ) collection ).getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						null
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 			}
 		}
 
 		return generators.values().iterator();
 	}
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		// drop them in reverse order in case db needs it done that way...
 		{
 			ListIterator itr = auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 			while ( itr.hasPrevious() ) {
 				AuxiliaryDatabaseObject object = (AuxiliaryDatabaseObject) itr.previous();
 				if ( object.appliesToDialect( dialect ) ) {
 					script.add( object.sqlDropString( dialect, defaultCatalog, defaultSchema ) );
 				}
 			}
 		}
 
 		if ( dialect.dropConstraints() ) {
 			Iterator itr = getTableMappings();
 			while ( itr.hasNext() ) {
 				Table table = (Table) itr.next();
 				if ( table.isPhysicalTable() ) {
 					Iterator subItr = table.getForeignKeyIterator();
 					while ( subItr.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subItr.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlDropString(
 											dialect,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 			}
 		}
 
 
 		Iterator itr = getTableMappings();
 		while ( itr.hasNext() ) {
 
 			Table table = (Table) itr.next();
 			if ( table.isPhysicalTable() ) {
 
 				/*Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					if ( !index.isForeignKey() || !dialect.hasImplicitIndexForForeignKey() ) {
 						script.add( index.sqlDropString(dialect) );
 					}
 				}*/
 
 				script.add(
 						table.sqlDropString(
 								dialect,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 
 			}
 
 		}
 
 		itr = iterateGenerators( dialect );
 		while ( itr.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) itr.next() ).sqlDropStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				script.add(
 						table.sqlCreateString(
 								dialect,
 								mapping,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				if ( !dialect.supportsUniqueConstraintInCreateAlterTable() ) {
 					Iterator subIter = table.getUniqueKeyIterator();
 					while ( subIter.hasNext() ) {
 						UniqueKey uk = (UniqueKey) subIter.next();
 						String constraintString = uk.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema );
 						if (constraintString != null) script.add( constraintString );
 					}
 				}
 
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 
 				if ( dialect.hasAlterTable() ) {
 					subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlCreateString(
 											dialect, mapping,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) iter.next() ).sqlCreateStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		for ( AuxiliaryDatabaseObject auxiliaryDatabaseObject : auxiliaryDatabaseObjects ) {
 			if ( auxiliaryDatabaseObject.appliesToDialect( dialect ) ) {
 				script.add( auxiliaryDatabaseObject.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out what
 	 * should be created/altered
 	 *
 	 * @return The sequence of DDL commands to apply the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaUpdateScript(Dialect dialect, DatabaseMetadata databaseMetadata)
 			throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						( table.getSchema() == null ) ? defaultSchema : table.getSchema(),
 						( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog(),
 								table.isQuoted()
 
 					);
 				if ( tableInfo == null ) {
 					script.add(
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
index e3de7fba56..2de09fad2c 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
@@ -1,174 +1,173 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.beanvalidation;
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.validation.ConstraintViolation;
 import javax.validation.ConstraintViolationException;
 import javax.validation.TraversableResolver;
 import javax.validation.Validation;
 import javax.validation.Validator;
 import javax.validation.ValidatorFactory;
 import org.hibernate.EntityMode;
+import org.hibernate.event.spi.PreDeleteEvent;
+import org.hibernate.event.spi.PreInsertEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.Initializable;
-import org.hibernate.event.PreDeleteEvent;
-import org.hibernate.event.PreDeleteEventListener;
-import org.hibernate.event.PreInsertEvent;
-import org.hibernate.event.PreInsertEventListener;
-import org.hibernate.event.PreUpdateEvent;
-import org.hibernate.event.PreUpdateEventListener;
+import org.hibernate.event.spi.PreDeleteEventListener;
+import org.hibernate.event.spi.PreInsertEvent;
+import org.hibernate.event.spi.PreUpdateEvent;
+import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 import org.jboss.logging.Logger;
 
 /**
  * Event listener used to enable Bean Validation for insert/update/delete events.
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 //FIXME review exception model
-public class BeanValidationEventListener implements
-		PreInsertEventListener, PreUpdateEventListener, PreDeleteEventListener, Initializable {
+public class BeanValidationEventListener
+		implements PreInsertEventListener, PreUpdateEventListener, PreDeleteEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        BeanValidationEventListener.class.getName());
 
 	private ValidatorFactory factory;
 	private ConcurrentHashMap<EntityPersister, Set<String>> associationsPerEntityPersister =
 			new ConcurrentHashMap<EntityPersister, Set<String>>();
 	private GroupsPerOperation groupsPerOperation;
 	boolean initialized;
 
 	/**
 	 * No-arg constructor used when listener is configured via configuration file
 	 */
 	public BeanValidationEventListener() {
 	}
 
 	/**
 	 * Constructor used in an environment where validator factory is injected (JPA2).
 	 *
 	 * @param factory The {@code ValidatorFactory} to use to create {@code Validator} instance(s)
 	 * @param properties Configued properties
 	 */
 	public BeanValidationEventListener(ValidatorFactory factory, Properties properties) {
 		init( factory, properties );
 	}
 
 	public void initialize(Configuration cfg) {
 		if ( !initialized ) {
 			ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
 			Properties props = cfg.getProperties();
 			init( factory, props );
 		}
 	}
 
 	public boolean onPreInsert(PreInsertEvent event) {
 		validate(
 				event.getEntity(), event.getSession().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.INSERT
 		);
 		return false;
 	}
 
 	public boolean onPreUpdate(PreUpdateEvent event) {
 		validate(
 				event.getEntity(), event.getSession().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.UPDATE
 		);
 		return false;
 	}
 
 	public boolean onPreDelete(PreDeleteEvent event) {
 		validate(
 				event.getEntity(), event.getSession().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.DELETE
 		);
 		return false;
 	}
 
 	private void init(ValidatorFactory factory, Properties properties) {
 		this.factory = factory;
 		groupsPerOperation = new GroupsPerOperation( properties );
 		initialized = true;
 	}
 
 	private <T> void validate(T object, EntityMode mode, EntityPersister persister,
 							  SessionFactoryImplementor sessionFactory, GroupsPerOperation.Operation operation) {
 		if ( object == null || mode != EntityMode.POJO ) {
 			return;
 		}
 		TraversableResolver tr = new HibernateTraversableResolver(
 				persister, associationsPerEntityPersister, sessionFactory
 		);
 		Validator validator = factory.usingContext()
 				.traversableResolver( tr )
 				.getValidator();
 		final Class<?>[] groups = groupsPerOperation.get( operation );
 		if ( groups.length > 0 ) {
 			final Set<ConstraintViolation<T>> constraintViolations = validator.validate( object, groups );
 			if ( constraintViolations.size() > 0 ) {
 				Set<ConstraintViolation<?>> propagatedViolations =
 						new HashSet<ConstraintViolation<?>>( constraintViolations.size() );
 				Set<String> classNames = new HashSet<String>();
 				for ( ConstraintViolation<?> violation : constraintViolations ) {
                     LOG.trace(violation);
 					propagatedViolations.add( violation );
 					classNames.add( violation.getLeafBean().getClass().getName() );
 				}
 				StringBuilder builder = new StringBuilder();
 				builder.append( "Validation failed for classes " );
 				builder.append( classNames );
 				builder.append( " during " );
 				builder.append( operation.getName() );
 				builder.append( " time for groups " );
 				builder.append( toString( groups ) );
 				builder.append( "\nList of constraint violations:[\n" );
 				for (ConstraintViolation<?> violation : constraintViolations) {
 					builder.append( "\t" ).append( violation.toString() ).append("\n");
 				}
 				builder.append( "]" );
 
 				throw new ConstraintViolationException(
 						builder.toString(), propagatedViolations
 				);
 			}
 		}
 	}
 
 	private String toString(Class<?>[] groups) {
 		StringBuilder toString = new StringBuilder( "[" );
 		for ( Class<?> group : groups ) {
 			toString.append( group.getName() ).append( ", " );
 		}
 		toString.append( "]" );
 		return toString.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
index 94d42c322b..c7dfd561cf 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
@@ -1,296 +1,296 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class BeanValidationIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, BeanValidationIntegrator.class.getName());
 
 	public static final String APPLY_CONSTRAINTS = "hibernate.validator.apply_to_ddl";
 
 	public static final String BV_CHECK_CLASS = "javax.validation.Validation";
 
 	public static final String MODE_PROPERTY = "javax.persistence.validation.mode";
 
 	private static final String ACTIVATOR_CLASS = "org.hibernate.cfg.beanvalidation.TypeSafeActivator";
 	private static final String DDL_METHOD = "applyDDL";
 	private static final String ACTIVATE_METHOD = "activateBeanValidation";
 	private static final String VALIDATE_METHOD = "validateFactory";
 
 	public static void validateFactory(Object object) {
 		try {
 			final Class activatorClass = BeanValidationIntegrator.class.getClassLoader().loadClass( ACTIVATOR_CLASS );
 			try {
 				final Method validateMethod = activatorClass.getMethod( VALIDATE_METHOD, Object.class );
 				if ( ! validateMethod.isAccessible() ) {
 					validateMethod.setAccessible( true );
 				}
 				try {
 					validateMethod.invoke( null, object );
 				}
 				catch (InvocationTargetException e) {
 					if ( e.getTargetException() instanceof HibernateException ) {
 						throw (HibernateException) e.getTargetException();
 					}
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 				catch (IllegalAccessException e) {
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Could not locate method needed for ValidatorFactory validation", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not locate TypeSafeActivator class", e );
 		}
 	}
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// determine requested validation modes.
 		final Set<ValidationMode> modes = ValidationMode.getModes( configuration.getProperties().get( MODE_PROPERTY ) );
 
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		// try to locate a BV class to see if it is available on the classpath
 		boolean isBeanValidationAvailable;
 		try {
 			classLoaderService.classForName( BV_CHECK_CLASS );
 			isBeanValidationAvailable = true;
 		}
 		catch ( Exception e ) {
 			isBeanValidationAvailable = false;
 		}
 
 		// locate the type safe activator class
 		final Class typeSafeActivatorClass = loadTypeSafeActivatorClass( serviceRegistry );
 
 		// todo : if this works out, probably better to simply alter TypeSafeActivator into a single method...
 
 		applyRelationalConstraints(
 				modes,
 				isBeanValidationAvailable,
 				typeSafeActivatorClass,
 				configuration
 		);
 		applyHibernateListeners(
 				modes,
 				isBeanValidationAvailable,
 				typeSafeActivatorClass,
 				configuration,
 				sessionFactory,
 				serviceRegistry
 		);
 	}
 
 	private Class loadTypeSafeActivatorClass(SessionFactoryServiceRegistry serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( ACTIVATOR_CLASS );
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private void applyRelationalConstraints(
 			Set<ValidationMode> modes,
 			boolean beanValidationAvailable,
 			Class typeSafeActivatorClass,
 			Configuration configuration) {
 		if ( ! ConfigurationHelper.getBoolean( APPLY_CONSTRAINTS, configuration.getProperties(), true ) ){
 			LOG.debug( "Skipping application of relational constraints from legacy Hibernate Validator" );
 			return;
 		}
 
 		if ( ! ( modes.contains( ValidationMode.DDL ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		if ( ! beanValidationAvailable ) {
 			if ( modes.contains( ValidationMode.DDL ) ) {
 				throw new HibernateException( "Bean Validation not available in the class path but required in " + MODE_PROPERTY );
 			}
 			else if (modes.contains( ValidationMode.AUTO ) ) {
 				//nothing to activate
 				return;
 			}
 		}
 
 		try {
 			Method applyDDLMethod = typeSafeActivatorClass.getMethod( DDL_METHOD, Collection.class, Properties.class );
 			try {
 				applyDDLMethod.invoke(
 						null,
 						configuration.createMappings().getClasses().values(),
 						configuration.getProperties()
 				);
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Error applying BeanValidation relational constraints", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Unable to locate TypeSafeActivator#applyDDL method", e );
 		}
 	}
 
 	private void applyHibernateListeners(
 			Set<ValidationMode> modes,
 			boolean beanValidationAvailable,
 			Class typeSafeActivatorClass,
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// de-activate not-null tracking at the core level when Bean Validation is present unless the user explicitly
 		// asks for it
 		if ( configuration.getProperty( Environment.CHECK_NULLABILITY ) == null ) {
 			sessionFactory.getSettings().setCheckNullability( false );
 		}
 
 		if ( ! ( modes.contains( ValidationMode.CALLBACK ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		if ( ! beanValidationAvailable ) {
 			if ( modes.contains( ValidationMode.CALLBACK ) ) {
 				throw new HibernateException( "Bean Validation not available in the class path but required in " + MODE_PROPERTY );
 			}
 			else if (modes.contains( ValidationMode.AUTO ) ) {
 				//nothing to activate
 				return;
 			}
 		}
 
 		try {
-			Method activateMethod = typeSafeActivatorClass.getMethod( ACTIVATE_METHOD, EventListenerRegistry.class, Properties.class );
+			Method activateMethod = typeSafeActivatorClass.getMethod( ACTIVATE_METHOD, EventListenerRegistry.class, Configuration.class );
 			try {
 				activateMethod.invoke(
 						null,
 						serviceRegistry.getService( EventListenerRegistry.class ),
-						configuration.getProperties()
+						configuration
 				);
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Error applying BeanValidation relational constraints", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Unable to locate TypeSafeActivator#applyDDL method", e );
 		}
 	}
 
 
 	// Because the javax validation classes might not be on the runtime classpath
 	private static enum ValidationMode {
 		AUTO,
 		CALLBACK,
 		NONE,
 		DDL;
 
 		public static Set<ValidationMode> getModes(Object modeProperty) {
 			Set<ValidationMode> modes = new HashSet<ValidationMode>(3);
 			if (modeProperty == null) {
 				modes.add(ValidationMode.AUTO);
 			}
 			else {
 				final String[] modesInString = modeProperty.toString().split( "," );
 				for ( String modeInString : modesInString ) {
 					modes.add( getMode(modeInString) );
 				}
 			}
 			if ( modes.size() > 1 && ( modes.contains( ValidationMode.AUTO ) || modes.contains( ValidationMode.NONE ) ) ) {
 				StringBuilder message = new StringBuilder( "Incompatible validation modes mixed: " );
 				for (ValidationMode mode : modes) {
 					message.append( mode ).append( ", " );
 				}
 				throw new HibernateException( message.substring( 0, message.length() - 2 ) );
 			}
 			return modes;
 		}
 
 		private static ValidationMode getMode(String modeProperty) {
 			if (modeProperty == null || modeProperty.length() == 0) {
 				return AUTO;
 			}
 			else {
 				try {
 					return valueOf( modeProperty.trim().toUpperCase() );
 				}
 				catch ( IllegalArgumentException e ) {
 					throw new HibernateException( "Unknown validation mode in " + MODE_PROPERTY + ": " + modeProperty );
 				}
 			}
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do here afaik
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
index 2dd6ce5c75..f53c78f962 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
@@ -1,377 +1,381 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.beanvalidation;
 
 import javax.validation.Validation;
 import javax.validation.ValidatorFactory;
 import javax.validation.constraints.Digits;
 import javax.validation.constraints.Max;
 import javax.validation.constraints.Min;
 import javax.validation.constraints.NotNull;
 import javax.validation.constraints.Size;
 import javax.validation.metadata.BeanDescriptor;
 import javax.validation.metadata.ConstraintDescriptor;
 import javax.validation.metadata.PropertyDescriptor;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
+import org.hibernate.cfg.Configuration;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 class TypeSafeActivator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, TypeSafeActivator.class.getName());
 
 	private static final String FACTORY_PROPERTY = "javax.persistence.validation.factory";
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static void validateFactory(Object object) {
 		if ( ! ValidatorFactory.class.isInstance( object ) ) {
 			throw new HibernateException(
 					"Given object was not an instance of " + ValidatorFactory.class.getName()
 							+ "[" + object.getClass().getName() + "]"
 			);
 		}
 	}
 
 	@SuppressWarnings( {"UnusedDeclaration"})
-	public static void activateBeanValidation(EventListenerRegistry listenerRegistry, Properties properties) {
+	public static void activateBeanValidation(EventListenerRegistry listenerRegistry, Configuration configuration) {
+		final Properties properties = configuration.getProperties();
 		ValidatorFactory factory = getValidatorFactory( properties );
 		BeanValidationEventListener listener = new BeanValidationEventListener(
 				factory, properties
 		);
 
 		listenerRegistry.addDuplicationStrategy( DuplicationStrategyImpl.INSTANCE );
 
 		listenerRegistry.appendListeners( EventType.PRE_INSERT, listener );
 		listenerRegistry.appendListeners( EventType.PRE_UPDATE, listener );
 		listenerRegistry.appendListeners( EventType.PRE_DELETE, listener );
+
+		listener.initialize( configuration );
 	}
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static void applyDDL(Collection<PersistentClass> persistentClasses, Properties properties) {
 		ValidatorFactory factory = getValidatorFactory( properties );
 		Class<?>[] groupsArray = new GroupsPerOperation( properties ).get( GroupsPerOperation.Operation.DDL );
 		Set<Class<?>> groups = new HashSet<Class<?>>( Arrays.asList( groupsArray ) );
 
 		for ( PersistentClass persistentClass : persistentClasses ) {
 			final String className = persistentClass.getClassName();
 
 			if ( className == null || className.length() == 0 ) {
 				continue;
 			}
 			Class<?> clazz;
 			try {
 				clazz = ReflectHelper.classForName( className, TypeSafeActivator.class );
 			}
 			catch ( ClassNotFoundException e ) {
 				throw new AssertionFailure( "Entity class not found", e );
 			}
 
 			try {
 				applyDDL( "", persistentClass, clazz, factory, groups, true );
 			}
 			catch (Exception e) {
                 LOG.unableToApplyConstraints(className, e);
 			}
 		}
 	}
 
 	private static void applyDDL(String prefix,
 								 PersistentClass persistentClass,
 								 Class<?> clazz,
 								 ValidatorFactory factory,
 								 Set<Class<?>> groups,
 								 boolean activateNotNull) {
 		final BeanDescriptor descriptor = factory.getValidator().getConstraintsForClass( clazz );
 		//no bean level constraints can be applied, go to the properties
 
 		for ( PropertyDescriptor propertyDesc : descriptor.getConstrainedProperties() ) {
 			Property property = findPropertyByName( persistentClass, prefix + propertyDesc.getPropertyName() );
 			boolean hasNotNull;
 			if ( property != null ) {
 				hasNotNull = applyConstraints(
 						propertyDesc.getConstraintDescriptors(), property, propertyDesc, groups, activateNotNull
 				);
 				if ( property.isComposite() && propertyDesc.isCascaded() ) {
 					Class<?> componentClass = ( (Component) property.getValue() ).getComponentClass();
 
 					/*
 					 * we can apply not null if the upper component let's us activate not null
 					 * and if the property is not null.
 					 * Otherwise, all sub columns should be left nullable
 					 */
 					final boolean canSetNotNullOnColumns = activateNotNull && hasNotNull;
 					applyDDL(
 							prefix + propertyDesc.getPropertyName() + ".",
 							persistentClass, componentClass, factory, groups,
 							canSetNotNullOnColumns
 					);
 				}
 				//FIXME add collection of components
 			}
 		}
 	}
 
 	private static boolean applyConstraints(Set<ConstraintDescriptor<?>> constraintDescriptors,
 											Property property,
 											PropertyDescriptor propertyDesc,
 											Set<Class<?>> groups,
 											boolean canApplyNotNull
 	) {
 		boolean hasNotNull = false;
 		for ( ConstraintDescriptor<?> descriptor : constraintDescriptors ) {
 			if ( groups != null && Collections.disjoint( descriptor.getGroups(), groups ) ) {
 				continue;
 			}
 
 			if ( canApplyNotNull ) {
 				hasNotNull = hasNotNull || applyNotNull( property, descriptor );
 			}
 
 			// apply bean validation specific constraints
 			applyDigits( property, descriptor );
 			applySize( property, descriptor, propertyDesc );
 			applyMin( property, descriptor );
 			applyMax( property, descriptor );
 
 			// apply hibernate validator specific constraints - we cannot import any HV specific classes though!
 			// no need to check explicitly for @Range. @Range is a composed constraint using @Min and @Max which
 			// will be taken care later
 			applyLength( property, descriptor, propertyDesc );
 
 			// pass an empty set as composing constraints inherit the main constraint and thus are matching already
 			hasNotNull = hasNotNull || applyConstraints(
 					descriptor.getComposingConstraints(),
 					property, propertyDesc, null,
 					canApplyNotNull
 			);
 		}
 		return hasNotNull;
 	}
 
 	private static void applyMin(Property property, ConstraintDescriptor<?> descriptor) {
 		if ( Min.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Min> minConstraint = (ConstraintDescriptor<Min>) descriptor;
 			long min = minConstraint.getAnnotation().value();
 
 			Column col = (Column) property.getColumnIterator().next();
 			String checkConstraint = col.getName() + ">=" + min;
 			applySQLCheck( col, checkConstraint );
 		}
 	}
 
 	private static void applyMax(Property property, ConstraintDescriptor<?> descriptor) {
 		if ( Max.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Max> maxConstraint = (ConstraintDescriptor<Max>) descriptor;
 			long max = maxConstraint.getAnnotation().value();
 			Column col = (Column) property.getColumnIterator().next();
 			String checkConstraint = col.getName() + "<=" + max;
 			applySQLCheck( col, checkConstraint );
 		}
 	}
 
 	private static void applySQLCheck(Column col, String checkConstraint) {
 		String existingCheck = col.getCheckConstraint();
 		// need to check whether the new check is already part of the existing check, because applyDDL can be called
 		// multiple times
 		if ( StringHelper.isNotEmpty( existingCheck ) && !existingCheck.contains( checkConstraint ) ) {
 			checkConstraint = col.getCheckConstraint() + " AND " + checkConstraint;
 		}
 		col.setCheckConstraint( checkConstraint );
 	}
 
 	private static boolean applyNotNull(Property property, ConstraintDescriptor<?> descriptor) {
 		boolean hasNotNull = false;
 		if ( NotNull.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			if ( !( property.getPersistentClass() instanceof SingleTableSubclass ) ) {
 				//single table should not be forced to null
 				if ( !property.isComposite() ) { //composite should not add not-null on all columns
 					@SuppressWarnings( "unchecked" )
 					Iterator<Column> iter = property.getColumnIterator();
 					while ( iter.hasNext() ) {
 						iter.next().setNullable( false );
 						hasNotNull = true;
 					}
 				}
 			}
 			hasNotNull = true;
 		}
 		return hasNotNull;
 	}
 
 	private static void applyDigits(Property property, ConstraintDescriptor<?> descriptor) {
 		if ( Digits.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Digits> digitsConstraint = (ConstraintDescriptor<Digits>) descriptor;
 			int integerDigits = digitsConstraint.getAnnotation().integer();
 			int fractionalDigits = digitsConstraint.getAnnotation().fraction();
 			Column col = (Column) property.getColumnIterator().next();
 			col.setPrecision( integerDigits + fractionalDigits );
 			col.setScale( fractionalDigits );
 		}
 	}
 
 	private static void applySize(Property property, ConstraintDescriptor<?> descriptor, PropertyDescriptor propertyDescriptor) {
 		if ( Size.class.equals( descriptor.getAnnotation().annotationType() )
 				&& String.class.equals( propertyDescriptor.getElementClass() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Size> sizeConstraint = (ConstraintDescriptor<Size>) descriptor;
 			int max = sizeConstraint.getAnnotation().max();
 			Column col = (Column) property.getColumnIterator().next();
 			if ( max < Integer.MAX_VALUE ) {
 				col.setLength( max );
 			}
 		}
 	}
 
 	private static void applyLength(Property property, ConstraintDescriptor<?> descriptor, PropertyDescriptor propertyDescriptor) {
 		if ( "org.hibernate.validator.constraints.Length".equals(
 				descriptor.getAnnotation().annotationType().getName()
 		)
 				&& String.class.equals( propertyDescriptor.getElementClass() ) ) {
 			@SuppressWarnings("unchecked")
 			int max = (Integer) descriptor.getAttributes().get( "max" );
 			Column col = (Column) property.getColumnIterator().next();
 			if ( max < Integer.MAX_VALUE ) {
 				col.setLength( max );
 			}
 		}
 	}
 
 	/**
 	 * Retrieve the property by path in a recursive way, including IndentifierProperty in the loop
 	 * If propertyName is null or empty, the IdentifierProperty is returned
 	 */
 	private static Property findPropertyByName(PersistentClass associatedClass, String propertyName) {
 		Property property = null;
 		Property idProperty = associatedClass.getIdentifierProperty();
 		String idName = idProperty != null ? idProperty.getName() : null;
 		try {
 			if ( propertyName == null
 					|| propertyName.length() == 0
 					|| propertyName.equals( idName ) ) {
 				//default to id
 				property = idProperty;
 			}
 			else {
 				if ( propertyName.indexOf( idName + "." ) == 0 ) {
 					property = idProperty;
 					propertyName = propertyName.substring( idName.length() + 1 );
 				}
 				StringTokenizer st = new StringTokenizer( propertyName, ".", false );
 				while ( st.hasMoreElements() ) {
 					String element = (String) st.nextElement();
 					if ( property == null ) {
 						property = associatedClass.getProperty( element );
 					}
 					else {
 						if ( !property.isComposite() ) {
 							return null;
 						}
 						property = ( (Component) property.getValue() ).getProperty( element );
 					}
 				}
 			}
 		}
 		catch ( MappingException e ) {
 			try {
 				//if we do not find it try to check the identifier mapper
 				if ( associatedClass.getIdentifierMapper() == null ) {
 					return null;
 				}
 				StringTokenizer st = new StringTokenizer( propertyName, ".", false );
 				while ( st.hasMoreElements() ) {
 					String element = (String) st.nextElement();
 					if ( property == null ) {
 						property = associatedClass.getIdentifierMapper().getProperty( element );
 					}
 					else {
 						if ( !property.isComposite() ) {
 							return null;
 						}
 						property = ( (Component) property.getValue() ).getProperty( element );
 					}
 				}
 			}
 			catch ( MappingException ee ) {
 				return null;
 			}
 		}
 		return property;
 	}
 
 	private static ValidatorFactory getValidatorFactory(Map<Object, Object> properties) {
 		ValidatorFactory factory = null;
 		if ( properties != null ) {
 			Object unsafeProperty = properties.get( FACTORY_PROPERTY );
 			if ( unsafeProperty != null ) {
 				try {
 					factory = ValidatorFactory.class.cast( unsafeProperty );
 				}
 				catch ( ClassCastException e ) {
 					throw new HibernateException(
 							"Property " + FACTORY_PROPERTY
 									+ " should contain an object of type " + ValidatorFactory.class.getName()
 					);
 				}
 			}
 		}
 		if ( factory == null ) {
 			try {
 				factory = Validation.buildDefaultValidatorFactory();
 			}
 			catch ( Exception e ) {
 				throw new HibernateException( "Unable to build the default ValidatorFactory", e );
 			}
 		}
 		return factory;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/search/HibernateSearchIntegrator.java b/hibernate-core/src/main/java/org/hibernate/cfg/search/HibernateSearchIntegrator.java
index 83e54175d8..6dc960f046 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/search/HibernateSearchIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/search/HibernateSearchIntegrator.java
@@ -1,134 +1,134 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.search;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostCollectionRemoveEventListener;
+import org.hibernate.event.spi.PostCollectionUpdateEventListener;
+import org.hibernate.event.spi.PostDeleteEventListener;
+import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostCollectionRecreateEventListener;
-import org.hibernate.event.PostCollectionRemoveEventListener;
-import org.hibernate.event.PostCollectionUpdateEventListener;
-import org.hibernate.event.PostDeleteEventListener;
-import org.hibernate.event.PostInsertEventListener;
-import org.hibernate.event.PostUpdateEventListener;
+import org.hibernate.event.spi.PostCollectionRecreateEventListener;
+import org.hibernate.event.spi.PostUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Integrates Hibernate Search into Hibernate Core by registering its needed listeners
  * <p/>
  * The note on the original (now removed) org.hibernate.cfg.search.HibernateSearchEventListenerRegister class indicated
  * that Search now uses a new means for this.  However that signature is relying on removed classes...
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  * @author Steve Ebersole
  */
 public class HibernateSearchIntegrator implements Integrator {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HibernateSearchIntegrator.class.getName() );
 
 	public static final String AUTO_REGISTER = "hibernate.search.autoregister_listeners";
 	public static final String LISTENER_CLASS = "org.hibernate.search.event.FullTextIndexEventListener";
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		final boolean registerListeners = ConfigurationHelper.getBoolean( AUTO_REGISTER, configuration.getProperties(), false );
 		if ( !registerListeners ) {
 			LOG.debug( "Skipping search event listener auto registration" );
 			return;
 		}
 
 		final Class listenerClass = loadSearchEventListener( serviceRegistry );
 		if ( listenerClass == null ) {
 			LOG.debug( "Skipping search event listener auto registration - could not fid listener class" );
 			return;
 		}
 
 		final Object listener = instantiateListener( listenerClass );
 
 		EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 
 		listenerRegistry.addDuplicationStrategy( new DuplicationStrategyImpl( listenerClass ) );
 
 		listenerRegistry.getEventListenerGroup( EventType.POST_INSERT ).appendListener( (PostInsertEventListener) listener );
 		listenerRegistry.getEventListenerGroup( EventType.POST_UPDATE ).appendListener( (PostUpdateEventListener) listener );
 		listenerRegistry.getEventListenerGroup( EventType.POST_DELETE ).appendListener( (PostDeleteEventListener) listener );
 		listenerRegistry.getEventListenerGroup( EventType.POST_COLLECTION_RECREATE ).appendListener( (PostCollectionRecreateEventListener) listener );
 		listenerRegistry.getEventListenerGroup( EventType.POST_COLLECTION_REMOVE ).appendListener( (PostCollectionRemoveEventListener) listener );
 		listenerRegistry.getEventListenerGroup( EventType.POST_COLLECTION_UPDATE ).appendListener( (PostCollectionUpdateEventListener) listener );
 	}
 
 	private Class loadSearchEventListener(SessionFactoryServiceRegistry serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( LISTENER_CLASS );
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private Object instantiateListener(Class listenerClass) {
 		try {
 			return listenerClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new AnnotationException( "Unable to instantiate Search event listener", e );
 		}
 	}
 
 	public static class DuplicationStrategyImpl implements DuplicationStrategy {
 		private final Class checkClass;
 
 		public DuplicationStrategyImpl(Class checkClass) {
 			this.checkClass = checkClass;
 		}
 
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			// not isAssignableFrom since the user could subclass
 			return checkClass == original.getClass() && checkClass == listener.getClass();
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do here afaik
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/internal/ThreadLocalSessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/internal/ThreadLocalSessionContext.java
index 182463721e..006979a8c3 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/internal/ThreadLocalSessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/internal/ThreadLocalSessionContext.java
@@ -1,387 +1,387 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.context.internal;
 
 import javax.transaction.Synchronization;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.transaction.spi.TransactionContext;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 
 /**
  * A {@link CurrentSessionContext} impl which scopes the notion of current
  * session by the current thread of execution.  Unlike the JTA counterpart,
  * threads do not give us a nice hook to perform any type of cleanup making
  * it questionable for this impl to actually generate Session instances.  In
  * the interest of usability, it was decided to have this default impl
  * actually generate a session upon first request and then clean it up
  * after the {@link org.hibernate.Transaction} associated with that session
  * is committed/rolled-back.  In order for ensuring that happens, the sessions
  * generated here are unusable until after {@link Session#beginTransaction()}
  * has been called. If <tt>close()</tt> is called on a session managed by
  * this class, it will be automatically unbound.
  * <p/>
  * Additionally, the static {@link #bind} and {@link #unbind} methods are
  * provided to allow application code to explicitly control opening and
  * closing of these sessions.  This, with some from of interception,
  * is the preferred approach.  It also allows easy framework integration
  * and one possible approach for implementing long-sessions.
  * <p/>
  * The {@link #buildOrObtainSession}, {@link #isAutoCloseEnabled},
  * {@link #isAutoFlushEnabled}, {@link #getConnectionReleaseMode}, and
  * {@link #buildCleanupSynch} methods are all provided to allow easy
  * subclassing (for long-running session scenarios, for example).
  *
  * @author Steve Ebersole
  */
 public class ThreadLocalSessionContext implements CurrentSessionContext {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        ThreadLocalSessionContext.class.getName());
 	private static final Class[] SESSION_PROXY_INTERFACES = new Class[] {
 			Session.class,
 	        SessionImplementor.class,
 	        EventSource.class,
 			TransactionContext.class,
 			LobCreationContext.class
 	};
 
 	/**
 	 * A ThreadLocal maintaining current sessions for the given execution thread.
 	 * The actual ThreadLocal variable is a java.util.Map to account for
 	 * the possibility for multiple SessionFactorys being used during execution
 	 * of the given thread.
 	 */
 	private static final ThreadLocal<Map> context = new ThreadLocal<Map>();
 
 	protected final SessionFactoryImplementor factory;
 
 	public ThreadLocalSessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public final Session currentSession() throws HibernateException {
 		Session current = existingSession( factory );
 		if (current == null) {
 			current = buildOrObtainSession();
 			// register a cleanup sync
 			current.getTransaction().registerSynchronization( buildCleanupSynch() );
 			// wrap the session in the transaction-protection proxy
 			if ( needsWrapping( current ) ) {
 				current = wrap( current );
 			}
 			// then bind it
 			doBind( current, factory );
 		}
 		return current;
 	}
 
 	private boolean needsWrapping(Session session) {
 		// try to make sure we don't wrap and already wrapped session
 		return session != null
 		       && ! Proxy.isProxyClass( session.getClass() )
 		       || ( Proxy.getInvocationHandler( session ) != null
 		       && ! ( Proxy.getInvocationHandler( session ) instanceof TransactionProtectionWrapper ) );
 	}
 
 	/**
 	 * Getter for property 'factory'.
 	 *
 	 * @return Value for property 'factory'.
 	 */
 	protected SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return factory.withOptions()
 				.autoClose( isAutoCloseEnabled() )
 				.connectionReleaseMode( getConnectionReleaseMode() )
 				.flushBeforeCompletion( isAutoFlushEnabled() )
 				.openSession();
 	}
 
 	protected CleanupSynch buildCleanupSynch() {
 		return new CleanupSynch( factory );
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_transaction.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return factory.getSettings().getConnectionReleaseMode();
 	}
 
 	protected Session wrap(Session session) {
 		TransactionProtectionWrapper wrapper = new TransactionProtectionWrapper( session );
 		Session wrapped = ( Session ) Proxy.newProxyInstance(
 				Session.class.getClassLoader(),
 				SESSION_PROXY_INTERFACES,
 		        wrapper
 			);
 		// yick!  need this for proper serialization/deserialization handling...
 		wrapper.setWrapped( wrapped );
 		return wrapped;
 	}
 
 	/**
 	 * Associates the given session with the current thread of execution.
 	 *
 	 * @param session The session to bind.
 	 */
 	public static void bind(org.hibernate.Session session) {
 		SessionFactory factory = session.getSessionFactory();
 		cleanupAnyOrphanedSession( factory );
 		doBind( session, factory );
 	}
 
 	private static void cleanupAnyOrphanedSession(SessionFactory factory) {
 		Session orphan = doUnbind( factory, false );
 		if ( orphan != null ) {
             LOG.alreadySessionBound();
 			try {
 				if ( orphan.getTransaction() != null && orphan.getTransaction().isActive() ) {
 					try {
 						orphan.getTransaction().rollback();
 					}
 					catch( Throwable t ) {
                         LOG.debug("Unable to rollback transaction for orphaned session", t);
 					}
 				}
 				orphan.close();
 			}
 			catch( Throwable t ) {
                 LOG.debug("Unable to close orphaned session", t);
 			}
 		}
 	}
 
 	/**
 	 * Disassociates a previously bound session from the current thread of execution.
 	 *
 	 * @param factory The factory for which the session should be unbound.
 	 * @return The session which was unbound.
 	 */
 	public static Session unbind(SessionFactory factory) {
 		return doUnbind( factory, true );
 	}
 
 	private static Session existingSession(SessionFactory factory) {
 		Map sessionMap = sessionMap();
         if (sessionMap == null) return null;
         return (Session)sessionMap.get(factory);
 	}
 
 	protected static Map sessionMap() {
 		return context.get();
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private static void doBind(org.hibernate.Session session, SessionFactory factory) {
 		Map sessionMap = sessionMap();
 		if ( sessionMap == null ) {
 			sessionMap = new HashMap();
 			context.set( sessionMap );
 		}
 		sessionMap.put( factory, session );
 	}
 
 	private static Session doUnbind(SessionFactory factory, boolean releaseMapIfEmpty) {
 		Map sessionMap = sessionMap();
 		Session session = null;
 		if ( sessionMap != null ) {
 			session = ( Session ) sessionMap.remove( factory );
 			if ( releaseMapIfEmpty && sessionMap.isEmpty() ) {
 				context.set( null );
 			}
 		}
 		return session;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization, Serializable {
 		protected final SessionFactory factory;
 
 		public CleanupSynch(SessionFactory factory) {
 			this.factory = factory;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			unbind( factory );
 		}
 	}
 
 	private class TransactionProtectionWrapper implements InvocationHandler, Serializable {
 		private final Session realSession;
 		private Session wrappedSession;
 
 		public TransactionProtectionWrapper(Session realSession) {
 			this.realSession = realSession;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			try {
 				// If close() is called, guarantee unbind()
 				if ( "close".equals( method.getName()) ) {
 					unbind( realSession.getSessionFactory() );
 				}
 				else if ( "toString".equals( method.getName() )
 					     || "equals".equals( method.getName() )
 					     || "hashCode".equals( method.getName() )
 				         || "getStatistics".equals( method.getName() )
 					     || "isOpen".equals( method.getName() )
 						 || "getListeners".equals( method.getName() ) //useful for HSearch in particular
 						) {
 					// allow these to go through the the real session no matter what
 				}
 				else if ( !realSession.isOpen() ) {
 					// essentially, if the real session is closed allow any
 					// method call to pass through since the real session
 					// will complain by throwing an appropriate exception;
 					// NOTE that allowing close() above has the same basic effect,
 					//   but we capture that there simply to doAfterTransactionCompletion the unbind...
 				}
 				else if ( !realSession.getTransaction().isActive() ) {
 					// limit the methods available if no transaction is active
 					if ( "beginTransaction".equals( method.getName() )
 					     || "getTransaction".equals( method.getName() )
 					     || "isTransactionInProgress".equals( method.getName() )
 					     || "setFlushMode".equals( method.getName() )
 					     || "getSessionFactory".equals( method.getName() ) ) {
                         LOG.trace("Allowing method [" + method.getName() + "] in non-transacted context");
 					}
 					else if ( "reconnect".equals( method.getName() )
 					          || "disconnect".equals( method.getName() ) ) {
 						// allow these (deprecated) methods to pass through
 					}
 					else {
 						throw new HibernateException( method.getName() + " is not valid without active transaction" );
 					}
 				}
                 LOG.trace("Allowing proxied method [" + method.getName() + "] to proceed to real session");
 				return method.invoke( realSession, args );
 			}
 			catch ( InvocationTargetException e ) {
                 if (e.getTargetException() instanceof RuntimeException) throw (RuntimeException)e.getTargetException();
                 throw e;
 			}
 		}
 
 		/**
 		 * Setter for property 'wrapped'.
 		 *
 		 * @param wrapped Value to set for property 'wrapped'.
 		 */
 		public void setWrapped(Session wrapped) {
 			this.wrappedSession = wrapped;
 		}
 
 
 		// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		private void writeObject(ObjectOutputStream oos) throws IOException {
 			// if a ThreadLocalSessionContext-bound session happens to get
 			// serialized, to be completely correct, we need to make sure
 			// that unbinding of that session occurs.
 			oos.defaultWriteObject();
 			if ( existingSession( factory ) == wrappedSession ) {
 				unbind( factory );
 			}
 		}
 
 		private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 			// on the inverse, it makes sense that if a ThreadLocalSessionContext-
 			// bound session then gets deserialized to go ahead and re-bind it to
 			// the ThreadLocalSessionContext session map.
 			ois.defaultReadObject();
 			realSession.getTransaction().registerSynchronization( buildCleanupSynch() );
 			doBind( wrappedSession, factory );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticForceIncrementLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticForceIncrementLockingStrategy.java
index 4afc6e30ff..f3310c4cea 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticForceIncrementLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticForceIncrementLockingStrategy.java
@@ -1,84 +1,84 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 import java.io.Serializable;
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.LockMode;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.action.internal.EntityIncrementVersionProcess;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.Lockable;
 
 /**
  * An optimistic locking strategy that forces an increment of the version (after verifying that version hasn't changed).
  * This takes place just prior to transaction commit.
  * <p/>
  * This strategy is valid for LockMode.OPTIMISTIC_FORCE_INCREMENT
  *
  * @author Scott Marlow
  * @since 3.5
  */
 public class OptimisticForceIncrementLockingStrategy implements LockingStrategy {
 	private final Lockable lockable;
 	private final LockMode lockMode;
 
 	/**
 	 * Construct locking strategy.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indicates the type of lock to be acquired.
 	 */
 	public OptimisticForceIncrementLockingStrategy(Lockable lockable, LockMode lockMode) {
 		this.lockable = lockable;
 		this.lockMode = lockMode;
 		if ( lockMode.lessThan( LockMode.OPTIMISTIC_FORCE_INCREMENT ) ) {
 			throw new HibernateException( "[" + lockMode + "] not valid for [" + lockable.getEntityName() + "]" );
 		}
 	}
 
 	/**
 	 * @see LockingStrategy#lock
 	 */
 	public void lock(
 			Serializable id,
 			Object version,
 			Object object,
 			int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		if ( !lockable.isVersioned() ) {
 			throw new HibernateException( "[" + lockMode + "] not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 		}
 		EntityEntry entry = session.getPersistenceContext().getEntry( object );
 		EntityIncrementVersionProcess incrementVersion = new EntityIncrementVersionProcess( object, entry );
 		EventSource source = (EventSource) session;
 		// Register the EntityIncrementVersionProcess action to run just prior to transaction commit. 
 		source.getActionQueue().registerProcess( incrementVersion );
 	}
 
 	protected LockMode getLockMode() {
 		return lockMode;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticLockingStrategy.java b/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticLockingStrategy.java
index a6700a8783..59d44b2b13 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticLockingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/lock/OptimisticLockingStrategy.java
@@ -1,86 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.lock;
 import java.io.Serializable;
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.LockMode;
 import org.hibernate.OptimisticLockException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.action.internal.EntityVerifyVersionProcess;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.Lockable;
 
 /**
  * An optimistic locking strategy that verifies that the version hasn't changed (prior to transaction commit).
  * <p/>
  * This strategy is valid for LockMode.OPTIMISTIC
  *
  * @since 3.5
  *
  * @author Scott Marlow
  */
 public class OptimisticLockingStrategy implements LockingStrategy {
 
 	private final Lockable lockable;
 	private final LockMode lockMode;
 
 	/**
 	 * Construct locking strategy.
 	 *
 	 * @param lockable The metadata for the entity to be locked.
 	 * @param lockMode Indictates the type of lock to be acquired.
 	 */
 	public OptimisticLockingStrategy(Lockable lockable, LockMode lockMode) {
 		this.lockable = lockable;
 		this.lockMode = lockMode;
 		if ( lockMode.lessThan( LockMode.OPTIMISTIC ) ) {
 			throw new HibernateException( "[" + lockMode + "] not valid for [" + lockable.getEntityName() + "]" );
 		}
 	}
 
    /**
 	 * @see org.hibernate.dialect.lock.LockingStrategy#lock
 	 */
 	public void lock(
       Serializable id,
       Object version,
       Object object,
       int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
 		if ( !lockable.isVersioned() ) {
 			throw new OptimisticLockException( "[" + lockMode + "] not supported for non-versioned entities [" + lockable.getEntityName() + "]" );
 		}
 		EntityEntry entry = session.getPersistenceContext().getEntry(object);
 		EventSource source = (EventSource)session;
 		EntityVerifyVersionProcess verifyVersion = new EntityVerifyVersionProcess(object, entry);
 		// Register the EntityVerifyVersionProcess action to run just prior to transaction commit.
 		source.getActionQueue().registerProcess(verifyVersion);
 	}
 
 	protected LockMode getLockMode() {
 		return lockMode;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/internal/Cascade.java b/hibernate-core/src/main/java/org/hibernate/engine/internal/Cascade.java
index e860b66e88..c8432008ee 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/internal/Cascade.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/internal/Cascade.java
@@ -1,482 +1,482 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.internal;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Stack;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * Delegate responsible for, in conjunction with the various
  * {@link org.hibernate.engine.spi.CascadingAction actions}, implementing cascade processing.
  *
  * @author Gavin King
  * @see org.hibernate.engine.spi.CascadingAction
  */
 public final class Cascade {
 
 	/**
 	 * A cascade point that occurs just after the insertion of the parent entity and
 	 * just before deletion
 	 */
 	public static final int AFTER_INSERT_BEFORE_DELETE = 1;
 	/**
 	 * A cascade point that occurs just before the insertion of the parent entity and
 	 * just after deletion
 	 */
 	public static final int BEFORE_INSERT_AFTER_DELETE = 2;
 	/**
 	 * A cascade point that occurs just after the insertion of the parent entity and
 	 * just before deletion, inside a collection
 	 */
 	public static final int AFTER_INSERT_BEFORE_DELETE_VIA_COLLECTION = 3;
 	/**
 	 * A cascade point that occurs just after update of the parent entity
 	 */
 	public static final int AFTER_UPDATE = 0;
 	/**
 	 * A cascade point that occurs just before the session is flushed
 	 */
 	public static final int BEFORE_FLUSH = 0;
 	/**
 	 * A cascade point that occurs just after eviction of the parent entity from the
 	 * session cache
 	 */
 	public static final int AFTER_EVICT = 0;
 	/**
 	 * A cascade point that occurs just after locking a transient parent entity into the
 	 * session cache
 	 */
 	public static final int BEFORE_REFRESH = 0;
 	/**
 	 * A cascade point that occurs just after refreshing a parent entity
 	 */
 	public static final int AFTER_LOCK = 0;
 	/**
 	 * A cascade point that occurs just before merging from a transient parent entity into
 	 * the object in the session cache
 	 */
 	public static final int BEFORE_MERGE = 0;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Cascade.class.getName());
 
 
 	private int cascadeTo;
 	private EventSource eventSource;
 	private CascadingAction action;
 
 	public Cascade(final CascadingAction action, final int cascadeTo, final EventSource eventSource) {
 		this.cascadeTo = cascadeTo;
 		this.eventSource = eventSource;
 		this.action = action;
 	}
 
 	private SessionFactoryImplementor getFactory() {
 		return eventSource.getFactory();
 	}
 
 	/**
 	 * Cascade an action from the parent entity instance to all its children.
 	 *
 	 * @param persister The parent's entity persister
 	 * @param parent The parent reference.
 	 * @throws HibernateException
 	 */
 	public void cascade(final EntityPersister persister, final Object parent)
 	throws HibernateException {
 		cascade( persister, parent, null );
 	}
 
 	/**
 	 * Cascade an action from the parent entity instance to all its children.  This
 	 * form is typicaly called from within cascade actions.
 	 *
 	 * @param persister The parent's entity persister
 	 * @param parent The parent reference.
 	 * @param anything Anything ;)   Typically some form of cascade-local cache
 	 * which is specific to each CascadingAction type
 	 * @throws HibernateException
 	 */
 	public void cascade(final EntityPersister persister, final Object parent, final Object anything)
 			throws HibernateException {
 
 		if ( persister.hasCascades() || action.requiresNoCascadeChecking() ) { // performance opt
             LOG.trace("Processing cascade " + action + " for: " + persister.getEntityName());
 
 			Type[] types = persister.getPropertyTypes();
 			CascadeStyle[] cascadeStyles = persister.getPropertyCascadeStyles();
 			EntityMode entityMode = eventSource.getEntityMode();
 			boolean hasUninitializedLazyProperties = persister.hasUninitializedLazyProperties( parent, entityMode );
 			for ( int i=0; i<types.length; i++) {
 				final CascadeStyle style = cascadeStyles[i];
 				final String propertyName = persister.getPropertyNames()[i];
 				if ( hasUninitializedLazyProperties && persister.getPropertyLaziness()[i] && ! action.performOnLazyProperty() ) {
 					//do nothing to avoid a lazy property initialization
 					continue;
 				}
 
 				if ( style.doCascade( action ) ) {
 					cascadeProperty(
 						    parent,
 					        persister.getPropertyValue( parent, i, entityMode ),
 					        types[i],
 					        style,
 							propertyName,
 					        anything,
 					        false
 					);
 				}
 				else if ( action.requiresNoCascadeChecking() ) {
 					action.noCascade(
 							eventSource,
 							persister.getPropertyValue( parent, i, entityMode ),
 							parent,
 							persister,
 							i
 					);
 				}
 			}
 
             LOG.trace("Done processing cascade " + action + " for: " + persister.getEntityName());
 		}
 	}
 
 	/**
 	 * Cascade an action to the child or children
 	 */
 	private void cascadeProperty(
 			final Object parent,
 			final Object child,
 			final Type type,
 			final CascadeStyle style,
 			final String propertyName,
 			final Object anything,
 			final boolean isCascadeDeleteEnabled) throws HibernateException {
 
 		if (child!=null) {
 			if ( type.isAssociationType() ) {
 				AssociationType associationType = (AssociationType) type;
 				if ( cascadeAssociationNow( associationType ) ) {
 					cascadeAssociation(
 							parent,
 							child,
 							type,
 							style,
 							anything,
 							isCascadeDeleteEnabled
 						);
 				}
 			}
 			else if ( type.isComponentType() ) {
 				cascadeComponent( parent, child, (CompositeType) type, propertyName, anything );
 			}
 		}
 		else {
 			// potentially we need to handle orphan deletes for one-to-ones here...
 			if ( isLogicalOneToOne( type ) ) {
 				// We have a physical or logical one-to-one and from previous checks we know we
 				// have a null value.  See if the attribute cascade settings and action-type require
 				// orphan checking
 				if ( style.hasOrphanDelete() && action.deleteOrphans() ) {
 					// value is orphaned if loaded state for this property shows not null
 					// because it is currently null.
 					final EntityEntry entry = eventSource.getPersistenceContext().getEntry( parent );
 					if ( entry != null && entry.getStatus() != Status.SAVING ) {
 						final Object loadedValue;
 						if ( componentPathStack.isEmpty() ) {
 							// association defined on entity
 							loadedValue = entry.getLoadedValue( propertyName );
 						}
 						else {
 							// association defined on component
 							// 		todo : this is currently unsupported because of the fact that
 							//		we do not know the loaded state of this value properly
 							//		and doing so would be very difficult given how components and
 							//		entities are loaded (and how 'loaded state' is put into the
 							//		EntityEntry).  Solutions here are to either:
 							//			1) properly account for components as a 2-phase load construct
 							//			2) just assume the association was just now orphaned and
 							// 				issue the orphan delete.  This would require a special
 							//				set of SQL statements though since we do not know the
 							//				orphaned value, something a delete with a subquery to
 							// 				match the owner.
 //							final EntityType entityType = (EntityType) type;
 //							final String propertyPath = composePropertyPath( entityType.getPropertyName() );
 							loadedValue = null;
 						}
 						if ( loadedValue != null ) {
 							final String entityName = entry.getPersister().getEntityName();
                             if (LOG.isTraceEnabled()) {
 								final Serializable id = entry.getPersister().getIdentifier( loadedValue, eventSource );
 								final String description = MessageHelper.infoString( entityName, id );
                                 LOG.trace("Deleting orphaned entity instance: " + description);
 							}
 							eventSource.delete( entityName, loadedValue, false, new HashSet() );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	/**
 	 * Check if the association is a one to one in the logical model (either a shared-pk
 	 * or unique fk).
 	 *
 	 * @param type The type representing the attribute metadata
 	 *
 	 * @return True if the attribute represents a logical one to one association
 	 */
 	private boolean isLogicalOneToOne(Type type) {
 		return type.isEntityType() && ( (EntityType) type ).isLogicalOneToOne();
 	}
 
 	private String composePropertyPath(String propertyName) {
 		if ( componentPathStack.isEmpty() ) {
 			return propertyName;
 		}
 		else {
 			StringBuffer buffer = new StringBuffer();
 			Iterator itr = componentPathStack.iterator();
 			while ( itr.hasNext() ) {
 				buffer.append( itr.next() ).append( '.' );
 			}
 			buffer.append( propertyName );
 			return buffer.toString();
 		}
 	}
 
 	private Stack componentPathStack = new Stack();
 
 	private boolean cascadeAssociationNow(AssociationType associationType) {
 		return associationType.getForeignKeyDirection().cascadeNow(cascadeTo) &&
 			( eventSource.getEntityMode()!=EntityMode.DOM4J || associationType.isEmbeddedInXML() );
 	}
 
 	private void cascadeComponent(
 			final Object parent,
 			final Object child,
 			final CompositeType componentType,
 			final String componentPropertyName,
 			final Object anything) {
 		componentPathStack.push( componentPropertyName );
 		Object[] children = componentType.getPropertyValues( child, eventSource );
 		Type[] types = componentType.getSubtypes();
 		for ( int i=0; i<types.length; i++ ) {
 			final CascadeStyle componentPropertyStyle = componentType.getCascadeStyle(i);
 			final String subPropertyName = componentType.getPropertyNames()[i];
 			if ( componentPropertyStyle.doCascade(action) ) {
 				cascadeProperty(
 						parent,
 						children[i],
 						types[i],
 						componentPropertyStyle,
 						subPropertyName,
 						anything,
 						false
 					);
 			}
 		}
 		componentPathStack.pop();
 	}
 
 	private void cascadeAssociation(
 			final Object parent,
 			final Object child,
 			final Type type,
 			final CascadeStyle style,
 			final Object anything,
 			final boolean isCascadeDeleteEnabled) {
 		if ( type.isEntityType() || type.isAnyType() ) {
 			cascadeToOne( parent, child, type, style, anything, isCascadeDeleteEnabled );
 		}
 		else if ( type.isCollectionType() ) {
 			cascadeCollection( parent, child, style, anything, (CollectionType) type );
 		}
 	}
 
 	/**
 	 * Cascade an action to a collection
 	 */
 	private void cascadeCollection(
 			final Object parent,
 			final Object child,
 			final CascadeStyle style,
 			final Object anything,
 			final CollectionType type) {
 		CollectionPersister persister = eventSource.getFactory()
 				.getCollectionPersister( type.getRole() );
 		Type elemType = persister.getElementType();
 
 		final int oldCascadeTo = cascadeTo;
 		if ( cascadeTo==AFTER_INSERT_BEFORE_DELETE) {
 			cascadeTo = AFTER_INSERT_BEFORE_DELETE_VIA_COLLECTION;
 		}
 
 		//cascade to current collection elements
 		if ( elemType.isEntityType() || elemType.isAnyType() || elemType.isComponentType() ) {
 			cascadeCollectionElements(
 				parent,
 				child,
 				type,
 				style,
 				elemType,
 				anything,
 				persister.isCascadeDeleteEnabled()
 			);
 		}
 
 		cascadeTo = oldCascadeTo;
 	}
 
 	/**
 	 * Cascade an action to a to-one association or any type
 	 */
 	private void cascadeToOne(
 			final Object parent,
 			final Object child,
 			final Type type,
 			final CascadeStyle style,
 			final Object anything,
 			final boolean isCascadeDeleteEnabled) {
 		final String entityName = type.isEntityType()
 				? ( (EntityType) type ).getAssociatedEntityName()
 				: null;
 		if ( style.reallyDoCascade(action) ) { //not really necessary, but good for consistency...
 			eventSource.getPersistenceContext().addChildParent(child, parent);
 			try {
 				action.cascade(eventSource, child, entityName, anything, isCascadeDeleteEnabled);
 			}
 			finally {
 				eventSource.getPersistenceContext().removeChildParent(child);
 			}
 		}
 	}
 
 	/**
 	 * Cascade to the collection elements
 	 */
 	private void cascadeCollectionElements(
 			final Object parent,
 			final Object child,
 			final CollectionType collectionType,
 			final CascadeStyle style,
 			final Type elemType,
 			final Object anything,
 			final boolean isCascadeDeleteEnabled) throws HibernateException {
 		// we can't cascade to non-embedded elements
 		boolean embeddedElements = eventSource.getEntityMode()!=EntityMode.DOM4J ||
 				( (EntityType) collectionType.getElementType( eventSource.getFactory() ) ).isEmbeddedInXML();
 
 		boolean reallyDoCascade = style.reallyDoCascade(action) &&
 			embeddedElements && child!=CollectionType.UNFETCHED_COLLECTION;
 
 		if ( reallyDoCascade ) {
             LOG.trace("Cascade " + action + " for collection: " + collectionType.getRole());
 
 			Iterator iter = action.getCascadableChildrenIterator(eventSource, collectionType, child);
 			while ( iter.hasNext() ) {
 				cascadeProperty(
 						parent,
 						iter.next(),
 						elemType,
 						style,
 						null,
 						anything,
 						isCascadeDeleteEnabled
 					);
 			}
 
             LOG.trace("Done cascade " + action + " for collection: " + collectionType.getRole());
 		}
 
 		final boolean deleteOrphans = style.hasOrphanDelete() &&
 				action.deleteOrphans() &&
 				elemType.isEntityType() &&
 				child instanceof PersistentCollection; //a newly instantiated collection can't have orphans
 
 		if ( deleteOrphans ) { // handle orphaned entities!!
             LOG.trace("Deleting orphans for collection: " + collectionType.getRole());
 
 			// we can do the cast since orphan-delete does not apply to:
 			// 1. newly instantiated collections
 			// 2. arrays (we can't track orphans for detached arrays)
 			final String entityName = collectionType.getAssociatedEntityName( eventSource.getFactory() );
 			deleteOrphans( entityName, (PersistentCollection) child );
 
             LOG.trace("Done deleting orphans for collection: " + collectionType.getRole());
 		}
 	}
 
 	/**
 	 * Delete any entities that were removed from the collection
 	 */
 	private void deleteOrphans(String entityName, PersistentCollection pc) throws HibernateException {
 		//TODO: suck this logic into the collection!
 		final Collection orphans;
 		if ( pc.wasInitialized() ) {
 			CollectionEntry ce = eventSource.getPersistenceContext().getCollectionEntry(pc);
 			orphans = ce==null ?
 					CollectionHelper.EMPTY_COLLECTION :
 					ce.getOrphans(entityName, pc);
 		}
 		else {
 			orphans = pc.getQueuedOrphans(entityName);
 		}
 
 		final Iterator orphanIter = orphans.iterator();
 		while ( orphanIter.hasNext() ) {
 			Object orphan = orphanIter.next();
 			if (orphan!=null) {
                 LOG.trace("Deleting orphaned entity instance: " + entityName);
 				eventSource.delete( entityName, orphan, false, new HashSet() );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java b/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
index 2c6a403277..7a33080123 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
@@ -1,340 +1,340 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.CacheMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PostLoadEventListener;
-import org.hibernate.event.PreLoadEvent;
-import org.hibernate.event.PreLoadEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostLoadEvent;
+import org.hibernate.event.spi.PostLoadEventListener;
+import org.hibernate.event.spi.PreLoadEvent;
+import org.hibernate.event.spi.PreLoadEventListener;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.property.BackrefPropertyAccessor;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * Functionality relating to Hibernate's two-phase loading process,
  * that may be reused by persisters that do not use the Loader
  * framework
  *
  * @author Gavin King
  */
 public final class TwoPhaseLoad {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class, TwoPhaseLoad.class.getName()
 	);
 
 	private TwoPhaseLoad() {}
 
 	/**
 	 * Register the "hydrated" state of an entity instance, after the first step of 2-phase loading.
 	 *
 	 * Add the "hydrated state" (an array) of an uninitialized entity to the session. We don't try
 	 * to resolve any associations yet, because there might be other entities waiting to be
 	 * read from the JDBC result set we are currently processing
 	 */
 	public static void postHydrate(
 		final EntityPersister persister,
 		final Serializable id,
 		final Object[] values,
 		final Object rowId,
 		final Object object,
 		final LockMode lockMode,
 		final boolean lazyPropertiesAreUnfetched,
 		final SessionImplementor session)
 	throws HibernateException {
 
 		Object version = Versioning.getVersion( values, persister );
 		session.getPersistenceContext().addEntry(
 				object,
 				Status.LOADING,
 				values,
 				rowId,
 				id,
 				version,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnfetched
 			);
 
         if (LOG.isTraceEnabled() && version != null) {
 			String versionStr = persister.isVersioned()
 					? persister.getVersionType().toLoggableString( version, session.getFactory() )
 			        : "null";
             LOG.trace("Version: " + versionStr);
 		}
 
 	}
 
 	/**
 	 * Perform the second step of 2-phase load. Fully initialize the entity
 	 * instance.
 	 *
 	 * After processing a JDBC result set, we "resolve" all the associations
 	 * between the entities which were instantiated and had their state
 	 * "hydrated" into an array
 	 */
 	public static void initializeEntity(
 			final Object entity,
 			final boolean readOnly,
 			final SessionImplementor session,
 			final PreLoadEvent preLoadEvent,
 			final PostLoadEvent postLoadEvent) throws HibernateException {
 
 		//TODO: Should this be an InitializeEntityEventListener??? (watch out for performance!)
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		EntityEntry entityEntry = persistenceContext.getEntry(entity);
 		if ( entityEntry == null ) {
 			throw new AssertionFailure( "possible non-threadsafe access to the session" );
 		}
 		EntityPersister persister = entityEntry.getPersister();
 		Serializable id = entityEntry.getId();
 		Object[] hydratedState = entityEntry.getLoadedState();
 
         if (LOG.isDebugEnabled()) LOG.debugf(
 				"Resolving associations for %s",
 				MessageHelper.infoString( persister, id, session.getFactory() )
 		);
 
 		Type[] types = persister.getPropertyTypes();
 		for ( int i = 0; i < hydratedState.length; i++ ) {
 			final Object value = hydratedState[i];
 			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
 				hydratedState[i] = types[i].resolve( value, session, entity );
 			}
 		}
 
 		//Must occur after resolving identifiers!
 		if ( session.isEventSource() ) {
 			preLoadEvent.setEntity( entity ).setState( hydratedState ).setId( id ).setPersister( persister );
 
 			final EventListenerGroup<PreLoadEventListener> listenerGroup = session
 					.getFactory()
 					.getServiceRegistry()
 					.getService( EventListenerRegistry.class )
 					.getEventListenerGroup( EventType.PRE_LOAD );
 			for ( PreLoadEventListener listener : listenerGroup.listeners() ) {
 				listener.onPreLoad( preLoadEvent );
 			}
 		}
 
 		persister.setPropertyValues( entity, hydratedState, session.getEntityMode() );
 
 		final SessionFactoryImplementor factory = session.getFactory();
 		if ( persister.hasCache() && session.getCacheMode().isPutEnabled() ) {
 
             if (LOG.isDebugEnabled()) LOG.debugf(
 					"Adding entity to second-level cache: %s",
 					MessageHelper.infoString( persister, id, session.getFactory() )
 			);
 
 			Object version = Versioning.getVersion(hydratedState, persister);
 			CacheEntry entry = new CacheEntry(
 					hydratedState,
 					persister,
 					entityEntry.isLoadedWithLazyPropertiesUnfetched(),
 					version,
 					session,
 					entity
 			);
 			CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
 
 			// explicit handling of caching for rows just inserted and then somehow forced to be read
 			// from the database *within the same transaction*.  usually this is done by
 			// 		1) Session#refresh, or
 			// 		2) Session#clear + some form of load
 			//
 			// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be
 			if ( session.getPersistenceContext().wasInsertedDuringTransaction( persister, id ) ) {
 				persister.getCacheAccessStrategy().update(
 						cacheKey,
 						persister.getCacheEntryStructure().structure( entry ),
 						version,
 						version
 				);
 			}
 			else {
 				boolean put = persister.getCacheAccessStrategy().putFromLoad(
 						cacheKey,
 						persister.getCacheEntryStructure().structure( entry ),
 						session.getTimestamp(),
 						version,
 						useMinimalPuts( session, entityEntry )
 				);
 
 				if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 					factory.getStatisticsImplementor().secondLevelCachePut( persister.getCacheAccessStrategy().getRegion().getName() );
 				}
 			}
 		}
 
 		boolean isReallyReadOnly = readOnly;
 		if ( !persister.isMutable() ) {
 			isReallyReadOnly = true;
 		}
 		else {
 			Object proxy = persistenceContext.getProxy( entityEntry.getEntityKey() );
 			if ( proxy != null ) {
 				// there is already a proxy for this impl
 				// only set the status to read-only if the proxy is read-only
 				isReallyReadOnly = ( ( HibernateProxy ) proxy ).getHibernateLazyInitializer().isReadOnly();
 			}
 		}
 		if ( isReallyReadOnly ) {
 			//no need to take a snapshot - this is a
 			//performance optimization, but not really
 			//important, except for entities with huge
 			//mutable property values
 			persistenceContext.setEntryStatus(entityEntry, Status.READ_ONLY);
 		}
 		else {
 			//take a snapshot
 			TypeHelper.deepCopy(
 					hydratedState,
 					persister.getPropertyTypes(),
 					persister.getPropertyUpdateability(),
 					hydratedState,  //after setting values to object, entityMode
 					session
 			);
 			persistenceContext.setEntryStatus(entityEntry, Status.MANAGED);
 		}
 
 		persister.afterInitialize(
 				entity,
 				entityEntry.isLoadedWithLazyPropertiesUnfetched(),
 				session
 			);
 
 		if ( session.isEventSource() ) {
 			postLoadEvent.setEntity( entity ).setId( id ).setPersister( persister );
 
 			final EventListenerGroup<PostLoadEventListener> listenerGroup = session
 					.getFactory()
 					.getServiceRegistry()
 					.getService( EventListenerRegistry.class )
 					.getEventListenerGroup( EventType.POST_LOAD );
 			for ( PostLoadEventListener listener : listenerGroup.listeners() ) {
 				listener.onPostLoad( postLoadEvent );
 			}
 		}
 
         if ( LOG.isDebugEnabled() ) {
 			LOG.debugf(
 					"Done materializing entity %s",
 					MessageHelper.infoString( persister, id, session.getFactory() )
 			);
 		}
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().loadEntity( persister.getEntityName() );
 		}
 
 	}
 
 	private static boolean useMinimalPuts(SessionImplementor session, EntityEntry entityEntry) {
 		return ( session.getFactory().getSettings().isMinimalPutsEnabled() &&
 						session.getCacheMode()!=CacheMode.REFRESH ) ||
 				( entityEntry.getPersister().hasLazyProperties() &&
 						entityEntry.isLoadedWithLazyPropertiesUnfetched() &&
 						entityEntry.getPersister().isLazyPropertiesCacheable() );
 	}
 
 	/**
 	 * Add an uninitialized instance of an entity class, as a placeholder to ensure object
 	 * identity. Must be called before <tt>postHydrate()</tt>.
 	 *
 	 * Create a "temporary" entry for a newly instantiated entity. The entity is uninitialized,
 	 * but we need the mapping from id to instance in order to guarantee uniqueness.
 	 */
 	public static void addUninitializedEntity(
 			final EntityKey key,
 			final Object object,
 			final EntityPersister persister,
 			final LockMode lockMode,
 			final boolean lazyPropertiesAreUnfetched,
 			final SessionImplementor session
 	) {
 		session.getPersistenceContext().addEntity(
 				object,
 				Status.LOADING,
 				null,
 				key,
 				null,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnfetched
 			);
 	}
 
 	public static void addUninitializedCachedEntity(
 			final EntityKey key,
 			final Object object,
 			final EntityPersister persister,
 			final LockMode lockMode,
 			final boolean lazyPropertiesAreUnfetched,
 			final Object version,
 			final SessionImplementor session
 	) {
 		session.getPersistenceContext().addEntity(
 				object,
 				Status.LOADING,
 				null,
 				key,
 				version,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnfetched
 			);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
index cf523bfd18..fbd1a1616e 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
@@ -1,339 +1,339 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.FilterTranslator;
 import org.hibernate.hql.ParameterTranslations;
 import org.hibernate.hql.QuerySplitter;
 import org.hibernate.hql.QueryTranslator;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.type.Type;
 
 /**
  * Defines a query execution plan for an HQL query (or filter).
  *
  * @author Steve Ebersole
  */
 public class HQLQueryPlan implements Serializable {
 
     // TODO : keep separate notions of QT[] here for shallow/non-shallow queries...
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HQLQueryPlan.class.getName());
 
 	private final String sourceQuery;
 	private final QueryTranslator[] translators;
 	private final String[] sqlStrings;
 
 	private final ParameterMetadata parameterMetadata;
 	private final ReturnMetadata returnMetadata;
 	private final Set querySpaces;
 
 	private final Set enabledFilterNames;
 	private final boolean shallow;
 
 
 	public HQLQueryPlan(String hql, boolean shallow, Map enabledFilters, SessionFactoryImplementor factory) {
 		this( hql, null, shallow, enabledFilters, factory );
 	}
 
 	protected HQLQueryPlan(String hql, String collectionRole, boolean shallow, Map enabledFilters, SessionFactoryImplementor factory) {
 		this.sourceQuery = hql;
 		this.shallow = shallow;
 
 		Set copy = new HashSet();
 		copy.addAll( enabledFilters.keySet() );
 		this.enabledFilterNames = java.util.Collections.unmodifiableSet( copy );
 
 		Set combinedQuerySpaces = new HashSet();
 		String[] concreteQueryStrings = QuerySplitter.concreteQueries( hql, factory );
 		final int length = concreteQueryStrings.length;
 		translators = new QueryTranslator[length];
 		List sqlStringList = new ArrayList();
 		for ( int i=0; i<length; i++ ) {
 			if ( collectionRole == null ) {
 				translators[i] = factory.getSettings()
 						.getQueryTranslatorFactory()
 						.createQueryTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				translators[i].compile( factory.getSettings().getQuerySubstitutions(), shallow );
 			}
 			else {
 				translators[i] = factory.getSettings()
 						.getQueryTranslatorFactory()
 						.createFilterTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				( ( FilterTranslator ) translators[i] ).compile( collectionRole, factory.getSettings().getQuerySubstitutions(), shallow );
 			}
 			combinedQuerySpaces.addAll( translators[i].getQuerySpaces() );
 			sqlStringList.addAll( translators[i].collectSqlStrings() );
 		}
 
 		this.sqlStrings = ArrayHelper.toStringArray( sqlStringList );
 		this.querySpaces = combinedQuerySpaces;
 
 		if ( length == 0 ) {
 			parameterMetadata = new ParameterMetadata( null, null );
 			returnMetadata = null;
 		}
 		else {
 			this.parameterMetadata = buildParameterMetadata( translators[0].getParameterTranslations(), hql );
 			if ( translators[0].isManipulationStatement() ) {
 				returnMetadata = null;
 			}
 			else {
 				if ( length > 1 ) {
 					final int returns = translators[0].getReturnTypes().length;
 					returnMetadata = new ReturnMetadata( translators[0].getReturnAliases(), new Type[returns] );
 				}
 				else {
 					returnMetadata = new ReturnMetadata( translators[0].getReturnAliases(), translators[0].getReturnTypes() );
 				}
 			}
 		}
 	}
 
 	public String getSourceQuery() {
 		return sourceQuery;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	public ReturnMetadata getReturnMetadata() {
 		return returnMetadata;
 	}
 
 	public Set getEnabledFilterNames() {
 		return enabledFilterNames;
 	}
 
 	public String[] getSqlStrings() {
 		return sqlStrings;
 	}
 
 	public Set getUtilizedFilterNames() {
 		// TODO : add this info to the translator and aggregate it here...
 		return null;
 	}
 
 	public boolean isShallow() {
 		return shallow;
 	}
 
 	public List performList(
 			QueryParameters queryParameters,
 	        SessionImplementor session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Find: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		boolean hasLimit = queryParameters.getRowSelection() != null &&
 		                   queryParameters.getRowSelection().definesLimits();
 		boolean needsLimit = hasLimit && translators.length > 1;
 		QueryParameters queryParametersToUse;
 		if ( needsLimit ) {
             LOG.needsLimit();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List combinedResults = new ArrayList();
 		IdentitySet distinction = new IdentitySet();
 		int includedCount = -1;
 		translator_loop: for ( int i = 0; i < translators.length; i++ ) {
 			List tmp = translators[i].list( session, queryParametersToUse );
 			if ( needsLimit ) {
 				// NOTE : firstRow is zero-based
 				int first = queryParameters.getRowSelection().getFirstRow() == null
 				            ? 0
 			                : queryParameters.getRowSelection().getFirstRow().intValue();
 				int max = queryParameters.getRowSelection().getMaxRows() == null
 				            ? -1
 			                : queryParameters.getRowSelection().getMaxRows().intValue();
 				final int size = tmp.size();
 				for ( int x = 0; x < size; x++ ) {
 					final Object result = tmp.get( x );
 					if ( ! distinction.add( result ) ) {
 						continue;
 					}
 					includedCount++;
 					if ( includedCount < first ) {
 						continue;
 					}
 					combinedResults.add( result );
 					if ( max >= 0 && includedCount > max ) {
 						// break the outer loop !!!
 						break translator_loop;
 					}
 				}
 			}
 			else {
 				combinedResults.addAll( tmp );
 			}
 		}
 		return combinedResults;
 	}
 
 	public Iterator performIterate(
 			QueryParameters queryParameters,
 	        EventSource session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Iterate: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length == 0 ) {
 			return EmptyIterator.INSTANCE;
 		}
 
 		Iterator[] results = null;
 		boolean many = translators.length > 1;
 		if (many) {
 			results = new Iterator[translators.length];
 		}
 
 		Iterator result = null;
 		for ( int i = 0; i < translators.length; i++ ) {
 			result = translators[i].iterate( queryParameters, session );
 			if (many) results[i] = result;
 		}
 
 		return many ? new JoinedIterator(results) : result;
 	}
 
 	public ScrollableResults performScroll(
 			QueryParameters queryParameters,
 	        SessionImplementor session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Iterate: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length != 1 ) {
 			throw new QueryException( "implicit polymorphism not supported for scroll() queries" );
 		}
 		if ( queryParameters.getRowSelection().definesLimits() && translators[0].containsCollectionFetches() ) {
 			throw new QueryException( "firstResult/maxResults not supported in conjunction with scroll() of a query containing collection fetches" );
 		}
 
 		return translators[0].scroll( queryParameters, session );
 	}
 
 	public int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Execute update: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
         if (translators.length != 1) LOG.splitQueries(getSourceQuery(), translators.length);
 		int result = 0;
 		for ( int i = 0; i < translators.length; i++ ) {
 			result += translators[i].executeUpdate( queryParameters, session );
 		}
 		return result;
 	}
 
 	private ParameterMetadata buildParameterMetadata(ParameterTranslations parameterTranslations, String hql) {
 		long start = System.currentTimeMillis();
 		ParamLocationRecognizer recognizer = ParamLocationRecognizer.parseLocations( hql );
 		long end = System.currentTimeMillis();
         LOG.trace("HQL param location recognition took " + (end - start) + " mills (" + hql + ")");
 
 		int ordinalParamCount = parameterTranslations.getOrdinalParameterCount();
 		int[] locations = ArrayHelper.toIntArray( recognizer.getOrdinalParameterLocationList() );
 		if ( parameterTranslations.supportsOrdinalParameterMetadata() && locations.length != ordinalParamCount ) {
 			throw new HibernateException( "ordinal parameter mismatch" );
 		}
 		ordinalParamCount = locations.length;
 		OrdinalParameterDescriptor[] ordinalParamDescriptors = new OrdinalParameterDescriptor[ordinalParamCount];
 		for ( int i = 1; i <= ordinalParamCount; i++ ) {
 			ordinalParamDescriptors[ i - 1 ] = new OrdinalParameterDescriptor(
 					i,
 			        parameterTranslations.supportsOrdinalParameterMetadata()
 		                    ? parameterTranslations.getOrdinalParameterExpectedType( i )
 		                    : null,
 			        locations[ i - 1 ]
 			);
 		}
 
 		Iterator itr = recognizer.getNamedParameterDescriptionMap().entrySet().iterator();
 		Map namedParamDescriptorMap = new HashMap();
 		while( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String name = ( String ) entry.getKey();
 			final ParamLocationRecognizer.NamedParameterDescription description =
 					( ParamLocationRecognizer.NamedParameterDescription ) entry.getValue();
 			namedParamDescriptorMap.put(
 					name,
 					new NamedParameterDescriptor(
 							name,
 					        parameterTranslations.getNamedParameterExpectedType( name ),
 					        description.buildPositionsArray(),
 					        description.isJpaStyle()
 					)
 			);
 		}
 
 		return new ParameterMetadata( ordinalParamDescriptors, namedParamDescriptorMap );
 	}
 
 	public QueryTranslator[] getTranslators() {
 		QueryTranslator[] copy = new QueryTranslator[translators.length];
 		System.arraycopy(translators, 0, copy, 0, copy.length);
 		return copy;
 	}
 
 	public Class getDynamicInstantiationResultType() {
 		return translators[0].getDynamicInstantiationResultType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeSQLQueryPlan.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeSQLQueryPlan.java
index 2e489291f9..323ee49b40 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeSQLQueryPlan.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeSQLQueryPlan.java
@@ -1,217 +1,217 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.TypedValue;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.action.internal.BulkOperationCleanupAction;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.custom.sql.SQLCustomQuery;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Defines a query execution plan for a native-SQL query.
  *
  * @author Steve Ebersole
  */
 public class NativeSQLQueryPlan implements Serializable {
 	private final String sourceQuery;
 
 	private final SQLCustomQuery customQuery;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, NativeSQLQueryPlan.class.getName());
 
 	public NativeSQLQueryPlan(
 			NativeSQLQuerySpecification specification,
 			SessionFactoryImplementor factory) {
 		this.sourceQuery = specification.getQueryString();
 
 		customQuery = new SQLCustomQuery(
 				specification.getQueryString(),
 				specification.getQueryReturns(),
 				specification.getQuerySpaces(),
 				factory );
 	}
 
 	public String getSourceQuery() {
 		return sourceQuery;
 	}
 
 	public SQLCustomQuery getCustomQuery() {
 		return customQuery;
 	}
 
 	private int[] getNamedParameterLocs(String name) throws QueryException {
 		Object loc = customQuery.getNamedParameterBindPoints().get( name );
 		if ( loc == null ) {
 			throw new QueryException(
 					"Named parameter does not appear in Query: " + name,
 					customQuery.getSQL() );
 		}
 		if ( loc instanceof Integer ) {
 			return new int[] { ((Integer) loc ).intValue() };
 		}
 		else {
 			return ArrayHelper.toIntArray( (List) loc );
 		}
 	}
 
 	/**
 	 * Perform binding of all the JDBC bind parameter values based on the user-defined
 	 * positional query parameters (these are the '?'-style hibernate query
 	 * params) into the JDBC {@link PreparedStatement}.
 	 *
 	 * @param st The prepared statement to which to bind the parameter values.
 	 * @param queryParameters The query parameters specified by the application.
 	 * @param start JDBC paramer binds are positional, so this is the position
 	 * from which to start binding.
 	 * @param session The session from which the query originated.
 	 *
 	 * @return The number of JDBC bind positions accounted for during execution.
 	 *
 	 * @throws SQLException Some form of JDBC error binding the values.
 	 * @throws HibernateException Generally indicates a mapping problem or type mismatch.
 	 */
 	private int bindPositionalParameters(
 			final PreparedStatement st,
 			final QueryParameters queryParameters,
 			final int start,
 			final SessionImplementor session) throws SQLException {
 		final Object[] values = queryParameters.getFilteredPositionalParameterValues();
 		final Type[] types = queryParameters.getFilteredPositionalParameterTypes();
 		int span = 0;
 		for (int i = 0; i < values.length; i++) {
 			types[i].nullSafeSet( st, values[i], start + span, session );
 			span += types[i].getColumnSpan( session.getFactory() );
 		}
 		return span;
 	}
 
 	/**
 	 * Perform binding of all the JDBC bind parameter values based on the user-defined
 	 * named query parameters into the JDBC {@link PreparedStatement}.
 	 *
 	 * @param ps The prepared statement to which to bind the parameter values.
 	 * @param namedParams The named query parameters specified by the application.
 	 * @param start JDBC paramer binds are positional, so this is the position
 	 * from which to start binding.
 	 * @param session The session from which the query originated.
 	 *
 	 * @return The number of JDBC bind positions accounted for during execution.
 	 *
 	 * @throws SQLException Some form of JDBC error binding the values.
 	 * @throws HibernateException Generally indicates a mapping problem or type mismatch.
 	 */
 	private int bindNamedParameters(
 			final PreparedStatement ps,
 			final Map namedParams,
 			final int start,
 			final SessionImplementor session) throws SQLException {
 		if ( namedParams != null ) {
 			// assumes that types are all of span 1
 			Iterator iter = namedParams.entrySet().iterator();
 			int result = 0;
 			while ( iter.hasNext() ) {
 				Map.Entry e = (Map.Entry) iter.next();
 				String name = (String) e.getKey();
 				TypedValue typedval = (TypedValue) e.getValue();
 				int[] locs = getNamedParameterLocs( name );
 				for (int i = 0; i < locs.length; i++) {
                     LOG.debugf("bindNamedParameters() %s -> %s [%s]", typedval.getValue(), name, locs[i] + start);
 					typedval.getType().nullSafeSet( ps, typedval.getValue(),
 							locs[i] + start, session );
 				}
 				result += locs.length;
 			}
 			return result;
 		}
         return 0;
 	}
 
 	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
 		BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );
 
 		if ( session.isEventSource() ) {
 			( ( EventSource ) session ).getActionQueue().addAction( action );
 		}
 		else {
 			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
 		}
 	}
 
 	public int performExecuteUpdate(QueryParameters queryParameters,
 			SessionImplementor session) throws HibernateException {
 
 		coordinateSharedCacheCleanup( session );
 
 		if(queryParameters.isCallable()) {
 			throw new IllegalArgumentException("callable not yet supported for native queries");
 		}
 
 		int result = 0;
 		PreparedStatement ps;
 		try {
 			queryParameters.processFilters( this.customQuery.getSQL(),
 					session );
 			String sql = queryParameters.getFilteredSQL();
 
 			ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 
 			try {
 				int col = 1;
 				col += bindPositionalParameters( ps, queryParameters, col,
 						session );
 				col += bindNamedParameters( ps, queryParameters
 						.getNamedParameters(), col, session );
 				result = ps.executeUpdate();
 			}
 			finally {
 				if ( ps != null ) {
 					ps.close();
 				}
 			}
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle, "could not execute native bulk manipulation query", this.sourceQuery );
 		}
 
 		return result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
index 929765f1f5..d1c838a614 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
@@ -1,468 +1,468 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.ReplicationMode;
 import org.hibernate.TransientObjectException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.internal.ForeignKeys;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * A session action that may be cascaded from parent entity to its children
  *
  * @author Gavin King
  */
 public abstract class CascadingAction {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, CascadingAction.class.getName());
 
 
 	// the CascadingAction contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public CascadingAction() {
 	}
 
 	/**
 	 * Cascade the action to the child object.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param child The child to which cascading should be performed.
 	 * @param entityName The child's entity name
 	 * @param anything Anything ;)  Typically some form of cascade-local cache
 	 * which is specific to each CascadingAction type
 	 * @param isCascadeDeleteEnabled Are cascading deletes enabled.
 	 * @throws HibernateException
 	 */
 	public abstract void cascade(
 			EventSource session,
 			Object child,
 			String entityName,
 			Object anything,
 			boolean isCascadeDeleteEnabled) throws HibernateException;
 
 	/**
 	 * Given a collection, get an iterator of the children upon which the
 	 * current cascading action should be visited.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param collectionType The mapping type of the collection.
 	 * @param collection The collection instance.
 	 * @return The children iterator.
 	 */
 	public abstract Iterator getCascadableChildrenIterator(
 			EventSource session,
 			CollectionType collectionType,
 			Object collection);
 
 	/**
 	 * Does this action potentially extrapolate to orphan deletes?
 	 *
 	 * @return True if this action can lead to deletions of orphans.
 	 */
 	public abstract boolean deleteOrphans();
 
 
 	/**
 	 * Does the specified cascading action require verification of no cascade validity?
 	 *
 	 * @return True if this action requires no-cascade verification; false otherwise.
 	 */
 	public boolean requiresNoCascadeChecking() {
 		return false;
 	}
 
 	/**
 	 * Called (in the case of {@link #requiresNoCascadeChecking} returning true) to validate
 	 * that no cascade on the given property is considered a valid semantic.
 	 *
 	 * @param session The session witin which the cascade is occurring.
 	 * @param child The property value
 	 * @param parent The property value owner
 	 * @param persister The entity persister for the owner
 	 * @param propertyIndex The index of the property within the owner.
 	 */
 	public void noCascade(EventSource session, Object child, Object parent, EntityPersister persister, int propertyIndex) {
 	}
 
 	/**
 	 * Should this action be performed (or noCascade consulted) in the case of lazy properties.
 	 */
 	public boolean performOnLazyProperty() {
 		return true;
 	}
 
 
 	// the CascadingAction implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * @see org.hibernate.Session#delete(Object)
 	 */
 	public static final CascadingAction DELETE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to delete: " + entityName);
 			session.delete( entityName, child, isCascadeDeleteEnabled, ( Set ) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// delete does cascade to uninitialized collections
 			return CascadingAction.getAllElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should be deleted during delete
 			return true;
 		}
 		@Override
         public String toString() {
 			return "ACTION_DELETE";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#lock(Object, LockMode)
 	 */
 	public static final CascadingAction LOCK = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to lock: " + entityName);
 			LockMode lockMode = LockMode.NONE;
 			LockOptions lr = new LockOptions();
 			if ( anything instanceof LockOptions) {
 				LockOptions lockOptions = (LockOptions)anything;
 				lr.setTimeOut(lockOptions.getTimeOut());
 				lr.setScope( lockOptions.getScope());
 				if ( lockOptions.getScope() == true )	// cascade specified lockMode
 					lockMode = lockOptions.getLockMode();
 			}
 			lr.setLockMode(lockMode);
 			session.buildLockRequest(lr).lock(entityName, child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// lock doesn't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			//TODO: should orphans really be deleted during lock???
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_LOCK";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#refresh(Object)
 	 */
 	public static final CascadingAction REFRESH = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to refresh: " + entityName);
 			session.refresh( child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// refresh doesn't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_REFRESH";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#evict(Object)
 	 */
 	public static final CascadingAction EVICT = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to evict: " + entityName);
 			session.evict(child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// evicts don't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_EVICT";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#saveOrUpdate(Object)
 	 */
 	public static final CascadingAction SAVE_UPDATE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to save or update: " + entityName);
 			session.saveOrUpdate(entityName, child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// saves / updates don't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should be deleted during save/update
 			return true;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_SAVE_UPDATE";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#merge(Object)
 	 */
 	public static final CascadingAction MERGE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to merge: " + entityName);
 			session.merge( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// merges don't cascade to uninitialized collections
 //			//TODO: perhaps this does need to cascade after all....
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should not be deleted during merge??
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_MERGE";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#persist(Object)
 	 */
 	public static final CascadingAction PERSIST = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to persist: " + entityName);
 			session.persist( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// persists don't cascade to uninitialized collections
 			return CascadingAction.getAllElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_PERSIST";
 		}
 	};
 
 	/**
 	 * Execute persist during flush time
 	 *
 	 * @see org.hibernate.Session#persist(Object)
 	 */
 	public static final CascadingAction PERSIST_ON_FLUSH = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to persist on flush: " + entityName);
 			session.persistOnFlush( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// persists don't cascade to uninitialized collections
 			return CascadingAction.getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return true;
 		}
 		@Override
         public boolean requiresNoCascadeChecking() {
 			return true;
 		}
 		@Override
         public void noCascade(
 				EventSource session,
 				Object child,
 				Object parent,
 				EntityPersister persister,
 				int propertyIndex) {
 			if ( child == null ) {
 				return;
 			}
 			Type type = persister.getPropertyTypes()[propertyIndex];
 			if ( type.isEntityType() ) {
 				String childEntityName = ( ( EntityType ) type ).getAssociatedEntityName( session.getFactory() );
 
 				if ( ! isInManagedState( child, session )
 						&& ! ( child instanceof HibernateProxy ) //a proxy cannot be transient and it breaks ForeignKeys.isTransient
 						&& ForeignKeys.isTransient( childEntityName, child, null, session ) ) {
 					String parentEntiytName = persister.getEntityName();
 					String propertyName = persister.getPropertyNames()[propertyIndex];
 					throw new TransientObjectException(
 							"object references an unsaved transient instance - " +
 							"save the transient instance before flushing: " +
 							parentEntiytName + "." + propertyName + " -> " + childEntityName
 					);
 
 				}
 			}
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 
 		private boolean isInManagedState(Object child, EventSource session) {
 			EntityEntry entry = session.getPersistenceContext().getEntry( child );
 			return entry != null && (entry.getStatus() == Status.MANAGED || entry.getStatus() == Status.READ_ONLY);
 		}
 
 		@Override
         public String toString() {
 			return "ACTION_PERSIST_ON_FLUSH";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#replicate(Object, org.hibernate.ReplicationMode)
 	 */
 	public static final CascadingAction REPLICATE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to replicate: " + entityName);
 			session.replicate( entityName, child, (ReplicationMode) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// replicate does cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false; //I suppose?
 		}
 		@Override
         public String toString() {
 			return "ACTION_REPLICATE";
 		}
 	};
 
 
 	// static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Given a collection, get an iterator of all its children, loading them
 	 * from the database if necessary.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param collectionType The mapping type of the collection.
 	 * @param collection The collection instance.
 	 * @return The children iterator.
 	 */
 	private static Iterator getAllElementsIterator(
 			EventSource session,
 			CollectionType collectionType,
 			Object collection) {
 		return collectionType.getElementsIterator( collection, session );
 	}
 
 	/**
 	 * Iterate just the elements of the collection that are already there. Don't load
 	 * any new elements from the database.
 	 */
 	public static Iterator getLoadedElementsIterator(SessionImplementor session, CollectionType collectionType, Object collection) {
 		if ( collectionIsInitialized(collection) ) {
 			// handles arrays and newly instantiated collections
 			return collectionType.getElementsIterator(collection, session);
 		}
 		else {
 			// does not handle arrays (thats ok, cos they can't be lazy)
 			// or newly instantiated collections, so we can do the cast
 			return ( (PersistentCollection) collection ).queuedAdditionIterator();
 		}
 	}
 
 	private static boolean collectionIsInitialized(Object collection) {
 		return !(collection instanceof PersistentCollection) || ( (PersistentCollection) collection ).wasInitialized();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
index abd03055be..9e3e844421 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 
 public interface NonFlushedChanges extends Serializable {
 	/**
 	 * Extracts the non-flushed Changes from an EventSource into this NonFlushedChanges object.
 	 * <p>
 	 * @param source The session
 	 */
 	void extractFromSession(EventSource source);
 
 	/**
 	 * Remove the non-flushed changes from this NonFlushedChanges object.
 	 */
 	void clear();
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/event/Destructible.java b/hibernate-core/src/main/java/org/hibernate/event/Destructible.java
deleted file mode 100644
index 48b3b333e1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/event/Destructible.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.event;
-
-
-/**
- * Contract for listeners which require notification of SessionFactory closing,
- * presumably to destroy internal state.
- *
- * @author Steve Ebersole
- */
-public interface Destructible {
-	/**
-	 * Notification of {@link org.hibernate.SessionFactory} shutdown.
-	 */
-	public void cleanup();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java b/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java
deleted file mode 100644
index d202233d3a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java
+++ /dev/null
@@ -1,502 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.event;
-
-import java.io.Serializable;
-import java.lang.reflect.Field;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import org.hibernate.HibernateException;
-import org.hibernate.MappingException;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.event.def.DefaultAutoFlushEventListener;
-import org.hibernate.event.def.DefaultDeleteEventListener;
-import org.hibernate.event.def.DefaultDirtyCheckEventListener;
-import org.hibernate.event.def.DefaultEvictEventListener;
-import org.hibernate.event.def.DefaultFlushEntityEventListener;
-import org.hibernate.event.def.DefaultFlushEventListener;
-import org.hibernate.event.def.DefaultInitializeCollectionEventListener;
-import org.hibernate.event.def.DefaultLoadEventListener;
-import org.hibernate.event.def.DefaultLockEventListener;
-import org.hibernate.event.def.DefaultMergeEventListener;
-import org.hibernate.event.def.DefaultPersistEventListener;
-import org.hibernate.event.def.DefaultPersistOnFlushEventListener;
-import org.hibernate.event.def.DefaultPostLoadEventListener;
-import org.hibernate.event.def.DefaultPreLoadEventListener;
-import org.hibernate.event.def.DefaultRefreshEventListener;
-import org.hibernate.event.def.DefaultReplicateEventListener;
-import org.hibernate.event.def.DefaultSaveEventListener;
-import org.hibernate.event.def.DefaultSaveOrUpdateEventListener;
-import org.hibernate.event.def.DefaultUpdateEventListener;
-import org.hibernate.internal.util.Cloneable;
-
-/**
- * A convience holder for all defined session event listeners.
- *
- * @author Steve Ebersole
- */
-public class EventListeners extends Cloneable implements Serializable {
-
-	private LoadEventListener[] loadEventListeners = { new DefaultLoadEventListener() };
-	private SaveOrUpdateEventListener[] saveOrUpdateEventListeners = { new DefaultSaveOrUpdateEventListener() };
-	private MergeEventListener[] mergeEventListeners = { new DefaultMergeEventListener() };
-	private PersistEventListener[] persistEventListeners = { new DefaultPersistEventListener() };
-	private PersistEventListener[] persistOnFlushEventListeners = { new DefaultPersistOnFlushEventListener() };
-	private ReplicateEventListener[] replicateEventListeners = { new DefaultReplicateEventListener() };
-	private DeleteEventListener[] deleteEventListeners = { new DefaultDeleteEventListener() };
-	private AutoFlushEventListener[] autoFlushEventListeners = { new DefaultAutoFlushEventListener() };
-	private DirtyCheckEventListener[] dirtyCheckEventListeners = { new DefaultDirtyCheckEventListener() };
-	private FlushEventListener[] flushEventListeners = { new DefaultFlushEventListener() };
-	private EvictEventListener[] evictEventListeners = { new DefaultEvictEventListener() };
-	private LockEventListener[] lockEventListeners = { new DefaultLockEventListener() };
-	private RefreshEventListener[] refreshEventListeners = { new DefaultRefreshEventListener() };
-	private FlushEntityEventListener[] flushEntityEventListeners = { new DefaultFlushEntityEventListener() };
-	private InitializeCollectionEventListener[] initializeCollectionEventListeners =
-			{ new DefaultInitializeCollectionEventListener() };
-
-	private PostLoadEventListener[] postLoadEventListeners = { new DefaultPostLoadEventListener() };
-	private PreLoadEventListener[] preLoadEventListeners = { new DefaultPreLoadEventListener() };
-
-	private PreDeleteEventListener[] preDeleteEventListeners = {};
-	private PreUpdateEventListener[] preUpdateEventListeners = {};
-	private PreInsertEventListener[] preInsertEventListeners = {};
-	private PostDeleteEventListener[] postDeleteEventListeners = {};
-	private PostUpdateEventListener[] postUpdateEventListeners = {};
-	private PostInsertEventListener[] postInsertEventListeners = {};
-	private PostDeleteEventListener[] postCommitDeleteEventListeners = {};
-	private PostUpdateEventListener[] postCommitUpdateEventListeners = {};
-	private PostInsertEventListener[] postCommitInsertEventListeners = {};
-
-	private PreCollectionRecreateEventListener[] preCollectionRecreateEventListeners = {};
-	private PostCollectionRecreateEventListener[] postCollectionRecreateEventListeners = {};
-	private PreCollectionRemoveEventListener[] preCollectionRemoveEventListeners = {};
-	private PostCollectionRemoveEventListener[] postCollectionRemoveEventListeners = {};
-	private PreCollectionUpdateEventListener[] preCollectionUpdateEventListeners = {};
-	private PostCollectionUpdateEventListener[] postCollectionUpdateEventListeners = {};
-
-	private SaveOrUpdateEventListener[] saveEventListeners = { new DefaultSaveEventListener() };
-	private SaveOrUpdateEventListener[] updateEventListeners = { new DefaultUpdateEventListener() };
-
-	private static Map eventInterfaceFromType;
-
-	static {
-		eventInterfaceFromType = new HashMap();
-
-		eventInterfaceFromType.put("auto-flush", AutoFlushEventListener.class);
-		eventInterfaceFromType.put("merge", MergeEventListener.class);
-		eventInterfaceFromType.put("create", PersistEventListener.class);
-		eventInterfaceFromType.put("create-onflush", PersistEventListener.class);
-		eventInterfaceFromType.put("delete", DeleteEventListener.class);
-		eventInterfaceFromType.put("dirty-check", DirtyCheckEventListener.class);
-		eventInterfaceFromType.put("evict", EvictEventListener.class);
-		eventInterfaceFromType.put("flush", FlushEventListener.class);
-		eventInterfaceFromType.put("flush-entity", FlushEntityEventListener.class);
-		eventInterfaceFromType.put("load", LoadEventListener.class);
-		eventInterfaceFromType.put("load-collection", InitializeCollectionEventListener.class);
-		eventInterfaceFromType.put("lock", LockEventListener.class);
-		eventInterfaceFromType.put("refresh", RefreshEventListener.class);
-		eventInterfaceFromType.put("replicate", ReplicateEventListener.class);
-		eventInterfaceFromType.put("save-update", SaveOrUpdateEventListener.class);
-		eventInterfaceFromType.put("save", SaveOrUpdateEventListener.class);
-		eventInterfaceFromType.put("update", SaveOrUpdateEventListener.class);
-		eventInterfaceFromType.put("pre-load", PreLoadEventListener.class);
-		eventInterfaceFromType.put("pre-update", PreUpdateEventListener.class);
-		eventInterfaceFromType.put("pre-delete", PreDeleteEventListener.class);
-		eventInterfaceFromType.put("pre-insert", PreInsertEventListener.class);
-		eventInterfaceFromType.put("pre-collection-recreate", PreCollectionRecreateEventListener.class);
-		eventInterfaceFromType.put("pre-collection-remove", PreCollectionRemoveEventListener.class);
-		eventInterfaceFromType.put("pre-collection-update", PreCollectionUpdateEventListener.class);
-		eventInterfaceFromType.put("post-load", PostLoadEventListener.class);
-		eventInterfaceFromType.put("post-update", PostUpdateEventListener.class);
-		eventInterfaceFromType.put("post-delete", PostDeleteEventListener.class);
-		eventInterfaceFromType.put("post-insert", PostInsertEventListener.class);
-		eventInterfaceFromType.put("post-commit-update", PostUpdateEventListener.class);
-		eventInterfaceFromType.put("post-commit-delete", PostDeleteEventListener.class);
-		eventInterfaceFromType.put("post-commit-insert", PostInsertEventListener.class);
-		eventInterfaceFromType.put("post-collection-recreate", PostCollectionRecreateEventListener.class);
-		eventInterfaceFromType.put("post-collection-remove", PostCollectionRemoveEventListener.class);
-		eventInterfaceFromType.put("post-collection-update", PostCollectionUpdateEventListener.class);
-		eventInterfaceFromType = Collections.unmodifiableMap( eventInterfaceFromType );
-	}
-
-	public Class getListenerClassFor(String type) {
-		Class clazz = (Class) eventInterfaceFromType.get(type);
-
-		if (clazz == null) {
-			throw new MappingException("Unrecognized listener type [" + type + "]");
-		}
-
-		return clazz;
-	}
-
-	private static interface ListenerProcesser {
-		public void processListener(Object listener);
-	}
-
-	private void processListeners(ListenerProcesser processer) {
-		Field[] fields = getClass().getDeclaredFields();
-		for ( int i = 0; i < fields.length; i++ ) {
-			final Object[] listeners;
-			try {
-				Object fieldValue = fields[i].get(this);
-				if ( fieldValue instanceof Object[] ) {
-					listeners = ( Object[] ) fieldValue;
-				}
-				else {
-					continue;
-				}
-			}
-			catch ( Throwable t ) {
-				throw new HibernateException( "could not init listeners", t );
-			}
-
-			int length = listeners.length;
-			for ( int index = 0 ; index < length ; index++ ) {
-				processer.processListener( listeners[index ] );
-			}
-		}
-	}
-
-	/**
-	 * Call {@link Initializable#initialize} on any listeners that implement the
-	 * {@link Initializable} interface.
-	 *
-	 * @param cfg The configuration.
-	 */
-	public void initializeListeners(final Configuration cfg) {
-		try {
-			processListeners(
-					new ListenerProcesser() {
-						public void processListener(Object listener) {
-							if ( listener instanceof Initializable ) {
-								( ( Initializable ) listener ).initialize( cfg );
-							}
-						}
-					}
-			);
-		}
-		catch ( Exception e ) {
-			throw new HibernateException("could not init listeners", e);
-		}
-	}
-
-	/**
-	 * Call {@link Destructible#cleanup} on any listeners that implement the
-	 * {@link Destructible} interface.
-	 */
-	public void destroyListeners() {
-		try {
-			processListeners(
-					new ListenerProcesser() {
-						public void processListener(Object listener) {
-							if ( listener instanceof Destructible ) {
-								( ( Destructible ) listener ).cleanup();
-							}
-						}
-					}
-			);
-		}
-		catch ( Exception e ) {
-			throw new HibernateException("could not destruct listeners", e);
-		}
-	}
-
-	public LoadEventListener[] getLoadEventListeners() {
-        return loadEventListeners;
-    }
-
-    public void setLoadEventListeners(LoadEventListener[] loadEventListener) {
-        this.loadEventListeners = loadEventListener;
-    }
-
-	public ReplicateEventListener[] getReplicateEventListeners() {
-		return replicateEventListeners;
-	}
-
-	public void setReplicateEventListeners(ReplicateEventListener[] replicateEventListener) {
-		this.replicateEventListeners = replicateEventListener;
-	}
-
-	public DeleteEventListener[] getDeleteEventListeners() {
-		return deleteEventListeners;
-	}
-
-	public void setDeleteEventListeners(DeleteEventListener[] deleteEventListener) {
-		this.deleteEventListeners = deleteEventListener;
-	}
-
-	public AutoFlushEventListener[] getAutoFlushEventListeners() {
-		return autoFlushEventListeners;
-	}
-
-	public void setAutoFlushEventListeners(AutoFlushEventListener[] autoFlushEventListener) {
-		this.autoFlushEventListeners = autoFlushEventListener;
-	}
-
-	public DirtyCheckEventListener[] getDirtyCheckEventListeners() {
-		return dirtyCheckEventListeners;
-	}
-
-	public void setDirtyCheckEventListeners(DirtyCheckEventListener[] dirtyCheckEventListener) {
-		this.dirtyCheckEventListeners = dirtyCheckEventListener;
-	}
-
-	public FlushEventListener[] getFlushEventListeners() {
-		return flushEventListeners;
-	}
-
-	public void setFlushEventListeners(FlushEventListener[] flushEventListener) {
-		this.flushEventListeners = flushEventListener;
-	}
-
-	public EvictEventListener[] getEvictEventListeners() {
-		return evictEventListeners;
-	}
-
-	public void setEvictEventListeners(EvictEventListener[] evictEventListener) {
-		this.evictEventListeners = evictEventListener;
-	}
-
-	public LockEventListener[] getLockEventListeners() {
-		return lockEventListeners;
-	}
-
-	public void setLockEventListeners(LockEventListener[] lockEventListener) {
-		this.lockEventListeners = lockEventListener;
-	}
-
-	public RefreshEventListener[] getRefreshEventListeners() {
-		return refreshEventListeners;
-	}
-
-	public void setRefreshEventListeners(RefreshEventListener[] refreshEventListener) {
-		this.refreshEventListeners = refreshEventListener;
-	}
-
-	public InitializeCollectionEventListener[] getInitializeCollectionEventListeners() {
-		return initializeCollectionEventListeners;
-	}
-
-	public void setInitializeCollectionEventListeners(InitializeCollectionEventListener[] initializeCollectionEventListener) {
-		this.initializeCollectionEventListeners = initializeCollectionEventListener;
-	}
-
-	public FlushEntityEventListener[] getFlushEntityEventListeners() {
-		return flushEntityEventListeners;
-	}
-
-	public void setFlushEntityEventListeners(FlushEntityEventListener[] flushEntityEventListener) {
-		this.flushEntityEventListeners = flushEntityEventListener;
-	}
-
-	public SaveOrUpdateEventListener[] getSaveOrUpdateEventListeners() {
-		return saveOrUpdateEventListeners;
-	}
-
-	public void setSaveOrUpdateEventListeners(SaveOrUpdateEventListener[] saveOrUpdateEventListener) {
-		this.saveOrUpdateEventListeners = saveOrUpdateEventListener;
-	}
-
-	public MergeEventListener[] getMergeEventListeners() {
-		return mergeEventListeners;
-	}
-
-	public void setMergeEventListeners(MergeEventListener[] mergeEventListener) {
-		this.mergeEventListeners = mergeEventListener;
-	}
-
-	public PersistEventListener[] getPersistEventListeners() {
-		return persistEventListeners;
-	}
-
-	public void setPersistEventListeners(PersistEventListener[] createEventListener) {
-		this.persistEventListeners = createEventListener;
-	}
-
-	public PersistEventListener[] getPersistOnFlushEventListeners() {
-		return persistOnFlushEventListeners;
-	}
-
-	public void setPersistOnFlushEventListeners(PersistEventListener[] createEventListener) {
-		this.persistOnFlushEventListeners = createEventListener;
-	}
-
-	public SaveOrUpdateEventListener[] getSaveEventListeners() {
-		return saveEventListeners;
-	}
-
-	public void setSaveEventListeners(SaveOrUpdateEventListener[] saveEventListener) {
-		this.saveEventListeners = saveEventListener;
-	}
-
-	public SaveOrUpdateEventListener[] getUpdateEventListeners() {
-		return updateEventListeners;
-	}
-
-	public void setUpdateEventListeners(SaveOrUpdateEventListener[] updateEventListener) {
-		this.updateEventListeners = updateEventListener;
-	}
-
-	public PostLoadEventListener[] getPostLoadEventListeners() {
-		return postLoadEventListeners;
-	}
-
-	public void setPostLoadEventListeners(PostLoadEventListener[] postLoadEventListener) {
-		this.postLoadEventListeners = postLoadEventListener;
-	}
-
-	public PreLoadEventListener[] getPreLoadEventListeners() {
-		return preLoadEventListeners;
-	}
-
-	public void setPreLoadEventListeners(PreLoadEventListener[] preLoadEventListener) {
-		this.preLoadEventListeners = preLoadEventListener;
-	}
-
-	public PreCollectionRecreateEventListener[] getPreCollectionRecreateEventListeners() {
-		return preCollectionRecreateEventListeners;
-	}
-
-	public void setPreCollectionRecreateEventListeners(PreCollectionRecreateEventListener[] preCollectionRecreateEventListener) {
-		this.preCollectionRecreateEventListeners = preCollectionRecreateEventListener;
-	}
-
-	public PreCollectionRemoveEventListener[] getPreCollectionRemoveEventListeners() {
-		return preCollectionRemoveEventListeners;
-	}
-
-	public void setPreCollectionRemoveEventListeners(PreCollectionRemoveEventListener[] preCollectionRemoveEventListener) {
-		this.preCollectionRemoveEventListeners = preCollectionRemoveEventListener;
-	}
-
-	public PreCollectionUpdateEventListener[] getPreCollectionUpdateEventListeners() {
-		return preCollectionUpdateEventListeners;
-	}
-
-	public void setPreCollectionUpdateEventListeners(PreCollectionUpdateEventListener[] preCollectionUpdateEventListeners) {
-		this.preCollectionUpdateEventListeners = preCollectionUpdateEventListeners;
-	}
-
-	public PostDeleteEventListener[] getPostDeleteEventListeners() {
-		return postDeleteEventListeners;
-	}
-
-	public PostInsertEventListener[] getPostInsertEventListeners() {
-		return postInsertEventListeners;
-	}
-
-	public PostUpdateEventListener[] getPostUpdateEventListeners() {
-		return postUpdateEventListeners;
-	}
-
-	public void setPostDeleteEventListeners(PostDeleteEventListener[] postDeleteEventListener) {
-		this.postDeleteEventListeners = postDeleteEventListener;
-	}
-
-	public void setPostInsertEventListeners(PostInsertEventListener[] postInsertEventListener) {
-		this.postInsertEventListeners = postInsertEventListener;
-	}
-
-	public void setPostUpdateEventListeners(PostUpdateEventListener[] postUpdateEventListener) {
-		this.postUpdateEventListeners = postUpdateEventListener;
-	}
-
-	public PostCollectionRecreateEventListener[] getPostCollectionRecreateEventListeners() {
-		return postCollectionRecreateEventListeners;
-	}
-
-	public void setPostCollectionRecreateEventListeners(PostCollectionRecreateEventListener[] postCollectionRecreateEventListener) {
-		this.postCollectionRecreateEventListeners = postCollectionRecreateEventListener;
-	}
-
-	public PostCollectionRemoveEventListener[] getPostCollectionRemoveEventListeners() {
-		return postCollectionRemoveEventListeners;
-	}
-
-	public void setPostCollectionRemoveEventListeners(PostCollectionRemoveEventListener[] postCollectionRemoveEventListener) {
-		this.postCollectionRemoveEventListeners = postCollectionRemoveEventListener;
-	}
-
-	public PostCollectionUpdateEventListener[] getPostCollectionUpdateEventListeners() {
-		return postCollectionUpdateEventListeners;
-	}
-
-	public void setPostCollectionUpdateEventListeners(PostCollectionUpdateEventListener[] postCollectionUpdateEventListeners) {
-		this.postCollectionUpdateEventListeners = postCollectionUpdateEventListeners;
-	}
-
-	public PreDeleteEventListener[] getPreDeleteEventListeners() {
-		return preDeleteEventListeners;
-	}
-
-	public void setPreDeleteEventListeners(PreDeleteEventListener[] preDeleteEventListener) {
-		this.preDeleteEventListeners = preDeleteEventListener;
-	}
-
-	public PreInsertEventListener[] getPreInsertEventListeners() {
-		return preInsertEventListeners;
-	}
-
-	public void setPreInsertEventListeners(PreInsertEventListener[] preInsertEventListener) {
-		this.preInsertEventListeners = preInsertEventListener;
-	}
-
-	public PreUpdateEventListener[] getPreUpdateEventListeners() {
-		return preUpdateEventListeners;
-	}
-
-	public void setPreUpdateEventListeners(PreUpdateEventListener[] preUpdateEventListener) {
-		this.preUpdateEventListeners = preUpdateEventListener;
-	}
-
-	public PostDeleteEventListener[] getPostCommitDeleteEventListeners() {
-		return postCommitDeleteEventListeners;
-	}
-
-	public void setPostCommitDeleteEventListeners(
-			PostDeleteEventListener[] postCommitDeleteEventListeners) {
-		this.postCommitDeleteEventListeners = postCommitDeleteEventListeners;
-	}
-
-	public PostInsertEventListener[] getPostCommitInsertEventListeners() {
-		return postCommitInsertEventListeners;
-	}
-
-	public void setPostCommitInsertEventListeners(
-			PostInsertEventListener[] postCommitInsertEventListeners) {
-		this.postCommitInsertEventListeners = postCommitInsertEventListeners;
-	}
-
-	public PostUpdateEventListener[] getPostCommitUpdateEventListeners() {
-		return postCommitUpdateEventListeners;
-	}
-
-	public void setPostCommitUpdateEventListeners(
-			PostUpdateEventListener[] postCommitUpdateEventListeners) {
-		this.postCommitUpdateEventListeners = postCommitUpdateEventListeners;
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/Initializable.java b/hibernate-core/src/main/java/org/hibernate/event/Initializable.java
deleted file mode 100755
index 1f77bdfeda..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/event/Initializable.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.event;
-import org.hibernate.cfg.Configuration;
-
-/**
- * An event listener that requires access to mappings to initialize state at 
- * initialization time.
- *
- * @author Gavin King
- */
-public interface Initializable {
-	public void initialize(Configuration cfg);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractFlushingEventListener.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/AbstractFlushingEventListener.java
index c427a83444..28e084013e 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractFlushingEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractFlushingEventListener.java
@@ -1,387 +1,386 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.internal.Collections;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.CollectionKey;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.FlushEntityEvent;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.action.internal.CollectionRecreateAction;
 import org.hibernate.action.internal.CollectionRemoveAction;
 import org.hibernate.action.internal.CollectionUpdateAction;
 import org.hibernate.engine.spi.ActionQueue;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
-import org.hibernate.event.FlushEntityEvent;
-import org.hibernate.event.FlushEntityEventListener;
-import org.hibernate.event.FlushEvent;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.FlushEntityEventListener;
+import org.hibernate.event.spi.FlushEvent;
 import org.hibernate.internal.util.collections.IdentityMap;
 import org.hibernate.internal.util.collections.LazyIterator;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.Printer;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * A convenience base class for listeners whose functionality results in flushing.
  *
  * @author Steve Eberole
  */
 public abstract class AbstractFlushingEventListener implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractFlushingEventListener.class.getName()
 	);
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Pre-flushing section
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Coordinates the processing necessary to get things ready for executions
 	 * as db calls by preping the session caches and moving the appropriate
 	 * entities and collections to their respective execution queues.
 	 *
 	 * @param event The flush event.
 	 * @throws HibernateException Error flushing caches to execution queues.
 	 */
 	protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException {
 
         LOG.trace("Flushing session");
 
 		EventSource session = event.getSession();
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		session.getInterceptor().preFlush( new LazyIterator( persistenceContext.getEntitiesByKey() ) );
 
 		prepareEntityFlushes(session);
 		// we could move this inside if we wanted to
 		// tolerate collection initializations during
 		// collection dirty checking:
 		prepareCollectionFlushes(session);
 		// now, any collections that are initialized
 		// inside this block do not get updated - they
 		// are ignored until the next flush
 
 		persistenceContext.setFlushing(true);
 		try {
 			flushEntities(event);
 			flushCollections(session);
 		}
 		finally {
 			persistenceContext.setFlushing(false);
 		}
 
 		//some statistics
         if (LOG.isDebugEnabled()) {
             LOG.debugf(
 					"Flushed: %s insertions, %s updates, %s deletions to %s objects",
 					session.getActionQueue().numberOfInsertions(),
 					session.getActionQueue().numberOfUpdates(),
 					session.getActionQueue().numberOfDeletions(),
 					persistenceContext.getEntityEntries().size()
 			);
             LOG.debugf(
 					"Flushed: %s (re)creations, %s updates, %s removals to %s collections",
 					session.getActionQueue().numberOfCollectionCreations(),
 					session.getActionQueue().numberOfCollectionUpdates(),
 					session.getActionQueue().numberOfCollectionRemovals(),
 					persistenceContext.getCollectionEntries().size()
 			);
 			new Printer( session.getFactory() ).toString(
 					persistenceContext.getEntitiesByKey().values().iterator(),
 					session.getEntityMode()
 				);
 		}
 	}
 
 	/**
 	 * process cascade save/update at the start of a flush to discover
 	 * any newly referenced entity that must be passed to saveOrUpdate(),
 	 * and also apply orphan delete
 	 */
 	private void prepareEntityFlushes(EventSource session) throws HibernateException {
 
         LOG.debugf( "Processing flush-time cascades" );
 
 		final Map.Entry[] list = IdentityMap.concurrentEntries( session.getPersistenceContext().getEntityEntries() );
 		//safe from concurrent modification because of how entryList() is implemented on IdentityMap
 		final int size = list.length;
 		final Object anything = getAnything();
 		for ( int i=0; i<size; i++ ) {
 			Map.Entry me = list[i];
 			EntityEntry entry = (EntityEntry) me.getValue();
 			Status status = entry.getStatus();
 			if ( status == Status.MANAGED || status == Status.SAVING || status == Status.READ_ONLY ) {
 				cascadeOnFlush( session, entry.getPersister(), me.getKey(), anything );
 			}
 		}
 	}
 
 	private void cascadeOnFlush(EventSource session, EntityPersister persister, Object object, Object anything)
 	throws HibernateException {
 		session.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadingAction(), Cascade.BEFORE_FLUSH, session )
 			.cascade( persister, object, anything );
 		}
 		finally {
 			session.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	protected Object getAnything() { return null; }
 
 	protected CascadingAction getCascadingAction() {
 		return CascadingAction.SAVE_UPDATE;
 	}
 
 	/**
 	 * Initialize the flags of the CollectionEntry, including the
 	 * dirty check.
 	 */
 	private void prepareCollectionFlushes(SessionImplementor session) throws HibernateException {
 
 		// Initialize dirty flags for arrays + collections with composite elements
 		// and reset reached, doupdate, etc.
 
         LOG.debugf( "Dirty checking collections" );
 
 		final List list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		final int size = list.size();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry e = ( Map.Entry ) list.get( i );
 			( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );
 		}
 	}
 
 	/**
 	 * 1. detect any dirty entities
 	 * 2. schedule any entity updates
 	 * 3. search out any reachable collections
 	 */
 	private void flushEntities(FlushEvent event) throws HibernateException {
 
         LOG.trace("Flushing entities and processing referenced collections");
 
 		// Among other things, updateReachables() will recursively load all
 		// collections that are moving roles. This might cause entities to
 		// be loaded.
 
 		// So this needs to be safe from concurrent modification problems.
 		// It is safe because of how IdentityMap implements entrySet()
 
 		final EventSource source = event.getSession();
 
 		final Map.Entry[] list = IdentityMap.concurrentEntries( source.getPersistenceContext().getEntityEntries() );
 		final int size = list.length;
 		for ( int i = 0; i < size; i++ ) {
 
 			// Update the status of the object and if necessary, schedule an update
 
 			Map.Entry me = list[i];
 			EntityEntry entry = (EntityEntry) me.getValue();
 			Status status = entry.getStatus();
 
 			if ( status != Status.LOADING && status != Status.GONE ) {
 				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
 				final EventListenerGroup<FlushEntityEventListener> listenerGroup = source
 						.getFactory()
 						.getServiceRegistry()
 						.getService( EventListenerRegistry.class )
 						.getEventListenerGroup( EventType.FLUSH_ENTITY );
 				for ( FlushEntityEventListener listener : listenerGroup.listeners() ) {
 					listener.onFlushEntity( entityEvent );
 				}
 			}
 		}
 
 		source.getActionQueue().sortActions();
 	}
 
 	/**
 	 * process any unreferenced collections and then inspect all known collections,
 	 * scheduling creates/removes/updates
 	 */
 	private void flushCollections(EventSource session) throws HibernateException {
 
         LOG.trace("Processing unreferenced collections");
 
 		List list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		int size = list.size();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry me = ( Map.Entry ) list.get( i );
 			CollectionEntry ce = (CollectionEntry) me.getValue();
 			if ( !ce.isReached() && !ce.isIgnore() ) {
 				Collections.processUnreachableCollection( (PersistentCollection) me.getKey(), session );
 			}
 		}
 
 		// Schedule updates to collections:
 
         LOG.trace("Scheduling collection removes/(re)creates/updates");
 
 		list = IdentityMap.entries( session.getPersistenceContext().getCollectionEntries() );
 		size = list.size();
 		ActionQueue actionQueue = session.getActionQueue();
 		for ( int i = 0; i < size; i++ ) {
 			Map.Entry me = (Map.Entry) list.get(i);
 			PersistentCollection coll = (PersistentCollection) me.getKey();
 			CollectionEntry ce = (CollectionEntry) me.getValue();
 
 			if ( ce.isDorecreate() ) {
 				session.getInterceptor().onCollectionRecreate( coll, ce.getCurrentKey() );
 				actionQueue.addAction(
 						new CollectionRecreateAction(
 								coll,
 								ce.getCurrentPersister(),
 								ce.getCurrentKey(),
 								session
 							)
 					);
 			}
 			if ( ce.isDoremove() ) {
 				session.getInterceptor().onCollectionRemove( coll, ce.getLoadedKey() );
 				actionQueue.addAction(
 						new CollectionRemoveAction(
 								coll,
 								ce.getLoadedPersister(),
 								ce.getLoadedKey(),
 								ce.isSnapshotEmpty(coll),
 								session
 							)
 					);
 			}
 			if ( ce.isDoupdate() ) {
 				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
 				actionQueue.addAction(
 						new CollectionUpdateAction(
 								coll,
 								ce.getLoadedPersister(),
 								ce.getLoadedKey(),
 								ce.isSnapshotEmpty(coll),
 								session
 							)
 					);
 			}
 
 		}
 
 		actionQueue.sortCollectionActions();
 
 	}
 
 	/**
 	 * Execute all SQL and second-level cache updates, in a
 	 * special order so that foreign-key constraints cannot
 	 * be violated:
 	 * <ol>
 	 * <li> Inserts, in the order they were performed
 	 * <li> Updates
 	 * <li> Deletion of collection elements
 	 * <li> Insertion of collection elements
 	 * <li> Deletes, in the order they were performed
 	 * </ol>
 	 */
 	protected void performExecutions(EventSource session) throws HibernateException {
 
         LOG.trace("Executing flush");
 
 		try {
 			session.getTransactionCoordinator().getJdbcCoordinator().flushBeginning();
 			// we need to lock the collection caches before
 			// executing entity inserts/updates in order to
 			// account for bidi associations
 			session.getActionQueue().prepareActions();
 			session.getActionQueue().executeActions();
 		}
 		finally {
 			session.getTransactionCoordinator().getJdbcCoordinator().flushEnding();
 		}
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Post-flushing section
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * 1. Recreate the collection key -> collection map
 	 * 2. rebuild the collection entries
 	 * 3. call Interceptor.postFlush()
 	 */
 	protected void postFlush(SessionImplementor session) throws HibernateException {
 
         LOG.trace("Post flush");
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		persistenceContext.getCollectionsByKey().clear();
 		persistenceContext.getBatchFetchQueue()
 				.clearSubselects(); //the database has changed now, so the subselect results need to be invalidated
 
 		Iterator iter = persistenceContext.getCollectionEntries().entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = (Map.Entry) iter.next();
 			CollectionEntry collectionEntry = (CollectionEntry) me.getValue();
 			PersistentCollection persistentCollection = (PersistentCollection) me.getKey();
 			collectionEntry.postFlush(persistentCollection);
 			if ( collectionEntry.getLoadedPersister() == null ) {
 				//if the collection is dereferenced, remove from the session cache
 				//iter.remove(); //does not work, since the entrySet is not backed by the set
 				persistenceContext.getCollectionEntries()
 						.remove(persistentCollection);
 			}
 			else {
 				//otherwise recreate the mapping between the collection and its key
 				CollectionKey collectionKey = new CollectionKey(
 						collectionEntry.getLoadedPersister(),
 						collectionEntry.getLoadedKey(),
 						session.getEntityMode()
 					);
 				persistenceContext.getCollectionsByKey()
 						.put(collectionKey, persistentCollection);
 			}
 		}
 
 		session.getInterceptor().postFlush( new LazyIterator( persistenceContext.getEntitiesByKey() ) );
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractLockUpgradeEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractLockUpgradeEventListener.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/AbstractLockUpgradeEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/AbstractLockUpgradeEventListener.java
index 414a98513f..23b602ec2b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractLockUpgradeEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractLockUpgradeEventListener.java
@@ -1,114 +1,114 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.cache.spi.access.SoftLock;
 import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.event.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 
 /**
  * A convenience base class for listeners that respond to requests to perform a
  * pessimistic lock upgrade on an entity.
  *
  * @author Gavin King
  */
 public class AbstractLockUpgradeEventListener extends AbstractReassociateEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractLockUpgradeEventListener.class.getName());
 
 	/**
 	 * Performs a pessimistic lock upgrade on a given entity, if needed.
 	 *
 	 * @param object The entity for which to upgrade the lock.
 	 * @param entry The entity's EntityEntry instance.
 	 * @param lockOptions contains the requested lock mode.
 	 * @param source The session which is the source of the event being processed.
 	 */
 	protected void upgradeLock(Object object, EntityEntry entry, LockOptions lockOptions, EventSource source) {
 
 		LockMode requestedLockMode = lockOptions.getLockMode();
 		if ( requestedLockMode.greaterThan( entry.getLockMode() ) ) {
 			// The user requested a "greater" (i.e. more restrictive) form of
 			// pessimistic lock
 
 			if ( entry.getStatus() != Status.MANAGED ) {
 				throw new ObjectDeletedException(
 						"attempted to lock a deleted instance",
 						entry.getId(),
 						entry.getPersister().getEntityName()
 				);
 			}
 
 			final EntityPersister persister = entry.getPersister();
 
             if (LOG.isTraceEnabled()) LOG.trace("Locking "
                                                 + MessageHelper.infoString(persister, entry.getId(), source.getFactory())
                                                 + " in mode: " + requestedLockMode);
 
 			final SoftLock lock;
 			final CacheKey ck;
 			if ( persister.hasCache() ) {
 				ck = source.generateCacheKey( entry.getId(), persister.getIdentifierType(), persister.getRootEntityName() );
 				lock = persister.getCacheAccessStrategy().lockItem( ck, entry.getVersion() );
 			}
 			else {
 				ck = null;
 				lock = null;
 			}
 
 			try {
 				if ( persister.isVersioned() && requestedLockMode == LockMode.FORCE  ) {
 					// todo : should we check the current isolation mode explicitly?
 					Object nextVersion = persister.forceVersionIncrement(
 							entry.getId(), entry.getVersion(), source
 					);
 					entry.forceLocked( object, nextVersion );
 				}
 				else {
 					persister.lock( entry.getId(), entry.getVersion(), object, lockOptions, source );
 				}
 				entry.setLockMode(requestedLockMode);
 			}
 			finally {
 				// the database now holds a lock + the object is flushed from the cache,
 				// so release the soft lock
 				if ( persister.hasCache() ) {
 					persister.getCacheAccessStrategy().unlockItem( ck, lock );
 				}
 			}
 
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractReassociateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractReassociateEventListener.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/event/def/AbstractReassociateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/AbstractReassociateEventListener.java
index ecf9eecbe0..7a9da6ee25 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractReassociateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractReassociateEventListener.java
@@ -1,105 +1,105 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.AbstractEvent;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.AbstractEvent;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.TypeHelper;
 
 /**
  * A convenience base class for listeners that respond to requests to reassociate an entity
  * to a session ( such as through lock() or update() ).
  *
  * @author Gavin King
  */
 public class AbstractReassociateEventListener implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractReassociateEventListener.class.getName());
 
 	/**
 	 * Associates a given entity (either transient or associated with another session) to
 	 * the given session.
 	 *
 	 * @param event The event triggering the re-association
 	 * @param object The entity to be associated
 	 * @param id The id of the entity.
 	 * @param persister The entity's persister instance.
 	 *
 	 * @return An EntityEntry representing the entity within this session.
 	 */
 	protected final EntityEntry reassociate(AbstractEvent event, Object object, Serializable id, EntityPersister persister) {
 
         if (LOG.isTraceEnabled()) LOG.trace("Reassociating transient instance: "
                                             + MessageHelper.infoString(persister, id, event.getSession().getFactory()));
 
 		final EventSource source = event.getSession();
 		final EntityKey key = source.generateEntityKey( id, persister );
 
 		source.getPersistenceContext().checkUniqueness( key, object );
 
 		//get a snapshot
 		Object[] values = persister.getPropertyValues( object, source.getEntityMode() );
 		TypeHelper.deepCopy(
 				values,
 				persister.getPropertyTypes(),
 				persister.getPropertyUpdateability(),
 				values,
 				source
 		);
 		Object version = Versioning.getVersion( values, persister );
 
 		EntityEntry newEntry = source.getPersistenceContext().addEntity(
 				object,
 				( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 				values,
 				key,
 				version,
 				LockMode.NONE,
 				true,
 				persister,
 				false,
 				true //will be ignored, using the existing Entry instead
 		);
 
 		new OnLockVisitor( source, id, object ).process( object, persister );
 
 		persister.afterReassociate( object, source );
 
 		return newEntry;
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractSaveEventListener.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/AbstractSaveEventListener.java
index 9a76461e68..25bfd2d5e4 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractSaveEventListener.java
@@ -1,517 +1,517 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
-import org.hibernate.engine.internal.Cascade;
-import org.hibernate.engine.internal.ForeignKeys;
-import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.engine.spi.EntityKey;
-import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.engine.spi.Status;
-import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.action.internal.EntityIdentityInsertAction;
 import org.hibernate.action.internal.EntityInsertAction;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.classic.Lifecycle;
-import org.hibernate.engine.spi.CascadingAction;
+import org.hibernate.engine.internal.Cascade;
+import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.internal.Nullability;
 import org.hibernate.engine.internal.Versioning;
-import org.hibernate.event.EventSource;
+import org.hibernate.engine.spi.CascadingAction;
+import org.hibernate.engine.spi.EntityEntry;
+import org.hibernate.engine.spi.EntityKey;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.id.IdentifierGenerationException;
 import org.hibernate.id.IdentifierGeneratorHelper;
+import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * A convenience bas class for listeners responding to save events.
  *
  * @author Steve Ebersole.
  */
 public abstract class AbstractSaveEventListener extends AbstractReassociateEventListener {
 
 	protected static final int PERSISTENT = 0;
 	protected static final int TRANSIENT = 1;
 	protected static final int DETACHED = 2;
 	protected static final int DELETED = 3;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractSaveEventListener.class.getName());
 
 	/**
 	 * Prepares the save call using the given requested id.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param requestedId The id to which to associate the entity.
 	 * @param entityName The name of the entity being saved.
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 *
 	 * @return The id used to save the entity.
 	 */
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		return performSave(
 				entity,
 				requestedId,
 				source.getEntityPersister( entityName, entity ),
 				false,
 				anything,
 				source,
 				true
 		);
 	}
 
 	/**
 	 * Prepares the save call using a newly generated id.
 	 *
 	 * @param entity The entity to be saved
 	 * @param entityName The entity-name for the entity to be saved
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		EntityPersister persister = source.getEntityPersister( entityName, entity );
 		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
 		if ( generatedId == null ) {
 			throw new IdentifierGenerationException( "null id generated for:" + entity.getClass() );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.SHORT_CIRCUIT_INDICATOR ) {
 			return source.getIdentifier( entity );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.POST_INSERT_INDICATOR ) {
 			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
 		}
 		else {
             // TODO: define toString()s for generators
             if (LOG.isDebugEnabled()) LOG.debugf("Generated identifier: %s, using strategy: %s",
                                                  persister.getIdentifierType().toLoggableString(generatedId, source.getFactory()),
                                                  persister.getIdentifierGenerator().getClass().getName());
 
 			return performSave( entity, generatedId, persister, false, anything, source, true );
 		}
 	}
 
 	/**
 	 * Ppepares the save call by checking the session caches for a pre-existing
 	 * entity and performing any lifecycle callbacks.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param id The id by which to save the entity.
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Is an identity column being used?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session from which the event originated.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSave(
 			Object entity,
 			Serializable id,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
         if ( LOG.isTraceEnabled() ) {
 			LOG.trace("Saving " + MessageHelper.infoString(persister, id, source.getFactory()));
 		}
 
 		final EntityKey key;
 		if ( !useIdentityColumn ) {
 			key = source.generateEntityKey( id, persister );
 			Object old = source.getPersistenceContext().getEntity( key );
 			if ( old != null ) {
 				if ( source.getPersistenceContext().getEntry( old ).getStatus() == Status.DELETED ) {
 					source.forceFlush( source.getPersistenceContext().getEntry( old ) );
 				}
 				else {
 					throw new NonUniqueObjectException( id, persister.getEntityName() );
 				}
 			}
 			persister.setIdentifier( entity, id, source );
 		}
 		else {
 			key = null;
 		}
 
 		if ( invokeSaveLifecycle( entity, persister, source ) ) {
 			return id; //EARLY EXIT
 		}
 
 		return performSaveOrReplicate(
 				entity,
 				key,
 				persister,
 				useIdentityColumn,
 				anything,
 				source,
 				requiresImmediateIdAccess
 		);
 	}
 
 	protected boolean invokeSaveLifecycle(Object entity, EntityPersister persister, EventSource source) {
 		// Sub-insertions should occur before containing insertion so
 		// Try to do the callback now
 		if ( persister.implementsLifecycle( source.getEntityMode() ) ) {
             LOG.debugf("Calling onSave()");
 			if ( ( ( Lifecycle ) entity ).onSave( source ) ) {
                 LOG.debugf("Insertion vetoed by onSave()");
 				return true;
 			}
 		}
 		return false;
 	}
 
 	/**
 	 * Performs all the actual work needed to save an entity (well to get the save moved to
 	 * the execution queue).
 	 *
 	 * @param entity The entity to be saved
 	 * @param key The id to be used for saving the entity (or null, in the case of identity columns)
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Should an identity column be used for id generation?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of the current event.
 	 * @param requiresImmediateIdAccess Is access to the identifier required immediately
 	 * after the completion of the save?  persist(), for example, does not require this...
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSaveOrReplicate(
 			Object entity,
 			EntityKey key,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
 		Serializable id = key == null ? null : key.getIdentifier();
 
 		boolean inTxn = source.getTransactionCoordinator().isTransactionInProgress();
 		boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;
 
 		// Put a placeholder in entries, so we don't recurse back and try to save() the
 		// same object again. QUESTION: should this be done before onSave() is called?
 		// likewise, should it be done before onUpdate()?
 		source.getPersistenceContext().addEntry(
 				entity,
 				Status.SAVING,
 				null,
 				null,
 				id,
 				null,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				false,
 				false
 		);
 
 		cascadeBeforeSave( source, persister, entity, anything );
 
 		if ( useIdentityColumn && !shouldDelayIdentityInserts ) {
             LOG.trace("Executing insertions");
 			source.getActionQueue().executeInserts();
 		}
 
 		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
 		Type[] types = persister.getPropertyTypes();
 
 		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
 
 		if ( persister.hasCollections() ) {
 			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
 		}
 
 		if ( substitute ) {
 			persister.setPropertyValues( entity, values, source.getEntityMode() );
 		}
 
 		TypeHelper.deepCopy(
 				values,
 				types,
 				persister.getPropertyUpdateability(),
 				values,
 				source
 		);
 
 		new ForeignKeys.Nullifier( entity, false, useIdentityColumn, source )
 				.nullifyTransientReferences( values, types );
 		new Nullability( source ).checkNullability( values, persister, false );
 
 		if ( useIdentityColumn ) {
 			EntityIdentityInsertAction insert = new EntityIdentityInsertAction(
 					values, entity, persister, source, shouldDelayIdentityInserts
 			);
 			if ( !shouldDelayIdentityInserts ) {
                 LOG.debugf("Executing identity-insert immediately");
 				source.getActionQueue().execute( insert );
 				id = insert.getGeneratedId();
 				key = source.generateEntityKey( id, persister );
 				source.getPersistenceContext().checkUniqueness( key, entity );
 			}
 			else {
                 LOG.debugf("Delaying identity-insert due to no transaction in progress");
 				source.getActionQueue().addAction( insert );
 				key = insert.getDelayedEntityKey();
 			}
 		}
 
 		Object version = Versioning.getVersion( values, persister );
 		source.getPersistenceContext().addEntity(
 				entity,
 				( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 				values,
 				key,
 				version,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				isVersionIncrementDisabled(),
 				false
 		);
 		//source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );
 
 		if ( !useIdentityColumn ) {
 			source.getActionQueue().addAction(
 					new EntityInsertAction( id, values, entity, version, persister, source )
 			);
 		}
 
 		cascadeAfterSave( source, persister, entity, anything );
 
 		markInterceptorDirty( entity, persister, source );
 
 		return id;
 	}
 
 	private void markInterceptorDirty(Object entity, EntityPersister persister, EventSource source) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.injectFieldInterceptor(
 					entity,
 					persister.getEntityName(),
 					null,
 					source
 			);
 			interceptor.dirty();
 		}
 	}
 
 	protected Map getMergeMap(Object anything) {
 		return null;
 	}
 
 	/**
 	 * After the save, will te version number be incremented
 	 * if the instance is modified?
 	 *
 	 * @return True if the version will be incremented on an entity change after save;
 	 *         false otherwise.
 	 */
 	protected boolean isVersionIncrementDisabled() {
 		return false;
 	}
 
 	protected boolean visitCollectionsBeforeSave(Object entity, Serializable id, Object[] values, Type[] types, EventSource source) {
 		WrapVisitor visitor = new WrapVisitor( source );
 		// substitutes into values by side-effect
 		visitor.processEntityPropertyValues( values, types );
 		return visitor.isSubstitutionRequired();
 	}
 
 	/**
 	 * Perform any property value substitution that is necessary
 	 * (interceptor callback, version initialization...)
 	 *
 	 * @param entity The entity
 	 * @param id The entity identifier
 	 * @param values The snapshot entity state
 	 * @param persister The entity persister
 	 * @param source The originating session
 	 *
 	 * @return True if the snapshot state changed such that
 	 * reinjection of the values into the entity is required.
 	 */
 	protected boolean substituteValuesIfNecessary(
 			Object entity,
 			Serializable id,
 			Object[] values,
 			EntityPersister persister,
 			SessionImplementor source) {
 		boolean substitute = source.getInterceptor().onSave(
 				entity,
 				id,
 				values,
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 		);
 
 		//keep the existing version number in the case of replicate!
 		if ( persister.isVersioned() ) {
 			substitute = Versioning.seedVersion(
 					values,
 					persister.getVersionProperty(),
 					persister.getVersionType(),
 					source
 			) || substitute;
 		}
 		return substitute;
 	}
 
 	/**
 	 * Handles the calls needed to perform pre-save cascades for the given entity.
 	 *
 	 * @param source The session from whcih the save event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity to be saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeBeforeSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to many-to-one BEFORE the parent is saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.BEFORE_INSERT_AFTER_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	/**
 	 * Handles to calls needed to perform post-save cascades.
 	 *
 	 * @param source The session from which the event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity beng saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeAfterSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to collections AFTER the collection owner was saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.AFTER_INSERT_BEFORE_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	protected abstract CascadingAction getCascadeAction();
 
 	/**
 	 * Determine whether the entity is persistent, detached, or transient
 	 *
 	 * @param entity The entity to check
 	 * @param entityName The name of the entity
 	 * @param entry The entity's entry in the persistence context
 	 * @param source The originating session.
 	 *
 	 * @return The state.
 	 */
 	protected int getEntityState(
 			Object entity,
 			String entityName,
 			EntityEntry entry, //pass this as an argument only to avoid double looking
 			SessionImplementor source) {
 
 		if ( entry != null ) { // the object is persistent
 
 			//the entity is associated with the session, so check its status
 			if ( entry.getStatus() != Status.DELETED ) {
 				// do nothing for persistent instances
                 if (LOG.isTraceEnabled()) LOG.trace("Persistent instance of: " + getLoggableName(entityName, entity));
 				return PERSISTENT;
 			}
             // ie. e.status==DELETED
             if (LOG.isTraceEnabled()) LOG.trace("Deleted instance of: " + getLoggableName(entityName, entity));
             return DELETED;
 
 		}
         // the object is transient or detached
 
 		// the entity is not associated with the session, so
         // try interceptor and unsaved-value
 
 		if ( ForeignKeys.isTransient( entityName, entity, getAssumedUnsaved(), source )) {
             if (LOG.isTraceEnabled()) LOG.trace("Transient instance of: " + getLoggableName(entityName, entity));
             return TRANSIENT;
 		}
         if (LOG.isTraceEnabled()) LOG.trace("Detached instance of: " + getLoggableName(entityName, entity));
         return DETACHED;
 	}
 
 	protected String getLoggableName(String entityName, Object entity) {
 		return entityName == null ? entity.getClass().getName() : entityName;
 	}
 
 	protected Boolean getAssumedUnsaved() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractVisitor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/AbstractVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/AbstractVisitor.java
index 815471fbe6..5c1ce9d7c2 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/AbstractVisitor.java
@@ -1,177 +1,177 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.HibernateException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
-
 /**
  * Abstract superclass of algorithms that walk
  * a tree of property values of an entity, and
  * perform specific functionality for collections,
  * components and associated entities.
  *
  * @author Gavin King
  */
 public abstract class AbstractVisitor {
 
 	private final EventSource session;
 
 	AbstractVisitor(EventSource session) {
 		this.session = session;
 	}
 
 	/**
 	 * Dispatch each property value to processValue().
 	 *
 	 * @param values
 	 * @param types
 	 * @throws HibernateException
 	 */
 	void processValues(Object[] values, Type[] types) throws HibernateException {
 		for ( int i=0; i<types.length; i++ ) {
 			if ( includeProperty(values, i) ) {
 				processValue( i, values, types );
 			}
 		}
 	}
 	
 	/**
 	 * Dispatch each property value to processValue().
 	 *
 	 * @param values
 	 * @param types
 	 * @throws HibernateException
 	 */
 	public void processEntityPropertyValues(Object[] values, Type[] types) throws HibernateException {
 		for ( int i=0; i<types.length; i++ ) {
 			if ( includeEntityProperty(values, i) ) {
 				processValue( i, values, types );
 			}
 		}
 	}
 	
 	void processValue(int i, Object[] values, Type[] types) {
 		processValue( values[i], types[i] );
 	}
 	
 	boolean includeEntityProperty(Object[] values, int i) {
 		return includeProperty(values, i);
 	}
 	
 	boolean includeProperty(Object[] values, int i) {
 		return values[i]!= LazyPropertyInitializer.UNFETCHED_PROPERTY;
 	}
 
 	/**
 	 * Visit a component. Dispatch each property
 	 * to processValue().
 	 * @param component
 	 * @param componentType
 	 * @throws HibernateException
 	 */
 	Object processComponent(Object component, CompositeType componentType) throws HibernateException {
 		if (component!=null) {
 			processValues(
 				componentType.getPropertyValues(component, session),
 				componentType.getSubtypes()
 			);
 		}
 		return null;
 	}
 
 	/**
 	 * Visit a property value. Dispatch to the
 	 * correct handler for the property type.
 	 * @param value
 	 * @param type
 	 * @throws HibernateException
 	 */
 	final Object processValue(Object value, Type type) throws HibernateException {
 
 		if ( type.isCollectionType() ) {
 			//even process null collections
 			return processCollection( value, (CollectionType) type );
 		}
 		else if ( type.isEntityType() ) {
 			return processEntity( value, (EntityType) type );
 		}
 		else if ( type.isComponentType() ) {
 			return processComponent( value, (CompositeType) type );
 		}
 		else {
 			return null;
 		}
 	}
 
 	/**
 	 * Walk the tree starting from the given entity.
 	 *
 	 * @param object
 	 * @param persister
 	 * @throws HibernateException
 	 */
 	void process(Object object, EntityPersister persister)
 	throws HibernateException {
 		processEntityPropertyValues(
 			persister.getPropertyValues( object, getSession().getEntityMode() ),
 			persister.getPropertyTypes()
 		);
 	}
 
 	/**
 	 * Visit a collection. Default superclass
 	 * implementation is a no-op.
 	 * @param collection
 	 * @param type
 	 * @throws HibernateException
 	 */
 	Object processCollection(Object collection, CollectionType type)
 	throws HibernateException {
 		return null;
 	}
 
 	/**
 	 * Visit a many-to-one or one-to-one associated
 	 * entity. Default superclass implementation is
 	 * a no-op.
 	 * @param value
 	 * @param entityType
 	 * @throws HibernateException
 	 */
 	Object processEntity(Object value, EntityType entityType)
 	throws HibernateException {
 		return null;
 	}
 
 	final EventSource getSession() {
 		return session;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultAutoFlushEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultAutoFlushEventListener.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultAutoFlushEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultAutoFlushEventListener.java
index 358a595f9a..931bc8eb40 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultAutoFlushEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultAutoFlushEventListener.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
+import org.hibernate.event.spi.AutoFlushEvent;
+import org.hibernate.event.spi.AutoFlushEventListener;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.event.AutoFlushEvent;
-import org.hibernate.event.AutoFlushEventListener;
-import org.hibernate.event.EventSource;
-
-import org.jboss.logging.Logger;
 
 /**
  * Defines the default flush event listeners used by hibernate for
  * flushing session state in response to generated auto-flush events.
  *
  * @author Steve Ebersole
  */
 public class DefaultAutoFlushEventListener extends AbstractFlushingEventListener implements AutoFlushEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultAutoFlushEventListener.class.getName());
 
     /** Handle the given auto-flush event.
      *
      * @param event The auto-flush event to be handled.
      * @throws HibernateException
      */
 	public void onAutoFlush(AutoFlushEvent event) throws HibernateException {
 		final EventSource source = event.getSession();
 		if ( flushMightBeNeeded(source) ) {
 			final int oldSize = source.getActionQueue().numberOfCollectionRemovals();
 			flushEverythingToExecutions(event);
 			if ( flushIsReallyNeeded(event, source) ) {
                 LOG.trace("Need to execute flush");
 
 				performExecutions(source);
 				postFlush(source);
 				// note: performExecutions() clears all collectionXxxxtion
 				// collections (the collection actions) in the session
 
                 if (source.getFactory().getStatistics().isStatisticsEnabled()) source.getFactory().getStatisticsImplementor().flush();
 			}
 			else {
                 LOG.trace("Don't need to execute flush");
 				source.getActionQueue().clearFromFlushNeededCheck( oldSize );
 			}
 
 			event.setFlushRequired( flushIsReallyNeeded( event, source ) );
 		}
 	}
 
 	private boolean flushIsReallyNeeded(AutoFlushEvent event, final EventSource source) {
 		return source.getActionQueue()
 				.areTablesToBeUpdated( event.getQuerySpaces() ) ||
 						source.getFlushMode()==FlushMode.ALWAYS;
 	}
 
 	private boolean flushMightBeNeeded(final EventSource source) {
 		return !source.getFlushMode().lessThan(FlushMode.AUTO) &&
 				source.getDontFlushFromFind() == 0 &&
 				( source.getPersistenceContext().getEntityEntries().size() > 0 ||
 						source.getPersistenceContext().getCollectionEntries().size() > 0 );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDeleteEventListener.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDeleteEventListener.java
index 5552843047..8cbf2a4d1a 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDeleteEventListener.java
@@ -1,351 +1,351 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.CacheMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.internal.Nullability;
 import org.hibernate.engine.spi.EntityEntry;
+import org.hibernate.event.spi.DeleteEvent;
+import org.hibernate.event.spi.DeleteEventListener;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.TransientObjectException;
 import org.hibernate.action.internal.EntityDeleteAction;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.DeleteEvent;
-import org.hibernate.event.DeleteEventListener;
-import org.hibernate.event.EventSource;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * Defines the default delete event listener used by hibernate for deleting entities
  * from the datastore in response to generated delete events.
  *
  * @author Steve Ebersole
  */
 public class DefaultDeleteEventListener implements DeleteEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultDeleteEventListener.class.getName());
 
 	/**
 	 * Handle the given delete event.
 	 *
 	 * @param event The delete event to be handled.
 	 *
 	 * @throws HibernateException
 	 */
 	public void onDelete(DeleteEvent event) throws HibernateException {
 		onDelete( event, new IdentitySet() );
 	}
 
 	/**
 	 * Handle the given delete event.  This is the cascaded form.
 	 *
 	 * @param event The delete event.
 	 * @param transientEntities The cache of entities already deleted
 	 *
 	 * @throws HibernateException
 	 */
 	public void onDelete(DeleteEvent event, Set transientEntities) throws HibernateException {
 
 		final EventSource source = event.getSession();
 
 		final PersistenceContext persistenceContext = source.getPersistenceContext();
 		Object entity = persistenceContext.unproxyAndReassociate( event.getObject() );
 
 		EntityEntry entityEntry = persistenceContext.getEntry( entity );
 		final EntityPersister persister;
 		final Serializable id;
 		final Object version;
 
 		if ( entityEntry == null ) {
             LOG.trace("Entity was not persistent in delete processing");
 
 			persister = source.getEntityPersister( event.getEntityName(), entity );
 
 			if ( ForeignKeys.isTransient( persister.getEntityName(), entity, null, source ) ) {
 				deleteTransientEntity( source, entity, event.isCascadeDeleteEnabled(), persister, transientEntities );
 				// EARLY EXIT!!!
 				return;
 			}
             performDetachedEntityDeletionCheck(event);
 
 			id = persister.getIdentifier( entity, source );
 
 			if ( id == null ) {
 				throw new TransientObjectException(
 						"the detached instance passed to delete() had a null identifier"
 				);
 			}
 
 			final EntityKey key = source.generateEntityKey( id, persister );
 
 			persistenceContext.checkUniqueness( key, entity );
 
 			new OnUpdateVisitor( source, id, entity ).process( entity, persister );
 
 			version = persister.getVersion( entity, source.getEntityMode() );
 
 			entityEntry = persistenceContext.addEntity(
 					entity,
 					( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 					persister.getPropertyValues( entity, source.getEntityMode() ),
 					key,
 					version,
 					LockMode.NONE,
 					true,
 					persister,
 					false,
 					false
 			);
 		}
 		else {
             LOG.trace("Deleting a persistent instance");
 
 			if ( entityEntry.getStatus() == Status.DELETED || entityEntry.getStatus() == Status.GONE ) {
                 LOG.trace("Object was already deleted");
 				return;
 			}
 			persister = entityEntry.getPersister();
 			id = entityEntry.getId();
 			version = entityEntry.getVersion();
 		}
 
 		/*if ( !persister.isMutable() ) {
 			throw new HibernateException(
 					"attempted to delete an object of immutable class: " +
 					MessageHelper.infoString(persister)
 				);
 		}*/
 
 		if ( invokeDeleteLifecycle( source, entity, persister ) ) {
 			return;
 		}
 
 		deleteEntity( source, entity, entityEntry, event.isCascadeDeleteEnabled(), persister, transientEntities );
 
 		if ( source.getFactory().getSettings().isIdentifierRollbackEnabled() ) {
 			persister.resetIdentifier( entity, id, version, source );
 		}
 	}
 
 	/**
 	 * Called when we have recognized an attempt to delete a detached entity.
 	 * <p/>
 	 * This is perfectly valid in Hibernate usage; JPA, however, forbids this.
 	 * Thus, this is a hook for HEM to affect this behavior.
 	 *
 	 * @param event The event.
 	 */
 	protected void performDetachedEntityDeletionCheck(DeleteEvent event) {
 		// ok in normal Hibernate usage to delete a detached entity; JPA however
 		// forbids it, thus this is a hook for HEM to affect this behavior
 	}
 
 	/**
 	 * We encountered a delete request on a transient instance.
 	 * <p/>
 	 * This is a deviation from historical Hibernate (pre-3.2) behavior to
 	 * align with the JPA spec, which states that transient entities can be
 	 * passed to remove operation in which case cascades still need to be
 	 * performed.
 	 *
 	 * @param session The session which is the source of the event
 	 * @param entity The entity being delete processed
 	 * @param cascadeDeleteEnabled Is cascading of deletes enabled
 	 * @param persister The entity persister
 	 * @param transientEntities A cache of already visited transient entities
 	 * (to avoid infinite recursion).
 	 */
 	protected void deleteTransientEntity(
 			EventSource session,
 			Object entity,
 			boolean cascadeDeleteEnabled,
 			EntityPersister persister,
 			Set transientEntities) {
         LOG.handlingTransientEntity();
 		if ( transientEntities.contains( entity ) ) {
             LOG.trace("Already handled transient entity; skipping");
 			return;
 		}
 		transientEntities.add( entity );
 		cascadeBeforeDelete( session, persister, entity, null, transientEntities );
 		cascadeAfterDelete( session, persister, entity, transientEntities );
 	}
 
 	/**
 	 * Perform the entity deletion.  Well, as with most operations, does not
 	 * really perform it; just schedules an action/execution with the
 	 * {@link org.hibernate.engine.spi.ActionQueue} for execution during flush.
 	 *
 	 * @param session The originating session
 	 * @param entity The entity to delete
 	 * @param entityEntry The entity's entry in the {@link PersistenceContext}
 	 * @param isCascadeDeleteEnabled Is delete cascading enabled?
 	 * @param persister The entity persister.
 	 * @param transientEntities A cache of already deleted entities.
 	 */
 	protected final void deleteEntity(
 			final EventSource session,
 			final Object entity,
 			final EntityEntry entityEntry,
 			final boolean isCascadeDeleteEnabled,
 			final EntityPersister persister,
 			final Set transientEntities) {
 
         if (LOG.isTraceEnabled()) LOG.trace("Deleting "
                                             + MessageHelper.infoString(persister, entityEntry.getId(), session.getFactory()));
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		final Type[] propTypes = persister.getPropertyTypes();
 		final Object version = entityEntry.getVersion();
 
 		final Object[] currentState;
 		if ( entityEntry.getLoadedState() == null ) { //ie. the entity came in from update()
 			currentState = persister.getPropertyValues( entity, session.getEntityMode() );
 		}
 		else {
 			currentState = entityEntry.getLoadedState();
 		}
 
 		final Object[] deletedState = createDeletedState( persister, currentState, session );
 		entityEntry.setDeletedState( deletedState );
 
 		session.getInterceptor().onDelete(
 				entity,
 				entityEntry.getId(),
 				deletedState,
 				persister.getPropertyNames(),
 				propTypes
 		);
 
 		// before any callbacks, etc, so subdeletions see that this deletion happened first
 		persistenceContext.setEntryStatus( entityEntry, Status.DELETED );
 		final EntityKey key = session.generateEntityKey( entityEntry.getId(), persister );
 
 		cascadeBeforeDelete( session, persister, entity, entityEntry, transientEntities );
 
 		new ForeignKeys.Nullifier( entity, true, false, session )
 				.nullifyTransientReferences( entityEntry.getDeletedState(), propTypes );
 		new Nullability( session ).checkNullability( entityEntry.getDeletedState(), persister, true );
 		persistenceContext.getNullifiableEntityKeys().add( key );
 
 		// Ensures that containing deletions happen before sub-deletions
 		session.getActionQueue().addAction(
 				new EntityDeleteAction(
 						entityEntry.getId(),
 						deletedState,
 						version,
 						entity,
 						persister,
 						isCascadeDeleteEnabled,
 						session
 				)
 		);
 
 		cascadeAfterDelete( session, persister, entity, transientEntities );
 
 		// the entry will be removed after the flush, and will no longer
 		// override the stale snapshot
 		// This is now handled by removeEntity() in EntityDeleteAction
 		//persistenceContext.removeDatabaseSnapshot(key);
 	}
 
 	private Object[] createDeletedState(EntityPersister persister, Object[] currentState, EventSource session) {
 		Type[] propTypes = persister.getPropertyTypes();
 		final Object[] deletedState = new Object[propTypes.length];
 //		TypeFactory.deepCopy( currentState, propTypes, persister.getPropertyUpdateability(), deletedState, session );
 		boolean[] copyability = new boolean[propTypes.length];
 		java.util.Arrays.fill( copyability, true );
 		TypeHelper.deepCopy( currentState, propTypes, copyability, deletedState, session );
 		return deletedState;
 	}
 
 	protected boolean invokeDeleteLifecycle(EventSource session, Object entity, EntityPersister persister) {
 		if ( persister.implementsLifecycle( session.getEntityMode() ) ) {
             LOG.debugf("Calling onDelete()");
 			if ( ( ( Lifecycle ) entity ).onDelete( session ) ) {
                 LOG.debugf("Deletion vetoed by onDelete()");
 				return true;
 			}
 		}
 		return false;
 	}
 
 	protected void cascadeBeforeDelete(
 			EventSource session,
 			EntityPersister persister,
 			Object entity,
 			EntityEntry entityEntry,
 			Set transientEntities) throws HibernateException {
 
 		CacheMode cacheMode = session.getCacheMode();
 		session.setCacheMode( CacheMode.GET );
 		session.getPersistenceContext().incrementCascadeLevel();
 		try {
 			// cascade-delete to collections BEFORE the collection owner is deleted
 			new Cascade( CascadingAction.DELETE, Cascade.AFTER_INSERT_BEFORE_DELETE, session )
 					.cascade( persister, entity, transientEntities );
 		}
 		finally {
 			session.getPersistenceContext().decrementCascadeLevel();
 			session.setCacheMode( cacheMode );
 		}
 	}
 
 	protected void cascadeAfterDelete(
 			EventSource session,
 			EntityPersister persister,
 			Object entity,
 			Set transientEntities) throws HibernateException {
 
 		CacheMode cacheMode = session.getCacheMode();
 		session.setCacheMode( CacheMode.GET );
 		session.getPersistenceContext().incrementCascadeLevel();
 		try {
 			// cascade-delete to many-to-one AFTER the parent was deleted
 			new Cascade( CascadingAction.DELETE, Cascade.BEFORE_INSERT_AFTER_DELETE, session )
 					.cascade( persister, entity, transientEntities );
 		}
 		finally {
 			session.getPersistenceContext().decrementCascadeLevel();
 			session.setCacheMode( cacheMode );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultDirtyCheckEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDirtyCheckEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultDirtyCheckEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDirtyCheckEventListener.java
index 2de4ffec8b..5b884f1ac3 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultDirtyCheckEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultDirtyCheckEventListener.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
-import org.hibernate.HibernateException;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.event.DirtyCheckEvent;
-import org.hibernate.event.DirtyCheckEventListener;
+package org.hibernate.event.internal;
 
 import org.jboss.logging.Logger;
 
+import org.hibernate.HibernateException;
+import org.hibernate.event.spi.DirtyCheckEvent;
+import org.hibernate.event.spi.DirtyCheckEventListener;
+import org.hibernate.internal.CoreMessageLogger;
+
 /**
  * Defines the default dirty-check event listener used by hibernate for
  * checking the session for dirtiness in response to generated dirty-check
  * events.
  *
  * @author Steve Ebersole
  */
 public class DefaultDirtyCheckEventListener extends AbstractFlushingEventListener implements DirtyCheckEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultDirtyCheckEventListener.class.getName());
 
     /** Handle the given dirty-check event.
      *
      * @param event The dirty-check event to be handled.
      * @throws HibernateException
      */
 	public void onDirtyCheck(DirtyCheckEvent event) throws HibernateException {
 
 		int oldSize = event.getSession().getActionQueue().numberOfCollectionRemovals();
 
 		try {
 			flushEverythingToExecutions(event);
 			boolean wasNeeded = event.getSession().getActionQueue().hasAnyQueuedActions();
             if (wasNeeded) LOG.debugf("Session dirty");
             else LOG.debugf("Session not dirty");
 			event.setDirty( wasNeeded );
 		}
 		finally {
 			event.getSession().getActionQueue().clearFromFlushNeededCheck( oldSize );
 		}
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultEvictEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultEvictEventListener.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultEvictEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultEvictEventListener.java
index 8f3305a627..6d53c5da18 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultEvictEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultEvictEventListener.java
@@ -1,120 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.Cascade;
+import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EvictEvent;
+import org.hibernate.event.spi.EvictEventListener;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.engine.spi.CascadingAction;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EvictEvent;
-import org.hibernate.event.EvictEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 
-import org.jboss.logging.Logger;
-
 /**
  * Defines the default evict event listener used by hibernate for evicting entities
  * in response to generated flush events.  In particular, this implementation will
  * remove any hard references to the entity that are held by the infrastructure
  * (references held by application or other persistent instances are okay)
  *
  * @author Steve Ebersole
  */
 public class DefaultEvictEventListener implements EvictEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultEvictEventListener.class.getName());
 
 	/**
 	 * Handle the given evict event.
 	 *
 	 * @param event The evict event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onEvict(EvictEvent event) throws HibernateException {
 		EventSource source = event.getSession();
 		final Object object = event.getObject();
 		final PersistenceContext persistenceContext = source.getPersistenceContext();
 
 		if ( object instanceof HibernateProxy ) {
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			Serializable id = li.getIdentifier();
 			EntityPersister persister = source.getFactory().getEntityPersister( li.getEntityName() );
 			if ( id == null ) {
 				throw new IllegalArgumentException("null identifier");
 			}
 
 			final EntityKey key = source.generateEntityKey( id, persister );
 			persistenceContext.removeProxy( key );
 
 			if ( !li.isUninitialized() ) {
 				final Object entity = persistenceContext.removeEntity( key );
 				if ( entity != null ) {
 					EntityEntry e = event.getSession().getPersistenceContext().removeEntry( entity );
 					doEvict( entity, key, e.getPersister(), event.getSession() );
 				}
 			}
 			li.unsetSession();
 		}
 		else {
 			EntityEntry e = persistenceContext.removeEntry( object );
 			if ( e != null ) {
 				persistenceContext.removeEntity( e.getEntityKey() );
 				doEvict( object, e.getEntityKey(), e.getPersister(), source );
 			}
 		}
 	}
 
 	protected void doEvict(
 		final Object object,
 		final EntityKey key,
 		final EntityPersister persister,
 		final EventSource session)
 	throws HibernateException {
 
         if (LOG.isTraceEnabled()) LOG.trace("Evicting " + MessageHelper.infoString(persister));
 
 		// remove all collections for the entity from the session-level cache
 		if ( persister.hasCollections() ) {
 			new EvictVisitor( session ).process( object, persister );
 		}
 
 		// remove any snapshot, not really for memory management purposes, but
 		// rather because it might now be stale, and there is no longer any
 		// EntityEntry to take precedence
 		// This is now handled by removeEntity()
 		//session.getPersistenceContext().removeDatabaseSnapshot(key);
 
 		new Cascade( CascadingAction.EVICT, Cascade.AFTER_EVICT, session )
 				.cascade( persister, object );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEntityEventListener.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEntityEventListener.java
index 06719a567a..d2e00a12da 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEntityEventListener.java
@@ -1,564 +1,564 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
-import org.hibernate.engine.internal.Versioning;
-import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.engine.spi.Status;
-import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.action.internal.DelayedPostInsertIdentifier;
 import org.hibernate.action.internal.EntityUpdateAction;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
-import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.internal.Nullability;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.FlushEntityEvent;
-import org.hibernate.event.FlushEntityEventListener;
+import org.hibernate.engine.internal.Versioning;
+import org.hibernate.engine.spi.EntityEntry;
+import org.hibernate.engine.spi.EntityKey;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.FlushEntityEvent;
+import org.hibernate.event.spi.FlushEntityEventListener;
+import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 
 /**
  * An event that occurs for each entity instance at flush time
  *
  * @author Gavin King
  */
 public class DefaultFlushEntityEventListener implements FlushEntityEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultFlushEntityEventListener.class.getName());
 
 	/**
 	 * make sure user didn't mangle the id
 	 */
 	public void checkId(
 			Object object,
 			EntityPersister persister,
 			Serializable id,
 			EntityMode entityMode,
 			SessionImplementor session) throws HibernateException {
 
 		if ( id != null && id instanceof DelayedPostInsertIdentifier ) {
 			// this is a situation where the entity id is assigned by a post-insert generator
 			// and was saved outside the transaction forcing it to be delayed
 			return;
 		}
 
 		if ( persister.canExtractIdOutOfEntity() ) {
 
 			Serializable oid = persister.getIdentifier( object, session );
 			if (id==null) {
 				throw new AssertionFailure("null id in " + persister.getEntityName() + " entry (don't flush the Session after an exception occurs)");
 			}
 			if ( !persister.getIdentifierType().isEqual( id, oid, entityMode, session.getFactory() ) ) {
 				throw new HibernateException(
 						"identifier of an instance of " +
 						persister.getEntityName() +
 						" was altered from " + id +
 						" to " + oid
 					);
 			}
 		}
 
 	}
 
 	private void checkNaturalId(
 			EntityPersister persister,
 	        EntityEntry entry,
 	        Object[] current,
 	        Object[] loaded,
 	        EntityMode entityMode,
 	        SessionImplementor session) {
 		if ( persister.hasNaturalIdentifier() && entry.getStatus() != Status.READ_ONLY ) {
  			Object[] snapshot = null;
 			Type[] types = persister.getPropertyTypes();
 			int[] props = persister.getNaturalIdentifierProperties();
 			boolean[] updateable = persister.getPropertyUpdateability();
 			for ( int i=0; i<props.length; i++ ) {
 				int prop = props[i];
 				if ( !updateable[prop] ) {
  					Object loadedVal;
  					if ( loaded == null ) {
  						if ( snapshot == null) {
  							snapshot = session.getPersistenceContext().getNaturalIdSnapshot( entry.getId(), persister );
  						}
  						loadedVal = snapshot[i];
  					} else {
  						loadedVal = loaded[prop];
  					}
  					if ( !types[prop].isEqual( current[prop], loadedVal, entityMode ) ) {
 						throw new HibernateException(
 								"immutable natural identifier of an instance of " +
 								persister.getEntityName() +
 								" was altered"
 							);
 					}
 				}
 			}
 		}
 	}
 
 	/**
 	 * Flushes a single entity's state to the database, by scheduling
 	 * an update action, if necessary
 	 */
 	public void onFlushEntity(FlushEntityEvent event) throws HibernateException {
 		final Object entity = event.getEntity();
 		final EntityEntry entry = event.getEntityEntry();
 		final EventSource session = event.getSession();
 		final EntityPersister persister = entry.getPersister();
 		final Status status = entry.getStatus();
 		final EntityMode entityMode = session.getEntityMode();
 		final Type[] types = persister.getPropertyTypes();
 
 		final boolean mightBeDirty = entry.requiresDirtyCheck(entity);
 
 		final Object[] values = getValues( entity, entry, entityMode, mightBeDirty, session );
 
 		event.setPropertyValues(values);
 
 		//TODO: avoid this for non-new instances where mightBeDirty==false
 		boolean substitute = wrapCollections( session, persister, types, values);
 
 		if ( isUpdateNecessary( event, mightBeDirty ) ) {
 			substitute = scheduleUpdate( event ) || substitute;
 		}
 
 		if ( status != Status.DELETED ) {
 			// now update the object .. has to be outside the main if block above (because of collections)
 			if (substitute) persister.setPropertyValues( entity, values, entityMode );
 
 			// Search for collections by reachability, updating their role.
 			// We don't want to touch collections reachable from a deleted object
 			if ( persister.hasCollections() ) {
 				new FlushVisitor(session, entity).processEntityPropertyValues(values, types);
 			}
 		}
 
 	}
 
 	private Object[] getValues(
 			Object entity,
 			EntityEntry entry,
 			EntityMode entityMode,
 			boolean mightBeDirty,
 	        SessionImplementor session) {
 		final Object[] loadedState = entry.getLoadedState();
 		final Status status = entry.getStatus();
 		final EntityPersister persister = entry.getPersister();
 
 		final Object[] values;
 		if ( status == Status.DELETED ) {
 			//grab its state saved at deletion
 			values = entry.getDeletedState();
 		}
 		else if ( !mightBeDirty && loadedState!=null ) {
 			values = loadedState;
 		}
 		else {
 			checkId( entity, persister, entry.getId(), entityMode, session );
 
 			// grab its current state
 			values = persister.getPropertyValues( entity, entityMode );
 
 			checkNaturalId( persister, entry, values, loadedState, entityMode, session );
 		}
 		return values;
 	}
 
 	private boolean wrapCollections(
 			EventSource session,
 			EntityPersister persister,
 			Type[] types,
 			Object[] values
 	) {
 		if ( persister.hasCollections() ) {
 
 			// wrap up any new collections directly referenced by the object
 			// or its components
 
 			// NOTE: we need to do the wrap here even if its not "dirty",
 			// because collections need wrapping but changes to _them_
 			// don't dirty the container. Also, for versioned data, we
 			// need to wrap before calling searchForDirtyCollections
 
 			WrapVisitor visitor = new WrapVisitor(session);
 			// substitutes into values by side-effect
 			visitor.processEntityPropertyValues(values, types);
 			return visitor.isSubstitutionRequired();
 		}
 		else {
 			return false;
 		}
 	}
 
 	private boolean isUpdateNecessary(final FlushEntityEvent event, final boolean mightBeDirty) {
 		final Status status = event.getEntityEntry().getStatus();
 		if ( mightBeDirty || status==Status.DELETED ) {
 			// compare to cached state (ignoring collections unless versioned)
 			dirtyCheck(event);
 			if ( isUpdateNecessary(event) ) {
 				return true;
 			}
 			else {
 				FieldInterceptionHelper.clearDirty( event.getEntity() );
 				return false;
 			}
 		}
 		else {
 			return hasDirtyCollections( event, event.getEntityEntry().getPersister(), status );
 		}
 	}
 
 	private boolean scheduleUpdate(final FlushEntityEvent event) {
 
 		final EntityEntry entry = event.getEntityEntry();
 		final EventSource session = event.getSession();
 		final Object entity = event.getEntity();
 		final Status status = entry.getStatus();
 		final EntityMode entityMode = session.getEntityMode();
 		final EntityPersister persister = entry.getPersister();
 		final Object[] values = event.getPropertyValues();
 
         if (LOG.isTraceEnabled()) {
 			if ( status == Status.DELETED ) {
                 if (!persister.isMutable()) LOG.trace("Updating immutable, deleted entity: "
                                                       + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
                 else if (!entry.isModifiableEntity()) LOG.trace("Updating non-modifiable, deleted entity: "
                                                                 + MessageHelper.infoString(persister,
                                                                                            entry.getId(),
                                                                                            session.getFactory()));
                 else LOG.trace("Updating deleted entity: "
                                + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
             } else LOG.trace("Updating entity: " + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
 		}
 
 		final boolean intercepted = !entry.isBeingReplicated() && handleInterception( event );
 
 		// increment the version number (if necessary)
 		final Object nextVersion = getNextVersion(event);
 
 		// if it was dirtied by a collection only
 		int[] dirtyProperties = event.getDirtyProperties();
 		if ( event.isDirtyCheckPossible() && dirtyProperties == null ) {
 			if ( ! intercepted && !event.hasDirtyCollection() ) {
 				throw new AssertionFailure( "dirty, but no dirty properties" );
 			}
 			dirtyProperties = ArrayHelper.EMPTY_INT_ARRAY;
 		}
 
 		// check nullability but do not doAfterTransactionCompletion command execute
 		// we'll use scheduled updates for that.
 		new Nullability(session).checkNullability( values, persister, true );
 
 		// schedule the update
 		// note that we intentionally do _not_ pass in currentPersistentState!
 		session.getActionQueue().addAction(
 				new EntityUpdateAction(
 						entry.getId(),
 						values,
 						dirtyProperties,
 						event.hasDirtyCollection(),
 						( status == Status.DELETED && ! entry.isModifiableEntity() ?
 								persister.getPropertyValues( entity, entityMode ) :
 								entry.getLoadedState() ),
 						entry.getVersion(),
 						nextVersion,
 						entity,
 						entry.getRowId(),
 						persister,
 						session
 					)
 			);
 
 		return intercepted;
 	}
 
 	protected boolean handleInterception(FlushEntityEvent event) {
 		SessionImplementor session = event.getSession();
 		EntityEntry entry = event.getEntityEntry();
 		EntityPersister persister = entry.getPersister();
 		Object entity = event.getEntity();
 
 		//give the Interceptor a chance to modify property values
 		final Object[] values = event.getPropertyValues();
 		final boolean intercepted = invokeInterceptor( session, entity, entry, values, persister );
 
 		//now we might need to recalculate the dirtyProperties array
 		if ( intercepted && event.isDirtyCheckPossible() && !event.isDirtyCheckHandledByInterceptor() ) {
 			int[] dirtyProperties;
 			if ( event.hasDatabaseSnapshot() ) {
 				dirtyProperties = persister.findModified( event.getDatabaseSnapshot(), values, entity, session );
 			}
 			else {
 				dirtyProperties = persister.findDirty( values, entry.getLoadedState(), entity, session );
 			}
 			event.setDirtyProperties(dirtyProperties);
 		}
 
 		return intercepted;
 	}
 
 	protected boolean invokeInterceptor(
 			SessionImplementor session,
 			Object entity,
 			EntityEntry entry,
 			final Object[] values,
 			EntityPersister persister) {
 		return session.getInterceptor().onFlushDirty(
 				entity,
 				entry.getId(),
 				values,
 				entry.getLoadedState(),
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 		);
 	}
 
 	/**
 	 * Convience method to retreive an entities next version value
 	 */
 	private Object getNextVersion(FlushEntityEvent event) throws HibernateException {
 
 		EntityEntry entry = event.getEntityEntry();
 		EntityPersister persister = entry.getPersister();
 		if ( persister.isVersioned() ) {
 
 			Object[] values = event.getPropertyValues();
 
 			if ( entry.isBeingReplicated() ) {
 				return Versioning.getVersion(values, persister);
 			}
 			else {
 				int[] dirtyProperties = event.getDirtyProperties();
 
 				final boolean isVersionIncrementRequired = isVersionIncrementRequired(
 						event,
 						entry,
 						persister,
 						dirtyProperties
 					);
 
 				final Object nextVersion = isVersionIncrementRequired ?
 						Versioning.increment( entry.getVersion(), persister.getVersionType(), event.getSession() ) :
 						entry.getVersion(); //use the current version
 
 				Versioning.setVersion(values, nextVersion, persister);
 
 				return nextVersion;
 			}
 		}
 		else {
 			return null;
 		}
 
 	}
 
 	private boolean isVersionIncrementRequired(
 			FlushEntityEvent event,
 			EntityEntry entry,
 			EntityPersister persister,
 			int[] dirtyProperties
 	) {
 		final boolean isVersionIncrementRequired = entry.getStatus()!=Status.DELETED && (
 				dirtyProperties==null ||
 				Versioning.isVersionIncrementRequired(
 						dirtyProperties,
 						event.hasDirtyCollection(),
 						persister.getPropertyVersionability()
 				)
 			);
 		return isVersionIncrementRequired;
 	}
 
 	/**
 	 * Performs all necessary checking to determine if an entity needs an SQL update
 	 * to synchronize its state to the database. Modifies the event by side-effect!
 	 * Note: this method is quite slow, avoid calling if possible!
 	 */
 	protected final boolean isUpdateNecessary(FlushEntityEvent event) throws HibernateException {
 
 		EntityPersister persister = event.getEntityEntry().getPersister();
 		Status status = event.getEntityEntry().getStatus();
 
 		if ( !event.isDirtyCheckPossible() ) {
 			return true;
 		}
 		else {
 
 			int[] dirtyProperties = event.getDirtyProperties();
 			if ( dirtyProperties!=null && dirtyProperties.length!=0 ) {
 				return true; //TODO: suck into event class
 			}
 			else {
 				return hasDirtyCollections( event, persister, status );
 			}
 
 		}
 	}
 
 	private boolean hasDirtyCollections(FlushEntityEvent event, EntityPersister persister, Status status) {
 		if ( isCollectionDirtyCheckNecessary(persister, status ) ) {
 			DirtyCollectionSearchVisitor visitor = new DirtyCollectionSearchVisitor(
 					event.getSession(),
 					persister.getPropertyVersionability()
 				);
 			visitor.processEntityPropertyValues( event.getPropertyValues(), persister.getPropertyTypes() );
 			boolean hasDirtyCollections = visitor.wasDirtyCollectionFound();
 			event.setHasDirtyCollection(hasDirtyCollections);
 			return hasDirtyCollections;
 		}
 		else {
 			return false;
 		}
 	}
 
 	private boolean isCollectionDirtyCheckNecessary(EntityPersister persister, Status status) {
 		return ( status == Status.MANAGED || status == Status.READ_ONLY ) &&
 				persister.isVersioned() &&
 				persister.hasCollections();
 	}
 
 	/**
 	 * Perform a dirty check, and attach the results to the event
 	 */
 	protected void dirtyCheck(FlushEntityEvent event) throws HibernateException {
 
 		final Object entity = event.getEntity();
 		final Object[] values = event.getPropertyValues();
 		final SessionImplementor session = event.getSession();
 		final EntityEntry entry = event.getEntityEntry();
 		final EntityPersister persister = entry.getPersister();
 		final Serializable id = entry.getId();
 		final Object[] loadedState = entry.getLoadedState();
 
 		int[] dirtyProperties = session.getInterceptor().findDirty(
 				entity,
 				id,
 				values,
 				loadedState,
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 			);
 
 		event.setDatabaseSnapshot(null);
 
 		final boolean interceptorHandledDirtyCheck;
 		boolean cannotDirtyCheck;
 
 		if ( dirtyProperties==null ) {
 			// Interceptor returned null, so do the dirtycheck ourself, if possible
 			interceptorHandledDirtyCheck = false;
 
 			cannotDirtyCheck = loadedState==null; // object loaded by update()
 			if ( !cannotDirtyCheck ) {
 				// dirty check against the usual snapshot of the entity
 				dirtyProperties = persister.findDirty( values, loadedState, entity, session );
 			}
 			else if ( entry.getStatus() == Status.DELETED && ! event.getEntityEntry().isModifiableEntity() ) {
 				// A non-modifiable (e.g., read-only or immutable) entity needs to be have
 				// references to transient entities set to null before being deleted. No other
 				// fields should be updated.
 				if ( values != entry.getDeletedState() ) {
 					throw new IllegalStateException(
 							"Entity has status Status.DELETED but values != entry.getDeletedState"
 					);
 				}
 				// Even if loadedState == null, we can dirty-check by comparing currentState and
 				// entry.getDeletedState() because the only fields to be updated are those that
 				// refer to transient entities that are being set to null.
 				// - currentState contains the entity's current property values.
 				// - entry.getDeletedState() contains the entity's current property values with
 				//   references to transient entities set to null.
 				// - dirtyProperties will only contain properties that refer to transient entities
 				final Object[] currentState =
 						persister.getPropertyValues( event.getEntity(), event.getSession().getEntityMode() );
 				dirtyProperties = persister.findDirty( entry.getDeletedState(), currentState, entity, session );
 				cannotDirtyCheck = false;
 			}
 			else {
 				// dirty check against the database snapshot, if possible/necessary
 				final Object[] databaseSnapshot = getDatabaseSnapshot(session, persister, id);
 				if ( databaseSnapshot != null ) {
 					dirtyProperties = persister.findModified(databaseSnapshot, values, entity, session);
 					cannotDirtyCheck = false;
 					event.setDatabaseSnapshot(databaseSnapshot);
 				}
 			}
 		}
 		else {
 			// the Interceptor handled the dirty checking
 			cannotDirtyCheck = false;
 			interceptorHandledDirtyCheck = true;
 		}
 
 		logDirtyProperties( id, dirtyProperties, persister );
 
 		event.setDirtyProperties(dirtyProperties);
 		event.setDirtyCheckHandledByInterceptor(interceptorHandledDirtyCheck);
 		event.setDirtyCheckPossible(!cannotDirtyCheck);
 
 	}
 
 	private void logDirtyProperties(Serializable id, int[] dirtyProperties, EntityPersister persister) {
         if (LOG.isTraceEnabled() && dirtyProperties != null && dirtyProperties.length > 0) {
 			final String[] allPropertyNames = persister.getPropertyNames();
 			final String[] dirtyPropertyNames = new String[ dirtyProperties.length ];
 			for ( int i = 0; i < dirtyProperties.length; i++ ) {
 				dirtyPropertyNames[i] = allPropertyNames[ dirtyProperties[i]];
 			}
             LOG.trace("Found dirty properties [" + MessageHelper.infoString(persister.getEntityName(), id) + "] : "
                       + dirtyPropertyNames);
 		}
 	}
 
 	private Object[] getDatabaseSnapshot(SessionImplementor session, EntityPersister persister, Serializable id) {
 		if ( persister.isSelectBeforeUpdateRequired() ) {
 			Object[] snapshot = session.getPersistenceContext()
 					.getDatabaseSnapshot(id, persister);
 			if (snapshot==null) {
 				//do we even really need this? the update will fail anyway....
 				if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
 					session.getFactory().getStatisticsImplementor()
 							.optimisticFailure( persister.getEntityName() );
 				}
 				throw new StaleObjectStateException( persister.getEntityName(), id );
 			}
             return snapshot;
 		}
         // TODO: optimize away this lookup for entities w/o unsaved-value="undefined"
         final EntityKey entityKey = session.generateEntityKey( id, persister );
         return session.getPersistenceContext().getCachedDatabaseSnapshot(entityKey);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEventListener.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEventListener.java
index db14e76b99..e51ebe91f6 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultFlushEventListener.java
@@ -1,59 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.HibernateException;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.FlushEvent;
-import org.hibernate.event.FlushEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.FlushEvent;
+import org.hibernate.event.spi.FlushEventListener;
 
 /**
  * Defines the default flush event listeners used by hibernate for 
  * flushing session state in response to generated flush events.
  *
  * @author Steve Ebersole
  */
 public class DefaultFlushEventListener extends AbstractFlushingEventListener implements FlushEventListener {
 
 	/** Handle the given flush event.
 	 *
 	 * @param event The flush event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onFlush(FlushEvent event) throws HibernateException {
 		final EventSource source = event.getSession();
 		if ( source.getPersistenceContext().getEntityEntries().size() > 0 ||
 				source.getPersistenceContext().getCollectionEntries().size() > 0 ) {
 
 			flushEverythingToExecutions(event);
 			performExecutions(source);
 			postFlush(source);
 		
 			if ( source.getFactory().getStatistics().isStatisticsEnabled() ) {
 				source.getFactory().getStatisticsImplementor().flush();
 			}
 
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultInitializeCollectionEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultInitializeCollectionEventListener.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultInitializeCollectionEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultInitializeCollectionEventListener.java
index c50b52d02a..47bd57d472 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultInitializeCollectionEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultInitializeCollectionEventListener.java
@@ -1,146 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.event.spi.InitializeCollectionEvent;
+import org.hibernate.event.spi.InitializeCollectionEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.cache.spi.entry.CollectionCacheEntry;
 import org.hibernate.engine.spi.CollectionEntry;
-import org.hibernate.event.InitializeCollectionEvent;
-import org.hibernate.event.InitializeCollectionEventListener;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.pretty.MessageHelper;
 
 /**
  * @author Gavin King
  */
 public class DefaultInitializeCollectionEventListener implements InitializeCollectionEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultInitializeCollectionEventListener.class.getName());
 
 	/**
 	 * called by a collection that wants to initialize itself
 	 */
 	public void onInitializeCollection(InitializeCollectionEvent event)
 	throws HibernateException {
 
 		PersistentCollection collection = event.getCollection();
 		SessionImplementor source = event.getSession();
 
 		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry(collection);
 		if (ce==null) throw new HibernateException("collection was evicted");
 		if ( !collection.wasInitialized() ) {
             if (LOG.isTraceEnabled()) LOG.trace("Initializing collection "
                                                 + MessageHelper.collectionInfoString(ce.getLoadedPersister(),
                                                                                      ce.getLoadedKey(),
                                                                                      source.getFactory()));
 
             LOG.trace("Checking second-level cache");
 			final boolean foundInCache = initializeCollectionFromCache(
 					ce.getLoadedKey(),
 					ce.getLoadedPersister(),
 					collection,
 					source
 				);
 
             if (foundInCache) LOG.trace("Collection initialized from cache");
 			else {
                 LOG.trace("Collection not cached");
 				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );
                 LOG.trace("Collection initialized");
 
 				if ( source.getFactory().getStatistics().isStatisticsEnabled() ) {
 					source.getFactory().getStatisticsImplementor().fetchCollection(
 							ce.getLoadedPersister().getRole()
 						);
 				}
 			}
 		}
 	}
 
 	/**
 	 * Try to initialize a collection from the cache
 	 *
 	 * @param id The id of the collection of initialize
 	 * @param persister The collection persister
 	 * @param collection The collection to initialize
 	 * @param source The originating session
 	 * @return true if we were able to initialize the collection from the cache;
 	 * false otherwise.
 	 */
 	private boolean initializeCollectionFromCache(
 			Serializable id,
 			CollectionPersister persister,
 			PersistentCollection collection,
 			SessionImplementor source) {
 
 		if ( !source.getEnabledFilters().isEmpty() && persister.isAffectedByEnabledFilters( source ) ) {
             LOG.trace("Disregarding cached version (if any) of collection due to enabled filters");
 			return false;
 		}
 
 		final boolean useCache = persister.hasCache() &&
 				source.getCacheMode().isGetEnabled();
 
         if (!useCache) return false;
 
         final SessionFactoryImplementor factory = source.getFactory();
 
         final CacheKey ck = source.generateCacheKey( id, persister.getKeyType(), persister.getRole() );
         Object ce = persister.getCacheAccessStrategy().get(ck, source.getTimestamp());
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
             if (ce == null) {
                 factory.getStatisticsImplementor()
 						.secondLevelCacheMiss( persister.getCacheAccessStrategy().getRegion().getName() );
             }
 			else {
                 factory.getStatisticsImplementor()
 						.secondLevelCacheHit( persister.getCacheAccessStrategy().getRegion().getName() );
             }
 		}
 
         if ( ce == null ) {
 			return false;
 		}
 
 		CollectionCacheEntry cacheEntry = (CollectionCacheEntry)persister.getCacheEntryStructure().destructure(ce, factory);
 
 		final PersistenceContext persistenceContext = source.getPersistenceContext();
         cacheEntry.assemble(collection, persister, persistenceContext.getCollectionOwner(id, persister));
         persistenceContext.getCollectionEntry(collection).postInitialize(collection);
         // addInitializedCollection(collection, persister, id);
         return true;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLoadEventListener.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLoadEventListener.java
index 394b2cfdaf..7fdfb510d5 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLoadEventListener.java
@@ -1,668 +1,668 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.LoadEvent;
+import org.hibernate.event.spi.LoadEventListener;
+import org.hibernate.event.spi.PostLoadEvent;
+import org.hibernate.event.spi.PostLoadEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.PersistentObjectException;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.cache.spi.access.SoftLock;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.internal.TwoPhaseLoad;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
-import org.hibernate.event.LoadEvent;
-import org.hibernate.event.LoadEventListener;
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PostLoadEventListener;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.type.EmbeddedComponentType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * Defines the default load event listeners used by hibernate for loading entities
  * in response to generated load events.
  *
  * @author Steve Ebersole
  */
 public class DefaultLoadEventListener extends AbstractLockUpgradeEventListener implements LoadEventListener {
 
 	public static final Object REMOVED_ENTITY_MARKER = new Object();
 	public static final Object INCONSISTENT_RTN_CLASS_MARKER = new Object();
 	public static final LockMode DEFAULT_LOCK_MODE = LockMode.NONE;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultLoadEventListener.class.getName());
 
 
 	/**
 	 * Handle the given load event.
 	 *
 	 * @param event The load event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType) throws HibernateException {
 
 		final SessionImplementor source = event.getSession();
 
 		EntityPersister persister;
 		if ( event.getInstanceToLoad() != null ) {
 			persister = source.getEntityPersister( null, event.getInstanceToLoad() ); //the load() which takes an entity does not pass an entityName
 			event.setEntityClassName( event.getInstanceToLoad().getClass().getName() );
 		}
 		else {
 			persister = source.getFactory().getEntityPersister( event.getEntityClassName() );
 		}
 
 		if ( persister == null ) {
 			throw new HibernateException(
 					"Unable to locate persister: " +
 					event.getEntityClassName()
 				);
 		}
 
 		final Class idClass = persister.getIdentifierType().getReturnedClass();
 		if ( persister.getIdentifierType().isComponentType() && EntityMode.DOM4J == event.getSession().getEntityMode() ) {
 			// skip this check for composite-ids relating to dom4j entity-mode;
 			// alternatively, we could add a check to make sure the incoming id value is
 			// an instance of Element...
 		}
 		else {
 			if ( idClass != null && ! idClass.isInstance( event.getEntityId() ) ) {
 				// we may have the kooky jpa requirement of allowing find-by-id where
 				// "id" is the "simple pk value" of a dependent objects parent.  This
 				// is part of its generally goofy "derived identity" "feature"
 				if ( persister.getEntityMetamodel().getIdentifierProperty().isEmbedded() ) {
 					final EmbeddedComponentType dependentIdType =
 							(EmbeddedComponentType) persister.getEntityMetamodel().getIdentifierProperty().getType();
 					if ( dependentIdType.getSubtypes().length == 1 ) {
 						final Type singleSubType = dependentIdType.getSubtypes()[0];
 						if ( singleSubType.isEntityType() ) {
 							final EntityType dependentParentType = (EntityType) singleSubType;
 							final Type dependentParentIdType = dependentParentType.getIdentifierOrUniqueKeyType( source.getFactory() );
 							if ( dependentParentIdType.getReturnedClass().isInstance( event.getEntityId() ) ) {
 								// yep that's what we have...
 								loadByDerivedIdentitySimplePkValue(
 										event,
 										loadType,
 										persister,
 										dependentIdType,
 										source.getFactory().getEntityPersister( dependentParentType.getAssociatedEntityName() )
 								);
 								return;
 							}
 						}
 					}
 				}
 				throw new TypeMismatchException(
 						"Provided id of the wrong type for class " + persister.getEntityName() + ". Expected: " + idClass + ", got " + event.getEntityId().getClass()
 				);
 			}
 		}
 
 		final  EntityKey keyToLoad = source.generateEntityKey( event.getEntityId(), persister );
 
 		try {
 			if ( loadType.isNakedEntityReturned() ) {
 				//do not return a proxy!
 				//(this option indicates we are initializing a proxy)
 				event.setResult( load(event, persister, keyToLoad, loadType) );
 			}
 			else {
 				//return a proxy if appropriate
 				if ( event.getLockMode() == LockMode.NONE ) {
 					event.setResult( proxyOrLoad(event, persister, keyToLoad, loadType) );
 				}
 				else {
 					event.setResult( lockAndLoad(event, persister, keyToLoad, loadType, source) );
 				}
 			}
 		}
 		catch(HibernateException e) {
             LOG.unableToLoadCommand(e);
 			throw e;
 		}
 	}
 
 	private void loadByDerivedIdentitySimplePkValue(
 			LoadEvent event,
 			LoadEventListener.LoadType options,
 			EntityPersister dependentPersister,
 			EmbeddedComponentType dependentIdType,
 			EntityPersister parentPersister) {
 		final EntityKey parentEntityKey = event.getSession().generateEntityKey( event.getEntityId(), parentPersister );
 		final Object parent = doLoad( event, parentPersister, parentEntityKey, options );
 
 		final Serializable dependent = (Serializable) dependentIdType.instantiate( parent, event.getSession() );
 		dependentIdType.setPropertyValues( dependent, new Object[] {parent}, event.getSession().getEntityMode() );
 		final EntityKey dependentEntityKey = event.getSession().generateEntityKey( dependent, dependentPersister );
 		event.setEntityId( dependent );
 
 		event.setResult( doLoad( event, dependentPersister, dependentEntityKey, options ) );
 	}
 
 	/**
 	 * Performs the load of an entity.
 	 *
 	 * @param event The initiating load request event
 	 * @param persister The persister corresponding to the entity to be loaded
 	 * @param keyToLoad The key of the entity to be loaded
 	 * @param options The defined load options
 	 * @return The loaded entity.
 	 * @throws HibernateException
 	 */
 	protected Object load(
 		final LoadEvent event,
 		final EntityPersister persister,
 		final EntityKey keyToLoad,
 		final LoadEventListener.LoadType options) {
 
 		if ( event.getInstanceToLoad() != null ) {
 			if ( event.getSession().getPersistenceContext().getEntry( event.getInstanceToLoad() ) != null ) {
 				throw new PersistentObjectException(
 						"attempted to load into an instance that was already associated with the session: " +
 						MessageHelper.infoString( persister, event.getEntityId(), event.getSession().getFactory() )
 					);
 			}
 			persister.setIdentifier( event.getInstanceToLoad(), event.getEntityId(), event.getSession() );
 		}
 
 		Object entity = doLoad(event, persister, keyToLoad, options);
 
 		boolean isOptionalInstance = event.getInstanceToLoad() != null;
 
 		if ( !options.isAllowNulls() || isOptionalInstance ) {
 			if ( entity == null ) {
 				event.getSession().getFactory().getEntityNotFoundDelegate().handleEntityNotFound( event.getEntityClassName(), event.getEntityId() );
 			}
 		}
 
 		if ( isOptionalInstance && entity != event.getInstanceToLoad() ) {
 			throw new NonUniqueObjectException( event.getEntityId(), event.getEntityClassName() );
 		}
 
 		return entity;
 	}
 
 	/**
 	 * Based on configured options, will either return a pre-existing proxy,
 	 * generate a new proxy, or perform an actual load.
 	 *
 	 * @param event The initiating load request event
 	 * @param persister The persister corresponding to the entity to be loaded
 	 * @param keyToLoad The key of the entity to be loaded
 	 * @param options The defined load options
 	 * @return The result of the proxy/load operation.
 	 */
 	protected Object proxyOrLoad(
 		final LoadEvent event,
 		final EntityPersister persister,
 		final EntityKey keyToLoad,
 		final LoadEventListener.LoadType options) {
 
         if (LOG.isTraceEnabled()) LOG.trace("Loading entity: "
                                             + MessageHelper.infoString(persister,
                                                                              event.getEntityId(),
                                                                              event.getSession().getFactory()));
 
         // this class has no proxies (so do a shortcut)
         if (!persister.hasProxy()) return load(event, persister, keyToLoad, options);
         final PersistenceContext persistenceContext = event.getSession().getPersistenceContext();
 
 		// look for a proxy
         Object proxy = persistenceContext.getProxy(keyToLoad);
         if (proxy != null) return returnNarrowedProxy(event, persister, keyToLoad, options, persistenceContext, proxy);
         if (options.isAllowProxyCreation()) return createProxyIfNecessary(event, persister, keyToLoad, options, persistenceContext);
         // return a newly loaded object
         return load(event, persister, keyToLoad, options);
 	}
 
 	/**
 	 * Given a proxy, initialize it and/or narrow it provided either
 	 * is necessary.
 	 *
 	 * @param event The initiating load request event
 	 * @param persister The persister corresponding to the entity to be loaded
 	 * @param keyToLoad The key of the entity to be loaded
 	 * @param options The defined load options
 	 * @param persistenceContext The originating session
 	 * @param proxy The proxy to narrow
 	 * @return The created/existing proxy
 	 */
 	private Object returnNarrowedProxy(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options,
 			final PersistenceContext persistenceContext,
 			final Object proxy) {
         LOG.trace("Entity proxy found in session cache");
 		LazyInitializer li = ( (HibernateProxy) proxy ).getHibernateLazyInitializer();
 		if ( li.isUnwrap() ) {
 			return li.getImplementation();
 		}
 		Object impl = null;
 		if ( !options.isAllowProxyCreation() ) {
 			impl = load( event, persister, keyToLoad, options );
 			if ( impl == null ) {
 				event.getSession().getFactory().getEntityNotFoundDelegate().handleEntityNotFound( persister.getEntityName(), keyToLoad.getIdentifier());
 			}
 		}
 		return persistenceContext.narrowProxy( proxy, persister, keyToLoad, impl );
 	}
 
 	/**
 	 * If there is already a corresponding proxy associated with the
 	 * persistence context, return it; otherwise create a proxy, associate it
 	 * with the persistence context, and return the just-created proxy.
 	 *
 	 * @param event The initiating load request event
 	 * @param persister The persister corresponding to the entity to be loaded
 	 * @param keyToLoad The key of the entity to be loaded
 	 * @param options The defined load options
 	 * @param persistenceContext The originating session
 	 * @return The created/existing proxy
 	 */
 	private Object createProxyIfNecessary(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options,
 			final PersistenceContext persistenceContext) {
 		Object existing = persistenceContext.getEntity( keyToLoad );
 		if ( existing != null ) {
 			// return existing object or initialized proxy (unless deleted)
             LOG.trace("Entity found in session cache");
 			if ( options.isCheckDeleted() ) {
 				EntityEntry entry = persistenceContext.getEntry( existing );
 				Status status = entry.getStatus();
 				if ( status == Status.DELETED || status == Status.GONE ) {
 					return null;
 				}
 			}
 			return existing;
 		}
         LOG.trace("Creating new proxy for entity");
         // return new uninitialized proxy
         Object proxy = persister.createProxy(event.getEntityId(), event.getSession());
         persistenceContext.getBatchFetchQueue().addBatchLoadableEntityKey(keyToLoad);
         persistenceContext.addProxy(keyToLoad, proxy);
         return proxy;
 	}
 
 	/**
 	 * If the class to be loaded has been configured with a cache, then lock
 	 * given id in that cache and then perform the load.
 	 *
 	 * @param event The initiating load request event
 	 * @param persister The persister corresponding to the entity to be loaded
 	 * @param keyToLoad The key of the entity to be loaded
 	 * @param options The defined load options
 	 * @param source The originating session
 	 * @return The loaded entity
 	 * @throws HibernateException
 	 */
 	protected Object lockAndLoad(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options,
 			final SessionImplementor source) {
 		SoftLock lock = null;
 		final CacheKey ck;
 		if ( persister.hasCache() ) {
 			ck = source.generateCacheKey(
 					event.getEntityId(),
 					persister.getIdentifierType(),
 					persister.getRootEntityName()
 			);
 			lock = persister.getCacheAccessStrategy().lockItem( ck, null );
 		}
 		else {
 			ck = null;
 		}
 
 		Object entity;
 		try {
 			entity = load(event, persister, keyToLoad, options);
 		}
 		finally {
 			if ( persister.hasCache() ) {
 				persister.getCacheAccessStrategy().unlockItem( ck, lock );
 			}
 		}
 
 		return event.getSession().getPersistenceContext().proxyFor( persister, keyToLoad, entity );
 	}
 
 
 	/**
 	 * Coordinates the efforts to load a given entity.  First, an attempt is
 	 * made to load the entity from the session-level cache.  If not found there,
 	 * an attempt is made to locate it in second-level cache.  Lastly, an
 	 * attempt is made to load it directly from the datasource.
 	 *
 	 * @param event The load event
 	 * @param persister The persister for the entity being requested for load
 	 * @param keyToLoad The EntityKey representing the entity to be loaded.
 	 * @param options The load options.
 	 * @return The loaded entity, or null.
 	 */
 	protected Object doLoad(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options) {
 
         if (LOG.isTraceEnabled()) LOG.trace("Attempting to resolve: "
                                             + MessageHelper.infoString(persister,
                                                                        event.getEntityId(),
                                                                        event.getSession().getFactory()));
 
 		Object entity = loadFromSessionCache( event, keyToLoad, options );
 		if ( entity == REMOVED_ENTITY_MARKER ) {
             LOG.debugf("Load request found matching entity in context, but it is scheduled for removal; returning null");
 			return null;
 		}
 		if ( entity == INCONSISTENT_RTN_CLASS_MARKER ) {
             LOG.debugf("Load request found matching entity in context, but the matched entity was of an inconsistent return type; returning null");
 			return null;
 		}
 		if ( entity != null ) {
             if (LOG.isTraceEnabled()) LOG.trace("Resolved object in session cache: "
                                                 + MessageHelper.infoString(persister,
                                                                            event.getEntityId(),
                                                                            event.getSession().getFactory()));
 			return entity;
 		}
 
 		entity = loadFromSecondLevelCache(event, persister, options);
 		if ( entity != null ) {
             if (LOG.isTraceEnabled()) LOG.trace("Resolved object in second-level cache: "
                                                 + MessageHelper.infoString(persister,
                                                                            event.getEntityId(),
                                                                            event.getSession().getFactory()));
 			return entity;
 		}
 
         if (LOG.isTraceEnabled()) LOG.trace("Object not resolved in any cache: "
                                             + MessageHelper.infoString(persister,
                                                                        event.getEntityId(),
                                                                        event.getSession().getFactory()));
 
 		return loadFromDatasource(event, persister, keyToLoad, options);
 	}
 
 	/**
 	 * Performs the process of loading an entity from the configured
 	 * underlying datasource.
 	 *
 	 * @param event The load event
 	 * @param persister The persister for the entity being requested for load
 	 * @param keyToLoad The EntityKey representing the entity to be loaded.
 	 * @param options The load options.
 	 * @return The object loaded from the datasource, or null if not found.
 	 */
 	protected Object loadFromDatasource(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options) {
 		final SessionImplementor source = event.getSession();
 		Object entity = persister.load(
 				event.getEntityId(),
 				event.getInstanceToLoad(),
 				event.getLockOptions(),
 				source
 		);
 
 		if ( event.isAssociationFetch() && source.getFactory().getStatistics().isStatisticsEnabled() ) {
 			source.getFactory().getStatisticsImplementor().fetchEntity( event.getEntityClassName() );
 		}
 
 		return entity;
 	}
 
 	/**
 	 * Attempts to locate the entity in the session-level cache.
 	 * <p/>
 	 * If allowed to return nulls, then if the entity happens to be found in
 	 * the session cache, we check the entity type for proper handling
 	 * of entity hierarchies.
 	 * <p/>
 	 * If checkDeleted was set to true, then if the entity is found in the
 	 * session-level cache, it's current status within the session cache
 	 * is checked to see if it has previously been scheduled for deletion.
 	 *
 	 * @param event The load event
 	 * @param keyToLoad The EntityKey representing the entity to be loaded.
 	 * @param options The load options.
 	 * @return The entity from the session-level cache, or null.
 	 * @throws HibernateException Generally indicates problems applying a lock-mode.
 	 */
 	protected Object loadFromSessionCache(
 			final LoadEvent event,
 			final EntityKey keyToLoad,
 			final LoadEventListener.LoadType options) throws HibernateException {
 
 		SessionImplementor session = event.getSession();
 		Object old = session.getEntityUsingInterceptor( keyToLoad );
 
 		if ( old != null ) {
 			// this object was already loaded
 			EntityEntry oldEntry = session.getPersistenceContext().getEntry( old );
 			if ( options.isCheckDeleted() ) {
 				Status status = oldEntry.getStatus();
 				if ( status == Status.DELETED || status == Status.GONE ) {
 					return REMOVED_ENTITY_MARKER;
 				}
 			}
 			if ( options.isAllowNulls() ) {
 //				EntityPersister persister = event.getSession().getFactory().getEntityPersister( event.getEntityClassName() );
 				EntityPersister persister = event.getSession().getFactory().getEntityPersister( keyToLoad.getEntityName() );
 				if ( ! persister.isInstance( old, event.getSession().getEntityMode() ) ) {
 					return INCONSISTENT_RTN_CLASS_MARKER;
 				}
 			}
 			upgradeLock( old, oldEntry, event.getLockOptions(), event.getSession() );
 		}
 
 		return old;
 	}
 
 	/**
 	 * Attempts to load the entity from the second-level cache.
 	 *
 	 * @param event The load event
 	 * @param persister The persister for the entity being requested for load
 	 * @param options The load options.
 	 * @return The entity from the second-level cache, or null.
 	 */
 	protected Object loadFromSecondLevelCache(
 			final LoadEvent event,
 			final EntityPersister persister,
 			final LoadEventListener.LoadType options) {
 
 		final SessionImplementor source = event.getSession();
 
 		final boolean useCache = persister.hasCache()
 				&& source.getCacheMode().isGetEnabled()
 				&& event.getLockMode().lessThan(LockMode.READ);
 
 		if ( useCache ) {
 
 			final SessionFactoryImplementor factory = source.getFactory();
 
 			final CacheKey ck = source.generateCacheKey(
 					event.getEntityId(),
 					persister.getIdentifierType(),
 					persister.getRootEntityName()
 			);
 			Object ce = persister.getCacheAccessStrategy().get( ck, source.getTimestamp() );
 			if ( factory.getStatistics().isStatisticsEnabled() ) {
 				if ( ce == null ) {
 					factory.getStatisticsImplementor().secondLevelCacheMiss(
 							persister.getCacheAccessStrategy().getRegion().getName()
 					);
 				}
 				else {
 					factory.getStatisticsImplementor().secondLevelCacheHit(
 							persister.getCacheAccessStrategy().getRegion().getName()
 					);
 				}
 			}
 
 			if ( ce != null ) {
 				CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
 
 				// Entity was found in second-level cache...
 				return assembleCacheEntry(
 						entry,
 						event.getEntityId(),
 						persister,
 						event
 				);
 			}
 		}
 
 		return null;
 	}
 
 	private Object assembleCacheEntry(
 			final CacheEntry entry,
 			final Serializable id,
 			final EntityPersister persister,
 			final LoadEvent event) throws HibernateException {
 
 		final Object optionalObject = event.getInstanceToLoad();
 		final EventSource session = event.getSession();
 		final SessionFactoryImplementor factory = session.getFactory();
 
         if (LOG.isTraceEnabled()) LOG.trace("Assembling entity from second-level cache: "
                                             + MessageHelper.infoString(persister, id, factory));
 
 		EntityPersister subclassPersister = factory.getEntityPersister( entry.getSubclass() );
 		Object result = optionalObject == null ?
 				session.instantiate( subclassPersister, id ) : optionalObject;
 
 		// make it circular-reference safe
 		final EntityKey entityKey = session.generateEntityKey( id, subclassPersister );
 		TwoPhaseLoad.addUninitializedCachedEntity(
 				entityKey,
 				result,
 				subclassPersister,
 				LockMode.NONE,
 				entry.areLazyPropertiesUnfetched(),
 				entry.getVersion(),
 				session
 			);
 
 		Type[] types = subclassPersister.getPropertyTypes();
 		Object[] values = entry.assemble( result, id, subclassPersister, session.getInterceptor(), session ); // intializes result by side-effect
 		TypeHelper.deepCopy(
 				values,
 				types,
 				subclassPersister.getPropertyUpdateability(),
 				values,
 				session
 		);
 
 		Object version = Versioning.getVersion( values, subclassPersister );
         if (LOG.isTraceEnabled()) LOG.trace("Cached Version: " + version);
 
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		boolean isReadOnly = session.isDefaultReadOnly();
 		if ( persister.isMutable() ) {
 			Object proxy = persistenceContext.getProxy( entityKey );
 			if ( proxy != null ) {
 				// there is already a proxy for this impl
 				// only set the status to read-only if the proxy is read-only
 				isReadOnly = ( ( HibernateProxy ) proxy ).getHibernateLazyInitializer().isReadOnly();
 			}
 		}
 		else {
 			isReadOnly = true;
 		}
 		persistenceContext.addEntry(
 				result,
 				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
 				values,
 				null,
 				id,
 				version,
 				LockMode.NONE,
 				true,
 				subclassPersister,
 				false,
 				entry.areLazyPropertiesUnfetched()
 			);
 		subclassPersister.afterInitialize( result, entry.areLazyPropertiesUnfetched(), session );
 		persistenceContext.initializeNonLazyCollections();
 		// upgrade the lock if necessary:
 		//lock(result, lockMode);
 
 		//PostLoad is needed for EJB3
 		//TODO: reuse the PostLoadEvent...
 		PostLoadEvent postLoadEvent = new PostLoadEvent( session )
 				.setEntity( result )
 				.setId( id )
 				.setPersister( persister );
 
 		for ( PostLoadEventListener listener : postLoadEventListeners( session ) ) {
 			listener.onPostLoad( postLoadEvent );
 		}
 
 		return result;
 	}
 
 	private Iterable<PostLoadEventListener> postLoadEventListeners(EventSource session) {
 		return session
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( EventType.POST_LOAD )
 				.listeners();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultLockEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLockEventListener.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultLockEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLockEventListener.java
index 2d401b1f0a..5e42c38973 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultLockEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLockEventListener.java
@@ -1,99 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.TransientObjectException;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.LockEvent;
-import org.hibernate.event.LockEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.LockEvent;
+import org.hibernate.event.spi.LockEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Defines the default lock event listeners used by hibernate to lock entities
  * in response to generated lock events.
  *
  * @author Steve Ebersole
  */
 public class DefaultLockEventListener extends AbstractLockUpgradeEventListener implements LockEventListener {
 
 	/** Handle the given lock event.
 	 *
 	 * @param event The lock event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onLock(LockEvent event) throws HibernateException {
 
 		if ( event.getObject() == null ) {
 			throw new NullPointerException( "attempted to lock null" );
 		}
 
 		if ( event.getLockMode() == LockMode.WRITE ) {
 			throw new HibernateException( "Invalid lock mode for lock()" );
 		}
 
 		SessionImplementor source = event.getSession();
 		
 		Object entity = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );
 		//TODO: if object was an uninitialized proxy, this is inefficient,
 		//      resulting in two SQL selects
 		
 		EntityEntry entry = source.getPersistenceContext().getEntry(entity);
 		if (entry==null) {
 			final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 			final Serializable id = persister.getIdentifier( entity, source );
 			if ( !ForeignKeys.isNotTransient( event.getEntityName(), entity, Boolean.FALSE, source ) ) {
 				throw new TransientObjectException(
 						"cannot lock an unsaved transient instance: " +
 						persister.getEntityName()
 				);
 			}
 
 			entry = reassociate(event, entity, id, persister);
 			cascadeOnLock(event, persister, entity);
 		}
 
 		upgradeLock( entity, entry, event.getLockOptions(), event.getSession() );
 	}
 	
 	private void cascadeOnLock(LockEvent event, EntityPersister persister, Object entity) {
 		EventSource source = event.getSession();
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade(CascadingAction.LOCK, Cascade.AFTER_LOCK, source)
 					.cascade( persister, entity, event.getLockOptions() );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultMergeEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultMergeEventListener.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultMergeEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultMergeEventListener.java
index 0ba17f6932..960ce2f8ad 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultMergeEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultMergeEventListener.java
@@ -1,657 +1,657 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.MergeEvent;
+import org.hibernate.event.spi.MergeEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.PropertyValueException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.WrongClassException;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.MergeEvent;
-import org.hibernate.event.MergeEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.type.ForeignKeyDirection;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * Defines the default copy event listener used by hibernate for copying entities
  * in response to generated copy events.
  *
  * @author Gavin King
  */
 public class DefaultMergeEventListener extends AbstractSaveEventListener
 	implements MergeEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultMergeEventListener.class.getName());
 
 	@Override
     protected Map getMergeMap(Object anything) {
 		return ( ( EventCache ) anything ).invertMap();
 	}
 
 	/**
 	 * Handle the given merge event.
 	 *
 	 * @param event The merge event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onMerge(MergeEvent event) throws HibernateException {
 		EventCache copyCache = new EventCache();
 		onMerge( event, copyCache );
 		// TODO: iteratively get transient entities and retry merge until one of the following conditions:
 		//       1) transientCopyCache.size() == 0
 		//       2) transientCopyCache.size() is not decreasing and copyCache.size() is not increasing
 		// TODO: find out if retrying can add entities to copyCache (don't think it can...)
 		// For now, just retry once; throw TransientObjectException if there are still any transient entities
 		Map transientCopyCache = getTransientCopyCache(event, copyCache );
 		if ( transientCopyCache.size() > 0 ) {
 			retryMergeTransientEntities( event, transientCopyCache, copyCache, true );
 			// find any entities that are still transient after retry
 			transientCopyCache = getTransientCopyCache(event, copyCache );
 			if ( transientCopyCache.size() > 0 ) {
 				Set transientEntityNames = new HashSet();
 				for( Iterator it=transientCopyCache.entrySet().iterator(); it.hasNext(); ) {
 					Object transientEntity = ( ( Map.Entry ) it.next() ).getKey();
 					String transientEntityName = event.getSession().guessEntityName( transientEntity );
 					transientEntityNames.add( transientEntityName );
                     LOG.trace("Transient instance could not be processed by merge when checking nullability: "
                               + transientEntityName + "[" + transientEntity + "]");
 				}
                 if (isNullabilityCheckedGlobal(event.getSession())) throw new TransientObjectException(
 						"one or more objects is an unsaved transient instance - save transient instance(s) before merging: " +
 						transientEntityNames );
                 LOG.trace("Retry saving transient instances without checking nullability");
                 // failures will be detected later...
                 retryMergeTransientEntities(event, transientCopyCache, copyCache, false);
 			}
 		}
 		copyCache.clear();
 		copyCache = null;
 	}
 
 	protected EventCache getTransientCopyCache(MergeEvent event, EventCache copyCache) {
 		EventCache transientCopyCache = new EventCache();
 		for ( Iterator it=copyCache.entrySet().iterator(); it.hasNext(); ) {
 			Map.Entry mapEntry = ( Map.Entry ) it.next();
 			Object entity = mapEntry.getKey();
 			Object copy = mapEntry.getValue();
 			if ( copy instanceof HibernateProxy ) {
 				copy = ( (HibernateProxy) copy ).getHibernateLazyInitializer().getImplementation();
 			}
 			EntityEntry copyEntry = event.getSession().getPersistenceContext().getEntry( copy );
 			if ( copyEntry == null ) {
 				// entity name will not be available for non-POJO entities
 				// TODO: cache the entity name somewhere so that it is available to this exception
                 LOG.trace("Transient instance could not be processed by merge: " + event.getSession().guessEntityName(copy) + "["
                           + entity + "]");
 				// merge did not cascade to this entity; it's in copyCache because a
 				// different entity has a non-nullable reference to this entity;
 				// this entity should not be put in transientCopyCache, because it was
 				// not included in the merge;
 				// if the global setting for checking nullability is false, the non-nullable
 				// reference to this entity will be detected later
 				if ( isNullabilityCheckedGlobal( event.getSession() ) ) {
 					throw new TransientObjectException(
 						"object is an unsaved transient instance - save the transient instance before merging: " +
 							event.getSession().guessEntityName( copy )
 					);
 				}
 			}
 			else if ( copyEntry.getStatus() == Status.SAVING ) {
 				transientCopyCache.put( entity, copy, copyCache.isOperatedOn( entity ) );
 			}
 			else if ( copyEntry.getStatus() != Status.MANAGED && copyEntry.getStatus() != Status.READ_ONLY ) {
 				throw new AssertionFailure( "Merged entity does not have status set to MANAGED or READ_ONLY; "+copy+" status="+copyEntry.getStatus() );
 			}
 		}
 		return transientCopyCache;
 	}
 
 	protected void retryMergeTransientEntities(
 			MergeEvent event,
 			Map transientCopyCache,
 			EventCache copyCache,
 			boolean isNullabilityChecked) {
 		// TODO: The order in which entities are saved may matter (e.g., a particular transient entity
 		//       may need to be saved before other transient entities can be saved;
 		//       Keep retrying the batch of transient entities until either:
 		//       1) there are no transient entities left in transientCopyCache
 		//       or 2) no transient entities were saved in the last batch
 		// For now, just run through the transient entities and retry the merge
 		for ( Iterator it=transientCopyCache.entrySet().iterator(); it.hasNext(); ) {
 			Map.Entry mapEntry = ( Map.Entry ) it.next();
 			Object entity = mapEntry.getKey();
 			Object copy = transientCopyCache.get( entity );
 			EntityEntry copyEntry = event.getSession().getPersistenceContext().getEntry( copy );
 			mergeTransientEntity(
 					entity,
 					copyEntry.getEntityName(),
 					( entity == event.getEntity() ? event.getRequestedId() : copyEntry.getId() ),
 					event.getSession(),
 					copyCache,
 					isNullabilityChecked
 			);
 		}
 	}
 
 	/**
 	 * Handle the given merge event.
 	 *
 	 * @param event The merge event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onMerge(MergeEvent event, Map copiedAlready) throws HibernateException {
 
 		final EventCache copyCache = ( EventCache ) copiedAlready;
 		final EventSource source = event.getSession();
 		final Object original = event.getOriginal();
 
 		if ( original != null ) {
 
 			final Object entity;
 			if ( original instanceof HibernateProxy ) {
 				LazyInitializer li = ( (HibernateProxy) original ).getHibernateLazyInitializer();
 				if ( li.isUninitialized() ) {
                     LOG.trace("Ignoring uninitialized proxy");
 					event.setResult( source.load( li.getEntityName(), li.getIdentifier() ) );
 					return; //EARLY EXIT!
 				}
 				else {
 					entity = li.getImplementation();
 				}
 			}
 			else {
 				entity = original;
 			}
 
 			if ( copyCache.containsKey( entity ) &&
 					( copyCache.isOperatedOn( entity ) ) ) {
                 LOG.trace("Already in merge process");
 				event.setResult( entity );
 			}
 			else {
 				if ( copyCache.containsKey( entity ) ) {
                     LOG.trace("Already in copyCache; setting in merge process");
 					copyCache.setOperatedOn( entity, true );
 				}
 				event.setEntity( entity );
 				int entityState = -1;
 
 				// Check the persistence context for an entry relating to this
 				// entity to be merged...
 				EntityEntry entry = source.getPersistenceContext().getEntry( entity );
 				if ( entry == null ) {
 					EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 					Serializable id = persister.getIdentifier( entity, source );
 					if ( id != null ) {
 						final EntityKey key = source.generateEntityKey( id, persister );
 						final Object managedEntity = source.getPersistenceContext().getEntity( key );
 						entry = source.getPersistenceContext().getEntry( managedEntity );
 						if ( entry != null ) {
 							// we have specialized case of a detached entity from the
 							// perspective of the merge operation.  Specifically, we
 							// have an incoming entity instance which has a corresponding
 							// entry in the current persistence context, but registered
 							// under a different entity instance
 							entityState = DETACHED;
 						}
 					}
 				}
 
 				if ( entityState == -1 ) {
 					entityState = getEntityState( entity, event.getEntityName(), entry, source );
 				}
 
 				switch (entityState) {
 					case DETACHED:
 						entityIsDetached(event, copyCache);
 						break;
 					case TRANSIENT:
 						entityIsTransient(event, copyCache);
 						break;
 					case PERSISTENT:
 						entityIsPersistent(event, copyCache);
 						break;
 					default: //DELETED
 						throw new ObjectDeletedException(
 								"deleted instance passed to merge",
 								null,
 								getLoggableName( event.getEntityName(), entity )
 							);
 				}
 			}
 
 		}
 
 	}
 
 	protected void entityIsPersistent(MergeEvent event, Map copyCache) {
         LOG.trace("Ignoring persistent instance");
 
 		//TODO: check that entry.getIdentifier().equals(requestedId)
 
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 
 		( ( EventCache ) copyCache ).put( entity, entity, true  );  //before cascade!
 
 		cascadeOnMerge(source, persister, entity, copyCache);
 		copyValues(persister, entity, entity, source, copyCache);
 
 		event.setResult(entity);
 	}
 
 	protected void entityIsTransient(MergeEvent event, Map copyCache) {
 
         LOG.trace("Merging transient instance");
 
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 		final String entityName = persister.getEntityName();
 
 		event.setResult( mergeTransientEntity( entity, entityName, event.getRequestedId(), source, copyCache, true ) );
 	}
 
 	protected Object mergeTransientEntity(Object entity, String entityName, Serializable requestedId, EventSource source, Map copyCache) {
 		return mergeTransientEntity( entity, entityName, requestedId, source, copyCache, true );
 	}
 
 	private Object mergeTransientEntity(
 			Object entity,
 			String entityName,
 			Serializable requestedId,
 			EventSource source,
 			Map copyCache,
 			boolean isNullabilityChecked) {
 
         LOG.trace("Merging transient instance");
 
 		final EntityPersister persister = source.getEntityPersister( entityName, entity );
 
 		final Serializable id = persister.hasIdentifierProperty() ?
 				persister.getIdentifier( entity, source ) :
 		        null;
 		if ( copyCache.containsKey( entity ) ) {
 			persister.setIdentifier( copyCache.get( entity ), id, source );
 		}
 		else {
 			( ( EventCache ) copyCache ).put( entity, source.instantiate( persister, id ), true ); //before cascade!
 		}
 		final Object copy = copyCache.get( entity );
 
 		// cascade first, so that all unsaved objects get their
 		// copy created before we actually copy
 		//cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);
 		super.cascadeBeforeSave(source, persister, entity, copyCache);
 		copyValues(persister, entity, copy, source, copyCache, ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT);
 
 		try {
 			// try saving; check for non-nullable properties that are null or transient entities before saving
 			saveTransientEntity( copy, entityName, requestedId, source, copyCache, isNullabilityChecked );
 		}
 		catch (PropertyValueException ex) {
 			String propertyName = ex.getPropertyName();
 			Object propertyFromCopy = persister.getPropertyValue( copy, propertyName, source.getEntityMode() );
 			Object propertyFromEntity = persister.getPropertyValue( entity, propertyName, source.getEntityMode() );
 			Type propertyType = persister.getPropertyType( propertyName );
 			EntityEntry copyEntry = source.getPersistenceContext().getEntry( copy );
 			if ( propertyFromCopy == null ||
 					propertyFromEntity == null ||
 					! propertyType.isEntityType() ||
 					! copyCache.containsKey( propertyFromEntity ) ) {
 				if ( LOG.isTraceEnabled() ) {
                     LOG.trace("Property '" + copyEntry.getEntityName() + "." + propertyName + "' in copy is "
                               + (propertyFromCopy == null ? "null" : propertyFromCopy));
                     LOG.trace("Property '" + copyEntry.getEntityName() + "." + propertyName + "' in original is "
                               + (propertyFromCopy == null ? "null" : propertyFromCopy));
                     LOG.trace("Property '" + copyEntry.getEntityName() + "." + propertyName + "' is"
                               + (propertyType.isEntityType() ? "" : " not") + " an entity type");
                     if (propertyFromEntity != null && !copyCache.containsKey(propertyFromEntity)) LOG.trace("Property '"
                                                                                                             + copyEntry.getEntityName()
                                                                                                             + "."
                                                                                                             + propertyName
                                                                                                             + "' is not in copy cache");
 	            }
                 if ( isNullabilityCheckedGlobal( source ) ) {
                     throw ex;
                 }
                 else {
                     // retry save w/o checking for non-nullable properties
                     // (the failure will be detected later)
                     saveTransientEntity( copy, entityName, requestedId, source, copyCache, false );
 				}
 			}
 			if ( LOG.isTraceEnabled() && propertyFromEntity != null ) {
                 if (((EventCache)copyCache).isOperatedOn(propertyFromEntity)) LOG.trace("Property '"
                                                                                         + copyEntry.getEntityName()
                                                                                         + "."
                                                                                         + propertyName
                                                                                         + "' from original entity is in copyCache and is in the process of being merged; "
                                                                                         + propertyName + " =[" + propertyFromEntity
                                                                                         + "]");
                 else LOG.trace("Property '" + copyEntry.getEntityName() + "." + propertyName
                                + "' from original entity is in copyCache and is not in the process of being merged; "
                                + propertyName + " =[" + propertyFromEntity + "]");
 			}
 			// continue...; we'll find out if it ends up not getting saved later
 		}
 
 		// cascade first, so that all unsaved objects get their
 		// copy created before we actually copy
 		super.cascadeAfterSave(source, persister, entity, copyCache);
 		copyValues(persister, entity, copy, source, copyCache, ForeignKeyDirection.FOREIGN_KEY_TO_PARENT);
 
 		return copy;
 
 	}
 
 	private boolean isNullabilityCheckedGlobal(EventSource source) {
 		return source.getFactory().getSettings().isCheckNullability();
 	}
 
 	private void saveTransientEntity(
 			Object entity,
 			String entityName,
 			Serializable requestedId,
 			EventSource source,
 			Map copyCache,
 			boolean isNullabilityChecked) {
 
 		boolean isNullabilityCheckedOrig =
 			source.getFactory().getSettings().isCheckNullability();
 		try {
 			source.getFactory().getSettings().setCheckNullability( isNullabilityChecked );
 			//this bit is only *really* absolutely necessary for handling
 			//requestedId, but is also good if we merge multiple object
 			//graphs, since it helps ensure uniqueness
 			if (requestedId==null) {
 				saveWithGeneratedId( entity, entityName, copyCache, source, false );
 			}
 			else {
 				saveWithRequestedId( entity, requestedId, entityName, copyCache, source );
 			}
 		}
 		finally {
 			source.getFactory().getSettings().setCheckNullability( isNullabilityCheckedOrig );
 		}
 	}
 	protected void entityIsDetached(MergeEvent event, Map copyCache) {
 
         LOG.trace("Merging detached instance");
 
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 		final String entityName = persister.getEntityName();
 
 		Serializable id = event.getRequestedId();
 		if ( id == null ) {
 			id = persister.getIdentifier( entity, source );
 		}
 		else {
 			// check that entity id = requestedId
 			Serializable entityId = persister.getIdentifier( entity, source );
 			if ( !persister.getIdentifierType().isEqual( id, entityId, source.getEntityMode(), source.getFactory() ) ) {
 				throw new HibernateException( "merge requested with id not matching id of passed entity" );
 			}
 		}
 
 		String previousFetchProfile = source.getFetchProfile();
 		source.setFetchProfile("merge");
 		//we must clone embedded composite identifiers, or
 		//we will get back the same instance that we pass in
 		final Serializable clonedIdentifier = (Serializable) persister.getIdentifierType()
 				.deepCopy( id, source.getEntityMode(), source.getFactory() );
 		final Object result = source.get(entityName, clonedIdentifier);
 		source.setFetchProfile(previousFetchProfile);
 
 		if ( result == null ) {
 			//TODO: we should throw an exception if we really *know* for sure
 			//      that this is a detached instance, rather than just assuming
 			//throw new StaleObjectStateException(entityName, id);
 
 			// we got here because we assumed that an instance
 			// with an assigned id was detached, when it was
 			// really persistent
 			entityIsTransient(event, copyCache);
 		}
 		else {
 			( ( EventCache ) copyCache ).put( entity, result, true ); //before cascade!
 
 			final Object target = source.getPersistenceContext().unproxy(result);
 			if ( target == entity ) {
 				throw new AssertionFailure("entity was not detached");
 			}
 			else if ( !source.getEntityName(target).equals(entityName) ) {
 				throw new WrongClassException(
 						"class of the given object did not match class of persistent copy",
 						event.getRequestedId(),
 						entityName
 					);
 			}
 			else if ( isVersionChanged( entity, source, persister, target ) ) {
 				if ( source.getFactory().getStatistics().isStatisticsEnabled() ) {
 					source.getFactory().getStatisticsImplementor()
 							.optimisticFailure( entityName );
 				}
 				throw new StaleObjectStateException( entityName, id );
 			}
 
 			// cascade first, so that all unsaved objects get their
 			// copy created before we actually copy
 			cascadeOnMerge(source, persister, entity, copyCache);
 			copyValues(persister, entity, target, source, copyCache);
 
 			//copyValues works by reflection, so explicitly mark the entity instance dirty
 			markInterceptorDirty( entity, target );
 
 			event.setResult(result);
 		}
 
 	}
 
 	private void markInterceptorDirty(final Object entity, final Object target) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.extractFieldInterceptor( target );
 			if ( interceptor != null ) {
 				interceptor.dirty();
 			}
 		}
 	}
 
 	private boolean isVersionChanged(Object entity, EventSource source, EntityPersister persister, Object target) {
 		if ( ! persister.isVersioned() ) {
 			return false;
 		}
 		// for merging of versioned entities, we consider the version having
 		// been changed only when:
 		// 1) the two version values are different;
 		//      *AND*
 		// 2) The target actually represents database state!
 		//
 		// This second condition is a special case which allows
 		// an entity to be merged during the same transaction
 		// (though during a seperate operation) in which it was
 		// originally persisted/saved
 		boolean changed = ! persister.getVersionType().isSame(
 				persister.getVersion( target, source.getEntityMode() ),
 				persister.getVersion( entity, source.getEntityMode() ),
 				source.getEntityMode()
 		);
 
 		// TODO : perhaps we should additionally require that the incoming entity
 		// version be equivalent to the defined unsaved-value?
 		return changed && existsInDatabase( target, source, persister );
 	}
 
 	private boolean existsInDatabase(Object entity, EventSource source, EntityPersister persister) {
 		EntityEntry entry = source.getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			Serializable id = persister.getIdentifier( entity, source );
 			if ( id != null ) {
 				final EntityKey key = source.generateEntityKey( id, persister );
 				final Object managedEntity = source.getPersistenceContext().getEntity( key );
 				entry = source.getPersistenceContext().getEntry( managedEntity );
 			}
 		}
 
 		return entry != null && entry.isExistsInDatabase();
 	}
 
 	protected void copyValues(
 			final EntityPersister persister,
 			final Object entity,
 			final Object target,
 			final SessionImplementor source,
 			final Map copyCache) {
 		final Object[] copiedValues = TypeHelper.replace(
 				persister.getPropertyValues( entity, source.getEntityMode() ),
 				persister.getPropertyValues( target, source.getEntityMode() ),
 				persister.getPropertyTypes(),
 				source,
 				target,
 				copyCache
 		);
 
 		persister.setPropertyValues( target, copiedValues, source.getEntityMode() );
 	}
 
 	protected void copyValues(
 			final EntityPersister persister,
 			final Object entity,
 			final Object target,
 			final SessionImplementor source,
 			final Map copyCache,
 			final ForeignKeyDirection foreignKeyDirection) {
 
 		final Object[] copiedValues;
 
 		if ( foreignKeyDirection == ForeignKeyDirection.FOREIGN_KEY_TO_PARENT ) {
 			// this is the second pass through on a merge op, so here we limit the
 			// replacement to associations types (value types were already replaced
 			// during the first pass)
 			copiedValues = TypeHelper.replaceAssociations(
 					persister.getPropertyValues( entity, source.getEntityMode() ),
 					persister.getPropertyValues( target, source.getEntityMode() ),
 					persister.getPropertyTypes(),
 					source,
 					target,
 					copyCache,
 					foreignKeyDirection
 			);
 		}
 		else {
 			copiedValues = TypeHelper.replace(
 					persister.getPropertyValues( entity, source.getEntityMode() ),
 					persister.getPropertyValues( target, source.getEntityMode() ),
 					persister.getPropertyTypes(),
 					source,
 					target,
 					copyCache,
 					foreignKeyDirection
 			);
 		}
 
 		persister.setPropertyValues( target, copiedValues, source.getEntityMode() );
 	}
 
 	/**
 	 * Perform any cascades needed as part of this copy event.
 	 *
 	 * @param source The merge event being processed.
 	 * @param persister The persister of the entity being copied.
 	 * @param entity The entity being copied.
 	 * @param copyCache A cache of already copied instance.
 	 */
 	protected void cascadeOnMerge(
 		final EventSource source,
 		final EntityPersister persister,
 		final Object entity,
 		final Map copyCache
 	) {
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.BEFORE_MERGE, source )
 					.cascade(persister, entity, copyCache);
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 
 	@Override
     protected CascadingAction getCascadeAction() {
 		return CascadingAction.MERGE;
 	}
 
 	@Override
     protected Boolean getAssumedUnsaved() {
 		return Boolean.FALSE;
 	}
 
 	/**
 	 * Cascade behavior is redefined by this subclass, disable superclass behavior
 	 */
 	@Override
     protected void cascadeAfterSave(EventSource source, EntityPersister persister, Object entity, Object anything)
 	throws HibernateException {
 	}
 
 	/**
 	 * Cascade behavior is redefined by this subclass, disable superclass behavior
 	 */
 	@Override
     protected void cascadeBeforeSave(EventSource source, EntityPersister persister, Object entity, Object anything)
 	throws HibernateException {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistEventListener.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistEventListener.java
index 0aa7aaef51..ff2527790a 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistEventListener.java
@@ -1,191 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.util.Map;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.CascadingAction;
-import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.PersistentObjectException;
+import org.hibernate.engine.spi.CascadingAction;
+import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.PersistEvent;
-import org.hibernate.event.PersistEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.PersistEvent;
+import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.id.ForeignGenerator;
+import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.IdentityMap;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 
-import org.jboss.logging.Logger;
-
 /**
  * Defines the default create event listener used by hibernate for creating
  * transient entities in response to generated create events.
  *
  * @author Gavin King
  */
 public class DefaultPersistEventListener extends AbstractSaveEventListener implements PersistEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultPersistEventListener.class.getName());
 
 	/**
 	 * Handle the given create event.
 	 *
 	 * @param event The create event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onPersist(PersistEvent event) throws HibernateException {
 		onPersist( event, IdentityMap.instantiate(10) );
 	}
 
 
 	/**
 	 * Handle the given create event.
 	 *
 	 * @param event The create event to be handled.
 	 * @throws HibernateException
 	 */
 	public void onPersist(PersistEvent event, Map createCache) throws HibernateException {
 		final SessionImplementor source = event.getSession();
 		final Object object = event.getObject();
 
 		final Object entity;
 		if ( object instanceof HibernateProxy ) {
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			if ( li.isUninitialized() ) {
 				if ( li.getSession() == source ) {
 					return; //NOTE EARLY EXIT!
 				}
 				else {
 					throw new PersistentObjectException( "uninitialized proxy passed to persist()" );
 				}
 			}
 			entity = li.getImplementation();
 		}
 		else {
 			entity = object;
 		}
 
 		final String entityName;
 		if ( event.getEntityName() != null ) {
 			entityName = event.getEntityName();
 		}
 		else {
 			entityName = source.bestGuessEntityName( entity );
 			event.setEntityName( entityName );
 		}
 
 		final EntityEntry entityEntry = source.getPersistenceContext().getEntry( entity );
 		int entityState = getEntityState( entity, entityName, entityEntry, source );
 		if ( entityState == DETACHED ) {
 			// JPA 2, in its version of a "foreign generated", allows the id attribute value
 			// to be manually set by the user, even though this manual value is irrelevant.
 			// The issue is that this causes problems with the Hibernate unsaved-value strategy
 			// which comes into play here in determining detached/transient state.
 			//
 			// Detect if we have this situation and if so null out the id value and calculate the
 			// entity state again.
 
 			// NOTE: entityEntry must be null to get here, so we cannot use any of its values
 			EntityPersister persister = source.getFactory().getEntityPersister( entityName );
 			if ( ForeignGenerator.class.isInstance( persister.getIdentifierGenerator() ) ) {
                 if (LOG.isDebugEnabled() && persister.getIdentifier(entity, source) != null) LOG.debugf("Resetting entity id attribute to null for foreign generator");
 				persister.setIdentifier( entity, null, source );
 				entityState = getEntityState( entity, entityName, entityEntry, source );
 			}
 		}
 
 		switch ( entityState ) {
 			case DETACHED:
 				throw new PersistentObjectException(
 						"detached entity passed to persist: " +
 								getLoggableName( event.getEntityName(), entity )
 				);
 			case PERSISTENT:
 				entityIsPersistent( event, createCache );
 				break;
 			case TRANSIENT:
 				entityIsTransient( event, createCache );
 				break;
 			default:
 				throw new ObjectDeletedException(
 						"deleted entity passed to persist",
 						null,
 						getLoggableName( event.getEntityName(), entity )
 				);
 		}
 
 	}
 
 	protected void entityIsPersistent(PersistEvent event, Map createCache) {
         LOG.trace("Ignoring persistent instance");
 		final EventSource source = event.getSession();
 
 		//TODO: check that entry.getIdentifier().equals(requestedId)
 
 		final Object entity = source.getPersistenceContext().unproxy( event.getObject() );
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 
 		if ( createCache.put(entity, entity)==null ) {
 			//TODO: merge into one method!
 			cascadeBeforeSave(source, persister, entity, createCache);
 			cascadeAfterSave(source, persister, entity, createCache);
 		}
 
 	}
 
 	/**
 	 * Handle the given create event.
 	 *
 	 * @param event The save event to be handled.
 	 * @throws HibernateException
 	 */
 	protected void entityIsTransient(PersistEvent event, Map createCache) throws HibernateException {
 
         LOG.trace("Saving transient instance");
 
 		final EventSource source = event.getSession();
 
 		final Object entity = source.getPersistenceContext().unproxy( event.getObject() );
 
 		if ( createCache.put(entity, entity)==null ) {
 			saveWithGeneratedId( entity, event.getEntityName(), createCache, source, false );
 		}
 
 	}
 
 	@Override
     protected CascadingAction getCascadeAction() {
 		return CascadingAction.PERSIST;
 	}
 
 	@Override
     protected Boolean getAssumedUnsaved() {
 		return Boolean.TRUE;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistOnFlushEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistOnFlushEventListener.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistOnFlushEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistOnFlushEventListener.java
index 86fdd9ce7f..3f8095688e 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPersistOnFlushEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPersistOnFlushEventListener.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.engine.spi.CascadingAction;
 
 /**
  * When persist is used as the cascade action, persistOnFlush should be used
  * @author Emmanuel Bernard
  */
 public class DefaultPersistOnFlushEventListener extends DefaultPersistEventListener {
 	protected CascadingAction getCascadeAction() {
 		return CascadingAction.PERSIST_ON_FLUSH;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPostLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPostLoadEventListener.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultPostLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPostLoadEventListener.java
index cf59f21da0..ada6ffceff 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPostLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPostLoadEventListener.java
@@ -1,76 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.AssertionFailure;
 import org.hibernate.LockMode;
 import org.hibernate.action.internal.EntityIncrementVersionProcess;
 import org.hibernate.action.internal.EntityVerifyVersionProcess;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PostLoadEventListener;
+import org.hibernate.event.spi.PostLoadEvent;
+import org.hibernate.event.spi.PostLoadEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * We do 2 things here:<ul>
  * <li>Call {@link Lifecycle} interface if necessary</li>
  * <li>Perform needed {@link EntityEntry#getLockMode()} related processing</li>
  * </ul>
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class DefaultPostLoadEventListener implements PostLoadEventListener {
 	
 	public void onPostLoad(PostLoadEvent event) {
 		final Object entity = event.getEntity();
 		final EntityEntry entry = event.getSession().getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			throw new AssertionFailure( "possible non-threadsafe access to the session" );
 		}
 
 		final LockMode lockMode = entry.getLockMode();
 		if ( LockMode.PESSIMISTIC_FORCE_INCREMENT.equals( lockMode ) ) {
 			final EntityPersister persister = entry.getPersister();
 			Object nextVersion = persister.forceVersionIncrement(
 					entry.getId(), entry.getVersion(), event.getSession()
 			);
 			entry.forceLocked( entity, nextVersion );
 		}
 		else if ( LockMode.OPTIMISTIC_FORCE_INCREMENT.equals( lockMode ) ) {
 			EntityIncrementVersionProcess incrementVersion = new EntityIncrementVersionProcess( entity, entry );
 			event.getSession().getActionQueue().registerProcess( incrementVersion );
 		}
 		else if ( LockMode.OPTIMISTIC.equals( lockMode ) ) {
 			EntityVerifyVersionProcess verifyVersion = new EntityVerifyVersionProcess( entity, entry );
 			event.getSession().getActionQueue().registerProcess( verifyVersion );
 		}
 
 		if ( event.getPersister().implementsLifecycle( event.getSession().getEntityMode() ) ) {
 			//log.debug( "calling onLoad()" );
 			( ( Lifecycle ) event.getEntity() ).onLoad( event.getSession(), event.getId() );
 		}
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPreLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPreLoadEventListener.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultPreLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPreLoadEventListener.java
index 4dfd64f5c8..36b03b99b9 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultPreLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultPreLoadEventListener.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
-import org.hibernate.event.PreLoadEvent;
-import org.hibernate.event.PreLoadEventListener;
+package org.hibernate.event.internal;
+
+import org.hibernate.event.spi.PreLoadEvent;
+import org.hibernate.event.spi.PreLoadEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Called before injecting property values into a newly 
  * loaded entity instance.
  *
  * @author Gavin King
  */
 public class DefaultPreLoadEventListener implements PreLoadEventListener {
 	
 	public void onPreLoad(PreLoadEvent event) {
 		EntityPersister persister = event.getPersister();
 		event.getSession()
 			.getInterceptor()
 			.onLoad( 
 					event.getEntity(), 
 					event.getId(), 
 					event.getState(), 
 					persister.getPropertyNames(), 
 					persister.getPropertyTypes() 
 				);
 	}
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java
index 3875007163..3ebd8ec37d 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java
@@ -1,176 +1,176 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.event.spi.RefreshEvent;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.PersistentObjectException;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.engine.spi.EntityEntry;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.RefreshEvent;
-import org.hibernate.event.RefreshEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.RefreshEventListener;
 import org.hibernate.internal.util.collections.IdentityMap;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
 
 /**
  * Defines the default refresh event listener used by hibernate for refreshing entities
  * in response to generated refresh events.
  *
  * @author Steve Ebersole
  */
 public class DefaultRefreshEventListener implements RefreshEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultRefreshEventListener.class.getName());
 
 	public void onRefresh(RefreshEvent event) throws HibernateException {
 		onRefresh( event, IdentityMap.instantiate(10) );
 	}
 
 	/**
 	 * Handle the given refresh event.
 	 *
 	 * @param event The refresh event to be handled.
 	 */
 	public void onRefresh(RefreshEvent event, Map refreshedAlready) {
 
 		final EventSource source = event.getSession();
 
 		boolean isTransient = ! source.contains( event.getObject() );
 		if ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {
 			if ( isTransient ) {
 				source.setReadOnly( event.getObject(), source.isDefaultReadOnly() );
 			}
 			return;
 		}
 
 		final Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );
 
 		if ( refreshedAlready.containsKey(object) ) {
             LOG.trace("Already refreshed");
 			return;
 		}
 
 		final EntityEntry e = source.getPersistenceContext().getEntry( object );
 		final EntityPersister persister;
 		final Serializable id;
 
 		if ( e == null ) {
 			persister = source.getEntityPersister(null, object); //refresh() does not pass an entityName
 			id = persister.getIdentifier( object, event.getSession() );
             if (LOG.isTraceEnabled()) LOG.trace("Refreshing transient "
                                                 + MessageHelper.infoString(persister, id, source.getFactory()));
 			final EntityKey key = source.generateEntityKey( id, persister );
 			if ( source.getPersistenceContext().getEntry(key) != null ) {
 				throw new PersistentObjectException(
 						"attempted to refresh transient instance when persistent instance was already associated with the Session: " +
 						MessageHelper.infoString(persister, id, source.getFactory() )
 					);
 			}
 		}
 		else {
             if (LOG.isTraceEnabled()) LOG.trace("Refreshing "
                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));
 			if ( !e.isExistsInDatabase() ) {
 				throw new HibernateException( "this instance does not yet exist as a row in the database" );
 			}
 
 			persister = e.getPersister();
 			id = e.getId();
 		}
 
 		// cascade the refresh prior to refreshing this entity
 		refreshedAlready.put(object, object);
 		new Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)
 				.cascade( persister, object, refreshedAlready );
 
 		if ( e != null ) {
 			final EntityKey key = source.generateEntityKey( id, persister );
 			source.getPersistenceContext().removeEntity(key);
 			if ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);
 		}
 
 		if ( persister.hasCache() ) {
 			final CacheKey ck = source.generateCacheKey(
 					id,
 					persister.getIdentifierType(),
 					persister.getRootEntityName()
 			);
 			persister.getCacheAccessStrategy().evict( ck );
 		}
 
 		evictCachedCollections( persister, id, source.getFactory() );
 
 		String previousFetchProfile = source.getFetchProfile();
 		source.setFetchProfile("refresh");
 		Object result = persister.load( id, object, event.getLockOptions(), source );
 		// Keep the same read-only/modifiable setting for the entity that it had before refreshing;
 		// If it was transient, then set it to the default for the source.
 		if ( result != null ) {
 			if ( ! persister.isMutable() ) {
 				// this is probably redundant; it should already be read-only
 				source.setReadOnly( result, true );
 			}
 			else {
 				source.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );
 			}
 		}
 		source.setFetchProfile(previousFetchProfile);
 
 		UnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );
 
 	}
 
 	private void evictCachedCollections(EntityPersister persister, Serializable id, SessionFactoryImplementor factory) {
 		evictCachedCollections( persister.getPropertyTypes(), id, factory );
 	}
 
 	private void evictCachedCollections(Type[] types, Serializable id, SessionFactoryImplementor factory)
 	throws HibernateException {
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( types[i].isCollectionType() ) {
 				factory.evictCollection( ( (CollectionType) types[i] ).getRole(), id );
 			}
 			else if ( types[i].isComponentType() ) {
 				CompositeType actype = (CompositeType) types[i];
 				evictCachedCollections( actype.getSubtypes(), id, factory );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultReplicateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultReplicateEventListener.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultReplicateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultReplicateEventListener.java
index b07d7426aa..0cc9864675 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultReplicateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultReplicateEventListener.java
@@ -1,216 +1,216 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
+import org.hibernate.event.spi.ReplicateEvent;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.ReplicationMode;
 import org.hibernate.TransientObjectException;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.ReplicateEvent;
-import org.hibernate.event.ReplicateEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.ReplicateEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 
 /**
  * Defines the default replicate event listener used by Hibernate to replicate
  * entities in response to generated replicate events.
  *
  * @author Steve Ebersole
  */
 public class DefaultReplicateEventListener extends AbstractSaveEventListener implements ReplicateEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultReplicateEventListener.class.getName());
 
 	/**
 	 * Handle the given replicate event.
 	 *
 	 * @param event The replicate event to be handled.
 	 *
 	 * @throws TransientObjectException An invalid attempt to replicate a transient entity.
 	 */
 	public void onReplicate(ReplicateEvent event) {
 		final EventSource source = event.getSession();
 		if ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {
             LOG.trace("Uninitialized proxy passed to replicate()");
 			return;
 		}
 
 		Object entity = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );
 
 		if ( source.getPersistenceContext().isEntryFor( entity ) ) {
             LOG.trace("Ignoring persistent instance passed to replicate()");
 			//hum ... should we cascade anyway? throw an exception? fine like it is?
 			return;
 		}
 
 		EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 
 		// get the id from the object
 		/*if ( persister.isUnsaved(entity, source) ) {
 			throw new TransientObjectException("transient instance passed to replicate()");
 		}*/
 		Serializable id = persister.getIdentifier( entity, source );
 		if ( id == null ) {
 			throw new TransientObjectException( "instance with null id passed to replicate()" );
 		}
 
 		final ReplicationMode replicationMode = event.getReplicationMode();
 
 		final Object oldVersion;
 		if ( replicationMode == ReplicationMode.EXCEPTION ) {
 			//always do an INSERT, and let it fail by constraint violation
 			oldVersion = null;
 		}
 		else {
 			//what is the version on the database?
 			oldVersion = persister.getCurrentVersion( id, source );
 		}
 
 		if ( oldVersion != null ) {
             if (LOG.isTraceEnabled()) LOG.trace("Found existing row for "
                                                 + MessageHelper.infoString(persister, id, source.getFactory()));
 
 			/// HHH-2378
 			final Object realOldVersion = persister.isVersioned() ? oldVersion : null;
 
 			boolean canReplicate = replicationMode.shouldOverwriteCurrentVersion(
 					entity,
 					realOldVersion,
 					persister.getVersion( entity, source.getEntityMode() ),
 					persister.getVersionType()
 			);
 
             // if can replicate, will result in a SQL UPDATE
             // else do nothing (don't even reassociate object!)
             if (canReplicate) performReplication(entity, id, realOldVersion, persister, replicationMode, source);
             else LOG.trace("No need to replicate");
 
 			//TODO: would it be better to do a refresh from db?
 		}
 		else {
 			// no existing row - do an insert
             if (LOG.isTraceEnabled()) LOG.trace("No existing row, replicating new instance "
                                                 + MessageHelper.infoString(persister, id, source.getFactory()));
 
 			final boolean regenerate = persister.isIdentifierAssignedByInsert(); // prefer re-generation of identity!
 			final EntityKey key = regenerate ? null : source.generateEntityKey( id, persister );
 
 			performSaveOrReplicate(
 					entity,
 					key,
 					persister,
 					regenerate,
 					replicationMode,
 					source,
 					true
 			);
 
 		}
 	}
 
 	@Override
     protected boolean visitCollectionsBeforeSave(Object entity, Serializable id, Object[] values, Type[] types, EventSource source) {
 		//TODO: we use two visitors here, inefficient!
 		OnReplicateVisitor visitor = new OnReplicateVisitor( source, id, entity, false );
 		visitor.processEntityPropertyValues( values, types );
 		return super.visitCollectionsBeforeSave( entity, id, values, types, source );
 	}
 
 	@Override
     protected boolean substituteValuesIfNecessary(
 			Object entity,
 			Serializable id,
 			Object[] values,
 			EntityPersister persister,
 			SessionImplementor source) {
 		return false;
 	}
 
 	@Override
     protected boolean isVersionIncrementDisabled() {
 		return true;
 	}
 
 	private void performReplication(
 			Object entity,
 			Serializable id,
 			Object version,
 			EntityPersister persister,
 			ReplicationMode replicationMode,
 			EventSource source) throws HibernateException {
 
         if (LOG.isTraceEnabled()) LOG.trace("Replicating changes to "
                                             + MessageHelper.infoString(persister, id, source.getFactory()));
 
 		new OnReplicateVisitor( source, id, entity, true ).process( entity, persister );
 
 		source.getPersistenceContext().addEntity(
 				entity,
 				( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 				null,
 				source.generateEntityKey( id, persister ),
 				version,
 				LockMode.NONE,
 				true,
 				persister,
 				true,
 				false
 		);
 
 		cascadeAfterReplicate( entity, persister, replicationMode, source );
 	}
 
 	private void cascadeAfterReplicate(
 			Object entity,
 			EntityPersister persister,
 			ReplicationMode replicationMode,
 			EventSource source) {
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( CascadingAction.REPLICATE, Cascade.AFTER_UPDATE, source )
 					.cascade( persister, entity, replicationMode );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	@Override
     protected CascadingAction getCascadeAction() {
 		return CascadingAction.REPLICATE;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveEventListener.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveEventListener.java
index b819b6d925..9afda3c3c1 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveEventListener.java
@@ -1,78 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.Hibernate;
 import org.hibernate.PersistentObjectException;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.SaveOrUpdateEvent;
+import org.hibernate.event.spi.SaveOrUpdateEvent;
 
 /**
  * An event handler for save() events
  * @author Gavin King
  */
 public class DefaultSaveEventListener extends DefaultSaveOrUpdateEventListener {
 
 	protected Serializable performSaveOrUpdate(SaveOrUpdateEvent event) {
 		// this implementation is supposed to tolerate incorrect unsaved-value
 		// mappings, for the purpose of backward-compatibility
 		EntityEntry entry = event.getSession().getPersistenceContext().getEntry( event.getEntity() );
 		if ( entry!=null && entry.getStatus() != Status.DELETED ) {
 			return entityIsPersistent(event);
 		}
 		else {
 			return entityIsTransient(event);
 		}
 	}
 	
 	protected Serializable saveWithGeneratedOrRequestedId(SaveOrUpdateEvent event) {
 		if ( event.getRequestedId() == null ) {
 			return super.saveWithGeneratedOrRequestedId(event);
 		}
 		else {
 			return saveWithRequestedId( 
 					event.getEntity(), 
 					event.getRequestedId(), 
 					event.getEntityName(), 
 					null, 
 					event.getSession() 
 				);
 		}
 		
 	}
 
 	protected boolean reassociateIfUninitializedProxy(Object object, SessionImplementor source) {
 		if ( !Hibernate.isInitialized(object) ) {
 			throw new PersistentObjectException("uninitialized proxy passed to save()");
 		}
 		else {
 			return false;
 		}
 	}
 	
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveOrUpdateEventListener.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveOrUpdateEventListener.java
index 8c41e74a7f..5ef166f562 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultSaveOrUpdateEventListener.java
@@ -1,365 +1,365 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.event.spi.SaveOrUpdateEvent;
+import org.hibernate.event.spi.SaveOrUpdateEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.PersistentObjectException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.engine.internal.Cascade;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.SaveOrUpdateEvent;
-import org.hibernate.event.SaveOrUpdateEventListener;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 
 /**
  * Defines the default listener used by Hibernate for handling save-update
  * events.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class DefaultSaveOrUpdateEventListener extends AbstractSaveEventListener implements SaveOrUpdateEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        DefaultSaveOrUpdateEventListener.class.getName());
 
 	/**
 	 * Handle the given update event.
 	 *
 	 * @param event The update event to be handled.
 	 */
 	public void onSaveOrUpdate(SaveOrUpdateEvent event) {
 		final SessionImplementor source = event.getSession();
 		final Object object = event.getObject();
 		final Serializable requestedId = event.getRequestedId();
 
 		if ( requestedId != null ) {
 			//assign the requested id to the proxy, *before*
 			//reassociating the proxy
 			if ( object instanceof HibernateProxy ) {
 				( ( HibernateProxy ) object ).getHibernateLazyInitializer().setIdentifier( requestedId );
 			}
 		}
 
         // For an uninitialized proxy, noop, don't even need to return an id, since it is never a save()
         if (reassociateIfUninitializedProxy(object, source)) LOG.trace("Reassociated uninitialized proxy");
 		else {
 			//initialize properties of the event:
 			final Object entity = source.getPersistenceContext().unproxyAndReassociate( object );
 			event.setEntity( entity );
 			event.setEntry( source.getPersistenceContext().getEntry( entity ) );
 			//return the id in the event object
 			event.setResultId( performSaveOrUpdate( event ) );
 		}
 
 	}
 
 	protected boolean reassociateIfUninitializedProxy(Object object, SessionImplementor source) {
 		return source.getPersistenceContext().reassociateIfUninitializedProxy( object );
 	}
 
 	protected Serializable performSaveOrUpdate(SaveOrUpdateEvent event) {
 		int entityState = getEntityState(
 				event.getEntity(),
 				event.getEntityName(),
 				event.getEntry(),
 				event.getSession()
 		);
 
 		switch ( entityState ) {
 			case DETACHED:
 				entityIsDetached( event );
 				return null;
 			case PERSISTENT:
 				return entityIsPersistent( event );
 			default: //TRANSIENT or DELETED
 				return entityIsTransient( event );
 		}
 	}
 
 	protected Serializable entityIsPersistent(SaveOrUpdateEvent event) throws HibernateException {
         LOG.trace("Ignoring persistent instance");
 
 		EntityEntry entityEntry = event.getEntry();
 		if ( entityEntry == null ) {
 			throw new AssertionFailure( "entity was transient or detached" );
 		}
 		else {
 
 			if ( entityEntry.getStatus() == Status.DELETED ) {
 				throw new AssertionFailure( "entity was deleted" );
 			}
 
 			final SessionFactoryImplementor factory = event.getSession().getFactory();
 
 			Serializable requestedId = event.getRequestedId();
 
 			Serializable savedId;
 			if ( requestedId == null ) {
 				savedId = entityEntry.getId();
 			}
 			else {
 
 				final boolean isEqual = !entityEntry.getPersister().getIdentifierType()
 						.isEqual( requestedId, entityEntry.getId(), event.getSession().getEntityMode(), factory );
 
 				if ( isEqual ) {
 					throw new PersistentObjectException(
 							"object passed to save() was already persistent: " +
 									MessageHelper.infoString( entityEntry.getPersister(), requestedId, factory )
 					);
 				}
 
 				savedId = requestedId;
 
 			}
 
             if (LOG.isTraceEnabled()) LOG.trace("Object already associated with session: "
                                                 + MessageHelper.infoString(entityEntry.getPersister(), savedId, factory));
 
 			return savedId;
 
 		}
 	}
 
 	/**
 	 * The given save-update event named a transient entity.
 	 * <p/>
 	 * Here, we will perform the save processing.
 	 *
 	 * @param event The save event to be handled.
 	 *
 	 * @return The entity's identifier after saving.
 	 */
 	protected Serializable entityIsTransient(SaveOrUpdateEvent event) {
 
         LOG.trace("Saving transient instance");
 
 		final EventSource source = event.getSession();
 
 		EntityEntry entityEntry = event.getEntry();
 		if ( entityEntry != null ) {
 			if ( entityEntry.getStatus() == Status.DELETED ) {
 				source.forceFlush( entityEntry );
 			}
 			else {
 				throw new AssertionFailure( "entity was persistent" );
 			}
 		}
 
 		Serializable id = saveWithGeneratedOrRequestedId( event );
 
 		source.getPersistenceContext().reassociateProxy( event.getObject(), id );
 
 		return id;
 	}
 
 	/**
 	 * Save the transient instance, assigning the right identifier
 	 *
 	 * @param event The initiating event.
 	 *
 	 * @return The entity's identifier value after saving.
 	 */
 	protected Serializable saveWithGeneratedOrRequestedId(SaveOrUpdateEvent event) {
 		return saveWithGeneratedId(
 				event.getEntity(),
 				event.getEntityName(),
 				null,
 				event.getSession(),
 				true
 		);
 	}
 
 	/**
 	 * The given save-update event named a detached entity.
 	 * <p/>
 	 * Here, we will perform the update processing.
 	 *
 	 * @param event The update event to be handled.
 	 */
 	protected void entityIsDetached(SaveOrUpdateEvent event) {
 
         LOG.trace("Updating detached instance");
 
 		if ( event.getSession().getPersistenceContext().isEntryFor( event.getEntity() ) ) {
 			//TODO: assertion only, could be optimized away
 			throw new AssertionFailure( "entity was persistent" );
 		}
 
 		Object entity = event.getEntity();
 
 		EntityPersister persister = event.getSession().getEntityPersister( event.getEntityName(), entity );
 
 		event.setRequestedId(
 				getUpdateId(
 						entity, persister, event.getRequestedId(), event.getSession()
 				)
 		);
 
 		performUpdate( event, entity, persister );
 
 	}
 
 	/**
 	 * Determine the id to use for updating.
 	 *
 	 * @param entity The entity.
 	 * @param persister The entity persister
 	 * @param requestedId The requested identifier
 	 * @param session The session
 	 *
 	 * @return The id.
 	 *
 	 * @throws TransientObjectException If the entity is considered transient.
 	 */
 	protected Serializable getUpdateId(
 			Object entity,
 			EntityPersister persister,
 			Serializable requestedId,
 			SessionImplementor session) {
 		// use the id assigned to the instance
 		Serializable id = persister.getIdentifier( entity, session );
 		if ( id == null ) {
 			// assume this is a newly instantiated transient object
 			// which should be saved rather than updated
 			throw new TransientObjectException(
 					"The given object has a null identifier: " +
 							persister.getEntityName()
 			);
 		}
 		else {
 			return id;
 		}
 
 	}
 
 	protected void performUpdate(
 			SaveOrUpdateEvent event,
 			Object entity,
 			EntityPersister persister) throws HibernateException {
 
         if (!persister.isMutable()) LOG.trace("Immutable instance passed to performUpdate()");
 
         if (LOG.isTraceEnabled()) LOG.trace("Updating "
                                             + MessageHelper.infoString(persister,
                                                                        event.getRequestedId(),
                                                                        event.getSession().getFactory()));
 
         final EventSource source = event.getSession();
 		final EntityKey key = source.generateEntityKey( event.getRequestedId(), persister );
 
 		source.getPersistenceContext().checkUniqueness(key, entity);
 
 		if (invokeUpdateLifecycle(entity, persister, source)) {
             reassociate(event, event.getObject(), event.getRequestedId(), persister);
             return;
         }
 
 		// this is a transient object with existing persistent state not loaded by the session
 
 		new OnUpdateVisitor(source, event.getRequestedId(), entity).process(entity, persister);
 
 		// TODO: put this stuff back in to read snapshot from
         // the second-level cache (needs some extra work)
         /*Object[] cachedState = null;
 
         if ( persister.hasCache() ) {
         	CacheEntry entry = (CacheEntry) persister.getCache()
         			.get( event.getRequestedId(), source.getTimestamp() );
             cachedState = entry==null ?
             		null :
             		entry.getState(); //TODO: half-assemble this stuff
         }*/
 
 		source.getPersistenceContext().addEntity(entity, (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY), null, // cachedState,
                                                  key,
                                                  persister.getVersion(entity, source.getEntityMode()),
                                                  LockMode.NONE,
                                                  true,
                                                  persister,
                                                  false,
                                                  true // assume true, since we don't really know, and it doesn't matter
         );
 
 		persister.afterReassociate(entity, source);
 
         if (LOG.isTraceEnabled()) LOG.trace("Updating "
                                             + MessageHelper.infoString(persister, event.getRequestedId(), source.getFactory()));
 
         cascadeOnUpdate(event, persister, entity);
 	}
 
 	protected boolean invokeUpdateLifecycle(Object entity, EntityPersister persister, EventSource source) {
 		if ( persister.implementsLifecycle( source.getEntityMode() ) ) {
             LOG.debugf("Calling onUpdate()");
             if (((Lifecycle)entity).onUpdate(source)) {
                 LOG.debugf("Update vetoed by onUpdate()");
 				return true;
 			}
 		}
 		return false;
 	}
 
 	/**
 	 * Handles the calls needed to perform cascades as part of an update request
 	 * for the given entity.
 	 *
 	 * @param event The event currently being processed.
 	 * @param persister The defined persister for the entity being updated.
 	 * @param entity The entity being updated.
 	 */
 	private void cascadeOnUpdate(SaveOrUpdateEvent event, EntityPersister persister, Object entity) {
 		EventSource source = event.getSession();
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( CascadingAction.SAVE_UPDATE, Cascade.AFTER_UPDATE, source )
 					.cascade( persister, entity );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	@Override
     protected CascadingAction getCascadeAction() {
 		return CascadingAction.SAVE_UPDATE;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultUpdateEventListener.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DefaultUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DefaultUpdateEventListener.java
index c2f8e9657c..333975af2b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultUpdateEventListener.java
@@ -1,77 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.SaveOrUpdateEvent;
+import org.hibernate.event.spi.SaveOrUpdateEvent;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * An event handler for update() events
  * @author Gavin King
  */
 public class DefaultUpdateEventListener extends DefaultSaveOrUpdateEventListener {
 
 	protected Serializable performSaveOrUpdate(SaveOrUpdateEvent event) {
 		// this implementation is supposed to tolerate incorrect unsaved-value
 		// mappings, for the purpose of backward-compatibility
 		EntityEntry entry = event.getSession().getPersistenceContext().getEntry( event.getEntity() );
 		if ( entry!=null ) {
 			if ( entry.getStatus()== Status.DELETED ) {
 				throw new ObjectDeletedException( "deleted instance passed to update()", null, event.getEntityName() );
 			}
 			else {
 				return entityIsPersistent(event);
 			}
 		}
 		else {
 			entityIsDetached(event);
 			return null;
 		}
 	}
 	
 	/**
 	 * If the user specified an id, assign it to the instance and use that, 
 	 * otherwise use the id already assigned to the instance
 	 */
 	protected Serializable getUpdateId(
 			Object entity,
 			EntityPersister persister,
 			Serializable requestedId,
 			SessionImplementor session) throws HibernateException {
 		if ( requestedId == null ) {
 			return super.getUpdateId( entity, persister, requestedId, session );
 		}
 		else {
 			persister.setIdentifier( entity, requestedId, session );
 			return requestedId;
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DirtyCollectionSearchVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/DirtyCollectionSearchVisitor.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/DirtyCollectionSearchVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/DirtyCollectionSearchVisitor.java
index fea981ad47..283d4bb050 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DirtyCollectionSearchVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/DirtyCollectionSearchVisitor.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.CollectionType;
 
 /**
  * Do we have a dirty collection here?
  * 1. if it is a new application-instantiated collection, return true (does not occur anymore!)
  * 2. if it is a component, recurse
  * 3. if it is a wrappered collection, ask the collection entry
  *
  * @author Gavin King
  */
 public class DirtyCollectionSearchVisitor extends AbstractVisitor {
 
 	private boolean dirty = false;
 	private boolean[] propertyVersionability;
 
 	DirtyCollectionSearchVisitor(EventSource session, boolean[] propertyVersionability) {
 		super(session);
 		this.propertyVersionability = propertyVersionability;
 	}
 
 	boolean wasDirtyCollectionFound() {
 		return dirty;
 	}
 
 	Object processCollection(Object collection, CollectionType type)
 		throws HibernateException {
 
 		if (collection!=null) {
 
 			SessionImplementor session = getSession();
 
 			final PersistentCollection persistentCollection;
 			if ( type.isArrayType() ) {
 				 persistentCollection = session.getPersistenceContext().getCollectionHolder(collection);
 				// if no array holder we found an unwrappered array (this can't occur,
 				// because we now always call wrap() before getting to here)
 				// return (ah==null) ? true : searchForDirtyCollections(ah, type);
 			}
 			else {
 				// if not wrappered yet, its dirty (this can't occur, because
 				// we now always call wrap() before getting to here)
 				// return ( ! (obj instanceof PersistentCollection) ) ?
 				//true : searchForDirtyCollections( (PersistentCollection) obj, type );
 				persistentCollection = (PersistentCollection) collection;
 			}
 
 			if ( persistentCollection.isDirty() ) { //we need to check even if it was not initialized, because of delayed adds!
 				dirty=true;
 				return null; //NOTE: EARLY EXIT!
 			}
 		}
 
 		return null;
 	}
 
 	boolean includeEntityProperty(Object[] values, int i) {
 		return propertyVersionability[i] && super.includeEntityProperty(values, i);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/EventCache.java b/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/EventCache.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
index 127e3d66eb..ae8cf5ab94 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/EventCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
@@ -1,252 +1,251 @@
-//$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
 
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+
 import org.hibernate.AssertionFailure;
 import org.hibernate.internal.util.collections.IdentityMap;
 
 /**
  * EventCache is a Map implementation that can be used by an event
  * listener to keep track of entities involved in the operation
  * being performed. This implementation allows entities to be added
  * to the EventCache before the operation has cascaded to that
  * entity.
  * <p/>
  * The following methods can be used by event listeners (and other
  * classes) in the same package to add entities to an EventCache
  * and indicate if the operation is being performed on the entity:<p/>
  * {@link EventCache#put(Object entity, Object copy, boolean isOperatedOn)}
  * <p/>
  * The following method can be used by event listeners (and other
  * classes) in the same package to indicate that the operation is being
  * performed on an entity already in the EventCache:
  * {@link EventCache#setOperatedOn(Object entity, boolean isOperatedOn)
  *
  * @author Gail Badner
  */
 class EventCache implements Map {
 	private Map entityToCopyMap = IdentityMap.instantiate(10);
 		// key is an entity involved with the operation performed by the listener;
 		// value can be either a copy of the entity or the entity itself
 
 	private Map entityToOperatedOnFlagMap = IdentityMap.instantiate( 10 );
 	    // key is an entity involved with the operation performed by the listener;
 	    // value is a flag indicating if the listener explicitly operates on the entity
 
 	/**
 	 * Clears the EventCache.
 	 */
 	public void clear() {
 		entityToCopyMap.clear();
 		entityToOperatedOnFlagMap.clear();
 	}
 
 	/**
 	 * Returns true if this EventCache contains a mapping for the specified entity.
 	 * @param entity must be non-null
 	 * @return true if this EventCache contains a mapping for the specified entity
 	 * @throws NullPointerException if entity is null
 	 */
 	public boolean containsKey(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return entityToCopyMap.containsKey( entity );
 	}
 
 	/**
 	 * Returns true if this EventCache maps one or more entities to the specified copy.
 	 * @param copy must be non-null
 	 * @return true if this EventCache maps one or more entities to the specified copy
 	 * @throws NullPointerException if copy is null
 	 */
 	public boolean containsValue(Object copy) {
 		if ( copy == null ) {
 			throw new NullPointerException( "null copies are not supported by " + getClass().getName() );
 		}
 		return entityToCopyMap.containsValue( copy );
 	}
 
 	/**
 	 * Returns a set view of the entity-to-copy mappings contained in this EventCache.
 	 * @return set view of the entity-to-copy mappings contained in this EventCache
 	 */
 	public Set entrySet() {
 		return entityToCopyMap.entrySet();
 	}
 
 	/**
 	 * Returns the copy to which this EventCache maps the specified entity.
 	 * @param entity must be non-null
 	 * @return the copy to which this EventCache maps the specified entity
 	 * @throws NullPointerException if entity is null
 	 */
 	public Object get(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return entityToCopyMap.get( entity );
 	}
 
 	/**
 	 * Returns true if this EventCache contains no entity-copy mappings.
 	 * @return true if this EventCache contains no entity-copy mappings
 	 */
 	public boolean isEmpty() {
 		return entityToCopyMap.isEmpty();
 	}
 
 	/**
 	 * Returns a set view of the entities contained in this EventCache
 	 * @return a set view of the entities contained in this EventCache
 	 */
 	public Set keySet() {
 		return entityToCopyMap.keySet();
 	}
 
 	/**
 	 * Associates the specified entity with the specified copy in this EventCache;
 	 * @param entity must be non-null
 	 * @param copy must be non- null
 	 * @return previous copy associated with specified entity, or null if
 	 * there was no mapping for entity.
 	 * @throws NullPointerException if entity or copy is null
 	 */
 	public Object put(Object entity, Object copy) {
 		if ( entity == null || copy == null ) {
 			throw new NullPointerException( "null entities and copies are not supported by " + getClass().getName() );
 		}
 		entityToOperatedOnFlagMap.put( entity, Boolean.FALSE );
 		return entityToCopyMap.put( entity, copy );
 	}
 
 	/**
 	 * Associates the specified entity with the specified copy in this EventCache;
 	 * @param entity must be non-null
 	 * @param copy must be non- null
 	 * @param isOperatedOn indicates if the operation is performed on the entity
 	 *
 	 * @return previous copy associated with specified entity, or null if
 	 * there was no mapping for entity.
 	 * @throws NullPointerException if entity or copy is null
 	 */
 	/* package-private */ Object put(Object entity, Object copy, boolean isOperatedOn) {
 		if ( entity == null || copy == null ) {
 			throw new NullPointerException( "null entities and copies are not supported by " + getClass().getName() );
 		}
 		entityToOperatedOnFlagMap.put( entity, Boolean.valueOf( isOperatedOn ) );
 		return entityToCopyMap.put( entity, copy );
 	}
 
 	/**
 	 * Copies all of the mappings from the specified map to this EventCache
 	 * @param map keys and values must be non-null
 	 * @throws NullPointerException if any map keys or values are null
 	 */
 	public void putAll(Map map) {
 		for ( Iterator it=map.entrySet().iterator(); it.hasNext(); ) {
 			Map.Entry entry = ( Map.Entry ) it.next();
 			if ( entry.getKey() == null || entry.getValue() == null ) {
 				throw new NullPointerException( "null entities and copies are not supported by " + getClass().getName() );
 			}
 			entityToCopyMap.put( entry.getKey(), entry.getValue() );
 			entityToOperatedOnFlagMap.put( entry.getKey(), Boolean.FALSE );
 		}
 	}
 
 	/**
 	 * Removes the mapping for this entity from this EventCache if it is present
 	 * @param entity must be non-null
 	 * @return previous value associated with specified entity, or null if there was no mapping for entity.
 	 * @throws NullPointerException if entity is null
 	 */
 	public Object remove(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		entityToOperatedOnFlagMap.remove( entity );
 		return entityToCopyMap.remove( entity );
 	}
 
 	/**
 	 * Returns the number of entity-copy mappings in this EventCache
 	 * @return the number of entity-copy mappings in this EventCache
 	 */
 	public int size() {
 		return entityToCopyMap.size();
 	}
 
 	/**
 	 * Returns a collection view of the entity copies contained in this EventCache.
 	 * @return a collection view of the entity copies contained in this EventCache
 	 */
 	public Collection values() {
 		return entityToCopyMap.values();
 	}
 
 	/**
 	 * Returns true if the listener is performing the operation on the specified entity.
 	 * @param entity must be non-null
 	 * @return true if the listener is performing the operation on the specified entity.
 	 * @throws NullPointerException if entity is null
 	 */
 	public boolean isOperatedOn(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return ( ( Boolean ) entityToOperatedOnFlagMap.get( entity ) ).booleanValue();
 	}
 
 	/**
 	 * Set flag to indicate if the listener is performing the operation on the specified entity.
 	 * @param entity must be non-null and this EventCache must contain a mapping for this entity
 	 * @return true if the listener is performing the operation on the specified entity
 	 * @throws NullPointerException if entity is null
 	 * @throws AssertionFailure if this EventCache does not contain a mapping for the specified entity
 	 */
 	/* package-private */ void setOperatedOn(Object entity, boolean isOperatedOn) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		if ( ! entityToOperatedOnFlagMap.containsKey( entity ) ||
 			! entityToCopyMap.containsKey( entity ) ) {
 			throw new AssertionFailure( "called EventCache.setOperatedOn() for entity not found in EventCache" );
 		}
 		entityToOperatedOnFlagMap.put( entity, Boolean.valueOf( isOperatedOn ) );
 	}
 
 	/**
 	 * Returns the copy-entity mappings
 	 * @return the copy-entity mappings
 	 */
 	public Map invertMap() {
 		return IdentityMap.invert( entityToCopyMap );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/EvictVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/EvictVisitor.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/event/def/EvictVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/EvictVisitor.java
index f5165ace8b..d4df3c0f5c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/EvictVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/EvictVisitor.java
@@ -1,89 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
+import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.CollectionKey;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.engine.spi.CollectionEntry;
-import org.hibernate.event.EventSource;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.CollectionType;
-import org.jboss.logging.Logger;
 
 /**
  * Evict any collections referenced by the object from the session cache.
  * This will NOT pick up any collections that were dereferenced, so they
  * will be deleted (suboptimal but not exactly incorrect).
  *
  * @author Gavin King
  */
 public class EvictVisitor extends AbstractVisitor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, EvictVisitor.class.getName());
 
 	EvictVisitor(EventSource session) {
 		super(session);
 	}
 
 	@Override
     Object processCollection(Object collection, CollectionType type)
 		throws HibernateException {
 
 		if (collection!=null) evictCollection(collection, type);
 
 		return null;
 	}
 	public void evictCollection(Object value, CollectionType type) {
 
 		final Object pc;
 		if ( type.hasHolder( getSession().getEntityMode() ) ) {
 			pc = getSession().getPersistenceContext().removeCollectionHolder(value);
 		}
 		else if ( value instanceof PersistentCollection ) {
 			pc = value;
 		}
 		else {
 			return; //EARLY EXIT!
 		}
 
 		PersistentCollection collection = (PersistentCollection) pc;
 		if ( collection.unsetSession( getSession() ) ) evictCollection(collection);
 	}
 
 	private void evictCollection(PersistentCollection collection) {
 		CollectionEntry ce = (CollectionEntry) getSession().getPersistenceContext().getCollectionEntries().remove(collection);
         if (LOG.isDebugEnabled()) LOG.debugf("Evicting collection: %s",
                                              MessageHelper.collectionInfoString(ce.getLoadedPersister(),
                                                                                 ce.getLoadedKey(),
                                                                                 getSession().getFactory()));
 		if ( ce.getLoadedPersister() != null && ce.getLoadedKey() != null ) {
 			//TODO: is this 100% correct?
 			getSession().getPersistenceContext().getCollectionsByKey().remove(
 					new CollectionKey( ce.getLoadedPersister(), ce.getLoadedKey(), getSession().getEntityMode() )
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/FlushVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/FlushVisitor.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/def/FlushVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/FlushVisitor.java
index 2261cdb713..74c9d54993 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/FlushVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/FlushVisitor.java
@@ -1,71 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.internal.Collections;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.CollectionType;
 
 /**
  * Process collections reachable from an entity. This
  * visitor assumes that wrap was already performed for
  * the entity.
  *
  * @author Gavin King
  */
 public class FlushVisitor extends AbstractVisitor {
 	
 	private Object owner;
 
 	Object processCollection(Object collection, CollectionType type)
 	throws HibernateException {
 		
 		if (collection==CollectionType.UNFETCHED_COLLECTION) {
 			return null;
 		}
 
 		if (collection!=null) {
 			final PersistentCollection coll;
 			if ( type.hasHolder( getSession().getEntityMode() ) ) {
 				coll = getSession().getPersistenceContext().getCollectionHolder(collection);
 			}
 			else {
 				coll = (PersistentCollection) collection;
 			}
 
 			Collections.processReachableCollection( coll, type, owner, getSession() );
 		}
 
 		return null;
 
 	}
 
 	FlushVisitor(EventSource session, Object owner) {
 		super(session);
 		this.owner = owner;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/OnLockVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/OnLockVisitor.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/OnLockVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/OnLockVisitor.java
index 9a2129c9c8..344f792538 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/OnLockVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/OnLockVisitor.java
@@ -1,89 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.CollectionType;
 
 /**
  * When a transient entity is passed to lock(), we must inspect all its collections and
  * 1. associate any uninitialized PersistentCollections with this session
  * 2. associate any initialized PersistentCollections with this session, using the
  * existing snapshot
  * 3. throw an exception for each "new" collection
  *
  * @author Gavin King
  */
 public class OnLockVisitor extends ReattachVisitor {
 
 	public OnLockVisitor(EventSource session, Serializable key, Object owner) {
 		super( session, key, owner );
 	}
 
 	Object processCollection(Object collection, CollectionType type) throws HibernateException {
 
 		SessionImplementor session = getSession();
 		CollectionPersister persister = session.getFactory().getCollectionPersister( type.getRole() );
 
 		if ( collection == null ) {
 			//do nothing
 		}
 		else if ( collection instanceof PersistentCollection ) {
 			PersistentCollection persistentCollection = ( PersistentCollection ) collection;
 			if ( persistentCollection.setCurrentSession( session ) ) {
 				if ( isOwnerUnchanged( persistentCollection, persister, extractCollectionKeyFromOwner( persister ) ) ) {
 					// a "detached" collection that originally belonged to the same entity
 					if ( persistentCollection.isDirty() ) {
 						throw new HibernateException( "reassociated object has dirty collection" );
 					}
 					reattachCollection( persistentCollection, type );
 				}
 				else {
 					// a "detached" collection that belonged to a different entity
 					throw new HibernateException( "reassociated object has dirty collection reference" );
 				}
 			}
 			else {
 				// a collection loaded in the current session
 				// can not possibly be the collection belonging
 				// to the entity passed to update()
 				throw new HibernateException( "reassociated object has dirty collection reference" );
 			}
 		}
 		else {
 			// brand new collection
 			//TODO: or an array!! we can't lock objects with arrays now??
 			throw new HibernateException( "reassociated object has dirty collection reference (or an array)" );
 		}
 
 		return null;
 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/OnReplicateVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/OnReplicateVisitor.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/OnReplicateVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/OnReplicateVisitor.java
index b71bb33325..3710c9ec26 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/OnReplicateVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/OnReplicateVisitor.java
@@ -1,87 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.CollectionType;
 
 /**
  * When an entity is passed to replicate(), and there is an existing row, we must
  * inspect all its collections and
  * 1. associate any uninitialized PersistentCollections with this session
  * 2. associate any initialized PersistentCollections with this session, using the
  * existing snapshot
  * 3. execute a collection removal (SQL DELETE) for each null collection property
  * or "new" collection
  *
  * @author Gavin King
  */
 public class OnReplicateVisitor extends ReattachVisitor {
 
 	private boolean isUpdate;
 
 	OnReplicateVisitor(EventSource session, Serializable key, Object owner, boolean isUpdate) {
 		super( session, key, owner );
 		this.isUpdate = isUpdate;
 	}
 
 	Object processCollection(Object collection, CollectionType type)
 			throws HibernateException {
 
 		if ( collection == CollectionType.UNFETCHED_COLLECTION ) {
 			return null;
 		}
 
 		EventSource session = getSession();
 		CollectionPersister persister = session.getFactory().getCollectionPersister( type.getRole() );
 
 		if ( isUpdate ) {
 			removeCollection( persister, extractCollectionKeyFromOwner( persister ), session );
 		}
 		if ( collection != null && ( collection instanceof PersistentCollection ) ) {
 			PersistentCollection wrapper = ( PersistentCollection ) collection;
 			wrapper.setCurrentSession( session );
 			if ( wrapper.wasInitialized() ) {
 				session.getPersistenceContext().addNewCollection( persister, wrapper );
 			}
 			else {
 				reattachCollection( wrapper, type );
 			}
 		}
 		else {
 			// otherwise a null or brand new collection
 			// this will also (inefficiently) handle arrays, which
 			// have no snapshot, so we can't do any better
 			//processArrayOrNewCollection(collection, type);
 		}
 
 		return null;
 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/OnUpdateVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/OnUpdateVisitor.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/OnUpdateVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/OnUpdateVisitor.java
index cc4b58d78d..48932d6bfd 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/OnUpdateVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/OnUpdateVisitor.java
@@ -1,90 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.CollectionType;
 
 /**
  * When an entity is passed to update(), we must inspect all its collections and
  * 1. associate any uninitialized PersistentCollections with this session
  * 2. associate any initialized PersistentCollections with this session, using the
  *    existing snapshot
  * 3. execute a collection removal (SQL DELETE) for each null collection property
  *    or "new" collection
  *
  * @author Gavin King
  */
 public class OnUpdateVisitor extends ReattachVisitor {
 
 	OnUpdateVisitor(EventSource session, Serializable key, Object owner) {
 		super( session, key, owner );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	Object processCollection(Object collection, CollectionType type) throws HibernateException {
 
 		if ( collection == CollectionType.UNFETCHED_COLLECTION ) {
 			return null;
 		}
 
 		EventSource session = getSession();
 		CollectionPersister persister = session.getFactory().getCollectionPersister( type.getRole() );
 
 		final Serializable collectionKey = extractCollectionKeyFromOwner( persister );
 		if ( collection!=null && (collection instanceof PersistentCollection) ) {
 			PersistentCollection wrapper = (PersistentCollection) collection;
 			if ( wrapper.setCurrentSession(session) ) {
 				//a "detached" collection!
 				if ( !isOwnerUnchanged( wrapper, persister, collectionKey ) ) {
 					// if the collection belonged to a different entity,
 					// clean up the existing state of the collection
 					removeCollection( persister, collectionKey, session );
 				}
 				reattachCollection(wrapper, type);
 			}
 			else {
 				// a collection loaded in the current session
 				// can not possibly be the collection belonging
 				// to the entity passed to update()
 				removeCollection(persister, collectionKey, session);
 			}
 		}
 		else {
 			// null or brand new collection
 			// this will also (inefficiently) handle arrays, which have
 			// no snapshot, so we can't do any better
 			removeCollection(persister, collectionKey, session);
 		}
 
 		return null;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/ProxyVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/ProxyVisitor.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/def/ProxyVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/ProxyVisitor.java
index 4c6eef49af..1a3f7102ba 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/ProxyVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/ProxyVisitor.java
@@ -1,100 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 
 /**
  * Reassociates uninitialized proxies with the session
  * @author Gavin King
  */
 public abstract class ProxyVisitor extends AbstractVisitor {
 
 
 	public ProxyVisitor(EventSource session) {
 		super(session);
 	}
 
 	Object processEntity(Object value, EntityType entityType) throws HibernateException {
 
 		if (value!=null) {
 			getSession().getPersistenceContext().reassociateIfUninitializedProxy(value);
 			// if it is an initialized proxy, let cascade
 			// handle it later on
 		}
 
 		return null;
 	}
 
 	/**
 	 * Has the owner of the collection changed since the collection
 	 * was snapshotted and detached?
 	 */
 	protected static boolean isOwnerUnchanged(
 			final PersistentCollection snapshot, 
 			final CollectionPersister persister, 
 			final Serializable id
 	) {
 		return isCollectionSnapshotValid(snapshot) &&
 				persister.getRole().equals( snapshot.getRole() ) &&
 				id.equals( snapshot.getKey() );
 	}
 
 	private static boolean isCollectionSnapshotValid(PersistentCollection snapshot) {
 		return snapshot != null &&
 				snapshot.getRole() != null &&
 				snapshot.getKey() != null;
 	}
 	
 	/**
 	 * Reattach a detached (disassociated) initialized or uninitialized
 	 * collection wrapper, using a snapshot carried with the collection
 	 * wrapper
 	 */
 	protected void reattachCollection(PersistentCollection collection, CollectionType type)
 	throws HibernateException {
 		if ( collection.wasInitialized() ) {
 			CollectionPersister collectionPersister = getSession().getFactory()
 			.getCollectionPersister( type.getRole() );
 			getSession().getPersistenceContext()
 				.addInitializedDetachedCollection( collectionPersister, collection );
 		}
 		else {
 			if ( !isCollectionSnapshotValid(collection) ) {
 				throw new HibernateException( "could not reassociate uninitialized transient collection" );
 			}
 			CollectionPersister collectionPersister = getSession().getFactory()
 					.getCollectionPersister( collection.getRole() );
 			getSession().getPersistenceContext()
 				.addUninitializedDetachedCollection( collectionPersister, collection );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/ReattachVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/ReattachVisitor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/ReattachVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/ReattachVisitor.java
index aed42622f0..123d024b92 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/ReattachVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/ReattachVisitor.java
@@ -1,117 +1,120 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
 import java.io.Serializable;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateException;
-import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.action.internal.CollectionRemoveAction;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
-import org.jboss.logging.Logger;
 
 /**
  * Abstract superclass of visitors that reattach collections.
  *
  * @author Gavin King
  */
 public abstract class ReattachVisitor extends ProxyVisitor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, ReattachVisitor.class.getName());
 
 	private final Serializable ownerIdentifier;
 	private final Object owner;
 
 	public ReattachVisitor(EventSource session, Serializable ownerIdentifier, Object owner) {
 		super( session );
 		this.ownerIdentifier = ownerIdentifier;
 		this.owner = owner;
 	}
 
 	/**
 	 * Retrieve the identifier of the entity being visited.
 	 *
 	 * @return The entity's identifier.
 	 */
 	final Serializable getOwnerIdentifier() {
 		return ownerIdentifier;
 	}
 
 	/**
 	 * Retrieve the entity being visited.
 	 *
 	 * @return The entity.
 	 */
 	final Object getOwner() {
 		return owner;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     Object processComponent(Object component, CompositeType componentType) throws HibernateException {
 		Type[] types = componentType.getSubtypes();
 		if ( component == null ) {
 			processValues( new Object[types.length], types );
 		}
 		else {
 			super.processComponent( component, componentType );
 		}
 
 		return null;
 	}
 
 	/**
 	 * Schedules a collection for deletion.
 	 *
 	 * @param role The persister representing the collection to be removed.
 	 * @param collectionKey The collection key (differs from owner-id in the case of property-refs).
 	 * @param source The session from which the request originated.
 	 * @throws HibernateException
 	 */
 	void removeCollection(CollectionPersister role, Serializable collectionKey, EventSource source) throws HibernateException {
         if (LOG.isTraceEnabled()) LOG.trace("Collection dereferenced while transient "
                                             + MessageHelper.collectionInfoString(role, ownerIdentifier, source.getFactory()));
 		source.getActionQueue().addAction( new CollectionRemoveAction( owner, role, collectionKey, false, source ) );
 	}
 
 	/**
 	 * This version is slightly different for say
 	 * {@link org.hibernate.type.CollectionType#getKeyOfOwner} in that here we
 	 * need to assume that the owner is not yet associated with the session,
 	 * and thus we cannot rely on the owner's EntityEntry snapshot...
 	 *
 	 * @param role The persister for the collection role being processed.
 	 * @return
 	 */
 	final Serializable extractCollectionKeyFromOwner(CollectionPersister role) {
         if (role.getCollectionType().useLHSPrimaryKey()) return ownerIdentifier;
         return (Serializable)role.getOwnerEntityPersister().getPropertyValue(owner,
                                                                              role.getCollectionType().getLHSPropertyName(),
                                                                              getSession().getEntityMode());
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/WrapVisitor.java b/hibernate-core/src/main/java/org/hibernate/event/internal/WrapVisitor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/event/def/WrapVisitor.java
rename to hibernate-core/src/main/java/org/hibernate/event/internal/WrapVisitor.java
index a5ea091c07..32a96bafaf 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/WrapVisitor.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/WrapVisitor.java
@@ -1,161 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event.def;
+package org.hibernate.event.internal;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.PersistenceContext;
-import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
-import org.jboss.logging.Logger;
 
 /**
  * Wrap collections in a Hibernate collection
  * wrapper.
  * @author Gavin King
  */
 public class WrapVisitor extends ProxyVisitor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, WrapVisitor.class.getName());
 
 	boolean substitute = false;
 
 	boolean isSubstitutionRequired() {
 		return substitute;
 	}
 
 	WrapVisitor(EventSource session) {
 		super(session);
 	}
 
 	@Override
     Object processCollection(Object collection, CollectionType collectionType)
 	throws HibernateException {
 
 		if ( collection!=null && (collection instanceof PersistentCollection) ) {
 
 			final SessionImplementor session = getSession();
 			PersistentCollection coll = (PersistentCollection) collection;
 			if ( coll.setCurrentSession(session) ) {
 				reattachCollection( coll, collectionType );
 			}
 			return null;
 
 		}
 		else {
 			return processArrayOrNewCollection(collection, collectionType);
 		}
 
 	}
 
 	final Object processArrayOrNewCollection(Object collection, CollectionType collectionType)
 	throws HibernateException {
 
 		final SessionImplementor session = getSession();
 
 		if (collection==null) {
 			//do nothing
 			return null;
 		}
 		else {
 			CollectionPersister persister = session.getFactory().getCollectionPersister( collectionType.getRole() );
 
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			//TODO: move into collection type, so we can use polymorphism!
 			if ( collectionType.hasHolder( session.getEntityMode() ) ) {
 
 				if (collection==CollectionType.UNFETCHED_COLLECTION) return null;
 
 				PersistentCollection ah = persistenceContext.getCollectionHolder(collection);
 				if (ah==null) {
 					ah = collectionType.wrap(session, collection);
 					persistenceContext.addNewCollection( persister, ah );
 					persistenceContext.addCollectionHolder(ah);
 				}
 				return null;
 			}
 			else {
 
 				PersistentCollection persistentCollection = collectionType.wrap(session, collection);
 				persistenceContext.addNewCollection( persister, persistentCollection );
 
                 if (LOG.isTraceEnabled()) LOG.trace("Wrapped collection in role: " + collectionType.getRole());
 
 				return persistentCollection; //Force a substitution!
 
 			}
 
 		}
 
 	}
 
 	@Override
     void processValue(int i, Object[] values, Type[] types) {
 		Object result = processValue( values[i], types[i] );
 		if (result!=null) {
 			substitute = true;
 			values[i] = result;
 		}
 	}
 
 	@Override
     Object processComponent(Object component, CompositeType componentType)
 	throws HibernateException {
 
 		if (component!=null) {
 			Object[] values = componentType.getPropertyValues( component, getSession() );
 			Type[] types = componentType.getSubtypes();
 			boolean substituteComponent = false;
 			for ( int i=0; i<types.length; i++ ) {
 				Object result = processValue( values[i], types[i] );
 				if (result!=null) {
 					values[i] = result;
 					substituteComponent = true;
 				}
 			}
 			if (substituteComponent) {
 				componentType.setPropertyValues( component, values, getSession().getEntityMode() );
 			}
 		}
 
 		return null;
 	}
 
 	@Override
     void process(Object object, EntityPersister persister) throws HibernateException {
 		EntityMode entityMode = getSession().getEntityMode();
 		Object[] values = persister.getPropertyValues( object, entityMode );
 		Type[] types = persister.getPropertyTypes();
 		processEntityPropertyValues(values, types);
 		if ( isSubstitutionRequired() ) {
 			persister.setPropertyValues( object, values, entityMode );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/package.html b/hibernate-core/src/main/java/org/hibernate/event/internal/package.html
similarity index 100%
rename from hibernate-core/src/main/java/org/hibernate/event/def/package.html
rename to hibernate-core/src/main/java/org/hibernate/event/internal/package.html
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java
index c099edcd90..cd2786e564 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java
@@ -1,178 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.internal;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistrationException;
 
 /**
  * @author Steve Ebersole
  */
 public class EventListenerGroupImpl<T> implements EventListenerGroup<T> {
 	private EventType<T> eventType;
 
 	private final Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<DuplicationStrategy>();
 	private List<T> listeners;
 
 	public EventListenerGroupImpl(EventType<T> eventType) {
 		this.eventType = eventType;
 		duplicationStrategies.add(
 				// At minimum make sure we do not register the same exact listener class multiple times.
 				new DuplicationStrategy() {
 					@Override
 					public boolean areMatch(Object listener, Object original) {
 						return listener.getClass().equals( original.getClass() );
 					}
 
 					@Override
 					public Action getAction() {
 						return Action.ERROR;
 					}
 				}
 		);
 	}
 
 	@Override
 	public EventType<T> getEventType() {
 		return eventType;
 	}
 
 	@Override
 	public boolean isEmpty() {
 		return count() <= 0;
 	}
 
 	@Override
 	public int count() {
 		return listeners == null ? 0 : listeners.size();
 	}
 
 	@Override
 	public void clear() {
 		if ( duplicationStrategies != null ) {
 			duplicationStrategies.clear();
 		}
 		if ( listeners != null ) {
 			listeners.clear();
 		}
 	}
 
 	@Override
 	public void addDuplicationStrategy(DuplicationStrategy strategy) {
 		duplicationStrategies.add( strategy );
 	}
 
 	public Iterable<T> listeners() {
 		return listeners == null ? Collections.<T>emptyList() : listeners;
 	}
 
 	@Override
 	public void appendListeners(T... listeners) {
 		for ( T listener : listeners ) {
 			appendListener( listener );
 		}
 	}
 
 	@Override
 	public void appendListener(T listener) {
 		if ( listenerShouldGetAdded( listener ) ) {
 			internalAppend( listener );
 		}
 	}
 
 	@Override
 	public void prependListeners(T... listeners) {
 		for ( T listener : listeners ) {
 			prependListener( listener );
 		}
 	}
 
 	@Override
 	public void prependListener(T listener) {
 		if ( listenerShouldGetAdded( listener ) ) {
 			internalPrepend( listener );
 		}
 	}
 
 	private boolean listenerShouldGetAdded(T listener) {
 		if ( listeners == null ) {
 			listeners = new ArrayList<T>();
 			return true;
 			// no need to do de-dup checks
 		}
 
 		boolean doAdd = true;
 		strategy_loop: for ( DuplicationStrategy strategy : duplicationStrategies ) {
 			final ListIterator<T> itr = listeners.listIterator();
 			while ( itr.hasNext() ) {
 				final T existingListener = itr.next();
 				if ( strategy.areMatch( listener,  existingListener ) ) {
 					switch ( strategy.getAction() ) {
 						// todo : add debug logging of what happens here...
 						case ERROR: {
 							throw new EventListenerRegistrationException( "Duplicate event listener found" );
 						}
 						case KEEP_ORIGINAL: {
 							doAdd = false;
 							break strategy_loop;
 						}
 						case REPLACE_ORIGINAL: {
 							itr.set( listener );
 							doAdd = false;
 							break strategy_loop;
 						}
 					}
 				}
 			}
 		}
 		return doAdd;
 	}
 
 	private void internalPrepend(T listener) {
 		checkAgainstBaseInterface( listener );
 		listeners.add( 0, listener );
 	}
 
 	private void checkAgainstBaseInterface(T listener) {
 		if ( !eventType.baseListenerInterface().isInstance( listener ) ) {
 			throw new EventListenerRegistrationException(
 					"Listener did not implement expected interface [" + eventType.baseListenerInterface().getName() + "]"
 			);
 		}
 	}
 
 	private void internalAppend(T listener) {
 		checkAgainstBaseInterface( listener );
 		listeners.add( listener );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerRegistryImpl.java
index b96bb46b9f..770efb958f 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerRegistryImpl.java
@@ -1,423 +1,423 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.internal;
 
 import java.lang.reflect.Array;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
-import org.hibernate.event.EventType;
-import org.hibernate.event.def.DefaultAutoFlushEventListener;
-import org.hibernate.event.def.DefaultDeleteEventListener;
-import org.hibernate.event.def.DefaultDirtyCheckEventListener;
-import org.hibernate.event.def.DefaultEvictEventListener;
-import org.hibernate.event.def.DefaultFlushEntityEventListener;
-import org.hibernate.event.def.DefaultFlushEventListener;
-import org.hibernate.event.def.DefaultInitializeCollectionEventListener;
-import org.hibernate.event.def.DefaultLoadEventListener;
-import org.hibernate.event.def.DefaultLockEventListener;
-import org.hibernate.event.def.DefaultMergeEventListener;
-import org.hibernate.event.def.DefaultPersistEventListener;
-import org.hibernate.event.def.DefaultPersistOnFlushEventListener;
-import org.hibernate.event.def.DefaultPostLoadEventListener;
-import org.hibernate.event.def.DefaultPreLoadEventListener;
-import org.hibernate.event.def.DefaultRefreshEventListener;
-import org.hibernate.event.def.DefaultReplicateEventListener;
-import org.hibernate.event.def.DefaultSaveEventListener;
-import org.hibernate.event.def.DefaultSaveOrUpdateEventListener;
-import org.hibernate.event.def.DefaultUpdateEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.internal.DefaultAutoFlushEventListener;
+import org.hibernate.event.internal.DefaultDeleteEventListener;
+import org.hibernate.event.internal.DefaultDirtyCheckEventListener;
+import org.hibernate.event.internal.DefaultEvictEventListener;
+import org.hibernate.event.internal.DefaultFlushEntityEventListener;
+import org.hibernate.event.internal.DefaultFlushEventListener;
+import org.hibernate.event.internal.DefaultInitializeCollectionEventListener;
+import org.hibernate.event.internal.DefaultLoadEventListener;
+import org.hibernate.event.internal.DefaultLockEventListener;
+import org.hibernate.event.internal.DefaultMergeEventListener;
+import org.hibernate.event.internal.DefaultPersistEventListener;
+import org.hibernate.event.internal.DefaultPersistOnFlushEventListener;
+import org.hibernate.event.internal.DefaultPostLoadEventListener;
+import org.hibernate.event.internal.DefaultPreLoadEventListener;
+import org.hibernate.event.internal.DefaultRefreshEventListener;
+import org.hibernate.event.internal.DefaultReplicateEventListener;
+import org.hibernate.event.internal.DefaultSaveEventListener;
+import org.hibernate.event.internal.DefaultSaveOrUpdateEventListener;
+import org.hibernate.event.internal.DefaultUpdateEventListener;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerRegistrationException;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
-import static org.hibernate.event.EventType.AUTO_FLUSH;
-import static org.hibernate.event.EventType.DELETE;
-import static org.hibernate.event.EventType.DIRTY_CHECK;
-import static org.hibernate.event.EventType.EVICT;
-import static org.hibernate.event.EventType.FLUSH;
-import static org.hibernate.event.EventType.FLUSH_ENTITY;
-import static org.hibernate.event.EventType.INIT_COLLECTION;
-import static org.hibernate.event.EventType.LOAD;
-import static org.hibernate.event.EventType.LOCK;
-import static org.hibernate.event.EventType.MERGE;
-import static org.hibernate.event.EventType.PERSIST;
-import static org.hibernate.event.EventType.PERSIST_ONFLUSH;
-import static org.hibernate.event.EventType.POST_COLLECTION_RECREATE;
-import static org.hibernate.event.EventType.POST_COLLECTION_REMOVE;
-import static org.hibernate.event.EventType.POST_COLLECTION_UPDATE;
-import static org.hibernate.event.EventType.POST_COMMIT_DELETE;
-import static org.hibernate.event.EventType.POST_COMMIT_INSERT;
-import static org.hibernate.event.EventType.POST_COMMIT_UPDATE;
-import static org.hibernate.event.EventType.POST_DELETE;
-import static org.hibernate.event.EventType.POST_INSERT;
-import static org.hibernate.event.EventType.POST_LOAD;
-import static org.hibernate.event.EventType.POST_UPDATE;
-import static org.hibernate.event.EventType.PRE_COLLECTION_RECREATE;
-import static org.hibernate.event.EventType.PRE_COLLECTION_REMOVE;
-import static org.hibernate.event.EventType.PRE_COLLECTION_UPDATE;
-import static org.hibernate.event.EventType.PRE_DELETE;
-import static org.hibernate.event.EventType.PRE_INSERT;
-import static org.hibernate.event.EventType.PRE_LOAD;
-import static org.hibernate.event.EventType.PRE_UPDATE;
-import static org.hibernate.event.EventType.REFRESH;
-import static org.hibernate.event.EventType.REPLICATE;
-import static org.hibernate.event.EventType.SAVE;
-import static org.hibernate.event.EventType.SAVE_UPDATE;
-import static org.hibernate.event.EventType.UPDATE;
+import static org.hibernate.event.spi.EventType.AUTO_FLUSH;
+import static org.hibernate.event.spi.EventType.DELETE;
+import static org.hibernate.event.spi.EventType.DIRTY_CHECK;
+import static org.hibernate.event.spi.EventType.EVICT;
+import static org.hibernate.event.spi.EventType.FLUSH;
+import static org.hibernate.event.spi.EventType.FLUSH_ENTITY;
+import static org.hibernate.event.spi.EventType.INIT_COLLECTION;
+import static org.hibernate.event.spi.EventType.LOAD;
+import static org.hibernate.event.spi.EventType.LOCK;
+import static org.hibernate.event.spi.EventType.MERGE;
+import static org.hibernate.event.spi.EventType.PERSIST;
+import static org.hibernate.event.spi.EventType.PERSIST_ONFLUSH;
+import static org.hibernate.event.spi.EventType.POST_COLLECTION_RECREATE;
+import static org.hibernate.event.spi.EventType.POST_COLLECTION_REMOVE;
+import static org.hibernate.event.spi.EventType.POST_COLLECTION_UPDATE;
+import static org.hibernate.event.spi.EventType.POST_COMMIT_DELETE;
+import static org.hibernate.event.spi.EventType.POST_COMMIT_INSERT;
+import static org.hibernate.event.spi.EventType.POST_COMMIT_UPDATE;
+import static org.hibernate.event.spi.EventType.POST_DELETE;
+import static org.hibernate.event.spi.EventType.POST_INSERT;
+import static org.hibernate.event.spi.EventType.POST_LOAD;
+import static org.hibernate.event.spi.EventType.POST_UPDATE;
+import static org.hibernate.event.spi.EventType.PRE_COLLECTION_RECREATE;
+import static org.hibernate.event.spi.EventType.PRE_COLLECTION_REMOVE;
+import static org.hibernate.event.spi.EventType.PRE_COLLECTION_UPDATE;
+import static org.hibernate.event.spi.EventType.PRE_DELETE;
+import static org.hibernate.event.spi.EventType.PRE_INSERT;
+import static org.hibernate.event.spi.EventType.PRE_LOAD;
+import static org.hibernate.event.spi.EventType.PRE_UPDATE;
+import static org.hibernate.event.spi.EventType.REFRESH;
+import static org.hibernate.event.spi.EventType.REPLICATE;
+import static org.hibernate.event.spi.EventType.SAVE;
+import static org.hibernate.event.spi.EventType.SAVE_UPDATE;
+import static org.hibernate.event.spi.EventType.UPDATE;
 
 /**
  * @author Steve Ebersole
  */
 public class EventListenerRegistryImpl implements EventListenerRegistry {
 	private Map<Class,Object> listenerClassToInstanceMap = new HashMap<Class, Object>();
 
 	private Map<EventType,EventListenerGroupImpl> registeredEventListenersMap = prepareListenerMap();
 
 	@SuppressWarnings({ "unchecked" })
 	public <T> EventListenerGroupImpl<T> getEventListenerGroup(EventType<T> eventType) {
 		EventListenerGroupImpl<T> listeners = registeredEventListenersMap.get( eventType );
 		if ( listeners == null ) {
 			throw new HibernateException( "Unable to find listeners for type [" + eventType.eventName() + "]" );
 		}
 		return listeners;
 	}
 
 	@Override
 	public void addDuplicationStrategy(DuplicationStrategy strategy) {
 		for ( EventListenerGroupImpl group : registeredEventListenersMap.values() ) {
 			group.addDuplicationStrategy( strategy );
 		}
 	}
 
 	@Override
 	public <T> void setListeners(EventType<T> type, Class<T>... listenerClasses) {
 		setListeners( type, resolveListenerInstances( type, listenerClasses ) );
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private <T> T[] resolveListenerInstances(EventType<T> type, Class<T>... listenerClasses) {
 		T[] listeners = (T[]) Array.newInstance( type.baseListenerInterface(), listenerClasses.length );
 		for ( int i = 0; i < listenerClasses.length; i++ ) {
 			listeners[i] = resolveListenerInstance( listenerClasses[i] );
 		}
 		return listeners;
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private <T> T resolveListenerInstance(Class<T> listenerClass) {
 		T listenerInstance = (T) listenerClassToInstanceMap.get( listenerClass );
 		if ( listenerInstance == null ) {
 			listenerInstance = instantiateListener( listenerClass );
 			listenerClassToInstanceMap.put( listenerClass, listenerInstance );
 		}
 		return listenerInstance;
 	}
 
 	private <T> T instantiateListener(Class<T> listenerClass) {
 		try {
 			return listenerClass.newInstance();
 		}
 		catch ( Exception e ) {
 			throw new EventListenerRegistrationException(
 					"Unable to instantiate specified event listener class: " + listenerClass.getName(),
 					e
 			);
 		}
 	}
 
 	@Override
 	public <T> void setListeners(EventType<T> type, T... listeners) {
 		EventListenerGroupImpl<T> registeredListeners = getEventListenerGroup( type );
 		registeredListeners.clear();
 		if ( listeners != null ) {
 			for ( int i = 0, max = listeners.length; i < max; i++ ) {
 				registeredListeners.appendListener( listeners[i] );
 			}
 		}
 	}
 
 	@Override
 	public <T> void appendListeners(EventType<T> type, Class<T>... listenerClasses) {
 		appendListeners( type, resolveListenerInstances( type, listenerClasses ) );
 	}
 
 	@Override
 	public <T> void appendListeners(EventType<T> type, T... listeners) {
 		getEventListenerGroup( type ).appendListeners( listeners );
 	}
 
 	@Override
 	public <T> void prependListeners(EventType<T> type, Class<T>... listenerClasses) {
 		prependListeners( type, resolveListenerInstances( type, listenerClasses ) );
 	}
 
 	@Override
 	public <T> void prependListeners(EventType<T> type, T... listeners) {
 		getEventListenerGroup( type ).prependListeners( listeners );
 	}
 
 	private static Map<EventType,EventListenerGroupImpl> prepareListenerMap() {
 		final Map<EventType,EventListenerGroupImpl> workMap = new HashMap<EventType, EventListenerGroupImpl>();
 
 		// auto-flush listeners
 		prepareListeners(
 				AUTO_FLUSH,
 				new DefaultAutoFlushEventListener(),
 				workMap
 		);
 
 		// create listeners
 		prepareListeners(
 				PERSIST,
 				new DefaultPersistEventListener(),
 				workMap
 		);
 
 		// create-onflush listeners
 		prepareListeners(
 				PERSIST_ONFLUSH,
 				new DefaultPersistOnFlushEventListener(),
 				workMap
 		);
 
 		// delete listeners
 		prepareListeners(
 				DELETE,
 				new DefaultDeleteEventListener(),
 				workMap
 		);
 
 		// dirty-check listeners
 		prepareListeners(
 				DIRTY_CHECK,
 				new DefaultDirtyCheckEventListener(),
 				workMap
 		);
 
 		// evict listeners
 		prepareListeners(
 				EVICT,
 				new DefaultEvictEventListener(),
 				workMap
 		);
 
 		// flush listeners
 		prepareListeners(
 				FLUSH,
 				new DefaultFlushEventListener(),
 				workMap
 		);
 
 		// flush-entity listeners
 		prepareListeners(
 				FLUSH_ENTITY,
 				new DefaultFlushEntityEventListener(),
 				workMap
 		);
 
 		// load listeners
 		prepareListeners(
 				LOAD,
 				new DefaultLoadEventListener(),
 				workMap
 		);
 
 		// load-collection listeners
 		prepareListeners(
 				INIT_COLLECTION,
 				new DefaultInitializeCollectionEventListener(),
 				workMap
 		);
 
 		// lock listeners
 		prepareListeners(
 				LOCK,
 				new DefaultLockEventListener(),
 				workMap
 		);
 
 		// merge listeners
 		prepareListeners(
 				MERGE,
 				new DefaultMergeEventListener(),
 				workMap
 		);
 
 		// pre-collection-recreate listeners
 		prepareListeners(
 				PRE_COLLECTION_RECREATE,
 				workMap
 		);
 
 		// pre-collection-remove listeners
 		prepareListeners(
 				PRE_COLLECTION_REMOVE,
 				workMap
 		);
 
 		// pre-collection-update listeners
 		prepareListeners(
 				PRE_COLLECTION_UPDATE,
 				workMap
 		);
 
 		// pre-delete listeners
 		prepareListeners(
 				PRE_DELETE,
 				workMap
 		);
 
 		// pre-insert listeners
 		prepareListeners(
 				PRE_INSERT,
 				workMap
 		);
 
 		// pre-load listeners
 		prepareListeners(
 				PRE_LOAD,
 				new DefaultPreLoadEventListener(),
 				workMap
 		);
 
 		// pre-update listeners
 		prepareListeners(
 				PRE_UPDATE,
 				workMap
 		);
 
 		// post-collection-recreate listeners
 		prepareListeners(
 				POST_COLLECTION_RECREATE,
 				workMap
 		);
 
 		// post-collection-remove listeners
 		prepareListeners(
 				POST_COLLECTION_REMOVE,
 				workMap
 		);
 
 		// post-collection-update listeners
 		prepareListeners(
 				POST_COLLECTION_UPDATE,
 				workMap
 		);
 
 		// post-commit-delete listeners
 		prepareListeners(
 				POST_COMMIT_DELETE,
 				workMap
 		);
 
 		// post-commit-insert listeners
 		prepareListeners(
 				POST_COMMIT_INSERT,
 				workMap
 		);
 
 		// post-commit-update listeners
 		prepareListeners(
 				POST_COMMIT_UPDATE,
 				workMap
 		);
 
 		// post-delete listeners
 		prepareListeners(
 				POST_DELETE,
 				workMap
 		);
 
 		// post-insert listeners
 		prepareListeners(
 				POST_INSERT,
 				workMap
 		);
 
 		// post-load listeners
 		prepareListeners(
 				POST_LOAD,
 				new DefaultPostLoadEventListener(),
 				workMap
 		);
 
 		// post-update listeners
 		prepareListeners(
 				POST_UPDATE,
 				workMap
 		);
 
 		// update listeners
 		prepareListeners(
 				UPDATE,
 				new DefaultUpdateEventListener(),
 				workMap
 		);
 
 		// refresh listeners
 		prepareListeners(
 				REFRESH,
 				new DefaultRefreshEventListener(),
 				workMap
 		);
 
 		// replicate listeners
 		prepareListeners(
 				REPLICATE,
 				new DefaultReplicateEventListener(),
 				workMap
 		);
 
 		// save listeners
 		prepareListeners(
 				SAVE,
 				new DefaultSaveEventListener(),
 				workMap
 		);
 
 		// save-update listeners
 		prepareListeners(
 				SAVE_UPDATE,
 				new DefaultSaveOrUpdateEventListener(),
 				workMap
 		);
 
 		return Collections.unmodifiableMap( workMap );
 	}
 
 	private static <T> void prepareListeners(EventType<T> type, Map<EventType,EventListenerGroupImpl> map) {
 		prepareListeners( type, null, map );
 	}
 
 	private static <T> void prepareListeners(EventType<T> type, T defaultListener, Map<EventType,EventListenerGroupImpl> map) {
 		final EventListenerGroupImpl<T> listeners = new EventListenerGroupImpl<T>( type );
 		if ( defaultListener != null ) {
 			listeners.appendListener( defaultListener );
 		}
 		map.put( type, listeners  );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerGroup.java b/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerGroup.java
index 4336ca0cae..060cd68680 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerGroup.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerGroup.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.spi;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 
 /**
  * Contract for a groups of events listeners for a particular event type.
  *
  * @author Steve Ebersole
  */
 public interface EventListenerGroup<T> extends Serializable {
 
 	/**
 	 * Retrieve the event type associated with this groups of listeners.
 	 *
 	 * @return The event type.
 	 */
 	public EventType<T> getEventType();
 
 	/**
 	 * Are there no listeners registered?
 	 *
 	 * @return {@literal true} if no listeners are registered; {@literal false} otherwise.
 	 */
 	public boolean isEmpty();
 
 	public int count();
 
 	public Iterable<T> listeners();
 
 	/**
 	 * Mechanism to more finely control the notion of duplicates.
 	 * <p/>
 	 * For example, say you are registering listeners for an extension library.  This extension library
 	 * could define a "marker interface" which indicates listeners related to it and register a strategy
 	 * that checks against that marker interface.
 	 *
 	 * @param strategy The duplication strategy
 	 */
 	public void addDuplicationStrategy(DuplicationStrategy strategy);
 
 	public void appendListener(T listener);
 	public void appendListeners(T... listeners);
 
 	public void prependListener(T listener);
 	public void prependListeners(T... listeners);
 
 	public void clear();
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerRegistry.java b/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerRegistry.java
index a80ca5793c..29244d83b9 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/spi/EventListenerRegistry.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.spi;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.service.Service;
 
 /**
  * Service for accessing each {@link EventListenerGroup} by {@link EventType}, as well as convenience
  * methods for managing the listeners registered in each {@link EventListenerGroup}.
  *
  * @author Steve Ebersole
  */
 public interface EventListenerRegistry extends Service, Serializable {
 	public <T> EventListenerGroup<T> getEventListenerGroup(EventType<T> eventType);
 
 	public void addDuplicationStrategy(DuplicationStrategy strategy);
 
 	public <T> void setListeners(EventType<T> type, Class<T>... listeners);
 	public <T> void setListeners(EventType<T> type, T... listeners);
 
 	public <T> void appendListeners(EventType<T> type, Class<T>... listeners);
 	public <T> void appendListeners(EventType<T> type, T... listeners);
 
 	public <T> void prependListeners(EventType<T> type, Class<T>... listeners);
 	public <T> void prependListeners(EventType<T> type, T... listeners);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/AbstractCollectionEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractCollectionEvent.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/event/AbstractCollectionEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/AbstractCollectionEvent.java
index f506a3b6fa..06933846cf 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/AbstractCollectionEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractCollectionEvent.java
@@ -1,136 +1,137 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * Defines a base class for events involving collections.
  *
  * @author Gail Badner
  */
 public abstract class AbstractCollectionEvent extends AbstractEvent {
 
 	private final PersistentCollection collection;
 	private final Object affectedOwner;
 	private final Serializable affectedOwnerId;
 	private final String affectedOwnerEntityName;
 
 	/**
 	 * Constructs an AbstractCollectionEvent object.
 	 *
 	 * @param collection - the collection
 	 * @param source - the Session source
 	 * @param affectedOwner - the owner that is affected by this event;
 	 * can be null if unavailable
 	 * @param affectedOwnerId - the ID for the owner that is affected
 	 * by this event; can be null if unavailable
 	 * that is affected by this event; can be null if unavailable
 	 */
 	public AbstractCollectionEvent( CollectionPersister collectionPersister,
 					PersistentCollection collection,
 					EventSource source,
 					Object affectedOwner,
 					Serializable affectedOwnerId) {
 		super(source);
 		this.collection = collection;
 		this.affectedOwner = affectedOwner;
 		this.affectedOwnerId = affectedOwnerId;
 		this.affectedOwnerEntityName =
 				getAffectedOwnerEntityName( collectionPersister, affectedOwner, source );
 	}
 
 	protected static CollectionPersister getLoadedCollectionPersister( PersistentCollection collection, EventSource source ) {
 		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
 		return ( ce == null ? null : ce.getLoadedPersister() );		
 	}
 
 	protected static Object getLoadedOwnerOrNull( PersistentCollection collection, EventSource source ) {
 		return source.getPersistenceContext().getLoadedCollectionOwnerOrNull( collection );
 	}
 
 	protected static Serializable getLoadedOwnerIdOrNull( PersistentCollection collection, EventSource source ) {
 		return source.getPersistenceContext().getLoadedCollectionOwnerIdOrNull( collection );
 	}
 
 	protected static Serializable getOwnerIdOrNull( Object owner, EventSource source ) {
 		EntityEntry ownerEntry = source.getPersistenceContext().getEntry( owner );
 		return ( ownerEntry == null ? null : ownerEntry.getId() );
 	}
 
 	protected static String getAffectedOwnerEntityName(CollectionPersister collectionPersister, Object affectedOwner, EventSource source ) {
 
 		// collectionPersister should not be null, but we don't want to throw
 		// an exception if it is null
 		String entityName =
 				( collectionPersister == null ? null : collectionPersister.getOwnerEntityPersister().getEntityName() );
 		if ( affectedOwner != null ) {
 			EntityEntry ee = source.getPersistenceContext().getEntry( affectedOwner );
 			if ( ee != null && ee.getEntityName() != null) {
 				entityName = ee.getEntityName();
 			}
 		}	
 		return entityName;
 	}
 
 	public PersistentCollection getCollection() {
 		return collection;
 	}
 
 	/**
 	 * Get the collection owner entity that is affected by this event.
 	 *
 	 * @return the affected owner; returns null if the entity is not in the persistence context
 	 * (e.g., because the collection from a detached entity was moved to a new owner)
 	 */
 	public Object getAffectedOwnerOrNull() {
 		return affectedOwner;
 	}
 
 	/**
 	 * Get the ID for the collection owner entity that is affected by this event.
 	 *
 	 * @return the affected owner ID; returns null if the ID cannot be obtained
 	 * from the collection's loaded key (e.g., a property-ref is used for the
 	 * collection and does not include the entity's ID)
 	 */
 	public Serializable getAffectedOwnerIdOrNull() {
 		return affectedOwnerId;
 	}
 
 	/**
 	 * Get the entity name for the collection owner entity that is affected by this event.
 	 *
 	 * @return the entity name; if the owner is not in the PersistenceContext, the
 	 * returned value may be a superclass name, instead of the actual class name
 	 */
 	public String getAffectedOwnerEntityName() {
 		return affectedOwnerEntityName;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/AbstractEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/AbstractEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/AbstractEvent.java
index a966aebae5..debec4322c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/AbstractEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractEvent.java
@@ -1,57 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-import java.io.Serializable;
+package org.hibernate.event.spi;
 
+import java.io.Serializable;
 
 /**
  * Defines a base class for Session generated events.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractEvent implements Serializable {
 
 	private final EventSource session;
 
     /**
      * Constructs an event from the given event session.
      *
      * @param source The session event source.
      */
 	public AbstractEvent(EventSource source) {
 		this.session = source;
 	}
 
     /**
      * Returns the session event source for this event.  This is the underlying
      * session from which this event was generated.
      *
      * @return The session event source.
      */
 	public final EventSource getSession() {
 		return session;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/AbstractPreDatabaseOperationEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractPreDatabaseOperationEvent.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/event/AbstractPreDatabaseOperationEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/AbstractPreDatabaseOperationEvent.java
index 6310228352..c39afd5dde 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/AbstractPreDatabaseOperationEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/AbstractPreDatabaseOperationEvent.java
@@ -1,99 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Represents an operation we are about to perform against the database.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractPreDatabaseOperationEvent extends AbstractEvent {
 	private final Object entity;
 	private final Serializable id;
 	private final EntityPersister persister;
 
 	/**
 	 * Constructs an event containing the pertinent information.
 	 *
 	 * @param source The session from which the event originated.
 	 * @param entity The entity to be invloved in the database operation.
 	 * @param id The entity id to be invloved in the database operation.
 	 * @param persister The entity's persister.
 	 */
 	public AbstractPreDatabaseOperationEvent(
 			EventSource source,
 			Object entity,
 			Serializable id,
 			EntityPersister persister) {
 		super( source );
 		this.entity = entity;
 		this.id = id;
 		this.persister = persister;
 	}
 
 	/**
 	 * Retrieves the entity involved in the database operation.
 	 *
 	 * @return The entity.
 	 */
 	public Object getEntity() {
 		return entity;
 	}
 
 	/**
 	 * The id to be used in the database operation.
 	 *
 	 * @return The id.
 	 */
 	public Serializable getId() {
 		return id;
 	}
 
 	/**
 	 * The persister for the {@link #getEntity entity}.
 	 *
 	 * @return The entity persister.
 	 */
 	public EntityPersister getPersister() {
 		return persister;
 	}
 
 	/**
 	 * Getter for property 'source'.  This is the session from which the event
 	 * originated.
 	 * <p/>
 	 * Some of the pre-* events had previous exposed the event source using
 	 * getSource() because they had not originally extended from
 	 * {@link AbstractEvent}.
 	 *
 	 * @return Value for property 'source'.
 	 * @deprecated Use {@link #getSession} instead
 	 */
 	public EventSource getSource() {
 		return getSession();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/AutoFlushEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/AutoFlushEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEvent.java
index 79c8716639..2b3cc5792e 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/AutoFlushEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEvent.java
@@ -1,58 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-import java.util.Set;
+package org.hibernate.event.spi;
 
+import java.util.Set;
 
 /** Defines an event class for the auto-flushing of a session.
  *
  * @author Steve Ebersole
  */
 public class AutoFlushEvent extends FlushEvent {
 
 	private Set querySpaces;
 	private boolean flushRequired;
 
 	public AutoFlushEvent(Set querySpaces, EventSource source) {
 		super(source);
 		this.querySpaces = querySpaces;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	public void setQuerySpaces(Set querySpaces) {
 		this.querySpaces = querySpaces;
 	}
 
 	public boolean isFlushRequired() {
 		return flushRequired;
 	}
 
 	public void setFlushRequired(boolean dirty) {
 		this.flushRequired = dirty;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/AutoFlushEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/AutoFlushEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEventListener.java
index 1caee5c5f9..aa5bd5ce6b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/AutoFlushEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/AutoFlushEventListener.java
@@ -1,42 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of session auto-flush events.
  *
  * @author Steve Ebersole
  */
 public interface AutoFlushEventListener extends Serializable {
 
     /** Handle the given auto-flush event.
      *
      * @param event The auto-flush event to be handled.
      * @throws HibernateException
      */
 	public void onAutoFlush(AutoFlushEvent event) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/DeleteEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/DeleteEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEvent.java
index 2f1bc384ec..f43035d07b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/DeleteEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEvent.java
@@ -1,83 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-
+package org.hibernate.event.spi;
 
-
-/** Defines an event class for the deletion of an entity.
+/**
+ * Defines an event class for the deletion of an entity.
  *
  * @author Steve Ebersole
  */
 public class DeleteEvent extends AbstractEvent {
-
 	private Object object;
 	private String entityName;
 	private boolean cascadeDeleteEnabled;
 
 	/**
 	 * Constructs a new DeleteEvent instance.
 	 *
 	 * @param object The entity to be deleted.
 	 * @param source The session from which the delete event was generated.
 	 */
 	public DeleteEvent(Object object, EventSource source) {
 		super(source);
 		if (object == null) {
 			throw new IllegalArgumentException(
 					"attempt to create delete event with null entity"
 				);
 		}
 		this.object = object;
 	}
 
 	public DeleteEvent(String entityName, Object object, EventSource source) {
 		this(object, source);
 		this.entityName = entityName;
 	}
 
 	public DeleteEvent(String entityName, Object object, boolean isCascadeDeleteEnabled, EventSource source) {
 		this(object, source);
 		this.entityName = entityName;
 		cascadeDeleteEnabled = isCascadeDeleteEnabled;
 	}
 
 	/**
      * Returns the encapsulated entity to be deleed.
      *
      * @return The entity to be deleted.
      */
 	public Object getObject() {
 		return object;
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 	
 	public boolean isCascadeDeleteEnabled() {
 		return cascadeDeleteEnabled;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/DeleteEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEventListener.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/DeleteEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEventListener.java
index c1d92f0819..98706c5cb9 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/DeleteEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/DeleteEventListener.java
@@ -1,45 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import java.util.Set;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of deletion events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface DeleteEventListener extends Serializable {
 
     /** Handle the given delete event.
      *
      * @param event The delete event to be handled.
      * @throws HibernateException
      */
 	public void onDelete(DeleteEvent event) throws HibernateException;
 
 	public void onDelete(DeleteEvent event, Set transientEntities) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEvent.java
similarity index 83%
rename from hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEvent.java
index 9546338516..4071d37211 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEvent.java
@@ -1,49 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-
-
+package org.hibernate.event.spi;
 
-/** Defines an event class for the dirty-checking of a session.
+/**
+ * Defines an event class for the dirty-checking of a session.
  *
  * @author Steve Ebersole
  */
 public class DirtyCheckEvent extends FlushEvent {
-	
 	private boolean dirty;
 
 	public DirtyCheckEvent(EventSource source) {
 		super(source);
 	}
 
 	public boolean isDirty() {
 		return dirty;
 	}
 
 	public void setDirty(boolean dirty) {
 		this.dirty = dirty;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEventListener.java
index 6add586137..81c687e943 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/DirtyCheckEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/DirtyCheckEventListener.java
@@ -1,43 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of session dirty-check events.
  *
  * @author Steve Ebersole
  */
 public interface DirtyCheckEventListener extends Serializable {
 
     /** Handle the given dirty-check event.
      *
      * @param event The dirty-check event to be handled.
      * @throws HibernateException
      */
 	public void onDirtyCheck(DirtyCheckEvent event) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EventSource.java b/hibernate-core/src/main/java/org/hibernate/event/spi/EventSource.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/EventSource.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/EventSource.java
index e75fbd2c26..83fb16465b 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/EventSource.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/EventSource.java
@@ -1,79 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import java.util.Map;
 import java.util.Set;
+
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Gavin King
  */
 public interface EventSource extends SessionImplementor, Session {
 	
 	/**
 	 * Get the ActionQueue for this session
 	 */
 	public ActionQueue getActionQueue();
 
 	/**
 	 * Instantiate an entity instance, using either an interceptor,
 	 * or the given persister
 	 */
 	public Object instantiate(EntityPersister persister, Serializable id) throws HibernateException;
 
 	/**
 	 * Force an immediate flush
 	 */
 	public void forceFlush(EntityEntry e) throws HibernateException;
 
 	/**
 	 * Cascade merge an entity instance
 	 */
 	public void merge(String entityName, Object object, Map copiedAlready) throws HibernateException;
 	/**
 	 * Cascade persist an entity instance
 	 */
 	public void persist(String entityName, Object object, Map createdAlready) throws HibernateException;
 
 	/**
 	 * Cascade persist an entity instance during the flush process
 	 */
 	public void persistOnFlush(String entityName, Object object, Map copiedAlready);
 	/**
 	 * Cascade refesh an entity instance
 	 */
 	public void refresh(Object object, Map refreshedAlready) throws HibernateException;
 	/**
 	 * Cascade delete an entity instance
 	 */
 	public void delete(String entityName, Object child, boolean isCascadeDeleteEnabled, Set transientEntities);
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EventType.java b/hibernate-core/src/main/java/org/hibernate/event/spi/EventType.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/event/EventType.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/EventType.java
index f399dc8a1d..416dbf19b2 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/EventType.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/EventType.java
@@ -1,195 +1,195 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
 
 import java.lang.reflect.Field;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 
 /**
  * Enumeration of the recognized types of events, including meta-information about each.
  *
  * @author Steve Ebersole
  */
 public class EventType<T> {
 	public static final EventType<LoadEventListener> LOAD
 			= new EventType<LoadEventListener>( "load", LoadEventListener.class );
 	public static final EventType<InitializeCollectionEventListener> INIT_COLLECTION
 			= new EventType<InitializeCollectionEventListener>( "load-collection", InitializeCollectionEventListener.class );
 
 	public static final EventType<SaveOrUpdateEventListener> SAVE_UPDATE
 			= new EventType<SaveOrUpdateEventListener>( "save-update", SaveOrUpdateEventListener.class );
 	public static final EventType<SaveOrUpdateEventListener> UPDATE
 			= new EventType<SaveOrUpdateEventListener>( "update", SaveOrUpdateEventListener.class );
 	public static final EventType<SaveOrUpdateEventListener> SAVE
 			= new EventType<SaveOrUpdateEventListener>( "save", SaveOrUpdateEventListener.class );
 	public static final EventType<PersistEventListener> PERSIST
 			= new EventType<PersistEventListener>( "create", PersistEventListener.class );
 	public static final EventType<PersistEventListener> PERSIST_ONFLUSH
 			= new EventType<PersistEventListener>( "create-onflush", PersistEventListener.class );
 
 	public static final EventType<MergeEventListener> MERGE
 			= new EventType<MergeEventListener>( "merge", MergeEventListener.class );
 
 	public static final EventType<DeleteEventListener> DELETE
 			= new EventType<DeleteEventListener>( "delete", DeleteEventListener.class );
 
 	public static final EventType<ReplicateEventListener> REPLICATE
 			= new EventType<ReplicateEventListener>( "replicate", ReplicateEventListener.class );
 
 	public static final EventType<FlushEventListener> FLUSH
 			= new EventType<FlushEventListener>( "flush", FlushEventListener.class );
 	public static final EventType<AutoFlushEventListener> AUTO_FLUSH
 			= new EventType<AutoFlushEventListener>( "auto-flush", AutoFlushEventListener.class );
 	public static final EventType<DirtyCheckEventListener> DIRTY_CHECK
 			= new EventType<DirtyCheckEventListener>( "dirty-check", DirtyCheckEventListener.class );
 	public static final EventType<FlushEntityEventListener> FLUSH_ENTITY
 			= new EventType<FlushEntityEventListener>( "flush-entity", FlushEntityEventListener.class );
 
 	public static final EventType<EvictEventListener> EVICT
 			= new EventType<EvictEventListener>( "evict", EvictEventListener.class );
 
 	public static final EventType<LockEventListener> LOCK
 			= new EventType<LockEventListener>( "lock", LockEventListener.class );
 
 	public static final EventType<RefreshEventListener> REFRESH
 			= new EventType<RefreshEventListener>( "refresh", RefreshEventListener.class );
 
 	public static final EventType<PreLoadEventListener> PRE_LOAD
 			= new EventType<PreLoadEventListener>( "pre-load", PreLoadEventListener.class );
 	public static final EventType<PreDeleteEventListener> PRE_DELETE
 			= new EventType<PreDeleteEventListener>( "pre-delete", PreDeleteEventListener.class );
 	public static final EventType<PreUpdateEventListener> PRE_UPDATE
 			= new EventType<PreUpdateEventListener>( "pre-update", PreUpdateEventListener.class );
 	public static final EventType<PreInsertEventListener> PRE_INSERT
 			= new EventType<PreInsertEventListener>( "pre-insert", PreInsertEventListener.class );
 
 	public static final EventType<PostLoadEventListener> POST_LOAD
 			= new EventType<PostLoadEventListener>( "post-load", PostLoadEventListener.class );
 	public static final EventType<PostDeleteEventListener> POST_DELETE
 			= new EventType<PostDeleteEventListener>( "post-delete", PostDeleteEventListener.class );
 	public static final EventType<PostUpdateEventListener> POST_UPDATE
 			= new EventType<PostUpdateEventListener>( "post-update", PostUpdateEventListener.class );
 	public static final EventType<PostInsertEventListener> POST_INSERT
 			= new EventType<PostInsertEventListener>( "post-insert", PostInsertEventListener.class );
 
 	public static final EventType<PostDeleteEventListener> POST_COMMIT_DELETE
 			= new EventType<PostDeleteEventListener>( "post-commit-delete", PostDeleteEventListener.class );
 	public static final EventType<PostUpdateEventListener> POST_COMMIT_UPDATE
 			= new EventType<PostUpdateEventListener>( "post-commit-update", PostUpdateEventListener.class );
 	public static final EventType<PostInsertEventListener> POST_COMMIT_INSERT
 			= new EventType<PostInsertEventListener>( "post-commit-insert", PostInsertEventListener.class );
 
 	public static final EventType<PreCollectionRecreateEventListener> PRE_COLLECTION_RECREATE
 			= new EventType<PreCollectionRecreateEventListener>( "pre-collection-recreate", PreCollectionRecreateEventListener.class );
 	public static final EventType<PreCollectionRemoveEventListener> PRE_COLLECTION_REMOVE
 			= new EventType<PreCollectionRemoveEventListener>( "pre-collection-remove", PreCollectionRemoveEventListener.class );
 	public static final EventType<PreCollectionUpdateEventListener> PRE_COLLECTION_UPDATE
 			= new EventType<PreCollectionUpdateEventListener>( "pre-collection-update", PreCollectionUpdateEventListener.class );
 
 	public static final EventType<PostCollectionRecreateEventListener> POST_COLLECTION_RECREATE
 			= new EventType<PostCollectionRecreateEventListener>( "post-collection-recreate", PostCollectionRecreateEventListener.class );
 	public static final EventType<PostCollectionRemoveEventListener> POST_COLLECTION_REMOVE
 			= new EventType<PostCollectionRemoveEventListener>( "post-collection-remove", PostCollectionRemoveEventListener.class );
 	public static final EventType<PostCollectionUpdateEventListener> POST_COLLECTION_UPDATE
 			= new EventType<PostCollectionUpdateEventListener>( "post-collection-update", PostCollectionUpdateEventListener.class );
 
 
 	/**
 	 * Maintain a map of {@link EventType} instances keyed by name for lookup by name as well as {@link #values()}
 	 * resolution.
 	 */
 	public static final Map<String,EventType> eventTypeByNameMap = AccessController.doPrivileged(
 			new PrivilegedAction<Map<String, EventType>>() {
 				@Override
 				public Map<String, EventType> run() {
 					final Map<String, EventType> typeByNameMap = new HashMap<String, EventType>();
 					final Field[] fields = EventType.class.getDeclaredFields();
 					for ( int i = 0, max = fields.length; i < max; i++ ) {
 						if ( EventType.class.isAssignableFrom( fields[i].getType() ) ) {
 							try {
 								final EventType typeField = ( EventType ) fields[i].get( null );
 								typeByNameMap.put( typeField.eventName(), typeField );
 							}
 							catch( Exception t ) {
 								throw new HibernateException( "Unable to initialize EventType map", t );
 							}
 						}
 					}
 					return typeByNameMap;
 				}
 			}
 	);
 
 	/**
 	 * Find an {@link EventType} by its name
 	 *
 	 * @param eventName The name
 	 *
 	 * @return The {@link EventType} instance.
 	 *
 	 * @throws HibernateException If eventName is null, or if eventName does not correlate to any known event type.
 	 */
 	public static EventType resolveEventTypeByName(final String eventName) {
 		if ( eventName == null ) {
 			throw new HibernateException( "event name to resolve cannot be null" );
 		}
 		final EventType eventType = eventTypeByNameMap.get( eventName );
 		if ( eventType == null ) {
 			throw new HibernateException( "Unable to locate proper event type for event name [" + eventName + "]" );
 		}
 		return eventType;
 	}
 
 	/**
 	 * Get a collection of all {@link EventType} instances.
 	 *
 	 * @return All {@link EventType} instances
 	 */
 	public static Collection<EventType> values() {
 		return eventTypeByNameMap.values();
 	}
 
 
 	private final String eventName;
 	private final Class<? extends T> baseListenerInterface;
 
 	private EventType(String eventName, Class<? extends T> baseListenerInterface) {
 		this.eventName = eventName;
 		this.baseListenerInterface = baseListenerInterface;
 	}
 
 	public String eventName() {
 		return eventName;
 	}
 
 	public Class baseListenerInterface() {
 		return baseListenerInterface;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EvictEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/EvictEvent.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/EvictEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/EvictEvent.java
index c834d5a2ca..b276adad15 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/EvictEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/EvictEvent.java
@@ -1,50 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-
-
+package org.hibernate.event.spi;
 
 /**
  *  Defines an event class for the evicting of an entity.
  *
  * @author Steve Ebersole
  */
 public class EvictEvent extends AbstractEvent {
 
 	private Object object;
 
 	public EvictEvent(Object object, EventSource source) {
 		super(source);
 		this.object = object;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public void setObject(Object object) {
 		this.object = object;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EvictEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/EvictEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/EvictEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/EvictEventListener.java
index ed3ec869de..c000be1674 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/EvictEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/EvictEventListener.java
@@ -1,43 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of evict events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface EvictEventListener extends Serializable {
 
     /** 
      * Handle the given evict event.
      *
      * @param event The evict event to be handled.
      * @throws HibernateException
      */
 	public void onEvict(EvictEvent event) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/FlushEntityEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEvent.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/event/FlushEntityEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEvent.java
index 82d02ce8aa..55d1b15c38 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/FlushEntityEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEvent.java
@@ -1,93 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.engine.spi.EntityEntry;
 
 /**
  * @author Gavin King
  */
 public class FlushEntityEvent extends AbstractEvent {
-	
 	private Object entity;
 	private Object[] propertyValues;
 	private Object[] databaseSnapshot;
 	private int[] dirtyProperties;
 	private boolean hasDirtyCollection;
 	private boolean dirtyCheckPossible;
 	private boolean dirtyCheckHandledByInterceptor;
 	private EntityEntry entityEntry;
 	
 	public FlushEntityEvent(EventSource source, Object entity, EntityEntry entry) {
 		super(source);
 		this.entity = entity;
 		this.entityEntry = entry;
 	}
 
 	public EntityEntry getEntityEntry() {
 		return entityEntry;
 	}
 	public Object[] getDatabaseSnapshot() {
 		return databaseSnapshot;
 	}
 	public void setDatabaseSnapshot(Object[] databaseSnapshot) {
 		this.databaseSnapshot = databaseSnapshot;
 	}
 	public boolean hasDatabaseSnapshot() {
 		return databaseSnapshot!=null;
 	}
 	public boolean isDirtyCheckHandledByInterceptor() {
 		return dirtyCheckHandledByInterceptor;
 	}
 	public void setDirtyCheckHandledByInterceptor(boolean dirtyCheckHandledByInterceptor) {
 		this.dirtyCheckHandledByInterceptor = dirtyCheckHandledByInterceptor;
 	}
 	public boolean isDirtyCheckPossible() {
 		return dirtyCheckPossible;
 	}
 	public void setDirtyCheckPossible(boolean dirtyCheckPossible) {
 		this.dirtyCheckPossible = dirtyCheckPossible;
 	}
 	public int[] getDirtyProperties() {
 		return dirtyProperties;
 	}
 	public void setDirtyProperties(int[] dirtyProperties) {
 		this.dirtyProperties = dirtyProperties;
 	}
 	public boolean hasDirtyCollection() {
 		return hasDirtyCollection;
 	}
 	public void setHasDirtyCollection(boolean hasDirtyCollection) {
 		this.hasDirtyCollection = hasDirtyCollection;
 	}
 	public Object[] getPropertyValues() {
 		return propertyValues;
 	}
 	public void setPropertyValues(Object[] propertyValues) {
 		this.propertyValues = propertyValues;
 	}
 	public Object getEntity() {
 		return entity;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/FlushEntityEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/FlushEntityEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEventListener.java
index 781d01f46a..7e795dd542 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/FlushEntityEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEntityEventListener.java
@@ -1,34 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * @author Gavin King
  */
 public interface FlushEntityEventListener extends Serializable {
 	public void onFlushEntity(FlushEntityEvent event) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/FlushEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEvent.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/event/FlushEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/FlushEvent.java
index 66150993c2..176c39cd5c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/FlushEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEvent.java
@@ -1,40 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-
+package org.hibernate.event.spi;
 
-
-/** 
+/**
  * Defines an event class for the flushing of a session.
  *
  * @author Steve Ebersole
  */
 public class FlushEvent extends AbstractEvent {
-	
 	public FlushEvent(EventSource source) {
 		super(source);
 	}
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/FlushEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEventListener.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/event/FlushEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/FlushEventListener.java
index cab03e2116..dbfb1111c9 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/FlushEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/FlushEventListener.java
@@ -1,42 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of session flush events.
  *
  * @author Steve Ebersole
  */
 public interface FlushEventListener extends Serializable {
-
-    /** Handle the given flush event.
+    /**
+	 * Handle the given flush event.
      *
      * @param event The flush event to be handled.
      * @throws HibernateException
      */
 	public void onFlush(FlushEvent event) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEvent.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEvent.java
index 243b9cc31d..63642fb0ea 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEvent.java
@@ -1,43 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 
 /**
  * An event that occurs when a collection wants to be
  * initialized
  * 
  * @author Gavin King
  */
 public class InitializeCollectionEvent extends AbstractCollectionEvent {
-
 	public InitializeCollectionEvent(PersistentCollection collection, EventSource source ) {
 		super( getLoadedCollectionPersister( collection, source ),
 				collection,
 				source,
 				getLoadedOwnerOrNull( collection, source ),
 				getLoadedOwnerIdOrNull( collection, source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEventListener.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEventListener.java
index cd1c4d6560..ce3c47f307 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/InitializeCollectionEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/InitializeCollectionEventListener.java
@@ -1,39 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of collection initialization events 
  * generated by a session.
  *
  * @author Gavin King
  */
 public interface InitializeCollectionEventListener extends Serializable {
-
 	public void onInitializeCollection(InitializeCollectionEvent event) throws HibernateException;
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/LoadEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/LoadEvent.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/event/LoadEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/LoadEvent.java
index 9fa403e2c4..ee975967d2 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/LoadEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/LoadEvent.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 
 /**
  *  Defines an event class for the loading of an entity.
  *
  * @author Steve Ebersole
  */
 public class LoadEvent extends AbstractEvent {
-
 	public static final LockMode DEFAULT_LOCK_MODE = LockMode.NONE;
 
 	private Serializable entityId;
 	private String entityClassName;
 	private Object instanceToLoad;
 	private LockOptions lockOptions;
 	private boolean isAssociationFetch;
 	private Object result;
 
 	public LoadEvent(Serializable entityId, Object instanceToLoad, EventSource source) {
 		this(entityId, null, instanceToLoad, new LockOptions(), false, source);
 	}
 
 	public LoadEvent(Serializable entityId, String entityClassName, LockMode lockMode, EventSource source) {
 		this(entityId, entityClassName, null, lockMode, false, source);
 	}
 
 	public LoadEvent(Serializable entityId, String entityClassName, LockOptions lockOptions, EventSource source) {
 		this(entityId, entityClassName, null, lockOptions, false, source);
 	}
 
 	public LoadEvent(Serializable entityId, String entityClassName, boolean isAssociationFetch, EventSource source) {
 		this(entityId, entityClassName, null, new LockOptions(), isAssociationFetch, source);
 	}
 	
 	public boolean isAssociationFetch() {
 		return isAssociationFetch;
 	}
 
 	private LoadEvent(
 			Serializable entityId,
 			String entityClassName,
 			Object instanceToLoad,
 			LockMode lockMode,
 			boolean isAssociationFetch,
 			EventSource source) {
 		this(entityId, entityClassName, instanceToLoad, new LockOptions().setLockMode(lockMode), isAssociationFetch, source );
 	}
 
 	private LoadEvent(
 			Serializable entityId,
 			String entityClassName,
 			Object instanceToLoad,
 			LockOptions lockOptions,
 			boolean isAssociationFetch,
 			EventSource source) {
 
 		super(source);
 
 		if ( entityId == null ) {
 			throw new IllegalArgumentException("id to load is required for loading");
 		}
 
 		if ( lockOptions.getLockMode() == LockMode.WRITE ) {
 			throw new IllegalArgumentException("Invalid lock mode for loading");
 		}
 		else if ( lockOptions.getLockMode() == null ) {
 			lockOptions.setLockMode(DEFAULT_LOCK_MODE);
 		}
 
 		this.entityId = entityId;
 		this.entityClassName = entityClassName;
 		this.instanceToLoad = instanceToLoad;
 		this.lockOptions = lockOptions;
 		this.isAssociationFetch = isAssociationFetch;
 	}
 
 	public Serializable getEntityId() {
 		return entityId;
 	}
 
 	public void setEntityId(Serializable entityId) {
 		this.entityId = entityId;
 	}
 
 	public String getEntityClassName() {
 		return entityClassName;
 	}
 
 	public void setEntityClassName(String entityClassName) {
 		this.entityClassName = entityClassName;
 	}
 
 	public Object getInstanceToLoad() {
 		return instanceToLoad;
 	}
 
 	public void setInstanceToLoad(Object instanceToLoad) {
 		this.instanceToLoad = instanceToLoad;
 	}
 
 	public LockOptions getLockOptions() {
 		return lockOptions;
 	}
 
 	public LockMode getLockMode() {
 		return lockOptions.getLockMode();
 	}
 
 	public void setLockMode(LockMode lockMode) {
 		this.lockOptions.setLockMode(lockMode);
 	}
 
 	public void setLockTimeout(int timeout) {
 		this.lockOptions.setTimeOut(timeout);
 	}
 
 	public int getLockTimeout() {
 		return this.lockOptions.getTimeOut();
 	}
 
 	public void setLockScope(boolean cascade) {
 		this.lockOptions.setScope(cascade);
 	}
 
 	public boolean getLockScope() {
 		return this.lockOptions.getScope();
 	}
 
 	public Object getResult() {
 		return result;
 	}
 
 	public void setResult(Object result) {
 		this.result = result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/LoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/LoadEventListener.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/event/LoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/LoadEventListener.java
index c8476b4e33..fb0926f0f8 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/LoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/LoadEventListener.java
@@ -1,143 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of load events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface LoadEventListener extends Serializable {
 
 	/** 
 	 * Handle the given load event.
      *
      * @param event The load event to be handled.
      * @return The result (i.e., the loaded entity).
      * @throws HibernateException
      */
 	public void onLoad(LoadEvent event, LoadType loadType) throws HibernateException;
 
 	public static final LoadType RELOAD = new LoadType("GET")
 			.setAllowNulls(false)
 			.setAllowProxyCreation(false)
 			.setCheckDeleted(true)
 			.setNakedEntityReturned(false);
 
 	public static final LoadType GET = new LoadType("GET")
 			.setAllowNulls(true)
 			.setAllowProxyCreation(false)
 			.setCheckDeleted(true)
 			.setNakedEntityReturned(false);
 	
 	public static final LoadType LOAD = new LoadType("LOAD")
 			.setAllowNulls(false)
 			.setAllowProxyCreation(true)
 			.setCheckDeleted(true)
 			.setNakedEntityReturned(false);
 	
 	public static final LoadType IMMEDIATE_LOAD = new LoadType("IMMEDIATE_LOAD")
 			.setAllowNulls(true)
 			.setAllowProxyCreation(false)
 			.setCheckDeleted(false)
 			.setNakedEntityReturned(true);
 	
 	public static final LoadType INTERNAL_LOAD_EAGER = new LoadType("INTERNAL_LOAD_EAGER")
 			.setAllowNulls(false)
 			.setAllowProxyCreation(false)
 			.setCheckDeleted(false)
 			.setNakedEntityReturned(false);
 	
 	public static final LoadType INTERNAL_LOAD_LAZY = new LoadType("INTERNAL_LOAD_LAZY")
 			.setAllowNulls(false)
 			.setAllowProxyCreation(true)
 			.setCheckDeleted(false)
 			.setNakedEntityReturned(false);
 	
 	public static final LoadType INTERNAL_LOAD_NULLABLE = new LoadType("INTERNAL_LOAD_NULLABLE")
 			.setAllowNulls(true)
 			.setAllowProxyCreation(false)
 			.setCheckDeleted(false)
 			.setNakedEntityReturned(false);
 
 	public static final class LoadType {
 		private String name;
 
 		private boolean nakedEntityReturned;
 		private boolean allowNulls;
 		private boolean checkDeleted;
 		private boolean allowProxyCreation;
 
         private LoadType(String name) {
 	        this.name = name;
         }
 
 		public boolean isAllowNulls() {
 			return allowNulls;
 		}
 
 		private LoadType setAllowNulls(boolean allowNulls) {
 			this.allowNulls = allowNulls;
 			return this;
 		}
 
 		public boolean isNakedEntityReturned() {
 			return nakedEntityReturned;
 		}
 
 		private LoadType setNakedEntityReturned(boolean immediateLoad) {
 			this.nakedEntityReturned = immediateLoad;
 			return this;
 		}
 
 		public boolean isCheckDeleted() {
 			return checkDeleted;
 		}
 
 		private LoadType setCheckDeleted(boolean checkDeleted) {
 			this.checkDeleted = checkDeleted;
 			return this;
 		}
 
 		public boolean isAllowProxyCreation() {
 			return allowProxyCreation;
 		}
 
 		private LoadType setAllowProxyCreation(boolean allowProxyCreation) {
 			this.allowProxyCreation = allowProxyCreation;
 			return this;
 		}
 
 		public String getName() {
 			return name;
 		}
 		
 		public String toString() {
 			return name;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/LockEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/LockEvent.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/event/LockEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/LockEvent.java
index 526802265f..7c25ff1214 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/LockEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/LockEvent.java
@@ -1,106 +1,106 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 
 /**
  *  Defines an event class for the locking of an entity.
  *
  * @author Steve Ebersole
  */
 public class LockEvent extends AbstractEvent {
 
 	private Object object;
 	private LockOptions lockOptions;
 	private String entityName;
 
 	public LockEvent(String entityName, Object original, LockMode lockMode, EventSource source) {
 		this(original, lockMode, source);
 		this.entityName = entityName;
 	}
 
 	public LockEvent(String entityName, Object original, LockOptions lockOptions, EventSource source) {
 		this(original, lockOptions, source);
 		this.entityName = entityName;
 	}
 
 	public LockEvent(Object object, LockMode lockMode, EventSource source) {
 		super(source);
 		this.object = object;
 		this.lockOptions = new LockOptions().setLockMode(lockMode);
 	}
 
 	public LockEvent(Object object, LockOptions lockOptions, EventSource source) {
 		super(source);
 		this.object = object;
 		this.lockOptions = lockOptions;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public void setObject(Object object) {
 		this.object = object;
 	}
 
 	public LockOptions getLockOptions() {
 		return lockOptions;
 	}
 
 	public LockMode getLockMode() {
 		return lockOptions.getLockMode();
 	}
 
 	public void setLockMode(LockMode lockMode) {
 		this.lockOptions.setLockMode(lockMode);
 	}
 
 	public void setLockTimeout(int timeout) {
 		this.lockOptions.setTimeOut(timeout);
 	}
 
 	public int getLockTimeout() {
 		return this.lockOptions.getTimeOut();
 	}
 
 	public void setLockScope(boolean cascade) {
 		this.lockOptions.setScope(cascade);
 	}
 
 	public boolean getLockScope() {
 		return this.lockOptions.getScope();
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/LockEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/LockEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/LockEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/LockEventListener.java
index ee9868bb61..9ff3a414ff 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/LockEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/LockEventListener.java
@@ -1,43 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of lock events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface LockEventListener extends Serializable {
 
     /** Handle the given lock event.
      *
      * @param event The lock event to be handled.
      * @throws HibernateException
      */
 	public void onLock(LockEvent event) throws HibernateException;
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/event/MergeEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/MergeEvent.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/MergeEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/MergeEvent.java
index f021228a70..4b4b823d4f 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/MergeEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/MergeEvent.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /** 
  * An event class for merge() and saveOrUpdateCopy()
  *
  * @author Gavin King
  */
 public class MergeEvent extends AbstractEvent {
 
 	private Object original;
 	private Serializable requestedId;
 	private String entityName;
 	private Object entity;
 	private Object result;
 
 	public MergeEvent(String entityName, Object original, EventSource source) {
 		this(original, source);
 		this.entityName = entityName;
 	}
 
 	public MergeEvent(String entityName, Object original, Serializable id, EventSource source) {
 		this(entityName, original, source);
 		this.requestedId = id;
 		if ( requestedId == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create merge event with null identifier"
 				);
 		}
 	}
 
 	public MergeEvent(Object object, EventSource source) {
 		super(source);
 		if ( object == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create merge event with null entity"
 				);
 		}
 		this.original = object;
 	}
 
 	public Object getOriginal() {
 		return original;
 	}
 
 	public void setOriginal(Object object) {
 		this.original = object;
 	}
 
 	public Serializable getRequestedId() {
 		return requestedId;
 	}
 
 	public void setRequestedId(Serializable requestedId) {
 		this.requestedId = requestedId;
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 
 	public Object getEntity() {
 		return entity;
 	}
 	public void setEntity(Object entity) {
 		this.entity = entity;
 	}
 
 	public Object getResult() {
 		return result;
 	}
 
 	public void setResult(Object result) {
 		this.result = result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/MergeEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/MergeEventListener.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/MergeEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/MergeEventListener.java
index a892e03830..dc2fb0ea54 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/MergeEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/MergeEventListener.java
@@ -1,53 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import java.util.Map;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of merge events generated from a session.
  *
  * @author Gavin King
  */
 public interface MergeEventListener extends Serializable {
 
     /** 
      * Handle the given merge event.
      *
      * @param event The merge event to be handled.
      * @throws HibernateException
      */
 	public void onMerge(MergeEvent event) throws HibernateException;
 
     /** 
      * Handle the given merge event.
      *
      * @param event The merge event to be handled.
      * @throws HibernateException
      */
 	public void onMerge(MergeEvent event, Map copiedAlready) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PersistEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PersistEvent.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/PersistEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PersistEvent.java
index c94059c148..b27fb3aa3c 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PersistEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PersistEvent.java
@@ -1,69 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
-
+package org.hibernate.event.spi;
 
-/** 
+/**
  * An event class for persist()
  *
  * @author Gavin King
  */
 public class PersistEvent extends AbstractEvent {
 
 	private Object object;
 	private String entityName;
 
 	public PersistEvent(String entityName, Object original, EventSource source) {
 		this(original, source);
 		this.entityName = entityName;
 	}
 
 	public PersistEvent(Object object, EventSource source) {
 		super(source);
 		if ( object == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create create event with null entity"
 			);
 		}
 		this.object = object;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public void setObject(Object object) {
 		this.object = object;
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PersistEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PersistEventListener.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PersistEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PersistEventListener.java
index 0afbe3a28f..4faade34af 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PersistEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PersistEventListener.java
@@ -1,53 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import java.util.Map;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of create events generated from a session.
  *
  * @author Gavin King
  */
 public interface PersistEventListener extends Serializable {
 
     /** 
      * Handle the given create event.
      *
      * @param event The create event to be handled.
      * @throws HibernateException
      */
 	public void onPersist(PersistEvent event) throws HibernateException;
 
     /** 
      * Handle the given create event.
      *
      * @param event The create event to be handled.
      * @throws HibernateException
      */
 	public void onPersist(PersistEvent event, Map createdAlready) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEvent.java
index b330e7bb58..9ca974247c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEvent.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs after a collection is recreated
  *
  * @author Gail Badner
  */
 public class PostCollectionRecreateEvent extends AbstractCollectionEvent {
 
 	public PostCollectionRecreateEvent( CollectionPersister collectionPersister,
 										PersistentCollection collection,
 										EventSource source ) {
 		super( collectionPersister, collection, source,
 				collection.getOwner(),
 				getOwnerIdOrNull( collection.getOwner(), source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEventListener.java
index ef205473c1..b81a4c3a97 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRecreateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRecreateEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after recreating a collection
  *
  * @author Gail Badner
  */
 public interface PostCollectionRecreateEventListener extends Serializable {
 	public void onPostRecreateCollection(PostCollectionRecreateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEvent.java
index 0523d57461..079c98e9f3 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEvent.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs after a collection is removed
  *
  * @author Gail Badner
  */
 public class PostCollectionRemoveEvent extends AbstractCollectionEvent {
 
 	public PostCollectionRemoveEvent(CollectionPersister collectionPersister,
 									 PersistentCollection collection,
 									 EventSource source,
 									 Object loadedOwner ) {
 		super( collectionPersister, collection, source,
 				loadedOwner,
 				getOwnerIdOrNull( loadedOwner, source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEventListener.java
index 2e4827a1a8..97bd3733b3 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionRemoveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionRemoveEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after removing a collection
  *
  * @author Gail Badner
  */
 public interface PostCollectionRemoveEventListener extends Serializable {
 	public void onPostRemoveCollection(PostCollectionRemoveEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEvent.java
index 44255aaac6..b22b364874 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEvent.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs after a collection is updated
  *
  * @author Gail Badner
  */
 public class PostCollectionUpdateEvent extends AbstractCollectionEvent {
 
 	public PostCollectionUpdateEvent(CollectionPersister collectionPersister,
 									 PersistentCollection collection,
 									 EventSource source) {
 		super( collectionPersister, collection, source,
 				getLoadedOwnerOrNull( collection, source ),
 				getLoadedOwnerIdOrNull( collection, source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEventListener.java
index 7990faefc5..0dfcde92fa 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostCollectionUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostCollectionUpdateEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after updating a collection
  *
  * @author Gail Badner
  */
 public interface PostCollectionUpdateEventListener extends Serializable {
 	public void onPostUpdateCollection(PostCollectionUpdateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostDeleteEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEvent.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/PostDeleteEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEvent.java
index c34c71047a..55c9c2cce4 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostDeleteEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEvent.java
@@ -1,66 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Occurs after deleting an item from the datastore
  * 
  * @author Gavin King
  */
 public class PostDeleteEvent extends AbstractEvent {
 	private Object entity;
 	private EntityPersister persister;
 	private Serializable id;
 	private Object[] deletedState;
 	
 	public PostDeleteEvent(
 			Object entity, 
 			Serializable id,
 			Object[] deletedState,
 			EntityPersister persister,
 			EventSource source
 	) {
 		super(source);
 		this.entity = entity;
 		this.id = id;
 		this.persister = persister;
 		this.deletedState = deletedState;
 	}
 	
 	public Serializable getId() {
 		return id;
 	}
 	public EntityPersister getPersister() {
 		return persister;
 	}
 	public Object getEntity() {
 		return entity;
 	}
 	public Object[] getDeletedState() {
 		return deletedState;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostDeleteEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostDeleteEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEventListener.java
index f56e26f0b9..c0a63f8a03 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostDeleteEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostDeleteEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after deleting an item from the datastore
  * 
  * @author Gavin King
  */
 public interface PostDeleteEventListener extends Serializable {
 	public void onPostDelete(PostDeleteEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostInsertEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEvent.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/PostInsertEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEvent.java
index 0e4342adc7..f2103b4269 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PostInsertEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEvent.java
@@ -1,66 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Occurs after inserting an item in the datastore
  * 
  * @author Gavin King
  */
 public class PostInsertEvent extends AbstractEvent {
 	private Object entity;
 	private EntityPersister persister;
 	private Object[] state;
 	private Serializable id;
 	
 	public PostInsertEvent(
 			Object entity, 
 			Serializable id,
 			Object[] state,
 			EntityPersister persister,
 			EventSource source
 	) {
 		super(source);
 		this.entity = entity;
 		this.id = id;
 		this.state = state;
 		this.persister = persister;
 	}
 	
 	public Object getEntity() {
 		return entity;
 	}
 	public Serializable getId() {
 		return id;
 	}
 	public EntityPersister getPersister() {
 		return persister;
 	}
 	public Object[] getState() {
 		return state;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostInsertEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostInsertEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEventListener.java
index b2f5079a3c..fb41d46b2f 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PostInsertEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostInsertEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after insterting an item in the datastore
  * 
  * @author Gavin King
  */
 public interface PostInsertEventListener extends Serializable {
 	public void onPostInsert(PostInsertEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostLoadEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEvent.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/event/PostLoadEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEvent.java
index df6019d562..b8b69260c1 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostLoadEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEvent.java
@@ -1,70 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Occurs after an an entity instance is fully loaded.
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>, Gavin King
  */
 public class PostLoadEvent extends AbstractEvent {
 	private Object entity;
 	private Serializable id;
 	private EntityPersister persister;
 
 	public PostLoadEvent(EventSource session) {
 		super(session);
 	}
 
 	public Object getEntity() {
 		return entity;
 	}
 	
 	public EntityPersister getPersister() {
 		return persister;
 	}
 	
 	public Serializable getId() {
 		return id;
 	}
 
 	public PostLoadEvent setEntity(Object entity) {
 		this.entity = entity;
 		return this;
 	}
 	
 	public PostLoadEvent setId(Serializable id) {
 		this.id = id;
 		return this;
 	}
 
 	public PostLoadEvent setPersister(EntityPersister persister) {
 		this.persister = persister;
 		return this;
 	}
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEventListener.java
index d52a8ba76b..99015447bf 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PostLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostLoadEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Occurs after an an entity instance is fully loaded.
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 public interface PostLoadEventListener extends Serializable {
 	public void onPostLoad(PostLoadEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostUpdateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEvent.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/PostUpdateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEvent.java
index 52b4d5f832..78e1580789 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PostUpdateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEvent.java
@@ -1,80 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Occurs after the datastore is updated
  * 
  * @author Gavin King
  */
 public class PostUpdateEvent extends AbstractEvent {
 	private Object entity;
 	private EntityPersister persister;
 	private Object[] state;
 	private Object[] oldState;
 	private Serializable id;
 	//list of dirty properties as computed by Hibernate during a FlushEntityEvent
 	private final int[] dirtyProperties;
 	
 	public PostUpdateEvent(
 			Object entity, 
 			Serializable id,
 			Object[] state,
 			Object[] oldState,
 			int[] dirtyProperties,
 			EntityPersister persister,
 			EventSource source
 	) {
 		super(source);
 		this.entity = entity;
 		this.id = id;
 		this.state = state;
 		this.oldState = oldState;
 		this.dirtyProperties = dirtyProperties;
 		this.persister = persister;
 	}
 	
 	public Object getEntity() {
 		return entity;
 	}
 	public Serializable getId() {
 		return id;
 	}
 	public Object[] getOldState() {
 		return oldState;
 	}
 	public EntityPersister getPersister() {
 		return persister;
 	}
 	public Object[] getState() {
 		return state;
 	}
 
 	public int[] getDirtyProperties() {
 		return dirtyProperties;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PostUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PostUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEventListener.java
index 36be83c69e..5151611d8c 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PostUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PostUpdateEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called after updating the datastore
  * 
  * @author Gavin King
  */
 public interface PostUpdateEventListener extends Serializable {
 	public void onPostUpdate(PostUpdateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEvent.java
index ea7cc9f42b..516cae344c 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEvent.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs before a collection is recreated
  *
  * @author Gail Badner
  */
 public class PreCollectionRecreateEvent extends AbstractCollectionEvent {
 
 	public PreCollectionRecreateEvent(CollectionPersister collectionPersister,
 									  PersistentCollection collection,
 									  EventSource source) {
 		super( collectionPersister, collection, source,
 				collection.getOwner(),
 				getOwnerIdOrNull( collection.getOwner(), source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEventListener.java
index 6af38c2c7c..9a13efb851 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRecreateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRecreateEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before recreating a collection
  *
  * @author Gail Badner
  */
 public interface PreCollectionRecreateEventListener extends Serializable {
 	public void onPreRecreateCollection(PreCollectionRecreateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEvent.java
index bbed9fe141..5017cb3f7b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEvent.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs before a collection is removed
  *
  * @author Gail Badner
  */
 public class PreCollectionRemoveEvent extends AbstractCollectionEvent {
 
 	public PreCollectionRemoveEvent(CollectionPersister collectionPersister,
 									PersistentCollection collection,
 									EventSource source,
 									Object loadedOwner) {
 		super( collectionPersister, collection, source,
 				loadedOwner,
 				getOwnerIdOrNull( loadedOwner, source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEventListener.java
index 77d87bb9a5..b4e9ffd110 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionRemoveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionRemoveEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before removing a collection
  *
  * @author Gail Badner
  */
 public interface PreCollectionRemoveEventListener extends Serializable {
 	public void onPreRemoveCollection(PreCollectionRemoveEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEvent.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEvent.java
index 31d3007ece..5376d6c16d 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEvent.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.persister.collection.CollectionPersister;
 
 /**
  * An event that occurs before a collection is updated
  *
  * @author Gail Badner
  */
 public class PreCollectionUpdateEvent extends AbstractCollectionEvent {
 
 	public PreCollectionUpdateEvent(CollectionPersister collectionPersister,
 									PersistentCollection collection,
 									EventSource source) {
 		super( collectionPersister, collection, source,
 				getLoadedOwnerOrNull( collection, source ),
 				getLoadedOwnerIdOrNull( collection, source ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEventListener.java
index e0748bbf3a..907fea5ced 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/PreCollectionUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreCollectionUpdateEventListener.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before updating a collection
  *
  * @author Gail Badner
  */
 public interface PreCollectionUpdateEventListener extends Serializable {
 	public void onPreUpdateCollection(PreCollectionUpdateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreDeleteEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEvent.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/PreDeleteEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEvent.java
index ce938ea98e..5543208fd6 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreDeleteEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEvent.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Represents a <tt>pre-delete</tt> event, which occurs just prior to
  * performing the deletion of an entity from the database.
  * 
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class PreDeleteEvent extends AbstractPreDatabaseOperationEvent {
 	private Object[] deletedState;
 
 	/**
 	 *
 	 * Constructs an event containing the pertinent information.
 	 *
 	 * @param entity The entity to be deleted.
 	 * @param id The id to use in the deletion.
 	 * @param deletedState The entity's state at deletion time.
 	 * @param persister The entity's persister.
 	 * @param source The session from which the event originated.
 	 */
 	public PreDeleteEvent(
 			Object entity,
 			Serializable id,
 			Object[] deletedState,
 			EntityPersister persister,
 			EventSource source) {
 	    super( source, entity, id, persister );
 		this.deletedState = deletedState;
 	}
 
 	/**
 	 * Getter for property 'deletedState'.  This is the entity state at the
 	 * time of deletion (useful for optomistic locking and such).
 	 *
 	 * @return Value for property 'deletedState'.
 	 */
 	public Object[] getDeletedState() {
 		return deletedState;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreDeleteEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEventListener.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/PreDeleteEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEventListener.java
index 5885838df6..eae852717e 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreDeleteEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreDeleteEventListener.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before deleting an item from the datastore
  * 
  * @author Gavin King
  */
 public interface PreDeleteEventListener extends Serializable {
 	/**
 	 * Return true if the operation should be vetoed
 	 */
 	public boolean onPreDelete(PreDeleteEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreInsertEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEvent.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/PreInsertEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEvent.java
index ad92f5858d..d2a74b974e 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreInsertEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEvent.java
@@ -1,66 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Represents a <tt>pre-insert</tt> event, which occurs just prior to
  * performing the insert of an entity into the database.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class PreInsertEvent extends AbstractPreDatabaseOperationEvent {
 	private Object[] state;
 
 	/**
 	 * Constructs an event containing the pertinent information.
 	 *
 	 * @param entity The entity to be inserted.
 	 * @param id The id to use in the insertion.
 	 * @param state The state to be inserted.
 	 * @param persister The entity's persister.
 	 * @param source The session from which the event originated.
 	 */
 	public PreInsertEvent(
 			Object entity,
 			Serializable id,
 			Object[] state,
 			EntityPersister persister,
 			EventSource source) {
 		super( source, entity, id, persister );
 		this.state = state;
 	}
 
 	/**
 	 * Getter for property 'state'.  These are the values to be inserted.
 	 *
 	 * @return Value for property 'state'.
 	 */
 	public Object[] getState() {
 		return state;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreInsertEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEventListener.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/PreInsertEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEventListener.java
index 9403665b98..43b5d62040 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreInsertEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreInsertEventListener.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before inserting an item in the datastore
  * 
  * @author Gavin King
  */
 public interface PreInsertEventListener extends Serializable {
 	/**
 	 * Return true if the operation should be vetoed
 	 */
 	public boolean onPreInsert(PreInsertEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreLoadEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEvent.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/event/PreLoadEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEvent.java
index f11a42c236..7d825fee87 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreLoadEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEvent.java
@@ -1,81 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Called before injecting property values into a newly 
  * loaded entity instance.
  *
  * @author Gavin King
  */
 public class PreLoadEvent extends AbstractEvent {
 	private Object entity;
 	private Object[] state;
 	private Serializable id;
 	private EntityPersister persister;
 
 	public PreLoadEvent(EventSource session) {
 		super(session);
 	}
 
 	public Object getEntity() {
 		return entity;
 	}
 	
 	public Serializable getId() {
 		return id;
 	}
 	
 	public EntityPersister getPersister() {
 		return persister;
 	}
 	
 	public Object[] getState() {
 		return state;
 	}
 
 	public PreLoadEvent setEntity(Object entity) {
 		this.entity = entity;
 		return this;
 	}
 	
 	public PreLoadEvent setId(Serializable id) {
 		this.id = id;
 		return this;
 	}
 	
 	public PreLoadEvent setPersister(EntityPersister persister) {
 		this.persister = persister;
 		return this;
 	}
 	
 	public PreLoadEvent setState(Object[] state) {
 		this.state = state;
 		return this;
 	}
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEventListener.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/event/PreLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEventListener.java
index a4289de869..f4659b5f36 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreLoadEventListener.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before injecting property values into a newly 
  * loaded entity instance.
  *
  * @author Gavin King
  */
 public interface PreLoadEventListener extends Serializable {
 	public void onPreLoad(PreLoadEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreUpdateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEvent.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/PreUpdateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEvent.java
index 3a546b9b79..69662ae463 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreUpdateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEvent.java
@@ -1,81 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Represents a <tt>pre-update</tt> event, which occurs just prior to
  * performing the update of an entity in the database.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class PreUpdateEvent extends AbstractPreDatabaseOperationEvent {
 	private Object[] state;
 	private Object[] oldState;
 
 	/**
 	 * Constructs an event containing the pertinent information.
 	 *
 	 * @param entity The entity to be updated.
 	 * @param id The id of the entity to use for updating.
 	 * @param state The state to be updated.
 	 * @param oldState The state of the entity at the time it was loaded from
 	 * the database.
 	 * @param persister The entity's persister.
 	 * @param source The session from which the event originated.
 	 */
 	public PreUpdateEvent(
 			Object entity,
 			Serializable id,
 			Object[] state,
 			Object[] oldState,
 			EntityPersister persister,
 			EventSource source) {
 		super( source, entity, id, persister );
 		this.state = state;
 		this.oldState = oldState;
 	}
 
 	/**
 	 * Retrieves the state to be used in the update.
 	 *
 	 * @return The current state.
 	 */
 	public Object[] getState() {
 		return state;
 	}
 
 	/**
 	 * The old state of the entity at the time it was last loaded from the
 	 * database; can be null in the case of detached entities.
 	 *
 	 * @return The loaded state, or null.
 	 */
 	public Object[] getOldState() {
 		return oldState;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/PreUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEventListener.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/event/PreUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEventListener.java
index 4991f3af96..28c5effea4 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/PreUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/PreUpdateEventListener.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 
 /**
  * Called before updating the datastore
  * 
  * @author Gavin King
  */
 public interface PreUpdateEventListener extends Serializable {
 	/**
 	 * Return true if the operation should be vetoed
 	 */
 	public boolean onPreUpdate(PreUpdateEvent event);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/RefreshEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEvent.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/RefreshEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEvent.java
index 7af132aaa6..408efa3ebc 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/RefreshEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEvent.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 
 /**
  *  Defines an event class for the refreshing of an object.
  *
  * @author Steve Ebersole
  */
 public class RefreshEvent extends AbstractEvent {
 
 	private Object object;
 	private LockOptions lockOptions = new LockOptions().setLockMode(LockMode.READ);
 
 	public RefreshEvent(Object object, EventSource source) {
 		super(source);
 		if (object == null) {
 			throw new IllegalArgumentException("Attempt to generate refresh event with null object");
 		}
 		this.object = object;
 	}
 
 	public RefreshEvent(Object object, LockMode lockMode, EventSource source) {
 		this(object, source);
 		if (lockMode == null) {
 			throw new IllegalArgumentException("Attempt to generate refresh event with null lock mode");
 		}
 		this.lockOptions.setLockMode(lockMode);
 	}
 
 	public RefreshEvent(Object object, LockOptions lockOptions, EventSource source) {
 		this(object, source);
 		if (lockOptions == null) {
 			throw new IllegalArgumentException("Attempt to generate refresh event with null lock request");
 		}
 		this.lockOptions = lockOptions;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public LockOptions getLockOptions() {
 		return lockOptions;
 	}
 
 	public LockMode getLockMode() {
 		return lockOptions.getLockMode();
 	}
 
 	public int getLockTimeout() {
 		return this.lockOptions.getTimeOut();
 	}
 
 	public boolean getLockScope() {
 		return this.lockOptions.getScope();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/RefreshEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEventListener.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/event/RefreshEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEventListener.java
index 7de7d75166..d86885d398 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/RefreshEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/RefreshEventListener.java
@@ -1,47 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import java.util.Map;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of refresh events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface RefreshEventListener extends Serializable {
 
     /** 
      * Handle the given refresh event.
      *
      * @param event The refresh event to be handled.
      * @throws HibernateException
      */
 	public void onRefresh(RefreshEvent event) throws HibernateException;
 	
 	public void onRefresh(RefreshEvent event, Map refreshedAlready) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/ReplicateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEvent.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/event/ReplicateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEvent.java
index 0341c60de9..d029465a75 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/ReplicateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEvent.java
@@ -1,84 +1,83 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import org.hibernate.ReplicationMode;
 
 /**
  *  Defines an event class for the replication of an entity.
  *
  * @author Steve Ebersole
  */
 public class ReplicateEvent extends AbstractEvent {
-
 	private Object object;
 	private ReplicationMode replicationMode;
 	private String entityName;
 
 	public ReplicateEvent(Object object, ReplicationMode replicationMode, EventSource source) {
 		this(null, object, replicationMode, source);
 	}
 	
 	public ReplicateEvent(String entityName, Object object, ReplicationMode replicationMode, EventSource source) {
 		super(source);
 		this.entityName = entityName;
 
 		if ( object == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create replication strategy with null entity"
 			);
 		}
 		if ( replicationMode == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create replication strategy with null replication mode"
 			);
 		}
 
 		this.object = object;
 		this.replicationMode = replicationMode;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public void setObject(Object object) {
 		this.object = object;
 	}
 
 	public ReplicationMode getReplicationMode() {
 		return replicationMode;
 	}
 
 	public void setReplicationMode(ReplicationMode replicationMode) {
 		this.replicationMode = replicationMode;
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/ReplicateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/ReplicateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEventListener.java
index 8a60167a62..90b3a7f8f2 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/ReplicateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/ReplicateEventListener.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of replicate events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface ReplicateEventListener extends Serializable {
 
     /** Handle the given replicate event.
      *
      * @param event The replicate event to be handled.
      * @throws HibernateException
      */
 	public void onReplicate(ReplicateEvent event) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEvent.java b/hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEvent.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEvent.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEvent.java
index 895d46d444..ba733b1d2f 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEvent.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEvent.java
@@ -1,115 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.engine.spi.EntityEntry;
 
 /** 
  * An event class for saveOrUpdate()
  *
  * @author Steve Ebersole
  */
 public class SaveOrUpdateEvent extends AbstractEvent {
 
 	private Object object;
 	private Serializable requestedId;
 	private String entityName;
 	private Object entity;
 	private EntityEntry entry;
 	private Serializable resultId;
 
 	public SaveOrUpdateEvent(String entityName, Object original, EventSource source) {
 		this(original, source);
 		this.entityName = entityName;
 	}
 
 	public SaveOrUpdateEvent(String entityName, Object original, Serializable id, EventSource source) {
 		this(entityName, original, source);
 		this.requestedId = id;
 		if ( requestedId == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create saveOrUpdate event with null identifier"
 				);
 		}
 	}
 
 	public SaveOrUpdateEvent(Object object, EventSource source) {
 		super(source);
 		if ( object == null ) {
 			throw new IllegalArgumentException(
 					"attempt to create saveOrUpdate event with null entity"
 				);
 		}
 		this.object = object;
 	}
 
 	public Object getObject() {
 		return object;
 	}
 
 	public void setObject(Object object) {
 		this.object = object;
 	}
 
 	public Serializable getRequestedId() {
 		return requestedId;
 	}
 
 	public void setRequestedId(Serializable requestedId) {
 		this.requestedId = requestedId;
 	}
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 
 	public Object getEntity() {
 		return entity;
 	}
 	
 	public void setEntity(Object entity) {
 		this.entity = entity;
 	}
 	
 	public EntityEntry getEntry() {
 		return entry;
 	}
 	
 	public void setEntry(EntityEntry entry) {
 		this.entry = entry;
 	}
 
 	public Serializable getResultId() {
 		return resultId;
 	}
 
 	public void setResultId(Serializable resultId) {
 		this.resultId = resultId;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEventListener.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEventListener.java
index d1e8e89e2e..f5284dfc7f 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/SaveOrUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/spi/SaveOrUpdateEventListener.java
@@ -1,44 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.event;
+package org.hibernate.event.spi;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
 
 /**
  * Defines the contract for handling of update events generated from a session.
  *
  * @author Steve Ebersole
  */
 public interface SaveOrUpdateEventListener extends Serializable {
 
     /** 
      * Handle the given update event.
      *
      * @param event The update event to be handled.
      * @throws HibernateException
      */
 	public void onSaveOrUpdate(SaveOrUpdateEvent event) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java b/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java
index 6517b28ecd..11efcfea82 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java
@@ -1,191 +1,191 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql;
 
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.Type;
 
 /**
  * Defines the contract of an HQL->SQL translator.
  *
  * @author josh
  */
 public interface QueryTranslator {
 
 	// Error message constants.
 	public static final String ERROR_CANNOT_FETCH_WITH_ITERATE = "fetch may not be used with scroll() or iterate()";
 	public static final String ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR = "Named parameter does not appear in Query: ";
     public static final String ERROR_CANNOT_DETERMINE_TYPE = "Could not determine type of: ";
 	public static final String ERROR_CANNOT_FORMAT_LITERAL =  "Could not format constant value to SQL literal: ";
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	void compile(Map replacements, boolean shallow) throws QueryException, MappingException;
 
 	/**
 	 * Perform a list operation given the underlying query definition.
 	 *
 	 * @param session         The session owning this query.
 	 * @param queryParameters The query bind parameters.
 	 * @return The query list results.
 	 * @throws HibernateException
 	 */
 	List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException;
 
 	/**
 	 * Perform an iterate operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return An iterator over the query results.
 	 * @throws HibernateException
 	 */
 	Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException;
 
 	/**
 	 * Perform a scroll operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The ScrollableResults wrapper around the query results.
 	 * @throws HibernateException
 	 */
 	ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Perform a bulk update/delete operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The number of entities updated or deleted.
 	 * @throws HibernateException
 	 */
 	int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Returns the set of query spaces (table names) that the query refers to.
 	 *
 	 * @return A set of query spaces (table names).
 	 */
 	Set getQuerySpaces();
 
 	/**
 	 * Retrieve the query identifier for this translator.  The query identifier is
 	 * used in states collection.
 	 *
 	 * @return the identifier
 	 */
 	String getQueryIdentifier();
 
 	/**
 	 * Returns the SQL string generated by the translator.
 	 *
 	 * @return the SQL string generated by the translator.
 	 */
 	String getSQLString();
 
 	List collectSqlStrings();
 
 	/**
 	 * Returns the HQL string processed by the translator.
 	 *
 	 * @return the HQL string processed by the translator.
 	 */
 	String getQueryString();
 
 	/**
 	 * Returns the filters enabled for this query translator.
 	 *
 	 * @return Filters enabled for this query execution.
 	 */
 	Map getEnabledFilters();
 
 	/**
 	 * Returns an array of Types represented in the query result.
 	 *
 	 * @return Query return types.
 	 */
 	Type[] getReturnTypes();
 	
 	/**
 	 * Returns an array of HQL aliases
 	 */
 	String[] getReturnAliases();
 
 	/**
 	 * Returns the column names in the generated SQL.
 	 *
 	 * @return the column names in the generated SQL.
 	 */
 	String[][] getColumnNames();
 
 	/**
 	 * Return information about any parameters encountered during
 	 * translation.
 	 *
 	 * @return The parameter information.
 	 */
 	ParameterTranslations getParameterTranslations();
 
 	/**
 	 * Validate the scrollability of the translated query.
 	 *
 	 * @throws HibernateException
 	 */
 	void validateScrollability() throws HibernateException;
 
 	/**
 	 * Does the translated query contain collection fetches?
 	 *
 	 * @return true if the query does contain collection fetched;
 	 * false otherwise.
 	 */
 	boolean containsCollectionFetches();
 
 	boolean isManipulationStatement();
 
 	public Class getDynamicInstantiationResultType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java
index 77605cc1a1..de43b6e5dd 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java
@@ -1,600 +1,600 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.ast;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import antlr.ANTLRException;
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.FilterTranslator;
 import org.hibernate.hql.ParameterTranslations;
 import org.hibernate.hql.QueryExecutionRequestException;
 import org.hibernate.hql.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.antlr.HqlTokenTypes;
 import org.hibernate.hql.antlr.SqlTokenTypes;
 import org.hibernate.hql.ast.exec.BasicExecutor;
 import org.hibernate.hql.ast.exec.MultiTableDeleteExecutor;
 import org.hibernate.hql.ast.exec.MultiTableUpdateExecutor;
 import org.hibernate.hql.ast.exec.StatementExecutor;
 import org.hibernate.hql.ast.tree.AggregatedSelectExpression;
 import org.hibernate.hql.ast.tree.FromElement;
 import org.hibernate.hql.ast.tree.InsertStatement;
 import org.hibernate.hql.ast.tree.QueryNode;
 import org.hibernate.hql.ast.tree.Statement;
 import org.hibernate.hql.ast.util.ASTPrinter;
 import org.hibernate.hql.ast.util.ASTUtil;
 import org.hibernate.hql.ast.util.NodeTraverser;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.loader.hql.QueryLoader;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.Type;
 
 /**
  * A QueryTranslator that uses an Antlr-based parser.
  *
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 public class QueryTranslatorImpl implements FilterTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryTranslatorImpl.class.getName());
 
 	private SessionFactoryImplementor factory;
 
 	private final String queryIdentifier;
 	private String hql;
 	private boolean shallowQuery;
 	private Map tokenReplacements;
 
 	private Map enabledFilters; //TODO:this is only needed during compilation .. can we eliminate the instvar?
 
 	private boolean compiled;
 	private QueryLoader queryLoader;
 	private StatementExecutor statementExecutor;
 
 	private Statement sqlAst;
 	private String sql;
 
 	private ParameterTranslations paramTranslations;
 	private List collectedParameterSpecifications;
 
 
 	/**
 	 * Creates a new AST-based query translator.
 	 *
 	 * @param queryIdentifier The query-identifier (used in stats collection)
 	 * @param query The hql query to translate
 	 * @param enabledFilters Currently enabled filters
 	 * @param factory The session factory constructing this translator instance.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 	        String query,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		this.queryIdentifier = queryIdentifier;
 		this.hql = query;
 		this.compiled = false;
 		this.shallowQuery = false;
 		this.enabledFilters = enabledFilters;
 		this.factory = factory;
 	}
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	public void compile(
 	        Map replacements,
 	        boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, null );
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param collectionRole the role name of the collection used as the basis for the filter.
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	public void compile(
 	        String collectionRole,
 	        Map replacements,
 	        boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, collectionRole );
 	}
 
 	/**
 	 * Performs both filter and non-filter compiling.
 	 *
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @param collectionRole the role name of the collection used as the basis for the filter, NULL if this
 	 *                       is not a filter.
 	 */
 	private synchronized void doCompile(Map replacements, boolean shallow, String collectionRole) {
 		// If the query is already compiled, skip the compilation.
 		if ( compiled ) {
             LOG.debugf("compile() : The query is already compiled, skipping...");
 			return;
 		}
 
 		// Remember the parameters for the compilation.
 		this.tokenReplacements = replacements;
 		if ( tokenReplacements == null ) {
 			tokenReplacements = new HashMap();
 		}
 		this.shallowQuery = shallow;
 
 		try {
 			// PHASE 1 : Parse the HQL into an AST.
 			HqlParser parser = parse( true );
 
 			// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.
 			HqlSqlWalker w = analyze( parser, collectionRole );
 
 			sqlAst = ( Statement ) w.getAST();
 
 			// at some point the generate phase needs to be moved out of here,
 			// because a single object-level DML might spawn multiple SQL DML
 			// command executions.
 			//
 			// Possible to just move the sql generation for dml stuff, but for
 			// consistency-sake probably best to just move responsiblity for
 			// the generation phase completely into the delegates
 			// (QueryLoader/StatementExecutor) themselves.  Also, not sure why
 			// QueryLoader currently even has a dependency on this at all; does
 			// it need it?  Ideally like to see the walker itself given to the delegates directly...
 
 			if ( sqlAst.needsExecutor() ) {
 				statementExecutor = buildAppropriateStatementExecutor( w );
 			}
 			else {
 				// PHASE 3 : Generate the SQL.
 				generate( ( QueryNode ) sqlAst );
 				queryLoader = new QueryLoader( this, factory, w.getSelectClause() );
 			}
 
 			compiled = true;
 		}
 		catch ( QueryException qe ) {
 			qe.setQueryString( hql );
 			throw qe;
 		}
 		catch ( RecognitionException e ) {
             // we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
             LOG.trace("Converted antlr.RecognitionException", e);
 			throw QuerySyntaxException.convert( e, hql );
 		}
 		catch ( ANTLRException e ) {
             // we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
             LOG.trace("Converted antlr.ANTLRException", e);
 			throw new QueryException( e.getMessage(), hql );
 		}
 
 		this.enabledFilters = null; //only needed during compilation phase...
 	}
 
 	private void generate(AST sqlAst) throws QueryException, RecognitionException {
 		if ( sql == null ) {
 			SqlGenerator gen = new SqlGenerator(factory);
 			gen.statement( sqlAst );
 			sql = gen.getSQL();
             if (LOG.isDebugEnabled()) {
                 LOG.debugf("HQL: %s", hql);
                 LOG.debugf("SQL: %s", sql);
 			}
 			gen.getParseErrorHandler().throwQueryException();
 			collectedParameterSpecifications = gen.getCollectedParameters();
 		}
 	}
 
 	private HqlSqlWalker analyze(HqlParser parser, String collectionRole) throws QueryException, RecognitionException {
 		HqlSqlWalker w = new HqlSqlWalker( this, factory, parser, tokenReplacements, collectionRole );
 		AST hqlAst = parser.getAST();
 
 		// Transform the tree.
 		w.statement( hqlAst );
 
         if (LOG.isDebugEnabled()) {
 			ASTPrinter printer = new ASTPrinter( SqlTokenTypes.class );
             LOG.debug( printer.showAsString( w.getAST(), "--- SQL AST ---" ) );
 		}
 
 		w.getParseErrorHandler().throwQueryException();
 
 		return w;
 	}
 
 	private HqlParser parse(boolean filter) throws TokenStreamException, RecognitionException {
 		// Parse the query string into an HQL AST.
 		HqlParser parser = HqlParser.getInstance( hql );
 		parser.setFilter( filter );
 
         LOG.debugf("parse() - HQL: %s", hql);
 		parser.statement();
 
 		AST hqlAst = parser.getAST();
 
 		JavaConstantConverter converter = new JavaConstantConverter();
 		NodeTraverser walker = new NodeTraverser( converter );
 		walker.traverseDepthFirst( hqlAst );
 
 		showHqlAst( hqlAst );
 
 		parser.getParseErrorHandler().throwQueryException();
 		return parser;
 	}
 
 	void showHqlAst(AST hqlAst) {
         if (LOG.isDebugEnabled()) {
 			ASTPrinter printer = new ASTPrinter( HqlTokenTypes.class );
             LOG.debug( printer.showAsString( hqlAst, "--- HQL AST ---" ) );
 		}
 	}
 
 	private void errorIfDML() throws HibernateException {
 		if ( sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for DML operations", hql );
 		}
 	}
 
 	private void errorIfSelect() throws HibernateException {
 		if ( !sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for select queries", hql );
 		}
 	}
 
 	public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	public Statement getSqlAST() {
 		return sqlAst;
 	}
 
 	private HqlSqlWalker getWalker() {
 		return sqlAst.getWalker();
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	public Type[] getReturnTypes() {
 		errorIfDML();
 		return getWalker().getReturnTypes();
 	}
 
 	public String[] getReturnAliases() {
 		errorIfDML();
 		return getWalker().getReturnAliases();
 	}
 
 	public String[][] getColumnNames() {
 		errorIfDML();
 		return getWalker().getSelectClause().getColumnNames();
 	}
 
 	public Set getQuerySpaces() {
 		return getWalker().getQuerySpaces();
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		QueryNode query = ( QueryNode ) sqlAst;
 		boolean hasLimit = queryParameters.getRowSelection() != null && queryParameters.getRowSelection().definesLimits();
 		boolean needsDistincting = ( query.getSelectClause().isDistinct() || hasLimit ) && containsCollectionFetches();
 
 		QueryParameters queryParametersToUse;
 		if ( hasLimit && containsCollectionFetches() ) {
             LOG.firstOrMaxResultsSpecifiedWithCollectionFetch();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List results = queryLoader.list( session, queryParametersToUse );
 
 		if ( needsDistincting ) {
 			int includedCount = -1;
 			// NOTE : firstRow is zero-based
 			int first = !hasLimit || queryParameters.getRowSelection().getFirstRow() == null
 						? 0
 						: queryParameters.getRowSelection().getFirstRow().intValue();
 			int max = !hasLimit || queryParameters.getRowSelection().getMaxRows() == null
 						? -1
 						: queryParameters.getRowSelection().getMaxRows().intValue();
 			int size = results.size();
 			List tmp = new ArrayList();
 			IdentitySet distinction = new IdentitySet();
 			for ( int i = 0; i < size; i++ ) {
 				final Object result = results.get( i );
 				if ( !distinction.add( result ) ) {
 					continue;
 				}
 				includedCount++;
 				if ( includedCount < first ) {
 					continue;
 				}
 				tmp.add( result );
 				// NOTE : ( max - 1 ) because first is zero-based while max is not...
 				if ( max >= 0 && ( includedCount - first ) >= ( max - 1 ) ) {
 					break;
 				}
 			}
 			results = tmp;
 		}
 
 		return results;
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.iterate( queryParameters, session );
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 */
 	public ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.scroll( queryParameters, session );
 	}
 
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		errorIfSelect();
 		return statementExecutor.execute( queryParameters, session );
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 */
 	public String getSQLString() {
 		return sql;
 	}
 
 	public List collectSqlStrings() {
 		ArrayList list = new ArrayList();
 		if ( isManipulationStatement() ) {
 			String[] sqlStatements = statementExecutor.getSqlStatements();
 			for ( int i = 0; i < sqlStatements.length; i++ ) {
 				list.add( sqlStatements[i] );
 			}
 		}
 		else {
 			list.add( sql );
 		}
 		return list;
 	}
 
 	// -- Package local methods for the QueryLoader delegate --
 
 	public boolean isShallowQuery() {
 		return shallowQuery;
 	}
 
 	public String getQueryString() {
 		return hql;
 	}
 
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		return getWalker().getNamedParameterLocations( name );
 	}
 
 	public boolean containsCollectionFetches() {
 		errorIfDML();
 		List collectionFetches = ( ( QueryNode ) sqlAst ).getFromClause().getCollectionFetches();
 		return collectionFetches != null && collectionFetches.size() > 0;
 	}
 
 	public boolean isManipulationStatement() {
 		return sqlAst.needsExecutor();
 	}
 
 	public void validateScrollability() throws HibernateException {
 		// Impl Note: allows multiple collection fetches as long as the
 		// entire fecthed graph still "points back" to a single
 		// root entity for return
 
 		errorIfDML();
 
 		QueryNode query = ( QueryNode ) sqlAst;
 
 		// If there are no collection fetches, then no further checks are needed
 		List collectionFetches = query.getFromClause().getCollectionFetches();
 		if ( collectionFetches.isEmpty() ) {
 			return;
 		}
 
 		// A shallow query is ok (although technically there should be no fetching here...)
 		if ( isShallowQuery() ) {
 			return;
 		}
 
 		// Otherwise, we have a non-scalar select with defined collection fetch(es).
 		// Make sure that there is only a single root entity in the return (no tuples)
 		if ( getReturnTypes().length > 1 ) {
 			throw new HibernateException( "cannot scroll with collection fetches and returned tuples" );
 		}
 
 		FromElement owner = null;
 		Iterator itr = query.getSelectClause().getFromElementsForLoad().iterator();
 		while ( itr.hasNext() ) {
 			// should be the first, but just to be safe...
 			final FromElement fromElement = ( FromElement ) itr.next();
 			if ( fromElement.getOrigin() == null ) {
 				owner = fromElement;
 				break;
 			}
 		}
 
 		if ( owner == null ) {
 			throw new HibernateException( "unable to locate collection fetch(es) owner for scrollability checks" );
 		}
 
 		// This is not strictly true.  We actually just need to make sure that
 		// it is ordered by root-entity PK and that that order-by comes before
 		// any non-root-entity ordering...
 
 		AST primaryOrdering = query.getOrderByClause().getFirstChild();
 		if ( primaryOrdering != null ) {
 			// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)
 			String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
 			String expectedPrimaryOrderSeq = StringHelper.join(
 			        ", ",
 			        StringHelper.qualify( owner.getTableAlias(), idColNames )
 			);
 			if (  !primaryOrdering.getText().startsWith( expectedPrimaryOrderSeq ) ) {
 				throw new HibernateException( "cannot scroll results with collection fetches which are not ordered primarily by the root entity's PK" );
 			}
 		}
 	}
 
 	private StatementExecutor buildAppropriateStatementExecutor(HqlSqlWalker walker) {
 		Statement statement = ( Statement ) walker.getAST();
 		if ( walker.getStatementType() == HqlSqlTokenTypes.DELETE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				return new MultiTableDeleteExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.UPDATE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				// even here, if only properties mapped to the "base table" are referenced
 				// in the set and where clauses, this could be handled by the BasicDelegate.
 				// TODO : decide if it is better performance-wise to doAfterTransactionCompletion that check, or to simply use the MultiTableUpdateDelegate
 				return new MultiTableUpdateExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.INSERT ) {
 			return new BasicExecutor( walker, ( ( InsertStatement ) statement ).getIntoClause().getQueryable() );
 		}
 		else {
 			throw new QueryException( "Unexpected statement type" );
 		}
 	}
 
 	public ParameterTranslations getParameterTranslations() {
 		if ( paramTranslations == null ) {
 			paramTranslations = new ParameterTranslationsImpl( getWalker().getParameters() );
 //			paramTranslations = new ParameterTranslationsImpl( collectedParameterSpecifications );
 		}
 		return paramTranslations;
 	}
 
 	public List getCollectedParameterSpecifications() {
 		return collectedParameterSpecifications;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		AggregatedSelectExpression aggregation = queryLoader.getAggregatedSelectExpression();
 		return aggregation == null ? null : aggregation.getAggregationResultType();
 	}
 
 	public static class JavaConstantConverter implements NodeTraverser.VisitationStrategy {
 		private AST dotRoot;
 		public void visit(AST node) {
 			if ( dotRoot != null ) {
 				// we are already processing a dot-structure
                 if (ASTUtil.isSubtreeChild(dotRoot, node)) return;
                 // we are now at a new tree level
                 dotRoot = null;
 			}
 
 			if ( dotRoot == null && node.getType() == HqlTokenTypes.DOT ) {
 				dotRoot = node;
 				handleDotStructure( dotRoot );
 			}
 		}
 		private void handleDotStructure(AST dotStructureRoot) {
 			String expression = ASTUtil.getPathText( dotStructureRoot );
 			Object constant = ReflectHelper.getConstantValue( expression );
 			if ( constant != null ) {
 				dotStructureRoot.setFirstChild( null );
 				dotStructureRoot.setType( HqlTokenTypes.JAVA_CONSTANT );
 				dotStructureRoot.setText( expression );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
index b2f40b0229..5b22a1bdb3 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
@@ -1,308 +1,308 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.ast.exec;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLWarning;
 import java.sql.Statement;
 import java.util.Collections;
 import java.util.List;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.action.internal.BulkOperationCleanupAction;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.hql.ast.SqlGenerator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jdbc.AbstractWork;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InsertSelect;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.jboss.logging.Logger;
 import antlr.RecognitionException;
 import antlr.collections.AST;
 
 /**
  * Implementation of AbstractStatementExecutor.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractStatementExecutor implements StatementExecutor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractStatementExecutor.class.getName());
 
 	private final HqlSqlWalker walker;
 	private List idSelectParameterSpecifications = Collections.EMPTY_LIST;
 
     public AbstractStatementExecutor( HqlSqlWalker walker,
                                       CoreMessageLogger log ) {
 		this.walker = walker;
 	}
 
 	protected HqlSqlWalker getWalker() {
 		return walker;
 	}
 
 	protected SessionFactoryImplementor getFactory() {
 		return walker.getSessionFactoryHelper().getFactory();
 	}
 
 	protected List getIdSelectParameterSpecifications() {
 		return idSelectParameterSpecifications;
 	}
 
 	protected abstract Queryable[] getAffectedQueryables();
 
 	protected String generateIdInsertSelect(Queryable persister, String tableAlias, AST whereClause) {
 		Select select = new Select( getFactory().getDialect() );
 		SelectFragment selectFragment = new SelectFragment()
 				.addColumns( tableAlias, persister.getIdentifierColumnNames(), persister.getIdentifierColumnNames() );
 		select.setSelectClause( selectFragment.toFragmentString().substring( 2 ) );
 
 		String rootTableName = persister.getTableName();
 		String fromJoinFragment = persister.fromJoinFragment( tableAlias, true, false );
 		String whereJoinFragment = persister.whereJoinFragment( tableAlias, true, false );
 
 		select.setFromClause( rootTableName + ' ' + tableAlias + fromJoinFragment );
 
 		if ( whereJoinFragment == null ) {
 			whereJoinFragment = "";
 		}
 		else {
 			whereJoinFragment = whereJoinFragment.trim();
 			if ( whereJoinFragment.startsWith( "and" ) ) {
 				whereJoinFragment = whereJoinFragment.substring( 4 );
 			}
 		}
 
 		String userWhereClause = "";
 		if ( whereClause.getNumberOfChildren() != 0 ) {
 			// If a where clause was specified in the update/delete query, use it to limit the
 			// returned ids here...
 			try {
 				SqlGenerator sqlGenerator = new SqlGenerator( getFactory() );
 				sqlGenerator.whereClause( whereClause );
 				userWhereClause = sqlGenerator.getSQL().substring( 7 );  // strip the " where "
 				idSelectParameterSpecifications = sqlGenerator.getCollectedParameters();
 			}
 			catch ( RecognitionException e ) {
 				throw new HibernateException( "Unable to generate id select for DML operation", e );
 			}
 			if ( whereJoinFragment.length() > 0 ) {
 				whereJoinFragment += " and ";
 			}
 		}
 
 		select.setWhereClause( whereJoinFragment + userWhereClause );
 
 		InsertSelect insert = new InsertSelect( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert-select for " + persister.getEntityName() + " ids" );
 		}
 		insert.setTableName( persister.getTemporaryIdTableName() );
 		insert.setSelect( select );
 		return insert.toStatementString();
 	}
 
 	protected String generateIdSubselect(Queryable persister) {
 		return "select " + StringHelper.join( ", ", persister.getIdentifierColumnNames() ) +
 			        " from " + persister.getTemporaryIdTableName();
 	}
 
 	private static class TemporaryTableCreationWork extends AbstractWork {
 		private final Queryable persister;
 
 		private TemporaryTableCreationWork(Queryable persister) {
 			this.persister = persister;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement.executeUpdate( persister.getTemporaryIdTableDDL() );
 					persister.getFactory()
 							.getServiceRegistry()
 							.getService( JdbcServices.class )
 							.getSqlExceptionHelper()
 							.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				LOG.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
 			}
 		}
 	}
 	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
 		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
 		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
 		TemporaryTableCreationWork work = new TemporaryTableCreationWork( persister );
 		if ( shouldIsolateTemporaryTableDDL() ) {
 			session.getTransactionCoordinator()
 					.getTransaction()
 					.createIsolationDelegate()
 					.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
 		}
 		else {
 			final Connection connection = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.getShareableConnectionProxy();
 			work.execute( connection );
 			session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.afterStatementExecution();
 		}
 	}
 
 	private static SqlExceptionHelper.WarningHandler CREATION_WARNING_HANDLER = new SqlExceptionHelper.WarningHandlerLoggingSupport() {
 		public boolean doProcess() {
 			return LOG.isDebugEnabled();
 		}
 
 		public void prepare(SQLWarning warning) {
             LOG.warningsCreatingTempTable(warning);
 		}
 
 		@Override
 		protected void logWarning(String description, String message) {
             LOG.debugf(description);
             LOG.debugf(message);
 		}
 	};
 
 	private static class TemporaryTableDropWork extends AbstractWork {
 		private final Queryable persister;
 		private final SessionImplementor session;
 
 		private TemporaryTableDropWork(Queryable persister, SessionImplementor session) {
 			this.persister = persister;
 			this.session = session;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			final String command = session.getFactory().getDialect().getDropTemporaryTableString()
 					+ ' ' + persister.getTemporaryIdTableName();
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement = connection.createStatement();
 					statement.executeUpdate( command );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				LOG.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
 			}
 		}
 	}
 
 	protected void dropTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
 		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
 			TemporaryTableDropWork work = new TemporaryTableDropWork( persister, session );
 			if ( shouldIsolateTemporaryTableDDL() ) {
 				session.getTransactionCoordinator()
 						.getTransaction()
 						.createIsolationDelegate()
 						.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
 			}
 			else {
 				final Connection connection = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getLogicalConnection()
 						.getShareableConnectionProxy();
 				work.execute( connection );
 				session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getLogicalConnection()
 						.afterStatementExecution();
 			}
 		}
 		else {
 			// at the very least cleanup the data :)
 			PreparedStatement ps = null;
 			try {
 				final String sql = "delete from " + persister.getTemporaryIdTableName();
 				ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				ps.executeUpdate();
 			}
 			catch( Throwable t ) {
                 LOG.unableToCleanupTemporaryIdTable(t);
 			}
 			finally {
 				if ( ps != null ) {
 					try {
 						ps.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 		}
 	}
 
 	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
 		BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getAffectedQueryables() );
 
 		if ( session.isEventSource() ) {
 			( ( EventSource ) session ).getActionQueue().addAction( action );
 		}
 		else {
 			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
 		}
 	}
 
 	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	protected boolean shouldIsolateTemporaryTableDDL() {
 		Boolean dialectVote = getFactory().getDialect().performTemporaryTableDDLInIsolation();
         if (dialectVote != null) return dialectVote.booleanValue();
         return getFactory().getSettings().isDataDefinitionImplicitCommit();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java
index 90141dfc9b..0cfa051267 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java
@@ -1,1053 +1,1053 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.classic;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.FilterTranslator;
 import org.hibernate.hql.HolderInstantiator;
 import org.hibernate.hql.NameGenerator;
 import org.hibernate.hql.ParameterTranslations;
 import org.hibernate.internal.IteratorImpl;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.BasicLoader;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.QuerySelect;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * An instance of <tt>QueryTranslator</tt> translates a Hibernate
  * query string to SQL.
  */
 public class QueryTranslatorImpl extends BasicLoader implements FilterTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryTranslatorImpl.class.getName());
 
 	private static final String[] NO_RETURN_ALIASES = new String[] {};
 
 	private final String queryIdentifier;
 	private final String queryString;
 
 	private final Map typeMap = new LinkedHashMap();
 	private final Map collections = new LinkedHashMap();
 	private List returnedTypes = new ArrayList();
 	private final List fromTypes = new ArrayList();
 	private final List scalarTypes = new ArrayList();
 	private final Map namedParameters = new HashMap();
 	private final Map aliasNames = new HashMap();
 	private final Map oneToOneOwnerNames = new HashMap();
 	private final Map uniqueKeyOwnerReferences = new HashMap();
 	private final Map decoratedPropertyMappings = new HashMap();
 
 	private final List scalarSelectTokens = new ArrayList();
 	private final List whereTokens = new ArrayList();
 	private final List havingTokens = new ArrayList();
 	private final Map joins = new LinkedHashMap();
 	private final List orderByTokens = new ArrayList();
 	private final List groupByTokens = new ArrayList();
 	private final Set querySpaces = new HashSet();
 	private final Set entitiesToFetch = new HashSet();
 
 	private final Map pathAliases = new HashMap();
 	private final Map pathJoins = new HashMap();
 
 	private Queryable[] persisters;
 	private int[] owners;
 	private EntityType[] ownerAssociationTypes;
 	private String[] names;
 	private boolean[] includeInSelect;
 	private int selectLength;
 	private Type[] returnTypes;
 	private Type[] actualReturnTypes;
 	private String[][] scalarColumnNames;
 	private Map tokenReplacements;
 	private int nameCount = 0;
 	private int parameterCount = 0;
 	private boolean distinct = false;
 	private boolean compiled;
 	private String sqlString;
 	private Class holderClass;
 	private Constructor holderConstructor;
 	private boolean hasScalars;
 	private boolean shallowQuery;
 	private QueryTranslatorImpl superQuery;
 
 	private QueryableCollection collectionPersister;
 	private int collectionOwnerColumn = -1;
 	private String collectionOwnerName;
 	private String fetchName;
 
 	private String[] suffixes;
 
 	private Map enabledFilters;
 
 	/**
 	 * Construct a query translator
 	 *
 	 * @param queryIdentifier A unique identifier for the query of which this
 	 * translation is part; typically this is the original, user-supplied query string.
 	 * @param queryString The "preprocessed" query string; at the very least
 	 * already processed by {@link org.hibernate.hql.QuerySplitter}.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		super( factory );
 		this.queryIdentifier = queryIdentifier;
 		this.queryString = queryString;
 		this.enabledFilters = enabledFilters;
 	}
 
 	/**
 	 * Construct a query translator; this form used internally.
 	 *
 	 * @param queryString The query string to process.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		this( queryString, queryString, enabledFilters, factory );
 	}
 
 	/**
 	 * Compile a subquery.
 	 *
 	 * @param superquery The containing query of the query to be compiled.
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	void compile(QueryTranslatorImpl superquery) throws QueryException, MappingException {
 		this.tokenReplacements = superquery.tokenReplacements;
 		this.superQuery = superquery;
 		this.shallowQuery = true;
 		this.enabledFilters = superquery.getEnabledFilters();
 		compile();
 	}
 
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 		if ( !compiled ) {
 			this.tokenReplacements = replacements;
 			this.shallowQuery = scalar;
 			compile();
 		}
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			String collectionRole,
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 
 		if ( !isCompiled() ) {
 			addFromAssociation( "this", collectionRole );
 			compile( replacements, scalar );
 		}
 	}
 
 	/**
 	 * Compile the query (generate the SQL).
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	private void compile() throws QueryException, MappingException {
 
         LOG.trace("Compiling query");
 		try {
 			ParserHelper.parse( new PreprocessingParser( tokenReplacements ),
 					queryString,
 					ParserHelper.HQL_SEPARATORS,
 					this );
 			renderSQL();
 		}
 		catch ( QueryException qe ) {
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 		catch ( MappingException me ) {
 			throw me;
 		}
 		catch ( Exception e ) {
             LOG.debug("Unexpected query compilation problem", e);
 			e.printStackTrace();
 			QueryException qe = new QueryException( "Incorrect query syntax", e );
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 
 		postInstantiate();
 
 		compiled = true;
 
 	}
 
 	@Override
     public String getSQLString() {
 		return sqlString;
 	}
 
 	public List collectSqlStrings() {
 		return ArrayHelper.toList( new String[] { sqlString } );
 	}
 
 	public String getQueryString() {
 		return queryString;
 	}
 
 	/**
 	 * Persisters for the return values of a <tt>find()</tt> style query.
 	 *
 	 * @return an array of <tt>EntityPersister</tt>s.
 	 */
 	@Override
     protected Loadable[] getEntityPersisters() {
 		return persisters;
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	public Type[] getReturnTypes() {
 		return actualReturnTypes;
 	}
 
 	public String[] getReturnAliases() {
 		// return aliases not supported in classic translator!
 		return NO_RETURN_ALIASES;
 	}
 
 	public String[][] getColumnNames() {
 		return scalarColumnNames;
 	}
 
 	private static void logQuery(String hql, String sql) {
         if (LOG.isDebugEnabled()) {
             LOG.debugf("HQL: %s", hql);
             LOG.debugf("SQL: %s", sql);
 		}
 	}
 
 	void setAliasName(String alias, String name) {
 		aliasNames.put( alias, name );
 	}
 
 	public String getAliasName(String alias) {
 		String name = ( String ) aliasNames.get( alias );
 		if ( name == null ) {
 			if ( superQuery != null ) {
 				name = superQuery.getAliasName( alias );
 			}
 			else {
 				name = alias;
 			}
 		}
 		return name;
 	}
 
 	String unalias(String path) {
 		String alias = StringHelper.root( path );
 		String name = getAliasName( alias );
         if (name != null) return name + path.substring(alias.length());
         return path;
 	}
 
 	void addEntityToFetch(String name, String oneToOneOwnerName, AssociationType ownerAssociationType) {
 		addEntityToFetch( name );
 		if ( oneToOneOwnerName != null ) oneToOneOwnerNames.put( name, oneToOneOwnerName );
 		if ( ownerAssociationType != null ) uniqueKeyOwnerReferences.put( name, ownerAssociationType );
 	}
 
 	private void addEntityToFetch(String name) {
 		entitiesToFetch.add( name );
 	}
 
 	private int nextCount() {
 		return ( superQuery == null ) ? nameCount++ : superQuery.nameCount++;
 	}
 
 	String createNameFor(String type) {
 		return StringHelper.generateAlias( type, nextCount() );
 	}
 
 	String createNameForCollection(String role) {
 		return StringHelper.generateAlias( role, nextCount() );
 	}
 
 	private String getType(String name) {
 		String type = ( String ) typeMap.get( name );
 		if ( type == null && superQuery != null ) {
 			type = superQuery.getType( name );
 		}
 		return type;
 	}
 
 	private String getRole(String name) {
 		String role = ( String ) collections.get( name );
 		if ( role == null && superQuery != null ) {
 			role = superQuery.getRole( name );
 		}
 		return role;
 	}
 
 	boolean isName(String name) {
 		return aliasNames.containsKey( name ) ||
 				typeMap.containsKey( name ) ||
 				collections.containsKey( name ) || (
 				superQuery != null && superQuery.isName( name )
 				);
 	}
 
 	PropertyMapping getPropertyMapping(String name) throws QueryException {
 		PropertyMapping decorator = getDecoratedPropertyMapping( name );
 		if ( decorator != null ) return decorator;
 
 		String type = getType( name );
 		if ( type == null ) {
 			String role = getRole( name );
 			if ( role == null ) {
 				throw new QueryException( "alias not found: " + name );
 			}
 			return getCollectionPersister( role ); //.getElementPropertyMapping();
 		}
 		else {
 			Queryable persister = getEntityPersister( type );
 			if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 			return persister;
 		}
 	}
 
 	private PropertyMapping getDecoratedPropertyMapping(String name) {
 		return ( PropertyMapping ) decoratedPropertyMappings.get( name );
 	}
 
 	void decoratePropertyMapping(String name, PropertyMapping mapping) {
 		decoratedPropertyMappings.put( name, mapping );
 	}
 
 	private Queryable getEntityPersisterForName(String name) throws QueryException {
 		String type = getType( name );
 		Queryable persister = getEntityPersister( type );
 		if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 		return persister;
 	}
 
 	Queryable getEntityPersisterUsingImports(String className) {
 		final String importedClassName = getFactory().getImportedClassName( className );
 		if ( importedClassName == null ) {
 			return null;
 		}
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( importedClassName );
 		}
 		catch ( MappingException me ) {
 			return null;
 		}
 	}
 
 	Queryable getEntityPersister(String entityName) throws QueryException {
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( entityName );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "persistent class not found: " + entityName );
 		}
 	}
 
 	QueryableCollection getCollectionPersister(String role) throws QueryException {
 		try {
 			return ( QueryableCollection ) getFactory().getCollectionPersister( role );
 		}
 		catch ( ClassCastException cce ) {
 			throw new QueryException( "collection role is not queryable: " + role );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "collection role not found: " + role );
 		}
 	}
 
 	void addType(String name, String type) {
 		typeMap.put( name, type );
 	}
 
 	void addCollection(String name, String role) {
 		collections.put( name, role );
 	}
 
 	void addFrom(String name, String type, JoinSequence joinSequence)
 			throws QueryException {
 		addType( name, type );
 		addFrom( name, joinSequence );
 	}
 
 	void addFromCollection(String name, String collectionRole, JoinSequence joinSequence)
 			throws QueryException {
 		//register collection role
 		addCollection( name, collectionRole );
 		addJoin( name, joinSequence );
 	}
 
 	void addFrom(String name, JoinSequence joinSequence)
 			throws QueryException {
 		fromTypes.add( name );
 		addJoin( name, joinSequence );
 	}
 
 	void addFromClass(String name, Queryable classPersister)
 			throws QueryException {
 		JoinSequence joinSequence = new JoinSequence( getFactory() )
 				.setRoot( classPersister, name );
 		//crossJoins.add(name);
 		addFrom( name, classPersister.getEntityName(), joinSequence );
 	}
 
 	void addSelectClass(String name) {
 		returnedTypes.add( name );
 	}
 
 	void addSelectScalar(Type type) {
 		scalarTypes.add( type );
 	}
 
 	void appendWhereToken(String token) {
 		whereTokens.add( token );
 	}
 
 	void appendHavingToken(String token) {
 		havingTokens.add( token );
 	}
 
 	void appendOrderByToken(String token) {
 		orderByTokens.add( token );
 	}
 
 	void appendGroupByToken(String token) {
 		groupByTokens.add( token );
 	}
 
 	void appendScalarSelectToken(String token) {
 		scalarSelectTokens.add( token );
 	}
 
 	void appendScalarSelectTokens(String[] tokens) {
 		scalarSelectTokens.add( tokens );
 	}
 
 	void addFromJoinOnly(String name, JoinSequence joinSequence) throws QueryException {
 		addJoin( name, joinSequence.getFromPart() );
 	}
 
 	void addJoin(String name, JoinSequence joinSequence) throws QueryException {
 		if ( !joins.containsKey( name ) ) joins.put( name, joinSequence );
 	}
 
 	void addNamedParameter(String name) {
 		if ( superQuery != null ) superQuery.addNamedParameter( name );
 		Integer loc = new Integer( parameterCount++ );
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			namedParameters.put( name, loc );
 		}
 		else if ( o instanceof Integer ) {
 			ArrayList list = new ArrayList( 4 );
 			list.add( o );
 			list.add( loc );
 			namedParameters.put( name, list );
 		}
 		else {
 			( ( ArrayList ) o ).add( loc );
 		}
 	}
 
 	@Override
     public int[] getNamedParameterLocs(String name) throws QueryException {
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			QueryException qe = new QueryException( ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name );
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 		if ( o instanceof Integer ) {
 			return new int[]{ ( ( Integer ) o ).intValue() };
 		}
 		else {
 			return ArrayHelper.toIntArray( ( ArrayList ) o );
 		}
 	}
 
 	private void renderSQL() throws QueryException, MappingException {
 
 		final int rtsize;
 		if ( returnedTypes.size() == 0 && scalarTypes.size() == 0 ) {
 			//ie no select clause in HQL
 			returnedTypes = fromTypes;
 			rtsize = returnedTypes.size();
 		}
 		else {
 			rtsize = returnedTypes.size();
 			Iterator iter = entitiesToFetch.iterator();
 			while ( iter.hasNext() ) {
 				returnedTypes.add( iter.next() );
 			}
 		}
 		int size = returnedTypes.size();
 		persisters = new Queryable[size];
 		names = new String[size];
 		owners = new int[size];
 		ownerAssociationTypes = new EntityType[size];
 		suffixes = new String[size];
 		includeInSelect = new boolean[size];
 		for ( int i = 0; i < size; i++ ) {
 			String name = ( String ) returnedTypes.get( i );
 			//if ( !isName(name) ) throw new QueryException("unknown type: " + name);
 			persisters[i] = getEntityPersisterForName( name );
 			// TODO: cannot use generateSuffixes() - it handles the initial suffix differently.
 			suffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + '_';
 			names[i] = name;
 			includeInSelect[i] = !entitiesToFetch.contains( name );
 			if ( includeInSelect[i] ) selectLength++;
 			if ( name.equals( collectionOwnerName ) ) collectionOwnerColumn = i;
 			String oneToOneOwner = ( String ) oneToOneOwnerNames.get( name );
 			owners[i] = ( oneToOneOwner == null ) ? -1 : returnedTypes.indexOf( oneToOneOwner );
 			ownerAssociationTypes[i] = (EntityType) uniqueKeyOwnerReferences.get( name );
 		}
 
 		if ( ArrayHelper.isAllNegative( owners ) ) owners = null;
 
 		String scalarSelect = renderScalarSelect(); //Must be done here because of side-effect! yuck...
 
 		int scalarSize = scalarTypes.size();
 		hasScalars = scalarTypes.size() != rtsize;
 
 		returnTypes = new Type[scalarSize];
 		for ( int i = 0; i < scalarSize; i++ ) {
 			returnTypes[i] = ( Type ) scalarTypes.get( i );
 		}
 
 		QuerySelect sql = new QuerySelect( getFactory().getDialect() );
 		sql.setDistinct( distinct );
 
 		if ( !shallowQuery ) {
 			renderIdentifierSelect( sql );
 			renderPropertiesSelect( sql );
 		}
 
 		if ( collectionPersister != null ) {
 			sql.addSelectFragmentString( collectionPersister.selectFragment( fetchName, "__" ) );
 		}
 
 		if ( hasScalars || shallowQuery ) sql.addSelectFragmentString( scalarSelect );
 
 		//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings
 		mergeJoins( sql.getJoinFragment() );
 
 		sql.setWhereTokens( whereTokens.iterator() );
 
 		sql.setGroupByTokens( groupByTokens.iterator() );
 		sql.setHavingTokens( havingTokens.iterator() );
 		sql.setOrderByTokens( orderByTokens.iterator() );
 
 		if ( collectionPersister != null && collectionPersister.hasOrdering() ) {
 			sql.addOrderBy( collectionPersister.getSQLOrderByString( fetchName ) );
 		}
 
 		scalarColumnNames = NameGenerator.generateColumnNames( returnTypes, getFactory() );
 
 		// initialize the Set of queried identifier spaces (ie. tables)
 		Iterator iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = getCollectionPersister( ( String ) iter.next() );
 			addQuerySpaces( p.getCollectionSpaces() );
 		}
 		iter = typeMap.keySet().iterator();
 		while ( iter.hasNext() ) {
 			Queryable p = getEntityPersisterForName( ( String ) iter.next() );
 			addQuerySpaces( p.getQuerySpaces() );
 		}
 
 		sqlString = sql.toQueryString();
 
 		if ( holderClass != null ) holderConstructor = ReflectHelper.getConstructor( holderClass, returnTypes );
 
 		if ( hasScalars ) {
 			actualReturnTypes = returnTypes;
 		}
 		else {
 			actualReturnTypes = new Type[selectLength];
 			int j = 0;
 			for ( int i = 0; i < persisters.length; i++ ) {
 				if ( includeInSelect[i] ) {
 					actualReturnTypes[j++] = getFactory().getTypeResolver()
 							.getTypeFactory()
 							.manyToOne( persisters[i].getEntityName(), shallowQuery );
 				}
 			}
 		}
 
 	}
 
 	private void renderIdentifierSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 
 		for ( int k = 0; k < size; k++ ) {
 			String name = ( String ) returnedTypes.get( k );
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			sql.addSelectFragmentString( persisters[k].identifierSelectFragment( name, suffix ) );
 		}
 
 	}
 
 	/*private String renderOrderByPropertiesSelect() {
 		StringBuffer buf = new StringBuffer(10);
 
 		//add the columns we are ordering by to the select ID select clause
 		Iterator iter = orderByTokens.iterator();
 		while ( iter.hasNext() ) {
 			String token = (String) iter.next();
 			if ( token.lastIndexOf(".") > 0 ) {
 				//ie. it is of form "foo.bar", not of form "asc" or "desc"
 				buf.append(StringHelper.COMMA_SPACE).append(token);
 			}
 		}
 
 		return buf.toString();
 	}*/
 
 	private void renderPropertiesSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 		for ( int k = 0; k < size; k++ ) {
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			String name = ( String ) returnedTypes.get( k );
 			sql.addSelectFragmentString( persisters[k].propertySelectFragment( name, suffix, false ) );
 		}
 	}
 
 	/**
 	 * WARNING: side-effecty
 	 */
 	private String renderScalarSelect() {
 
 		boolean isSubselect = superQuery != null;
 
 		StringBuffer buf = new StringBuffer( 20 );
 
 		if ( scalarTypes.size() == 0 ) {
 			//ie. no select clause
 			int size = returnedTypes.size();
 			for ( int k = 0; k < size; k++ ) {
 
 				scalarTypes.add(
 						getFactory().getTypeResolver().getTypeFactory().manyToOne( persisters[k].getEntityName(), shallowQuery )
 				);
 
 				String[] idColumnNames = persisters[k].getIdentifierColumnNames();
 				for ( int i = 0; i < idColumnNames.length; i++ ) {
 					buf.append( returnedTypes.get( k ) ).append( '.' ).append( idColumnNames[i] );
 					if ( !isSubselect ) buf.append( " as " ).append( NameGenerator.scalarName( k, i ) );
 					if ( i != idColumnNames.length - 1 || k != size - 1 ) buf.append( ", " );
 				}
 
 			}
 
 		}
 		else {
 			//there _was_ a select clause
 			Iterator iter = scalarSelectTokens.iterator();
 			int c = 0;
 			boolean nolast = false; //real hacky...
 			int parenCount = 0; // used to count the nesting of parentheses
 			while ( iter.hasNext() ) {
 				Object next = iter.next();
 				if ( next instanceof String ) {
 					String token = ( String ) next;
 
 					if ( "(".equals( token ) ) {
 						parenCount++;
 					}
 					else if ( ")".equals( token ) ) {
 						parenCount--;
 					}
 
 					String lc = token.toLowerCase();
 					if ( lc.equals( ", " ) ) {
 						if ( nolast ) {
 							nolast = false;
 						}
 						else {
 							if ( !isSubselect && parenCount == 0 ) {
 								int x = c++;
 								buf.append( " as " )
 										.append( NameGenerator.scalarName( x, 0 ) );
 							}
 						}
 					}
 					buf.append( token );
 					if ( lc.equals( "distinct" ) || lc.equals( "all" ) ) {
 						buf.append( ' ' );
 					}
 				}
 				else {
 					nolast = true;
 					String[] tokens = ( String[] ) next;
 					for ( int i = 0; i < tokens.length; i++ ) {
 						buf.append( tokens[i] );
 						if ( !isSubselect ) {
 							buf.append( " as " )
 									.append( NameGenerator.scalarName( c, i ) );
 						}
 						if ( i != tokens.length - 1 ) buf.append( ", " );
 					}
 					c++;
 				}
 			}
 			if ( !isSubselect && !nolast ) {
 				int x = c++;
 				buf.append( " as " )
 						.append( NameGenerator.scalarName( x, 0 ) );
 			}
 
 		}
 
 		return buf.toString();
 	}
 
 	private void mergeJoins(JoinFragment ojf) throws MappingException, QueryException {
 
 		Iterator iter = joins.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) iter.next();
 			String name = ( String ) me.getKey();
 			JoinSequence join = ( JoinSequence ) me.getValue();
 			join.setSelector( new JoinSequence.Selector() {
 				public boolean includeSubclasses(String alias) {
 					boolean include = returnedTypes.contains( alias ) && !isShallowQuery();
 					return include;
 				}
 			} );
 
 			if ( typeMap.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else if ( collections.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else {
 				//name from a super query (a bit inelegant that it shows up here)
 			}
 
 		}
 
 	}
 
 	public final Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	/**
 	 * Is this query called by scroll() or iterate()?
 	 *
 	 * @return true if it is, false if it is called by find() or list()
 	 */
 	boolean isShallowQuery() {
 		return shallowQuery;
 	}
 
 	void addQuerySpaces(Serializable[] spaces) {
 		for ( int i = 0; i < spaces.length; i++ ) {
 			querySpaces.add( spaces[i] );
 		}
 		if ( superQuery != null ) superQuery.addQuerySpaces( spaces );
 	}
 
 	void setDistinct(boolean distinct) {
 		this.distinct = distinct;
 	}
 
 	boolean isSubquery() {
 		return superQuery != null;
 	}
 
 	/**
 	 * Overrides method from Loader
 	 */
 	@Override
     public CollectionPersister[] getCollectionPersisters() {
 		return collectionPersister == null ? null : new CollectionPersister[] { collectionPersister };
 	}
 
 	@Override
     protected String[] getCollectionSuffixes() {
 		return collectionPersister == null ? null : new String[] { "__" };
 	}
 
 	void setCollectionToFetch(String role, String name, String ownerName, String entityName)
 			throws QueryException {
 		fetchName = name;
 		collectionPersister = getCollectionPersister( role );
 		collectionOwnerName = ownerName;
 		if ( collectionPersister.getElementType().isEntityType() ) {
 			addEntityToFetch( entityName );
 		}
 	}
 
 	@Override
     protected String[] getSuffixes() {
 		return suffixes;
 	}
 
 	@Override
     protected String[] getAliases() {
 		return names;
 	}
 
 	/**
 	 * Used for collection filters
 	 */
 	private void addFromAssociation(final String elementName, final String collectionRole)
 			throws QueryException {
 		//q.addCollection(collectionName, collectionRole);
 		QueryableCollection persister = getCollectionPersister( collectionRole );
 		Type collectionElementType = persister.getElementType();
 		if ( !collectionElementType.isEntityType() ) {
 			throw new QueryException( "collection of values in filter: " + elementName );
 		}
 
 		String[] keyColumnNames = persister.getKeyColumnNames();
 		//if (keyColumnNames.length!=1) throw new QueryException("composite-key collection in filter: " + collectionRole);
 
 		String collectionName;
 		JoinSequence join = new JoinSequence( getFactory() );
 		collectionName = persister.isOneToMany() ?
 				elementName :
 				createNameForCollection( collectionRole );
 		join.setRoot( persister, collectionName );
 		if ( !persister.isOneToMany() ) {
 			//many-to-many
 			addCollection( collectionName, collectionRole );
 			try {
 				join.addJoin( ( AssociationType ) persister.getElementType(),
 						elementName,
 						JoinFragment.INNER_JOIN,
 						persister.getElementColumnNames(collectionName) );
 			}
 			catch ( MappingException me ) {
 				throw new QueryException( me );
 			}
 		}
 		join.addCondition( collectionName, keyColumnNames, " = ?" );
 		//if ( persister.hasWhere() ) join.addCondition( persister.getSQLWhereString(collectionName) );
 		EntityType elemType = ( EntityType ) collectionElementType;
 		addFrom( elementName, elemType.getAssociatedEntityName(), join );
 
 	}
 
 	String getPathAlias(String path) {
 		return ( String ) pathAliases.get( path );
 	}
 
 	JoinSequence getPathJoin(String path) {
 		return ( JoinSequence ) pathJoins.get( path );
 	}
 
 	void addPathAliasAndJoin(String path, String alias, JoinSequence joinSequence) {
 		pathAliases.put( path, alias );
 		pathJoins.put( path, joinSequence );
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		return list( session, queryParameters, getQuerySpaces(), actualReturnTypes );
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 
 		boolean stats = session.getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		try {
 
 			PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 			ResultSet rs = getResultSet( st, queryParameters.hasAutoDiscoverScalarTypes(), false, queryParameters.getRowSelection(), session );
 			HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(holderConstructor, queryParameters.getResultTransformer());
 			Iterator result = new IteratorImpl( rs, st, session, queryParameters.isReadOnly( session ), returnTypes, getColumnNames(), hi );
 
 			if ( stats ) {
 				session.getFactory().getStatisticsImplementor().queryExecuted(
 						"HQL: " + queryString,
 						0,
 						System.currentTimeMillis() - startTime
 					);
 			}
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not execute query using iterate",
 					getSQLString()
 				);
 		}
 
 	}
 
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session) throws HibernateException {
 		throw new UnsupportedOperationException( "Not supported!  Use the AST translator...");
 	}
 
 	@Override
     protected boolean[] includeInResultRow() {
 		boolean[] isResultReturned = includeInSelect;
 		if ( hasScalars ) {
 			isResultReturned = new boolean[ returnedTypes.size() ];
 			Arrays.fill( isResultReturned, true );
 		}
 		return isResultReturned;
 	}
 
 
 	@Override
     protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return HolderInstantiator.resolveClassicResultTransformer(
 				holderConstructor,
 				resultTransformer
 		);
 	}
 
 	@Override
     protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow = getResultRow( row, rs, session );
 		return ( holderClass == null && resultRow.length == 1 ?
 				resultRow[ 0 ] :
 				resultRow
 		);
 	}
 
 	@Override
     protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow;
 		if ( hasScalars ) {
 			String[][] scalarColumns = getColumnNames();
 			int queryCols = returnTypes.length;
 			resultRow = new Object[queryCols];
 			for ( int i = 0; i < queryCols; i++ ) {
 				resultRow[i] = returnTypes[i].nullSafeGet( rs, scalarColumns[i], session, null );
 			}
 		}
 		else {
 			resultRow = toResultRow( row );
 		}
 		return resultRow;
 	}
 
 	@Override
     protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		if ( holderClass != null ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				try {
 					results.set( i, holderConstructor.newInstance( row ) );
 				}
 				catch ( Exception e ) {
 					throw new QueryException( "could not instantiate: " + holderClass, e );
 				}
 			}
 		}
 		return results;
 	}
 
 	private Object[] toResultRow(Object[] row) {
 		if ( selectLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[selectLength];
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
index 9598be189f..c4e9935c2c 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
@@ -1,181 +1,181 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.internal;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.NoSuchElementException;
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.engine.HibernateIterator;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.HolderInstantiator;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * An implementation of <tt>java.util.Iterator</tt> that is
  * returned by <tt>iterate()</tt> query execution methods.
  * @author Gavin King
  */
 public final class IteratorImpl implements HibernateIterator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, IteratorImpl.class.getName());
 
 	private ResultSet rs;
 	private final EventSource session;
 	private boolean readOnly;
 	private final Type[] types;
 	private final boolean single;
 	private Object currentResult;
 	private boolean hasNext;
 	private final String[][] names;
 	private PreparedStatement ps;
 	private HolderInstantiator holderInstantiator;
 
 	public IteratorImpl(
 	        ResultSet rs,
 	        PreparedStatement ps,
 	        EventSource sess,
 	        boolean readOnly,
 	        Type[] types,
 	        String[][] columnNames,
 	        HolderInstantiator holderInstantiator)
 	throws HibernateException, SQLException {
 
 		this.rs=rs;
 		this.ps=ps;
 		this.session = sess;
 		this.readOnly = readOnly;
 		this.types = types;
 		this.names = columnNames;
 		this.holderInstantiator = holderInstantiator;
 
 		single = types.length==1;
 
 		postNext();
 	}
 
 	public void close() throws JDBCException {
 		if (ps!=null) {
 			try {
                 LOG.debugf("Closing iterator");
 				ps.close();
 				ps = null;
 				rs = null;
 				hasNext = false;
 			}
 			catch (SQLException e) {
                 LOG.unableToCloseIterator(e);
 				throw session.getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "Unable to close iterator"
 					);
 			}
 			finally {
 				try {
 					session.getPersistenceContext().getLoadContexts().cleanup( rs );
 				}
 				catch( Throwable ignore ) {
 					// ignore this error for now
                     LOG.debugf("Exception trying to cleanup load context : %s", ignore.getMessage());
 				}
 			}
 		}
 	}
 
 	private void postNext() throws SQLException {
         LOG.debugf("Attempting to retrieve next results");
 		this.hasNext = rs.next();
 		if (!hasNext) {
             LOG.debugf("Exhausted results");
 			close();
         } else LOG.debugf("Retrieved next results");
 	}
 
 	public boolean hasNext() {
 		return hasNext;
 	}
 
 	public Object next() throws HibernateException {
 		if ( !hasNext ) throw new NoSuchElementException("No more results");
 		boolean sessionDefaultReadOnlyOrig = session.isDefaultReadOnly();
 		session.setDefaultReadOnly( readOnly );
 		try {
 			boolean isHolder = holderInstantiator.isRequired();
 
             LOG.debugf("Assembling results");
 			if ( single && !isHolder ) {
 				currentResult = types[0].nullSafeGet( rs, names[0], session, null );
 			}
 			else {
 				Object[] currentResults = new Object[types.length];
 				for (int i=0; i<types.length; i++) {
 					currentResults[i] = types[i].nullSafeGet( rs, names[i], session, null );
 				}
 
 				if (isHolder) {
 					currentResult = holderInstantiator.instantiate(currentResults);
 				}
 				else {
 					currentResult = currentResults;
 				}
 			}
 
 			postNext();
             LOG.debugf("Returning current results");
 			return currentResult;
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not get next iterator result"
 				);
 		}
 		finally {
 			session.setDefaultReadOnly( sessionDefaultReadOnlyOrig );
 		}
 	}
 
 	public void remove() {
 		if (!single) {
 			throw new UnsupportedOperationException("Not a single column hibernate query result set");
 		}
 		if (currentResult==null) {
 			throw new IllegalStateException("Called Iterator.remove() before next()");
 		}
 		if ( !( types[0] instanceof EntityType ) ) {
 			throw new UnsupportedOperationException("Not an entity");
 		}
 
 		session.delete(
 				( (EntityType) types[0] ).getAssociatedEntityName(),
 				currentResult,
 				false,
 		        null
 			);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
index b53f8bc397..28cdaa4c22 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.NonFlushedChanges;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 
 import org.jboss.logging.Logger;
 
 public final class NonFlushedChangesImpl implements NonFlushedChanges {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, NonFlushedChangesImpl.class.getName());
 
 	private static class SessionNonFlushedChanges implements Serializable {
 		private transient EntityMode entityMode;
 		private transient ActionQueue actionQueue;
 		private transient StatefulPersistenceContext persistenceContext;
 
 		public SessionNonFlushedChanges(EventSource session) {
 			this.entityMode = session.getEntityMode();
 			this.actionQueue = session.getActionQueue();
 			this.persistenceContext = ( StatefulPersistenceContext ) session.getPersistenceContext();
 		}
 
 		private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 			ois.defaultReadObject();
 			entityMode = EntityMode.parse( ( String ) ois.readObject() );
 			persistenceContext = StatefulPersistenceContext.deserialize( ois, null );
 			actionQueue = ActionQueue.deserialize( ois, null );
 		}
 
 		private void writeObject(ObjectOutputStream oos) throws IOException {
             LOG.trace("Serializing SessionNonFlushedChanges");
 			oos.defaultWriteObject();
 			oos.writeObject( entityMode.toString() );
 			persistenceContext.serialize( oos );
 			actionQueue.serialize( oos );
 		}
 	}
 	private Map nonFlushedChangesByEntityMode = new HashMap();
 
 	public NonFlushedChangesImpl( EventSource session ) {
 		extractFromSession( session );
 	}
 
 	public void extractFromSession(EventSource session) {
 		if ( nonFlushedChangesByEntityMode.containsKey( session.getEntityMode() ) ) {
 			throw new AssertionFailure( "Already has non-flushed changes for entity mode: " + session.getEntityMode() );
 		}
 		nonFlushedChangesByEntityMode.put( session.getEntityMode(), new SessionNonFlushedChanges( session ) );
 	}
 
 	private SessionNonFlushedChanges getSessionNonFlushedChanges(EntityMode entityMode) {
 		return ( SessionNonFlushedChanges ) nonFlushedChangesByEntityMode.get( entityMode );
 	}
 
 	/* package-protected */
 	ActionQueue getActionQueue(EntityMode entityMode) {
 		return getSessionNonFlushedChanges( entityMode ).actionQueue;
 	}
 
 	/* package-protected */
 	StatefulPersistenceContext getPersistenceContext(EntityMode entityMode) {
 		return getSessionNonFlushedChanges( entityMode ).persistenceContext;
 	}
 
 	public void clear() {
 		nonFlushedChangesByEntityMode.clear();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java
index fe1e1f5daf..07d249c7b2 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java
@@ -1,1129 +1,1129 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2005-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Reader;
 import java.io.Serializable;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.NClob;
 import java.sql.SQLException;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.CacheMode;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Criteria;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.Filter;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.SessionBuilder;
 import org.hibernate.Interceptor;
 import org.hibernate.LobHelper;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ReplicationMode;
 import org.hibernate.SQLQuery;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.SessionException;
 import org.hibernate.SharedSessionBuilder;
 import org.hibernate.Transaction;
 import org.hibernate.TransientObjectException;
 import org.hibernate.TypeHelper;
 import org.hibernate.UnknownProfileException;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.query.spi.FilterQueryPlan;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.NonFlushedChanges;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.Status;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.NativeSQLQueryPlan;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
-import org.hibernate.event.AutoFlushEvent;
-import org.hibernate.event.AutoFlushEventListener;
-import org.hibernate.event.DeleteEvent;
-import org.hibernate.event.DeleteEventListener;
-import org.hibernate.event.DirtyCheckEvent;
-import org.hibernate.event.DirtyCheckEventListener;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
-import org.hibernate.event.EvictEvent;
-import org.hibernate.event.EvictEventListener;
-import org.hibernate.event.FlushEvent;
-import org.hibernate.event.FlushEventListener;
-import org.hibernate.event.InitializeCollectionEvent;
-import org.hibernate.event.InitializeCollectionEventListener;
-import org.hibernate.event.LoadEvent;
-import org.hibernate.event.LoadEventListener;
-import org.hibernate.event.LoadEventListener.LoadType;
-import org.hibernate.event.LockEvent;
-import org.hibernate.event.LockEventListener;
-import org.hibernate.event.MergeEvent;
-import org.hibernate.event.MergeEventListener;
-import org.hibernate.event.PersistEvent;
-import org.hibernate.event.PersistEventListener;
-import org.hibernate.event.RefreshEvent;
-import org.hibernate.event.RefreshEventListener;
-import org.hibernate.event.ReplicateEvent;
-import org.hibernate.event.ReplicateEventListener;
-import org.hibernate.event.SaveOrUpdateEvent;
-import org.hibernate.event.SaveOrUpdateEventListener;
+import org.hibernate.event.spi.AutoFlushEvent;
+import org.hibernate.event.spi.AutoFlushEventListener;
+import org.hibernate.event.spi.DeleteEvent;
+import org.hibernate.event.spi.DeleteEventListener;
+import org.hibernate.event.spi.DirtyCheckEvent;
+import org.hibernate.event.spi.DirtyCheckEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.EvictEvent;
+import org.hibernate.event.spi.EvictEventListener;
+import org.hibernate.event.spi.FlushEvent;
+import org.hibernate.event.spi.FlushEventListener;
+import org.hibernate.event.spi.InitializeCollectionEvent;
+import org.hibernate.event.spi.InitializeCollectionEventListener;
+import org.hibernate.event.spi.LoadEvent;
+import org.hibernate.event.spi.LoadEventListener;
+import org.hibernate.event.spi.LoadEventListener.LoadType;
+import org.hibernate.event.spi.LockEvent;
+import org.hibernate.event.spi.LockEventListener;
+import org.hibernate.event.spi.MergeEvent;
+import org.hibernate.event.spi.MergeEventListener;
+import org.hibernate.event.spi.PersistEvent;
+import org.hibernate.event.spi.PersistEventListener;
+import org.hibernate.event.spi.RefreshEvent;
+import org.hibernate.event.spi.RefreshEventListener;
+import org.hibernate.event.spi.ReplicateEvent;
+import org.hibernate.event.spi.ReplicateEventListener;
+import org.hibernate.event.spi.SaveOrUpdateEvent;
+import org.hibernate.event.spi.SaveOrUpdateEventListener;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.jdbc.ReturningWork;
 import org.hibernate.jdbc.Work;
 import org.hibernate.jdbc.WorkExecutor;
 import org.hibernate.jdbc.WorkExecutorVisitable;
 import org.hibernate.loader.criteria.CriteriaLoader;
 import org.hibernate.loader.custom.CustomLoader;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.stat.SessionStatistics;
 import org.hibernate.stat.internal.SessionStatisticsImpl;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 
 /**
  * Concrete implementation of a Session.
  *
  * Exposes two interfaces:<ul>
  *     <li>{@link Session} to the application</li>
  *     <li>{@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI)</li>
  * </ul>
  *
  * This class is not thread-safe.
  *
  * @author Gavin King
  */
 public final class SessionImpl
 		extends AbstractSessionImpl
 		implements EventSource, org.hibernate.Session, TransactionContext, LobCreationContext {
 
 	// todo : need to find a clean way to handle the "event source" role
 	// a separate class responsible for generating/dispatching events just duplicates most of the Session methods...
 	// passing around separate interceptor, factory, actionQueue, and persistentContext is not manageable...
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionImpl.class.getName());
 
 	private transient long timestamp;
 
 	private transient ActionQueue actionQueue;
 	private transient StatefulPersistenceContext persistenceContext;
 	private transient TransactionCoordinatorImpl transactionCoordinator;
 	private transient Interceptor interceptor;
 	private transient EntityNameResolver entityNameResolver = new CoordinatingEntityNameResolver();
 
 	private transient ConnectionReleaseMode connectionReleaseMode;
 	private transient FlushMode flushMode = FlushMode.AUTO;
 	private transient CacheMode cacheMode = CacheMode.NORMAL;
 	private transient EntityMode entityMode = EntityMode.POJO;
 
 	private transient boolean autoClear; //for EJB3
 	private transient boolean autoJoinTransactions = true;
 	private transient boolean flushBeforeCompletionEnabled;
 	private transient boolean autoCloseSessionEnabled;
 
 	private transient int dontFlushFromFind = 0;
 
 	private transient LoadQueryInfluencers loadQueryInfluencers;
 
 	private transient Session rootSession;
 	private transient Map childSessionsByEntityMode;
 
 	/**
 	 * Constructor used in building "child sessions".
 	 *
 	 * @param parent The parent session
 	 * @param entityMode
 	 */
 	private SessionImpl(SessionImpl parent, EntityMode entityMode) {
 		super( parent.factory, parent.getTenantIdentifier() );
 		this.rootSession = parent;
 		this.timestamp = parent.timestamp;
 		this.transactionCoordinator = parent.transactionCoordinator;
 		this.interceptor = parent.interceptor;
 		this.actionQueue = new ActionQueue( this );
 		this.entityMode = entityMode;
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = false;
 		this.autoCloseSessionEnabled = false;
 		this.connectionReleaseMode = null;
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
         if (factory.getStatistics().isStatisticsEnabled()) factory.getStatisticsImplementor().openSession();
 
         LOG.debugf("Opened session [%s]", entityMode);
 	}
 
 	/**
 	 * Constructor used for openSession(...) processing, as well as construction
 	 * of sessions for getCurrentSession().
 	 *
 	 * @param connection The user-supplied connection to use for this session.
 	 * @param factory The factory from which this session was obtained
 	 * @param transactionCoordinator The transaction coordinator to use, may be null to indicate that a new transaction
 	 * coordinator should get created.
 	 * @param autoJoinTransactions Should the session automatically join JTA transactions?
 	 * @param timestamp The timestamp for this session
 	 * @param interceptor The interceptor to be applied to this session
 	 * @param entityMode The entity-mode for this session
 	 * @param flushBeforeCompletionEnabled Should we auto flush before completion of transaction
 	 * @param autoCloseSessionEnabled Should we auto close after completion of transaction
 	 * @param connectionReleaseMode The mode by which we should release JDBC connections.
 	 */
 	SessionImpl(
 			final Connection connection,
 			final SessionFactoryImpl factory,
 			final TransactionCoordinatorImpl transactionCoordinator,
 			final boolean autoJoinTransactions,
 			final long timestamp,
 			final Interceptor interceptor,
 			final EntityMode entityMode,
 			final boolean flushBeforeCompletionEnabled,
 			final boolean autoCloseSessionEnabled,
 			final ConnectionReleaseMode connectionReleaseMode,
 			final String tenantIdentifier) {
 		super( factory, tenantIdentifier );
 		this.rootSession = null;
 		this.timestamp = timestamp;
 		this.entityMode = entityMode;
 		this.interceptor = interceptor == null ? EmptyInterceptor.INSTANCE : interceptor;
 		this.actionQueue = new ActionQueue( this );
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 		this.connectionReleaseMode = connectionReleaseMode;
 		this.autoJoinTransactions = autoJoinTransactions;
 
 		if ( transactionCoordinator == null ) {
 			this.transactionCoordinator = new TransactionCoordinatorImpl( connection, this );
 			this.transactionCoordinator.getJdbcCoordinator().getLogicalConnection().addObserver(
 					new ConnectionObserverStatsBridge( factory )
 			);
 		}
 		else {
 			if ( connection != null ) {
 				throw new SessionException( "Cannot simultaneously share transaction context and specify connection" );
 			}
 			this.transactionCoordinator = transactionCoordinator;
 		}
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
         if (factory.getStatistics().isStatisticsEnabled()) factory.getStatisticsImplementor().openSession();
 
         LOG.debugf("Opened session at timestamp: %s", timestamp);
 	}
 
 	@Override
 	public SharedSessionBuilder sessionWithOptions() {
 		return new SharedSessionBuilderImpl( this );
 	}
 
 	public Session getSession(EntityMode entityMode) {
 		if ( this.entityMode == entityMode ) {
 			return this;
 		}
 
 		if ( rootSession != null ) {
 			return rootSession.getSession( entityMode );
 		}
 
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
 		SessionImpl rtn = null;
 		if ( childSessionsByEntityMode == null ) {
 			childSessionsByEntityMode = new HashMap();
 		}
 		else {
 			rtn = (SessionImpl) childSessionsByEntityMode.get( entityMode );
 		}
 
 		if ( rtn == null ) {
 			rtn = new SessionImpl( this, entityMode );
 			childSessionsByEntityMode.put( entityMode, rtn );
 		}
 
 		return rtn;
 	}
 
 	public void clear() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		persistenceContext.clear();
 		actionQueue.clear();
 	}
 
 	public long getTimestamp() {
 		checkTransactionSynchStatus();
 		return timestamp;
 	}
 
 	public Connection close() throws HibernateException {
         LOG.trace("Closing session");
 		if ( isClosed() ) {
 			throw new SessionException( "Session was already closed" );
 		}
 
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().closeSession();
 		}
 
 		try {
 			try {
 				if ( childSessionsByEntityMode != null ) {
 					Iterator childSessions = childSessionsByEntityMode.values().iterator();
 					while ( childSessions.hasNext() ) {
 						final SessionImpl child = ( SessionImpl ) childSessions.next();
 						child.close();
 					}
 				}
 			}
 			catch( Throwable t ) {
 				// just ignore
 			}
 
 			if ( rootSession == null ) {
 				return transactionCoordinator.close();
 			}
 			else {
 				return null;
 			}
 		}
 		finally {
 			setClosed();
 			cleanup();
 		}
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return connectionReleaseMode;
 	}
 
 	@Override
 	public boolean shouldAutoJoinTransaction() {
 		return autoJoinTransactions;
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public boolean isOpen() {
 		checkTransactionSynchStatus();
 		return !isClosed();
 	}
 
 	public boolean isFlushModeNever() {
 		return FlushMode.isManualFlushMode( getFlushMode() );
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
 	public void managedFlush() {
 		if ( isClosed() ) {
             LOG.trace("Skipping auto-flush due to session closed");
 			return;
 		}
         LOG.trace( "Automatically flushing session" );
 		flush();
 
 		if ( childSessionsByEntityMode != null ) {
 			Iterator iter = childSessionsByEntityMode.values().iterator();
 			while ( iter.hasNext() ) {
 				( (Session) iter.next() ).flush();
 			}
 		}
 	}
 
 	/**
 	 * Return changes to this session and its child sessions that have not been flushed yet.
 	 * <p/>
 	 * @return The non-flushed changes.
 	 */
 	public NonFlushedChanges getNonFlushedChanges() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		NonFlushedChanges nonFlushedChanges = new NonFlushedChangesImpl( this );
 		if ( childSessionsByEntityMode != null ) {
 			Iterator it = childSessionsByEntityMode.values().iterator();
 			while ( it.hasNext() ) {
 				nonFlushedChanges.extractFromSession( ( EventSource ) it.next() );
 			}
 		}
 		return nonFlushedChanges;
 	}
 
 	/**
 	 * Apply non-flushed changes from a different session to this session. It is assumed
 	 * that this SessionImpl is "clean" (e.g., has no non-flushed changes, no cached entities,
 	 * no cached collections, no queued actions). The specified NonFlushedChanges object cannot
 	 * be bound to any session.
 	 * <p/>
 	 * @param nonFlushedChanges the non-flushed changes
 	 */
 	public void applyNonFlushedChanges(NonFlushedChanges nonFlushedChanges) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		replacePersistenceContext( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getPersistenceContext( entityMode) );
 		replaceActionQueue( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getActionQueue( entityMode ) );
 		if ( childSessionsByEntityMode != null ) {
 			for ( Iterator it = childSessionsByEntityMode.values().iterator(); it.hasNext(); ) {
 				( ( SessionImpl ) it.next() ).applyNonFlushedChanges( nonFlushedChanges );
 			}
 		}
 	}
 
 	private void replacePersistenceContext(StatefulPersistenceContext persistenceContextNew) {
 		if ( persistenceContextNew.getSession() != null ) {
 			throw new IllegalStateException( "new persistence context is already connected to a session " );
 		}
 		persistenceContext.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializePersistenceContext( persistenceContextNew ) ) );
 			this.persistenceContext = StatefulPersistenceContext.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the persistence context",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the persistence context", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializePersistenceContext(StatefulPersistenceContext pc) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			( pc ).serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize persistence context", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	private void replaceActionQueue(ActionQueue actionQueueNew) {
 		if ( actionQueue.hasAnyQueuedActions() ) {
 			throw new IllegalStateException( "cannot replace an ActionQueue with queued actions " );
 		}
 		actionQueue.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializeActionQueue( actionQueueNew ) ) );
 			actionQueue = ActionQueue.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the action queue",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the action queue", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializeActionQueue(ActionQueue actionQueue) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			actionQueue.serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize action queue", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	public boolean shouldAutoClose() {
 		return isAutoCloseSessionEnabled() && !isClosed();
 	}
 
 	public void managedClose() {
         LOG.trace( "Automatically closing session" );
 		close();
 	}
 
 	public Connection connection() throws HibernateException {
 		errorIfClosed();
 		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getDistinctConnectionProxy();
 	}
 
 	public boolean isConnected() {
 		checkTransactionSynchStatus();
 		return !isClosed() && transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isOpen();
 	}
 
 	public boolean isTransactionInProgress() {
 		checkTransactionSynchStatus();
 		return !isClosed() && transactionCoordinator.isTransactionInProgress();
 	}
 
 	@Override
 	public Connection disconnect() throws HibernateException {
 		errorIfClosed();
         LOG.debugf("Disconnecting session");
 		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualDisconnect();
 	}
 
 	@Override
 	public void reconnect(Connection conn) throws HibernateException {
 		errorIfClosed();
         LOG.debugf("Reconnecting session");
 		checkTransactionSynchStatus();
 		transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualReconnect( conn );
 	}
 
 	public void setAutoClear(boolean enabled) {
 		errorIfClosed();
 		autoClear = enabled;
 	}
 
 	@Override
 	public void disableTransactionAutoJoin() {
 		errorIfClosed();
 		autoJoinTransactions = false;
 	}
 
 	/**
 	 * Check if there is a Hibernate or JTA transaction in progress and,
 	 * if there is not, flush if necessary, make sure the connection has
 	 * been committed (if it is not in autocommit mode) and run the after
 	 * completion processing
 	 */
 	public void afterOperation(boolean success) {
 		if ( ! transactionCoordinator.isTransactionInProgress() ) {
 			transactionCoordinator.afterNonTransactionalQuery( success );
 		}
 	}
 
 	@Override
 	public void afterTransactionBegin(TransactionImplementor hibernateTransaction) {
 		errorIfClosed();
 		interceptor.afterTransactionBegin( hibernateTransaction );
 	}
 
 	@Override
 	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction) {
 		LOG.trace( "before transaction completion" );
 		actionQueue.beforeTransactionCompletion();
 		if ( rootSession == null ) {
 			try {
 				interceptor.beforeTransactionCompletion( hibernateTransaction );
 			}
 			catch (Throwable t) {
                 LOG.exceptionInBeforeTransactionCompletionInterceptor(t);
 			}
 		}
 	}
 
 	@Override
 	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful) {
 		LOG.trace( "after transaction completion" );
 		persistenceContext.afterTransactionCompletion();
 		actionQueue.afterTransactionCompletion( successful );
 		if ( rootSession == null && hibernateTransaction != null ) {
 			try {
 				interceptor.afterTransactionCompletion( hibernateTransaction );
 			}
 			catch (Throwable t) {
                 LOG.exceptionInAfterTransactionCompletionInterceptor(t);
 			}
 		}
 		if ( autoClear ) {
 			clear();
 		}
 	}
 
 	/**
 	 * clear all the internal collections, just
 	 * to help the garbage collector, does not
 	 * clear anything that is needed during the
 	 * afterTransactionCompletion() phase
 	 */
 	private void cleanup() {
 		persistenceContext.clear();
 	}
 
 	public LockMode getCurrentLockMode(Object object) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object == null ) {
 			throw new NullPointerException( "null object passed to getCurrentLockMode()" );
 		}
 		if ( object instanceof HibernateProxy ) {
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation(this);
 			if ( object == null ) {
 				return LockMode.NONE;
 			}
 		}
 		EntityEntry e = persistenceContext.getEntry(object);
 		if ( e == null ) {
 			throw new TransientObjectException( "Given object not associated with the session" );
 		}
 		if ( e.getStatus() != Status.MANAGED ) {
 			throw new ObjectDeletedException(
 					"The given object was deleted",
 					e.getId(),
 					e.getPersister().getEntityName()
 				);
 		}
 		return e.getLockMode();
 	}
 
 	public Object getEntityUsingInterceptor(EntityKey key) throws HibernateException {
 		errorIfClosed();
 		// todo : should this get moved to PersistentContext?
 		// logically, is PersistentContext the "thing" to which an interceptor gets attached?
 		final Object result = persistenceContext.getEntity(key);
 		if ( result == null ) {
 			final Object newObject = interceptor.getEntity( key.getEntityName(), key.getIdentifier() );
 			if ( newObject != null ) {
 				lock( newObject, LockMode.NONE );
 			}
 			return newObject;
 		}
 		else {
 			return result;
 		}
 	}
 
 
 	// saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void saveOrUpdate(Object object) throws HibernateException {
 		saveOrUpdate( null, object );
 	}
 
 	public void saveOrUpdate(String entityName, Object obj) throws HibernateException {
 		fireSaveOrUpdate( new SaveOrUpdateEvent( entityName, obj, this ) );
 	}
 
 	private void fireSaveOrUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE_UPDATE ) ) {
 			listener.onSaveOrUpdate( event );
 		}
 	}
 
 	private <T> Iterable<T> listeners(EventType<T> type) {
 		return eventListenerGroup( type ).listeners();
 	}
 
 	private <T> EventListenerGroup<T> eventListenerGroup(EventType<T> type) {
 		return factory.getServiceRegistry().getService( EventListenerRegistry.class ).getEventListenerGroup( type );
 	}
 
 
 	// save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Serializable save(Object obj) throws HibernateException {
 		return save( null, obj );
 	}
 
 	public Serializable save(String entityName, Object object) throws HibernateException {
 		return fireSave( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
 	private Serializable fireSave(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE ) ) {
 			listener.onSaveOrUpdate( event );
 		}
 		return event.getResultId();
 	}
 
 
 	// update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void update(Object obj) throws HibernateException {
 		update(null, obj);
 	}
 
 	public void update(String entityName, Object object) throws HibernateException {
 		fireUpdate( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
 	private void fireUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( SaveOrUpdateEventListener listener : listeners( EventType.UPDATE ) ) {
 			listener.onSaveOrUpdate( event );
 		}
 	}
 
 
 	// lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void lock(String entityName, Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(entityName, object, lockMode, this) );
 	}
 
 	public LockRequest buildLockRequest(LockOptions lockOptions) {
 		return new LockRequestImpl(lockOptions);
 	}
 
 	public void lock(Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(object, lockMode, this) );
 	}
 
 	private void fireLock(String entityName, Object object, LockOptions options) {
 		fireLock( new LockEvent( entityName, object, options, this) );
 	}
 
 	private void fireLock( Object object, LockOptions options) {
 		fireLock( new LockEvent( object, options, this ) );
 	}
 
 	private void fireLock(LockEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( LockEventListener listener : listeners( EventType.LOCK ) ) {
 			listener.onLock( event );
 		}
 	}
 
 
 	// persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persist(String entityName, Object object) throws HibernateException {
 		firePersist( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persist(Object object) throws HibernateException {
 		persist( null, object );
 	}
 
 	public void persist(String entityName, Object object, Map copiedAlready)
 	throws HibernateException {
 		firePersist( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersist(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
 			listener.onPersist( event, copiedAlready );
 		}
 	}
 
 	private void firePersist(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( PersistEventListener listener : listeners( EventType.PERSIST ) ) {
 			listener.onPersist( event );
 		}
 	}
 
 
 	// persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persistOnFlush(String entityName, Object object)
 			throws HibernateException {
 		firePersistOnFlush( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persistOnFlush(Object object) throws HibernateException {
 		persist( null, object );
 	}
 
 	public void persistOnFlush(String entityName, Object object, Map copiedAlready)
 			throws HibernateException {
 		firePersistOnFlush( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersistOnFlush(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( PersistEventListener listener : listeners( EventType.PERSIST_ONFLUSH ) ) {
 			listener.onPersist( event, copiedAlready );
 		}
 	}
 
 	private void firePersistOnFlush(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( PersistEventListener listener : listeners( EventType.PERSIST_ONFLUSH ) ) {
 			listener.onPersist( event );
 		}
 	}
 
 
 	// merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object merge(String entityName, Object object) throws HibernateException {
 		return fireMerge( new MergeEvent( entityName, object, this ) );
 	}
 
 	public Object merge(Object object) throws HibernateException {
 		return merge( null, object );
 	}
 
 	public void merge(String entityName, Object object, Map copiedAlready) throws HibernateException {
 		fireMerge( copiedAlready, new MergeEvent( entityName, object, this ) );
 	}
 
 	private Object fireMerge(MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( MergeEventListener listener : listeners( EventType.MERGE ) ) {
 			listener.onMerge( event );
 		}
 		return event.getResult();
 	}
 
 	private void fireMerge(Map copiedAlready, MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( MergeEventListener listener : listeners( EventType.MERGE ) ) {
 			listener.onMerge( event, copiedAlready );
 		}
 	}
 
 
 	// delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(Object object) throws HibernateException {
 		fireDelete( new DeleteEvent(object, this) );
 	}
 
 	/**
 	 * Delete a persistent object (by explicit entity name)
 	 */
 	public void delete(String entityName, Object object) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, this ) );
 	}
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(String entityName, Object object, boolean isCascadeDeleteEnabled, Set transientEntities) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, isCascadeDeleteEnabled, this ), transientEntities );
 	}
 
 	private void fireDelete(DeleteEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( DeleteEventListener listener : listeners( EventType.DELETE ) ) {
 			listener.onDelete( event );
 		}
 	}
 
 	private void fireDelete(DeleteEvent event, Set transientEntities) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( DeleteEventListener listener : listeners( EventType.DELETE ) ) {
 			listener.onDelete( event, transientEntities );
 		}
 	}
 
 
 	// load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void load(Object object, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, object, this);
 		fireLoad( event, LoadEventListener.RELOAD );
 	}
 
 	public Object load(Class entityClass, Serializable id) throws HibernateException {
 		return load( entityClass.getName(), id );
 	}
 
 	public Object load(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad( event, LoadEventListener.LOAD );
 			if ( event.getResult() == null ) {
 				getFactory().getEntityNotFoundDelegate().handleEntityNotFound( entityName, id );
 			}
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	public Object get(Class entityClass, Serializable id) throws HibernateException {
 		return get( entityClass.getName(), id );
 	}
 
 	public Object get(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad(event, LoadEventListener.GET);
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	/**
 	 * Load the data for the object with the specified id into a newly created object.
 	 * This is only called when lazily initializing a proxy.
 	 * Do NOT return a proxy.
 	 */
 	public Object immediateLoad(String entityName, Serializable id) throws HibernateException {
         if (LOG.isDebugEnabled()) {
 			EntityPersister persister = getFactory().getEntityPersister(entityName);
             LOG.debugf("Initializing proxy: %s", MessageHelper.infoString(persister, id, getFactory()));
 		}
 
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, LoadEventListener.IMMEDIATE_LOAD);
 		return event.getResult();
 	}
 
 	public Object internalLoad(String entityName, Serializable id, boolean eager, boolean nullable) throws HibernateException {
 		// todo : remove
 		LoadEventListener.LoadType type = nullable
 				? LoadEventListener.INTERNAL_LOAD_NULLABLE
 				: eager
 						? LoadEventListener.INTERNAL_LOAD_EAGER
 						: LoadEventListener.INTERNAL_LOAD_LAZY;
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, type);
 		if ( !nullable ) {
 			UnresolvableObjectException.throwIfNull( event.getResult(), id, entityName );
 		}
 		return event.getResult();
 	}
 
 	public Object load(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return load( entityClass.getName(), id, lockMode );
 	}
 
 	public Object load(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
 		return load( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object load(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object load(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object get(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return get( entityClass.getName(), id, lockMode );
 	}
 
 	public Object get(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
 		return get( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object get(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 	   	fireLoad(event, LoadEventListener.GET);
 		return event.getResult();
 	}
 
 	public Object get(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
 	   	fireLoad( event, LoadEventListener.GET );
 		return event.getResult();
 	}
 
 	private void fireLoad(LoadEvent event, LoadType loadType) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( LoadEventListener listener : listeners( EventType.LOAD ) ) {
 			listener.onLoad( event, loadType );
 		}
 	}
 
 
 	// refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void refresh(Object object) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, this) );
 	}
 
 	public void refresh(Object object, LockMode lockMode) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockMode, this) );
 	}
 
 	public void refresh(Object object, LockOptions lockOptions) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockOptions, this) );
 	}
 
 	public void refresh(Object object, Map refreshedAlready) throws HibernateException {
 		fireRefresh( refreshedAlready, new RefreshEvent( object, this ) );
 	}
 
 	private void fireRefresh(RefreshEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( RefreshEventListener listener : listeners( EventType.REFRESH ) ) {
 			listener.onRefresh( event );
 		}
 	}
 
 	private void fireRefresh(Map refreshedAlready, RefreshEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( RefreshEventListener listener : listeners( EventType.REFRESH ) ) {
 			listener.onRefresh( event, refreshedAlready );
 		}
 	}
 
 
 	// replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void replicate(Object obj, ReplicationMode replicationMode) throws HibernateException {
 		fireReplicate( new ReplicateEvent(obj, replicationMode, this) );
 	}
 
 	public void replicate(String entityName, Object obj, ReplicationMode replicationMode)
 	throws HibernateException {
 		fireReplicate( new ReplicateEvent( entityName, obj, replicationMode, this ) );
 	}
 
 	private void fireReplicate(ReplicateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( ReplicateEventListener listener : listeners( EventType.REPLICATE ) ) {
 			listener.onReplicate( event );
 		}
 	}
 
 
 	// evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * remove any hard references to the entity that are held by the infrastructure
 	 * (references held by application or other persistant instances are okay)
 	 */
 	public void evict(Object object) throws HibernateException {
 		fireEvict( new EvictEvent( object, this ) );
 	}
 
 	private void fireEvict(EvictEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		for ( EvictEventListener listener : listeners( EventType.EVICT ) ) {
 			listener.onEvict( event );
 		}
 	}
 
 	/**
 	 * detect in-memory changes, determine if the changes are to tables
 	 * named in the query and, if so, complete execution the flush
 	 */
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
index 86aa8bb7cd..0ee02a3e9c 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
@@ -1,1070 +1,1070 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader;
 
 import java.io.Serializable;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.QueryKey;
 import org.hibernate.engine.internal.TwoPhaseLoad;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SubselectFetch;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.PreLoadEvent;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.WrongClassException;
 import org.hibernate.cache.spi.FilterKey;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.EntityUniqueKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.TypedValue;
 import org.hibernate.engine.jdbc.ColumnNameCache;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PreLoadEvent;
+import org.hibernate.event.spi.PostLoadEvent;
 import org.hibernate.hql.HolderInstantiator;
 import org.hibernate.internal.FetchingScrollableResultsImpl;
 import org.hibernate.internal.ScrollableResultsImpl;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.UniqueKeyLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.transform.CacheableResultTransformer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Abstract superclass of object loading (and querying) strategies. This class implements
  * useful common functionality that concrete loaders delegate to. It is not intended that this
  * functionality would be directly accessed by client code. (Hence, all methods of this class
  * are declared <tt>protected</tt> or <tt>private</tt>.) This class relies heavily upon the
  * <tt>Loadable</tt> interface, which is the contract between this class and
  * <tt>EntityPersister</tt>s that may be loaded by it.<br>
  * <br>
  * The present implementation is able to load any number of columns of entities and at most
  * one collection role per query.
  *
  * @author Gavin King
  * @see org.hibernate.persister.entity.Loadable
  */
 public abstract class Loader {
 
     protected static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Loader.class.getName());
 
 	private final SessionFactoryImplementor factory;
 	private ColumnNameCache columnNameCache;
 
 	public Loader(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 *
 	 * @return The sql command this loader should use to get its {@link ResultSet}.
 	 */
 	protected abstract String getSQLString();
 
 	/**
 	 * An array of persisters of entity classes contained in each row of results;
 	 * implemented by all subclasses
 	 *
 	 * @return The entity persisters.
 	 */
 	protected abstract Loadable[] getEntityPersisters();
 
 	/**
 	 * An array indicating whether the entities have eager property fetching
 	 * enabled.
 	 *
 	 * @return Eager property fetching indicators.
 	 */
 	protected boolean[] getEntityEagerPropertyFetches() {
 		return null;
 	}
 
 	/**
 	 * An array of indexes of the entity that owns a one-to-one association
 	 * to the entity at the given index (-1 if there is no "owner").  The
 	 * indexes contained here are relative to the result of
 	 * {@link #getEntityPersisters}.
 	 *
 	 * @return The owner indicators (see discussion above).
 	 */
 	protected int[] getOwners() {
 		return null;
 	}
 
 	/**
 	 * An array of the owner types corresponding to the {@link #getOwners()}
 	 * returns.  Indices indicating no owner would be null here.
 	 *
 	 * @return The types for the owners.
 	 */
 	protected EntityType[] getOwnerAssociationTypes() {
 		return null;
 	}
 
 	/**
 	 * An (optional) persister for a collection to be initialized; only
 	 * collection loaders return a non-null value
 	 */
 	protected CollectionPersister[] getCollectionPersisters() {
 		return null;
 	}
 
 	/**
 	 * Get the index of the entity that owns the collection, or -1
 	 * if there is no owner in the query results (ie. in the case of a
 	 * collection initializer) or no collection.
 	 */
 	protected int[] getCollectionOwners() {
 		return null;
 	}
 
 	protected int[][] getCompositeKeyManyToOneTargetIndices() {
 		return null;
 	}
 
 	/**
 	 * What lock options does this load entities with?
 	 *
 	 * @param lockOptions a collection of lock options specified dynamically via the Query interface
 	 */
 	//protected abstract LockOptions[] getLockOptions(Map lockOptions);
 	protected abstract LockMode[] getLockModes(LockOptions lockOptions);
 
 	/**
 	 * Append <tt>FOR UPDATE OF</tt> clause, if necessary. This
 	 * empty superclass implementation merely returns its first
 	 * argument.
 	 */
 	protected String applyLocks(String sql, LockOptions lockOptions, Dialect dialect) throws HibernateException {
 		return sql;
 	}
 
 	/**
 	 * Does this query return objects that might be already cached
 	 * by the session, whose lock mode may need upgrading
 	 */
 	protected boolean upgradeLocks() {
 		return false;
 	}
 
 	/**
 	 * Return false is this loader is a batch entity loader
 	 */
 	protected boolean isSingleRowLoader() {
 		return false;
 	}
 
 	/**
 	 * Get the SQL table aliases of entities whose
 	 * associations are subselect-loadable, returning
 	 * null if this loader does not support subselect
 	 * loading
 	 */
 	protected String[] getAliases() {
 		return null;
 	}
 
 	/**
 	 * Modify the SQL, adding lock hints and comments, if necessary
 	 */
 	protected String preprocessSQL(String sql, QueryParameters parameters, Dialect dialect)
 			throws HibernateException {
 
 		sql = applyLocks( sql, parameters.getLockOptions(), dialect );
 
 		return getFactory().getSettings().isCommentsEnabled() ?
 				prependComment( sql, parameters ) : sql;
 	}
 
 	private String prependComment(String sql, QueryParameters parameters) {
 		String comment = parameters.getComment();
 		if ( comment == null ) {
 			return sql;
 		}
 		else {
 			return new StringBuffer( comment.length() + sql.length() + 5 )
 					.append( "/* " )
 					.append( comment )
 					.append( " */ " )
 					.append( sql )
 					.toString();
 		}
 	}
 
 	/**
 	 * Execute an SQL query and attempt to instantiate instances of the class mapped by the given
 	 * persister from each row of the <tt>ResultSet</tt>. If an object is supplied, will attempt to
 	 * initialize that object. If a collection is supplied, attempt to initialize that collection.
 	 */
 	private List doQueryAndInitializeNonLazyCollections(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies) throws HibernateException, SQLException {
 		return doQueryAndInitializeNonLazyCollections(
 				session,
 				queryParameters,
 				returnProxies,
 				null
 		);
 	}
 
 	private List doQueryAndInitializeNonLazyCollections(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies,
 			final ResultTransformer forcedResultTransformer)
 			throws HibernateException, SQLException {
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		boolean defaultReadOnlyOrig = persistenceContext.isDefaultReadOnly();
 		if ( queryParameters.isReadOnlyInitialized() ) {
 			// The read-only/modifiable mode for the query was explicitly set.
 			// Temporarily set the default read-only/modifiable setting to the query's setting.
 			persistenceContext.setDefaultReadOnly( queryParameters.isReadOnly() );
 		}
 		else {
 			// The read-only/modifiable setting for the query was not initialized.
 			// Use the default read-only/modifiable from the persistence context instead.
 			queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
 		}
 		persistenceContext.beforeLoad();
 		List result;
 		try {
 			try {
 				result = doQuery( session, queryParameters, returnProxies, forcedResultTransformer );
 			}
 			finally {
 				persistenceContext.afterLoad();
 			}
 			persistenceContext.initializeNonLazyCollections();
 		}
 		finally {
 			// Restore the original default
 			persistenceContext.setDefaultReadOnly( defaultReadOnlyOrig );
 		}
 		return result;
 	}
 
 	/**
 	 * Loads a single row from the result set.  This is the processing used from the
 	 * ScrollableResults where no collection fetches were encountered.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSingleRow(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies) throws HibernateException {
 
 		final int entitySpan = getEntityPersisters().length;
 		final List hydratedObjects = entitySpan == 0 ?
 				null : new ArrayList( entitySpan );
 
 		final Object result;
 		try {
 			result = getRowFromResultSet(
 			        resultSet,
 					session,
 					queryParameters,
 					getLockModes( queryParameters.getLockOptions() ),
 					null,
 					hydratedObjects,
 					new EntityKey[entitySpan],
 					returnProxies
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not read next row of results",
 			        getSQLString()
 				);
 		}
 
 		initializeEntitiesAndCollections(
 				hydratedObjects,
 				resultSet,
 				session,
 				queryParameters.isReadOnly( session )
 			);
 		session.getPersistenceContext().initializeNonLazyCollections();
 		return result;
 	}
 
 	private Object sequentialLoad(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies,
 	        final EntityKey keyToRead) throws HibernateException {
 
 		final int entitySpan = getEntityPersisters().length;
 		final List hydratedObjects = entitySpan == 0 ?
 				null : new ArrayList( entitySpan );
 
 		Object result = null;
 		final EntityKey[] loadedKeys = new EntityKey[entitySpan];
 
 		try {
 			do {
 				Object loaded = getRowFromResultSet(
 						resultSet,
 						session,
 						queryParameters,
 						getLockModes( queryParameters.getLockOptions() ),
 						null,
 						hydratedObjects,
 						loadedKeys,
 						returnProxies
 					);
 				if ( result == null ) {
 					result = loaded;
 				}
 			}
 			while ( keyToRead.equals( loadedKeys[0] ) && resultSet.next() );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 
 		initializeEntitiesAndCollections(
 				hydratedObjects,
 				resultSet,
 				session,
 				queryParameters.isReadOnly( session )
 			);
 		session.getPersistenceContext().initializeNonLazyCollections();
 		return result;
 	}
 
 	/**
 	 * Loads a single logical row from the result set moving forward.  This is the
 	 * processing used from the ScrollableResults where there were collection fetches
 	 * encountered; thus a single logical row may have multiple rows in the underlying
 	 * result set.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSequentialRowsForward(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies) throws HibernateException {
 
 		// note that for sequential scrolling, we make the assumption that
 		// the first persister element is the "root entity"
 
 		try {
 			if ( resultSet.isAfterLast() ) {
 				// don't even bother trying to read further
 				return null;
 			}
 
 			if ( resultSet.isBeforeFirst() ) {
 				resultSet.next();
 			}
 
 			// We call getKeyFromResultSet() here so that we can know the
 			// key value upon which to doAfterTransactionCompletion the breaking logic.  However,
 			// it is also then called from getRowFromResultSet() which is certainly
 			// not the most efficient.  But the call here is needed, and there
 			// currently is no other way without refactoring of the doQuery()/getRowFromResultSet()
 			// methods
 			final EntityKey currentKey = getKeyFromResultSet(
 					0,
 					getEntityPersisters()[0],
 					null,
 					resultSet,
 					session
 				);
 
 			return sequentialLoad( resultSet, session, queryParameters, returnProxies, currentKey );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 	}
 
 	/**
 	 * Loads a single logical row from the result set moving forward.  This is the
 	 * processing used from the ScrollableResults where there were collection fetches
 	 * encountered; thus a single logical row may have multiple rows in the underlying
 	 * result set.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSequentialRowsReverse(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies,
 	        final boolean isLogicallyAfterLast) throws HibernateException {
 
 		// note that for sequential scrolling, we make the assumption that
 		// the first persister element is the "root entity"
 
 		try {
 			if ( resultSet.isFirst() ) {
 				// don't even bother trying to read any further
 				return null;
 			}
 
 			EntityKey keyToRead = null;
 			// This check is needed since processing leaves the cursor
 			// after the last physical row for the current logical row;
 			// thus if we are after the last physical row, this might be
 			// caused by either:
 			//      1) scrolling to the last logical row
 			//      2) scrolling past the last logical row
 			// In the latter scenario, the previous logical row
 			// really is the last logical row.
 			//
 			// In all other cases, we should process back two
 			// logical records (the current logic row, plus the
 			// previous logical row).
 			if ( resultSet.isAfterLast() && isLogicallyAfterLast ) {
 				// position cursor to the last row
 				resultSet.last();
 				keyToRead = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 			}
 			else {
 				// Since the result set cursor is always left at the first
 				// physical row after the "last processed", we need to jump
 				// back one position to get the key value we are interested
 				// in skipping
 				resultSet.previous();
 
 				// sequentially read the result set in reverse until we recognize
 				// a change in the key value.  At that point, we are pointed at
 				// the last physical sequential row for the logical row in which
 				// we are interested in processing
 				boolean firstPass = true;
 				final EntityKey lastKey = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 				while ( resultSet.previous() ) {
 					EntityKey checkKey = getKeyFromResultSet(
 							0,
 							getEntityPersisters()[0],
 							null,
 							resultSet,
 							session
 						);
 
 					if ( firstPass ) {
 						firstPass = false;
 						keyToRead = checkKey;
 					}
 
 					if ( !lastKey.equals( checkKey ) ) {
 						break;
 					}
 				}
 
 			}
 
 			// Read backwards until we read past the first physical sequential
 			// row with the key we are interested in loading
 			while ( resultSet.previous() ) {
 				EntityKey checkKey = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 
 				if ( !keyToRead.equals( checkKey ) ) {
 					break;
 				}
 			}
 
 			// Finally, read ahead one row to position result set cursor
 			// at the first physical row we are interested in loading
 			resultSet.next();
 
 			// and doAfterTransactionCompletion the load
 			return sequentialLoad( resultSet, session, queryParameters, returnProxies, keyToRead );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 	}
 
 	private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {
 		final Object optionalObject = queryParameters.getOptionalObject();
 		final Serializable optionalId = queryParameters.getOptionalId();
 		final String optionalEntityName = queryParameters.getOptionalEntityName();
 
 		if ( optionalObject != null && optionalEntityName != null ) {
 			return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) );
 		}
 		else {
 			return null;
 		}
 
 	}
 
 	private Object getRowFromResultSet(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final LockMode[] lockModesArray,
 	        final EntityKey optionalObjectKey,
 	        final List hydratedObjects,
 	        final EntityKey[] keys,
 	        boolean returnProxies) throws SQLException, HibernateException {
 		return getRowFromResultSet(
 				resultSet,
 				session,
 				queryParameters,
 				lockModesArray,
 				optionalObjectKey,
 				hydratedObjects,
 				keys,
 				returnProxies,
 				null
 		);
 	}
 
 	private Object getRowFromResultSet(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final LockMode[] lockModesArray,
 	        final EntityKey optionalObjectKey,
 	        final List hydratedObjects,
 	        final EntityKey[] keys,
 	        boolean returnProxies,
 	        ResultTransformer forcedResultTransformer) throws SQLException, HibernateException {
 		final Loadable[] persisters = getEntityPersisters();
 		final int entitySpan = persisters.length;
 		extractKeysFromResultSet( persisters, queryParameters, resultSet, session, keys, lockModesArray, hydratedObjects );
 
 		registerNonExists( keys, persisters, session );
 
 		// this call is side-effecty
 		Object[] row = getRow(
 		        resultSet,
 				persisters,
 				keys,
 				queryParameters.getOptionalObject(),
 				optionalObjectKey,
 				lockModesArray,
 				hydratedObjects,
 				session
 		);
 
 		readCollectionElements( row, resultSet, session );
 
 		if ( returnProxies ) {
 			// now get an existing proxy for each row element (if there is one)
 			for ( int i = 0; i < entitySpan; i++ ) {
 				Object entity = row[i];
 				Object proxy = session.getPersistenceContext().proxyFor( persisters[i], keys[i], entity );
 				if ( entity != proxy ) {
 					// force the proxy to resolve itself
 					( (HibernateProxy) proxy ).getHibernateLazyInitializer().setImplementation(entity);
 					row[i] = proxy;
 				}
 			}
 		}
 
 		applyPostLoadLocks( row, lockModesArray, session );
 
 		return forcedResultTransformer == null ?
 				getResultColumnOrRow( row, queryParameters.getResultTransformer(), resultSet, session ) :
 				forcedResultTransformer.transformTuple(
 						getResultRow( row, resultSet, session ),
 						getResultRowAliases()
 				)
 		;
 	}
 
 	protected void extractKeysFromResultSet(
 			Loadable[] persisters,
 			QueryParameters queryParameters,
 			ResultSet resultSet,
 			SessionImplementor session,
 			EntityKey[] keys,
 			LockMode[] lockModes,
 			List hydratedObjects) throws SQLException {
 		final int entitySpan = persisters.length;
 
 		final int numberOfPersistersToProcess;
 		final Serializable optionalId = queryParameters.getOptionalId();
 		if ( isSingleRowLoader() && optionalId != null ) {
 			keys[ entitySpan - 1 ] = session.generateEntityKey( optionalId, persisters[ entitySpan - 1 ] );
 			// skip the last persister below...
 			numberOfPersistersToProcess = entitySpan - 1;
 		}
 		else {
 			numberOfPersistersToProcess = entitySpan;
 		}
 
 		final Object[] hydratedKeyState = new Object[numberOfPersistersToProcess];
 
 		for ( int i = 0; i < numberOfPersistersToProcess; i++ ) {
 			final Type idType = persisters[i].getIdentifierType();
 			hydratedKeyState[i] = idType.hydrate( resultSet, getEntityAliases()[i].getSuffixedKeyAliases(), session, null );
 		}
 
 		for ( int i = 0; i < numberOfPersistersToProcess; i++ ) {
 			final Type idType = persisters[i].getIdentifierType();
 			if ( idType.isComponentType() && getCompositeKeyManyToOneTargetIndices() != null ) {
 				// we may need to force resolve any key-many-to-one(s)
 				int[] keyManyToOneTargetIndices = getCompositeKeyManyToOneTargetIndices()[i];
 				// todo : better solution is to order the index processing based on target indices
 				//		that would account for multiple levels whereas this scheme does not
 				if ( keyManyToOneTargetIndices != null ) {
 					for ( int targetIndex : keyManyToOneTargetIndices ) {
 						if ( targetIndex < numberOfPersistersToProcess ) {
 							final Type targetIdType = persisters[targetIndex].getIdentifierType();
 							final Serializable targetId = (Serializable) targetIdType.resolve(
 									hydratedKeyState[targetIndex],
 									session,
 									null
 							);
 							// todo : need a way to signal that this key is resolved and its data resolved
 							keys[targetIndex] = session.generateEntityKey( targetId, persisters[targetIndex] );
 						}
 
 						// this part copied from #getRow, this section could be refactored out
 						Object object = session.getEntityUsingInterceptor( keys[targetIndex] );
 						if ( object != null ) {
 							//its already loaded so don't need to hydrate it
 							instanceAlreadyLoaded(
 									resultSet,
 									targetIndex,
 									persisters[targetIndex],
 									keys[targetIndex],
 									object,
 									lockModes[targetIndex],
 									session
 							);
 						}
 						else {
 							instanceNotYetLoaded(
 									resultSet,
 									targetIndex,
 									persisters[targetIndex],
 									getEntityAliases()[targetIndex].getRowIdAlias(),
 									keys[targetIndex],
 									lockModes[targetIndex],
 									getOptionalObjectKey( queryParameters, session ),
 									queryParameters.getOptionalObject(),
 									hydratedObjects,
 									session
 							);
 						}
 					}
 				}
 			}
 			final Serializable resolvedId = (Serializable) idType.resolve( hydratedKeyState[i], session, null );
 			keys[i] = resolvedId == null ? null : session.generateEntityKey( resolvedId, persisters[i] );
 		}
 	}
 
 	private Serializable determineResultId(SessionImplementor session, Serializable optionalId, Type idType, Serializable resolvedId) {
 		final boolean idIsResultId = optionalId != null
 				&& resolvedId != null
 				&& idType.isEqual( optionalId, resolvedId, session.getEntityMode(), factory );
 		final Serializable resultId = idIsResultId ? optionalId : resolvedId;
 		return resultId;
 	}
 
 	protected void applyPostLoadLocks(Object[] row, LockMode[] lockModesArray, SessionImplementor session) {
 	}
 
 	/**
 	 * Read any collection elements contained in a single row of the result set
 	 */
 	private void readCollectionElements(Object[] row, ResultSet resultSet, SessionImplementor session)
 			throws SQLException, HibernateException {
 
 		//TODO: make this handle multiple collection roles!
 
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 
 			final CollectionAliases[] descriptors = getCollectionAliases();
 			final int[] collectionOwners = getCollectionOwners();
 
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 
 				final boolean hasCollectionOwners = collectionOwners !=null &&
 						collectionOwners[i] > -1;
 				//true if this is a query and we are loading multiple instances of the same collection role
 				//otherwise this is a CollectionInitializer and we are loading up a single collection or batch
 
 				final Object owner = hasCollectionOwners ?
 						row[ collectionOwners[i] ] :
 						null; //if null, owner will be retrieved from session
 
 				final CollectionPersister collectionPersister = collectionPersisters[i];
 				final Serializable key;
 				if ( owner == null ) {
 					key = null;
 				}
 				else {
 					key = collectionPersister.getCollectionType().getKeyOfOwner( owner, session );
 					//TODO: old version did not require hashmap lookup:
 					//keys[collectionOwner].getIdentifier()
 				}
 
 				readCollectionElement(
 						owner,
 						key,
 						collectionPersister,
 						descriptors[i],
 						resultSet,
 						session
 					);
 
 			}
 
 		}
 	}
 
 	private List doQuery(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies,
 			final ResultTransformer forcedResultTransformer) throws SQLException, HibernateException {
 
 		final RowSelection selection = queryParameters.getRowSelection();
 		final int maxRows = hasMaxRows( selection ) ?
 				selection.getMaxRows().intValue() :
 				Integer.MAX_VALUE;
 
 		final int entitySpan = getEntityPersisters().length;
 
 		final ArrayList hydratedObjects = entitySpan == 0 ? null : new ArrayList( entitySpan * 10 );
 		final PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 		final ResultSet rs = getResultSet( st, queryParameters.hasAutoDiscoverScalarTypes(), queryParameters.isCallable(), selection, session );
 
 // would be great to move all this below here into another method that could also be used
 // from the new scrolling stuff.
 //
 // Would need to change the way the max-row stuff is handled (i.e. behind an interface) so
 // that I could do the control breaking at the means to know when to stop
 
 		final EntityKey optionalObjectKey = getOptionalObjectKey( queryParameters, session );
 		final LockMode[] lockModesArray = getLockModes( queryParameters.getLockOptions() );
 		final boolean createSubselects = isSubselectLoadingEnabled();
 		final List subselectResultKeys = createSubselects ? new ArrayList() : null;
 		final List results = new ArrayList();
 
 		try {
 
 			handleEmptyCollections( queryParameters.getCollectionKeys(), rs, session );
 
 			EntityKey[] keys = new EntityKey[entitySpan]; //we can reuse it for each row
 
             LOG.trace("Processing result set");
 
 			int count;
 			for ( count = 0; count < maxRows && rs.next(); count++ ) {
 
                 LOG.debugf("Result set row: %s", count);
 
 				Object result = getRowFromResultSet(
 						rs,
 						session,
 						queryParameters,
 						lockModesArray,
 						optionalObjectKey,
 						hydratedObjects,
 						keys,
 						returnProxies,
 						forcedResultTransformer
 				);
 				results.add( result );
 
 				if ( createSubselects ) {
 					subselectResultKeys.add(keys);
 					keys = new EntityKey[entitySpan]; //can't reuse in this case
 				}
 
 			}
 
             LOG.trace("Done processing result set (" + count + " rows)");
 
 		}
 		finally {
 			st.close();
 		}
 
 		initializeEntitiesAndCollections( hydratedObjects, rs, session, queryParameters.isReadOnly( session ) );
 
 		if ( createSubselects ) createSubselects( subselectResultKeys, queryParameters, session );
 
 		return results; //getResultList(results);
 
 	}
 
 	protected boolean isSubselectLoadingEnabled() {
 		return false;
 	}
 
 	protected boolean hasSubselectLoadableCollections() {
 		final Loadable[] loadables = getEntityPersisters();
 		for (int i=0; i<loadables.length; i++ ) {
 			if ( loadables[i].hasSubselectLoadableCollections() ) return true;
 		}
 		return false;
 	}
 
 	private static Set[] transpose( List keys ) {
 		Set[] result = new Set[ ( ( EntityKey[] ) keys.get(0) ).length ];
 		for ( int j=0; j<result.length; j++ ) {
 			result[j] = new HashSet( keys.size() );
 			for ( int i=0; i<keys.size(); i++ ) {
 				result[j].add( ( ( EntityKey[] ) keys.get(i) ) [j] );
 			}
 		}
 		return result;
 	}
 
 	private void createSubselects(List keys, QueryParameters queryParameters, SessionImplementor session) {
 		if ( keys.size() > 1 ) { //if we only returned one entity, query by key is more efficient
 
 			Set[] keySets = transpose(keys);
 
 			Map namedParameterLocMap = buildNamedParameterLocMap( queryParameters );
 
 			final Loadable[] loadables = getEntityPersisters();
 			final String[] aliases = getAliases();
 			final Iterator iter = keys.iterator();
 			while ( iter.hasNext() ) {
 
 				final EntityKey[] rowKeys = (EntityKey[]) iter.next();
 				for ( int i=0; i<rowKeys.length; i++ ) {
 
 					if ( rowKeys[i]!=null && loadables[i].hasSubselectLoadableCollections() ) {
 
 						SubselectFetch subselectFetch = new SubselectFetch(
 								//getSQLString(),
 								aliases[i],
 								loadables[i],
 								queryParameters,
 								keySets[i],
 								namedParameterLocMap
 							);
 
 						session.getPersistenceContext()
 								.getBatchFetchQueue()
 								.addSubselect( rowKeys[i], subselectFetch );
 					}
 
 				}
 
 			}
 		}
 	}
 
 	private Map buildNamedParameterLocMap(QueryParameters queryParameters) {
 		if ( queryParameters.getNamedParameters()!=null ) {
 			final Map namedParameterLocMap = new HashMap();
 			Iterator piter = queryParameters.getNamedParameters().keySet().iterator();
 			while ( piter.hasNext() ) {
 				String name = (String) piter.next();
 				namedParameterLocMap.put(
 						name,
 						getNamedParameterLocs(name)
 					);
 			}
 			return namedParameterLocMap;
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void initializeEntitiesAndCollections(
 			final List hydratedObjects,
 			final Object resultSetId,
 			final SessionImplementor session,
 			final boolean readOnly)
 	throws HibernateException {
 
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( collectionPersisters[i].isArray() ) {
 					//for arrays, we should end the collection load before resolving
 					//the entities, since the actual array instances are not instantiated
 					//during loading
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 
 		//important: reuse the same event instances for performance!
 		final PreLoadEvent pre;
 		final PostLoadEvent post;
 		if ( session.isEventSource() ) {
 			pre = new PreLoadEvent( (EventSource) session );
 			post = new PostLoadEvent( (EventSource) session );
 		}
 		else {
 			pre = null;
 			post = null;
 		}
 
 		if ( hydratedObjects!=null ) {
 			int hydratedObjectsSize = hydratedObjects.size();
             LOG.trace("Total objects hydrated: " + hydratedObjectsSize);
 			for ( int i = 0; i < hydratedObjectsSize; i++ ) {
 				TwoPhaseLoad.initializeEntity( hydratedObjects.get(i), readOnly, session, pre, post );
 			}
 		}
 
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( !collectionPersisters[i].isArray() ) {
 					//for sets, we should end the collection load after resolving
 					//the entities, since we might call hashCode() on the elements
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 
 	}
 
 	private void endCollectionLoad(
 			final Object resultSetId,
 			final SessionImplementor session,
 			final CollectionPersister collectionPersister) {
 		//this is a query and we are loading multiple instances of the same collection role
 		session.getPersistenceContext()
 				.getLoadContexts()
 				.getCollectionLoadContext( ( ResultSet ) resultSetId )
 				.endLoadingCollections( collectionPersister );
 	}
 
 	/**
 	 * Determine the actual ResultTransformer that will be used to
 	 * transform query results.
 	 *
 	 * @param resultTransformer the specified result transformer
 	 * @return the actual result transformer
 	 */
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return resultTransformer;
 	}
 
 	protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		return results;
 	}
 
 	/**
 	 * Are rows transformed immediately after being read from the ResultSet?
 	 * @return true, if getResultColumnOrRow() transforms the results; false, otherwise
 	 */
 	protected boolean areResultSetRowsTransformedImmediately() {
 		return false;
 	}
 
 	/**
 	 * Returns the aliases that corresponding to a result row.
 	 * @return Returns the aliases that corresponding to a result row.
 	 */
 	protected String[] getResultRowAliases() {
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
index 19b1b108e7..be234e260d 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
@@ -1,617 +1,617 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.hql;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.HolderInstantiator;
 import org.hibernate.hql.ast.QueryTranslatorImpl;
 import org.hibernate.hql.ast.tree.AggregatedSelectExpression;
 import org.hibernate.hql.ast.tree.FromElement;
 import org.hibernate.hql.ast.tree.QueryNode;
 import org.hibernate.hql.ast.tree.SelectClause;
 import org.hibernate.internal.IteratorImpl;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.BasicLoader;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * A delegate that implements the Loader part of QueryTranslator.
  *
  * @author josh
  */
 public class QueryLoader extends BasicLoader {
 
 	/**
 	 * The query translator that is delegating to this object.
 	 */
 	private QueryTranslatorImpl queryTranslator;
 
 	private Queryable[] entityPersisters;
 	private String[] entityAliases;
 	private String[] sqlAliases;
 	private String[] sqlAliasSuffixes;
 	private boolean[] includeInSelect;
 
 	private String[] collectionSuffixes;
 
 	private boolean hasScalars;
 	private String[][] scalarColumnNames;
 	//private Type[] sqlResultTypes;
 	private Type[] queryReturnTypes;
 
 	private final Map sqlAliasByEntityAlias = new HashMap(8);
 
 	private EntityType[] ownerAssociationTypes;
 	private int[] owners;
 	private boolean[] entityEagerPropertyFetches;
 
 	private int[] collectionOwners;
 	private QueryableCollection[] collectionPersisters;
 
 	private int selectLength;
 
 	private AggregatedSelectExpression aggregatedSelectExpression;
 	private String[] queryReturnAliases;
 
 	private LockMode[] defaultLockModes;
 
 
 	/**
 	 * Creates a new Loader implementation.
 	 *
 	 * @param queryTranslator The query translator that is the delegator.
 	 * @param factory The factory from which this loader is being created.
 	 * @param selectClause The AST representing the select clause for loading.
 	 */
 	public QueryLoader(
 			final QueryTranslatorImpl queryTranslator,
 	        final SessionFactoryImplementor factory,
 	        final SelectClause selectClause) {
 		super( factory );
 		this.queryTranslator = queryTranslator;
 		initialize( selectClause );
 		postInstantiate();
 	}
 
 	private void initialize(SelectClause selectClause) {
 
 		List fromElementList = selectClause.getFromElementsForLoad();
 
 		hasScalars = selectClause.isScalarSelect();
 		scalarColumnNames = selectClause.getColumnNames();
 		//sqlResultTypes = selectClause.getSqlResultTypes();
 		queryReturnTypes = selectClause.getQueryReturnTypes();
 
 		aggregatedSelectExpression = selectClause.getAggregatedSelectExpression();
 		queryReturnAliases = selectClause.getQueryReturnAliases();
 
 		List collectionFromElements = selectClause.getCollectionFromElements();
 		if ( collectionFromElements != null && collectionFromElements.size()!=0 ) {
 			int length = collectionFromElements.size();
 			collectionPersisters = new QueryableCollection[length];
 			collectionOwners = new int[length];
 			collectionSuffixes = new String[length];
 			for ( int i=0; i<length; i++ ) {
 				FromElement collectionFromElement = (FromElement) collectionFromElements.get(i);
 				collectionPersisters[i] = collectionFromElement.getQueryableCollection();
 				collectionOwners[i] = fromElementList.indexOf( collectionFromElement.getOrigin() );
 //				collectionSuffixes[i] = collectionFromElement.getColumnAliasSuffix();
 //				collectionSuffixes[i] = Integer.toString( i ) + "_";
 				collectionSuffixes[i] = collectionFromElement.getCollectionSuffix();
 			}
 		}
 
 		int size = fromElementList.size();
 		entityPersisters = new Queryable[size];
 		entityEagerPropertyFetches = new boolean[size];
 		entityAliases = new String[size];
 		sqlAliases = new String[size];
 		sqlAliasSuffixes = new String[size];
 		includeInSelect = new boolean[size];
 		owners = new int[size];
 		ownerAssociationTypes = new EntityType[size];
 
 		for ( int i = 0; i < size; i++ ) {
 			final FromElement element = ( FromElement ) fromElementList.get( i );
 			entityPersisters[i] = ( Queryable ) element.getEntityPersister();
 
 			if ( entityPersisters[i] == null ) {
 				throw new IllegalStateException( "No entity persister for " + element.toString() );
 			}
 
 			entityEagerPropertyFetches[i] = element.isAllPropertyFetch();
 			sqlAliases[i] = element.getTableAlias();
 			entityAliases[i] = element.getClassAlias();
 			sqlAliasByEntityAlias.put( entityAliases[i], sqlAliases[i] );
 			// TODO should we just collect these like with the collections above?
 			sqlAliasSuffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + "_";
 //			sqlAliasSuffixes[i] = element.getColumnAliasSuffix();
 			includeInSelect[i] = !element.isFetch();
 			if ( includeInSelect[i] ) {
 				selectLength++;
 			}
 
 			owners[i] = -1; //by default
 			if ( element.isFetch() ) {
 				if ( element.isCollectionJoin() || element.getQueryableCollection() != null ) {
 					// This is now handled earlier in this method.
 				}
 				else if ( element.getDataType().isEntityType() ) {
 					EntityType entityType = ( EntityType ) element.getDataType();
 					if ( entityType.isOneToOne() ) {
 						owners[i] = fromElementList.indexOf( element.getOrigin() );
 					}
 					ownerAssociationTypes[i] = entityType;
 				}
 			}
 		}
 
 		//NONE, because its the requested lock mode, not the actual! 
 		defaultLockModes = ArrayHelper.fillArray( LockMode.NONE, size );
 	}
 
 	public AggregatedSelectExpression getAggregatedSelectExpression() {
 		return aggregatedSelectExpression;
 	}
 
 
 	// -- Loader implementation --
 
 	public final void validateScrollability() throws HibernateException {
 		queryTranslator.validateScrollability();
 	}
 
 	protected boolean needsFetchingScroll() {
 		return queryTranslator.containsCollectionFetches();
 	}
 
 	public Loadable[] getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	public String[] getAliases() {
 		return sqlAliases;
 	}
 
 	public String[] getSqlAliasSuffixes() {
 		return sqlAliasSuffixes;
 	}
 
 	public String[] getSuffixes() {
 		return getSqlAliasSuffixes();
 	}
 
 	public String[] getCollectionSuffixes() {
 		return collectionSuffixes;
 	}
 
 	protected String getQueryIdentifier() {
 		return queryTranslator.getQueryIdentifier();
 	}
 
 	/**
 	 * The SQL query string to be called.
 	 */
 	protected String getSQLString() {
 		return queryTranslator.getSQLString();
 	}
 
 	/**
 	 * An (optional) persister for a collection to be initialized; only collection loaders
 	 * return a non-null value
 	 */
 	protected CollectionPersister[] getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	protected int[] getCollectionOwners() {
 		return collectionOwners;
 	}
 
 	protected boolean[] getEntityEagerPropertyFetches() {
 		return entityEagerPropertyFetches;
 	}
 
 	/**
 	 * An array of indexes of the entity that owns a one-to-one association
 	 * to the entity at the given index (-1 if there is no "owner")
 	 */
 	protected int[] getOwners() {
 		return owners;
 	}
 
 	protected EntityType[] getOwnerAssociationTypes() {
 		return ownerAssociationTypes;
 	}
 
 	// -- Loader overrides --
 
 	protected boolean isSubselectLoadingEnabled() {
 		return hasSubselectLoadableCollections();
 	}
 
 	/**
 	 * @param lockOptions a collection of lock modes specified dynamically via the Query interface
 	 */
 	protected LockMode[] getLockModes(LockOptions lockOptions) {
 		if ( lockOptions == null ) {
 			return defaultLockModes;
 		}
 
 		if ( lockOptions.getAliasLockCount() == 0
 				&& ( lockOptions.getLockMode() == null || LockMode.NONE.equals( lockOptions.getLockMode() ) ) ) {
 			return defaultLockModes;
 		}
 
 		// unfortunately this stuff can't be cached because
 		// it is per-invocation, not constant for the
 		// QueryTranslator instance
 
 		LockMode[] lockModesArray = new LockMode[entityAliases.length];
 		for ( int i = 0; i < entityAliases.length; i++ ) {
 			LockMode lockMode = lockOptions.getEffectiveLockMode( entityAliases[i] );
 			if ( lockMode == null ) {
 				//NONE, because its the requested lock mode, not the actual!
 				lockMode = LockMode.NONE;
 			}
 			lockModesArray[i] = lockMode;
 		}
 
 		return lockModesArray;
 	}
 
 	protected String applyLocks(String sql, LockOptions lockOptions, Dialect dialect) throws QueryException {
 		// can't cache this stuff either (per-invocation)
 		// we are given a map of user-alias -> lock mode
 		// create a new map of sql-alias -> lock mode
 
 		if ( lockOptions == null ||
 			( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 
 		// we need both the set of locks and the columns to reference in locks
 		// as the ultimate output of this section...
 		final LockOptions locks = new LockOptions( lockOptions.getLockMode() );
 		final Map keyColumnNames = dialect.forUpdateOfColumns() ? new HashMap() : null;
 
 		locks.setScope( lockOptions.getScope() );
 		locks.setTimeOut( lockOptions.getTimeOut() );
 
 		final Iterator itr = sqlAliasByEntityAlias.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final String userAlias = (String) entry.getKey();
 			final String drivingSqlAlias = (String) entry.getValue();
 			if ( drivingSqlAlias == null ) {
 				throw new IllegalArgumentException( "could not locate alias to apply lock mode : " + userAlias );
 			}
 			// at this point we have (drivingSqlAlias) the SQL alias of the driving table
 			// corresponding to the given user alias.  However, the driving table is not
 			// (necessarily) the table against which we want to apply locks.  Mainly,
 			// the exception case here is joined-subclass hierarchies where we instead
 			// want to apply the lock against the root table (for all other strategies,
 			// it just happens that driving and root are the same).
 			final QueryNode select = ( QueryNode ) queryTranslator.getSqlAST();
 			final Lockable drivingPersister = ( Lockable ) select.getFromClause()
 					.findFromElementByUserOrSqlAlias( userAlias, drivingSqlAlias )
 					.getQueryable();
 			final String sqlAlias = drivingPersister.getRootTableAlias( drivingSqlAlias );
 
 			final LockMode effectiveLockMode = lockOptions.getEffectiveLockMode( userAlias );
 			locks.setAliasSpecificLockMode( sqlAlias, effectiveLockMode );
 
 			if ( keyColumnNames != null ) {
 				keyColumnNames.put( sqlAlias, drivingPersister.getRootTableIdentifierColumnNames() );
 			}
 		}
 
 		// apply the collected locks and columns
 		return dialect.applyLocksToSql( sql, locks, keyColumnNames );
 	}
 
 	protected void applyPostLoadLocks(Object[] row, LockMode[] lockModesArray, SessionImplementor session) {
 		// todo : scalars???
 //		if ( row.length != lockModesArray.length ) {
 //			return;
 //		}
 //
 //		for ( int i = 0; i < lockModesArray.length; i++ ) {
 //			if ( LockMode.OPTIMISTIC_FORCE_INCREMENT.equals( lockModesArray[i] ) ) {
 //				final EntityEntry pcEntry =
 //			}
 //			else if ( LockMode.PESSIMISTIC_FORCE_INCREMENT.equals( lockModesArray[i] ) ) {
 //
 //			}
 //		}
 	}
 
 	protected boolean upgradeLocks() {
 		return true;
 	}
 
 	private boolean hasSelectNew() {
 		return aggregatedSelectExpression != null &&  aggregatedSelectExpression.getResultTransformer() != null;
 	}
 
 	protected String[] getResultRowAliases() {
 		return queryReturnAliases;
 	}
 	
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		final ResultTransformer implicitResultTransformer = aggregatedSelectExpression == null
 				? null
 				: aggregatedSelectExpression.getResultTransformer();
 		return HolderInstantiator.resolveResultTransformer( implicitResultTransformer, resultTransformer );
 	}
 
 	protected boolean[] includeInResultRow() {
 		boolean[] includeInResultTuple = includeInSelect;
 		if ( hasScalars ) {
 			includeInResultTuple = new boolean[ queryReturnTypes.length ];
 			Arrays.fill( includeInResultTuple, true );
 		}
 		return includeInResultTuple;
 	}
 
 	protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 
 		Object[] resultRow = getResultRow( row, rs, session );
 		boolean hasTransform = hasSelectNew() || transformer!=null;
 		return ( ! hasTransform && resultRow.length == 1 ?
 				resultRow[ 0 ] :
 				resultRow
 		);
 	}
 
 	protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow;
 		if ( hasScalars ) {
 			String[][] scalarColumns = scalarColumnNames;
 			int queryCols = queryReturnTypes.length;
 			resultRow = new Object[queryCols];
 			for ( int i = 0; i < queryCols; i++ ) {
 				resultRow[i] = queryReturnTypes[i].nullSafeGet( rs, scalarColumns[i], session, null );
 			}
 		}
 		else {
 			resultRow = toResultRow( row );
 		}
 		return resultRow;
 	}
 
 	protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		// meant to handle dynamic instantiation queries...
 		HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );
 		if ( holderInstantiator.isRequired() ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				Object result = holderInstantiator.instantiate(row);
 				results.set( i, result );
 			}
 
 			if ( !hasSelectNew() && resultTransformer != null ) {
 				return resultTransformer.transformList(results);
 			}
 			else {
 				return results;
 			}
 		}
 		else {
 			return results;
 		}
 	}
 
 	private HolderInstantiator buildHolderInstantiator(ResultTransformer queryLocalResultTransformer) {
 		final ResultTransformer implicitResultTransformer = aggregatedSelectExpression == null
 				? null
 				: aggregatedSelectExpression.getResultTransformer();
 		return HolderInstantiator.getHolderInstantiator(
 				implicitResultTransformer,
 				queryLocalResultTransformer,
 				queryReturnAliases
 		);
 	}
 	// --- Query translator methods ---
 
 	public List list(
 			SessionImplementor session,
 			QueryParameters queryParameters) throws HibernateException {
 		checkQuery( queryParameters );
 		return list( session, queryParameters, queryTranslator.getQuerySpaces(), queryReturnTypes );
 	}
 
 	private void checkQuery(QueryParameters queryParameters) {
 		if ( hasSelectNew() && queryParameters.getResultTransformer() != null ) {
 			throw new QueryException( "ResultTransformer is not allowed for 'select new' queries." );
 		}
 	}
 
 	public Iterator iterate(
 			QueryParameters queryParameters,
 			EventSource session) throws HibernateException {
 		checkQuery( queryParameters );
 		final boolean stats = session.getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) {
 			startTime = System.currentTimeMillis();
 		}
 
 		try {
 			final PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 			if ( queryParameters.isCallable() ) {
 				throw new QueryException("iterate() not supported for callable statements");
 			}
 			final ResultSet rs = getResultSet(st, queryParameters.hasAutoDiscoverScalarTypes(), false, queryParameters.getRowSelection(), session);
 			final Iterator result = new IteratorImpl(
 					rs,
 			        st,
 			        session,
 			        queryParameters.isReadOnly( session ),
 			        queryReturnTypes,
 			        queryTranslator.getColumnNames(),
 			        buildHolderInstantiator( queryParameters.getResultTransformer() )
 			);
 
 			if ( stats ) {
 				session.getFactory().getStatisticsImplementor().queryExecuted(
 //						"HQL: " + queryTranslator.getQueryString(),
 						getQueryIdentifier(),
 						0,
 						System.currentTimeMillis() - startTime
 				);
 			}
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query using iterate",
 			        getSQLString()
 				);
 		}
 
 	}
 
 	public ScrollableResults scroll(
 			final QueryParameters queryParameters,
 	        final SessionImplementor session) throws HibernateException {
 		checkQuery( queryParameters );
 		return scroll( 
 				queryParameters,
 				queryReturnTypes,
 				buildHolderInstantiator( queryParameters.getResultTransformer() ),
 				session
 		);
 	}
 
 	// -- Implementation private methods --
 
 	private Object[] toResultRow(Object[] row) {
 		if ( selectLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[selectLength];
 			int j = 0;
 			for ( int i = 0; i < row.length; i++ ) {
 				if ( includeInSelect[i] ) {
 					result[j++] = row[i];
 				}
 			}
 			return result;
 		}
 	}
 
 	/**
 	 * Returns the locations of all occurrences of the named parameter.
 	 */
 	public int[] getNamedParameterLocs(String name) throws QueryException {
 		return queryTranslator.getParameterTranslations().getNamedParameterSqlLocations( name );
 	}
 
 	/**
 	 * We specifically override this method here, because in general we know much more
 	 * about the parameters and their appropriate bind positions here then we do in
 	 * our super because we track them explciitly here through the ParameterSpecification
 	 * interface.
 	 *
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 */
 	protected int bindParameterValues(
 			final PreparedStatement statement,
 			final QueryParameters queryParameters,
 			final int startIndex,
 			final SessionImplementor session) throws SQLException {
 //		int position = bindFilterParameterValues( statement, queryParameters, startIndex, session );
 		int position = startIndex;
 //		List parameterSpecs = queryTranslator.getSqlAST().getWalker().getParameters();
 		List parameterSpecs = queryTranslator.getCollectedParameterSpecifications();
 		Iterator itr = parameterSpecs.iterator();
 		while ( itr.hasNext() ) {
 			ParameterSpecification spec = ( ParameterSpecification ) itr.next();
 			position += spec.bind( statement, queryParameters, session, position );
 		}
 		return position - startIndex;
 	}
 
 	private int bindFilterParameterValues(
 			PreparedStatement st,
 			QueryParameters queryParameters,
 			int position,
 			SessionImplementor session) throws SQLException {
 		// todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification
 		// see the discussion there in DynamicFilterParameterSpecification's javadocs as to why
 		// it is currently not done that way.
 		int filteredParamCount = queryParameters.getFilteredPositionalParameterTypes() == null
 				? 0
 				: queryParameters.getFilteredPositionalParameterTypes().length;
 		int nonfilteredParamCount = queryParameters.getPositionalParameterTypes() == null
 				? 0
 				: queryParameters.getPositionalParameterTypes().length;
 		int filterParamCount = filteredParamCount - nonfilteredParamCount;
 		for ( int i = 0; i < filterParamCount; i++ ) {
 			Type type = queryParameters.getFilteredPositionalParameterTypes()[i];
 			Object value = queryParameters.getFilteredPositionalParameterValues()[i];
 			type.nullSafeSet( st, value, position, session );
 			position += type.getColumnSpan( getFactory() );
 		}
 
 		return position;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/HibernatePermission.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/HibernatePermission.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/secure/HibernatePermission.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/HibernatePermission.java
index 5025ab288d..071754d679 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/HibernatePermission.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/HibernatePermission.java
@@ -1,71 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
 import java.security.Permission;
 
 /**
  * @author Gavin King
  */
 public class HibernatePermission extends Permission {
-	
 	public static final String INSERT = "insert";
 	public static final String UPDATE = "update";
 	public static final String DELETE = "delete";
 	public static final String READ = "read";
 	public static final String ANY = "*";
 	
 	private final String actions;
 
 	public HibernatePermission(String entityName, String actions) {
 		super(entityName);
 		this.actions = actions;
 	}
 
 	public boolean implies(Permission permission) {
 		//TODO!
 		return ( "*".equals( getName() ) || getName().equals( permission.getName() ) ) &&
 			( "*".equals(actions) || actions.indexOf( permission.getActions() ) >= 0 );
 	}
 
 	public boolean equals(Object obj) {
 		if ( !(obj instanceof HibernatePermission) ) return false;
 		HibernatePermission permission = (HibernatePermission) obj;
 		return permission.getName().equals( getName() ) && 
 			permission.getActions().equals(actions);
 	}
 
 	public int hashCode() {
 		return getName().hashCode() * 37 + actions.hashCode();
 	}
 
 	public String getActions() {
 		return actions;
 	}
 	
 	public String toString() {
 		return "HibernatePermission(" + getName() + ':' + actions + ')';
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCConfiguration.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCConfiguration.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCConfiguration.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCConfiguration.java
index e398448ddb..96bf732e88 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCConfiguration.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCConfiguration.java
@@ -1,87 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
-import java.util.StringTokenizer;
+package org.hibernate.secure.internal;
+
 import javax.security.jacc.EJBMethodPermission;
 import javax.security.jacc.PolicyConfiguration;
 import javax.security.jacc.PolicyConfigurationFactory;
 import javax.security.jacc.PolicyContextException;
-import org.hibernate.HibernateException;
-import org.hibernate.internal.CoreMessageLogger;
+import java.util.StringTokenizer;
 
 import org.jboss.logging.Logger;
 
+import org.hibernate.HibernateException;
+import org.hibernate.internal.CoreMessageLogger;
+
 /**
  * Adds Hibernate permissions to roles via JACC
  *
  * @author Gavin King
  */
 public class JACCConfiguration {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JACCConfiguration.class.getName());
 
 	private final PolicyConfiguration policyConfiguration;
 
 	public JACCConfiguration(String contextId) throws HibernateException {
 		try {
 			policyConfiguration = PolicyConfigurationFactory
 					.getPolicyConfigurationFactory()
 					.getPolicyConfiguration( contextId, false );
 		}
 		catch (ClassNotFoundException cnfe) {
 			throw new HibernateException( "JACC provider class not found", cnfe );
 		}
 		catch (PolicyContextException pce) {
 			throw new HibernateException( "policy context exception occurred", pce );
 		}
 	}
 
 	public void addPermission(String role, String entityName, String action) {
 
 		if ( action.equals( "*" ) ) {
 			action = "insert,read,update,delete";
 		}
 
 		StringTokenizer tok = new StringTokenizer( action, "," );
 
 		while ( tok.hasMoreTokens() ) {
 			String methodName = tok.nextToken().trim();
 			EJBMethodPermission permission = new EJBMethodPermission(
 					entityName,
 					methodName,
 					null, // interfaces
 					null // arguments
 				);
 
             LOG.debugf("Adding permission to role %s: %s", role, permission);
 			try {
 				policyConfiguration.addToRole( role, permission );
 			}
 			catch (PolicyContextException pce) {
 				throw new HibernateException( "policy context exception occurred", pce );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCPermissions.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPermissions.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCPermissions.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPermissions.java
index 667f838541..f56601f27b 100644
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCPermissions.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPermissions.java
@@ -1,145 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
+import javax.security.auth.Subject;
+import javax.security.jacc.EJBMethodPermission;
+import javax.security.jacc.PolicyContext;
+import javax.security.jacc.PolicyContextException;
 import java.lang.reflect.UndeclaredThrowableException;
 import java.security.AccessController;
 import java.security.CodeSource;
 import java.security.Policy;
 import java.security.Principal;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.security.ProtectionDomain;
 import java.util.Set;
-import javax.security.auth.Subject;
-import javax.security.jacc.EJBMethodPermission;
-import javax.security.jacc.PolicyContext;
-import javax.security.jacc.PolicyContextException;
-
 
 /**
  * Copied from JBoss org.jboss.ejb3.security.JaccHelper and org.jboss.ejb3.security.SecurityActions
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 public class JACCPermissions {
 
 	public static void checkPermission(Class clazz, String contextID, EJBMethodPermission methodPerm)
 			throws SecurityException {
 		CodeSource ejbCS = clazz.getProtectionDomain().getCodeSource();
 
 		try {
 			setContextID( contextID );
 
 			Policy policy = Policy.getPolicy();
 			// Get the caller
 			Subject caller = getContextSubject();
 
 			Principal[] principals = null;
 			if ( caller != null ) {
 				// Get the caller principals
 				Set principalsSet = caller.getPrincipals();
 				principals = new Principal[ principalsSet.size() ];
 				principalsSet.toArray( principals );
 			}
 
 			ProtectionDomain pd = new ProtectionDomain( ejbCS, null, null, principals );
 			if ( policy.implies( pd, methodPerm ) == false ) {
 				String msg = "Denied: " + methodPerm + ", caller=" + caller;
 				SecurityException e = new SecurityException( msg );
 				throw e;
 			}
 		}
 		catch (PolicyContextException e) {
 			throw new RuntimeException( e );
 		}
 	}
 
 	interface PolicyContextActions {
 		/**
 		 * The JACC PolicyContext key for the current Subject
 		 */
 		static final String SUBJECT_CONTEXT_KEY = "javax.security.auth.Subject.container";
 		PolicyContextActions PRIVILEGED = new PolicyContextActions() {
 			private final PrivilegedExceptionAction exAction = new PrivilegedExceptionAction() {
 				public Object run() throws Exception {
 					return (Subject) PolicyContext.getContext( SUBJECT_CONTEXT_KEY );
 				}
 			};
 
 			public Subject getContextSubject() throws PolicyContextException {
 				try {
 					return (Subject) AccessController.doPrivileged( exAction );
 				}
 				catch (PrivilegedActionException e) {
 					Exception ex = e.getException();
 					if ( ex instanceof PolicyContextException ) {
 						throw (PolicyContextException) ex;
 					}
 					else {
 						throw new UndeclaredThrowableException( ex );
 					}
 				}
 			}
 		};
 
 		PolicyContextActions NON_PRIVILEGED = new PolicyContextActions() {
 			public Subject getContextSubject() throws PolicyContextException {
 				return (Subject) PolicyContext.getContext( SUBJECT_CONTEXT_KEY );
 			}
 		};
 
 		Subject getContextSubject() throws PolicyContextException;
 	}
 
 	static Subject getContextSubject() throws PolicyContextException {
 		if ( System.getSecurityManager() == null ) {
 			return PolicyContextActions.NON_PRIVILEGED.getContextSubject();
 		}
 		else {
 			return PolicyContextActions.PRIVILEGED.getContextSubject();
 		}
 	}
 
 	private static class SetContextID implements PrivilegedAction {
 		String contextID;
 
 		SetContextID(String contextID) {
 			this.contextID = contextID;
 		}
 
 		public Object run() {
 			String previousID = PolicyContext.getContextID();
 			PolicyContext.setContextID( contextID );
 			return previousID;
 		}
 	}
 
 	static String setContextID(String contextID) {
 		PrivilegedAction action = new SetContextID( contextID );
 		String previousID = (String) AccessController.doPrivileged( action );
 		return previousID;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreDeleteEventListener.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreDeleteEventListener.java
similarity index 67%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCPreDeleteEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreDeleteEventListener.java
index 8f59fcf1a4..955842f8d9 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreDeleteEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreDeleteEventListener.java
@@ -1,58 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
 import javax.security.jacc.EJBMethodPermission;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.event.Initializable;
-import org.hibernate.event.PreDeleteEvent;
-import org.hibernate.event.PreDeleteEventListener;
+
+import org.hibernate.event.spi.PreDeleteEvent;
+import org.hibernate.event.spi.PreDeleteEventListener;
 
 /**
  * Check security before any deletion
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
-public class JACCPreDeleteEventListener implements PreDeleteEventListener, Initializable, JACCSecurityListener {
-	private String contextID;
+public class JACCPreDeleteEventListener implements PreDeleteEventListener, JACCSecurityListener {
+	private final String contextId;
 
-	public boolean onPreDelete(PreDeleteEvent event) {
+	public JACCPreDeleteEventListener(String contextId) {
+		this.contextId = contextId;
+	}
 
-		EJBMethodPermission deletePermission = new EJBMethodPermission(
+	public boolean onPreDelete(PreDeleteEvent event) {
+		final EJBMethodPermission deletePermission = new EJBMethodPermission(
 				event.getPersister().getEntityName(),
 				HibernatePermission.DELETE,
 				null,
 				null
 		);
-
-		JACCPermissions.checkPermission( event.getEntity().getClass(), contextID, deletePermission );
-
+		JACCPermissions.checkPermission( event.getEntity().getClass(), contextId, deletePermission );
 		return false;
 	}
 
-   public void initialize(Configuration cfg){
-      contextID = cfg.getProperty(Environment.JACC_CONTEXTID);
-   }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreInsertEventListener.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreInsertEventListener.java
similarity index 67%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCPreInsertEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreInsertEventListener.java
index 6ee0ffcfa3..b05a73cfd7 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreInsertEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreInsertEventListener.java
@@ -1,59 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
 import javax.security.jacc.EJBMethodPermission;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.event.Initializable;
-import org.hibernate.event.PreInsertEvent;
-import org.hibernate.event.PreInsertEventListener;
+
+import org.hibernate.event.spi.PreInsertEvent;
+import org.hibernate.event.spi.PreInsertEventListener;
 
 /**
  * Check security before an insertion
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
-public class JACCPreInsertEventListener implements PreInsertEventListener, Initializable, JACCSecurityListener {
-	private String contextID;
+public class JACCPreInsertEventListener implements PreInsertEventListener, JACCSecurityListener {
+	private final String contextId;
 
-	public boolean onPreInsert(PreInsertEvent event) {
+	public JACCPreInsertEventListener(String contextId) {
+		this.contextId = contextId;
+	}
 
-		EJBMethodPermission insertPermission = new EJBMethodPermission(
+	public boolean onPreInsert(PreInsertEvent event) {
+		final EJBMethodPermission insertPermission = new EJBMethodPermission(
 				event.getPersister().getEntityName(),
 				HibernatePermission.INSERT,
 				null,
 				null
 		);
-
-		JACCPermissions.checkPermission( event.getEntity().getClass(), contextID, insertPermission );
-
+		JACCPermissions.checkPermission( event.getEntity().getClass(), contextId, insertPermission );
 		return false;
 	}
-
-
-   public void initialize(Configuration cfg){
-      contextID = cfg.getProperty(Environment.JACC_CONTEXTID);
-   }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreLoadEventListener.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreLoadEventListener.java
similarity index 66%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCPreLoadEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreLoadEventListener.java
index 26bfe0115a..51423314a6 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreLoadEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreLoadEventListener.java
@@ -1,59 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
 import javax.security.jacc.EJBMethodPermission;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.event.Initializable;
-import org.hibernate.event.PreLoadEvent;
-import org.hibernate.event.PreLoadEventListener;
+
+import org.hibernate.event.spi.PreLoadEvent;
+import org.hibernate.event.spi.PreLoadEventListener;
 
 /**
  * Check security before any load
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
- * @version $Revision: 8702 $
  */
-public class JACCPreLoadEventListener implements PreLoadEventListener, Initializable, JACCSecurityListener {
-	private String contextID;
+public class JACCPreLoadEventListener implements PreLoadEventListener, JACCSecurityListener {
+	private final String contextId;
 
-	public void onPreLoad(PreLoadEvent event) {
+	public JACCPreLoadEventListener(String contextId) {
+		this.contextId = contextId;
+	}
 
-		EJBMethodPermission loadPermission = new EJBMethodPermission(
+	public void onPreLoad(PreLoadEvent event) {
+		final EJBMethodPermission loadPermission = new EJBMethodPermission(
 				event.getPersister().getEntityName(),
 				HibernatePermission.READ,
 				null,
 				null
 		);
-
-		JACCPermissions.checkPermission( event.getEntity().getClass(), contextID, loadPermission );
-
+		JACCPermissions.checkPermission( event.getEntity().getClass(), contextId, loadPermission );
 	}
-
-
-   public void initialize(Configuration cfg){
-      contextID = cfg.getProperty(Environment.JACC_CONTEXTID);
-   }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreUpdateEventListener.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreUpdateEventListener.java
similarity index 66%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCPreUpdateEventListener.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreUpdateEventListener.java
index a88a764df2..f7e9d73303 100755
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCPreUpdateEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCPreUpdateEventListener.java
@@ -1,60 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
+package org.hibernate.secure.internal;
+
 import javax.security.jacc.EJBMethodPermission;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.cfg.Environment;
-import org.hibernate.event.Initializable;
-import org.hibernate.event.PreUpdateEvent;
-import org.hibernate.event.PreUpdateEventListener;
+
+import org.hibernate.event.spi.PreUpdateEvent;
+import org.hibernate.event.spi.PreUpdateEventListener;
 
 /**
  * Check security before any update
  *
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
- * @version $Revision: 8702 $
  */
-public class JACCPreUpdateEventListener implements PreUpdateEventListener, Initializable, JACCSecurityListener {
-	private String contextID;
+public class JACCPreUpdateEventListener implements PreUpdateEventListener, JACCSecurityListener {
+	private final String contextId;
 
-	public boolean onPreUpdate(PreUpdateEvent event) {
+	public JACCPreUpdateEventListener(String contextId) {
+		this.contextId = contextId;
+	}
 
-		EJBMethodPermission updatePermission = new EJBMethodPermission(
+	public boolean onPreUpdate(PreUpdateEvent event) {
+		final EJBMethodPermission updatePermission = new EJBMethodPermission(
 				event.getPersister().getEntityName(),
 				HibernatePermission.UPDATE,
 				null,
 				null
 		);
-
-		JACCPermissions.checkPermission( event.getEntity().getClass(), contextID, updatePermission );
-
+		JACCPermissions.checkPermission( event.getEntity().getClass(), contextId, updatePermission );
 		return false;
 	}
-
-
-   public void initialize(Configuration cfg){
-      contextID = cfg.getProperty(Environment.JACC_CONTEXTID);
-   }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/JACCSecurityListener.java b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCSecurityListener.java
similarity index 81%
rename from hibernate-core/src/main/java/org/hibernate/secure/JACCSecurityListener.java
rename to hibernate-core/src/main/java/org/hibernate/secure/internal/JACCSecurityListener.java
index 31ef8cbfb5..90b9871790 100644
--- a/hibernate-core/src/main/java/org/hibernate/secure/JACCSecurityListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/internal/JACCSecurityListener.java
@@ -1,36 +1,32 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
-package org.hibernate.secure;
-
+package org.hibernate.secure.internal;
 
 /**
  * Marker interface for JACC event listeners
  * 
  * @author <a href="kabir.khan@jboss.com">Kabir Khan</a>
- * @version $Revision: 8702 $
  */
-public interface JACCSecurityListener{
-
+public interface JACCSecurityListener {
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
index b281c892c0..456f7f93ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
@@ -1,686 +1,686 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.event.spi.PersistEvent;
+import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PersistEvent;
-import org.hibernate.event.PersistEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.id.Assigned;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.StandardProperty;
 import org.hibernate.tuple.VersionProperty;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 
 /**
  * Support for tuplizers relating to entities.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public abstract class AbstractEntityTuplizer implements EntityTuplizer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractEntityTuplizer.class.getName()
 	);
 
 	//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!
 
 	private final EntityMetamodel entityMetamodel;
 
 	private final Getter idGetter;
 	private final Setter idSetter;
 
 	protected final Getter[] getters;
 	protected final Setter[] setters;
 	protected final int propertySpan;
 	protected final boolean hasCustomAccessors;
 	private final Instantiator instantiator;
 	private final ProxyFactory proxyFactory;
 	private final CompositeType identifierMapperType;
 
 	public Type getIdentifierMapperType() {
 		return identifierMapperType;
 	}
 
 	/**
 	 * Build an appropriate Getter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Getter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Getter instance.
 	 */
 	protected abstract Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Setter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Setter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Setter instance.
 	 */
 	protected abstract Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Instantiator for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @return An appropriate Instantiator instance.
 	 */
 	protected abstract Instantiator buildInstantiator(PersistentClass mappingInfo);
 
 	/**
 	 * Build an appropriate ProxyFactory for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @param idGetter The constructed Getter relating to the entity's id property.
 	 * @param idSetter The constructed Setter relating to the entity's id property.
 	 * @return An appropriate ProxyFactory instance.
 	 */
 	protected abstract ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter);
 
 	/**
 	 * Constructs a new AbstractEntityTuplizer instance.
 	 *
 	 * @param entityMetamodel The "interpreted" information relating to the mapped entity.
 	 * @param mappingInfo The parsed "raw" mapping data relating to the given entity.
 	 */
 	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
 		this.entityMetamodel = entityMetamodel;
 
 		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
 			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 		}
 		else {
 			idGetter = null;
 			idSetter = null;
 		}
 
 		propertySpan = entityMetamodel.getPropertySpan();
 
         getters = new Getter[propertySpan];
 		setters = new Setter[propertySpan];
 
 		Iterator itr = mappingInfo.getPropertyClosureIterator();
 		boolean foundCustomAccessor=false;
 		int i=0;
 		while ( itr.hasNext() ) {
 			//TODO: redesign how PropertyAccessors are acquired...
 			Property property = (Property) itr.next();
 			getters[i] = buildPropertyGetter(property, mappingInfo);
 			setters[i] = buildPropertySetter(property, mappingInfo);
 			if ( !property.isBasicPropertyAccessor() ) {
 				foundCustomAccessor = true;
 			}
 			i++;
 		}
 		hasCustomAccessors = foundCustomAccessor;
 
         instantiator = buildInstantiator( mappingInfo );
 
 		if ( entityMetamodel.isLazy() ) {
 			proxyFactory = buildProxyFactory( mappingInfo, idGetter, idSetter );
 			if (proxyFactory == null) {
 				entityMetamodel.setLazy( false );
 			}
 		}
 		else {
 			proxyFactory = null;
 		}
 
 		Component mapper = mappingInfo.getIdentifierMapper();
 		if ( mapper == null ) {
 			identifierMapperType = null;
 			mappedIdentifierValueMarshaller = null;
 		}
 		else {
 			identifierMapperType = (CompositeType) mapper.getType();
 			mappedIdentifierValueMarshaller = buildMappedIdentifierValueMarshaller(
 					(ComponentType) entityMetamodel.getIdentifierProperty().getType(),
 					(ComponentType) identifierMapperType
 			);
 		}
 	}
 
 	/** Retreives the defined entity-name for the tuplized entity.
 	 *
 	 * @return The entity-name.
 	 */
 	protected String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	/**
 	 * Retrieves the defined entity-names for any subclasses defined for this
 	 * entity.
 	 *
 	 * @return Any subclass entity-names.
 	 */
 	protected Set getSubclassEntityNames() {
 		return entityMetamodel.getSubclassEntityNames();
 	}
 
 	public Serializable getIdentifier(Object entity) throws HibernateException {
 		return getIdentifier( entity, null );
 	}
 
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		final Object id;
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			id = entity;
 		}
 		else {
 			if ( idGetter == null ) {
 				if (identifierMapperType==null) {
 					throw new HibernateException( "The class has no identifier property: " + getEntityName() );
 				}
 				else {
 					id = mappedIdentifierValueMarshaller.getIdentifier( entity, getEntityMode(), session );
 				}
 			}
 			else {
                 id = idGetter.get( entity );
             }
         }
 
 		try {
 			return (Serializable) id;
 		}
 		catch ( ClassCastException cce ) {
 			StringBuffer msg = new StringBuffer( "Identifier classes must be serializable. " );
 			if ( id != null ) {
 				msg.append( id.getClass().getName() ).append( " is not serializable. " );
 			}
 			if ( cce.getMessage() != null ) {
 				msg.append( cce.getMessage() );
 			}
 			throw new ClassCastException( msg.toString() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		setIdentifier( entity, id, null );
 	}
 
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			if ( entity != id ) {
 				CompositeType copier = (CompositeType) entityMetamodel.getIdentifierProperty().getType();
 				copier.setPropertyValues( entity, copier.getPropertyValues( id, getEntityMode() ), getEntityMode() );
 			}
 		}
 		else if ( idSetter != null ) {
 			idSetter.set( entity, id, getFactory() );
 		}
 		else if ( identifierMapperType != null ) {
 			mappedIdentifierValueMarshaller.setIdentifier( entity, id, getEntityMode(), session );
 		}
 	}
 
 	private static interface MappedIdentifierValueMarshaller {
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session);
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session);
 	}
 
 	private final MappedIdentifierValueMarshaller mappedIdentifierValueMarshaller;
 
 	private static MappedIdentifierValueMarshaller buildMappedIdentifierValueMarshaller(
 			ComponentType mappedIdClassComponentType,
 			ComponentType virtualIdComponent) {
 		// so basically at this point we know we have a "mapped" composite identifier
 		// which is an awful way to say that the identifier is represented differently
 		// in the entity and in the identifier value.  The incoming value should
 		// be an instance of the mapped identifier class (@IdClass) while the incoming entity
 		// should be an instance of the entity class as defined by metamodel.
 		//
 		// However, even within that we have 2 potential scenarios:
 		//		1) @IdClass types and entity @Id property types match
 		//			- return a NormalMappedIdentifierValueMarshaller
 		//		2) They do not match
 		//			- return a IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller
 		boolean wereAllEquivalent = true;
 		// the sizes being off is a much bigger problem that should have been caught already...
 		for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 			if ( virtualIdComponent.getSubtypes()[i].isEntityType()
 					&& ! mappedIdClassComponentType.getSubtypes()[i].isEntityType() ) {
 				wereAllEquivalent = false;
 				break;
 			}
 		}
 
 		return wereAllEquivalent
 				? (MappedIdentifierValueMarshaller) new NormalMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType )
 				: (MappedIdentifierValueMarshaller) new IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType );
 	}
 
 	private static class NormalMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private NormalMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			virtualIdComponent.setPropertyValues(
 					entity,
 					mappedIdentifierType.getPropertyValues( id, session ),
 					entityMode
 			);
 		}
 	}
 
 	private static class IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			final Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			final Type[] subTypes = virtualIdComponent.getSubtypes();
 			final Type[] copierSubTypes = mappedIdentifierType.getSubtypes();
 			final int length = subTypes.length;
 			for ( int i = 0 ; i < length; i++ ) {
 				if ( propertyValues[i] == null ) {
 					throw new HibernateException( "No part of a composite identifier may be null" );
 				}
 				//JPA 2 @MapsId + @IdClass points to the pk of the entity
 				if ( subTypes[i].isAssociationType() && ! copierSubTypes[i].isAssociationType() ) {
 					// we need a session to handle this use case
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final Object subId;
 					if ( HibernateProxy.class.isInstance( propertyValues[i] ) ) {
 						subId = ( (HibernateProxy) propertyValues[i] ).getHibernateLazyInitializer().getIdentifier();
 					}
 					else {
 						EntityEntry pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 						if ( pcEntry != null ) {
 							subId = pcEntry.getId();
 						}
 						else {
                             LOG.debugf( "Performing implicit derived identity cascade" );
 							final PersistEvent event = new PersistEvent( null, propertyValues[i], (EventSource) session );
 							for ( PersistEventListener listener : persistEventListeners( session ) ) {
 								listener.onPersist( event );
 							}
 							pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 							if ( pcEntry == null || pcEntry.getId() == null ) {
 								throw new HibernateException( "Unable to process implicit derived identity cascade" );
 							}
 							else {
 								subId = pcEntry.getId();
 							}
 						}
 					}
 					propertyValues[i] = subId;
 				}
 			}
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			final Object[] extractedValues = mappedIdentifierType.getPropertyValues( id, entityMode );
 			final Object[] injectionValues = new Object[ extractedValues.length ];
 			for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 				final Type virtualPropertyType = virtualIdComponent.getSubtypes()[i];
 				final Type idClassPropertyType = mappedIdentifierType.getSubtypes()[i];
 				if ( virtualPropertyType.isEntityType() && ! idClassPropertyType.isEntityType() ) {
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final String associatedEntityName = ( (EntityType) virtualPropertyType ).getAssociatedEntityName();
 					final EntityKey entityKey = session.generateEntityKey(
 							(Serializable) extractedValues[i],
 							session.getFactory().getEntityPersister( associatedEntityName )
 					);
 					// it is conceivable there is a proxy, so check that first
 					Object association = session.getPersistenceContext().getProxy( entityKey );
 					if ( association == null ) {
 						// otherwise look for an initialized version
 						association = session.getPersistenceContext().getEntity( entityKey );
 					}
 					injectionValues[i] = association;
 				}
 				else {
 					injectionValues[i] = extractedValues[i];
 				}
 			}
 			virtualIdComponent.setPropertyValues( entity, injectionValues, session.getEntityMode() );
 		}
 	}
 
 	private static Iterable<PersistEventListener> persistEventListeners(SessionImplementor session) {
 		return session
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( EventType.PERSIST )
 				.listeners();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion) {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void resetIdentifier(
 			Object entity,
 			Serializable currentId,
 			Object currentVersion,
 			SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().getIdentifierGenerator() instanceof Assigned ) {
 		}
 		else {
 			//reset the id
 			Serializable result = entityMetamodel.getIdentifierProperty()
 					.getUnsavedValue()
 					.getDefaultValue( currentId );
 			setIdentifier( entity, result, session );
 			//reset the version
 			VersionProperty versionProperty = entityMetamodel.getVersionProperty();
 			if ( entityMetamodel.isVersioned() ) {
 				setPropertyValue(
 				        entity,
 				        entityMetamodel.getVersionPropertyIndex(),
 						versionProperty.getUnsavedValue().getDefaultValue( currentVersion )
 				);
 			}
 		}
 	}
 
 	public Object getVersion(Object entity) throws HibernateException {
 		if ( !entityMetamodel.isVersioned() ) return null;
 		return getters[ entityMetamodel.getVersionPropertyIndex() ].get( entity );
 	}
 
 	protected boolean shouldGetAllProperties(Object entity) {
 		return !hasUninitializedLazyProperties( entity );
 	}
 
 	public Object[] getPropertyValues(Object entity) throws HibernateException {
 		boolean getAll = shouldGetAllProperties( entity );
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			StandardProperty property = entityMetamodel.getProperties()[j];
 			if ( getAll || !property.isLazy() ) {
 				result[j] = getters[j].get( entity );
 			}
 			else {
 				result[j] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 			}
 		}
 		return result;
 	}
 
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 	throws HibernateException {
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			result[j] = getters[j].getForInsert( entity, mergeMap, session );
 		}
 		return result;
 	}
 
 	public Object getPropertyValue(Object entity, int i) throws HibernateException {
 		return getters[i].get( entity );
 	}
 
 	public Object getPropertyValue(Object entity, String propertyPath) throws HibernateException {
 		int loc = propertyPath.indexOf('.');
 		String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		//final int index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		Integer index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		if (index == null) {
 			propertyPath = "_identifierMapper." + propertyPath;
 			loc = propertyPath.indexOf('.');
 			basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		}
 		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		final Object baseValue = getPropertyValue( entity, index.intValue() );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) entityMetamodel.getPropertyTypes()[index.intValue()],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 	}
 
 	/**
 	 * Extract a component property value.
 	 *
 	 * @param type The component property types.
 	 * @param component The component instance itself.
 	 * @param propertyPath The property path for the property to be extracted.
 	 * @return The property value extracted.
 	 */
 	protected Object getComponentValue(ComponentType type, Object component, String propertyPath) {
 		final int loc = propertyPath.indexOf( '.' );
 		final String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		final int index = findSubPropertyIndex( type, basePropertyName );
 		final Object baseValue = type.getPropertyValue( component, index, getEntityMode() );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) type.getSubtypes()[index],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 
 	}
 
 	private int findSubPropertyIndex(ComponentType type, String subPropertyName) {
 		final String[] propertyNames = type.getPropertyNames();
 		for ( int index = 0; index<propertyNames.length; index++ ) {
 			if ( subPropertyName.equals( propertyNames[index] ) ) {
 				return index;
 			}
 		}
 		throw new MappingException( "component property not found: " + subPropertyName );
 	}
 
 	public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		boolean setAll = !entityMetamodel.hasLazyProperties();
 
 		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
 			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 				setters[j].set( entity, values[j], getFactory() );
 			}
 		}
 	}
 
 	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException {
 		setters[i].set( entity, value, getFactory() );
 	}
 
 	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException {
 		setters[ entityMetamodel.getPropertyIndex( propertyName ) ].set( entity, value, getFactory() );
 	}
 
 	public final Object instantiate(Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		return instantiate( id, null );
 	}
 
 	public final Object instantiate(Serializable id, SessionImplementor session) {
 		Object result = getInstantiator().instantiate( id );
 		if ( id != null ) {
 			setIdentifier( result, id, session );
 		}
 		return result;
 	}
 
 	public final Object instantiate() throws HibernateException {
 		return instantiate( null, null );
 	}
 
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {}
 
 	public boolean hasUninitializedLazyProperties(Object entity) {
 		// the default is to simply not lazy fetch properties for now...
 		return false;
 	}
 
 	public final boolean isInstance(Object object) {
         return getInstantiator().isInstance( object );
 	}
 
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	public final Object createProxy(Serializable id, SessionImplementor session)
 	throws HibernateException {
 		return getProxyFactory().getProxy( id, session );
 	}
 
 	public boolean isLifecycleImplementor() {
 		return false;
 	}
 
 	protected final EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	protected final SessionFactoryImplementor getFactory() {
 		return entityMetamodel.getSessionFactory();
 	}
 
 	protected final Instantiator getInstantiator() {
 		return instantiator;
 	}
 
 	protected final ProxyFactory getProxyFactory() {
 		return proxyFactory;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getEntityMetamodel().getName() + ')';
 	}
 
 	public Getter getIdentifierGetter() {
 		return idGetter;
 	}
 
 	public Getter getVersionGetter() {
 		if ( getEntityMetamodel().isVersioned() ) {
 			return getGetter( getEntityMetamodel().getVersionPropertyIndex() );
 		}
 		return null;
 	}
 
 	public Getter getGetter(int i) {
 		return getters[i];
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/AbstractCollectionEventTest.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/AbstractCollectionEventTest.java
index df7dba41c3..aea19a5e65 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/AbstractCollectionEventTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/AbstractCollectionEventTest.java
@@ -1,806 +1,806 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection;
 
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.collection.internal.PersistentSet;
-import org.hibernate.event.AbstractCollectionEvent;
+import org.hibernate.event.spi.AbstractCollectionEvent;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.test.event.collection.association.bidirectional.manytomany.ChildWithBidirectionalManyToMany;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * @author Gail Badner
  */
 public abstract class AbstractCollectionEventTest extends BaseCoreFunctionalTestCase {
 	@Override
 	protected void cleanupTest() {
 		ParentWithCollection dummyParent = createParent( "dummyParent" );
 		dummyParent.newChildren( createCollection() );
 		Child dummyChild = dummyParent.addChild( "dummyChild" );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		List children = s.createCriteria( dummyChild.getClass() ).list();
 		List parents = s.createCriteria( dummyParent.getClass() ).list();
 		for ( Iterator it = parents.iterator(); it.hasNext(); ) {
 			ParentWithCollection parent = ( ParentWithCollection ) it.next();
 			parent.clearChildren();
 			s.delete( parent );
 		}
 		for ( Iterator it = children.iterator(); it.hasNext(); ) {
 			s.delete( it.next() );
 		}
 		tx.commit();
 		s.close();
 	}
 
 	public abstract ParentWithCollection createParent(String name);
 
 	public abstract Collection createCollection();
 
 	@Test
 	public void testSaveParentEmptyChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		assertEquals( 0, parent.getChildren().size() );
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		tx.commit();
 		s.close();
 		assertNotNull( parent.getChildren() );
 		checkNumberOfResults( listeners, 0 );
 	}
 
 	@Test
 	public void testSaveParentOneChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentNullToOneChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNullChildren( "parent" );
 		listeners.clear();
 		assertNull( parent.getChildren() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		assertNotNull( parent.getChildren() );
 		Child newChild = parent.addChild( "new" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( newChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentNoneToOneChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Child newChild = parent.addChild( "new" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( newChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneToTwoChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Child newChild = parent.addChild( "new2" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( newChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneToTwoSameChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		parent.addChild( child );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		ChildWithBidirectionalManyToMany childWithManyToMany = null;
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			childWithManyToMany = ( ChildWithBidirectionalManyToMany ) child;
 			if ( ( ( PersistentCollection ) childWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), childWithManyToMany, index++ );
 			}
 		}
 		if ( !( parent.getChildren() instanceof PersistentSet ) ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		}
 		if ( childWithManyToMany != null && !( childWithManyToMany.getParents() instanceof PersistentSet ) ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), childWithManyToMany, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), childWithManyToMany, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentNullToOneChildDiffCollection() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNullChildren( "parent" );
 		listeners.clear();
 		assertNull( parent.getChildren() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Collection collectionOrig = parent.getChildren();
 		parent.newChildren( createCollection() );
 		Child newChild = parent.addChild( "new" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) collectionOrig ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, collectionOrig, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, collectionOrig, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, collectionOrig, index++ );
 		if ( newChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentNoneToOneChildDiffCollection() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( createCollection() );
 		Child newChild = parent.addChild( "new" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( newChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneChildDiffCollectionSameChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		assertEquals( 1, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child).getId() );
 		}
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( createCollection() );
 		parent.addChild( child );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			ChildWithBidirectionalManyToMany childWithManyToMany = ( ChildWithBidirectionalManyToMany ) child;
 			if ( ( ( PersistentCollection ) childWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), childWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			// hmmm, the same parent was removed and re-added to the child's collection;
 			// should this be considered an update?
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneChildDiffCollectionDiffChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		assertEquals( 1, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( oldChild instanceof Entity ) {
 			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( Entity ) oldChild).getId() );
 		}
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( createCollection() );
 		Child newChild = parent.addChild( "new1" );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( (PersistentCollection) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			ChildWithBidirectionalManyToMany oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneChildToNoneByRemove() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		parent.removeChild( child );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			ChildWithBidirectionalManyToMany childWithManyToMany = ( ChildWithBidirectionalManyToMany ) child;
 			if ( ( ( PersistentCollection ) childWithManyToMany.getParents( ) ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), childWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentOneChildToNoneByClear() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		parent.clearChildren();
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			ChildWithBidirectionalManyToMany childWithManyToMany = ( ChildWithBidirectionalManyToMany ) child;
 			if ( ( ( PersistentCollection ) childWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), childWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testUpdateParentTwoChildrenToOne() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		parent.addChild( "new" );
 		tx.commit();
 		s.close();
 		listeners.clear();
 		s = openSession();
 		tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( oldChild instanceof Entity ) {
 			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( Entity ) oldChild ).getId() );
 		}
 		parent.removeChild( oldChild );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			ChildWithBidirectionalManyToMany oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testDeleteParentWithNullChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNullChildren( "parent" );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		s.delete( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testDeleteParentWithNoChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		s.delete( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testDeleteParentAndChild() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		parent.removeChild( child );
 		if ( child instanceof Entity ) {
 			s.delete( child );
 		}
 		s.delete( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionRemoveListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionRemoveListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testMoveChildToDifferentParent() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		ParentWithCollection otherParent = createParentWithOneChild( "otherParent", "otherChild" );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		otherParent = ( ParentWithCollection ) s.get( otherParent.getClass(), otherParent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		parent.removeChild( child );
 		otherParent.addChild( child );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		if ( ( ( PersistentCollection ) otherParent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), otherParent, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), otherParent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), otherParent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testMoveAllChildrenToDifferentParent() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		ParentWithCollection otherParent = createParentWithOneChild( "otherParent", "otherChild" );
 		Child child = ( Child ) parent.getChildren().iterator().next();
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		otherParent = ( ParentWithCollection ) s.get( otherParent.getClass(), otherParent.getId() );
 		if ( child instanceof Entity ) {
 			child = ( Child ) s.get( child.getClass(), ( ( Entity ) child ).getId() );
 		}
 		otherParent.addAllChildren( parent.getChildren() );
 		parent.clearChildren();
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) parent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, index++ );
 		}
 		if ( ( ( PersistentCollection ) otherParent.getChildren() ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), otherParent, index++ );
 		}
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPreCollectionUpdateListener(), otherParent, index++ );
 		checkResult( listeners, listeners.getPostCollectionUpdateListener(), otherParent, index++ );
 		if ( child instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) child, index++ );
 		}
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testMoveCollectionToDifferentParent() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		ParentWithCollection otherParent = createParentWithOneChild( "otherParent", "otherChild" );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		otherParent = ( ParentWithCollection ) s.get( otherParent.getClass(), otherParent.getId() );
 		Collection otherCollectionOrig = otherParent.getChildren();
 		otherParent.newChildren( parent.getChildren() );
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		Child otherChildOrig = null;
 		if ( ( ( PersistentCollection ) otherCollectionOrig ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), otherParent, otherCollectionOrig, index++ );
 			otherChildOrig = ( Child ) otherCollectionOrig.iterator().next();
 			if ( otherChildOrig instanceof ChildWithBidirectionalManyToMany ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getInitializeCollectionListener(), parent, otherParent.getChildren(), index++ );
 		Child otherChild = ( Child ) otherParent.getChildren().iterator().next();
 		if ( otherChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) otherChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, otherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, otherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), otherParent, otherCollectionOrig, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), otherParent, otherCollectionOrig, index++ );
 		if ( otherChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), otherParent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), otherParent, index++ );
 		// there should also be pre- and post-recreate collection events for parent, but thats broken now;
 		// this is covered in BrokenCollectionEventTest
 		checkNumberOfResults( listeners, index );
 	}
 
 	@Test
 	public void testMoveCollectionToDifferentParentFlushMoveToDifferentParent() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		ParentWithCollection otherParent = createParentWithOneChild( "otherParent", "otherChild" );
 		ParentWithCollection otherOtherParent = createParentWithNoChildren( "otherParent" );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		otherParent = ( ParentWithCollection ) s.get( otherParent.getClass(), otherParent.getId() );
 		otherOtherParent = ( ParentWithCollection ) s.get( otherOtherParent.getClass(), otherOtherParent.getId() );
 		Collection otherCollectionOrig = otherParent.getChildren();
 		Collection otherOtherCollectionOrig = otherOtherParent.getChildren();
 		otherParent.newChildren( parent.getChildren() );
 		parent.newChildren( null );
 		s.flush();
 		otherOtherParent.newChildren( otherParent.getChildren() );
 		otherParent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		Child otherChildOrig = null;
 		if ( ( ( PersistentCollection ) otherCollectionOrig ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), otherParent, otherCollectionOrig, index++ );
 			otherChildOrig = ( Child ) otherCollectionOrig.iterator().next();
 			if ( otherChildOrig instanceof ChildWithBidirectionalManyToMany ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getInitializeCollectionListener(), parent, otherOtherParent.getChildren(), index++ );
 		Child otherOtherChild = ( Child ) otherOtherParent.getChildren().iterator().next();
 		if ( otherOtherChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), ( ChildWithBidirectionalManyToMany ) otherOtherChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, otherOtherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, otherOtherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), otherParent, otherCollectionOrig, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), otherParent, otherCollectionOrig, index++ );
 		if ( otherOtherChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherChildOrig, index++ );
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherOtherChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherOtherChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), otherParent, otherOtherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), otherParent, otherOtherParent.getChildren(), index++ );
 		if ( ( ( PersistentCollection ) otherOtherCollectionOrig ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), otherOtherParent, otherOtherCollectionOrig, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), otherParent, otherOtherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), otherParent, otherOtherParent.getChildren(), index++ );
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), otherOtherParent, otherOtherCollectionOrig, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), otherOtherParent, otherOtherCollectionOrig, index++ );
 		if ( otherOtherChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherOtherChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) otherOtherChild, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), otherOtherParent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), otherOtherParent, index++ );
 		// there should also be pre- and post-recreate collection events for parent, and otherParent
 		// but thats broken now; this is covered in BrokenCollectionEventTest
 		checkNumberOfResults( listeners, index );
 	}
 
 	protected ParentWithCollection createParentWithNullChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	protected ParentWithCollection createParentWithNoChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.newChildren( createCollection() );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	protected ParentWithCollection createParentWithOneChild(String parentName, String ChildName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.newChildren( createCollection() );
 		parent.addChild( ChildName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ParentWithCollection parent,
 							 int index) {
 		checkResult( listeners, listenerExpected, parent, parent.getChildren(), index );
 	}
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ChildWithBidirectionalManyToMany child,
 							 int index) {
 		checkResult( listeners, listenerExpected, child, child.getParents(), index );
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 Entity ownerExpected,
 							 Collection collExpected,
 							 int index) {
 		assertSame( listenerExpected, listeners.getListenersCalled().get( index ) );
 		assertSame(
 				ownerExpected,
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerOrNull()
 		);
 		assertEquals(
 				ownerExpected.getId(),
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerIdOrNull()
 		);
 		assertEquals(
 				ownerExpected.getClass().getName(),
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerEntityName()
 		);
 		assertSame(
-				collExpected, ( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getCollection()
+				collExpected, ( (AbstractCollectionEvent) listeners.getEvents().get( index ) ).getCollection()
 		);
 	}
 
 	protected void checkNumberOfResults(CollectionListeners listeners, int nEventsExpected) {
 		assertEquals( nEventsExpected, listeners.getListenersCalled().size() );
 		assertEquals( nEventsExpected, listeners.getEvents().size() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
index 2aa7df5dcc..7bc1c47a80 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
@@ -1,338 +1,338 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.collection.spi.PersistentCollection;
-import org.hibernate.event.AbstractCollectionEvent;
+import org.hibernate.event.spi.AbstractCollectionEvent;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.test.event.collection.association.bidirectional.manytomany.ChildWithBidirectionalManyToMany;
 import org.hibernate.test.event.collection.association.unidirectional.ParentWithCollectionOfEntities;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * These tests are known to fail. When the functionality is corrected, the
  * corresponding method will be moved into AbstractCollectionEventTest.
  *
  * @author Gail Badner
  */
 public class BrokenCollectionEventTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "event/collection/association/unidirectional/onetomany/UnidirectionalOneToManySetMapping.hbm.xml" };
 	}
 
 	@Override
 	protected void cleanupTest() {
 		ParentWithCollection dummyParent = createParent( "dummyParent" );
 		dummyParent.setChildren( createCollection() );
 		Child dummyChild = dummyParent.addChild( "dummyChild" );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		List children = s.createCriteria( dummyChild.getClass() ).list();
 		List parents = s.createCriteria( dummyParent.getClass() ).list();
 		for ( Iterator it = parents.iterator(); it.hasNext(); ) {
 			ParentWithCollection parent = ( ParentWithCollection ) it.next();
 			parent.clearChildren();
 			s.delete( parent );
 		}
 		for ( Iterator it = children.iterator(); it.hasNext(); ) {
 			s.delete( it.next() );
 		}
 		tx.commit();
 		s.close();
 	}
 
 	public ParentWithCollection createParent(String name) {
 		return new ParentWithCollectionOfEntities( name );
 	}
 
 	public Collection createCollection() {
 		return new HashSet();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testUpdateDetachedParentNoChildrenToNull() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		s.update( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	// The following fails for the same reason as testUpdateDetachedParentNoChildrenToNullFailureExpected
 	// When that issue is fixed, this one should also be fixed and moved into AbstractCollectionEventTest.
 	/*
 	public void testUpdateDetachedParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		s.update( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 	*/
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testSaveParentNullChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNullChildren( "parent" );
 		assertNull( parent.getChildren() );
 		int index = 0;
 		// pre- and post- collection recreate events should be created when creating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		tx.commit();
 		s.close();
 		assertNotNull( parent.getChildren() );
 		checkNumberOfResults( listeners, 0 );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testUpdateParentNoChildrenToNull() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( (PersistentCollection) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 
 	// The following two tests fail for the same reason as testUpdateParentNoChildrenToNullFailureExpected
 	// When that issue is fixed, this one should also be fixed and moved into AbstractCollectionEventTest.
 	/*
 	public void testUpdateParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( AbstractParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( oldChild instanceof ChildEntity ) {
 			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( ChildEntity ) oldChild ).getId() );
 		}
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		ChildWithBidirectionalManyToMany oldChildWithManyToMany = null;
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChildWithManyToMany != null ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	public void testUpdateMergedParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( AbstractParentWithCollection ) s.merge( parent );
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		Child oldChild = ( Child ) oldCollection.iterator().next();
 		ChildWithBidirectionalManyToMany oldChildWithManyToMany = null;
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 		}
 			checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChildWithManyToMany != null ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}	
 	*/
 
 	private ParentWithCollection createParentWithNullChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	private ParentWithCollection createParentWithNoChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.setChildren( createCollection() );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	private ParentWithCollection createParentWithOneChild(String parentName, String ChildName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.setChildren( createCollection() );
 		parent.addChild( ChildName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ParentWithCollection parent,
 							 int index) {
 		checkResult( listeners, listenerExpected, parent, parent.getChildren(), index );
 	}
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ChildWithBidirectionalManyToMany child,
 							 int index) {
 		checkResult( listeners, listenerExpected, child, child.getParents(), index );
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 Entity ownerExpected,
 							 Collection collExpected,
 							 int index) {
 		assertSame( listenerExpected, listeners.getListenersCalled().get( index ) );
 		assertSame(
 				ownerExpected,
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerOrNull()
 		);
 		assertEquals(
 				ownerExpected.getId(),
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerIdOrNull()
 		);
 		assertEquals(
 				ownerExpected.getClass().getName(),
-				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerEntityName()
+				( (AbstractCollectionEvent) listeners.getEvents().get( index ) ).getAffectedOwnerEntityName()
 		);
 		assertSame(
 				collExpected, ( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getCollection()
 		);
 	}
 
 	private void checkNumberOfResults(CollectionListeners listeners, int nEventsExpected) {
 		assertEquals( nEventsExpected, listeners.getListenersCalled().size() );
 		assertEquals( nEventsExpected, listeners.getEvents().size() );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/CollectionListeners.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/CollectionListeners.java
index 03c233bc38..f0e27b2007 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/CollectionListeners.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/CollectionListeners.java
@@ -1,207 +1,207 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.SessionFactory;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.AbstractCollectionEvent;
-import org.hibernate.event.EventType;
-import org.hibernate.event.InitializeCollectionEvent;
-import org.hibernate.event.PostCollectionRecreateEvent;
-import org.hibernate.event.PostCollectionRecreateEventListener;
-import org.hibernate.event.PostCollectionRemoveEvent;
-import org.hibernate.event.PostCollectionRemoveEventListener;
-import org.hibernate.event.PostCollectionUpdateEvent;
-import org.hibernate.event.PostCollectionUpdateEventListener;
-import org.hibernate.event.PreCollectionRecreateEvent;
-import org.hibernate.event.PreCollectionRecreateEventListener;
-import org.hibernate.event.PreCollectionRemoveEvent;
-import org.hibernate.event.PreCollectionRemoveEventListener;
-import org.hibernate.event.PreCollectionUpdateEvent;
-import org.hibernate.event.PreCollectionUpdateEventListener;
-import org.hibernate.event.def.DefaultInitializeCollectionEventListener;
+import org.hibernate.event.spi.AbstractCollectionEvent;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.InitializeCollectionEvent;
+import org.hibernate.event.spi.PostCollectionRecreateEvent;
+import org.hibernate.event.spi.PostCollectionRecreateEventListener;
+import org.hibernate.event.spi.PostCollectionRemoveEvent;
+import org.hibernate.event.spi.PostCollectionRemoveEventListener;
+import org.hibernate.event.spi.PostCollectionUpdateEvent;
+import org.hibernate.event.spi.PostCollectionUpdateEventListener;
+import org.hibernate.event.spi.PreCollectionRecreateEvent;
+import org.hibernate.event.spi.PreCollectionRecreateEventListener;
+import org.hibernate.event.spi.PreCollectionRemoveEvent;
+import org.hibernate.event.spi.PreCollectionRemoveEventListener;
+import org.hibernate.event.spi.PreCollectionUpdateEvent;
+import org.hibernate.event.spi.PreCollectionUpdateEventListener;
+import org.hibernate.event.internal.DefaultInitializeCollectionEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * @author Gail Badner
  * @author Steve Ebersole
  */
 public class CollectionListeners {
 
 	public interface Listener extends Serializable {
 		void addEvent(AbstractCollectionEvent event, Listener listener);
 	}
 
 	public static abstract class AbstractListener implements Listener {
 
 		private final CollectionListeners listeners;
 
 		protected AbstractListener( CollectionListeners listeners ) {
 			this.listeners = listeners;
 		}
 
 		public void addEvent(AbstractCollectionEvent event, Listener listener) {
 			listeners.addEvent( event, listener );
 		}
 	}
 
 	public static class InitializeCollectionListener
 			extends DefaultInitializeCollectionEventListener
 			implements Listener {
 		private final CollectionListeners listeners;
 		private InitializeCollectionListener(CollectionListeners listeners) {
 			this.listeners = listeners;
 		}
 		public void onInitializeCollection(InitializeCollectionEvent event) {
 			super.onInitializeCollection( event );
 			addEvent( event, this );
 		}
 		public void addEvent(AbstractCollectionEvent event, Listener listener) {
 			listeners.addEvent( event, listener );
 		}
 	}
 
 	public static class PreCollectionRecreateListener extends AbstractListener
 			implements PreCollectionRecreateEventListener {
 		private PreCollectionRecreateListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPreRecreateCollection(PreCollectionRecreateEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	public static class PostCollectionRecreateListener extends AbstractListener
 			implements PostCollectionRecreateEventListener {
 		private PostCollectionRecreateListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPostRecreateCollection(PostCollectionRecreateEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	public static class PreCollectionRemoveListener extends AbstractListener
 			implements PreCollectionRemoveEventListener {
 		private PreCollectionRemoveListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPreRemoveCollection(PreCollectionRemoveEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	public static class PostCollectionRemoveListener extends AbstractListener
 			implements PostCollectionRemoveEventListener {
 		private PostCollectionRemoveListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPostRemoveCollection(PostCollectionRemoveEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	public static class PreCollectionUpdateListener extends AbstractListener
 			implements PreCollectionUpdateEventListener {
 		private PreCollectionUpdateListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPreUpdateCollection(PreCollectionUpdateEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	public static class PostCollectionUpdateListener extends AbstractListener
 			implements PostCollectionUpdateEventListener {
 		private PostCollectionUpdateListener(CollectionListeners listeners) {
 			super( listeners );
 		}
 		public void onPostUpdateCollection(PostCollectionUpdateEvent event) {
 			addEvent( event, this );
 		}
 	}
 
 	private final PreCollectionRecreateListener preCollectionRecreateListener;
 	private final InitializeCollectionListener initializeCollectionListener;
 	private final PreCollectionRemoveListener preCollectionRemoveListener;
 	private final PreCollectionUpdateListener preCollectionUpdateListener;
 	private final PostCollectionRecreateListener postCollectionRecreateListener;
 	private final PostCollectionRemoveListener postCollectionRemoveListener;
 	private final PostCollectionUpdateListener postCollectionUpdateListener;
 
 	private List listenersCalled = new ArrayList();
 	private List events = new ArrayList();
 
 	public CollectionListeners( SessionFactory sf) {
 		preCollectionRecreateListener = new PreCollectionRecreateListener( this );
 		initializeCollectionListener = new InitializeCollectionListener( this );
 		preCollectionRemoveListener = new PreCollectionRemoveListener( this );
 		preCollectionUpdateListener = new PreCollectionUpdateListener( this );
 		postCollectionRecreateListener = new PostCollectionRecreateListener( this );
 		postCollectionRemoveListener = new PostCollectionRemoveListener( this );
 		postCollectionUpdateListener = new PostCollectionUpdateListener( this );
 
 		EventListenerRegistry registry = ( (SessionFactoryImplementor) sf ).getServiceRegistry().getService( EventListenerRegistry.class );
 		registry.setListeners( EventType.INIT_COLLECTION, initializeCollectionListener );
 
 		registry.setListeners( EventType.PRE_COLLECTION_RECREATE, preCollectionRecreateListener );
 		registry.setListeners( EventType.POST_COLLECTION_RECREATE, postCollectionRecreateListener );
 
 		registry.setListeners( EventType.PRE_COLLECTION_REMOVE, preCollectionRemoveListener );
 		registry.setListeners( EventType.POST_COLLECTION_REMOVE, postCollectionRemoveListener );
 
 		registry.setListeners( EventType.PRE_COLLECTION_UPDATE, preCollectionUpdateListener );
 		registry.setListeners( EventType.POST_COLLECTION_UPDATE, postCollectionUpdateListener );
 	}
 
 	public void addEvent(AbstractCollectionEvent event, Listener listener) {
 		listenersCalled.add( listener );
 		events.add( event );
 	}
 
 	public List getListenersCalled() {
 		return listenersCalled;
 	}
 
 	public List getEvents() {
 		return events;
 	}
 
 	public void clear() {
 		listenersCalled.clear();
 		events.clear();
 	}
 
 	public PreCollectionRecreateListener getPreCollectionRecreateListener() { return preCollectionRecreateListener; }
 	public InitializeCollectionListener getInitializeCollectionListener() { return initializeCollectionListener; }
 	public PreCollectionRemoveListener getPreCollectionRemoveListener() { return preCollectionRemoveListener; }
 	public PreCollectionUpdateListener getPreCollectionUpdateListener() { return preCollectionUpdateListener; }
 	public PostCollectionRecreateListener getPostCollectionRecreateListener() { return postCollectionRecreateListener; }
 	public PostCollectionRemoveListener getPostCollectionRemoveListener() { return postCollectionRemoveListener; }
 	public PostCollectionUpdateListener getPostCollectionUpdateListener() { return postCollectionUpdateListener; }
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
index ebe57db501..c3d5d28b20 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
@@ -1,135 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.events;
 
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.DeleteEvent;
-import org.hibernate.event.DeleteEventListener;
-import org.hibernate.event.Destructible;
-import org.hibernate.event.EventType;
-import org.hibernate.event.Initializable;
 import org.hibernate.event.service.spi.EventListenerRegistry;
+import org.hibernate.event.spi.DeleteEvent;
+import org.hibernate.event.spi.DeleteEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
-import org.hibernate.integrator.spi.Integrator;
 
 import org.junit.Test;
 
-import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 
 /**
  * CallbackTest implementation
  *
  * @author Steve Ebersole
  */
 public class CallbackTest extends BaseCoreFunctionalTestCase {
 	private TestingObserver observer = new TestingObserver();
 	private TestingListener listener = new TestingListener();
 
 	public String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	public void configure(Configuration cfg) {
 		cfg.setSessionFactoryObserver( observer );
 	}
 
 	@Override
 	protected void applyServices(BasicServiceRegistryImpl serviceRegistry) {
 		super.applyServices( serviceRegistry );
 		serviceRegistry.getService( IntegratorService.class ).addIntegrator(
 				new Integrator() {
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class ).setListeners(
 								EventType.DELETE, listener
 						);
+						listener.initialize( configuration );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
+						listener.cleanup();
 					}
 				}
 		);
 	}
 
 	@Test
-	@FailureExpected( jiraKey = "HHH-5913", message = "Need to figure out how to initialize/destroy event listeners now")
 	public void testCallbacks() {
 		assertEquals( "observer not notified of creation", 1, observer.creationCount );
 		assertEquals( "listener not notified of creation", 1, listener.initCount );
 
 		sessionFactory().close();
 
 		assertEquals( "observer not notified of close", 1, observer.closedCount );
 		assertEquals( "listener not notified of close", 1, listener.destoryCount );
 	}
 
 	private static class TestingObserver implements SessionFactoryObserver {
 		private int creationCount = 0;
 		private int closedCount = 0;
 
 		public void sessionFactoryCreated(SessionFactory factory) {
 			creationCount++;
 		}
 
 		public void sessionFactoryClosed(SessionFactory factory) {
 			closedCount++;
 		}
 	}
 
-	private static class TestingListener implements DeleteEventListener, Initializable, Destructible {
+	private static class TestingListener implements DeleteEventListener {
 		private int initCount = 0;
 		private int destoryCount = 0;
 
 		public void initialize(Configuration cfg) {
 			initCount++;
 		}
 
 		public void cleanup() {
 			destoryCount++;
 		}
 
 		public void onDelete(DeleteEvent event) throws HibernateException {
 		}
 
 		public void onDelete(DeleteEvent event, Set transientEntities) throws HibernateException {
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/InitializingPreUpdateEventListener.java b/hibernate-core/src/test/java/org/hibernate/test/flush/InitializingPreUpdateEventListener.java
index d005aacb4f..c23bd599fe 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/InitializingPreUpdateEventListener.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/InitializingPreUpdateEventListener.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import java.util.Collection;
 
-import org.hibernate.event.PreUpdateEvent;
-import org.hibernate.event.PreUpdateEventListener;
+import org.hibernate.event.spi.PreUpdateEvent;
+import org.hibernate.event.spi.PreUpdateEventListener;
 
 /**
  * @author Steve Ebersole
  */
 public class InitializingPreUpdateEventListener implements PreUpdateEventListener {
 	@Override
 	public boolean onPreUpdate(PreUpdateEvent event) {
         final Object entity = event.getEntity();
         final Object[] oldValues = event.getOldState();
         final String[] properties = event.getPersister().getPropertyNames();
 
         // Iterate through all fields of the updated object
         for ( int i = 0; i < properties.length; i++ ) {
             if (oldValues != null && oldValues[i] instanceof Collection ) {
                 final Collection col = (Collection) oldValues[i];
 				// force initialization of collection to illustrate HHH-2763
 				for ( Object element : col ) {
 					element.toString();
                 }
             }
         }
         return true;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
index f34353c1f5..1054d80538 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
@@ -1,103 +1,103 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.integrator.spi.Integrator;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Steve Ebersole
  */
 @TestForIssue( jiraKey = "HHH-2763" )
 public class TestCollectionInitializingDuringFlush extends BaseCoreFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { Author.class, Book.class, Publisher.class };
 	}
 
 	@Override
 	protected void applyServices(BasicServiceRegistryImpl serviceRegistry) {
 		super.applyServices( serviceRegistry );
 		serviceRegistry.getService( IntegratorService.class ).addIntegrator(
 				new Integrator() {
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class )
 								.getEventListenerGroup( EventType.PRE_UPDATE )
 								.appendListener( new InitializingPreUpdateEventListener() );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "HHH-2763" )
 	public void testInitializationDuringFlush() {
 		Session s = openSession();
 		s.beginTransaction();
 		Publisher publisher = new Publisher( "acme" );
 		Author author = new Author( "john" );
 		author.setPublisher( publisher );
 		publisher.getAuthors().add( author );
 		author.getBooks().add( new Book( "Reflections on a Wimpy Kid", author ) );
 		s.save( author );
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		publisher.setName( "random nally" );
 		s.flush();
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( author );
 		s.getTransaction().commit();
 		s.clear();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
index 560bc633c8..3d44985f8c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
@@ -1,180 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jpa;
 
 import javax.persistence.EntityNotFoundException;
 import java.io.Serializable;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.AutoFlushEventListener;
-import org.hibernate.event.EventType;
-import org.hibernate.event.FlushEntityEventListener;
-import org.hibernate.event.FlushEventListener;
-import org.hibernate.event.PersistEventListener;
-import org.hibernate.event.def.DefaultAutoFlushEventListener;
-import org.hibernate.event.def.DefaultFlushEntityEventListener;
-import org.hibernate.event.def.DefaultFlushEventListener;
-import org.hibernate.event.def.DefaultPersistEventListener;
+import org.hibernate.event.spi.AutoFlushEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.FlushEntityEventListener;
+import org.hibernate.event.spi.FlushEventListener;
+import org.hibernate.event.spi.PersistEventListener;
+import org.hibernate.event.internal.DefaultAutoFlushEventListener;
+import org.hibernate.event.internal.DefaultFlushEntityEventListener;
+import org.hibernate.event.internal.DefaultFlushEventListener;
+import org.hibernate.event.internal.DefaultPersistEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.util.collections.IdentityMap;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * An abstract test for all JPA spec related tests.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractJPATest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "jpa/Part.hbm.xml", "jpa/Item.hbm.xml", "jpa/MyEntity.hbm.xml" };
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.JPAQL_STRICT_COMPLIANCE, "true" );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "false" );
 		cfg.setEntityNotFoundDelegate( new JPAEntityNotFoundDelegate() );
 	}
 
 	@Override
 	protected void applyServices(BasicServiceRegistryImpl serviceRegistry) {
 		super.applyServices( serviceRegistry );
 		serviceRegistry.getService( IntegratorService.class ).addIntegrator(
 				new Integrator() {
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 						eventListenerRegistry.setListeners( EventType.PERSIST, buildPersistEventListeners() );
 						eventListenerRegistry.setListeners(
 								EventType.PERSIST_ONFLUSH, buildPersisOnFlushEventListeners()
 						);
 						eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, buildAutoFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH, buildFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, buildFlushEntityEventListeners() );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		// no second level caching
 		return null;
 	}
 
 
 	// mimic specific exception aspects of the JPA environment ~~~~~~~~~~~~~~~~
 
 	private static class JPAEntityNotFoundDelegate implements EntityNotFoundDelegate {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException("Unable to find " + entityName  + " with id " + id);			
 		}
 	}
 
 	// mimic specific event aspects of the JPA environment ~~~~~~~~~~~~~~~~~~~~
 
 	protected PersistEventListener[] buildPersistEventListeners() {
 		return new PersistEventListener[] { new JPAPersistEventListener() };
 	}
 
 	protected PersistEventListener[] buildPersisOnFlushEventListeners() {
 		return new PersistEventListener[] { new JPAPersistOnFlushEventListener() };
 	}
 
 	protected AutoFlushEventListener[] buildAutoFlushEventListeners() {
 		return new AutoFlushEventListener[] { JPAAutoFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEventListener[] buildFlushEventListeners() {
 		return new FlushEventListener[] { JPAFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEntityEventListener[] buildFlushEntityEventListeners() {
 		return new FlushEntityEventListener[] { new JPAFlushEntityEventListener() };
 	}
 
 	public static class JPAPersistEventListener extends DefaultPersistEventListener {
 		// overridden in JPA impl for entity callbacks...
 	}
 
 	public static class JPAPersistOnFlushEventListener extends JPAPersistEventListener {
 		@Override
         protected CascadingAction getCascadeAction() {
 			return CascadingAction.PERSIST_ON_FLUSH;
 		}
 	}
 
 	public static class JPAAutoFlushEventListener extends DefaultAutoFlushEventListener {
 		// not sure why EM code has this ...
 		public static final AutoFlushEventListener INSTANCE = new JPAAutoFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingAction.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return IdentityMap.instantiate( 10 );
 		}
 	}
 
 	public static class JPAFlushEventListener extends DefaultFlushEventListener {
 		// not sure why EM code has this ...
 		public static final FlushEventListener INSTANCE = new JPAFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingAction.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return IdentityMap.instantiate( 10 );
 		}
 	}
 
 	public static class JPAFlushEntityEventListener extends DefaultFlushEntityEventListener {
 		// in JPA, used mainly for preUpdate callbacks...
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
index b75f0a6d3c..7950354f41 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
@@ -1,198 +1,198 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.keymanytoone.bidir.component;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventType;
-import org.hibernate.event.LoadEvent;
-import org.hibernate.event.LoadEventListener;
-import org.hibernate.event.def.DefaultLoadEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.LoadEvent;
+import org.hibernate.event.spi.LoadEventListener;
+import org.hibernate.event.internal.DefaultLoadEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.integrator.spi.Integrator;
 
 import org.junit.Test;
 
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"unchecked"})
 public class EagerKeyManyToOneTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "keymanytoone/bidir/component/EagerMapping.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 	}
 
 	@Override
 	protected void applyServices(BasicServiceRegistryImpl serviceRegistry) {
 		super.applyServices( serviceRegistry );
 
 		serviceRegistry.getService( IntegratorService.class ).addIntegrator(
 				new Integrator() {
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class ).prependListeners(
 								EventType.LOAD, new CustomLoadListener()
 						);
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testSaveCascadedToKeyManyToOne() {
 		sessionFactory().getStatistics().clear();
 
 		// test cascading a save to an association with a key-many-to-one which refers to a
 		// just saved entity
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.flush();
 		assertEquals( 2, sessionFactory().getStatistics().getEntityInsertCount() );
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadingStrategies() {
 		sessionFactory().getStatistics().clear();
 
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		cust = ( Customer ) s.createQuery( "from Customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders as o join fetch o.id.customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createCriteria( Customer.class ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2277")
 	public void testLoadEntityWithEagerFetchingToKeyManyToOneReferenceBackToSelf() {
 		sessionFactory().getStatistics().clear();
 
 		// long winded method name to say that this is a test specifically for HHH-2277 ;)
 		// essentially we have a bidirectional association where one side of the
 		// association is actually part of a composite PK.
 		//
 		// The way these are mapped causes the problem because both sides
 		// are defined as eager which leads to the infinite loop; if only
 		// one side is marked as eager, then all is ok.  In other words the
 		// problem arises when both pieces of instance data are coming from
 		// the same result set.  This is because no "entry" can be placed
 		// into the persistence context for the association with the
 		// composite key because we are in the process of trying to build
 		// the composite-id instance
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		try {
 			cust = ( Customer ) s.get( Customer.class, cust.getId() );
 		}
 		catch( OverflowCondition overflow ) {
 			fail( "get()/load() caused overflow condition" );
 		}
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private static class OverflowCondition extends RuntimeException {
 	}
 
 	private static class CustomLoadListener extends DefaultLoadEventListener {
 		private int internalLoadCount = 0;
 		public void onLoad(LoadEvent event, LoadType loadType) throws HibernateException {
 			if ( LoadEventListener.INTERNAL_LOAD_EAGER.getName().equals( loadType.getName() ) ) {
 				internalLoadCount++;
 				if ( internalLoadCount > 10 ) {
 					throw new OverflowCondition();
 				}
 			}
 			super.onLoad( event, loadType );
 			internalLoadCount--;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomPersister.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomPersister.java
index b32217e5d2..883e39c84a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomPersister.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomPersister.java
@@ -1,674 +1,674 @@
 package org.hibernate.test.legacy;
 
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Hashtable;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.cache.spi.entry.UnstructuredCacheEntry;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.internal.TwoPhaseLoad;
 import org.hibernate.engine.spi.ValueInclusion;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PreLoadEvent;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.PostLoadEvent;
+import org.hibernate.event.spi.PreLoadEvent;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDHexGenerator;
 import org.hibernate.internal.util.compare.EqualsHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.sql.QuerySelect;
 import org.hibernate.sql.Select;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 public class CustomPersister implements EntityPersister {
 
 	private static final Hashtable INSTANCES = new Hashtable();
 	private static final IdentifierGenerator GENERATOR = new UUIDHexGenerator();
 
 	private SessionFactoryImplementor factory;
 
 	public CustomPersister(
 			PersistentClass model,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping mapping) {
 		this.factory = factory;
 	}
 
 	public boolean hasLazyProperties() {
 		return false;
 	}
 
 	private void checkEntityMode(EntityMode entityMode) {
 		if ( EntityMode.POJO != entityMode ) {
 			throw new IllegalArgumentException( "Unhandled EntityMode : " + entityMode );
 		}
 	}
 
 	private void checkEntityMode(SessionImplementor session) {
 		checkEntityMode( session.getEntityMode() );
 	}
 
 	public boolean isInherited() {
 		return false;
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	public Class getMappedClass() {
 		return Custom.class;
 	}
 
 	public void postInstantiate() throws MappingException {}
 
 	public String getEntityName() {
 		return Custom.class.getName();
 	}
 
 	public boolean isSubclassEntityName(String entityName) {
 		return Custom.class.getName().equals(entityName);
 	}
 
 	public boolean hasProxy() {
 		return false;
 	}
 
 	public boolean hasCollections() {
 		return false;
 	}
 
 	public boolean hasCascades() {
 		return false;
 	}
 
 	public boolean isMutable() {
 		return true;
 	}
 
 	public boolean isSelectBeforeUpdateRequired() {
 		return false;
 	}
 
 	public boolean isIdentifierAssignedByInsert() {
 		return false;
 	}
 
 	public Boolean isTransient(Object object, SessionImplementor session) {
 		return new Boolean( ( (Custom) object ).id==null );
 	}
 
 	public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session)
 	throws HibernateException {
 		return getPropertyValues( object, session.getEntityMode() );
 	}
 
 	public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 	}
 
 	public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 	}
 
 	public void retrieveGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		throw new UnsupportedOperationException();
 	}
 
 	public Class getMappedClass(EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return Custom.class;
 	}
 
 	public boolean implementsLifecycle(EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return false;
 	}
 
 	public boolean implementsValidatable(EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return false;
 	}
 
 	public Class getConcreteProxyClass(EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return Custom.class;
 	}
 
 	public void setPropertyValues(Object object, Object[] values, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		setPropertyValue( object, 0, values[0], entityMode );
 	}
 
 	public void setPropertyValue(Object object, int i, Object value, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		( (Custom) object ).setName( (String) value );
 	}
 
 	public Object[] getPropertyValues(Object object, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		Custom c = (Custom) object;
 		return new Object[] { c.getName() };
 	}
 
 	public Object getPropertyValue(Object object, int i, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		return ( (Custom) object ).getName();
 	}
 
 	public Object getPropertyValue(Object object, String propertyName, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		return ( (Custom) object ).getName();
 	}
 
 	public Serializable getIdentifier(Object object, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		return ( (Custom) object ).id;
 	}
 
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		checkEntityMode( session );
 		return ( (Custom) entity ).id;
 	}
 
 	public void setIdentifier(Object object, Serializable id, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		( (Custom) object ).id = (String) id;
 	}
 
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		checkEntityMode( session );
 		( (Custom) entity ).id = (String) id;
 	}
 
 	public Object getVersion(Object object, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		return null;
 	}
 
 	public Object instantiate(Serializable id, EntityMode entityMode) throws HibernateException {
 		checkEntityMode( entityMode );
 		return instantiate( id );
 	}
 
 	private Object instantiate(Serializable id) {
 		Custom c = new Custom();
 		c.id = (String) id;
 		return c;
 	}
 
 	public Object instantiate(Serializable id, SessionImplementor session) {
 		checkEntityMode( session );
 		return instantiate( id );
 	}
 
 	public boolean isInstance(Object object, EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return object instanceof Custom;
 	}
 
 	public boolean hasUninitializedLazyProperties(Object object, EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return false;
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		( ( Custom ) entity ).id = ( String ) currentId;
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		checkEntityMode( session );
 		( ( Custom ) entity ).id = ( String ) currentId;
 	}
 
 	public EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory, EntityMode entityMode) {
 		checkEntityMode( entityMode );
 		return this;
 	}
 
 	public int[] findDirty(
 		Object[] x,
 		Object[] y,
 		Object owner,
 		SessionImplementor session
 	) throws HibernateException {
 		if ( !EqualsHelper.equals( x[0], y[0] ) ) {
 			return new int[] { 0 };
 		}
 		else {
 			return null;
 		}
 	}
 
 	public int[] findModified(
 		Object[] x,
 		Object[] y,
 		Object owner,
 		SessionImplementor session
 	) throws HibernateException {
 		if ( !EqualsHelper.equals( x[0], y[0] ) ) {
 			return new int[] { 0 };
 		}
 		else {
 			return null;
 		}
 	}
 
 	/**
 	 * @see EntityPersister#hasIdentifierProperty()
 	 */
 	public boolean hasIdentifierProperty() {
 		return true;
 	}
 
 	/**
 	 * @see EntityPersister#isVersioned()
 	 */
 	public boolean isVersioned() {
 		return false;
 	}
 
 	/**
 	 * @see EntityPersister#getVersionType()
 	 */
 	public VersionType getVersionType() {
 		return null;
 	}
 
 	/**
 	 * @see EntityPersister#getVersionProperty()
 	 */
 	public int getVersionProperty() {
 		return 0;
 	}
 
 	/**
 	 * @see EntityPersister#getIdentifierGenerator()
 	 */
 	public IdentifierGenerator getIdentifierGenerator()
 	throws HibernateException {
 		return GENERATOR;
 	}
 
 	/**
 	 * @see EntityPersister#load(Serializable, Object, org.hibernate.LockOptions , SessionImplementor)
 	 */
 	public Object load(
 		Serializable id,
 		Object optionalObject,
 		LockOptions lockOptions,
 		SessionImplementor session
 	) throws HibernateException {
 		return load(id, optionalObject, lockOptions.getLockMode(), session);
 	}
 
 	/**
 	 * @see EntityPersister#load(Serializable, Object, LockMode, SessionImplementor)
 	 */
 	public Object load(
 		Serializable id,
 		Object optionalObject,
 		LockMode lockMode,
 		SessionImplementor session
 	) throws HibernateException {
 
 		// fails when optional object is supplied
 
 		Custom clone = null;
 		Custom obj = (Custom) INSTANCES.get(id);
 		if (obj!=null) {
 			clone = (Custom) obj.clone();
 			TwoPhaseLoad.addUninitializedEntity(
 					session.generateEntityKey( id, this ),
 					clone,
 					this,
 					LockMode.NONE,
 					false,
 					session
 				);
 			TwoPhaseLoad.postHydrate(
 					this, id,
 					new String[] { obj.getName() },
 					null,
 					clone,
 					LockMode.NONE,
 					false,
 					session
 				);
 			TwoPhaseLoad.initializeEntity(
 					clone,
 					false,
 					session,
 					new PreLoadEvent( (EventSource) session ),
 					new PostLoadEvent( (EventSource) session )
 				);
 		}
 		return clone;
 	}
 
 	/**
 	 * @see EntityPersister#lock(Serializable, Object, Object, LockMode, SessionImplementor)
 	 */
 	public void lock(
 		Serializable id,
 		Object version,
 		Object object,
 		LockOptions lockOptions,
 		SessionImplementor session
 	) throws HibernateException {
 
 		throw new UnsupportedOperationException();
 	}
 
 	/**
 	 * @see EntityPersister#lock(Serializable, Object, Object, LockMode, SessionImplementor)
 	 */
 	public void lock(
 		Serializable id,
 		Object version,
 		Object object,
 		LockMode lockMode,
 		SessionImplementor session
 	) throws HibernateException {
 
 		throw new UnsupportedOperationException();
 	}
 
 	public void insert(
 		Serializable id,
 		Object[] fields,
 		Object object,
 		SessionImplementor session
 	) throws HibernateException {
 
 		INSTANCES.put(id, ( (Custom) object ).clone() );
 	}
 
 	public Serializable insert(Object[] fields, Object object, SessionImplementor session)
 	throws HibernateException {
 
 		throw new UnsupportedOperationException();
 	}
 
 	public void delete(
 		Serializable id,
 		Object version,
 		Object object,
 		SessionImplementor session
 	) throws HibernateException {
 
 		INSTANCES.remove(id);
 	}
 
 	/**
 	 * @see EntityPersister
 	 */
 	public void update(
 		Serializable id,
 		Object[] fields,
 		int[] dirtyFields,
 		boolean hasDirtyCollection,
 		Object[] oldFields,
 		Object oldVersion,
 		Object object,
 		Object rowId,
 		SessionImplementor session
 	) throws HibernateException {
 
 		INSTANCES.put( id, ( (Custom) object ).clone() );
 
 	}
 
 	private static final Type[] TYPES = new Type[] { StandardBasicTypes.STRING };
 	private static final String[] NAMES = new String[] { "name" };
 	private static final boolean[] MUTABILITY = new boolean[] { true };
 	private static final boolean[] GENERATION = new boolean[] { false };
 
 	/**
 	 * @see EntityPersister#getPropertyTypes()
 	 */
 	public Type[] getPropertyTypes() {
 		return TYPES;
 	}
 
 	/**
 	 * @see EntityPersister#getPropertyNames()
 	 */
 	public String[] getPropertyNames() {
 		return NAMES;
 	}
 
 	/**
 	 * @see EntityPersister#getPropertyCascadeStyles()
 	 */
 	public CascadeStyle[] getPropertyCascadeStyles() {
 		return null;
 	}
 
 	/**
 	 * @see EntityPersister#getIdentifierType()
 	 */
 	public Type getIdentifierType() {
 		return StandardBasicTypes.STRING;
 	}
 
 	/**
 	 * @see EntityPersister#getIdentifierPropertyName()
 	 */
 	public String getIdentifierPropertyName() {
 		return "id";
 	}
 
 	public boolean hasCache() {
 		return false;
 	}
 
 	public EntityRegionAccessStrategy getCacheAccessStrategy() {
 		return null;
 	}
 
 	public String getRootEntityName() {
 		return "CUSTOMS";
 	}
 
 	public Serializable[] getPropertySpaces() {
 		return new String[] { "CUSTOMS" };
 	}
 
 	public Serializable[] getQuerySpaces() {
 		return new String[] { "CUSTOMS" };
 	}
 
 	/**
 	 * @see EntityPersister#getClassMetadata()
 	 */
 	public ClassMetadata getClassMetadata() {
 		return null;
 	}
 
 	public boolean[] getPropertyUpdateability() {
 		return MUTABILITY;
 	}
 
 	public boolean[] getPropertyCheckability() {
 		return MUTABILITY;
 	}
 
 	/**
 	 * @see EntityPersister#getPropertyInsertability()
 	 */
 	public boolean[] getPropertyInsertability() {
 		return MUTABILITY;
 	}
 
 	public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 		return new ValueInclusion[0];
 	}
 
 	public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 		return new ValueInclusion[0];
 	}
 
 
 	public boolean canExtractIdOutOfEntity() {
 		return true;
 	}
 
 	public boolean isBatchLoadable() {
 		return false;
 	}
 
 	public Type getPropertyType(String propertyName) {
 		throw new UnsupportedOperationException();
 	}
 
 	public Object getPropertyValue(Object object, String propertyName)
 		throws HibernateException {
 		throw new UnsupportedOperationException();
 	}
 
 	public Object createProxy(Serializable id, SessionImplementor session)
 		throws HibernateException {
 		throw new UnsupportedOperationException("no proxy for this class");
 	}
 
 	public Object getCurrentVersion(
 		Serializable id,
 		SessionImplementor session)
 		throws HibernateException {
 
 		return INSTANCES.get(id);
 	}
 
 	public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session)
 			throws HibernateException {
 		return null;
 	}
 
 	public EntityMode guessEntityMode(Object object) {
 		if ( !isInstance(object, EntityMode.POJO) ) {
 			return null;
 		}
 		else {
 			return EntityMode.POJO;
 		}
 	}
 
 	public boolean[] getPropertyNullability() {
 		return MUTABILITY;
 	}
 
 	public boolean isDynamic() {
 		return false;
 	}
 
 	public boolean isCacheInvalidationRequired() {
 		return false;
 	}
 
 	public void applyFilters(QuerySelect select, String alias, Map filters) {
 	}
 
 	public void applyFilters(Select select, String alias, Map filters) {
 	}
 
 
 	public void afterInitialize(Object entity, boolean fetched, SessionImplementor session) {
 	}
 
 	public void afterReassociate(Object entity, SessionImplementor session) {
 	}
 
 	public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session)
 	throws HibernateException {
 		return null;
 	}
 
 	public boolean[] getPropertyVersionability() {
 		return MUTABILITY;
 	}
 
 	public CacheEntryStructure getCacheEntryStructure() {
 		return new UnstructuredCacheEntry();
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return false;
 	}
 
 	public int[] getNaturalIdentifierProperties() {
 		return null;
 	}
 
 	public Type[] getNaturalIdentifierTypes() {
 		return null;
 	}
 
 	public boolean hasNaturalIdentifier() {
 		return false;
 	}
 
 	public boolean hasMutableProperties() {
 		return false;
 	}
 
 	public boolean isInstrumented(EntityMode entityMode) {
 		return false;
 	}
 
 	public boolean hasInsertGeneratedProperties() {
 		return false;
 	}
 
 	public boolean hasUpdateGeneratedProperties() {
 		return false;
 	}
 
 	public boolean[] getPropertyLaziness() {
 		return null;
 	}
 
 	public boolean isLazyPropertiesCacheable() {
 		return true;
 	}
 
 	public boolean hasGeneratedProperties() {
 		return false;
 	}
 
 	public boolean isVersionPropertyGenerated() {
 		return false;
 	}
 
 	public String[] getOrphanRemovalOneToOnePaths() {
 		return null;
 	}
 
 	public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 		return null;
 	}
 
 	public Comparator getVersionComparator() {
 		return null;
 	}
 
 	public EntityMetamodel getEntityMetamodel() {
 		return null;
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/docbook/en/modules/migrated/configuration.xml b/hibernate-entitymanager/src/main/docbook/en/modules/migrated/configuration.xml
index 54ebd4b028..6369a31766 100644
--- a/hibernate-entitymanager/src/main/docbook/en/modules/migrated/configuration.xml
+++ b/hibernate-entitymanager/src/main/docbook/en/modules/migrated/configuration.xml
@@ -1,1005 +1,1005 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
   ~ Hibernate, Relational Persistence for Idiomatic Java
   ~
   ~ Copyright (c) 2008, Red Hat Inc or third-party contributors as
   ~ indicated by the @author tags or express copyright attribution
   ~ statements applied by the authors.  All third-party contributions are
   ~ distributed under license by Red Hat Inc.
   ~
   ~ This copyrighted material is made available to anyone wishing to use, modify,
   ~ copy, or redistribute it subject to the terms and conditions of the GNU
   ~ Lesser General Public License, as published by the Free Software Foundation.
   ~
   ~ This program is distributed in the hope that it will be useful,
   ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
   ~ for more details.
   ~
   ~ You should have received a copy of the GNU Lesser General Public License
   ~ along with this distribution; if not, write to:
   ~ Free Software Foundation, Inc.
   ~ 51 Franklin Street, Fifth Floor
   ~ Boston, MA  02110-1301  USA
   -->
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
 <chapter id="configuration">
   <title id="setup">Setup and configuration</title>
 
   <section>
     <title>Setup</title>
 
     <para>The JPA 2.0 compatible Hibernate EntityManager is built on top of
     the core of Hibernate and Hibernate Annotations. Starting from version
     3.5, we have bundled in a single Hibernate distribution all the necessary
     modules:</para>
 
     <itemizedlist>
       <listitem>
         <para>Hibernate Core: the native Hibernate APIs and core engine</para>
       </listitem>
 
       <listitem>
         <para>Hibernate Annotations: the annotation-based mapping</para>
       </listitem>
 
       <listitem>
         <para>Hibernate EntityManager: the JPA 2.0 APIs and livecycle semantic
         implementation</para>
       </listitem>
     </itemizedlist>
 
     <para>Download the Hibernate Core distribution. Set up your classpath
     (after you have created a new project in your favorite IDE):<itemizedlist>
         <listitem>
           <para>Copy <filename>hibernate3.jar</filename> and the required 3rd
           party libraries available in
           <filename>lib/required</filename>.</para>
         </listitem>
 
         <listitem>
           <para>Copy
           <filename>lib/jpa/hibernate-jpa-2.0-api-1.0.0.Final.jar</filename>
           to your classpath as well.</para>
         </listitem>
       </itemizedlist></para>
 
     <note>
       <title>What is hibernate-jpa-2.0-api-x.y.z.jar?</title>
 
       <para>This is the JAR containing the JPA 2.0 API, it provides all the
       interfaces and concrete classes that the specification defines as public
       API. Said otherwise, you can use this JAR to bootstrap any JPA provider
       implementation. Note that you typically don't need it when you deploy
       your application in a Java EE 6 application server (like JBoss AS 6 for
       example).</para>
     </note>
 
     <para>Alternatively, if you use Maven, add the following
     dependencies</para>
 
     <programlisting language="XML" role="XML">&lt;project ...&gt;
   ...
   &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
       &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
       &lt;version&gt;${hibernate-core-version}&lt;/version&gt;
     &lt;/dependency&gt;
   &lt;/dependencies&gt;
 &lt;/project&gt;</programlisting>
 
     <para>All the required dependencies like hibernate-core and
     hibernate-annotations will be dragged transitively.</para>
 
     <para>We recommend you use <ulink
     url="http://validator.hibernate.org">Hibernate Validator</ulink> and the
     Bean Validation specification capabilities as its integration with Java
     Persistence 2 has been standardized. Download Hibernate Validator 4 or
     above from the Hibernate website and add
     <filename>hibernate-validator.jar</filename> and
     <filename>validation-api.jar</filename> in your classpath. Alternatively
     add the following dependency in your <filename>pom.xml</filename>.</para>
 
     <programlisting language="XML" role="XML">&lt;project&gt;
   ...
   &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
       &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
       &lt;version&gt;${hibernate-validator-version}&lt;/version&gt;
     &lt;/dependency&gt;
     ...
   &lt;/dependencies&gt;
   ...
 &lt;/project&gt;</programlisting>
 
     <para>If you wish to use <ulink
     url="http://search.hibernate.org">Hibernate Search</ulink> (full-text
     search for Hibernate aplications), download it from the Hibernate website
     and add <filename>hibernate-search.jar</filename> and its dependencies in
     your classpath. Alternatively add the following dependency in your
     <filename>pom.xml</filename>.</para>
 
     <programlisting language="XML" role="XML">&lt;project&gt;
   ...
   &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
       &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;
       &lt;version&gt;${hibernate-search-version}&lt;/version&gt;
     &lt;/dependency&gt;
     ...
   &lt;/dependencies&gt;
   ...
 &lt;/project&gt;</programlisting>
   </section>
 
   <section id="setup-configuration"
            xreflabel="Configuration and bootstrapping">
     <title>Configuration and bootstrapping</title>
 
     <section id="setup-configuration-packaging" revision="1">
       <title>Packaging</title>
 
       <para>The configuration for entity managers both inside an application
       server and in a standalone application reside in a persistence archive.
       A persistence archive is a JAR file which must define a
       <literal>persistence.xml</literal> file that resides in the
       <filename>META-INF</filename> folder. All properly annotated classes
       included in the archive (ie. having an <literal>@Entity</literal>
       annotation), all annotated packages and all Hibernate hbm.xml files
       included in the archive will be added to the persistence unit
       configuration, so by default, your persistence.xml will be quite
       minimalist:</para>
 
       <programlisting language="XML" role="XML">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
              version="2.0"&gt;
    &lt;persistence-unit name="sample"&gt;
       &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
       &lt;properties&gt;
          &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
          &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
       &lt;/properties&gt;
    &lt;/persistence-unit&gt;
 &lt;/persistence&gt;</programlisting>
 
       <para>Here's a more complete example of a
       <filename><literal>persistence.xml</literal></filename> file</para>
 
       <programlisting language="XML" role="XML">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
              version="2.0"&gt;
    &lt;persistence-unit name="manager1" transaction-type="JTA"&gt;
       &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
       &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
       &lt;mapping-file&gt;ormap.xml&lt;/mapping-file&gt;
       &lt;jar-file&gt;MyApp.jar&lt;/jar-file&gt;
       &lt;class&gt;org.acme.Employee&lt;/class&gt;
       &lt;class&gt;org.acme.Person&lt;/class&gt;
       &lt;class&gt;org.acme.Address&lt;/class&gt;
       &lt;shared-cache-mode&gt;ENABLE_SELECTOVE&lt;/shared-cache-mode&gt;
       &lt;validation-mode&gt;CALLBACK&lt;/validation-mode&gt;
       &lt;properties&gt;
          &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
          &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
       &lt;/properties&gt;
    &lt;/persistence-unit&gt;
 &lt;/persistence&gt;</programlisting>
 
       <variablelist spacing="compact">
         <varlistentry>
           <term><code>name</code></term>
 
           <listitem>
             <para>(attribute) Every entity manager must have a name.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>transaction-type</code></term>
 
           <listitem>
             <para>(attribute) Transaction type used. Either JTA or
             RESOURCE_LOCAL (default to JTA in a JavaEE environment and to
             RESOURCE_LOCAL in a JavaSE environment). When a jta-datasource is
             used, the default is JTA, if non-jta-datasource is used,
             RESOURCE_LOCAL is used.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>provider</code></term>
 
           <listitem>
             <para>The provider is a fully-qualified class name of the EJB
             Persistence provider. You do not have to define it if you don't
             work with several EJB3 implementations. This is needed when you
             are using multiple vendor implementations of EJB
             Persistence.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>jta-data-source</code>,
           <code>non-jta-data-source</code></term>
 
           <listitem>
             <para>This is the JNDI name of where the javax.sql.DataSource is
             located. When running without a JNDI available Datasource, you
             must specify JDBC connections with Hibernate specific properties
             (see below).</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>mapping-file</code></term>
 
           <listitem>
             <para>The class element specifies a EJB3 compliant XML mapping
             file that you will map. The file has to be in the classpath. As
             per the EJB3 specification, Hibernate EntityManager will try to
             load the mapping file located in the jar file at
             <literal>META_INF/orm.xml</literal>. Of course any explicit
             mapping file will be loaded too. As a matter of fact, you can
             provide any XML file in the mapping file element ie. either hbm
             files or EJB3 deployment descriptor.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>jar-file</code></term>
 
           <listitem>
             <para>The jar-file elements specifies a jar to analyse. All
             properly annotated classes, annotated packages and all hbm.xml
             files part of this jar file will be added to the persistence unit
             configuration. This element is mainly used in Java EE environment.
             Use of this one in Java SE should be considered as non portable,
             in this case a absolute url is needed. You can alternatively point
             to a directory (This is especially useful when in your test
             environment, the persistence.xml file is not under the same root
             directory or jar than your domain model).</para>
 
             <programlisting language="XML" role="XML">        &lt;jar-file&gt;file:/home/turin/work/local/lab8/build/classes&lt;/jar-file&gt;</programlisting>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>exclude-unlisted-classes</code></term>
 
           <listitem>
             <para>Do not check the main jar file for annotated classes. Only
             explicit classes will be part of the persistence unit.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>class</code></term>
 
           <listitem>
             <para>The class element specifies a fully qualified class name
             that you will map. By default all properly annotated classes and
             all hbm.xml files found inside the archive are added to the
             persistence unit configuration. You can add some external entity
             through the class element though. As an extension to the
             specification, you can add a package name in the
             <literal>&lt;class&gt;</literal> element (eg
             <code>&lt;class&gt;org.hibernate.eg&lt;/class&gt;</code>).
             Caution, the package will include the metadata defined at the
             package level (ie in <filename>package-info.java</filename>), it
             will not include all the classes of a given package.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>shared-cache-mode</term>
 
           <listitem>
             <para>By default, entities are elected for second-level cache if
             annotated with <classname>@Cacheable</classname>. You can
             however:</para>
 
             <itemizedlist>
               <listitem>
                 <para><literal>ALL</literal>: force caching for all
                 entities</para>
               </listitem>
 
               <listitem>
                 <para><literal>NONE</literal>: disable caching for all
                 entities (useful to take second-level cache out of the
                 equation)</para>
               </listitem>
 
               <listitem>
                 <para><literal>ENABLE_SELECTIVE</literal> (default): enable
                 caching when explicitly marked</para>
               </listitem>
 
               <listitem>
                 <para><literal>DISABLE_SELECTIVE</literal>: enable caching
                 unless explicitly marked as
                 <classname>@Cacheable(false)</classname> (not
                 recommended)</para>
               </listitem>
             </itemizedlist>
 
             <para>See Hibernate Annotation's documentation for more
             details.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>validation-mode</term>
 
           <listitem>
             <para>By default, Bean Validation (and Hibernate Validator) is
             activated. When an entity is created, updated (and optionally
             deleted), it is validated before being sent to the database. The
             database schema generated by Hibernate also reflects the
             constraints declared on the entity.</para>
 
             <para>You can fine-tune that if needed:</para>
 
             <itemizedlist>
               <listitem>
                 <para><literal>AUTO</literal>: if Bean Validation is present
                 in the classpath, CALLBACK and DDL are activated.</para>
               </listitem>
 
               <listitem>
                 <para><literal>CALLBACK</literal>: entities are validated on
                 creation, update and deletion. If no Bean Validation provider
                 is present, an exception is raised at initialization
                 time.</para>
               </listitem>
 
               <listitem>
                 <para><literal>DDL</literal>: (not standard, see below)
                 database schemas are entities are validated on creation,
                 update and deletion. If no Bean Validation provider is
                 present, an exception is raised at initialization time.</para>
               </listitem>
 
               <listitem>
                 <para><literal>NONE</literal>: Bean Validation is not used at
                 all</para>
               </listitem>
             </itemizedlist>
 
             <para>Unfortunately, <literal>DDL</literal> is not standard mode
             (though extremely useful) and you will not be able to put it in
             <literal>&lt;validation-mode&gt;</literal>. To use it, add a
             regular property</para>
 
             <programlisting language="XML" role="XML">&lt;property name="javax.persistence.validation.mode"&gt;
   ddl
 &lt;/property&gt;</programlisting>
 
             <para>With this approach, you can mix ddl and callback
             modes:</para>
 
             <programlisting language="XML" role="XML">&lt;property name="javax.persistence.validation.mode"&gt;
   ddl, callback
 &lt;/property&gt;</programlisting>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><code>properties</code></term>
 
           <listitem>
             <para>The properties element is used to specify vendor specific
             properties. This is where you will define your Hibernate specific
             configurations. This is also where you will have to specify JDBC
             connection information as well.</para>
 
             <para>Here is a list of JPA 2 standard properties. Be sure to also
             Hibernate Core's documentation to see Hibernate specific
             properties.</para>
 
             <itemizedlist>
               <listitem>
                 <para><literal>javax.persistence.lock.timeout</literal>
                 pessimistic lock timeout in milliseconds
                 (<classname>Integer</classname> or
                 <classname>String</classname>), this is a hint used by
                 Hibernate but requires support by your underlying
                 database.</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.query.timeout</literal> query
                 timeout in milliseconds (<classname>Integer</classname> or
                 <classname>String</classname>), this is a hint used by
                 Hibernate but requires support by your underlying database
                 (TODO is that 100% true or do we use some other
                 tricks).</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.validation.mode</literal>
                 corresponds to the <literal>validation-mode</literal> element.
                 Use it if you wish to use the non standard
                 <literal>DDL</literal> value.</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.validation.group.pre-persist</literal>
                 defines the group or list of groups to validate before
                 persisting an entity. This is a comma separated fully
                 qualified class name string (eg
                 <code>com.acme.groups.Common</code> or
                 <code>com.acme.groups.Common,
                 javax.validation.groups.Default</code>). Defaults to the Bean
                 Validation default group.</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.validation.group.pre-update</literal>
                 defines the group or list of groups to validate before
                 updating an entity. This is a comma separated fully qualified
                 class name string (eg <code>com.acme.groups.Common</code> or
                 <code>com.acme.groups.Common,
                 javax.validation.groups.Default</code>). Defaults to the Bean
                 Validation default group.</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.validation.group.pre-remove</literal>
                 defines the group or list of groups to validate before
                 persisting an entity. This is a comma separated fully
                 qualified class name string (eg
                 <code>com.acme.groups.Common</code> or
                 <code>com.acme.groups.Common,
                 javax.validation.groups.Default</code>). Defaults to no
                 group.</para>
               </listitem>
             </itemizedlist>
 
             <note>
               <para>To know more about Bean Validation and Hibernate
               Validator, check out Hibernate Validator's reference
               documentation as well as Hibernate Annotations's documentation
               on Bean Validation.</para>
             </note>
 
             <para>The following properties can only be used in a SE
             environment where no datasource/JNDI is available:</para>
 
             <itemizedlist>
               <listitem>
                 <para><literal>javax.persistence.jdbc.driver</literal>: the
                 fully qualified class name of the driver class</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.jdbc.url</literal>: the
                 driver specific URL</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.jdbc.user</literal> the user
                 name used for the database connection</para>
               </listitem>
 
               <listitem>
                 <para><literal>javax.persistence.jdbc.password</literal> the
                 password used for the database connection</para>
               </listitem>
             </itemizedlist>
           </listitem>
         </varlistentry>
       </variablelist>
 
       <para>Be sure to define the grammar definition in the
       <literal>persistence</literal> element since the JPA specification
       requires schema validation. If the <literal>systemId</literal> ends with
       <literal>persistence_2_0.xsd</literal>, Hibernate entityManager will use
       the version embedded in the hibernate-entitymanager.jar. It won't fetch
       the resource from the internet.</para>
 
       <programlisting language="XML" role="XML">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
              version="2.0"&gt;</programlisting>
     </section>
 
     <section id="setup-configuration-bootstrapping" revision="1">
       <title>Bootstrapping</title>
 
       <para>The JPA specification defines a bootstrap procedure to access the
       <classname>EntityManagerFactory</classname> and the
       <classname>EntityManager</classname>. The bootstrap class is
       <classname>javax.persistence.Persistence</classname>, e.g.</para>
 
       <programlisting language="JAVA" role="JAVA">EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1");
 
 //or
 
 Map&lt;String, Object&gt; configOverrides = new HashMap&lt;String, Object&gt;();
 configOverrides.put("hibernate.hbm2ddl.auto", "create-drop");
 EntityManagerFactory programmaticEmf =
     Persistence.createEntityManagerFactory("manager1", configOverrides);</programlisting>
 
       <para>The first version is equivalent to the second with an empty map.
       The map version is a set of overrides that will take precedence over any
       properties defined in your <filename>persistence.xml</filename> files.
       All the properties defined in <xref
       linkend="setup-configuration-packaging" /> can be passed to the
       <methodname>createEntityManagerFactory</methodname> method and there are
       a few additional ones:</para>
 
       <itemizedlist>
         <listitem>
           <para><literal>javax.persistence.provider</literal> to define the
           provider class used</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.transactionType</literal> to define
           the transaction type used (either <literal>JTA</literal> or
           <literal>RESOURCE_LOCAL</literal>)</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.jtaDataSource</literal> to define
           the JTA datasource name in JNDI</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.nonJtaDataSource</literal> to
           define the non JTA datasource name in JNDI</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.lock.timeout</literal> pessimistic
           lock timeout in milliseconds (<classname>Integer</classname> or
           <classname>String</classname>)</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.query.timeout</literal> query
           timeout in milliseconds (<classname>Integer</classname> or
           <classname>String</classname>)</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.sharedCache.mode</literal>
           corresponds to the <literal>share-cache-mode</literal> element
           defined in <xref linkend="setup-configuration-packaging" />.</para>
         </listitem>
 
         <listitem>
           <para><literal>javax.persistence.validation.mode</literal>
           corresponds to the <literal>validation-mode</literal> element
           defined in <xref linkend="setup-configuration-packaging" />.</para>
         </listitem>
       </itemizedlist>
 
       <para>When <code>Persistence.createEntityManagerFactory()</code> is
       called, the persistence implementation will search your classpath for
       any <code>META-INF/persistence.xml</code> files using the
       <code>ClassLoader.getResource("META-INF/persistence.xml")</code> method.
       Actually the <classname>Persistence</classname> class will look at all
       the Persistence Providers available in the classpath and ask each of
       them if they are responsible for the creation of the entity manager
       factory <literal>manager1</literal>. Each provider, from this list of
       resources, it will try to find an entity manager that matches the name
       you specify in the command line with what is specified in the
       persistence.xml file (of course the provider <literal>element</literal>
       must match the current persistent provider). If no persistence.xml with
       the correct name are found or if the expected persistence provider is
       not found, a <classname>PersistenceException</classname> is
       raised.</para>
 
       <para>Apart from Hibernate system-level settings, all the properties
       available in Hibernate can be set in <code>properties</code> element of
       the persistence.xml file or as an override in the map you pass to
       <code>createEntityManagerFactory()</code>. Please refer to the Hibernate
       reference documentation for a complete listing. There are however a
       couple of properties available in the EJB3 provider only.</para>
 
       <table>
         <title>Hibernate Entity Manager specific properties</title>
 
         <tgroup cols="2">
           <colspec align="left" colname="c1" />
 
           <colspec colname="c2" colwidth="2*" />
 
           <thead>
             <row>
               <entry>Property name</entry>
 
               <entry>Description</entry>
             </row>
           </thead>
 
           <tbody>
             <row>
               <entry>hibernate.ejb.classcache.&lt;classname&gt;</entry>
 
               <entry>class cache strategy [comma cache region] of the class
               Default to no cache, and default region cache to
               fully.qualified.classname (eg.
               hibernate.ejb.classcache.com.acme.Cat read-write or
               hibernate.ejb.classcache.com.acme.Cat read-write,
               MyRegion).</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.collectioncache.&lt;collectionrole&gt;</entry>
 
               <entry>collection cache strategy [comma cache region] of the
               class Default to no cache, and default region cache to
               fully.qualified.classname.role (eg.
               hibernate.ejb.classcache.com.acme.Cat read-write or
               hibernate.ejb.classcache.com.acme.Cat read-write,
               MyRegion).</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.cfgfile</entry>
 
               <entry>XML configuration file to use to configure Hibernate (eg.
               <filename>/hibernate.cfg.xml</filename>).</entry>
             </row>
 
             <row>
               <entry>hibernate.archive.autodetection</entry>
 
               <entry>Determine which element is auto discovered by Hibernate
               Entity Manager while parsing the .par archive. (default to
               <literal>class,hbm</literal>).</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.interceptor</entry>
 
               <entry>An optional Hibernate interceptor. The interceptor
               instance is shared by all <classname>Session</classname>
               instances. This interceptor has to implement
               <classname>org.hibernate.Interceptor</classname> and have a
               no-arg constructor. This property can not be combined with
               <literal>hibernate.ejb.interceptor.session_scoped</literal>.</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.interceptor.session_scoped</entry>
 
               <entry>An optional Hibernate interceptor. The interceptor
               instance is specific to a given <classname>Session</classname>
               instance (and hence can be non thread-safe). This interceptor
               has to implement
               <classname>org.hibernate.Interceptor</classname> and have a
               no-arg constructor. This property can not be combined with
               <literal>hibernate.ejb.interceptor</literal>.</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.naming_strategy</entry>
 
               <entry>An optional naming strategy. The class must have a no-arg
               constructor. The default naming strategy used is
               <classname>EJB3NamingStrategy</classname>. You also might want
               to consider the
               <classname>DefaultComponentSafeNamingStrategy</classname>.</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.persister_class_provider</entry>
 
               <entry>A optional <classname>PersisterClassProvider</classname>
               implementation class name. The class must have a no-arg
               constructor.</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.session_factory_observer</entry>
 
               <entry>A optional <classname>SessionFactoryObserver</classname>
               implementation class name. The class must have a no-arg
               constructor.</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.event.&lt;eventtype&gt;</entry>
 
               <entry>Event listener list for a given eventtype. The list of
               event listeners is a comma separated fully qualified class name
               list (eg. hibernate.ejb.event.pre-load
               com.acme.SecurityListener, com.acme.AuditListener)</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.use_class_enhancer</entry>
 
               <entry>Whether or not use Application server class enhancement
               at deployment time (default to false)</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.discard_pc_on_close</entry>
 
               <entry>If true, the persistence context will be discarded (think
               clear() when the method is called. Otherwise the persistence
               context will stay alive till the transaction completion: all
               objects will remain managed, and any change will be synchronized
               with the database (default to false, ie wait the transaction
               completion)</entry>
             </row>
 
             <row>
               <entry>hibernate.ejb.resource_scanner</entry>
 
               <entry><para>By default, Hibernate EntityManager scans itself
               the list of resources for annotated classes and persistence
               deployment descriptors (like orm.xml and hbm.xml
               files).</para><para>You can customize this scanning strategy by
               implementing
               <classname>org.hibernate.ejb.packaging.Scanner</classname>. This
               property is used by container implementors to improve
               integration with Hibernate.</para><para>Accepts an instance of
               <classname>Scanner</classname> or the file name of a no-arg
               constructor class implementing
               <classname>Scanner</classname>.</para></entry>
             </row>
           </tbody>
         </tgroup>
       </table>
 
       <para>Note that you can mix XML <literal>&lt;class&gt;</literal>
       declaration and <literal>hibernate.ejb.cfgfile</literal> usage in the
       same configuration. Be aware of the potential clashed. The properties
       set in <filename>persistence.xml</filename> will override the one in the
       defined <filename>hibernate.cfg.xml</filename>.</para>
 
       <note>
         <para>It is important that you do not override
         <literal>hibernate.transaction.factory_class</literal>, Hibernate
         EntityManager automatically set the appropriate transaction factory
         depending on the EntityManager type (ie <literal>JTA</literal> versus
         <literal>RESOURSE_LOCAL</literal>). If you are working in a Java EE
         environment, you might want to set the
         <literal>hibernate.transaction.manager_lookup_class</literal>
         though.</para>
       </note>
 
       <para>Here is a typical configuration in a Java SE environment</para>
 
       <programlisting language="XML" role="XML">&lt;persistence&gt;
    &lt;persistence-unit name="manager1" transaction-type="RESOURCE_LOCAL"&gt;
       &lt;class&gt;org.hibernate.ejb.test.Cat&lt;/class&gt;
       &lt;class&gt;org.hibernate.ejb.test.Distributor&lt;/class&gt;
       &lt;class&gt;org.hibernate.ejb.test.Item&lt;/class&gt;
       &lt;properties&gt;
          &lt;property name="javax.persistence.jdbc.driver" value="org.hsqldb.jdbcDriver"/&gt;
          &lt;property name="javax.persistence.jdbc.user" value="sa"/&gt;
          &lt;property name="javax.persistence.jdbc.password" value=""/&gt;
          &lt;property name="javax.persistence.jdbc.url" value="jdbc:hsqldb:."/&gt;
          &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/
          &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
        
          &lt;!-- cache configuration --&gt;
          &lt;property name="hibernate.ejb.classcache.org.hibernate.ejb.test.Item" value="read-write"/&gt;
          &lt;property name="hibernate.ejb.collectioncache.org.hibernate.ejb.test.Item.distributors" value="read-write, RegionName"/&gt;
 
          &lt;!-- alternatively to &lt;class&gt; and &lt;property&gt; declarations, you can use a regular hibernate.cfg.xml file --&gt;
          &lt;!-- property name="hibernate.ejb.cfgfile" value="/org/hibernate/ejb/test/hibernate.cfg.xml"/ --&gt;
       &lt;/properties&gt;
    &lt;/persistence-unit&gt;
 &lt;/persistence&gt;</programlisting>
 
       <para>To ease the programmatic configuration, Hibernate Entity Manager
       provide a proprietary API. This API is very similar to the
       <classname>Configuration</classname> API and share the same concepts:
       <classname>Ejb3Configuration</classname>. Refer to the JavaDoc and the
       Hibernate reference guide for more detailed informations on how to use
       it.</para>
 
       <para>TODO: me more descriptive on some APIs like setDatasource()</para>
 
       <programlisting language="JAVA" role="JAVA">Ejb3Configuration cfg = new Ejb3Configuration();
 EntityManagerFactory emf = 
   cfg.addProperties( properties ) //add some properties
      .setInterceptor( myInterceptorImpl ) // set an interceptor
      .addAnnotatedClass( MyAnnotatedClass.class ) //add a class to be mapped
      .addClass( NonAnnotatedClass.class ) //add an hbm.xml file using the Hibernate convention
      .addRerousce( "mypath/MyOtherCLass.hbm.xml ) //add an hbm.xml file
      .addRerousce( "mypath/orm.xml ) //add an EJB3 deployment descriptor
      .configure("/mypath/hibernate.cfg.xml") //add a regular hibernate.cfg.xml
      .buildEntityManagerFactory(); //Create the entity manager factory</programlisting>
     </section>
   </section>
 
   <section>
     <title>Event listeners</title>
 
     <para>Hibernate Entity Manager needs to enhance Hibernate core to
     implements all the JPA semantics. It does that through the event listener
     system of Hibernate. Be careful when you use the event system yourself,
     you might override some of the JPA semantics. A safe way is to add your
     event listeners to the list given below.</para>
 
     <table>
       <title>Hibernate Entity Manager default event listeners</title>
 
       <tgroup cols="2">
         <colspec align="left" colname="c1" />
 
         <colspec colname="c2" colwidth="2*" />
 
         <thead>
           <row>
             <entry>Event</entry>
 
             <entry>Listeners</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry>flush</entry>
 
             <entry>org.hibernate.ejb.event.EJB3FlushEventListener</entry>
           </row>
 
           <row>
             <entry>auto-flush</entry>
 
             <entry>org.hibernate.ejb.event.EJB3AutoFlushEventListener</entry>
           </row>
 
           <row>
             <entry>delete</entry>
 
             <entry>org.hibernate.ejb.event.EJB3DeleteEventListener</entry>
           </row>
 
           <row>
             <entry>flush-entity</entry>
 
             <entry>org.hibernate.ejb.event.EJB3FlushEntityEventListener</entry>
           </row>
 
           <row>
             <entry>merge</entry>
 
             <entry>org.hibernate.ejb.event.EJB3MergeEventListener</entry>
           </row>
 
           <row>
             <entry>create</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PersistEventListener</entry>
           </row>
 
           <row>
             <entry>create-onflush</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PersistOnFlushEventListener</entry>
           </row>
 
           <row>
             <entry>save</entry>
 
             <entry>org.hibernate.ejb.event.EJB3SaveEventListener</entry>
           </row>
 
           <row>
             <entry>save-update</entry>
 
             <entry>org.hibernate.ejb.event.EJB3SaveOrUpdateEventListener</entry>
           </row>
 
           <row>
             <entry>pre-insert</entry>
 
-            <entry>org.hibernate.secure.JACCPreInsertEventListener</entry>
+            <entry>org.hibernate.secure.internal.JACCPreInsertEventListener</entry>
           </row>
 
           <row>
             <entry>pre-insert</entry>
 
-            <entry>org.hibernate.secure.JACCPreUpdateEventListener</entry>
+            <entry>org.hibernate.secure.internal.JACCPreUpdateEventListener</entry>
           </row>
 
           <row>
             <entry>pre-delete</entry>
 
-            <entry>org.hibernate.secure.JACCPreDeleteEventListener</entry>
+            <entry>org.hibernate.secure.internal.JACCPreDeleteEventListener</entry>
           </row>
 
           <row>
             <entry>pre-load</entry>
 
-            <entry>org.hibernate.secure.JACCPreLoadEventListener</entry>
+            <entry>org.hibernate.secure.internal.JACCPreLoadEventListener</entry>
           </row>
 
           <row>
             <entry>post-delete</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PostDeleteEventListener</entry>
           </row>
 
           <row>
             <entry>post-insert</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PostInsertEventListener</entry>
           </row>
 
           <row>
             <entry>post-load</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PostLoadEventListener</entry>
           </row>
 
           <row>
             <entry>post-update</entry>
 
             <entry>org.hibernate.ejb.event.EJB3PostUpdateEventListener</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>Note that the <classname>JACC*EventListeners</classname> are removed
     if the security is not enabled.</para>
 
     <para>You can configure the event listeners either through the properties
     (see <xref linkend="setup-configuration" />) or through the
     <methodname>ejb3configuration.getEventListeners()</methodname> API.</para>
   </section>
 
   <section>
     <title>Obtaining an EntityManager in a Java SE environment</title>
 
     <para>An entity manager factory should be considered as an immutable
     configuration holder, it is defined to point to a single datasource and to
     map a defined set of entities. This is the entry point to create and
     manage <classname>EntityManager</classname>s. The
     <classname>Persistence</classname> class is bootstrap class to create an
     entity manager factory.</para>
 
     <programlisting language="JAVA" role="JAVA">// Use persistence.xml configuration
 EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1")
 EntityManager em = emf.createEntityManager(); // Retrieve an application managed entity manager
 // Work with the EM
 em.close();
 ...
 emf.close(); //close at application end</programlisting>
 
     <para>An entity manager factory is typically create at application
     initialization time and closed at application end. It's creation is an
     expensive process. For those who are familiar with Hibernate, an entity
     manager factory is very much like a session factory. Actually, an entity
     manager factory is a wrapper on top of a session factory. Calls to the
     entityManagerFactory are thread safe.</para>
 
     <para>Thanks to the <classname>EntityManagerFactory</classname>, you can
     retrieve an extended entity manager. The extended entity manager keep the
     same persistence context for the lifetime of the entity manager: in other
     words, the entities are still managed between two transactions (unless you
     call <methodname>entityManager.clear()</methodname> in between). You can
     see an entity manager as a small wrapper on top of an Hibernate
     session.</para>
 
     <para>TODO explains emf.createEntityManager(Map)</para>
   </section>
 
   <section>
     <title>Various</title>
 
     <para>Hibernate Entity Manager comes with Hibernate Validator configured
     out of the box. You don't have to override any event yourself. If you do
     not use Hibernate Validator annotations in your domain model, there will
     be no performance cost. For more information on Hibernate Validator,
     please refer to the Hibernate Annotations reference guide.</para>
   </section>
 </chapter>
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/Ejb3Configuration.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/Ejb3Configuration.java
index 2accd8dfc1..3d61b3be2a 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/Ejb3Configuration.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/Ejb3Configuration.java
@@ -1,1103 +1,1103 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb;
 
 import javax.naming.BinaryRefAddr;
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.Referenceable;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.EntityNotFoundException;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitInfo;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import javax.sql.DataSource;
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.dom4j.Element;
 import org.jboss.logging.Logger;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.annotations.reflection.XMLContext;
 import org.hibernate.cfg.beanvalidation.BeanValidationIntegrator;
 import org.hibernate.ejb.connection.InjectedDataSourceConnectionProvider;
 import org.hibernate.ejb.event.JpaIntegrator;
 import org.hibernate.ejb.instrument.InterceptFieldClassFileTransformer;
 import org.hibernate.ejb.internal.EntityManagerMessageLogger;
 import org.hibernate.ejb.packaging.JarVisitorFactory;
 import org.hibernate.ejb.packaging.NamedInputStream;
 import org.hibernate.ejb.packaging.NativeScanner;
 import org.hibernate.ejb.packaging.PersistenceMetadata;
 import org.hibernate.ejb.packaging.PersistenceXmlLoader;
 import org.hibernate.ejb.packaging.Scanner;
 import org.hibernate.ejb.util.ConfigurationHelper;
 import org.hibernate.ejb.util.LogHelper;
 import org.hibernate.ejb.util.NamingHelper;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.xml.MappingReader;
 import org.hibernate.internal.util.xml.OriginImpl;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.proxy.EntityNotFoundDelegate;
-import org.hibernate.secure.JACCConfiguration;
+import org.hibernate.secure.internal.JACCConfiguration;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.jdbc.connections.internal.DatasourceConnectionProviderImpl;
 
 /**
  * Allow a fine tuned configuration of an EJB 3.0 EntityManagerFactory
  *
  * A Ejb3Configuration object is only guaranteed to create one EntityManagerFactory.
  * Multiple usage of {@link #buildEntityManagerFactory()} is not guaranteed.
  *
  * After #buildEntityManagerFactory() has been called, you no longer can change the configuration
  * state (no class adding, no property change etc)
  *
  * When serialized / deserialized or retrieved from the JNDI, you no longer can change the
  * configuration state (no class adding, no property change etc)
  *
  * Putting the configuration in the JNDI is an expensive operation that requires a partial
  * serialization
  *
  * @author Emmanuel Bernard
  *
  * @deprecated See <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6181">HHH-6181</a> and
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6159">HHH-6159</a> for details
  */
 @Deprecated
 public class Ejb3Configuration implements Serializable, Referenceable {
 
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(
 			EntityManagerMessageLogger.class,
 			Ejb3Configuration.class.getName()
 	);
 	private static final String IMPLEMENTATION_NAME = HibernatePersistence.class.getName();
 	private static final String META_INF_ORM_XML = "META-INF/orm.xml";
 	private static final String PARSED_MAPPING_DOMS = "hibernate.internal.mapping_doms";
 
 	private static EntityNotFoundDelegate ejb3EntityNotFoundDelegate = new Ejb3EntityNotFoundDelegate();
 	private static Configuration DEFAULT_CONFIGURATION = new Configuration();
 
 	private static class Ejb3EntityNotFoundDelegate implements EntityNotFoundDelegate, Serializable {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException("Unable to find " + entityName  + " with id " + id);
 		}
 	}
 
 	private String persistenceUnitName;
 	private String cfgXmlResource;
 
 	private Configuration cfg;
 	//made transient and not restored in deserialization on purpose, should no longer be called after restoration
 	private PersistenceUnitTransactionType transactionType;
 	private boolean discardOnClose;
 	//made transient and not restored in deserialization on purpose, should no longer be called after restoration
 	private transient ClassLoader overridenClassLoader;
 	private boolean isConfigurationProcessed = false;
 
 
 	public Ejb3Configuration() {
 		cfg = new Configuration();
 		cfg.setEntityNotFoundDelegate( ejb3EntityNotFoundDelegate );
 	}
 
 	/**
 	 * Used to inject a datasource object as the connection provider.
 	 * If used, be sure to <b>not override</b> the hibernate.connection.provider_class
 	 * property
 	 */
 	@SuppressWarnings({ "JavaDoc", "unchecked" })
 	public void setDataSource(DataSource ds) {
 		if ( ds != null ) {
 			cfg.getProperties().put( Environment.DATASOURCE, ds );
 			this.setProperty( Environment.CONNECTION_PROVIDER, DatasourceConnectionProviderImpl.class.getName() );
 		}
 	}
 
 	/**
 	 * create a factory from a parsed persistence.xml
 	 * Especially the scanning of classes and additional jars is done already at this point.
 	 * <p/>
 	 * NOTE: public only for unit testing purposes; not a public API!
 	 *
 	 * @param metadata The information parsed from the persistence.xml
 	 * @param overridesIn Any explicitly passed config settings
 	 *
 	 * @return this
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Ejb3Configuration configure(PersistenceMetadata metadata, Map overridesIn) {
         LOG.debugf("Creating Factory: %s", metadata.getName());
 
 		Map overrides = new HashMap();
 		if ( overridesIn != null ) {
 			overrides.putAll( overridesIn );
 		}
 
 		Map workingVars = new HashMap();
 		workingVars.put( AvailableSettings.PERSISTENCE_UNIT_NAME, metadata.getName() );
 		this.persistenceUnitName = metadata.getName();
 
 		if ( StringHelper.isNotEmpty( metadata.getJtaDatasource() ) ) {
 			this.setProperty( Environment.DATASOURCE, metadata.getJtaDatasource() );
 		}
 		else if ( StringHelper.isNotEmpty( metadata.getNonJtaDatasource() ) ) {
 			this.setProperty( Environment.DATASOURCE, metadata.getNonJtaDatasource() );
 		}
 		else {
 			final String driver = (String) metadata.getProps().get( AvailableSettings.JDBC_DRIVER );
 			if ( StringHelper.isNotEmpty( driver ) ) {
 				this.setProperty( Environment.DRIVER, driver );
 			}
 			final String url = (String) metadata.getProps().get( AvailableSettings.JDBC_URL );
 			if ( StringHelper.isNotEmpty( url ) ) {
 				this.setProperty( Environment.URL, url );
 			}
 			final String user = (String) metadata.getProps().get( AvailableSettings.JDBC_USER );
 			if ( StringHelper.isNotEmpty( user ) ) {
 				this.setProperty( Environment.USER, user );
 			}
 			final String pass = (String) metadata.getProps().get( AvailableSettings.JDBC_PASSWORD );
 			if ( StringHelper.isNotEmpty( pass ) ) {
 				this.setProperty( Environment.PASS, pass );
 			}
 		}
 		defineTransactionType( metadata.getTransactionType(), workingVars );
 		if ( metadata.getClasses().size() > 0 ) {
 			workingVars.put( AvailableSettings.CLASS_NAMES, metadata.getClasses() );
 		}
 		if ( metadata.getPackages().size() > 0 ) {
 			workingVars.put( AvailableSettings.PACKAGE_NAMES, metadata.getPackages() );
 		}
 		if ( metadata.getMappingFiles().size() > 0 ) {
 			workingVars.put( AvailableSettings.XML_FILE_NAMES, metadata.getMappingFiles() );
 		}
 		if ( metadata.getHbmfiles().size() > 0 ) {
 			workingVars.put( AvailableSettings.HBXML_FILES, metadata.getHbmfiles() );
 		}
 
 		Properties props = new Properties();
 		props.putAll( metadata.getProps() );
 
 		// validation factory
 		final Object validationFactory = overrides.get( AvailableSettings.VALIDATION_FACTORY );
 		if ( validationFactory != null ) {
 			BeanValidationIntegrator.validateFactory( validationFactory );
 			props.put( AvailableSettings.VALIDATION_FACTORY, validationFactory );
 		}
 		overrides.remove( AvailableSettings.VALIDATION_FACTORY );
 
 		// validation-mode (overrides has precedence)
 		{
 			final Object integrationValue = overrides.get( AvailableSettings.VALIDATION_MODE );
 			if ( integrationValue != null ) {
 				props.put( AvailableSettings.VALIDATION_MODE, integrationValue.toString() );
 			}
 			else if ( metadata.getValidationMode() != null ) {
 				props.put( AvailableSettings.VALIDATION_MODE, metadata.getValidationMode() );
 			}
 			overrides.remove( AvailableSettings.VALIDATION_MODE );
 		}
 
 		// shared-cache-mode (overrides has precedence)
 		{
 			final Object integrationValue = overrides.get( AvailableSettings.SHARED_CACHE_MODE );
 			if ( integrationValue != null ) {
 				props.put( AvailableSettings.SHARED_CACHE_MODE, integrationValue.toString() );
 			}
 			else if ( metadata.getSharedCacheMode() != null ) {
 				props.put( AvailableSettings.SHARED_CACHE_MODE, metadata.getSharedCacheMode() );
 			}
 			overrides.remove( AvailableSettings.SHARED_CACHE_MODE );
 		}
 
 		for ( Map.Entry entry : (Set<Map.Entry>) overrides.entrySet() ) {
 			Object value = entry.getValue();
 			props.put( entry.getKey(), value == null ? "" :  value ); //alter null, not allowed in properties
 		}
 
 		configure( props, workingVars );
 		return this;
 	}
 
 	/**
 	 * Build the configuration from an entity manager name and given the
 	 * appropriate extra properties. Those properties override the one get through
 	 * the persistence.xml file.
 	 * If the persistence unit name is not found or does not match the Persistence Provider, null is returned
 	 *
 	 * This method is used in a non managed environment
 	 *
 	 * @param persistenceUnitName persistence unit name
 	 * @param integration properties passed to the persistence provider
 	 *
 	 * @return configured Ejb3Configuration or null if no persistence unit match
 	 *
 	 * @see HibernatePersistence#createEntityManagerFactory(String, java.util.Map)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Ejb3Configuration configure(String persistenceUnitName, Map integration) {
 		try {
             LOG.debugf("Look up for persistence unit: %s", persistenceUnitName);
 			integration = integration == null ?
 					CollectionHelper.EMPTY_MAP :
 					Collections.unmodifiableMap( integration );
 			Enumeration<URL> xmls = Thread.currentThread()
 					.getContextClassLoader()
 					.getResources( "META-INF/persistence.xml" );
             if (!xmls.hasMoreElements()) LOG.unableToFindPersistenceXmlInClasspath();
 			while ( xmls.hasMoreElements() ) {
 				URL url = xmls.nextElement();
                 LOG.trace("Analyzing persistence.xml: " + url);
 				List<PersistenceMetadata> metadataFiles = PersistenceXmlLoader.deploy(
 						url,
 						integration,
 						cfg.getEntityResolver(),
 						PersistenceUnitTransactionType.RESOURCE_LOCAL );
 				for ( PersistenceMetadata metadata : metadataFiles ) {
                     LOG.trace(metadata);
 
 					if ( metadata.getProvider() == null || IMPLEMENTATION_NAME.equalsIgnoreCase(
 							metadata.getProvider()
 					) ) {
 						//correct provider
 
 						//lazy load the scanner to avoid unnecessary IOExceptions
 						Scanner scanner = null;
 						URL jarURL = null;
 						if ( metadata.getName() == null ) {
 							scanner = buildScanner( metadata.getProps(), integration );
 							jarURL = JarVisitorFactory.getJarURLFromURLEntry( url, "/META-INF/persistence.xml" );
 							metadata.setName( scanner.getUnqualifiedJarName(jarURL) );
 						}
 						if ( persistenceUnitName == null && xmls.hasMoreElements() ) {
 							throw new PersistenceException( "No name provided and several persistence units found" );
 						}
 						else if ( persistenceUnitName == null || metadata.getName().equals( persistenceUnitName ) ) {
 							if (scanner == null) {
 								scanner = buildScanner( metadata.getProps(), integration );
 								jarURL = JarVisitorFactory.getJarURLFromURLEntry( url, "/META-INF/persistence.xml" );
 							}
 							//scan main JAR
 							ScanningContext mainJarScanCtx = new ScanningContext()
 									.scanner( scanner )
 									.url( jarURL )
 									.explicitMappingFiles( metadata.getMappingFiles() )
 									.searchOrm( true );
 							setDetectedArtifactsOnScanningContext( mainJarScanCtx, metadata.getProps(), integration,
 																				metadata.getExcludeUnlistedClasses() );
 							addMetadataFromScan( mainJarScanCtx, metadata );
 
 							ScanningContext otherJarScanCtx = new ScanningContext()
 									.scanner( scanner )
 									.explicitMappingFiles( metadata.getMappingFiles() )
 									.searchOrm( true );
 							setDetectedArtifactsOnScanningContext( otherJarScanCtx, metadata.getProps(), integration,
 																				false );
 							for ( String jarFile : metadata.getJarFiles() ) {
 								otherJarScanCtx.url( JarVisitorFactory.getURLFromPath( jarFile ) );
 								addMetadataFromScan( otherJarScanCtx, metadata );
 							}
 							return configure( metadata, integration );
 						}
 					}
 				}
 			}
 			return null;
 		}
 		catch (Exception e) {
 			if ( e instanceof PersistenceException) {
 				throw (PersistenceException) e;
 			}
 			else {
 				throw new PersistenceException( getExceptionHeader() + "Unable to configure EntityManagerFactory", e );
 			}
 		}
 	}
 
 	private Scanner buildScanner(Properties properties, Map<?,?> integration) {
 		//read the String or Instance from the integration map first and use the properties as a backup.
 		Object scanner = integration.get( AvailableSettings.SCANNER );
 		if (scanner == null) {
 			scanner = properties.getProperty( AvailableSettings.SCANNER );
 		}
 		if (scanner != null) {
 			Class<?> scannerClass;
 			if ( scanner instanceof String ) {
 				try {
 					scannerClass = ReflectHelper.classForName( (String) scanner, this.getClass() );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new PersistenceException(  "Cannot find scanner class. " + AvailableSettings.SCANNER + "=" + scanner, e );
 				}
 			}
 			else if (scanner instanceof Class) {
 				scannerClass = (Class<? extends Scanner>) scanner;
 			}
 			else if (scanner instanceof Scanner) {
 				return (Scanner) scanner;
 			}
 			else {
 				throw new PersistenceException(  "Scanner class configuration error: unknown type on the property. " + AvailableSettings.SCANNER );
 			}
 			try {
 				return (Scanner) scannerClass.newInstance();
 			}
 			catch ( InstantiationException e ) {
 				throw new PersistenceException(  "Unable to load Scanner class: " + scannerClass, e );
 			}
 			catch ( IllegalAccessException e ) {
 				throw new PersistenceException(  "Unable to load Scanner class: " + scannerClass, e );
 			}
 		}
 		else {
 			return new NativeScanner();
 		}
 	}
 
 	private static class ScanningContext {
 		//boolean excludeUnlistedClasses;
 		private Scanner scanner;
 		private URL url;
 		private List<String> explicitMappingFiles;
 		private boolean detectClasses;
 		private boolean detectHbmFiles;
 		private boolean searchOrm;
 
 		public ScanningContext scanner(Scanner scanner) {
 			this.scanner = scanner;
 			return this;
 		}
 
 		public ScanningContext url(URL url) {
 			this.url = url;
 			return this;
 		}
 
 		public ScanningContext explicitMappingFiles(List<String> explicitMappingFiles) {
 			this.explicitMappingFiles = explicitMappingFiles;
 			return this;
 		}
 
 		public ScanningContext detectClasses(boolean detectClasses) {
 			this.detectClasses = detectClasses;
 			return this;
 		}
 
 		public ScanningContext detectHbmFiles(boolean detectHbmFiles) {
 			this.detectHbmFiles = detectHbmFiles;
 			return this;
 		}
 
 		public ScanningContext searchOrm(boolean searchOrm) {
 			this.searchOrm = searchOrm;
 			return this;
 		}
 	}
 
 	private static void addMetadataFromScan(ScanningContext scanningContext, PersistenceMetadata metadata) throws IOException {
 		List<String> classes = metadata.getClasses();
 		List<String> packages = metadata.getPackages();
 		List<NamedInputStream> hbmFiles = metadata.getHbmfiles();
 		List<String> mappingFiles = metadata.getMappingFiles();
 		addScannedEntries( scanningContext, classes, packages, hbmFiles, mappingFiles );
 	}
 
 	private static void addScannedEntries(ScanningContext scanningContext, List<String> classes, List<String> packages, List<NamedInputStream> hbmFiles, List<String> mappingFiles) throws IOException {
 		Scanner scanner = scanningContext.scanner;
 		if (scanningContext.detectClasses) {
 			Set<Class<? extends Annotation>> annotationsToExclude = new HashSet<Class<? extends Annotation>>(3);
 			annotationsToExclude.add( Entity.class );
 			annotationsToExclude.add( MappedSuperclass.class );
 			annotationsToExclude.add( Embeddable.class );
 			Set<Class<?>> matchingClasses = scanner.getClassesInJar( scanningContext.url, annotationsToExclude );
 			for (Class<?> clazz : matchingClasses) {
 				classes.add( clazz.getName() );
 			}
 
 			Set<Package> matchingPackages = scanner.getPackagesInJar( scanningContext.url, new HashSet<Class<? extends Annotation>>(0) );
 			for (Package pkg : matchingPackages) {
 				packages.add( pkg.getName() );
 			}
 		}
 		Set<String> patterns = new HashSet<String>();
 		if (scanningContext.searchOrm) {
 			patterns.add( META_INF_ORM_XML );
 		}
 		if (scanningContext.detectHbmFiles) {
 			patterns.add( "**/*.hbm.xml" );
 		}
 		if ( mappingFiles != null) patterns.addAll( mappingFiles );
 		if (patterns.size() !=0) {
 			Set<NamedInputStream> files = scanner.getFilesInJar( scanningContext.url, patterns );
 			for (NamedInputStream file : files) {
 				hbmFiles.add( file );
 				if (mappingFiles != null) mappingFiles.remove( file.getName() );
 			}
 		}
 	}
 
 	/**
 	 * Process configuration from a PersistenceUnitInfo object; typically called by the container
 	 * via {@link javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory}.
 	 * In Hibernate EM, this correlates to {@link HibernatePersistence#createContainerEntityManagerFactory}
 	 *
 	 * @param info The persistence unit info passed in by the container (usually from processing a persistence.xml).
 	 * @param integration The map of integration properties from the container to configure the provider.
 	 *
 	 * @return this
 	 *
 	 * @see HibernatePersistence#createContainerEntityManagerFactory
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Ejb3Configuration configure(PersistenceUnitInfo info, Map integration) {
         if (LOG.isDebugEnabled()) LOG.debugf("Processing %s", LogHelper.logPersistenceUnitInfo(info));
         else LOG.processingPersistenceUnitInfoName(info.getPersistenceUnitName());
 
 		// Spec says the passed map may be null, so handle that to make further processing easier...
 		integration = integration != null ? Collections.unmodifiableMap( integration ) : CollectionHelper.EMPTY_MAP;
 
 		// See if we (Hibernate) are the persistence provider
 		String provider = (String) integration.get( AvailableSettings.PROVIDER );
 		if ( provider == null ) {
 			provider = info.getPersistenceProviderClassName();
 		}
 		if ( provider != null && ! provider.trim().startsWith( IMPLEMENTATION_NAME ) ) {
             LOG.requiredDifferentProvider(provider);
 			return null;
 		}
 
 		// set the classloader, passed in by the container in info, to set as the TCCL so that
 		// Hibernate uses it to properly resolve class references.
 		if ( info.getClassLoader() == null ) {
 			throw new IllegalStateException(
 					"[PersistenceUnit: " + info.getPersistenceUnitName() == null ? "" : info.getPersistenceUnitName()
 							+ "] " + "PersistenceUnitInfo.getClassLoader() id null" );
 		}
 		Thread thread = Thread.currentThread();
 		ClassLoader contextClassLoader = thread.getContextClassLoader();
 		boolean sameClassLoader = info.getClassLoader().equals( contextClassLoader );
 		if ( ! sameClassLoader ) {
 			overridenClassLoader = info.getClassLoader();
 			thread.setContextClassLoader( overridenClassLoader );
 		}
 		else {
 			overridenClassLoader = null;
 		}
 
 		// Best I can tell, 'workingVars' is some form of additional configuration contract.
 		// But it does not correlate 1-1 to EMF/SF settings.  It really is like a set of de-typed
 		// additional configuration info.  I think it makes better sense to define this as an actual
 		// contract if that was in fact the intent; the code here is pretty confusing.
 		try {
 			Map workingVars = new HashMap();
 			workingVars.put( AvailableSettings.PERSISTENCE_UNIT_NAME, info.getPersistenceUnitName() );
 			this.persistenceUnitName = info.getPersistenceUnitName();
 			List<String> entities = new ArrayList<String>( 50 );
 			if ( info.getManagedClassNames() != null ) entities.addAll( info.getManagedClassNames() );
 			List<NamedInputStream> hbmFiles = new ArrayList<NamedInputStream>();
 			List<String> packages = new ArrayList<String>();
 			List<String> xmlFiles = new ArrayList<String>( 50 );
 			List<XmlDocument> xmlDocuments = new ArrayList<XmlDocument>( 50 );
 			if ( info.getMappingFileNames() != null ) {
 				xmlFiles.addAll( info.getMappingFileNames() );
 			}
 			//Should always be true if the container is not dump
 			boolean searchForORMFiles = ! xmlFiles.contains( META_INF_ORM_XML );
 
 			ScanningContext context = new ScanningContext();
 			final Properties copyOfProperties = (Properties) info.getProperties().clone();
 			ConfigurationHelper.overrideProperties( copyOfProperties, integration );
 			context.scanner( buildScanner( copyOfProperties, integration ) )
 					.searchOrm( searchForORMFiles )
 					.explicitMappingFiles( null ); //URLs provided by the container already
 
 			//context for other JARs
 			setDetectedArtifactsOnScanningContext(context, info.getProperties(), null, false );
 			for ( URL jar : info.getJarFileUrls() ) {
 				context.url(jar);
 				scanForClasses( context, packages, entities, hbmFiles );
 			}
 
 			//main jar
 			context.url( info.getPersistenceUnitRootUrl() );
 			setDetectedArtifactsOnScanningContext( context, info.getProperties(), null, info.excludeUnlistedClasses() );
 			scanForClasses( context, packages, entities, hbmFiles );
 
 			Properties properties = info.getProperties() != null ? info.getProperties() : new Properties();
 			ConfigurationHelper.overrideProperties( properties, integration );
 
 			//FIXME entities is used to enhance classes and to collect annotated entities this should not be mixed
 			//fill up entities with the on found in xml files
 			addXMLEntities( xmlFiles, info, entities, xmlDocuments );
 
 			//FIXME send the appropriate entites.
 			if ( "true".equalsIgnoreCase( properties.getProperty( AvailableSettings.USE_CLASS_ENHANCER ) ) ) {
 				info.addTransformer( new InterceptFieldClassFileTransformer( entities ) );
 			}
 
 			workingVars.put( AvailableSettings.CLASS_NAMES, entities );
 			workingVars.put( AvailableSettings.PACKAGE_NAMES, packages );
 			workingVars.put( AvailableSettings.XML_FILE_NAMES, xmlFiles );
 			workingVars.put( PARSED_MAPPING_DOMS, xmlDocuments );
 
 			if ( hbmFiles.size() > 0 ) {
 				workingVars.put( AvailableSettings.HBXML_FILES, hbmFiles );
 			}
 
 			// validation factory
 			final Object validationFactory = integration.get( AvailableSettings.VALIDATION_FACTORY );
 			if ( validationFactory != null ) {
 				BeanValidationIntegrator.validateFactory( validationFactory );
 				properties.put( AvailableSettings.VALIDATION_FACTORY, validationFactory );
 			}
 
 			// validation-mode (integration has precedence)
 			{
 				final Object integrationValue = integration.get( AvailableSettings.VALIDATION_MODE );
 				if ( integrationValue != null ) {
 					properties.put( AvailableSettings.VALIDATION_MODE, integrationValue.toString() );
 				}
 				else if ( info.getValidationMode() != null ) {
 					properties.put( AvailableSettings.VALIDATION_MODE, info.getValidationMode().name() );
 				}
 			}
 
 			// shared-cache-mode (integration has precedence)
 			{
 				final Object integrationValue = integration.get( AvailableSettings.SHARED_CACHE_MODE );
 				if ( integrationValue != null ) {
 					properties.put( AvailableSettings.SHARED_CACHE_MODE, integrationValue.toString() );
 				}
 				else if ( info.getSharedCacheMode() != null ) {
 					properties.put( AvailableSettings.SHARED_CACHE_MODE, info.getSharedCacheMode().name() );
 				}
 			}
 
 			//datasources
 			Boolean isJTA = null;
 			boolean overridenDatasource = false;
 			if ( integration.containsKey( AvailableSettings.JTA_DATASOURCE ) ) {
 				String dataSource = (String) integration.get( AvailableSettings.JTA_DATASOURCE );
 				overridenDatasource = true;
 				properties.setProperty( Environment.DATASOURCE, dataSource );
 				isJTA = Boolean.TRUE;
 			}
 			if ( integration.containsKey( AvailableSettings.NON_JTA_DATASOURCE ) ) {
 				String dataSource = (String) integration.get( AvailableSettings.NON_JTA_DATASOURCE );
 				overridenDatasource = true;
 				properties.setProperty( Environment.DATASOURCE, dataSource );
 				if (isJTA == null) isJTA = Boolean.FALSE;
 			}
 
 			if ( ! overridenDatasource && ( info.getJtaDataSource() != null || info.getNonJtaDataSource() != null ) ) {
 				isJTA = info.getJtaDataSource() != null ? Boolean.TRUE : Boolean.FALSE;
 				this.setDataSource(
 						isJTA ? info.getJtaDataSource() : info.getNonJtaDataSource()
 				);
 				this.setProperty(
 						Environment.CONNECTION_PROVIDER, InjectedDataSourceConnectionProvider.class.getName()
 				);
 			}
 			/*
 			 * If explicit type => use it
 			 * If a JTA DS is used => JTA transaction,
 			 * if a non JTA DS is used => RESOURCe_LOCAL
 			 * if none, set to JavaEE default => JTA transaction
 			 */
 			PersistenceUnitTransactionType transactionType = info.getTransactionType();
 			if (transactionType == null) {
 				if (isJTA == Boolean.TRUE) {
 					transactionType = PersistenceUnitTransactionType.JTA;
 				}
 				else if ( isJTA == Boolean.FALSE ) {
 					transactionType = PersistenceUnitTransactionType.RESOURCE_LOCAL;
 				}
 				else {
 					transactionType = PersistenceUnitTransactionType.JTA;
 				}
 			}
 			defineTransactionType( transactionType, workingVars );
 			configure( properties, workingVars );
 		}
 		finally {
 			//After EMF, set the CCL back
 			if ( ! sameClassLoader ) {
 				thread.setContextClassLoader( contextClassLoader );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Processes {@code xmlFiles} argument and populates:<ul>
 	 * <li>the {@code entities} list with encountered classnames</li>
 	 * <li>the {@code xmlDocuments} list with parsed/validated {@link XmlDocument} corrolary to each xml file</li>
 	 * </ul>
 	 *
 	 * @param xmlFiles The XML resource names; these will be resolved by classpath lookup and parsed/validated.
 	 * @param info The PUI
 	 * @param entities (output) The names of all encountered "mapped" classes
 	 * @param xmlDocuments (output) The list of {@link XmlDocument} instances of each entry in {@code xmlFiles}
 	 */
 	@SuppressWarnings({ "unchecked" })
 	private void addXMLEntities(
 			List<String> xmlFiles,
 			PersistenceUnitInfo info,
 			List<String> entities,
 			List<XmlDocument> xmlDocuments) {
 		//TODO handle inputstream related hbm files
 		ClassLoader classLoaderToUse = info.getNewTempClassLoader();
 		if ( classLoaderToUse == null ) {
             LOG.persistenceProviderCallerDoesNotImplementEjb3SpecCorrectly();
 			return;
 		}
 		for ( final String xmlFile : xmlFiles ) {
 			final InputStream fileInputStream = classLoaderToUse.getResourceAsStream( xmlFile );
 			if ( fileInputStream == null ) {
                 LOG.unableToResolveMappingFile(xmlFile);
 				continue;
 			}
 			final InputSource inputSource = new InputSource( fileInputStream );
 
 			XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument(
 					cfg.getEntityResolver(),
 					inputSource,
 					new OriginImpl( "persistence-unit-info", xmlFile )
 			);
 			xmlDocuments.add( metadataXml );
 			try {
 				final Element rootElement = metadataXml.getDocumentTree().getRootElement();
 				if ( rootElement != null && "entity-mappings".equals( rootElement.getName() ) ) {
 					Element element = rootElement.element( "package" );
 					String defaultPackage = element != null ? element.getTextTrim() : null;
 					List<Element> elements = rootElement.elements( "entity" );
 					for (Element subelement : elements ) {
 						String classname = XMLContext.buildSafeClassName( subelement.attributeValue( "class" ), defaultPackage );
 						if ( ! entities.contains( classname ) ) {
 							entities.add( classname );
 						}
 					}
 					elements = rootElement.elements( "mapped-superclass" );
 					for (Element subelement : elements ) {
 						String classname = XMLContext.buildSafeClassName( subelement.attributeValue( "class" ), defaultPackage );
 						if ( ! entities.contains( classname ) ) {
 							entities.add( classname );
 						}
 					}
 					elements = rootElement.elements( "embeddable" );
 					for (Element subelement : elements ) {
 						String classname = XMLContext.buildSafeClassName( subelement.attributeValue( "class" ), defaultPackage );
 						if ( ! entities.contains( classname ) ) {
 							entities.add( classname );
 						}
 					}
 				}
 				else if ( rootElement != null && "hibernate-mappings".equals( rootElement.getName() ) ) {
 					//FIXME include hbm xml entities to enhance them but entities is also used to collect annotated entities
 				}
 			}
 			finally {
 				try {
 					fileInputStream.close();
 				}
 				catch (IOException ioe) {
                     LOG.unableToCloseInputStream(ioe);
 				}
 			}
 		}
 		xmlFiles.clear();
 	}
 
 	private void defineTransactionType(Object overridenTxType, Map workingVars) {
 		if ( overridenTxType == null ) {
 //			if ( transactionType == null ) {
 //				transactionType = PersistenceUnitTransactionType.JTA; //this is the default value
 //			}
 			//nothing to override
 		}
 		else if ( overridenTxType instanceof String ) {
 			transactionType = PersistenceXmlLoader.getTransactionType( (String) overridenTxType );
 		}
 		else if ( overridenTxType instanceof PersistenceUnitTransactionType ) {
 			transactionType = (PersistenceUnitTransactionType) overridenTxType;
 		}
 		else {
 			throw new PersistenceException( getExceptionHeader() +
 					AvailableSettings.TRANSACTION_TYPE + " of the wrong class type"
 							+ ": " + overridenTxType.getClass()
 			);
 		}
 
 	}
 
 	public Ejb3Configuration setProperty(String key, String value) {
 		cfg.setProperty( key, value );
 		return this;
 	}
 
 	/**
 	 * Set ScanningContext detectClasses and detectHbmFiles according to context
 	 */
 	private void setDetectedArtifactsOnScanningContext(ScanningContext context,
 													   Properties properties,
 													   Map overridenProperties,
 													   boolean excludeIfNotOverriden) {
 
 		boolean detectClasses = false;
 		boolean detectHbm = false;
 		String detectSetting = overridenProperties != null ?
 				(String) overridenProperties.get( AvailableSettings.AUTODETECTION ) :
 				null;
 		detectSetting = detectSetting == null ?
 				properties.getProperty( AvailableSettings.AUTODETECTION) :
 				detectSetting;
 		if ( detectSetting == null && excludeIfNotOverriden) {
 			//not overriden through HibernatePersistence.AUTODETECTION so we comply with the spec excludeUnlistedClasses
 			context.detectClasses( false ).detectHbmFiles( false );
 			return;
 		}
 
 		if ( detectSetting == null){
 			detectSetting = "class,hbm";
 		}
 		StringTokenizer st = new StringTokenizer( detectSetting, ", ", false );
 		while ( st.hasMoreElements() ) {
 			String element = (String) st.nextElement();
 			if ( "class".equalsIgnoreCase( element ) ) detectClasses = true;
 			if ( "hbm".equalsIgnoreCase( element ) ) detectHbm = true;
 		}
         LOG.debugf("Detect class: %s; detect hbm: %s", detectClasses, detectHbm);
 		context.detectClasses( detectClasses ).detectHbmFiles( detectHbm );
 	}
 
 	private void scanForClasses(ScanningContext scanningContext, List<String> packages, List<String> entities, List<NamedInputStream> hbmFiles) {
 		if (scanningContext.url == null) {
             LOG.containerProvidingNullPersistenceUnitRootUrl();
 			return;
 		}
 		try {
 			addScannedEntries( scanningContext, entities, packages, hbmFiles, null );
 		}
 		catch (RuntimeException e) {
 			throw new RuntimeException( "error trying to scan <jar-file>: " + scanningContext.url.toString(), e );
 		}
 		catch( IOException e ) {
 			throw new RuntimeException( "Error while reading " + scanningContext.url.toString(), e );
 		}
 	}
 
 	/**
 	 * create a factory from a list of properties and
 	 * HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files
 	 * HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files
 	 * HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files)
 	 * HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes)
 	 * <p/>
 	 * <b>Used by JBoss AS only</b>
 	 * @deprecated use the Java Persistence API
 	 */
 	// This is used directly by JBoss so don't remove until further notice.  bill@jboss.org
 	@Deprecated
     public EntityManagerFactory createEntityManagerFactory(Map workingVars) {
 		configure( workingVars );
 		return buildEntityManagerFactory();
 	}
 
 	/**
 	 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 	 * @deprecated
 	 */
 	@Deprecated
     public EntityManagerFactory createEntityManagerFactory() {
 		configure( cfg.getProperties(), new HashMap() );
 		return buildEntityManagerFactory();
 	}
 
 	public EntityManagerFactory buildEntityManagerFactory() {
 		return buildEntityManagerFactory( new ServiceRegistryBuilder( cfg.getProperties() ).buildServiceRegistry() );
 	}
 
 	public EntityManagerFactory buildEntityManagerFactory(ServiceRegistry serviceRegistry) {
 		Thread thread = null;
 		ClassLoader contextClassLoader = null;
 		if (overridenClassLoader != null) {
 			thread = Thread.currentThread();
 			contextClassLoader = thread.getContextClassLoader();
 			thread.setContextClassLoader( overridenClassLoader );
 		}
 		try {
 			configure( (Properties)null, null );
 			NamingHelper.bind(this);
 			serviceRegistry.getService( IntegratorService.class ).addIntegrator( new JpaIntegrator() );
 			return new EntityManagerFactoryImpl(
 					transactionType,
 					discardOnClose,
 					getSessionInterceptorClass( cfg.getProperties() ),
 					cfg,
 					serviceRegistry
 			);
 		}
 		catch (HibernateException e) {
 			throw new PersistenceException( getExceptionHeader() + "Unable to build EntityManagerFactory", e );
 		}
 		finally {
 			if (thread != null) {
 				thread.setContextClassLoader( contextClassLoader );
 			}
 		}
 	}
 
 	private Class getSessionInterceptorClass(Properties properties) {
 		String sessionInterceptorClassname = (String) properties.get( AvailableSettings.SESSION_INTERCEPTOR );
 		if ( StringHelper.isNotEmpty( sessionInterceptorClassname ) ) {
 			try {
 				Class interceptorClass = ReflectHelper.classForName(
 						sessionInterceptorClassname, Ejb3Configuration.class
 				);
 				interceptorClass.newInstance();
 				return interceptorClass;
 			}
 			catch (ClassNotFoundException e) {
 				throw new PersistenceException( getExceptionHeader() + "Unable to load "
 						+ AvailableSettings.SESSION_INTERCEPTOR + ": " + sessionInterceptorClassname, e);
 			}
 			catch (IllegalAccessException e) {
 				throw new PersistenceException( getExceptionHeader() + "Unable to instanciate "
 						+ AvailableSettings.SESSION_INTERCEPTOR + ": " + sessionInterceptorClassname, e);
 			}
 			catch (InstantiationException e) {
 				throw new PersistenceException( getExceptionHeader() + "Unable to instanciate "
 						+ AvailableSettings.SESSION_INTERCEPTOR + ": " + sessionInterceptorClassname, e);
 			}
         }
         return null;
 	}
 
 	public Reference getReference() throws NamingException {
         LOG.debugf( "Returning a Reference to the Ejb3Configuration" );
 		ByteArrayOutputStream stream = new ByteArrayOutputStream();
 		ObjectOutput out = null;
 		byte[] serialized;
 		try {
 			out = new ObjectOutputStream( stream );
 			out.writeObject( this );
 			out.close();
 			serialized = stream.toByteArray();
 			stream.close();
 		}
 		catch (IOException e) {
 			NamingException namingException = new NamingException( "Unable to serialize Ejb3Configuration" );
 			namingException.setRootCause( e );
 			throw namingException;
 		}
 
 		return new Reference(
 				Ejb3Configuration.class.getName(),
 				new BinaryRefAddr("object", serialized ),
 				Ejb3ConfigurationObjectFactory.class.getName(),
 				null
 		);
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public Ejb3Configuration configure(Map configValues) {
 		Properties props = new Properties();
 		if ( configValues != null ) {
 			props.putAll( configValues );
 			//remove huge non String elements for a clean props
 			props.remove( AvailableSettings.CLASS_NAMES );
 			props.remove( AvailableSettings.PACKAGE_NAMES );
 			props.remove( AvailableSettings.HBXML_FILES );
 			props.remove( AvailableSettings.LOADED_CLASSES );
 		}
 		return configure( props, configValues );
 	}
 
 	/**
 	 * Configures this configuration object from 2 distinctly different sources.
 	 *
 	 * @param properties These are the properties that came from the user, either via
 	 * a persistence.xml or explicitly passed in to one of our
 	 * {@link javax.persistence.spi.PersistenceProvider}/{@link HibernatePersistence} contracts.
 	 * @param workingVars Is collection of settings which need to be handled similarly
 	 * between the 2 main bootstrap methods, but where the values are determine very differently
 	 * by each bootstrap method.  todo eventually make this a contract (class/interface)
 	 *
 	 * @return The configured configuration
 	 *
 	 * @see HibernatePersistence
 	 */
 	private Ejb3Configuration configure(Properties properties, Map workingVars) {
 		//TODO check for people calling more than once this method (except buildEMF)
 		if (isConfigurationProcessed) return this;
 		isConfigurationProcessed = true;
 		Properties preparedProperties = prepareProperties( properties, workingVars );
 		if ( workingVars == null ) workingVars = CollectionHelper.EMPTY_MAP;
 
 		if ( preparedProperties.containsKey( AvailableSettings.CFG_FILE ) ) {
 			String cfgFileName = preparedProperties.getProperty( AvailableSettings.CFG_FILE );
 			cfg.configure( cfgFileName );
 		}
 
 		cfg.addProperties( preparedProperties ); //persistence.xml has priority over hibernate.cfg.xml
 
 		addClassesToSessionFactory( workingVars );
 
 		//processes specific properties
 		List<String> jaccKeys = new ArrayList<String>();
 
 
 		Interceptor defaultInterceptor = DEFAULT_CONFIGURATION.getInterceptor();
 		NamingStrategy defaultNamingStrategy = DEFAULT_CONFIGURATION.getNamingStrategy();
 
 		Iterator propertyIt = preparedProperties.keySet().iterator();
 		while ( propertyIt.hasNext() ) {
 			Object uncastObject = propertyIt.next();
 			//had to be safe
 			if ( uncastObject != null && uncastObject instanceof String ) {
 				String propertyKey = (String) uncastObject;
 				if ( propertyKey.startsWith( AvailableSettings.CLASS_CACHE_PREFIX ) ) {
 					setCacheStrategy( propertyKey, preparedProperties, true, workingVars );
 				}
 				else if ( propertyKey.startsWith( AvailableSettings.COLLECTION_CACHE_PREFIX ) ) {
 					setCacheStrategy( propertyKey, preparedProperties, false, workingVars );
 				}
 				else if ( propertyKey.startsWith( AvailableSettings.JACC_PREFIX )
 						&& ! ( propertyKey.equals( AvailableSettings.JACC_CONTEXT_ID )
 						|| propertyKey.equals( AvailableSettings.JACC_ENABLED ) ) ) {
 					jaccKeys.add( propertyKey );
 				}
 			}
 		}
 		final Interceptor interceptor = instantiateCustomClassFromConfiguration(
 				preparedProperties,
 				defaultInterceptor,
 				cfg.getInterceptor(),
 				AvailableSettings.INTERCEPTOR,
 				"interceptor",
 				Interceptor.class
 		);
 		if ( interceptor != null ) {
 			cfg.setInterceptor( interceptor );
 		}
 		final NamingStrategy namingStrategy = instantiateCustomClassFromConfiguration(
 				preparedProperties,
 				defaultNamingStrategy,
 				cfg.getNamingStrategy(),
 				AvailableSettings.NAMING_STRATEGY,
 				"naming strategy",
 				NamingStrategy.class
 		);
 		if ( namingStrategy != null ) {
 			cfg.setNamingStrategy( namingStrategy );
 		}
 
 		final SessionFactoryObserver observer = instantiateCustomClassFromConfiguration(
 				preparedProperties,
 				null,
 				cfg.getSessionFactoryObserver(),
 				AvailableSettings.SESSION_FACTORY_OBSERVER,
 				"SessionFactory observer",
 				SessionFactoryObserver.class
 		);
 		if ( observer != null ) {
 			cfg.setSessionFactoryObserver( observer );
 		}
 
 		if ( jaccKeys.size() > 0 ) {
 			addSecurity( jaccKeys, preparedProperties, workingVars );
 		}
 
 		//some spec compliance checking
 		//TODO centralize that?
         if (!"true".equalsIgnoreCase(cfg.getProperty(Environment.AUTOCOMMIT))) LOG.jdbcAutoCommitFalseBreaksEjb3Spec(Environment.AUTOCOMMIT);
         discardOnClose = preparedProperties.getProperty(AvailableSettings.DISCARD_PC_ON_CLOSE).equals("true");
 		return this;
 	}
 
 	private <T> T instantiateCustomClassFromConfiguration(
 			Properties preparedProperties,
 			T defaultObject,
 			T cfgObject,
 			String propertyName,
 			String classDescription,
 			Class<T> objectClass) {
 		if ( preparedProperties.containsKey( propertyName )
 				&& ( cfgObject == null || cfgObject.equals( defaultObject ) ) ) {
 			//cfg.setXxx has precedence over configuration file
 			String className = preparedProperties.getProperty( propertyName );
 			try {
 				Class<T> clazz = classForName( className );
 				return clazz.newInstance();
 				//cfg.setInterceptor( (Interceptor) instance.newInstance() );
 			}
 			catch (ClassNotFoundException e) {
 				throw new PersistenceException(
 						getExceptionHeader() + "Unable to find " + classDescription + " class: " + className, e
 				);
 			}
 			catch (IllegalAccessException e) {
 				throw new PersistenceException(
 						getExceptionHeader() + "Unable to access " + classDescription + " class: " + className, e
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3AutoFlushEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3AutoFlushEventListener.java
index a148444256..55304ffe27 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3AutoFlushEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3AutoFlushEventListener.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import org.hibernate.engine.spi.CascadingAction;
-import org.hibernate.event.AutoFlushEventListener;
-import org.hibernate.event.def.DefaultAutoFlushEventListener;
+import org.hibernate.event.spi.AutoFlushEventListener;
+import org.hibernate.event.internal.DefaultAutoFlushEventListener;
 import org.hibernate.internal.util.collections.IdentityMap;
 
 /**
  * In JPA, it is the create operation that is cascaded to unmanaged entities at flush time (instead of the save-update
  * operation in Hibernate).
  *
  * @author Gavin King
  */
 public class EJB3AutoFlushEventListener
 		extends DefaultAutoFlushEventListener
 		implements HibernateEntityManagerEventListener {
 
 	public static final AutoFlushEventListener INSTANCE = new EJB3AutoFlushEventListener();
 
 	protected CascadingAction getCascadingAction() {
 		return CascadingAction.PERSIST_ON_FLUSH;
 	}
 
 	protected Object getAnything() {
 		return IdentityMap.instantiate( 10 );
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
index 41ebf052c1..aac071fe3c 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.io.Serializable;
 
-import org.hibernate.event.DeleteEvent;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.def.DefaultDeleteEventListener;
+import org.hibernate.event.spi.DeleteEvent;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.internal.DefaultDeleteEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PreRemove operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3DeleteEventListener extends DefaultDeleteEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3DeleteEventListener() {
 		super();
 	}
 
 	public EJB3DeleteEventListener(EntityCallbackHandler callbackHandler) {
 		this();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected boolean invokeDeleteLifecycle(EventSource session, Object entity, EntityPersister persister) {
 		callbackHandler.preRemove( entity );
 		return super.invokeDeleteLifecycle( session, entity, persister );
 	}
 
 	@Override
 	protected void performDetachedEntityDeletionCheck(DeleteEvent event) {
 		EventSource source = event.getSession();
 		String entityName = event.getEntityName();
 		EntityPersister persister = source.getEntityPersister( entityName, event.getObject() );
 		Serializable id =  persister.getIdentifier( event.getObject(), source );
 		entityName = entityName == null ? source.guessEntityName( event.getObject() ) : entityName; 
 		throw new IllegalArgumentException("Removing a detached instance "+ entityName + "#" + id);
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEntityEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEntityEventListener.java
index 4a2e291ba7..3a3aef899e 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEntityEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEntityEventListener.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import org.hibernate.EntityMode;
 import org.hibernate.SessionFactory;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.def.DefaultFlushEntityEventListener;
+import org.hibernate.event.internal.DefaultFlushEntityEventListener;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.type.Type;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PreUpdate operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3FlushEntityEventListener extends DefaultFlushEntityEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3FlushEntityEventListener() {
 		super();
 	}
 
 	public EJB3FlushEntityEventListener(EntityCallbackHandler callbackHandler) {
 		super();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected boolean invokeInterceptor(
 			SessionImplementor session,
 			Object entity,
 			EntityEntry entry,
 			Object[] values,
 			EntityPersister persister) {
 		boolean isDirty = false;
 		if ( entry.getStatus() != Status.DELETED ) {
 			if ( callbackHandler.preUpdate( entity ) ) {
 				isDirty = copyState( entity, persister.getPropertyTypes(), values, session.getFactory() );
 			}
 		}
 		return super.invokeInterceptor( session, entity, entry, values, persister ) || isDirty;
 	}
 
 	private boolean copyState(Object entity, Type[] types, Object[] state, SessionFactory sf) {
 		// copy the entity state into the state array and return true if the state has changed
 		ClassMetadata metadata = sf.getClassMetadata( entity.getClass() );
 		Object[] newState = metadata.getPropertyValues( entity, EntityMode.POJO );
 		int size = newState.length;
 		boolean isDirty = false;
 		for ( int index = 0; index < size ; index++ ) {
 			if ( !types[index].isEqual( state[index], newState[index], EntityMode.POJO ) ) {
 				isDirty = true;
 				state[index] = newState[index];
 			}
 		}
 		return isDirty;
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEventListener.java
index b308dc2ab9..50e74c41eb 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3FlushEventListener.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import org.hibernate.engine.spi.CascadingAction;
-import org.hibernate.event.FlushEventListener;
-import org.hibernate.event.def.DefaultFlushEventListener;
+import org.hibernate.event.spi.FlushEventListener;
+import org.hibernate.event.internal.DefaultFlushEventListener;
 import org.hibernate.internal.util.collections.IdentityMap;
 
 /**
  * In EJB3, it is the create operation that is cascaded to unmanaged entities at flush time (instead of the
  * save-update operation in Hibernate).
  *
  * @author Gavin King
  */
 public class EJB3FlushEventListener extends DefaultFlushEventListener implements HibernateEntityManagerEventListener {
 
 	public static final FlushEventListener INSTANCE = new EJB3FlushEventListener();
 
 	protected CascadingAction getCascadingAction() {
 		return CascadingAction.PERSIST_ON_FLUSH;
 	}
 
 	protected Object getAnything() {
 		return IdentityMap.instantiate( 10 );
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3MergeEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3MergeEventListener.java
index 4511657515..faad5ee22c 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3MergeEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3MergeEventListener.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventSource;
-import org.hibernate.event.def.DefaultMergeEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.internal.DefaultMergeEventListener;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PrePersist operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3MergeEventListener extends DefaultMergeEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3MergeEventListener() {
 		super();
 	}
 
 	public EJB3MergeEventListener(EntityCallbackHandler callbackHandler) {
 		super();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithRequestedId( entity, requestedId, entityName, anything, source );
 	}
 
 	@Override
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PersistEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PersistEventListener.java
index d4ac6a38a0..20b21b259b 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PersistEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PersistEventListener.java
@@ -1,85 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.io.Serializable;
 
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.EJB3CascadeStyle;
 import org.hibernate.engine.spi.EJB3CascadingAction;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.def.DefaultPersistEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.internal.DefaultPersistEventListener;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PrePersist operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3PersistEventListener extends DefaultPersistEventListener implements CallbackHandlerConsumer {
 	static {
 		EJB3CascadeStyle.PERSIST_EJB3.hasOrphanDelete(); //triggers class loading to override persist with PERSIST_EJB3
 	}
 
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3PersistEventListener() {
 		super();
 	}
 
 	public EJB3PersistEventListener(EntityCallbackHandler callbackHandler) {
 		super();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithRequestedId( entity, requestedId, entityName, anything, source );
 	}
 
 	@Override
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
 	}
 
 	@Override
 	protected CascadingAction getCascadeAction() {
 		return EJB3CascadingAction.PERSIST_SKIPLAZY;
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostDeleteEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostDeleteEventListener.java
index 868d754dd8..1616fe802d 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostDeleteEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostDeleteEventListener.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
-import org.hibernate.event.PostDeleteEvent;
-import org.hibernate.event.PostDeleteEventListener;
+import org.hibernate.event.spi.PostDeleteEvent;
+import org.hibernate.event.spi.PostDeleteEventListener;
 
 /**
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 public class EJB3PostDeleteEventListener implements PostDeleteEventListener, CallbackHandlerConsumer {
 	EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3PostDeleteEventListener() {
 		super();
 	}
 
 	public EJB3PostDeleteEventListener(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public void onPostDelete(PostDeleteEvent event) {
 		Object entity = event.getEntity();
 		callbackHandler.postRemove( entity );
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostInsertEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostInsertEventListener.java
index 091c5a6ae5..590afd58b0 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostInsertEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostInsertEventListener.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
-import org.hibernate.event.PostInsertEvent;
-import org.hibernate.event.PostInsertEventListener;
+import org.hibernate.event.spi.PostInsertEvent;
+import org.hibernate.event.spi.PostInsertEventListener;
 
 /**
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 public class EJB3PostInsertEventListener implements PostInsertEventListener, CallbackHandlerConsumer {
 	EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3PostInsertEventListener() {
 		super();
 	}
 
 	public EJB3PostInsertEventListener(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public void onPostInsert(PostInsertEvent event) {
 		Object entity = event.getEntity();
 		callbackHandler.postCreate( entity );
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostLoadEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostLoadEventListener.java
index f1a599829c..62e96f62e3 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostLoadEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostLoadEventListener.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
-import org.hibernate.event.PostLoadEvent;
-import org.hibernate.event.PostLoadEventListener;
+import org.hibernate.event.spi.PostLoadEvent;
+import org.hibernate.event.spi.PostLoadEventListener;
 
 /**
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 public class EJB3PostLoadEventListener implements PostLoadEventListener, CallbackHandlerConsumer {
 	EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3PostLoadEventListener() {
 		super();
 	}
 
 	public EJB3PostLoadEventListener(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public void onPostLoad(PostLoadEvent event) {
 		Object entity = event.getEntity();
 		callbackHandler.postLoad( entity );
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostUpdateEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostUpdateEventListener.java
index ea6b81b011..8a6cd90ec9 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostUpdateEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3PostUpdateEventListener.java
@@ -1,96 +1,96 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.Status;
-import org.hibernate.event.EventSource;
-import org.hibernate.event.PostCollectionRecreateEvent;
-import org.hibernate.event.PostCollectionRecreateEventListener;
-import org.hibernate.event.PostCollectionRemoveEvent;
-import org.hibernate.event.PostCollectionRemoveEventListener;
-import org.hibernate.event.PostCollectionUpdateEvent;
-import org.hibernate.event.PostCollectionUpdateEventListener;
-import org.hibernate.event.PostUpdateEvent;
-import org.hibernate.event.PostUpdateEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.spi.PostCollectionRecreateEvent;
+import org.hibernate.event.spi.PostCollectionRecreateEventListener;
+import org.hibernate.event.spi.PostCollectionRemoveEvent;
+import org.hibernate.event.spi.PostCollectionRemoveEventListener;
+import org.hibernate.event.spi.PostCollectionUpdateEvent;
+import org.hibernate.event.spi.PostCollectionUpdateEventListener;
+import org.hibernate.event.spi.PostUpdateEvent;
+import org.hibernate.event.spi.PostUpdateEventListener;
 
 /**
  * Implementation of the post update listeners.
  * 
  * @author <a href="mailto:kabir.khan@jboss.org">Kabir Khan</a>
  */
 @SuppressWarnings("serial")
 public class EJB3PostUpdateEventListener
 		implements PostUpdateEventListener,
 				   CallbackHandlerConsumer,
 				   PostCollectionRecreateEventListener,
 				   PostCollectionRemoveEventListener,
 				   PostCollectionUpdateEventListener {
 	EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3PostUpdateEventListener() {
 		super();
 	}
 
 	public EJB3PostUpdateEventListener(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public void onPostUpdate(PostUpdateEvent event) {
 		Object entity = event.getEntity();
 		EventSource eventSource = event.getSession();
 		handlePostUpdate(entity, eventSource);
 	}
 
 	private void handlePostUpdate(Object entity, EventSource source) {
 		EntityEntry entry = (EntityEntry) source.getPersistenceContext()
 				.getEntityEntries().get(entity);
 		// mimic the preUpdate filter
 		if ( Status.DELETED != entry.getStatus()) {
 			callbackHandler.postUpdate(entity);
 		}
 	}
 
 	public void onPostRecreateCollection(PostCollectionRecreateEvent event) {
 		Object entity = event.getCollection().getOwner();
 		EventSource eventSource = event.getSession();
 		handlePostUpdate(entity, eventSource);
 	}
 
 	public void onPostRemoveCollection(PostCollectionRemoveEvent event) {
 		Object entity = event.getCollection().getOwner();
 		EventSource eventSource = event.getSession();
 		handlePostUpdate(entity, eventSource);		
 	}
 
 	public void onPostUpdateCollection(PostCollectionUpdateEvent event) {
 		Object entity = event.getCollection().getOwner();
 		EventSource eventSource = event.getSession();
 		handlePostUpdate(entity, eventSource);		
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveEventListener.java
index 07a4ac899f..3df780c6aa 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveEventListener.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventSource;
-import org.hibernate.event.def.DefaultSaveEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.internal.DefaultSaveEventListener;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PrePersist operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3SaveEventListener extends DefaultSaveEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3SaveEventListener() {
 		super();
 	}
 
 	public EJB3SaveEventListener(EntityCallbackHandler callbackHandler) {
 		super();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithRequestedId( entity, requestedId, entityName, anything, source );
 	}
 
 	@Override
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveOrUpdateEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveOrUpdateEventListener.java
index 36305f8fa3..c84892e9c9 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveOrUpdateEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3SaveOrUpdateEventListener.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.io.Serializable;
 
-import org.hibernate.event.EventSource;
-import org.hibernate.event.def.DefaultSaveOrUpdateEventListener;
+import org.hibernate.event.spi.EventSource;
+import org.hibernate.event.internal.DefaultSaveOrUpdateEventListener;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PrePersist operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3SaveOrUpdateEventListener extends DefaultSaveOrUpdateEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3SaveOrUpdateEventListener() {
 		super();
 	}
 
 	public EJB3SaveOrUpdateEventListener(EntityCallbackHandler callbackHandler) {
 		super();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithRequestedId( entity, requestedId, entityName, anything, source );
 	}
 
 	@Override
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		callbackHandler.preCreate( entity );
 		return super.saveWithGeneratedId( entity, entityName, anything, source, requiresImmediateIdAccess );
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/JpaIntegrator.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/JpaIntegrator.java
index 0e1da557f4..8f7ed77e39 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/JpaIntegrator.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/JpaIntegrator.java
@@ -1,175 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.cfg.Configuration;
+import org.hibernate.cfg.Environment;
 import org.hibernate.ejb.AvailableSettings;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PreDeleteEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.secure.JACCPreDeleteEventListener;
-import org.hibernate.secure.JACCPreInsertEventListener;
-import org.hibernate.secure.JACCPreLoadEventListener;
-import org.hibernate.secure.JACCPreUpdateEventListener;
-import org.hibernate.secure.JACCSecurityListener;
+import org.hibernate.secure.internal.JACCPreDeleteEventListener;
+import org.hibernate.secure.internal.JACCPreInsertEventListener;
+import org.hibernate.secure.internal.JACCPreLoadEventListener;
+import org.hibernate.secure.internal.JACCPreUpdateEventListener;
+import org.hibernate.secure.internal.JACCSecurityListener;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Prepare the HEM-specific event listeners.
  * 
  * @author Steve Ebersole
  */
 public class JpaIntegrator implements Integrator {
 	private static final DuplicationStrategy JPA_DUPLICATION_STRATEGY = new DuplicationStrategy() {
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			return listener.getClass().equals( original.getClass() ) &&
 					HibernateEntityManagerEventListener.class.isInstance( original );
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	};
 
 	private static final DuplicationStrategy JACC_DUPLICATION_STRATEGY = new DuplicationStrategy() {
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			return listener.getClass().equals( original.getClass() ) &&
 					JACCSecurityListener.class.isInstance( original );
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	};
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 
 		boolean isSecurityEnabled = configuration.getProperties().containsKey( AvailableSettings.JACC_ENABLED );
 
 		eventListenerRegistry.addDuplicationStrategy( JPA_DUPLICATION_STRATEGY );
 		eventListenerRegistry.addDuplicationStrategy( JACC_DUPLICATION_STRATEGY );
 
 		// op listeners
 		eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, EJB3AutoFlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.DELETE, new EJB3DeleteEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, new EJB3FlushEntityEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH, EJB3FlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.MERGE, new EJB3MergeEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST, new EJB3PersistEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST_ONFLUSH, new EJB3PersistOnFlushEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE, new EJB3SaveEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE_UPDATE, new EJB3SaveOrUpdateEventListener() );
 
 		// pre op listeners
 		if ( isSecurityEnabled ) {
-			eventListenerRegistry.prependListeners( EventType.PRE_DELETE, new JACCPreDeleteEventListener() );
-			eventListenerRegistry.prependListeners( EventType.PRE_INSERT, new JACCPreInsertEventListener() );
-			eventListenerRegistry.prependListeners( EventType.PRE_UPDATE, new JACCPreUpdateEventListener() );
-			eventListenerRegistry.prependListeners( EventType.PRE_LOAD, new JACCPreLoadEventListener() );
+			final String jaccContextId = configuration.getProperty( Environment.JACC_CONTEXTID );
+			eventListenerRegistry.prependListeners( EventType.PRE_DELETE, new JACCPreDeleteEventListener(jaccContextId) );
+			eventListenerRegistry.prependListeners( EventType.PRE_INSERT, new JACCPreInsertEventListener(jaccContextId) );
+			eventListenerRegistry.prependListeners( EventType.PRE_UPDATE, new JACCPreUpdateEventListener(jaccContextId) );
+			eventListenerRegistry.prependListeners( EventType.PRE_LOAD, new JACCPreLoadEventListener(jaccContextId) );
 		}
 
 		// post op listeners
 		eventListenerRegistry.prependListeners( EventType.POST_DELETE, new EJB3PostDeleteEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_INSERT, new EJB3PostInsertEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_LOAD, new EJB3PostLoadEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_UPDATE, new EJB3PostUpdateEventListener() );
 
 		for ( Map.Entry<?,?> entry : configuration.getProperties().entrySet() ) {
 			if ( ! String.class.isInstance( entry.getKey() ) ) {
 				continue;
 			}
 			final String propertyName = (String) entry.getKey();
 			if ( ! propertyName.startsWith( AvailableSettings.EVENT_LISTENER_PREFIX ) ) {
 				continue;
 			}
 			final String eventTypeName = propertyName.substring( AvailableSettings.EVENT_LISTENER_PREFIX.length() + 1 );
 			final EventType eventType = EventType.resolveEventTypeByName( eventTypeName );
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( String listenerImpl : ( (String) entry.getValue() ).split( " ," ) ) {
 				eventListenerGroup.appendListener( instantiate( listenerImpl, serviceRegistry ) );
 			}
 		}
 
 		final EntityCallbackHandler callbackHandler = new EntityCallbackHandler();
 		Iterator classes = configuration.getClassMappings();
 		ReflectionManager reflectionManager = configuration.getReflectionManager();
 		while ( classes.hasNext() ) {
 			PersistentClass clazz = (PersistentClass) classes.next();
 			if ( clazz.getClassName() == null ) {
 				//we can have non java class persisted by hibernate
 				continue;
 			}
 			try {
 				callbackHandler.add( reflectionManager.classForName( clazz.getClassName(), this.getClass() ), reflectionManager );
 			}
 			catch (ClassNotFoundException e) {
 				throw new MappingException( "entity class not found: " + clazz.getNodeName(), e );
 			}
 		}
 
 		for ( EventType eventType : EventType.values() ) {
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( Object listener : eventListenerGroup.listeners() ) {
 				if ( CallbackHandlerConsumer.class.isInstance( listener ) ) {
 					( (CallbackHandlerConsumer) listener ).setCallbackHandler( callbackHandler );
 				}
 			}
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 	}
 
 	private Object instantiate(String listenerImpl, ServiceRegistryImplementor serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( listenerImpl ).newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not instantiate requested listener [" + listenerImpl + "]", e );
 		}
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/engine/spi/EJB3CascadingAction.java b/hibernate-entitymanager/src/main/java/org/hibernate/engine/spi/EJB3CascadingAction.java
index 0ab9961ac7..e3e681dce1 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/engine/spi/EJB3CascadingAction.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/engine/spi/EJB3CascadingAction.java
@@ -1,70 +1,70 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 import java.util.Iterator;
 import java.util.Map;
 import org.hibernate.HibernateException;
 import org.hibernate.ejb.internal.EntityManagerMessageLogger;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.CollectionType;
 import org.jboss.logging.Logger;
 
 /**
  * Because of CascadingAction constructor visibility
  * I need a packaged friendly subclass
  * TODO Get rid of it for 3.3
  * @author Emmanuel Bernard
  */
 public abstract class EJB3CascadingAction extends CascadingAction {
 
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(EntityManagerMessageLogger.class,
                                                                            EJB3CascadingAction.class.getName());
 	/**
 	 * @see org.hibernate.Session#persist(Object)
 	 */
 	public static final CascadingAction PERSIST_SKIPLAZY = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to persist: " + entityName);
 			session.persist( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// persists don't cascade to uninitialized collections
 			return CascadingAction.getLoadedElementsIterator( session, collectionType, collection );
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_PERSIST_SKIPLAZY";
 		}
 	};
 
 }
diff --git a/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/NoOpListener.java b/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/NoOpListener.java
index 5e04cf5ba7..b91c9f5899 100644
--- a/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/NoOpListener.java
+++ b/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/NoOpListener.java
@@ -1,13 +1,13 @@
 //$Id$
 package org.hibernate.ejb.test;
-import org.hibernate.event.PreInsertEvent;
-import org.hibernate.event.PreInsertEventListener;
+import org.hibernate.event.spi.PreInsertEvent;
+import org.hibernate.event.spi.PreInsertEventListener;
 
 /**
  * @author Emmanuel Bernard
  */
 public class NoOpListener implements PreInsertEventListener {
 	public boolean onPreInsert(PreInsertEvent event) {
 		return false;
 	}
 }
diff --git a/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/packaging/PackagedEntityManagerTest.java b/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/packaging/PackagedEntityManagerTest.java
index 10cf1659af..f7821f21c7 100644
--- a/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/packaging/PackagedEntityManagerTest.java
+++ b/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/packaging/PackagedEntityManagerTest.java
@@ -1,487 +1,487 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.test.packaging;
 
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.Persistence;
 import javax.persistence.PersistenceException;
 import java.io.File;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Properties;
 
 import org.hibernate.ejb.AvailableSettings;
 import org.hibernate.ejb.HibernateEntityManagerFactory;
 import org.hibernate.ejb.test.Distributor;
 import org.hibernate.ejb.test.Item;
 import org.hibernate.ejb.test.pack.cfgxmlpar.Morito;
 import org.hibernate.ejb.test.pack.defaultpar.ApplicationServer;
 import org.hibernate.ejb.test.pack.defaultpar.IncrementListener;
 import org.hibernate.ejb.test.pack.defaultpar.Lighter;
 import org.hibernate.ejb.test.pack.defaultpar.Money;
 import org.hibernate.ejb.test.pack.defaultpar.Mouse;
 import org.hibernate.ejb.test.pack.defaultpar.OtherIncrementListener;
 import org.hibernate.ejb.test.pack.defaultpar.Version;
 import org.hibernate.ejb.test.pack.defaultpar_1_0.ApplicationServer1;
 import org.hibernate.ejb.test.pack.defaultpar_1_0.Lighter1;
 import org.hibernate.ejb.test.pack.defaultpar_1_0.Mouse1;
 import org.hibernate.ejb.test.pack.defaultpar_1_0.Version1;
 import org.hibernate.ejb.test.pack.excludehbmpar.Caipirinha;
 import org.hibernate.ejb.test.pack.explodedpar.Carpet;
 import org.hibernate.ejb.test.pack.explodedpar.Elephant;
 import org.hibernate.ejb.test.pack.externaljar.Scooter;
 import org.hibernate.ejb.test.pack.spacepar.Bug;
 import org.hibernate.ejb.test.pack.various.Airplane;
 import org.hibernate.ejb.test.pack.various.Seat;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.event.EventType;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.stat.Statistics;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * In this test we verify that  it is possible to bootstrap Hibernate/JPA from
  * various bundles (war, par, ...) using {@code Persistence.createEntityManagerFactory()}
  * <p/>
  * Each test will before its run build the required bundle and place them into the classpath.
  *
  * @author Gavin King
  * @author Hardy Ferentschik
  */
 @SuppressWarnings("unchecked")
 public class PackagedEntityManagerTest extends PackagingTestCase {
 	@Test
 	public void testDefaultPar() throws Exception {
 		File testPackage = buildDefaultPar();
 		addPackageToClasspath( testPackage );
 
 		// run the test
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "defaultpar", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		ApplicationServer as = new ApplicationServer();
 		as.setName( "JBoss AS" );
 		Version v = new Version();
 		v.setMajor( 4 );
 		v.setMinor( 0 );
 		v.setMicro( 3 );
 		as.setVersion( v );
 		Mouse mouse = new Mouse();
 		mouse.setName( "mickey" );
 		em.getTransaction().begin();
 		em.persist( as );
 		em.persist( mouse );
 		assertEquals( 1, em.createNamedQuery( "allMouse" ).getResultList().size() );
 		Lighter lighter = new Lighter();
 		lighter.name = "main";
 		lighter.power = " 250 W";
 		em.persist( lighter );
 		em.flush();
 		em.remove( lighter );
 		em.remove( mouse );
 		assertNotNull( as.getId() );
 		em.remove( as );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testDefaultParForPersistence_1_0() throws Exception {
 		File testPackage = buildDefaultPar_1_0();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "defaultpar_1_0", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		ApplicationServer1 as = new ApplicationServer1();
 		as.setName( "JBoss AS" );
 		Version1 v = new Version1();
 		v.setMajor( 4 );
 		v.setMinor( 0 );
 		v.setMicro( 3 );
 		as.setVersion( v );
 		Mouse1 mouse = new Mouse1();
 		mouse.setName( "mickey" );
 		em.getTransaction().begin();
 		em.persist( as );
 		em.persist( mouse );
 		assertEquals( 1, em.createNamedQuery( "allMouse_1_0" ).getResultList().size() );
 		Lighter1 lighter = new Lighter1();
 		lighter.name = "main";
 		lighter.power = " 250 W";
 		em.persist( lighter );
 		em.flush();
 		em.remove( lighter );
 		em.remove( mouse );
 		assertNotNull( as.getId() );
 		em.remove( as );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testListenersDefaultPar() throws Exception {
 		File testPackage = buildDefaultPar();
 		addPackageToClasspath( testPackage );
 
 		IncrementListener.reset();
 		OtherIncrementListener.reset();
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "defaultpar", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		em.getTransaction().begin();
 		ApplicationServer as = new ApplicationServer();
 		as.setName( "JBoss AS" );
 		Version v = new Version();
 		v.setMajor( 4 );
 		v.setMinor( 0 );
 		v.setMicro( 3 );
 		as.setVersion( v );
 		em.persist( as );
 		em.flush();
 		assertEquals( "Failure in default listeners", 1, IncrementListener.getIncrement() );
 		assertEquals( "Failure in XML overriden listeners", 1, OtherIncrementListener.getIncrement() );
 
 		Mouse mouse = new Mouse();
 		mouse.setName( "mickey" );
 		em.persist( mouse );
 		em.flush();
 		assertEquals( "Failure in @ExcludeDefaultListeners", 1, IncrementListener.getIncrement() );
 		assertEquals( 1, OtherIncrementListener.getIncrement() );
 
 		Money money = new Money();
 		em.persist( money );
 		em.flush();
 		assertEquals( "Failure in @ExcludeDefaultListeners", 2, IncrementListener.getIncrement() );
 		assertEquals( 1, OtherIncrementListener.getIncrement() );
 
 		em.getTransaction().rollback();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testExplodedPar() throws Exception {
 		File testPackage = buildExplodedPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "explodedpar", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		org.hibernate.ejb.test.pack.explodedpar.Carpet carpet = new Carpet();
 		Elephant el = new Elephant();
 		el.setName( "Dumbo" );
 		carpet.setCountry( "Turkey" );
 		em.getTransaction().begin();
 		em.persist( carpet );
 		em.persist( el );
 		assertEquals( 1, em.createNamedQuery( "allCarpet" ).getResultList().size() );
 		assertNotNull( carpet.getId() );
 		em.remove( carpet );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testExcludeHbmPar() throws Exception {
 		File testPackage = buildExcludeHbmPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = null;
 		try {
 			emf = Persistence.createEntityManagerFactory( "excludehbmpar", new HashMap() );
 		}
 		catch ( PersistenceException e ) {
 			Throwable nested = e.getCause();
 			if ( nested == null ) {
 				throw e;
 			}
 			nested = nested.getCause();
 			if ( nested == null ) {
 				throw e;
 			}
 			if ( !( nested instanceof ClassNotFoundException ) ) {
 				throw e;
 			}
 			fail( "Try to process hbm file: " + e.getMessage() );
 		}
 		EntityManager em = emf.createEntityManager();
 		Caipirinha s = new Caipirinha( "Strong" );
 		em.getTransaction().begin();
 		em.persist( s );
 		em.getTransaction().commit();
 
 		em.getTransaction().begin();
 		s = em.find( Caipirinha.class, s.getId() );
 		em.remove( s );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testCfgXmlPar() throws Exception {
 		File testPackage = buildCfgXmlPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "cfgxmlpar", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		Item i = new Item();
 		i.setDescr( "Blah" );
 		i.setName( "factory" );
 		Morito m = new Morito();
 		m.setPower( "SuperStrong" );
 		em.getTransaction().begin();
 		em.persist( i );
 		em.persist( m );
 		em.getTransaction().commit();
 
 		em.getTransaction().begin();
 		i = em.find( Item.class, i.getName() );
 		em.remove( i );
 		em.remove( em.find( Morito.class, m.getId() ) );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testSpacePar() throws Exception {
 		File testPackage = buildSpacePar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "space par", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		Bug bug = new Bug();
 		bug.setSubject( "Spaces in directory name don't play well on Windows" );
 		em.getTransaction().begin();
 		em.persist( bug );
 		em.flush();
 		em.remove( bug );
 		assertNotNull( bug.getId() );
 		em.getTransaction().rollback();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testOverriddenPar() throws Exception {
 		File testPackage = buildOverridenPar();
 		addPackageToClasspath( testPackage );
 
 		HashMap properties = new HashMap();
 		properties.put( AvailableSettings.JTA_DATASOURCE, null );
 		Properties p = new Properties();
 		p.load( ConfigHelper.getResourceAsStream( "/overridenpar.properties" ) );
 		properties.putAll( p );
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "overridenpar", properties );
 		EntityManager em = emf.createEntityManager();
 		org.hibernate.ejb.test.pack.overridenpar.Bug bug = new org.hibernate.ejb.test.pack.overridenpar.Bug();
 		bug.setSubject( "Allow DS overriding" );
 		em.getTransaction().begin();
 		em.persist( bug );
 		em.flush();
 		em.remove( bug );
 		assertNotNull( bug.getId() );
 		em.getTransaction().rollback();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testListeners() throws Exception {
 		File testPackage = buildExplicitPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "manager1", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		EventListenerRegistry listenerRegistry = em.unwrap( SessionImplementor.class ).getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class );
 		assertEquals(
 				"Explicit pre-insert event through hibernate.ejb.event.pre-insert does not work",
 				listenerRegistry.getEventListenerGroup( EventType.PRE_INSERT ).count(),
 				listenerRegistry.getEventListenerGroup( EventType.PRE_UPDATE ).count() + 1
 		);
 
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testExtendedEntityManager() throws Exception {
 		File testPackage = buildExplicitPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "manager1", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		Item item = new Item( "Mouse", "Micro$oft mouse" );
 		em.getTransaction().begin();
 		em.persist( item );
 		assertTrue( em.contains( item ) );
 		em.getTransaction().commit();
 
 		assertTrue( em.contains( item ) );
 
 		em.getTransaction().begin();
 		Item item1 = (Item) em.createQuery( "select i from Item i where descr like 'M%'" ).getSingleResult();
 		assertNotNull( item1 );
 		assertSame( item, item1 );
 		item.setDescr( "Micro$oft wireless mouse" );
 		assertTrue( em.contains( item ) );
 		em.getTransaction().commit();
 
 		assertTrue( em.contains( item ) );
 
 		em.getTransaction().begin();
 		item1 = em.find( Item.class, "Mouse" );
 		assertSame( item, item1 );
 		em.getTransaction().commit();
 		assertTrue( em.contains( item ) );
 
 		item1 = em.find( Item.class, "Mouse" );
 		assertSame( item, item1 );
 		assertTrue( em.contains( item ) );
 
 		item1 = (Item) em.createQuery( "select i from Item i where descr like 'M%'" ).getSingleResult();
 		assertNotNull( item1 );
 		assertSame( item, item1 );
 		assertTrue( em.contains( item ) );
 
 		em.getTransaction().begin();
 		assertTrue( em.contains( item ) );
 		em.remove( item );
 		em.remove( item ); //second remove should be a no-op
 		em.getTransaction().commit();
 
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testConfiguration() throws Exception {
 		File testPackage = buildExplicitPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "manager1", new HashMap() );
 		Item item = new Item( "Mouse", "Micro$oft mouse" );
 		Distributor res = new Distributor();
 		res.setName( "Bruce" );
 		item.setDistributors( new HashSet<Distributor>() );
 		item.getDistributors().add( res );
 		Statistics stats = ( (HibernateEntityManagerFactory) emf ).getSessionFactory().getStatistics();
 		stats.clear();
 		stats.setStatisticsEnabled( true );
 
 		EntityManager em = emf.createEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( res );
 		em.persist( item );
 		assertTrue( em.contains( item ) );
 
 		em.getTransaction().commit();
 		em.close();
 
 		assertEquals( 1, stats.getSecondLevelCachePutCount() );
 		assertEquals( 0, stats.getSecondLevelCacheHitCount() );
 
 		em = emf.createEntityManager();
 		em.getTransaction().begin();
 		Item second = em.find( Item.class, item.getName() );
 		assertEquals( 1, second.getDistributors().size() );
 		assertEquals( 1, stats.getSecondLevelCacheHitCount() );
 		em.getTransaction().commit();
 		em.close();
 
 		em = emf.createEntityManager();
 		em.getTransaction().begin();
 		second = em.find( Item.class, item.getName() );
 		assertEquals( 1, second.getDistributors().size() );
 		assertEquals( 3, stats.getSecondLevelCacheHitCount() );
 		for ( Distributor distro : second.getDistributors() ) {
 			em.remove( distro );
 		}
 		em.remove( second );
 		em.getTransaction().commit();
 		em.close();
 
 		stats.clear();
 		stats.setStatisticsEnabled( false );
 		emf.close();
 	}
 
 	@Test
 	public void testExternalJar() throws Exception {
 		File externalJar = buildExternalJar();
 		File testPackage = buildExplicitPar();
 		addPackageToClasspath( testPackage, externalJar );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "manager1", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		Scooter s = new Scooter();
 		s.setModel( "Abadah" );
 		s.setSpeed( 85l );
 		em.getTransaction().begin();
 		em.persist( s );
 		em.getTransaction().commit();
 		em.close();
 		em = emf.createEntityManager();
 		em.getTransaction().begin();
 		s = em.find( Scooter.class, s.getModel() );
 		assertEquals( new Long( 85 ), s.getSpeed() );
 		em.remove( s );
 		em.getTransaction().commit();
 		em.close();
 		emf.close();
 	}
 
 	@Test
 	public void testORMFileOnMainAndExplicitJars() throws Exception {
 		File testPackage = buildExplicitPar();
 		addPackageToClasspath( testPackage );
 
 		EntityManagerFactory emf = Persistence.createEntityManagerFactory( "manager1", new HashMap() );
 		EntityManager em = emf.createEntityManager();
 		Seat seat = new Seat();
 		seat.setNumber( "3B" );
 		Airplane plane = new Airplane();
 		plane.setSerialNumber( "75924418409052355" );
 		em.getTransaction().begin();
 		em.persist( seat );
 		em.persist( plane );
 		em.flush();
 		em.getTransaction().rollback();
 		em.close();
 		emf.close();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java b/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
index 44d08ca1cd..a832bb7a21 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers;
 
 import javax.persistence.EntityManager;
 
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.event.EnversListener;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.reader.AuditReaderImpl;
-import org.hibernate.event.EventType;
-import org.hibernate.event.PostInsertEventListener;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class AuditReaderFactory {
     private AuditReaderFactory() { }
 
     /**
      * Create an audit reader associated with an open session.
      * @param session An open session.
      * @return An audit reader associated with the given sesison. It shouldn't be used
      * after the session is closed.
      * @throws AuditException When the given required listeners aren't installed.
      */
     public static AuditReader get(Session session) throws AuditException {
         SessionImplementor sessionImpl;
 		if (!(session instanceof SessionImplementor)) {
 			sessionImpl = (SessionImplementor) session.getSessionFactory().getCurrentSession();
 		} else {
 			sessionImpl = (SessionImplementor) session;
 		}
 
 		// todo : I wonder if there is a better means to do this via "named lookup" based on the session factory name/uuid
 		final EventListenerRegistry listenerRegistry = sessionImpl
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class );
 
 		for ( PostInsertEventListener listener : listenerRegistry.getEventListenerGroup( EventType.POST_INSERT ).listeners() ) {
 			if ( listener instanceof EnversListener ) {
 				// todo : slightly different from original code in that I am not checking the other listener groups...
 				return new AuditReaderImpl(
 						( (EnversListener) listener ).getAuditConfiguration(),
 						session,
 						sessionImpl
 				);
 			}
 		}
 
         throw new AuditException( "Envers listeners were not properly registered" );
     }
 
     /**
      * Create an audit reader associated with an open entity manager.
      * @param entityManager An open entity manager.
      * @return An audit reader associated with the given entity manager. It shouldn't be used
      * after the entity manager is closed.
      * @throws AuditException When the given entity manager is not based on Hibernate, or if the required
      * listeners aren't installed.
      */
     public static AuditReader get(EntityManager entityManager) throws AuditException {
         if (entityManager.getDelegate() instanceof Session) {
             return get((Session) entityManager.getDelegate());
         }
 
         if (entityManager.getDelegate() instanceof EntityManager) {
             return get((EntityManager) entityManager.getDelegate());
         }
 
         throw new AuditException("Hibernate EntityManager not present!");
     }
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversCollectionEventListener.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversCollectionEventListener.java
index 8bf86db05b..d0bae463f5 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversCollectionEventListener.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversCollectionEventListener.java
@@ -1,243 +1,243 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import java.io.Serializable;
 import java.util.List;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.envers.entities.EntityConfiguration;
 import org.hibernate.envers.entities.RelationDescription;
 import org.hibernate.envers.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.entities.mapper.id.IdMapper;
 import org.hibernate.envers.synchronization.AuditProcess;
 import org.hibernate.envers.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.synchronization.work.CollectionChangeWorkUnit;
 import org.hibernate.envers.synchronization.work.FakeBidirectionalRelationWorkUnit;
 import org.hibernate.envers.synchronization.work.PersistentCollectionChangeWorkUnit;
-import org.hibernate.event.AbstractCollectionEvent;
+import org.hibernate.event.spi.AbstractCollectionEvent;
 import org.hibernate.persister.collection.AbstractCollectionPersister;
 
 /**
  * Base class for Envers' collection event related listeners
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public abstract class BaseEnversCollectionEventListener extends BaseEnversEventListener {
 	protected BaseEnversCollectionEventListener(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
     protected final CollectionEntry getCollectionEntry(AbstractCollectionEvent event) {
         return event.getSession().getPersistenceContext().getCollectionEntry(event.getCollection());
     }
 
     protected final void onCollectionAction(
 			AbstractCollectionEvent event,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			CollectionEntry collectionEntry) {
         String entityName = event.getAffectedOwnerEntityName();
         if ( ! getAuditConfiguration().getGlobalCfg().isGenerateRevisionsForCollections() ) {
             return;
         }
         if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
             AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get(event.getSession());
 
             String ownerEntityName = ((AbstractCollectionPersister) collectionEntry.getLoadedPersister()).getOwnerEntityName();
             String referencingPropertyName = collectionEntry.getRole().substring(ownerEntityName.length() + 1);
 
             // Checking if this is not a "fake" many-to-one bidirectional relation. The relation description may be
             // null in case of collections of non-entities.
             RelationDescription rd = searchForRelationDescription( entityName, referencingPropertyName );
             if ( rd != null && rd.getMappedByPropertyName() != null ) {
                 generateFakeBidirecationalRelationWorkUnits(
 						auditProcess,
 						newColl,
 						oldColl,
 						entityName,
                         referencingPropertyName,
 						event,
 						rd
 				);
             }
 			else {
                 PersistentCollectionChangeWorkUnit workUnit = new PersistentCollectionChangeWorkUnit(
 						event.getSession(),
 						entityName,
 						getAuditConfiguration(),
 						newColl,
 						collectionEntry,
 						oldColl,
 						event.getAffectedOwnerIdOrNull(),
 						referencingPropertyName
 				);
 				auditProcess.addWorkUnit( workUnit );
 
                 if (workUnit.containsWork()) {
                     // There are some changes: a revision needs also be generated for the collection owner
                     auditProcess.addWorkUnit(
 							new CollectionChangeWorkUnit(
 									event.getSession(),
 									event.getAffectedOwnerEntityName(),
 									getAuditConfiguration(),
 									event.getAffectedOwnerIdOrNull(),
 									event.getAffectedOwnerOrNull()
 							)
 					);
 
                     generateBidirectionalCollectionChangeWorkUnits( auditProcess, event, workUnit, rd );
                 }
             }
         }
     }
 
     /**
      * Looks up a relation description corresponding to the given property in the given entity. If no description is
      * found in the given entity, the parent entity is checked (so that inherited relations work).
 	 *
      * @param entityName Name of the entity, in which to start looking.
      * @param referencingPropertyName The name of the property.
 	 * 
      * @return A found relation description corresponding to the given entity or {@code null}, if no description can
      * be found.
      */
     private RelationDescription searchForRelationDescription(String entityName, String referencingPropertyName) {
         EntityConfiguration configuration = getAuditConfiguration().getEntCfg().get( entityName );
         RelationDescription rd = configuration.getRelationDescription(referencingPropertyName);
         if ( rd == null && configuration.getParentEntityName() != null ) {
             return searchForRelationDescription( configuration.getParentEntityName(), referencingPropertyName );
         }
 
         return rd;
     }
 
     private void generateFakeBidirecationalRelationWorkUnits(
 			AuditProcess auditProcess,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			String collectionEntityName,
 			String referencingPropertyName,
 			AbstractCollectionEvent event,
 			RelationDescription rd) {
         // First computing the relation changes
         List<PersistentCollectionChangeData> collectionChanges = getAuditConfiguration()
 				.getEntCfg()
 				.get( collectionEntityName )
 				.getPropertyMapper()
                 .mapCollectionChanges( referencingPropertyName, newColl, oldColl, event.getAffectedOwnerIdOrNull() );
 
         // Getting the id mapper for the related entity, as the work units generated will corrspond to the related
         // entities.
         String relatedEntityName = rd.getToEntityName();
         IdMapper relatedIdMapper = getAuditConfiguration().getEntCfg().get(relatedEntityName).getIdMapper();
 
         // For each collection change, generating the bidirectional work unit.
         for ( PersistentCollectionChangeData changeData : collectionChanges ) {
             Object relatedObj = changeData.getChangedElement();
             Serializable relatedId = (Serializable) relatedIdMapper.mapToIdFromEntity(relatedObj);
             RevisionType revType = (RevisionType) changeData.getData().get(
 					getAuditConfiguration().getAuditEntCfg().getRevisionTypePropName()
 			);
 
             // This can be different from relatedEntityName, in case of inheritance (the real entity may be a subclass
             // of relatedEntityName).
             String realRelatedEntityName = event.getSession().bestGuessEntityName(relatedObj);
 
             // By default, the nested work unit is a collection change work unit.
             AuditWorkUnit nestedWorkUnit = new CollectionChangeWorkUnit(
 					event.getSession(),
 					realRelatedEntityName,
 					getAuditConfiguration(),
                     relatedId,
 					relatedObj
 			);
 
             auditProcess.addWorkUnit(
 					new FakeBidirectionalRelationWorkUnit(
 							event.getSession(),
 							realRelatedEntityName,
 							getAuditConfiguration(),
 							relatedId,
 							referencingPropertyName,
 							event.getAffectedOwnerOrNull(),
 							rd,
 							revType,
 							changeData.getChangedElementIndex(),
 							nestedWorkUnit
 					)
 			);
         }
 
         // We also have to generate a collection change work unit for the owning entity.
         auditProcess.addWorkUnit(
 				new CollectionChangeWorkUnit(
 						event.getSession(),
 						collectionEntityName,
 						getAuditConfiguration(),
 						event.getAffectedOwnerIdOrNull(),
 						event.getAffectedOwnerOrNull()
 				)
 		);
     }
 
     private void generateBidirectionalCollectionChangeWorkUnits(
 			AuditProcess auditProcess,
 			AbstractCollectionEvent event,
 			PersistentCollectionChangeWorkUnit workUnit,
 			RelationDescription rd) {
         // Checking if this is enabled in configuration ...
         if ( ! getAuditConfiguration().getGlobalCfg().isGenerateRevisionsForCollections() ) {
             return;
         }
 
         // Checking if this is not a bidirectional relation - then, a revision needs also be generated for
         // the other side of the relation.
         // relDesc can be null if this is a collection of simple values (not a relation).
         if ( rd != null && rd.isBidirectional() ) {
             String relatedEntityName = rd.getToEntityName();
             IdMapper relatedIdMapper = getAuditConfiguration().getEntCfg().get( relatedEntityName ).getIdMapper();
 
             for ( PersistentCollectionChangeData changeData : workUnit.getCollectionChanges() ) {
                 Object relatedObj = changeData.getChangedElement();
                 Serializable relatedId = (Serializable) relatedIdMapper.mapToIdFromEntity( relatedObj );
 
                 auditProcess.addWorkUnit(
 						new CollectionChangeWorkUnit(
 								event.getSession(),
 								relatedEntityName,
 								getAuditConfiguration(),
 								relatedId,
 								relatedObj
 						)
 				);
             }
         }
     }
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
index 03f4bd6472..ad1abf7e90 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.configuration.AuditConfiguration;
-import org.hibernate.event.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Provides integration for Envers into Hibernate, which mainly means registering the proper event listeners.
  * 
  * @author Steve Ebersole
  */
 public class EnversIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, EnversIntegrator.class.getName() );
 
 	public static final String AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		final boolean autoRegister = ConfigurationHelper.getBoolean( AUTO_REGISTER, configuration.getProperties(), true );
 		if ( !autoRegister ) {
 			LOG.debug( "Skipping Envers listener auto registration" );
 			return;
 		}
 
 		EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		listenerRegistry.addDuplicationStrategy( EnversListenerDuplicationStrategy.INSTANCE );
 
 		final AuditConfiguration enversConfiguration = AuditConfiguration.getFor( configuration );
 
         if (enversConfiguration.getEntCfg().hasAuditedEntities()) {
 		    listenerRegistry.appendListeners( EventType.POST_DELETE, new EnversPostDeleteEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_INSERT, new EnversPostInsertEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_UPDATE, new EnversPostUpdateEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_COLLECTION_RECREATE, new EnversPostCollectionRecreateEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.PRE_COLLECTION_REMOVE, new EnversPreCollectionRemoveEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.PRE_COLLECTION_UPDATE, new EnversPreCollectionUpdateEventListenerImpl( enversConfiguration ) );
         }
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do afaik
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostCollectionRecreateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostCollectionRecreateEventListenerImpl.java
index f54fe2e2ef..e5bfa9f651 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostCollectionRecreateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostCollectionRecreateEventListenerImpl.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.envers.configuration.AuditConfiguration;
-import org.hibernate.event.PostCollectionRecreateEvent;
-import org.hibernate.event.PostCollectionRecreateEventListener;
+import org.hibernate.event.spi.PostCollectionRecreateEvent;
+import org.hibernate.event.spi.PostCollectionRecreateEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostCollectionRecreateEventListenerImpl
 		extends  BaseEnversCollectionEventListener
 		implements PostCollectionRecreateEventListener {
 
 	protected EnversPostCollectionRecreateEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
 	@Override
 	public void onPostRecreateCollection(PostCollectionRecreateEvent event) {
         CollectionEntry collectionEntry = getCollectionEntry( event );
         if ( ! collectionEntry.getLoadedPersister().isInverse() ) {
             onCollectionAction( event, event.getCollection(), null, collectionEntry );
         }
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostDeleteEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostDeleteEventListenerImpl.java
index c1123e39e9..5f9743fb07 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostDeleteEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostDeleteEventListenerImpl.java
@@ -1,72 +1,72 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.envers.synchronization.AuditProcess;
 import org.hibernate.envers.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.synchronization.work.DelWorkUnit;
-import org.hibernate.event.PostDeleteEvent;
-import org.hibernate.event.PostDeleteEventListener;
+import org.hibernate.event.spi.PostDeleteEvent;
+import org.hibernate.event.spi.PostDeleteEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostDeleteEventListenerImpl extends BaseEnversEventListener implements PostDeleteEventListener {
 	protected EnversPostDeleteEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
 	@Override
 	public void onPostDelete(PostDeleteEvent event) {
         String entityName = event.getPersister().getEntityName();
 
         if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
             AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get( event.getSession() );
 
             AuditWorkUnit workUnit = new DelWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
 					getAuditConfiguration(),
                     event.getId(),
 					event.getPersister(),
 					event.getDeletedState()
 			);
             auditProcess.addWorkUnit( workUnit );
 
             if ( workUnit.containsWork() ) {
                 generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						null,
                         event.getDeletedState(),
 						event.getSession()
 				);
 			}
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostInsertEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostInsertEventListenerImpl.java
index 2e05712703..de12d032e1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostInsertEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostInsertEventListenerImpl.java
@@ -1,71 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.envers.synchronization.AuditProcess;
 import org.hibernate.envers.synchronization.work.AddWorkUnit;
 import org.hibernate.envers.synchronization.work.AuditWorkUnit;
-import org.hibernate.event.PostInsertEvent;
-import org.hibernate.event.PostInsertEventListener;
+import org.hibernate.event.spi.PostInsertEvent;
+import org.hibernate.event.spi.PostInsertEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostInsertEventListenerImpl extends BaseEnversEventListener implements PostInsertEventListener {
 	public EnversPostInsertEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
     public void onPostInsert(PostInsertEvent event) {
         String entityName = event.getPersister().getEntityName();
 
         if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
             AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get(event.getSession());
 
             AuditWorkUnit workUnit = new AddWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
 					getAuditConfiguration(),
                     event.getId(),
 					event.getPersister(),
 					event.getState()
 			);
             auditProcess.addWorkUnit( workUnit );
 
             if ( workUnit.containsWork() ) {
                 generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						event.getState(),
                         null,
 						event.getSession()
 				);
             }
         }
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostUpdateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostUpdateEventListenerImpl.java
index f217b72090..753749461f 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostUpdateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPostUpdateEventListenerImpl.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.envers.synchronization.AuditProcess;
 import org.hibernate.envers.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.synchronization.work.ModWorkUnit;
-import org.hibernate.event.PostUpdateEvent;
-import org.hibernate.event.PostUpdateEventListener;
+import org.hibernate.event.spi.PostUpdateEvent;
+import org.hibernate.event.spi.PostUpdateEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostUpdateEventListenerImpl extends BaseEnversEventListener implements PostUpdateEventListener {
 	protected EnversPostUpdateEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
 	@Override
 	public void onPostUpdate(PostUpdateEvent event) {
         String entityName = event.getPersister().getEntityName();
 
         if ( getAuditConfiguration().getEntCfg().isVersioned(entityName) ) {
             AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get(event.getSession());
 
             AuditWorkUnit workUnit = new ModWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
 					getAuditConfiguration(),
                     event.getId(),
 					event.getPersister(),
 					event.getState(),
 					event.getOldState()
 			);
             auditProcess.addWorkUnit( workUnit );
 
             if ( workUnit.containsWork() ) {
                 generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						event.getState(),
                         event.getOldState(),
 						event.getSession()
 				);
             }
         }
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionRemoveEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionRemoveEventListenerImpl.java
index b6b0a714f8..63ef6b4625 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionRemoveEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionRemoveEventListenerImpl.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.envers.configuration.AuditConfiguration;
-import org.hibernate.event.PreCollectionRemoveEvent;
-import org.hibernate.event.PreCollectionRemoveEventListener;
+import org.hibernate.event.spi.PreCollectionRemoveEvent;
+import org.hibernate.event.spi.PreCollectionRemoveEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPreCollectionRemoveEventListenerImpl
 		extends BaseEnversCollectionEventListener
 		implements PreCollectionRemoveEventListener {
 
 	protected EnversPreCollectionRemoveEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
 	@Override
 	public void onPreRemoveCollection(PreCollectionRemoveEvent event) {
         CollectionEntry collectionEntry = getCollectionEntry( event );
         if ( collectionEntry != null && !collectionEntry.getLoadedPersister().isInverse() ) {
             onCollectionAction( event, null, collectionEntry.getSnapshot(), collectionEntry );
         }
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionUpdateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionUpdateEventListenerImpl.java
index 4384ce27ae..21de20df19 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionUpdateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversPreCollectionUpdateEventListenerImpl.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.envers.configuration.AuditConfiguration;
-import org.hibernate.event.PreCollectionUpdateEvent;
-import org.hibernate.event.PreCollectionUpdateEventListener;
+import org.hibernate.event.spi.PreCollectionUpdateEvent;
+import org.hibernate.event.spi.PreCollectionUpdateEventListener;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern�n Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPreCollectionUpdateEventListenerImpl
 		extends BaseEnversCollectionEventListener
 		implements PreCollectionUpdateEventListener {
 
 	protected EnversPreCollectionUpdateEventListenerImpl(AuditConfiguration enversConfiguration) {
 		super( enversConfiguration );
 	}
 
 	@Override
 	public void onPreUpdateCollection(PreCollectionUpdateEvent event) {
         CollectionEntry collectionEntry = getCollectionEntry( event );
         if ( ! collectionEntry.getLoadedPersister().isInverse() ) {
             onCollectionAction( event, event.getCollection(), collectionEntry.getSnapshot(), collectionEntry );
         }
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/reader/AuditReaderImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/reader/AuditReaderImpl.java
index 06af92f9fd..6e432d523a 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/reader/AuditReaderImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/reader/AuditReaderImpl.java
@@ -1,286 +1,286 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.reader;
 import static org.hibernate.envers.tools.ArgumentsTools.checkNotNull;
 import static org.hibernate.envers.tools.ArgumentsTools.checkPositive;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.NoResultException;
 import org.hibernate.HibernateException;
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.exception.NotAuditedException;
 import org.hibernate.envers.exception.RevisionDoesNotExistException;
 import org.hibernate.envers.query.AuditEntity;
 import org.hibernate.envers.query.AuditQueryCreator;
 import org.hibernate.envers.synchronization.AuditProcess;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 import org.hibernate.proxy.HibernateProxy;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern&aacute;n Chanfreau
  */
 public class AuditReaderImpl implements AuditReaderImplementor {
     private final AuditConfiguration verCfg;
     private final SessionImplementor sessionImplementor;
     private final Session session;
     private final FirstLevelCache firstLevelCache;
 
     public AuditReaderImpl(AuditConfiguration verCfg, Session session,
                               SessionImplementor sessionImplementor) {
         this.verCfg = verCfg;
         this.sessionImplementor = sessionImplementor;
         this.session = session;
 
         firstLevelCache = new FirstLevelCache();
     }
 
     private void checkSession() {
         if (!session.isOpen()) {
             throw new IllegalStateException("The associated entity manager is closed!");
         }
     }
 
     public SessionImplementor getSessionImplementor() {
         return sessionImplementor;
     }
 
     public Session getSession() {
         return session;
     }
 
     public FirstLevelCache getFirstLevelCache() {
         return firstLevelCache;
     }
 
     public <T> T find(Class<T> cls, Object primaryKey, Number revision) throws
             IllegalArgumentException, NotAuditedException, IllegalStateException {
     	
     	return this.find(cls, cls.getName(), primaryKey, revision);
     }
     
     @SuppressWarnings({"unchecked"})
     public <T> T find(Class<T> cls, String entityName, Object primaryKey, Number revision) throws
             IllegalArgumentException, NotAuditedException, IllegalStateException {
         checkNotNull(cls, "Entity class");
         checkNotNull(entityName, "Entity name");
         checkNotNull(primaryKey, "Primary key");
         checkNotNull(revision, "Entity revision");
         checkPositive(revision, "Entity revision");
         checkSession();
 
         if (!verCfg.getEntCfg().isVersioned(entityName)) {
             throw new NotAuditedException(entityName, entityName + " is not versioned!");
         }
 
         if (firstLevelCache.contains(entityName, revision, primaryKey)) {
             return (T) firstLevelCache.get(entityName, revision, primaryKey);
         }
 
         Object result;
         try {
             // The result is put into the cache by the entity instantiator called from the query
             result = createQuery().forEntitiesAtRevision(cls, entityName, revision)
                 .add(AuditEntity.id().eq(primaryKey)).getSingleResult();
         } catch (NoResultException e) {
             result = null;
         } catch (NonUniqueResultException e) {
             throw new AuditException(e);
         }
 
         return (T) result;
     }    
 
     public List<Number> getRevisions(Class<?> cls, Object primaryKey)
             throws IllegalArgumentException, NotAuditedException, IllegalStateException {
     	
     	return this.getRevisions(cls, cls.getName(), primaryKey);
     }
 
     @SuppressWarnings({"unchecked"})
     public List<Number> getRevisions(Class<?> cls, String entityName, Object primaryKey)
             throws IllegalArgumentException, NotAuditedException, IllegalStateException {
         // todo: if a class is not versioned from the beginning, there's a missing ADD rev - what then?
         checkNotNull(cls, "Entity class");
         checkNotNull(entityName, "Entity name");
         checkNotNull(primaryKey, "Primary key");
         checkSession();
 
         if (!verCfg.getEntCfg().isVersioned(entityName)) {
             throw new NotAuditedException(entityName, entityName + " is not versioned!");
         }
 
         return createQuery().forRevisionsOfEntity(cls, entityName, false, true)
                 .addProjection(AuditEntity.revisionNumber())
                 .add(AuditEntity.id().eq(primaryKey))
                 .getResultList();
     }
 
     public Date getRevisionDate(Number revision) throws IllegalArgumentException, RevisionDoesNotExistException,
             IllegalStateException{
         checkNotNull(revision, "Entity revision");
         checkPositive(revision, "Entity revision");
         checkSession();
 
         Query query = verCfg.getRevisionInfoQueryCreator().getRevisionDateQuery(session, revision);
 
         try {
             Object timestampObject = query.uniqueResult();
             if (timestampObject == null) {
                 throw new RevisionDoesNotExistException(revision);
             }
 
             // The timestamp object is either a date or a long
             return timestampObject instanceof Date ? (Date) timestampObject : new Date((Long) timestampObject);
         } catch (NonUniqueResultException e) {
             throw new AuditException(e);
         }
     }
 
     public Number getRevisionNumberForDate(Date date) {
         checkNotNull(date, "Date of revision");
         checkSession();
 
         Query query = verCfg.getRevisionInfoQueryCreator().getRevisionNumberForDateQuery(session, date);
 
         try {
             Number res = (Number) query.uniqueResult();
             if (res == null) {
                 throw new RevisionDoesNotExistException(date);
             }
 
             return res;
         } catch (NonUniqueResultException e) {
             throw new AuditException(e);
         }
     }
 
     @SuppressWarnings({"unchecked"})
     public <T> T findRevision(Class<T> revisionEntityClass, Number revision) throws IllegalArgumentException,
             RevisionDoesNotExistException, IllegalStateException {
         checkNotNull(revision, "Entity revision");
         checkPositive(revision, "Entity revision");
         checkSession();
 
         Set<Number> revisions = new HashSet<Number>(1);
         revisions.add(revision);
         Query query = verCfg.getRevisionInfoQueryCreator().getRevisionsQuery(session, revisions);
 
         try {
             T revisionData = (T) query.uniqueResult();
 
             if (revisionData == null) {
                 throw new RevisionDoesNotExistException(revision);
             }
 
             return revisionData;
         } catch (NonUniqueResultException e) {
             throw new AuditException(e);
         }
     }
 
     @SuppressWarnings({"unchecked"})
     public <T> Map<Number, T> findRevisions(Class<T> revisionEntityClass, Set<Number> revisions) throws IllegalArgumentException,
     IllegalStateException {
 		Map<Number, T> result = new HashMap<Number, T>(revisions.size());
 
     	for (Number revision : revisions) {
             checkNotNull(revision, "Entity revision");
             checkPositive(revision, "Entity revision");
 		}
         checkSession();
 
         Query query = verCfg.getRevisionInfoQueryCreator().getRevisionsQuery(session, revisions);
 
         try {
             List<T> revisionList = query.list();
             for (T revision : revisionList) {
             	Number revNo = verCfg.getRevisionInfoNumberReader().getRevisionNumber(revision);
        			result.put(revNo, revision);
 			}
 
             return result;
         } catch (HibernateException e) {
             throw new AuditException(e);
         }
     }
 
 	@SuppressWarnings({"unchecked"})
 	public <T> T getCurrentRevision(Class<T> revisionEntityClass, boolean persist) {
 		if (!(session instanceof EventSource)) {
 			throw new IllegalArgumentException("The provided session is not an EventSource!");
 		}
 
 		// Obtaining the current audit sync
 		AuditProcess auditProcess = verCfg.getSyncManager().get((EventSource) session);
 
 		// And getting the current revision data
 		return (T) auditProcess.getCurrentRevisionData(session, persist);
 	}
 
 	public AuditQueryCreator createQuery() {
         return new AuditQueryCreator(verCfg, this);
     }
 	
     public boolean isEntityClassAudited(Class<?> entityClass) {
     	return this.isEntityNameAudited(entityClass.getName());
     }
 
 
 	public boolean isEntityNameAudited(String entityName) {
         checkNotNull(entityName, "Entity name");
         checkSession();
         return (verCfg.getEntCfg().isVersioned(entityName));
     }	
 
 
 	public String getEntityName(Object primaryKey, Number revision ,Object entity) throws HibernateException{
         checkNotNull(primaryKey, "Primary key");
         checkNotNull(revision, "Entity revision");
         checkPositive(revision, "Entity revision");
         checkNotNull(entity, "Entity");
         checkSession();
 
 		// Unwrap if necessary
 		if(entity instanceof HibernateProxy) {
 			entity = ((HibernateProxy)entity).getHibernateLazyInitializer().getImplementation();
 		}
 		if(firstLevelCache.containsEntityName(primaryKey, revision, entity)) {
 			// it's on envers FLC!
 			return firstLevelCache.getFromEntityNameCache(primaryKey, revision, entity);
 		} else {
 			throw new HibernateException(
 						"Envers can't resolve entityName for historic entity. The id, revision and entity is not on envers first level cache.");
     }	
 }
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/synchronization/AuditProcessManager.java b/hibernate-envers/src/main/java/org/hibernate/envers/synchronization/AuditProcessManager.java
index 9dbf80a77d..dbf9ccd33f 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/synchronization/AuditProcessManager.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/synchronization/AuditProcessManager.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.synchronization;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import org.hibernate.Transaction;
 import org.hibernate.action.spi.AfterTransactionCompletionProcess;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.revisioninfo.RevisionInfoGenerator;
-import org.hibernate.event.EventSource;
+import org.hibernate.event.spi.EventSource;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class AuditProcessManager {
     private final Map<Transaction, AuditProcess> auditProcesses;
     private final RevisionInfoGenerator revisionInfoGenerator;
 
     public AuditProcessManager(RevisionInfoGenerator revisionInfoGenerator) {
         auditProcesses = new ConcurrentHashMap<Transaction, AuditProcess>();
 
         this.revisionInfoGenerator = revisionInfoGenerator;
     }
 
     public AuditProcess get(EventSource session) {
         final Transaction transaction = session.getTransaction();
         
         AuditProcess auditProcess = auditProcesses.get(transaction);
         if (auditProcess == null) {
             // No worries about registering a transaction twice - a transaction is single thread
             auditProcess = new AuditProcess(revisionInfoGenerator, session);
             auditProcesses.put(transaction, auditProcess);
 
             session.getActionQueue().registerProcess(auditProcess);
 
             session.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {
                 public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {
                     auditProcesses.remove(transaction);
                 }
             });
         }
 
         return auditProcess;
     }
 }
