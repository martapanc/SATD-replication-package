diff --git a/src/org/jruby/IRuby.java b/src/org/jruby/IRuby.java
index d01406ecfe..03f39a8180 100644
--- a/src/org/jruby/IRuby.java
+++ b/src/org/jruby/IRuby.java
@@ -1,425 +1,426 @@
 package org.jruby;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.io.Reader;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
 import org.jruby.ast.Node;
 import org.jruby.common.RubyWarnings;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.internal.runtime.GlobalVariables;
 import org.jruby.internal.runtime.ThreadService;
 import org.jruby.javasupport.JavaSupport;
 import org.jruby.lexer.yacc.ISourcePosition;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.CacheMap;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicScope;
 import org.jruby.runtime.GlobalVariable;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ObjectSpace;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.load.LoadService;
 import org.jruby.util.collections.SinglyLinkedList;
 
 public interface IRuby {
 
 	/**
 	 * Retrieve mappings of cached methods to where they have been cached.  When a cached
 	 * method needs to be invalidated this map can be used to remove all places it has been
 	 * cached.
 	 * 
 	 * @return the mappings of where cached methods have been stored
 	 */
 	public CacheMap getCacheMap();
 
     /**
      * The contents of the runtimeInformation map are dumped with the JVM exits if
      * JRuby has been invoked via the Main class. Otherwise these contents can be used
      * by embedders to track development-time runtime information such as profiling
      * or logging data during execution.
      * 
      * @return the runtimeInformation map
      * @see org.jruby.Main#runInterpreter
      */
     public Map getRuntimeInformation();
     
 	/**
 	 * Evaluates a script and returns a RubyObject.
 	 */
 	public IRubyObject evalScript(String script);
 
     public IRubyObject eval(Node node);
 
     public IRubyObject compileAndRun(Node node);
 
 	public RubyClass getObject();
     
     public RubyModule getKernel();
     
     public RubyClass getString();
     
     public RubyClass getFixnum();
     
     public IRubyObject getTmsStruct();
 
 	/** Returns the "true" instance from the instance pool.
 	 * @return The "true" instance.
 	 */
 	public RubyBoolean getTrue();
 
 	/** Returns the "false" instance from the instance pool.
 	 * @return The "false" instance.
 	 */
 	public RubyBoolean getFalse();
 
 	/** Returns the "nil" singleton instance.
 	 * @return "nil"
 	 */
 	public IRubyObject getNil();
     
     /**
      * @return The NilClass class
      */
     public RubyClass getNilClass();
 
 	public RubyModule getModule(String name);
 
 	/** Returns a class from the instance pool.
 	 *
 	 * @param name The name of the class.
 	 * @return The class.
 	 */
 	public RubyClass getClass(String name);
 
 	/** Define a new class with name 'name' and super class 'superClass'.
 	 *
 	 * MRI: rb_define_class / rb_define_class_id
 	 *
 	 */
-	public RubyClass defineClass(String name, RubyClass superClass);
+	public RubyClass defineClass(String name, RubyClass superClass, ObjectAllocator allocator);
 
-	public RubyClass defineClassUnder(String name, RubyClass superClass, SinglyLinkedList parentCRef);
+	public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef);
 
 	/** rb_define_module / rb_define_module_id
 	 *
 	 */
 	public RubyModule defineModule(String name);
 
 	public RubyModule defineModuleUnder(String name, SinglyLinkedList parentCRef);
 
 	/**
 	 * In the current context, get the named module. If it doesn't exist a
 	 * new module is created.
 	 */
 	public RubyModule getOrCreateModule(String name);
 
 	/** Getter for property securityLevel.
 	 * @return Value of property securityLevel.
 	 */
 	public int getSafeLevel();
 
 	/** Setter for property securityLevel.
 	 * @param safeLevel New value of property securityLevel.
 	 */
 	public void setSafeLevel(int safeLevel);
 
 	public void secure(int level);
 
 	/** rb_define_global_const
 	 *
 	 */
 	public void defineGlobalConstant(String name, IRubyObject value);
 
 	public IRubyObject getTopConstant(String name);
     
     public String getCurrentDirectory();
     
     public void setCurrentDirectory(String dir);
     
     public long getStartTime();
     
     public InputStream getIn();
     public PrintStream getOut();
     public PrintStream getErr();
 
 	public boolean isClassDefined(String name);
 
     public boolean isObjectSpaceEnabled();
     
 	/** Getter for property rubyTopSelf.
 	 * @return Value of property rubyTopSelf.
 	 */
 	public IRubyObject getTopSelf();
 
     /** Getter for property isVerbose.
 	 * @return Value of property isVerbose.
 	 */
 	public IRubyObject getVerbose();
 
 	/** Setter for property isVerbose.
 	 * @param verbose New value of property isVerbose.
 	 */
 	public void setVerbose(IRubyObject verbose);
 
     /** Getter for property isDebug.
 	 * @return Value of property isDebug.
 	 */
 	public IRubyObject getDebug();
 
 	/** Setter for property isDebug.
 	 * @param verbose New value of property isDebug.
 	 */
 	public void setDebug(IRubyObject debug);
 
     public JavaSupport getJavaSupport();
 
     /** Defines a global variable
 	 */
 	public void defineVariable(final GlobalVariable variable);
 
 	/** defines a readonly global variable
 	 *
 	 */
 	public void defineReadonlyVariable(String name, IRubyObject value);
 
     /**
      * Parse the source specified by the reader and return an AST
      * 
      * @param content to be parsed
      * @param file the name of the file to be used in warnings/errors
      * @param scope that this content is being parsed under
      * @return the top of the AST
      */
 	public Node parse(Reader content, String file, DynamicScope scope);
 
     /**
      * Parse the source specified by the string and return an AST
      * 
      * @param content to be parsed
      * @param file the name of the file to be used in warnings/errors
      * @param scope that this content is being parsed under
      * @return the top of the AST
      */
 	public Node parse(String content, String file, DynamicScope scope);
 
 	public ThreadService getThreadService();
 
 	public ThreadContext getCurrentContext();
 
     /**
 	 * Returns the loadService.
 	 * @return ILoadService
 	 */
 	public LoadService getLoadService();
 
 	public RubyWarnings getWarnings();
 
 	public PrintStream getErrorStream();
 
 	public InputStream getInputStream();
 
 	public PrintStream getOutputStream();
 
 	public RubyModule getClassFromPath(String path);
 
 	/** Prints an error with backtrace to the error stream.
 	 *
 	 * MRI: eval.c - error_print()
 	 *
 	 */
 	public void printError(RubyException excp);
 
 	/** This method compiles and interprets a Ruby script.
 	 *
 	 *  It can be used if you want to use JRuby as a Macro language.
 	 *
 	 */
 	public void loadScript(RubyString scriptName, RubyString source,
 			boolean wrap);
 
 	public void loadScript(String scriptName, Reader source, boolean wrap);
 
 	public void loadNode(String scriptName, Node node, boolean wrap);
 
 	/** Loads, compiles and interprets a Ruby file.
 	 *  Used by Kernel#require.
 	 *
 	 *  @mri rb_load
 	 */
 	public void loadFile(File file, boolean wrap);
 
 	/** Call the trace function
 	 *
 	 * MRI: eval.c - call_trace_func
 	 *
 	 */
 	public void callTraceFunction(ThreadContext context, String event, ISourcePosition position,
 			IRubyObject self, String name, IRubyObject type);
 
 	public RubyProc getTraceFunction();
 
 	public void setTraceFunction(RubyProc traceFunction);
 
 	public GlobalVariables getGlobalVariables();
 	public void setGlobalVariables(GlobalVariables variables);
 
 	public CallbackFactory callbackFactory(Class type);
 
 	/**
 	 * Push block onto exit stack.  When runtime environment exits
 	 * these blocks will be evaluated.
 	 * 
 	 * @return the element that was pushed onto stack
 	 */
 	public IRubyObject pushExitBlock(RubyProc proc);
 
 	/**
 	 * Make sure Kernel#at_exit procs get invoked on runtime shutdown.
 	 * This method needs to be explicitly called to work properly.
 	 * I thought about using finalize(), but that did not work and I
 	 * am not sure the runtime will be at a state to run procs by the
 	 * time Ruby is going away.  This method can contain any other
 	 * things that need to be cleaned up at shutdown.  
 	 */
 	public void tearDown();
 
 	public RubyArray newArray();
 
 	public RubyArray newArray(IRubyObject object);
 
 	public RubyArray newArray(IRubyObject car, IRubyObject cdr);
 
 	public RubyArray newArray(IRubyObject[] objects);
 
 	public RubyArray newArray(List list);
 
 	public RubyArray newArray(int size);
 
 	public RubyBoolean newBoolean(boolean value);
 
 	public RubyFileStat newRubyFileStat(File file);
 
 	public RubyFixnum newFixnum(long value);
 
 	public RubyFloat newFloat(double value);
 
 	public RubyNumeric newNumeric();
 
     public RubyProc newProc();
 
     public RubyBinding newBinding();
     public RubyBinding newBinding(Block block);
 
 	public RubyString newString(String string);
 
 	public RubySymbol newSymbol(String string);
 
     public RaiseException newArgumentError(String message);
     
     public RaiseException newArgumentError(int got, int expected);
     
     public RaiseException newErrnoEBADFError();
 
     public RaiseException newErrnoEINVALError();
 
     public RaiseException newErrnoENOENTError();
 
     public RaiseException newErrnoESPIPEError();
 
     public RaiseException newErrnoEBADFError(String message);
 
     public RaiseException newErrnoEINVALError(String message);
 
     public RaiseException newErrnoENOENTError(String message);
 
     public RaiseException newErrnoESPIPEError(String message);
 
     public RaiseException newErrnoEEXISTError(String message);
 
     public RaiseException newIndexError(String message);
     
     public RaiseException newSecurityError(String message);
     
     public RaiseException newSystemCallError(String message);
 
     public RaiseException newTypeError(String message);
     
     public RaiseException newThreadError(String message);
     
     public RaiseException newSyntaxError(String message);
 
     public RaiseException newRangeError(String message);
 
     public RaiseException newNotImplementedError(String message);
 
     public RaiseException newNoMethodError(String message, String name);
 
     public RaiseException newNameError(String message, String name);
 
     public RaiseException newLocalJumpError(String message);
 
     public RaiseException newLoadError(String message);
 
     public RaiseException newFrozenError(String objectType);
 
     public RaiseException newSystemStackError(String message);
     
     public RaiseException newSystemExit(int status);
     
     public RaiseException newIOError(String message);
     
     public RaiseException newIOErrorFromException(IOException ioe);
     
     public RaiseException newTypeError(IRubyObject receivedObject, RubyClass expectedType);
 
     public RaiseException newEOFError();
     
     public RaiseException newZeroDivisionError();
 
 	public RubySymbol.SymbolTable getSymbolTable();
 
 	public void setStackTraces(int stackTraces);
 
 	public int getStackTraces();
 
 	public void setRandomSeed(long randomSeed);
 
 	public long getRandomSeed();
 
 	public Random getRandom();
 
 	public ObjectSpace getObjectSpace();
 
 	public Hashtable getIoHandlers();
 
 	public RubyFixnum[] getFixnumCache();
 
 	public long incrementRandomSeedSequence();
 
     public RubyTime newTime(long milliseconds);
 
 	public boolean isGlobalAbortOnExceptionEnabled();
 
 	public void setGlobalAbortOnExceptionEnabled(boolean b);
 
 	public boolean isDoNotReverseLookupEnabled();
 
 	public void setDoNotReverseLookupEnabled(boolean b);
 
     public boolean registerInspecting(Object obj);
     public void unregisterInspecting(Object obj);
 
     public void setEncoding(String encoding);
     public String getEncoding();
 
     public Profile getProfile();
     
     public String getJRubyHome();
 }
diff --git a/src/org/jruby/NativeException.java b/src/org/jruby/NativeException.java
index f68a46bedc..84cc05ad99 100644
--- a/src/org/jruby/NativeException.java
+++ b/src/org/jruby/NativeException.java
@@ -1,85 +1,88 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2005 David Corbin <dcorbin@users.sourceforge.net>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.PrintStream;
 
 import org.jruby.javasupport.JavaObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 
 public class NativeException extends RubyException {
 
     private final Throwable cause;
     public static final String CLASS_NAME = "NativeException";
 	private final IRuby runtime;
 
     public NativeException(IRuby runtime, RubyClass rubyClass, Throwable cause) {
         super(runtime, rubyClass, cause.getClass().getName()+": "+cause.getMessage());
 		this.runtime = runtime;
         this.cause = cause;
     }
     
     public static RubyClass createClass(IRuby runtime, RubyClass baseClass) {
-    	RubyClass exceptionClass = runtime.defineClass(CLASS_NAME, baseClass);
+        // FIXME: If NativeException is expected to be used from Ruby code, it should provide
+        // a real allocator to be used. Otherwise Class.new will fail, as will marshalling. JRUBY-415
+    	RubyClass exceptionClass = runtime.defineClass(CLASS_NAME, baseClass, ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
     	
 		CallbackFactory callbackFactory = runtime.callbackFactory(NativeException.class);
 		exceptionClass.defineMethod("cause", 
 				callbackFactory.getMethod("cause"));		
 
 		return exceptionClass;
     }
     
     public IRubyObject cause() {
         return getRuntime().getModule("JavaUtilities").callMethod(getRuntime().getCurrentContext(),
             "wrap",
             JavaObject.wrap(getRuntime(), cause));
     }
     
     public IRubyObject backtrace() {
         IRubyObject rubyTrace = super.backtrace();
         if (rubyTrace.isNil())
             return rubyTrace;
         RubyArray array = (RubyArray) rubyTrace;
         StackTraceElement[] stackTrace = cause.getStackTrace();
         for (int i=stackTrace.length-1; i>=0; i--) {
             StackTraceElement element = stackTrace[i];
             String line = element.toString();
             RubyString string = runtime.newString(line);
             array.unshift(string);
         }
         return rubyTrace;
     }
     
     public void printBacktrace(PrintStream errorStream) {
     	super.printBacktrace(errorStream);
     	errorStream.println("Complete Java stackTrace");
     	cause.printStackTrace(errorStream);
     }
 }
diff --git a/src/org/jruby/Ruby.java b/src/org/jruby/Ruby.java
index 52a217f904..68233bacae 100644
--- a/src/org/jruby/Ruby.java
+++ b/src/org/jruby/Ruby.java
@@ -1,1631 +1,1632 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * Copyright (C) 2006 Michael Studman <codehaus@michaelstudman.com>
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.io.Reader;
 import java.io.StringReader;
 import java.security.AccessControlException;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Stack;
 
 import org.jruby.ast.Node;
 import org.jruby.compiler.InstructionCompiler2;
 import org.jruby.ast.executable.Script;
 import org.jruby.common.RubyWarnings;
 import org.jruby.evaluator.EvaluationState;
 import org.jruby.exceptions.JumpException;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.internal.runtime.GlobalVariables;
 import org.jruby.internal.runtime.ThreadService;
 import org.jruby.internal.runtime.ValueAccessor;
 import org.jruby.javasupport.Java;
 import org.jruby.javasupport.JavaSupport;
 import org.jruby.lexer.yacc.ISourcePosition;
 import org.jruby.libraries.IConvLibrary;
 import org.jruby.libraries.JRubyLibrary;
 import org.jruby.libraries.RbConfigLibrary;
 import org.jruby.libraries.SocketLibrary;
 import org.jruby.libraries.StringIOLibrary;
 import org.jruby.libraries.StringScannerLibrary;
 import org.jruby.libraries.ZlibLibrary;
 import org.jruby.libraries.YamlLibrary;
 import org.jruby.libraries.EnumeratorLibrary;
 import org.jruby.libraries.BigDecimalLibrary;
 import org.jruby.ext.openssl.RubyOpenSSL;
 import org.jruby.libraries.DigestLibrary;
 import org.jruby.ext.Generator;
 import org.jruby.ext.Readline;
 import org.jruby.parser.Parser;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.CacheMap;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicScope;
 import org.jruby.runtime.GlobalVariable;
 import org.jruby.runtime.IAccessor;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ObjectSpace;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.builtin.meta.ArrayMetaClass;
 import org.jruby.runtime.builtin.meta.BignumMetaClass;
 import org.jruby.runtime.builtin.meta.BindingMetaClass;
 import org.jruby.runtime.builtin.meta.FileMetaClass;
 import org.jruby.runtime.builtin.meta.FixnumMetaClass;
 import org.jruby.runtime.builtin.meta.HashMetaClass;
 import org.jruby.runtime.builtin.meta.IOMetaClass;
 import org.jruby.runtime.builtin.meta.IntegerMetaClass;
 import org.jruby.runtime.builtin.meta.ModuleMetaClass;
 import org.jruby.runtime.builtin.meta.NumericMetaClass;
 import org.jruby.runtime.builtin.meta.ObjectMetaClass;
 import org.jruby.runtime.builtin.meta.ProcMetaClass;
 import org.jruby.runtime.builtin.meta.StringMetaClass;
 import org.jruby.runtime.builtin.meta.SymbolMetaClass;
 import org.jruby.runtime.builtin.meta.TimeMetaClass;
 import org.jruby.runtime.load.Library;
 import org.jruby.runtime.load.LoadService;
 import org.jruby.util.BuiltinScript;
 import org.jruby.util.JRubyClassLoader;
 import org.jruby.util.JRubyFile;
 import org.jruby.util.NormalizedFile;
 import org.jruby.util.collections.SinglyLinkedList;
 
 /**
  * The jruby runtime.
  */
 public final class Ruby implements IRuby {
 	private static String[] BUILTIN_LIBRARIES = {"fcntl", "yaml", "etc", "nkf" };
     
 	private CacheMap cacheMap = new CacheMap();
     private ThreadService threadService = new ThreadService(this);
     private Hashtable runtimeInformation;
 
     private int stackTraces = 0;
 
     private ObjectSpace objectSpace = new ObjectSpace();
 
     private final RubyFixnum[] fixnumCache = new RubyFixnum[256];
     private final RubySymbol.SymbolTable symbolTable = new RubySymbol.SymbolTable();
     private Hashtable ioHandlers = new Hashtable();
     private long randomSeed = 0;
     private long randomSeedSequence = 0;
     private Random random = new Random();
 
     private RubyProc traceFunction;
     private boolean globalAbortOnExceptionEnabled = false;
     private boolean doNotReverseLookupEnabled = false;
     private final boolean objectSpaceEnabled;
     
     /**
      * What encoding should we read source files in as...
      * @see org.jruby.util.CommandlineParser#processArgument()
      */
     private String encoding = "ISO8859_1";
 
     /** safe-level:
     		0 - strings from streams/environment/ARGV are tainted (default)
     		1 - no dangerous operation by tainted value
     		2 - process/file operations prohibited
     		3 - all genetated objects are tainted
     		4 - no global (non-tainted) variable modification/no direct output
     */
     private int safeLevel = 0;
 
     // Default classes/objects
     private IRubyObject nilObject;
     private RubyBoolean trueObject;
     private RubyBoolean falseObject;
     private RubyClass objectClass;
     private StringMetaClass stringClass;
     private RubyClass systemCallError = null;
     private RubyModule errnoModule = null;
     private IRubyObject topSelf;
     
     // former java.lang.System concepts now internalized for MVM
     private String currentDirectory;
     
     private long startTime = System.currentTimeMillis();
     
     private InputStream in;
     private PrintStream out;
     private PrintStream err;
     
     private IRubyObject verbose;
     private IRubyObject debug;
 
     // Java support
     private JavaSupport javaSupport;
 
     private Parser parser = new Parser(this);
 
     private LoadService loadService;
     private GlobalVariables globalVariables = new GlobalVariables(this);
     private RubyWarnings warnings = new RubyWarnings(this);
 
     // Contains a list of all blocks (as Procs) that should be called when
     // the runtime environment exits.
     private Stack atExitBlocks = new Stack();
 
     private RubyModule kernelModule;
 
     private RubyClass nilClass;
 
     private FixnumMetaClass fixnumClass;
     
     private IRubyObject tmsStruct;
 
     private Profile profile;
 
     private String jrubyHome;
 
     /**
      * Create and initialize a new jruby Runtime.
      */
     private Ruby(InputStream in, PrintStream out, PrintStream err) {
         this(in,out,err,true,Profile.DEFAULT);
     }
 
     /**
      * Create and initialize a new jruby Runtime.
      */
     private Ruby(InputStream in, PrintStream out, PrintStream err, boolean osEnabled) {
         this(in,out,err,osEnabled,Profile.DEFAULT);
     }
 
     /**
      * Create and initialize a new jruby Runtime.
      */
     private Ruby(InputStream in, PrintStream out, PrintStream err, boolean osEnabled, Profile profile) {
         this.in = in;
         this.out = out;
         this.err = err;
         
         objectSpaceEnabled = osEnabled;
 
         this.profile = profile;
         
         try {
             currentDirectory = JRubyFile.getFileProperty("user.dir");
         } catch (AccessControlException accessEx) {
             // default to "/" as current dir for applets (which can't read from FS anyway)
             currentDirectory = "/";
         }
     }
 
     /**
      * Returns a default instance of the JRuby runtime.
      *
      * @return the JRuby runtime
      */
     public static IRuby getDefaultInstance() {
         Ruby ruby;
         if(System.getProperty("jruby.objectspace.enabled") != null) {
             ruby = new Ruby(System.in, System.out, System.err, Boolean.getBoolean("jruby.objectspace.enabled"));
         } else {
             ruby = new Ruby(System.in, System.out, System.err);
         }
 
         ruby.init();
         
         return ruby;
     }
 
     /**
      * Returns a default instance of the JRuby runtime.
      *
      * @return the JRuby runtime
      */
     public static IRuby newInstance(InputStream in, PrintStream out, PrintStream err, boolean osEnabled, Profile profile) {
         Ruby ruby = new Ruby(in, out, err, osEnabled, profile);
         ruby.init();
         
         return ruby;
     }
 
     /**
      * Returns a default instance of the JRuby runtime.
      *
      * @return the JRuby runtime
      */
     public static IRuby newInstance(InputStream in, PrintStream out, PrintStream err, Profile profile) {
         return newInstance(in,out,err,true,profile);
     }
 
     /**
      * Returns a default instance of the JRuby runtime.
      *
      * @return the JRuby runtime
      */
     public static IRuby newInstance(InputStream in, PrintStream out, PrintStream err, boolean osEnabled) {
         return newInstance(in,out,err,osEnabled,Profile.DEFAULT);
     }
 
     /**
      * Returns a default instance of the JRuby runtime.
      *
      * @return the JRuby runtime
      */
     public static IRuby newInstance(InputStream in, PrintStream out, PrintStream err) {
         return newInstance(in, out, err, true, Profile.DEFAULT);
     }
 
     /**
      * Evaluates a script and returns a RubyObject.
      */
     public IRubyObject evalScript(String script) {
         return eval(parse(script, "<script>", getCurrentContext().getCurrentScope()));
     }
 
     public IRubyObject eval(Node node) {
         try {
             ThreadContext tc = getCurrentContext();
             
             return EvaluationState.eval(tc, node, tc.getFrameSelf());
         } catch (JumpException je) {
         	if (je.getJumpType() == JumpException.JumpType.ReturnJump) {
                 throw newLocalJumpError("unexpected return");
                 //	            return (IRubyObject)je.getSecondaryData();
         	} 
 
             throw je;
         }
     }
 
     public IRubyObject compileAndRun(Node node) {
         try {
             ThreadContext tc = getCurrentContext();
             ISourcePosition position = node.getPosition();
             InstructionCompiler2 compiler = new InstructionCompiler2();
             String classname = null;
             
             if (position != null) {
                 classname = node.getPosition().getFile();
                 if (classname.endsWith(".rb")) {
                     classname = classname.substring(0, classname.length() - 3);
                 }
                 compiler.compile(classname, position.getFile(), node);
             } else {
                 classname = "EVAL";
                 compiler.compile(classname, "EVAL", node);
             }
             
             JRubyClassLoader loader = new JRubyClassLoader();
             Class scriptClass = compiler.loadClasses(loader);
             
             Script script = (Script)scriptClass.newInstance();
             
             return script.run(tc, tc.getFrameSelf());
         } catch (JumpException je) {
             if (je.getJumpType() == JumpException.JumpType.ReturnJump) {
                 return (IRubyObject)je.getSecondaryData();
             } else {
                 throw je;
             }
         } catch (ClassNotFoundException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
             return null;
         } catch (InstantiationException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
             return null;
         } catch (IllegalAccessException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
             return null;
         }
     }
 
     public RubyClass getObject() {
     	return objectClass;
     }
     
     public RubyModule getKernel() {
         return kernelModule;
     }
     
     public RubyClass getString() {
         return stringClass;
     }
     
     public RubyClass getFixnum() {
         return fixnumClass;
     }
     
     public IRubyObject getTmsStruct() {
         return tmsStruct;
     }
 
     /** Returns the "true" instance from the instance pool.
      * @return The "true" instance.
      */
     public RubyBoolean getTrue() {
         return trueObject;
     }
 
     /** Returns the "false" instance from the instance pool.
      * @return The "false" instance.
      */
     public RubyBoolean getFalse() {
         return falseObject;
     }
 
     /** Returns the "nil" singleton instance.
      * @return "nil"
      */
     public IRubyObject getNil() {
         return nilObject;
     }
     
     public RubyClass getNilClass() {
         return nilClass;
     }
 
     public RubyModule getModule(String name) {
         return (RubyModule) objectClass.getConstantAt(name);
     }
 
     /** Returns a class from the instance pool.
      *
      * @param name The name of the class.
      * @return The class.
      */
     public RubyClass getClass(String name) {
         try {
             return objectClass.getClass(name);
         } catch (ClassCastException e) {
             throw newTypeError(name + " is not a Class");
         }
     }
 
     /** Define a new class with name 'name' and super class 'superClass'.
      *
      * MRI: rb_define_class / rb_define_class_id
      *
      */
-    public RubyClass defineClass(String name, RubyClass superClass) {
-        return defineClassUnder(name, superClass, objectClass.getCRef());
+    public RubyClass defineClass(String name, RubyClass superClass, ObjectAllocator allocator) {
+        return defineClassUnder(name, superClass, allocator, objectClass.getCRef());
     }
     
-    public RubyClass defineClassUnder(String name, RubyClass superClass, SinglyLinkedList parentCRef) {
+    public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
         if (superClass == null) {
             superClass = objectClass;
         }
 
-        return superClass.newSubClass(name, parentCRef);
+        return superClass.newSubClass(name, allocator, parentCRef);
     }
     
     /** rb_define_module / rb_define_module_id
      *
      */
     public RubyModule defineModule(String name) {
         return defineModuleUnder(name, objectClass.getCRef());
     }
     
     public RubyModule defineModuleUnder(String name, SinglyLinkedList parentCRef) {
         RubyModule newModule = RubyModule.newModule(this, name, parentCRef);
 
         ((RubyModule)parentCRef.getValue()).setConstant(name, newModule);
         
         return newModule;
     }
     
     /**
      * In the current context, get the named module. If it doesn't exist a
      * new module is created.
      */
     public RubyModule getOrCreateModule(String name) {
         ThreadContext tc = getCurrentContext();
         RubyModule module = (RubyModule) tc.getRubyClass().getConstantAt(name);
         
         if (module == null) {
             module = (RubyModule) tc.getRubyClass().setConstant(name, 
             		defineModule(name)); 
         } else if (getSafeLevel() >= 4) {
         	throw newSecurityError("Extending module prohibited.");
         }
 
         if (tc.getWrapper() != null) {
             module.getSingletonClass().includeModule(tc.getWrapper());
             module.includeModule(tc.getWrapper());
         }
         return module;
     }
     
 
     /** Getter for property securityLevel.
      * @return Value of property securityLevel.
      */
     public int getSafeLevel() {
         return this.safeLevel;
     }
 
     /** Setter for property securityLevel.
      * @param safeLevel New value of property securityLevel.
      */
     public void setSafeLevel(int safeLevel) {
         this.safeLevel = safeLevel;
     }
 
     public void secure(int level) {
         if (level <= safeLevel) {
             throw newSecurityError("Insecure operation '" + getCurrentContext().getFrameLastFunc() + "' at level " + safeLevel);
         }
     }
     
     /**
      * Retrieve mappings of cached methods to where they have been cached.  When a cached
      * method needs to be invalidated this map can be used to remove all places it has been
      * cached.
      * 
      * @return the mappings of where cached methods have been stored
      */
     public CacheMap getCacheMap() {
         return cacheMap;
     }
 
     /**
      * @see org.jruby.IRuby#getRuntimeInformation
      */
     public Map getRuntimeInformation() {
         return runtimeInformation == null ? runtimeInformation = new Hashtable() : runtimeInformation;
     }
 
     /** rb_define_global_const
      *
      */
     public void defineGlobalConstant(String name, IRubyObject value) {
         objectClass.defineConstant(name, value);
     }
 
     public IRubyObject getTopConstant(String name) {
         IRubyObject constant = getModule(name);
         if (constant == null) {
             constant = getLoadService().autoload(name);
         }
         return constant;
     }
 
     public boolean isClassDefined(String name) {
         return getModule(name) != null;
     }
 
     /** Getter for property rubyTopSelf.
      * @return Value of property rubyTopSelf.
      */
     public IRubyObject getTopSelf() {
         return topSelf;
     }
     
     public void setCurrentDirectory(String dir) {
         currentDirectory = dir;
     }
     
     public String getCurrentDirectory() {
         return currentDirectory;
     }
 
     /** ruby_init
      *
      */
     // TODO: Figure out real dependencies between vars and reorder/refactor into better methods
     private void init() {
         ThreadContext tc = getCurrentContext();
         nilObject = new RubyNil(this);
         trueObject = new RubyBoolean(this, true);
         falseObject = new RubyBoolean(this, false);
 
         verbose = falseObject;
         debug = falseObject;
         
         javaSupport = new JavaSupport(this);
         
         initLibraries();
         
         tc.preInitCoreClasses();
 
         initCoreClasses();
 
         topSelf = TopSelfFactory.createTopSelf(this);
 
         tc.preInitBuiltinClasses(objectClass, topSelf);
 
         RubyGlobal.createGlobals(this);
 
         initBuiltinClasses();
         
         getObject().defineConstant("TOPLEVEL_BINDING", newBinding());
         
         // Load additional definitions and hacks from etc.rb
         getLoadService().smartLoad("builtin/etc.rb");
     }
 
     private void initLibraries() {
         loadService = new LoadService(this);
         registerBuiltin("java.rb", new Library() {
                 public void load(IRuby runtime) throws IOException {
                     Java.createJavaModule(runtime);
                     new BuiltinScript("javasupport").load(runtime);
                 }
             });
 
         registerBuiltin("socket.rb", new SocketLibrary());
         registerBuiltin("rbconfig.rb", new RbConfigLibrary());
 
         for (int i=0; i<BUILTIN_LIBRARIES.length; i++) {
             if(profile.allowBuiltin(BUILTIN_LIBRARIES[i])) {
                 loadService.registerRubyBuiltin(BUILTIN_LIBRARIES[i]);
             }
         }
         
         registerBuiltin("jruby.rb", new JRubyLibrary());
         registerBuiltin("iconv.rb", new IConvLibrary());
         registerBuiltin("stringio.rb", new StringIOLibrary());
         registerBuiltin("strscan.rb", new StringScannerLibrary());
         registerBuiltin("zlib.rb", new ZlibLibrary());
         registerBuiltin("yaml_internal.rb", new YamlLibrary());
         registerBuiltin("enumerator.rb", new EnumeratorLibrary());
         registerBuiltin("generator_internal.rb", new Generator.Service());
         registerBuiltin("readline.rb", new Readline.Service());
         registerBuiltin("openssl.so", new RubyOpenSSL.Service());
         registerBuiltin("digest.so", new DigestLibrary());
         registerBuiltin("digest.rb", new DigestLibrary());
         registerBuiltin("digest/md5.rb", new DigestLibrary.MD5());
         registerBuiltin("digest/rmd160.rb", new DigestLibrary.RMD160());
         registerBuiltin("digest/sha1.rb", new DigestLibrary.SHA1());
         registerBuiltin("digest/sha2.rb", new DigestLibrary.SHA2());
         registerBuiltin("bigdecimal.rb", new BigDecimalLibrary());
     }
 
     private void registerBuiltin(String nm, Library lib) {
         if(profile.allowBuiltin(nm)) {
             loadService.registerBuiltin(nm,lib);
         }
     }
 
     private void initCoreClasses() {
         ObjectMetaClass objectMetaClass = new ObjectMetaClass(this);
         objectMetaClass.initializeClass();
         
         objectClass = objectMetaClass;
         objectClass.setConstant("Object", objectClass);
         RubyClass moduleClass = new ModuleMetaClass(this, objectClass);
         objectClass.setConstant("Module", moduleClass);
         RubyClass classClass = RubyClass.newClassClass(this, moduleClass);
         objectClass.setConstant("Class", classClass);
 
         // I don't think the containment is correct here (parent cref)
         RubyClass metaClass = objectClass.makeMetaClass(classClass, objectMetaClass.getCRef());
         metaClass = moduleClass.makeMetaClass(metaClass, objectMetaClass.getCRef());
         metaClass = classClass.makeMetaClass(metaClass, objectMetaClass.getCRef());
 
         ((ObjectMetaClass) moduleClass).initializeBootstrapClass();
         
         kernelModule = RubyKernel.createKernelModule(this);
         objectClass.includeModule(kernelModule);
 
         RubyClass.createClassClass(classClass);
 
         nilClass = RubyNil.createNilClass(this);
 
         // We cannot define this constant until nil itself was made
         objectClass.defineConstant("NIL", getNil());
         
         // Pre-create the core classes we know we will get referenced by starting up the runtime.
         RubyBoolean.createFalseClass(this);
         RubyBoolean.createTrueClass(this);
         RubyComparable.createComparable(this);
         RubyEnumerable.createEnumerableModule(this);
         stringClass = new StringMetaClass(this);
         stringClass.initializeClass();
         new SymbolMetaClass(this).initializeClass();
         if(profile.allowClass("ThreadGroup")) {
             RubyThreadGroup.createThreadGroupClass(this);
         }
         if(profile.allowClass("Thread")) {
             RubyThread.createThreadClass(this);
         }
         if(profile.allowClass("Exception")) {
             RubyException.createExceptionClass(this);
         }
         
         if(profile.allowModule("Precision")) {
             RubyPrecision.createPrecisionModule(this);
         }
 
         if(profile.allowClass("Numeric")) {
             new NumericMetaClass(this).initializeClass();
         }
         if(profile.allowClass("Fixnum")) {
             new IntegerMetaClass(this).initializeClass();        
             fixnumClass = new FixnumMetaClass(this);
             fixnumClass.initializeClass();
         }
         new HashMetaClass(this).initializeClass();
         new IOMetaClass(this).initializeClass();
         new ArrayMetaClass(this).initializeClass();
         
         RubyClass structClass = null;
         if(profile.allowClass("Struct")) {
             structClass = RubyStruct.createStructClass(this);
         }
         
         if(profile.allowClass("Tms")) {
             tmsStruct = RubyStruct.newInstance(structClass,
                                                new IRubyObject[] {
                                                    newString("Tms"),
                                                    newSymbol("utime"),
                                                    newSymbol("stime"),
                                                    newSymbol("cutime"),
                                                    newSymbol("cstime")});
         }
         
         if(profile.allowClass("Float")) {
             RubyFloat.createFloatClass(this);
         }        
 
         if(profile.allowClass("Bignum")) {
             new BignumMetaClass(this).initializeClass();
         }
         if(profile.allowClass("Binding")) {
             new BindingMetaClass(this).initializeClass();
         }
 
         if(profile.allowModule("Math")) {
             RubyMath.createMathModule(this); // depends on all numeric types
         }
         if(profile.allowClass("Regexp")) {
             RubyRegexp.createRegexpClass(this);
         }
         if(profile.allowClass("Range")) {
             RubyRange.createRangeClass(this);
         }
         if(profile.allowModule("ObjectSpace")) {
             RubyObjectSpace.createObjectSpaceModule(this);
         }
         if(profile.allowModule("GC")) {
             RubyGC.createGCModule(this);
         }
 
         if(profile.allowClass("Proc")) {
             new ProcMetaClass(this).initializeClass();
         }
 
         if(profile.allowClass("Method")) {
             RubyMethod.createMethodClass(this);
         }
 
         if(profile.allowClass("MatchData")) {
             RubyMatchData.createMatchDataClass(this);
         }
         if(profile.allowModule("Marshal")) {
             RubyMarshal.createMarshalModule(this);
         }
 
         if(profile.allowClass("Dir")) {
             RubyDir.createDirClass(this);
         }
 
         if(profile.allowModule("FileTest")) {
             RubyFileTest.createFileTestModule(this);
         }
 
         if(profile.allowClass("File")) {
             new FileMetaClass(this).initializeClass(); // depends on IO, FileTest
         }
 
         if(profile.allowModule("Process")) {
             RubyProcess.createProcessModule(this);
         }
         if(profile.allowClass("Time")) {
             new TimeMetaClass(this).initializeClass();
         }
         if(profile.allowClass("UnboundMethod")) {
             RubyUnboundMethod.defineUnboundMethodClass(this);
         }
         
         RubyClass exceptionClass = getClass("Exception");
         RubyClass standardError = null;
         RubyClass runtimeError = null;
         RubyClass ioError = null;
         RubyClass scriptError = null;
         RubyClass nameError = null;
         RubyClass rangeError = null;
         if(profile.allowClass("StandardError")) {
-            standardError = defineClass("StandardError", exceptionClass);
+            standardError = defineClass("StandardError", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("RuntimeError")) {
-            runtimeError = defineClass("RuntimeError", standardError);
+            runtimeError = defineClass("RuntimeError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("IOError")) {
-            ioError = defineClass("IOError", standardError);
+            ioError = defineClass("IOError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("ScriptError")) {
-            scriptError = defineClass("ScriptError", exceptionClass);
+            scriptError = defineClass("ScriptError", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("NameError")) {
             nameError = RubyNameError.createNameErrorClass(this, standardError);
         }
         if(profile.allowClass("RangeError")) {
-            rangeError = defineClass("RangeError", standardError);
+            rangeError = defineClass("RangeError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("SystemExit")) {
-            defineClass("SystemExit", exceptionClass);
+            defineClass("SystemExit", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("Fatal")) {
-            defineClass("Fatal", exceptionClass);
+            defineClass("Fatal", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("Interrupt")) {
-            defineClass("Interrupt", exceptionClass);
+            defineClass("Interrupt", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("SignalException")) {
-            defineClass("SignalException", exceptionClass);
+            defineClass("SignalException", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("TypeError")) {
-            defineClass("TypeError", standardError);
+            defineClass("TypeError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("ArgumentError")) {
-            defineClass("ArgumentError", standardError);
+            defineClass("ArgumentError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("IndexError")) {
-            defineClass("IndexError", standardError);
+            defineClass("IndexError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("SyntaxError")) {
-            defineClass("SyntaxError", scriptError);
+            defineClass("SyntaxError", scriptError, scriptError.getAllocator());
         }
         if(profile.allowClass("LoadError")) {
-            defineClass("LoadError", scriptError);
+            defineClass("LoadError", scriptError, scriptError.getAllocator());
         }
         if(profile.allowClass("NotImplementedError")) {
-            defineClass("NotImplementedError", scriptError);
+            defineClass("NotImplementedError", scriptError, scriptError.getAllocator());
         }
         if(profile.allowClass("NoMethodError")) {
-            defineClass("NoMethodError", nameError);
+            defineClass("NoMethodError", nameError, nameError.getAllocator());
         }
         if(profile.allowClass("SecurityError")) {
-            defineClass("SecurityError", standardError);
+            defineClass("SecurityError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("NoMemoryError")) {
-            defineClass("NoMemoryError", exceptionClass);
+            defineClass("NoMemoryError", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("RegexpError")) {
-            defineClass("RegexpError", standardError);
+            defineClass("RegexpError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("EOFError")) {
-            defineClass("EOFError", ioError);
+            defineClass("EOFError", ioError, ioError.getAllocator());
         }
         if(profile.allowClass("LocalJumpError")) {
-            defineClass("LocalJumpError", standardError);
+            defineClass("LocalJumpError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("ThreadError")) {
-            defineClass("ThreadError", standardError);
+            defineClass("ThreadError", standardError, standardError.getAllocator());
         }
         if(profile.allowClass("SystemStackError")) {
-            defineClass("SystemStackError", exceptionClass);
+            defineClass("SystemStackError", exceptionClass, exceptionClass.getAllocator());
         }
         if(profile.allowClass("ZeroDivisionError")) {
-            defineClass("ZeroDivisionError", standardError);
+            defineClass("ZeroDivisionError", standardError, standardError.getAllocator());
         }
         // FIXME: Actually this somewhere
         if(profile.allowClass("FloatDomainError")) {
-            defineClass("FloatDomainError", rangeError);
+            defineClass("FloatDomainError", rangeError, rangeError.getAllocator());
         }
         if(profile.allowClass("NativeException")) {
             NativeException.createClass(this, runtimeError);
         }
         if(profile.allowClass("SystemCallError")) {
-            systemCallError = defineClass("SystemCallError", standardError);
+            systemCallError = defineClass("SystemCallError", standardError, standardError.getAllocator());
         }
         if(profile.allowModule("Errno")) {
             errnoModule = defineModule("Errno");
         }
        
         initErrnoErrors();
 
         if(profile.allowClass("Data")) {
-            defineClass("Data",objectClass);
+            defineClass("Data", objectClass, objectClass.getAllocator());
         }
     }
 
     private void initBuiltinClasses() {
     	try {
 	        new BuiltinScript("FalseClass").load(this);
 	        new BuiltinScript("TrueClass").load(this);
     	} catch (IOException e) {
     		throw new Error("builtin scripts are missing", e);
     	}
     }
     
     /**
      * Create module Errno's Variables.  We have this method since Errno does not have it's 
      * own java class.
      */
     private void initErrnoErrors() {
         createSysErr(IErrno.ENOTEMPTY, "ENOTEMPTY");   
         createSysErr(IErrno.ERANGE, "ERANGE");      
         createSysErr(IErrno.ESPIPE, "ESPIPE");      
         createSysErr(IErrno.ENFILE, "ENFILE");      
         createSysErr(IErrno.EXDEV, "EXDEV");       
         createSysErr(IErrno.ENOMEM, "ENOMEM");      
         createSysErr(IErrno.E2BIG, "E2BIG");       
         createSysErr(IErrno.ENOENT, "ENOENT");      
         createSysErr(IErrno.ENOSYS, "ENOSYS");      
         createSysErr(IErrno.EDOM, "EDOM");        
         createSysErr(IErrno.ENOSPC, "ENOSPC");      
         createSysErr(IErrno.EINVAL, "EINVAL");      
         createSysErr(IErrno.EEXIST, "EEXIST");      
         createSysErr(IErrno.EAGAIN, "EAGAIN");      
         createSysErr(IErrno.ENXIO, "ENXIO");       
         createSysErr(IErrno.EILSEQ, "EILSEQ");      
         createSysErr(IErrno.ENOLCK, "ENOLCK");      
         createSysErr(IErrno.EPIPE, "EPIPE");       
         createSysErr(IErrno.EFBIG, "EFBIG");       
         createSysErr(IErrno.EISDIR, "EISDIR");      
         createSysErr(IErrno.EBUSY, "EBUSY");       
         createSysErr(IErrno.ECHILD, "ECHILD");      
         createSysErr(IErrno.EIO, "EIO");         
         createSysErr(IErrno.EPERM, "EPERM");       
         createSysErr(IErrno.EDEADLOCK, "EDEADLOCK");   
         createSysErr(IErrno.ENAMETOOLONG, "ENAMETOOLONG");
         createSysErr(IErrno.EMLINK, "EMLINK");      
         createSysErr(IErrno.ENOTTY, "ENOTTY");      
         createSysErr(IErrno.ENOTDIR, "ENOTDIR");     
         createSysErr(IErrno.EFAULT, "EFAULT");      
         createSysErr(IErrno.EBADF, "EBADF");       
         createSysErr(IErrno.EINTR, "EINTR");       
         createSysErr(IErrno.EWOULDBLOCK, "EWOULDBLOCK"); 
         createSysErr(IErrno.EDEADLK, "EDEADLK");     
         createSysErr(IErrno.EROFS, "EROFS");       
         createSysErr(IErrno.EMFILE, "EMFILE");      
         createSysErr(IErrno.ENODEV, "ENODEV");      
         createSysErr(IErrno.EACCES, "EACCES");      
         createSysErr(IErrno.ENOEXEC, "ENOEXEC");             
         createSysErr(IErrno.ESRCH, "ESRCH");       
         createSysErr(IErrno.ECONNREFUSED, "ECONNREFUSED");
         createSysErr(IErrno.ECONNRESET, "ECONNRESET");
         createSysErr(IErrno.EADDRINUSE, "EADDRINUSE");
     }
 
     /**
      * Creates a system error.
      * @param i the error code (will probably use a java exception instead)
      * @param name of the error to define.
      **/
     private void createSysErr(int i, String name) {
         if(profile.allowClass(name)) {
-            errnoModule.defineClassUnder(name, systemCallError).defineConstant("Errno", newFixnum(i));
+            errnoModule.defineClassUnder(name, systemCallError, systemCallError.getAllocator()).defineConstant("Errno", newFixnum(i));
         }
     }
     
 	/** Getter for property isVerbose.
      * @return Value of property isVerbose.
      */
     public IRubyObject getVerbose() {
         return verbose;
     }
 
     /** Setter for property isVerbose.
      * @param verbose New value of property isVerbose.
      */
     public void setVerbose(IRubyObject verbose) {
         this.verbose = verbose;
     }
 
 	/** Getter for property isDebug.
      * @return Value of property isDebug.
      */
     public IRubyObject getDebug() {
         return debug;
     }
 
     /** Setter for property isDebug.
      * @param debug New value of property isDebug.
      */
     public void setDebug(IRubyObject debug) {
         this.debug = debug;
     }
 
     public JavaSupport getJavaSupport() {
         return javaSupport;
     }
 
     /** Defines a global variable
      */
     public void defineVariable(final GlobalVariable variable) {
         globalVariables.define(variable.name(), new IAccessor() {
             public IRubyObject getValue() {
                 return variable.get();
             }
 
             public IRubyObject setValue(IRubyObject newValue) {
                 return variable.set(newValue);
             }
         });
     }
 
     /** defines a readonly global variable
      *
      */
     public void defineReadonlyVariable(String name, IRubyObject value) {
         globalVariables.defineReadonly(name, new ValueAccessor(value));
     }
 
     public Node parse(Reader content, String file, DynamicScope scope) {
         return parser.parse(file, content, scope);
     }
 
     public Node parse(String content, String file, DynamicScope scope) {
         return parser.parse(file, content, scope);
     }
 
     public ThreadService getThreadService() {
         return threadService;
     }
 
     public ThreadContext getCurrentContext() {
         return threadService.getCurrentContext();
     }
 
     /**
      * Returns the loadService.
      * @return ILoadService
      */
     public LoadService getLoadService() {
         return loadService;
     }
 
     public RubyWarnings getWarnings() {
         return warnings;
     }
 
     public PrintStream getErrorStream() {
         java.io.OutputStream os = ((RubyIO) getGlobalVariables().get("$stderr")).getOutStream();
         if(null != os) {
             return new PrintStream(os);
         } else {
             return new PrintStream(new org.jruby.util.SwallowingOutputStream());
         }
     }
 
     public InputStream getInputStream() {
         return ((RubyIO) getGlobalVariables().get("$stdin")).getInStream();
     }
 
     public PrintStream getOutputStream() {
         return new PrintStream(((RubyIO) getGlobalVariables().get("$stdout")).getOutStream());
     }
 
     public RubyModule getClassFromPath(String path) {
         if (path.charAt(0) == '#') {
             throw newArgumentError("can't retrieve anonymous class " + path);
         }
         IRubyObject type = evalScript(path);
         if (!(type instanceof RubyModule)) {
             throw newTypeError("class path " + path + " does not point class");
         }
         return (RubyModule) type;
     }
     
     /** Prints an error with backtrace to the error stream.
      *
      * MRI: eval.c - error_print()
      *
      */
     public void printError(RubyException excp) {
 		if (excp == null || excp.isNil()) {
             return;
         }
 
         ThreadContext tc = getCurrentContext();
         IRubyObject backtrace = excp.callMethod(tc, "backtrace");
 
         PrintStream errorStream = getErrorStream();
         if (backtrace.isNil() || !(backtrace instanceof RubyArray)) {
             if (tc.getSourceFile() != null) {
                 errorStream.print(tc.getPosition());
             } else {
                 errorStream.print(tc.getSourceLine());
             }
         } else if (((RubyArray) backtrace).getLength() == 0) {
             printErrorPos(errorStream);
         } else {
             IRubyObject mesg = ((RubyArray) backtrace).first(IRubyObject.NULL_ARRAY);
 
             if (mesg.isNil()) {
                 printErrorPos(errorStream);
             } else {
                 errorStream.print(mesg);
             }
         }
 
         RubyClass type = excp.getMetaClass();
         String info = excp.toString();
 
         if (type == getClass("RuntimeError") && (info == null || info.length() == 0)) {
             errorStream.print(": unhandled exception\n");
         } else {
             String path = type.getName();
 
             if (info.length() == 0) {
                 errorStream.print(": " + path + '\n');
             } else {
                 if (path.startsWith("#")) {
                     path = null;
                 }
 
                 String tail = null;
                 if (info.indexOf("\n") != -1) {
                     tail = info.substring(info.indexOf("\n") + 1);
                     info = info.substring(0, info.indexOf("\n"));
                 }
 
                 errorStream.print(": " + info);
 
                 if (path != null) {
                     errorStream.print(" (" + path + ")\n");
                 }
 
                 if (tail != null) {
                     errorStream.print(tail + '\n');
                 }
             }
         }
 
         excp.printBacktrace(errorStream);
 	}
 
 	private void printErrorPos(PrintStream errorStream) {
         ThreadContext tc = getCurrentContext();
         if (tc.getSourceFile() != null) {
             if (tc.getFrameLastFunc() != null) {
             	errorStream.print(tc.getPosition());
             	errorStream.print(":in '" + tc.getFrameLastFunc() + '\'');
             } else if (tc.getSourceLine() != 0) {
                 errorStream.print(tc.getPosition());
             } else {
             	errorStream.print(tc.getSourceFile());
             }
         }
     }
 
     /** This method compiles and interprets a Ruby script.
      *
      *  It can be used if you want to use JRuby as a Macro language.
      *
      */
     public void loadScript(RubyString scriptName, RubyString source, boolean wrap) {
         loadScript(scriptName.toString(), new StringReader(source.toString()), wrap);
     }
 
     public void loadScript(String scriptName, Reader source, boolean wrap) {
         IRubyObject self = getTopSelf();
 
         ThreadContext context = getCurrentContext();
 
         RubyModule wrapper = context.getWrapper();
 
         try {
             if (!wrap) {
                 secure(4); /* should alter global state */
 
                 context.preNodeEval(null, objectClass, self);
             } else {
                 /* load in anonymous module as toplevel */
                 context.preNodeEval(RubyModule.newModule(this, null), context.getWrapper(), self);
                 
                 self = getTopSelf().rbClone();
                 self.extendObject(context.getRubyClass());
             }
 
         	Node node = parse(source, scriptName, null);
             self.eval(node);
         } catch (JumpException je) {
         	if (je.getJumpType() == JumpException.JumpType.ReturnJump) {
         		// Make sure this does not bubble out to java caller.
         	} else {
         		throw je;
         	}
         } finally {
             context.postNodeEval(wrapper);
         }
     }
 
     public void loadNode(String scriptName, Node node, boolean wrap) {
         IRubyObject self = getTopSelf();
 
         ThreadContext context = getCurrentContext();
 
         RubyModule wrapper = context.getWrapper();
 
         try {
             if (!wrap) {
                 secure(4); /* should alter global state */
                 
                 context.preNodeEval(null, objectClass, self);
             } else {
 
                 /* load in anonymous module as toplevel */
                 context.preNodeEval(RubyModule.newModule(this, null), context.getWrapper(), self);
                 
                 self = getTopSelf().rbClone();
                 self.extendObject(context.getRubyClass());
             }
             
             self.eval(node);
         } catch (JumpException je) {
         	if (je.getJumpType() == JumpException.JumpType.ReturnJump) {
         		// Make sure this does not bubble out to java caller.
         	} else {
         		throw je;
         	}
         } finally {
             context.postNodeEval(wrapper);
         }
     }
 
 
     /** Loads, compiles and interprets a Ruby file.
      *  Used by Kernel#require.
      *
      *  @mri rb_load
      */
     public void loadFile(File file, boolean wrap) {
         assert file != null : "No such file to load";
         try {
             BufferedReader source = new BufferedReader(new FileReader(file));
             loadScript(file.getPath().replace(File.separatorChar, '/'), source, wrap);
             source.close();
         } catch (IOException ioExcptn) {
             throw newIOErrorFromException(ioExcptn);
         }
     }
 
     /** Call the trace function
      *
      * MRI: eval.c - call_trace_func
      *
      */
     public void callTraceFunction(ThreadContext context, String event, ISourcePosition position, 
             IRubyObject self, String name, IRubyObject type) {
         if (traceFunction == null) return;
 
         if (!context.isWithinTrace()) {
             context.setWithinTrace(true);
 
             ISourcePosition savePosition = context.getPosition();
             String file = position.getFile();
 
             if (file == null) file = "(ruby)";
             if (type == null) type = getFalse(); 
 
             context.preTrace();
 
             try {
                 traceFunction.call(new IRubyObject[] { newString(event), newString(file),
                         newFixnum(position.getEndLine()),
                         name != null ? RubySymbol.newSymbol(this, name) : getNil(),
                         self != null ? self : getNil(),
                         type });
             } finally {
                 context.postTrace();
                 context.setPosition(savePosition);
                 context.setWithinTrace(false);
             }
         }
     }
 
     public RubyProc getTraceFunction() {
         return traceFunction;
     }
 
     public void setTraceFunction(RubyProc traceFunction) {
         this.traceFunction = traceFunction;
     }
     public GlobalVariables getGlobalVariables() {
         return globalVariables;
     }
     
     // For JSR 223 support: see http://scripting.java.net/
     public void setGlobalVariables(GlobalVariables globalVariables) {
     	this.globalVariables = globalVariables;
     }
 
     public CallbackFactory callbackFactory(Class type) {
         return CallbackFactory.createFactory(type);
     }
 
     /**
      * Push block onto exit stack.  When runtime environment exits
      * these blocks will be evaluated.
      * 
      * @return the element that was pushed onto stack
      */
     public IRubyObject pushExitBlock(RubyProc proc) {
     	atExitBlocks.push(proc);
         return proc;
     }
     
     /**
      * Make sure Kernel#at_exit procs get invoked on runtime shutdown.
      * This method needs to be explicitly called to work properly.
      * I thought about using finalize(), but that did not work and I
      * am not sure the runtime will be at a state to run procs by the
      * time Ruby is going away.  This method can contain any other
      * things that need to be cleaned up at shutdown.  
      */
     public void tearDown() {
         while (!atExitBlocks.empty()) {
             RubyProc proc = (RubyProc) atExitBlocks.pop();
             
             proc.call(IRubyObject.NULL_ARRAY);
         }
         getObjectSpace().finishFinalizers();
     }
     
     // new factory methods ------------------------------------------------------------------------
     
     public RubyArray newArray() {
     	return RubyArray.newArray(this);
     }
     
     public RubyArray newArray(IRubyObject object) {
     	return RubyArray.newArray(this, object);
     }
 
     public RubyArray newArray(IRubyObject car, IRubyObject cdr) {
     	return RubyArray.newArray(this, car, cdr);
     }
     
     public RubyArray newArray(IRubyObject[] objects) {
     	return RubyArray.newArray(this, objects);
     }
     
     public RubyArray newArray(List list) {
     	return RubyArray.newArray(this, list);
     }
     
     public RubyArray newArray(int size) {
     	return RubyArray.newArray(this, size);
     }
     
     public RubyBoolean newBoolean(boolean value) {
     	return RubyBoolean.newBoolean(this, value);
     }
     
     public RubyFileStat newRubyFileStat(File file) {
     	return new RubyFileStat(this, JRubyFile.create(currentDirectory,file.getPath()));
     }
     
     public RubyFixnum newFixnum(long value) {
     	return RubyFixnum.newFixnum(this, value);
     }
     
     public RubyFloat newFloat(double value) {
     	return RubyFloat.newFloat(this, value);
     }
 
     public RubyNumeric newNumeric() {
     	return RubyNumeric.newNumeric(this);
     }
     
     public RubyProc newProc() {
     	return RubyProc.newProc(this, false);
     }
     
     public RubyBinding newBinding() {
         return RubyBinding.newBinding(this);
     }
     
     public RubyBinding newBinding(Block block) {
     	return RubyBinding.newBinding(this, block);
     }
 
     public RubyString newString(String string) {
     	return RubyString.newString(this, string);
     }
     
     public RubySymbol newSymbol(String string) {
     	return RubySymbol.newSymbol(this, string);
     }
     
     public RubyTime newTime(long milliseconds) {
         return RubyTime.newTime(this, milliseconds);
     }
     
     public RaiseException newArgumentError(String message) {
     	return newRaiseException(getClass("ArgumentError"), message);
     }
     
     public RaiseException newArgumentError(int got, int expected) {
     	return newRaiseException(getClass("ArgumentError"), "wrong # of arguments(" + got + " for " + expected + ")");
     }
     
     public RaiseException newErrnoEBADFError() {
     	return newRaiseException(getModule("Errno").getClass("EBADF"), "Bad file descriptor");
     }
 
     public RaiseException newErrnoEINVALError() {
     	return newRaiseException(getModule("Errno").getClass("EINVAL"), "Invalid file");
     }
 
     public RaiseException newErrnoENOENTError() {
     	return newRaiseException(getModule("Errno").getClass("ENOENT"), "File not found");
     }
 
     public RaiseException newErrnoESPIPEError() {
     	return newRaiseException(getModule("Errno").getClass("ESPIPE"), "Illegal seek");
     }
 
     public RaiseException newErrnoEBADFError(String message) {
     	return newRaiseException(getModule("Errno").getClass("EBADF"), message);
     }
 
     public RaiseException newErrnoEINVALError(String message) {
     	return newRaiseException(getModule("Errno").getClass("EINVAL"), message);
     }
 
     public RaiseException newErrnoENOENTError(String message) {
     	return newRaiseException(getModule("Errno").getClass("ENOENT"), message);
     }
 
     public RaiseException newErrnoESPIPEError(String message) {
     	return newRaiseException(getModule("Errno").getClass("ESPIPE"), message);
     }
 
     public RaiseException newErrnoEEXISTError(String message) {
     	return newRaiseException(getModule("Errno").getClass("EEXIST"), message);
     }
 
     public RaiseException newIndexError(String message) {
     	return newRaiseException(getClass("IndexError"), message);
     }
     
     public RaiseException newSecurityError(String message) {
     	return newRaiseException(getClass("SecurityError"), message);
     }
     
     public RaiseException newSystemCallError(String message) {
     	return newRaiseException(getClass("SystemCallError"), message);
     }
 
     public RaiseException newTypeError(String message) {
     	return newRaiseException(getClass("TypeError"), message);
     }
     
     public RaiseException newThreadError(String message) {
     	return newRaiseException(getClass("ThreadError"), message);
     }
     
     public RaiseException newSyntaxError(String message) {
     	return newRaiseException(getClass("SyntaxError"), message);
     }
 
     public RaiseException newRangeError(String message) {
     	return newRaiseException(getClass("RangeError"), message);
     }
 
     public RaiseException newNotImplementedError(String message) {
     	return newRaiseException(getClass("NotImplementedError"), message);
     }
 
     public RaiseException newNoMethodError(String message, String name) {
         return new RaiseException(new RubyNameError(this, this.getClass("NoMethodError"), message, name), true);
     }
 
     public RaiseException newNameError(String message, String name) {
         return new RaiseException(new RubyNameError(this, this.getClass("NameError"), message, name), true);
     }
 
     public RaiseException newLocalJumpError(String message) {
     	return newRaiseException(getClass("LocalJumpError"), message);
     }
 
     public RaiseException newLoadError(String message) {
     	return newRaiseException(getClass("LoadError"), message);
     }
 
     public RaiseException newFrozenError(String objectType) {
 		// TODO: Should frozen error have its own distinct class?  If not should more share?
     	return newRaiseException(getClass("TypeError"), "can't modify frozen " + objectType);
     }
 
     public RaiseException newSystemStackError(String message) {
     	return newRaiseException(getClass("SystemStackError"), message);
     }
     
     public RaiseException newSystemExit(int status) {
     	RaiseException re = newRaiseException(getClass("SystemExit"), "");
     	re.getException().setInstanceVariable("status", newFixnum(status));
     	
     	return re;
     }
     
 	public RaiseException newIOError(String message) {
 		return newRaiseException(getClass("IOError"), message);
     }
     
     public RaiseException newIOErrorFromException(IOException ioe) {
     	return newRaiseException(getClass("IOError"), ioe.getMessage());
     }
     
     public RaiseException newTypeError(IRubyObject receivedObject, RubyClass expectedType) {
     	return newRaiseException(getClass("TypeError"), "wrong argument type " + receivedObject.getMetaClass() + " (expected " + expectedType);
     }
     
     public RaiseException newEOFError() {
     	return newRaiseException(getClass("EOFError"), "End of file reached");
     }
     
     public RaiseException newZeroDivisionError() {
     	return newRaiseException(getClass("ZeroDivisionError"), "divided by 0");
     }
     
     /**
 	 * @param exceptionClass
 	 * @param message
 	 * @return
 	 */
 	private RaiseException newRaiseException(RubyClass exceptionClass, String message) {
 		RaiseException re = new RaiseException(this, exceptionClass, message, true);
 		return re;
 	}
 
 
 	public RubySymbol.SymbolTable getSymbolTable() {
 		return symbolTable;
 	}
 
 	public void setStackTraces(int stackTraces) {
 		this.stackTraces = stackTraces;
 	}
 
 	public int getStackTraces() {
 		return stackTraces;
 	}
 
 	public void setRandomSeed(long randomSeed) {
 		this.randomSeed = randomSeed;
 	}
 
 	public long getRandomSeed() {
 		return randomSeed;
 	}
 
 	public Random getRandom() {
 		return random;
 	}
 
 	public ObjectSpace getObjectSpace() {
 		return objectSpace;
 	}
 
 	public Hashtable getIoHandlers() {
 		return ioHandlers;
 	}
 
 	public RubyFixnum[] getFixnumCache() {
 		return fixnumCache;
 	}
 
 	public long incrementRandomSeedSequence() {
 		return randomSeedSequence++;
 	}
 
 	public InputStream getIn() {
 		return in;
 	}
 
 	public PrintStream getOut() {
 		return out;
 	}
 
 	public PrintStream getErr() {
 		return err;
 	}
 
 	public boolean isGlobalAbortOnExceptionEnabled() {
 		return globalAbortOnExceptionEnabled;
 	}
 
 	public void setGlobalAbortOnExceptionEnabled(boolean enable) {
 		globalAbortOnExceptionEnabled = enable;
 	}
 
 	public boolean isDoNotReverseLookupEnabled() {
 		return doNotReverseLookupEnabled;
 	}
 
 	public void setDoNotReverseLookupEnabled(boolean b) {
 		doNotReverseLookupEnabled = b;
 	}
 
     private ThreadLocal inspect = new ThreadLocal();
     public boolean registerInspecting(Object obj) {
         java.util.Map val = (java.util.Map)inspect.get();
         if(null == val) {
             val = new java.util.IdentityHashMap();
             inspect.set(val);
         }
         if(val.containsKey(obj)) {
             return false;
         }
         val.put(obj,null);
         return true;
     }
 
     public void unregisterInspecting(Object obj) {
         java.util.Map val = (java.util.Map)inspect.get();
         val.remove(obj);
     }
 
     public boolean isObjectSpaceEnabled() {
         return objectSpaceEnabled;
     }
 
     public long getStartTime() {
         return startTime;
     }
 
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
     
     public String getEncoding() {
         return encoding;
     }
 
     public Profile getProfile() {
         return profile;
     }
 
     public String getJRubyHome() {
         if (jrubyHome == null) {
             jrubyHome = System.getProperty("jruby.home", System.getProperty("user.home") + "/.jruby");
             new NormalizedFile(jrubyHome).mkdirs();
         }
         return jrubyHome;
     }
 
 }
diff --git a/src/org/jruby/RubyArray.java b/src/org/jruby/RubyArray.java
index 51f283898d..6ef14619f4 100644
--- a/src/org/jruby/RubyArray.java
+++ b/src/org/jruby/RubyArray.java
@@ -1,1666 +1,1670 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2005 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2006 Ola Bini <Ola.Bini@ki.se>
  * Copyright (C) 2006 Daniel Steer <damian.steer@hp.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.lang.reflect.Array;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
 import org.jruby.exceptions.RaiseException;
 import org.jruby.javasupport.JavaUtil;
 import org.jruby.javasupport.util.ConversionIterator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.builtin.meta.ArrayMetaClass;
 import org.jruby.runtime.builtin.meta.StringMetaClass;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.runtime.marshal.UnmarshalStream;
 import org.jruby.util.Pack;
 import org.jruby.util.collections.IdentitySet;
 
 /**
  * The implementation of the built-in class Array in Ruby.
  */
 public class RubyArray extends RubyObject implements List {
     private List list;
     private boolean tmpLock;
 
 	private RubyArray(IRuby runtime, List list) {
-		super(runtime, runtime.getClass("Array"));
+		this(runtime, runtime.getClass("Array"));
         this.list = list;
     }
+    
+    public RubyArray(IRuby runtime, RubyClass klass) {
+        super(runtime, klass);
+    }
 
     /** Getter for property list.
      * @return Value of property list.
      */
     public List getList() {
         return list;
     }
 
     public IRubyObject[] toJavaArray() {
         return (IRubyObject[])list.toArray(new IRubyObject[getLength()]);
     }
     
     public RubyArray convertToArray() {
     	return this;
     }
 
     /** Getter for property tmpLock.
      * @return Value of property tmpLock.
      */
     public boolean isTmpLock() {
         return tmpLock;
     }
 
     /** Setter for property tmpLock.
      * @param tmpLock New value of property tmpLock.
      */
     public void setTmpLock(boolean tmpLock) {
         this.tmpLock = tmpLock;
     }
 
     public int getLength() {
         return list.size();
     }
 
     public boolean includes(IRubyObject item) {
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = 0, n = getLength(); i < n; i++) {
             if (item.callMethod(context, "==", entry(i)).isTrue()) {
                 return true;
             }
         }
         return false;
     }
 
     public RubyFixnum hash() {
         return getRuntime().newFixnum(list.hashCode());
     }
 
     /** rb_ary_modify
      *
      */
     public void modify() {
     	testFrozen("Array");
         if (isTmpLock()) {
             throw getRuntime().newTypeError("can't modify array during sort");
         }
         if (isTaint() && getRuntime().getSafeLevel() >= 4) {
             throw getRuntime().newSecurityError("Insecure: can't modify array");
         }
     }
 
     /* if list's size is not at least 'toLength', add nil's until it is */
     private void autoExpand(long toLength) {
         //list.ensureCapacity((int) toLength);
         for (int i = getLength(); i < toLength; i++) {
             list.add(getRuntime().getNil());
         }
     }
 
     /** rb_ary_store
      *
      */
     private IRubyObject store(long index, IRubyObject value) {
         modify();
         if (index < 0) {
             index += getLength();
             if (index < 0) {
                 throw getRuntime().newIndexError("index " + (index - getLength()) + " out of array");
             }
         }
         autoExpand(index + 1);
         list.set((int) index, value);
         return value;
     }
 
     public IRubyObject entry(long offset) {
     	return entry(offset, false);
     }
     
     /** rb_ary_entry
      *
      */
     public IRubyObject entry(long offset, boolean throwException) {
         if (getLength() == 0) {
         	if (throwException) {
         		throw getRuntime().newIndexError("index " + offset + " out of array");
         	} 
         	return getRuntime().getNil();
         }
         if (offset < 0) {
             offset += getLength();
         }
         if (offset < 0 || getLength() <= offset) {
         	if (throwException) {
         		throw getRuntime().newIndexError("index " + offset + " out of array");
         	} 
             return getRuntime().getNil();
         }
         return (IRubyObject) list.get((int) offset);
     }
     
     public IRubyObject fetch(IRubyObject[] args) {
     	checkArgumentCount(args, 1, 2);
 
     	RubyInteger index = args[0].convertToInteger();
     	try {
     		return entry(index.getLongValue(), true);
     	} catch (RaiseException e) {
             ThreadContext tc = getRuntime().getCurrentContext();
     		// FIXME: use constant or method for IndexError lookup?
     		RubyException raisedException = e.getException();
     		if (raisedException.isKindOf(getRuntime().getClassFromPath("IndexError"))) {
 	    		if (args.length > 1) {
 	    			return args[1];
 	    		} else if (tc.isBlockGiven()) {
 	    			return tc.yield(index);
 	    		}
     		}
     		
     		throw e;
     	}
     }
     
     public IRubyObject insert(IRubyObject[] args) {
     	checkArgumentCount(args, 1, -1);
     	// ruby does not bother to bounds check index, if no elements are to be added.
     	if (args.length == 1) {
     	    return this;
     	}
     	
     	// too negative of an offset will throw an IndexError
     	long offset = args[0].convertToInteger().getLongValue();
     	if (offset < 0 && getLength() + offset < -1) {
     		throw getRuntime().newIndexError("index " + 
     				(getLength() + offset) + " out of array");
     	}
     	
     	// An offset larger than the current length will pad with nils
     	// to length
     	if (offset > getLength()) {
     		long difference = offset - getLength();
     		IRubyObject nil = getRuntime().getNil();
     		for (long i = 0; i < difference; i++) {
     			list.add(nil);
     		}
     	}
     	
     	if (offset < 0) {
     		offset += getLength() + 1;
     	}
     	
     	for (int i = 1; i < args.length; i++) {
     		list.add((int) (offset + i - 1), args[i]);
     	}
     	
     	return this;
     }
 
     public RubyArray transpose() {
     	RubyArray newArray = getRuntime().newArray();
     	int length = getLength();
     	
     	if (length == 0) {
     		return newArray;
     	}
 
     	for (int i = 0; i < length; i++) {
     	    if (!(entry(i) instanceof RubyArray)) {
     		    throw getRuntime().newTypeError("Some error");
     	    }
     	}
     	
     	int width = ((RubyArray) entry(0)).getLength();
 
 		for (int j = 0; j < width; j++) {
     		RubyArray columnArray = getRuntime().newArray(length);
     		
 			for (int i = 0; i < length; i++) {
 				try {
 				    columnArray.append((IRubyObject) ((RubyArray) entry(i)).list.get(j));
 				} catch (IndexOutOfBoundsException e) {
 					throw getRuntime().newIndexError("element size differ (" + i +
 							" should be " + width + ")");
 				}
     		}
 			
 			newArray.append(columnArray);
     	}
     	
     	return newArray;
     }
 
     public IRubyObject values_at(IRubyObject[] args) {
     	RubyArray newArray = getRuntime().newArray();
 
     	for (int i = 0; i < args.length; i++) {
     		IRubyObject o = aref(new IRubyObject[] {args[i]});
     		if (args[i] instanceof RubyRange) {
     			if (o instanceof RubyArray) {
     				for (Iterator j = ((RubyArray) o).getList().iterator(); j.hasNext();) {
     					newArray.append((IRubyObject) j.next());
     				}
     			}
     		} else {
     			newArray.append(o);    			
     		}
     	}
     	return newArray;
     }
     
     /** rb_ary_unshift
      *
      */
     public RubyArray unshift(IRubyObject item) {
         modify();
         list.add(0, item);
         return this;
     }
 
     /** rb_ary_subseq
      *
      */
     public IRubyObject subseq(long beg, long len) {
         int length = getLength();
 
         if (beg > length || beg < 0 || len < 0) {
             return getRuntime().getNil();
         }
 
         if (beg + len > length) {
             len = length - beg;
         }
         return len <= 0 ? getRuntime().newArray(0) :
         	getRuntime().newArray( 
         			new ArrayList(list.subList((int)beg, (int) (len + beg))));
     }
 
     /** rb_ary_replace
      *	@todo change the algorythm to make it efficient
      *			there should be no need to do any deletion or addition
      *			when the replacing object is an array of the same length
      *			and in any case we should minimize them, they are costly
      */
     public void replace(long beg, long len, IRubyObject repl) {
         int length = getLength();
 
         if (len < 0) {
             throw getRuntime().newIndexError("Negative array length: " + len);
         }
         if (beg < 0) {
             beg += length;
         }
         if (beg < 0) {
             throw getRuntime().newIndexError("Index out of bounds: " + beg);
         }
 
         modify();
 
         for (int i = 0; beg < getLength() && i < len; i++) {
             list.remove((int) beg);
         }
         autoExpand(beg);
         if (repl instanceof RubyArray) {
             List repList = ((RubyArray) repl).getList();
             //list.ensureCapacity(getLength() + repList.size());
             list.addAll((int) beg, new ArrayList(repList));
         } else if (!repl.isNil()) {
             list.add((int) beg, repl);
         }
     }
 
     private boolean flatten(List array) {
         return flatten(array, new IdentitySet(), null, -1);
     }
 
     private boolean flatten(List array, IdentitySet visited, List toModify, int index) {
         if (visited.contains(array)) {
             throw getRuntime().newArgumentError("tried to flatten recursive array");
         }
         visited.add(array);
         boolean isModified = false;
         for (int i = array.size() - 1; i >= 0; i--) {
             Object elem = array.get(i);
             if (elem instanceof RubyArray) {
                 if (toModify == null) { // This is the array to flatten
                     array.remove(i);
                     flatten(((RubyArray) elem).getList(), visited, array, i);
                 } else { // Sub-array, recurse
                     flatten(((RubyArray) elem).getList(), visited, toModify, index);
                 }
                 isModified = true;
             } else if (toModify != null) { // Add sub-list element to flattened array
                 toModify.add(index, elem);
             }
         }
         visited.remove(array);
         return isModified;
     }
 
     //
     // Methods of the Array Class (rb_ary_*):
     //
 
     /** rb_ary_new2
      *
      */
     public static final RubyArray newArray(final IRuby runtime, final long len) {
         return new RubyArray(runtime, new ArrayList((int) len));
     }
 
     /** rb_ary_new
      *
      */
     public static final RubyArray newArray(final IRuby runtime) {
         /* Ruby arrays default to holding 16 elements, so we create an
          * ArrayList of the same size if we're not told otherwise
          */
     	
         return new RubyArray(runtime, new ArrayList(16));
     }
 
     /**
      *
      */
     public static RubyArray newArray(IRuby runtime, IRubyObject obj) {
         ArrayList list = new ArrayList(1);
         list.add(obj);
         return new RubyArray(runtime, list);
     }
 
     /** rb_assoc_new
      *
      */
     public static RubyArray newArray(IRuby runtime, IRubyObject car, IRubyObject cdr) {
         ArrayList list = new ArrayList(2);
         list.add(car);
         list.add(cdr);
         return new RubyArray(runtime, list);
     }
 
     public static final RubyArray newArray(final IRuby runtime, final List list) {
         return new RubyArray(runtime, list);
     }
 
     public static RubyArray newArray(IRuby runtime, IRubyObject[] args) {
         final ArrayList list = new ArrayList(args.length);
         for (int i = 0; i < args.length; i++) {
             list.add(args[i]);
         }
         return new RubyArray(runtime, list);
     }
 
     /** rb_ary_length
      *
      */
     public RubyFixnum length() {
         return getRuntime().newFixnum(getLength());
     }
 
     /** rb_ary_push_m
      *
      */
     public RubyArray push(IRubyObject[] items) {
         modify();
         boolean tainted = false;
         for (int i = 0; i < items.length; i++) {
             tainted |= items[i].isTaint();
             list.add(items[i]);
         }
         setTaint(isTaint() || tainted);
         return this;
     }
 
     public RubyArray append(IRubyObject value) {
         modify();
         list.add(value);
         infectBy(value);
         return this;
     }
 
     /** rb_ary_pop
      *
      */
     public IRubyObject pop() {
         modify();
         int length = getLength();
         return length == 0 ? getRuntime().getNil() : 
         	(IRubyObject) list.remove(length - 1);
     }
 
     /** rb_ary_shift
      *
      */
     public IRubyObject shift() {
         modify();
         return getLength() == 0 ? getRuntime().getNil() : 
         	(IRubyObject) list.remove(0);
     }
 
     /** rb_ary_unshift_m
      *
      */
     public RubyArray unshift(IRubyObject[] items) {
         modify();
         boolean taint = false;
         for (int i = 0; i < items.length; i++) {
             taint |= items[i].isTaint();
             list.add(i, items[i]);
         }
         setTaint(isTaint() || taint);
         return this;
     }
 
     public RubyBoolean include_p(IRubyObject item) {
         return getRuntime().newBoolean(includes(item));
     }
 
     /** rb_ary_frozen_p
      *
      */
     public RubyBoolean frozen() {
         return getRuntime().newBoolean(isFrozen() || isTmpLock());
     }
 
     /** rb_ary_initialize
      */
     public IRubyObject initialize(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 0, 2);
         RubyArray arrayInitializer = null;
         long len = 0;
         if (argc > 0) {
         	if (args[0] instanceof RubyArray) {
         		arrayInitializer = (RubyArray)args[0];
         	} else {
         		len = convertToLong(args[0]);
         	}
         }
 
         modify();
 
         // Array initializer is provided
         if (arrayInitializer != null) {
         	list = new ArrayList(arrayInitializer.list);
         	return this;
         }
         
         // otherwise, continue with Array.new(fixnum, obj)
         if (len < 0) {
             throw getRuntime().newArgumentError("negative array size");
         }
         if (len > Integer.MAX_VALUE) {
             throw getRuntime().newArgumentError("array size too big");
         }
         list = new ArrayList((int) len);
         ThreadContext tc = getRuntime().getCurrentContext();
         if (len > 0) {
         	if (tc.isBlockGiven()) {
         		// handle block-based array initialization
                 for (int i = 0; i < len; i++) {
                     list.add(tc.yield(new RubyFixnum(getRuntime(), i)));
                 }
         	} else {
         		IRubyObject obj = (argc == 2) ? args[1] : getRuntime().getNil();
         		list.addAll(Collections.nCopies((int)len, obj));
         	}
         }
         return this;
     }
 
     /** rb_ary_aref
      */
     public IRubyObject aref(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 1, 2);
         if (argc == 2) {
             long beg = RubyNumeric.fix2long(args[0]);
             long len = RubyNumeric.fix2long(args[1]);
             if (beg < 0) {
                 beg += getLength();
             }
             return subseq(beg, len);
         }
         if (args[0] instanceof RubyFixnum) {
             return entry(RubyNumeric.fix2long(args[0]));
         }
         if (args[0] instanceof RubyBignum) {
             throw getRuntime().newIndexError("index too big");
         }
         if (args[0] instanceof RubyRange) {
             long[] begLen = ((RubyRange) args[0]).getBeginLength(getLength(), true, false);
 
             return begLen == null ? newArray(getRuntime()) : subseq(begLen[0], begLen[1]);
         }
         if(args[0] instanceof RubySymbol) {
             throw getRuntime().newTypeError("Symbol as array index");
         }
         return entry(args[0].convertToInteger().getLongValue());
     }
 
     /** rb_ary_aset
      *
      */
     public IRubyObject aset(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 2, 3);
         if (argc == 3) {
             long beg = args[0].convertToInteger().getLongValue();
             long len = args[1].convertToInteger().getLongValue();
             replace(beg, len, args[2]);
             return args[2];
         }
         if (args[0] instanceof RubyRange) {
             long[] begLen = ((RubyRange) args[0]).getBeginLength(getLength(), false, true);
             replace(begLen[0], begLen[1], args[1]);
             return args[1];
         }
         if (args[0] instanceof RubyBignum) {
             throw getRuntime().newIndexError("Index too large");
         }
         return store(args[0].convertToInteger().getLongValue(), args[1]);
     }
 
     /** rb_ary_at
      *
      */
     public IRubyObject at(IRubyObject pos) {
         return entry(convertToLong(pos));
     }
 
 	private long convertToLong(IRubyObject pos) {
 		if (pos instanceof RubyNumeric) {
 			return ((RubyNumeric) pos).getLongValue();
 		}
 		throw getRuntime().newTypeError("cannot convert " + pos.getType().getBaseName() + " to Integer");
 	}
 
 	/** rb_ary_concat
      *
      */
     public RubyArray concat(IRubyObject obj) {
         modify();
         RubyArray other = obj.convertToArray();
         list.addAll(other.getList());
         infectBy(other);
         return this;
     }
 
     /** rb_ary_inspect
      *
      */
     public IRubyObject inspect() {
         if(!getRuntime().registerInspecting(this)) {
             return getRuntime().newString("[...]");
         }
         try {
             int length = getLength();
 
             if (length == 0) {
                 return getRuntime().newString("[]");
             }
             RubyString result = getRuntime().newString("[");
             RubyString separator = getRuntime().newString(", ");
             ThreadContext context = getRuntime().getCurrentContext();
             for (int i = 0; i < length; i++) {
                 if (i > 0) {
                     result.append(separator);
                 }
                 result.append(entry(i).callMethod(context, "inspect"));
             }
             result.cat("]");
             return result;
         } finally {
             getRuntime().unregisterInspecting(this);
         }
     }
 
     /** rb_ary_first
      *
      */
     public IRubyObject first(IRubyObject[] args) {
     	checkArgumentCount(args, 0, 1);
 
     	if (args.length == 0) {
     		return getLength() == 0 ? getRuntime().getNil() : entry(0);
     	}
     	
     	// TODO: See if enough integer-only conversions to make this
     	// convenience function (which could replace RubyNumeric#fix2long).
     	if (!(args[0] instanceof RubyInteger)) {
             throw getRuntime().newTypeError("Cannot convert " + 
             		args[0].getType() + " into Integer");
     	}
     	
     	long length = ((RubyInteger)args[0]).getLongValue();
     	
     	if (length < 0) {
     		throw getRuntime().newArgumentError(
     				"negative array size (or size too big)");
     	}
     	
     	return subseq(0, length);
     }
 
     /** rb_ary_last
      *
      */
     public IRubyObject last(IRubyObject[] args) {
         int count = checkArgumentCount(args, 0, 1);
     	int length = getLength();
     	
     	int listSize = list.size();
     	int sublistSize = 0;
     	int startIndex = 0;
     		
     	switch (count) {
         case 0:
             return length == 0 ? getRuntime().getNil() : entry(length - 1);
         case 1:
             sublistSize = RubyNumeric.fix2int(args[0]);
             if (sublistSize == 0) {
                 return getRuntime().newArray();
             }
             if (sublistSize < 0) {
                 throw getRuntime().newArgumentError("negative array size (or size too big)");
             }
 
             startIndex = (sublistSize > listSize) ? 0 : listSize - sublistSize;
             return getRuntime().newArray(list.subList(startIndex, listSize));
         default:
             assert false;
         	return null;
         }
     }
 
     /** rb_ary_each
      *
      */
     public IRubyObject each() {
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = 0, len = getLength(); i < len; i++) {
             context.yield(entry(i));
         }
         return this;
     }
 
     /** rb_ary_each_index
      *
      */
     public IRubyObject each_index() {
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = 0, len = getLength(); i < len; i++) {
             context.yield(getRuntime().newFixnum(i));
         }
         return this;
     }
 
     /** rb_ary_reverse_each
      *
      */
     public IRubyObject reverse_each() {
         ThreadContext context = getRuntime().getCurrentContext();
         for (long i = getLength(); i > 0; i--) {
             context.yield(entry(i - 1));
         }
         return this;
     }
 
     /** rb_ary_join
      *
      */
     public RubyString join(RubyString sep) {
         StringBuffer buf = new StringBuffer();
         int length = getLength();
         if (length == 0) {
             getRuntime().newString("");
         }
         boolean taint = isTaint() || sep.isTaint();
         RubyString str;
         IRubyObject tmp = null;
         for (long i = 0; i < length; i++) {
             tmp = entry(i);
             taint |= tmp.isTaint();
             if (tmp instanceof RubyString) {
                 // do nothing
             } else if (tmp instanceof RubyArray) {
                 tmp = ((RubyArray) tmp).to_s_join(sep);
             } else {
                 tmp = RubyString.objAsString(tmp);
             }
             
             if (i > 0 && !sep.isNil()) {
                 buf.append(sep.toString());
             }
             buf.append(((RubyString)tmp).toString());
         }
         str = RubyString.newString(getRuntime(), buf.toString());
         str.setTaint(taint);
         return str;
     }
 
     /** rb_ary_join_m
      *
      */
     public RubyString join(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 0, 1);
         IRubyObject sep = (argc == 1) ? args[0] : getRuntime().getGlobalVariables().get("$,");
         return join(sep.isNil() ? getRuntime().newString("") : RubyString.stringValue(sep));
     }
 
     /** rb_ary_to_s
      *
      */
     public IRubyObject to_s() {
         if(!getRuntime().registerInspecting(this)) {
             return getRuntime().newString("[...]");
         }
         try {
             IRubyObject separatorObject = getRuntime().getGlobalVariables().get("$,");
             RubyString separator;
             if (separatorObject.isNil()) {
                 separator = getRuntime().newString("");
             } else {
                 separator = RubyString.stringValue(separatorObject);
             }
             return join(separator);
         } finally {
             getRuntime().unregisterInspecting(this);
         }
     }
 
     private IRubyObject to_s_join(RubyString sep) {
         if(!getRuntime().registerInspecting(this)) {
             return getRuntime().newString("[...]");
         }
         try {
             return join(sep);
         } finally {
             getRuntime().unregisterInspecting(this);
         }
     }
 
     /** rb_ary_to_a
      *
      */
     public RubyArray to_a() {
         return this;
     }
     
     public IRubyObject to_ary() {
     	return this;
     }
 
     /** rb_ary_equal
      *
      */
     public IRubyObject array_op_equal(IRubyObject obj) {
         if (this == obj) {
             return getRuntime().getTrue();
         }
 
         RubyArray ary;
         
         if (!(obj instanceof RubyArray)) {
             if (obj.respondsTo("to_ary")) {
                 ary = obj.convertToArray();
             } else {
                 return getRuntime().getFalse();
             }
         } else {
         	ary = (RubyArray) obj;
         }
         
         int length = getLength();
 
         if (length != ary.getLength()) {
             return getRuntime().getFalse();
         }
 
         for (long i = 0; i < length; i++) {
             if (!entry(i).callMethod(getRuntime().getCurrentContext(), "==", ary.entry(i)).isTrue()) {
                 return getRuntime().getFalse();
             }
         }
         return getRuntime().getTrue();
     }
 
     /** rb_ary_eql
      *
      */
     public RubyBoolean eql(IRubyObject obj) {
         if (!(obj instanceof RubyArray)) {
             return getRuntime().getFalse();
         }
         int length = getLength();
 
         RubyArray ary = (RubyArray) obj;
         
         if (length != ary.getLength()) {
             return getRuntime().getFalse();
         }
         
         ThreadContext context = getRuntime().getCurrentContext();
 
         for (long i = 0; i < length; i++) {
             if (!entry(i).callMethod(context, "eql?", ary.entry(i)).isTrue()) {
                 return getRuntime().getFalse();
             }
         }
         return getRuntime().getTrue();
     }
 
     /** rb_ary_compact_bang
      *
      */
     public IRubyObject compact_bang() {
         modify();
         boolean isChanged = false;
         for (int i = getLength() - 1; i >= 0; i--) {
             if (entry(i).isNil()) {
                 list.remove(i);
                 isChanged = true;
             }
         }
         return isChanged ? (IRubyObject) this : (IRubyObject) getRuntime().getNil();
     }
 
     /** rb_ary_compact
      *
      */
     public IRubyObject compact() {
         RubyArray ary = (RubyArray) dup();
         ary.compact_bang();
         return ary;
     }
 
     /** rb_ary_empty_p
      *
      */
     public IRubyObject empty_p() {
         return getLength() == 0 ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     /** rb_ary_clear
      *
      */
     public IRubyObject rb_clear() {
         modify();
         list.clear();
         return this;
     }
 
     /** rb_ary_fill
      *
      */
     public IRubyObject fill(IRubyObject[] args) {
         int beg = 0;
         int len = getLength();
         int argc;
         IRubyObject filObj;
         IRubyObject begObj;
         IRubyObject lenObj;
         IRuby runtime = getRuntime();
         ThreadContext tc = runtime.getCurrentContext();
         if (tc.isBlockGiven()) {
         	argc = checkArgumentCount(args, 0, 2);
         	filObj = null;
         	begObj = argc > 0 ? args[0] : null;
         	lenObj = argc > 1 ? args[1] : null;
         	argc++;
         } else {
         	argc = checkArgumentCount(args, 1, 3);
         	filObj = args[0];
         	begObj = argc > 1 ? args[1] : null;
         	lenObj = argc > 2 ? args[2] : null;
         }
         switch (argc) {
             case 1 :
                 break;
             case 2 :
                 if (begObj instanceof RubyRange) {
                     long[] begLen = ((RubyRange) begObj).getBeginLength(len, false, true);
                     beg = (int) begLen[0];
                     len = (int) begLen[1];
                     break;
                 }
                 /* fall through */
             default :
                 beg = begObj.isNil() ? beg : RubyNumeric.fix2int(begObj);
                 if (beg < 0 && (beg += len) < 0) {
                     throw getRuntime().newIndexError("Negative array index");
                 }
                 len -= beg;
                 if (argc == 3 && !lenObj.isNil()) {
                     len = RubyNumeric.fix2int(lenObj);
                 }
         }
 
         modify();
         autoExpand(beg + len);
         for (int i = beg; i < beg + len; i++) {
         	if (filObj == null) {
         		list.set(i, tc.yield(runtime.newFixnum(i)));
         	} else {
         		list.set(i, filObj);
         	}
         }
         return this;
     }
 
     /** rb_ary_index
      *
      */
     public IRubyObject index(IRubyObject obj) {
         ThreadContext context = getRuntime().getCurrentContext();
         int len = getLength();
         for (int i = 0; i < len; i++) {
             if (entry(i).callMethod(context, "==", obj).isTrue()) {
                 return getRuntime().newFixnum(i);
             }
         }
         return getRuntime().getNil();
     }
 
     /** rb_ary_rindex
      *
      */
     public IRubyObject rindex(IRubyObject obj) {
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = getLength() - 1; i >= 0; i--) {
             if (entry(i).callMethod(context, "==", obj).isTrue()) {
                 return getRuntime().newFixnum(i);
             }
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject indices(IRubyObject[] args) {
         IRubyObject[] result = new IRubyObject[args.length];
         boolean taint = false;
         for (int i = 0; i < args.length; i++) {
             result[i] = entry(RubyNumeric.fix2int(args[i]));
             taint |= result[i].isTaint();
         }
         // TODO: Why was is calling create, which used to skip array initialization?
-        IRubyObject ary = ((ArrayMetaClass) getMetaClass()).create(result);
+        IRubyObject ary = ArrayMetaClass.create(getMetaClass(), result);
         ary.setTaint(taint);
         return ary;
     }
 
     /** rb_ary_clone
      *
      */
     public IRubyObject rbClone() {
         RubyArray result = getRuntime().newArray(new ArrayList(list));
         result.setTaint(isTaint());
         result.initCopy(this);
         result.setFrozen(isFrozen());
         return result;
     }
 
     /** rb_ary_reverse_bang
      *
      */
     public IRubyObject reverse_bang() {
         modify();
         Collections.reverse(list);
         return this;
     }
 
     /** rb_ary_reverse_m
      *
      */
     public IRubyObject reverse() {
         RubyArray result = (RubyArray) dup();
         result.reverse_bang();
         return result;
     }
 
     /** rb_ary_collect
      *
      */
     public RubyArray collect() {
         ThreadContext tc = getRuntime().getCurrentContext();
         if (!tc.isBlockGiven()) {
             return (RubyArray) dup();
         }
         ArrayList ary = new ArrayList();
         for (int i = 0, len = getLength(); i < len; i++) {
             ary.add(tc.yield(entry(i)));
         }
         return new RubyArray(getRuntime(), ary);
     }
 
     /** rb_ary_collect_bang
      *
      */
     public RubyArray collect_bang() {
         modify();
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = 0, len = getLength(); i < len; i++) {
             list.set(i, context.yield(entry(i)));
         }
         return this;
     }
 
     /** rb_ary_delete
      *
      */
     public IRubyObject delete(IRubyObject obj) {
         modify();
         ThreadContext tc = getRuntime().getCurrentContext();
         IRubyObject result = getRuntime().getNil();
         for (int i = getLength() - 1; i >= 0; i--) {
             if (obj.callMethod(tc, "==", entry(i)).isTrue()) {
                 result = (IRubyObject) list.remove(i);
             }
         }
         if (result.isNil() && tc.isBlockGiven()) {
             result = tc.yield(entry(0));
         }
         return result;
     }
 
     /** rb_ary_delete_at
      *
      */
     public IRubyObject delete_at(IRubyObject obj) {
         modify();
         int pos = (int) obj.convertToInteger().getLongValue();
         int len = getLength();
         if (pos >= len) {
             return getRuntime().getNil();
         }
         
         return pos < 0 && (pos += len) < 0 ?
             getRuntime().getNil() : (IRubyObject) list.remove(pos);
     }
 
     /** rb_ary_reject_bang
      *
      */
     public IRubyObject reject_bang() {
         modify();
         IRubyObject retVal = getRuntime().getNil();
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = getLength() - 1; i >= 0; i--) {
             if (context.yield(entry(i)).isTrue()) {
                 retVal = (IRubyObject) list.remove(i);
             }
         }
         return retVal.isNil() ? (IRubyObject) retVal : (IRubyObject) this;
     }
 
     /** rb_ary_delete_if
      *
      */
     public IRubyObject delete_if() {
         reject_bang();
         return this;
     }
 
     /** rb_ary_replace
      *
      */
     public IRubyObject replace(IRubyObject other) {
         replace(0, getLength(), other.convertToArray());
         return this;
     }
 
     /** rb_ary_cmp
      *
      */
     public IRubyObject op_cmp(IRubyObject other) {
         RubyArray ary = other.convertToArray();
         int otherLen = ary.getLength();
         int len = getLength();
         int minCommon = Math.min(len, otherLen);
         ThreadContext context = getRuntime().getCurrentContext();
         RubyClass fixnumClass = getRuntime().getClass("Fixnum");
         for (int i = 0; i < minCommon; i++) {
         	IRubyObject result = entry(i).callMethod(context, "<=>", ary.entry(i));
             if (! result.isKindOf(fixnumClass) || RubyFixnum.fix2int(result) != 0) {
                 return result;
             }
         }
         if (len != otherLen) {
             return len < otherLen ? RubyFixnum.minus_one(getRuntime()) : RubyFixnum.one(getRuntime());
         }
         return RubyFixnum.zero(getRuntime());
     }
 
     /** rb_ary_slice_bang
      *
      */
     public IRubyObject slice_bang(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 1, 2);
         IRubyObject result = aref(args);
         if (argc == 2) {
             long beg = RubyNumeric.fix2long(args[0]);
             long len = RubyNumeric.fix2long(args[1]);
             replace(beg, len, getRuntime().getNil());
         } else if (args[0] instanceof RubyFixnum && RubyNumeric.fix2long(args[0]) < getLength()) {
             replace(RubyNumeric.fix2long(args[0]), 1, getRuntime().getNil());
         } else if (args[0] instanceof RubyRange) {
             long[] begLen = ((RubyRange) args[0]).getBeginLength(getLength(), false, true);
             replace(begLen[0], begLen[1], getRuntime().getNil());
         }
         return result;
     }
 
     /** rb_ary_assoc
      *
      */
     public IRubyObject assoc(IRubyObject arg) {
         for (int i = 0, len = getLength(); i < len; i++) {
             if (!(entry(i) instanceof RubyArray && ((RubyArray) entry(i)).getLength() > 0)) {
                 continue;
             }
             RubyArray ary = (RubyArray) entry(i);
             if (arg.callMethod(getRuntime().getCurrentContext(), "==", ary.entry(0)).isTrue()) {
                 return ary;
             }
         }
         return getRuntime().getNil();
     }
 
     /** rb_ary_rassoc
      *
      */
     public IRubyObject rassoc(IRubyObject arg) {
         ThreadContext context = getRuntime().getCurrentContext();
         
         for (int i = 0, len = getLength(); i < len; i++) {
             if (!(entry(i) instanceof RubyArray && ((RubyArray) entry(i)).getLength() > 1)) {
                 continue;
             }
             RubyArray ary = (RubyArray) entry(i);
             if (arg.callMethod(context, "==", ary.entry(1)).isTrue()) {
                 return ary;
             }
         }
         return getRuntime().getNil();
     }
 
     /** rb_ary_flatten_bang
      *
      */
     public IRubyObject flatten_bang() {
         modify();
         return flatten(list) ? this : getRuntime().getNil();
     }
 
     /** rb_ary_flatten
      *
      */
     public IRubyObject flatten() {
         RubyArray rubyArray = (RubyArray) dup();
         rubyArray.flatten_bang();
         return rubyArray;
     }
 
     /** rb_ary_nitems
      *
      */
     public IRubyObject nitems() {
         int count = 0;
         for (int i = 0, len = getLength(); i < len; i++) {
             count += entry(i).isNil() ? 0 : 1;
         }
         return getRuntime().newFixnum(count);
     }
 
     /** rb_ary_plus
      *
      */
     public IRubyObject op_plus(IRubyObject other) {
         List otherList = other.convertToArray().getList();
         List newList = new ArrayList(getLength() + otherList.size());
         newList.addAll(list);
         newList.addAll(otherList);
         return new RubyArray(getRuntime(), newList);
     }
 
     /** rb_ary_times
      *
      */
     public IRubyObject op_times(IRubyObject arg) {
         if (arg instanceof RubyString) {
             return join((RubyString) arg);
         }
 
         int len = (int) arg.convertToInteger().getLongValue();
         if (len < 0) {
             throw getRuntime().newArgumentError("negative argument");
         }
         ArrayList newList = new ArrayList(getLength() * len);
         for (int i = 0; i < len; i++) {
             newList.addAll(list);
         }
         return new RubyArray(getRuntime(), newList);
     }
 
     private static ArrayList uniq(List oldList) {
         ArrayList newList = new ArrayList(oldList.size());
         Set passed = new HashSet(oldList.size());
 
         for (Iterator iter = oldList.iterator(); iter.hasNext();) {
             Object item = iter.next();
             if (! passed.contains(item)) {
                 passed.add(item);
                 newList.add(item);
             }
         }
         newList.trimToSize();
         return newList;
     }
 
     /** rb_ary_uniq_bang
      *
      */
     public IRubyObject uniq_bang() {
         modify();
         ArrayList newList = uniq(list);
         if (newList.equals(list)) {
             return getRuntime().getNil();
         }
         list = newList;
         return this;
     }
 
     /** rb_ary_uniq
      *
      */
     public IRubyObject uniq() {
         return new RubyArray(getRuntime(), uniq(list));
     }
 
     /** rb_ary_diff
      *
      */
     public IRubyObject op_diff(IRubyObject other) {
         List ary1 = new ArrayList(list);
         List ary2 = other.convertToArray().getList();
         int len2 = ary2.size();
         ThreadContext context = getRuntime().getCurrentContext();
         
         for (int i = ary1.size() - 1; i >= 0; i--) {
             IRubyObject obj = (IRubyObject) ary1.get(i);
             for (int j = 0; j < len2; j++) {
                 if (obj.callMethod(context, "==", (IRubyObject) ary2.get(j)).isTrue()) {
                     ary1.remove(i);
                     break;
                 }
             }
         }
         return new RubyArray(getRuntime(), ary1);
     }
 
     /** rb_ary_and
      *
      */
     public IRubyObject op_and(IRubyObject other) {
     	RubyClass arrayClass = getRuntime().getClass("Array");
     	
     	// & only works with array types
     	if (!other.isKindOf(arrayClass)) {
     		throw getRuntime().newTypeError(other, arrayClass);
     	}
         List ary1 = uniq(list);
         int len1 = ary1.size();
         List ary2 = other.convertToArray().getList();
         int len2 = ary2.size();
         ArrayList ary3 = new ArrayList(len1);
         ThreadContext context = getRuntime().getCurrentContext();
         
         for (int i = 0; i < len1; i++) {
             IRubyObject obj = (IRubyObject) ary1.get(i);
             for (int j = 0; j < len2; j++) {
                 if (obj.callMethod(context, "eql?", (IRubyObject) ary2.get(j)).isTrue()) {
                     ary3.add(obj);
                     break;
                 }
             }
         }
         ary3.trimToSize();
         return new RubyArray(getRuntime(), ary3);
     }
 
     /** rb_ary_or
      *
      */
     public IRubyObject op_or(IRubyObject other) {
         List newArray = new ArrayList(list);
         
         newArray.addAll(other.convertToArray().getList());
         
         return new RubyArray(getRuntime(), uniq(newArray));
     }
 
     /** rb_ary_sort
      *
      */
     public RubyArray sort() {
         RubyArray rubyArray = (RubyArray) dup();
         rubyArray.sort_bang();
         return rubyArray;
     }
 
     /** rb_ary_sort_bang
      *
      */
     public IRubyObject sort_bang() {
         modify();
         setTmpLock(true);
 
         Comparator comparator;
         if (getRuntime().getCurrentContext().isBlockGiven()) {
             comparator = new BlockComparator();
         } else {
             comparator = new DefaultComparator();
         }
         Collections.sort(list, comparator);
 
         setTmpLock(false);
         return this;
     }
 
     public void marshalTo(MarshalStream output) throws IOException {
         output.write('[');
         output.dumpInt(getList().size());
         for (Iterator iter = getList().iterator(); iter.hasNext(); ) {
             output.dumpObject((IRubyObject) iter.next());
         }
     }
 
     public static RubyArray unmarshalFrom(UnmarshalStream input) throws IOException {
         RubyArray result = input.getRuntime().newArray();
         input.registerLinkTarget(result);
         int size = input.unmarshalInt();
         for (int i = 0; i < size; i++) {
             result.append(input.unmarshalObject());
         }
         return result;
     }
 
     /**
      * @see org.jruby.util.Pack#pack
      */
     public RubyString pack(IRubyObject obj) {
 	RubyString iFmt = RubyString.objAsString(obj);
         return Pack.pack(this.list, iFmt);
     }
 
     class BlockComparator implements Comparator {
         public int compare(Object o1, Object o2) {
             ThreadContext context = getRuntime().getCurrentContext();
             IRubyObject result = context.getFrameBlockOrRaise().yield(context, getRuntime().newArray((IRubyObject) o1, (IRubyObject) o2), null, null, true);
             return (int) ((RubyNumeric) result).getLongValue();
         }
     }
 
     static class DefaultComparator implements Comparator {
         public int compare(Object o1, Object o2) {
             IRubyObject obj1 = (IRubyObject) o1;
             IRubyObject obj2 = (IRubyObject) o2;
             if (o1 instanceof RubyFixnum && o2 instanceof RubyFixnum) {
             	long diff = RubyNumeric.fix2long(obj1) - RubyNumeric.fix2long(obj2);
 
             	return diff < 0 ? -1 : diff > 0 ? 1 : 0;
             }
 
             if (o1 instanceof RubyString && o2 instanceof RubyString) {
                 return RubyNumeric.fix2int(
                         ((RubyString)o1).op_cmp((RubyString)o2));
             }
 
             return RubyNumeric.fix2int(obj1.callMethod(obj1.getRuntime().getCurrentContext(), "<=>", obj2));
         }
     }
 
 
     public Class getJavaClass() {
         return List.class;
     }
     
     // Satisfy java.util.List interface (for Java integration)
     
 	public int size() {
 		return list.size();
 	}
 
 	public boolean isEmpty() {
 		return list.isEmpty();
 	}
 
 	public boolean contains(Object element) {
 		return list.contains(JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public Iterator iterator() {
 		return new ConversionIterator(list.iterator());
 	}
 
 	public Object[] toArray() {
 		Object[] array = new Object[getLength()];
 		Iterator iter = iterator();
 		
 		for (int i = 0; iter.hasNext(); i++) {
 			array[i] = iter.next();
 		}
 
 		return array;
 	}
 
 	public Object[] toArray(final Object[] arg) {
         Object[] array = arg;
         int length = getLength();
             
         if(array.length < length) {
             Class type = array.getClass().getComponentType();
             array = (Object[])Array.newInstance(type, length);
         }
 
         Iterator iter = iterator();
         for (int i = 0; iter.hasNext(); i++) {
             array[i] = iter.next();
         }
         
         return array;
 	}
 
 	public boolean add(Object element) {
 		return list.add(JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public boolean remove(Object element) {
 		return list.remove(JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public boolean containsAll(Collection c) {
 		for (Iterator iter = c.iterator(); iter.hasNext();) {
 			if (indexOf(iter.next()) == -1) {
 				return false;
 			}
 		}
 
 		return true;
 	}
 
 	public boolean addAll(Collection c) {
 		for (Iterator iter = c.iterator(); iter.hasNext(); ) {
 			add(iter.next());
 		}
 
 		return !c.isEmpty();
 	}
 
 	public boolean addAll(int index, Collection c) {
 		Iterator iter = c.iterator();
 		for (int i = index; iter.hasNext(); i++) {
 			add(i, iter.next());
 		}
 
 		return !c.isEmpty();
 	}
 
 	public boolean removeAll(Collection c) {
 		boolean changed = false;
 		
 		for (Iterator iter = c.iterator(); iter.hasNext();) {
 			if (remove(iter.next())) {
 				changed = true;
 			}
 		}
 
 		return changed;
 	}
 
 	public boolean retainAll(Collection c) {
 		boolean listChanged = false;
 		
 		for (Iterator iter = iterator(); iter.hasNext();) {
 			Object element = iter.next();
 			if (!c.contains(element)) {
 				remove(element);
 				listChanged = true;
 			}
 		}
 
 		return listChanged;
 	}
 
 	public Object get(int index) {
 		return JavaUtil.convertRubyToJava((IRubyObject) list.get(index), Object.class);
 	}
 
 	public Object set(int index, Object element) {
 		return list.set(index, JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public void add(int index, Object element) {
 		list.add(index, JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public Object remove(int index) {
 		return JavaUtil.convertRubyToJava((IRubyObject) list.remove(index), Object.class);
 	}
 
 	public int indexOf(Object element) {
 		return list.indexOf(JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public int lastIndexOf(Object element) {
 		return list.lastIndexOf(JavaUtil.convertJavaToRuby(getRuntime(), element));
 	}
 
 	public ListIterator listIterator() {
 		return new ConversionListIterator(list.listIterator());
 	}
 
 	public ListIterator listIterator(int index) {
 		return new ConversionListIterator(list.listIterator(index));
 	}
 
 	// TODO: list.subList(from, to).clear() is supposed to clear the sublist from the list.
 	// How can we support this operation?
 	public List subList(int fromIndex, int toIndex) {
 		if (fromIndex < 0 || toIndex > size() || fromIndex > toIndex) {
 			throw new IndexOutOfBoundsException();
 
 		}
 		IRubyObject subList = subseq(fromIndex, toIndex - fromIndex + 1);
 		
 		return subList.isNil() ? null : (List) subList;  
 	}
 
 	public void clear() {
 		list.clear();
 	}
 
 	class ConversionListIterator implements ListIterator {
 		private ListIterator iterator;
 
 		public ConversionListIterator(ListIterator iterator) {
 			this.iterator = iterator;
 		}
 
 		public boolean hasNext() {
 			return iterator.hasNext();
 		}
 
 		public Object next() {
 			return JavaUtil.convertRubyToJava((IRubyObject) iterator.next(), Object.class);
 		}
 
 		public boolean hasPrevious() {
 			return iterator.hasPrevious();
 		}
 
 		public Object previous() {
 			return JavaUtil.convertRubyToJava((IRubyObject) iterator.previous(), Object.class);
 		}
 
 		public int nextIndex() {
 			return iterator.nextIndex();
 		}
 
 		public int previousIndex() {
 			return iterator.previousIndex();
 		}
 
 		public void remove() {
 			iterator.remove();
 		}
 
 		public void set(Object arg0) {
 			// TODO Auto-generated method stub
 		}
 
 		public void add(Object arg0) {
 			// TODO Auto-generated method stub
 		}
 	}
 }
diff --git a/src/org/jruby/RubyBigDecimal.java b/src/org/jruby/RubyBigDecimal.java
index 3e6d9461bc..1f3d834856 100644
--- a/src/org/jruby/RubyBigDecimal.java
+++ b/src/org/jruby/RubyBigDecimal.java
@@ -1,525 +1,536 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 /**
  * $Id: $
  */
 package org.jruby;
 
 import java.math.BigDecimal;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  * @version $Revision: 1.2 $
  */
 public class RubyBigDecimal extends RubyNumeric {
+    private static final ObjectAllocator BIGDECIMAL_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyBigDecimal(runtime, klass);
+        }
+    };
+    
     public static RubyClass createBigDecimal(IRuby runtime) {
-        RubyClass result = runtime.defineClass("BigDecimal",runtime.getClass("Numeric"));
+        RubyClass result = runtime.defineClass("BigDecimal",runtime.getClass("Numeric"), BIGDECIMAL_ALLOCATOR);
 
         result.setConstant("ROUND_DOWN",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_DOWN));
         result.setConstant("SIGN_POSITIVE_INFINITE",RubyNumeric.int2fix(runtime,3));
         result.setConstant("EXCEPTION_OVERFLOW",RubyNumeric.int2fix(runtime,1));
         result.setConstant("SIGN_POSITIVE_ZERO",RubyNumeric.int2fix(runtime,1));
         result.setConstant("EXCEPTION_ALL",RubyNumeric.int2fix(runtime,255));
         result.setConstant("ROUND_CEILING",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_CEILING));
         result.setConstant("ROUND_UP",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_UP));
         result.setConstant("SIGN_NEGATIVE_FINITE",RubyNumeric.int2fix(runtime,-2));
         result.setConstant("EXCEPTION_UNDERFLOW",RubyNumeric.int2fix(runtime, 4));
         result.setConstant("SIGN_NaN",RubyNumeric.int2fix(runtime, 0));
         result.setConstant("BASE",RubyNumeric.int2fix(runtime,10000));
         result.setConstant("ROUND_HALF_DOWN",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_HALF_DOWN));
         result.setConstant("ROUND_MODE",RubyNumeric.int2fix(runtime,256));
         result.setConstant("SIGN_POSITIVE_FINITE",RubyNumeric.int2fix(runtime,2));
         result.setConstant("EXCEPTION_INFINITY",RubyNumeric.int2fix(runtime,1));
         result.setConstant("ROUND_HALF_EVEN",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_HALF_EVEN));
         result.setConstant("ROUND_HALF_UP",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_HALF_UP));
         result.setConstant("SIGN_NEGATIVE_INFINITE",RubyNumeric.int2fix(runtime,-3));
         result.setConstant("EXCEPTION_ZERODIVIDE",RubyNumeric.int2fix(runtime,1));
         result.setConstant("SIGN_NEGATIVE_ZERO",RubyNumeric.int2fix(runtime,-1));
         result.setConstant("EXCEPTION_NaN",RubyNumeric.int2fix(runtime,2));
         result.setConstant("ROUND_FLOOR",RubyNumeric.int2fix(runtime,BigDecimal.ROUND_FLOOR));
 
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyBigDecimal.class);
 
-        runtime.getModule("Kernel").defineModuleFunction("BigDecimal",callbackFactory.getOptSingletonMethod("newCreate"));
-        result.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newCreate"));
+        runtime.getModule("Kernel").defineModuleFunction("BigDecimal",callbackFactory.getOptSingletonMethod("newInstance"));
+        result.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
         result.defineFastSingletonMethod("ver", callbackFactory.getSingletonMethod("ver"));
         result.defineSingletonMethod("_load", callbackFactory.getSingletonMethod("_load",IRubyObject.class));
         result.defineFastSingletonMethod("double_fig", callbackFactory.getSingletonMethod("double_fig"));
         result.defineFastSingletonMethod("limit", callbackFactory.getSingletonMethod("limit",RubyFixnum.class));
         result.defineFastSingletonMethod("mode", callbackFactory.getSingletonMethod("mode",RubyFixnum.class,RubyFixnum.class));
 
         result.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         result.defineFastMethod("%", callbackFactory.getMethod("mod",IRubyObject.class));
         result.defineFastMethod("modulo", callbackFactory.getMethod("mod",IRubyObject.class));
         result.defineFastMethod("*", callbackFactory.getOptMethod("mult"));
         result.defineFastMethod("mult", callbackFactory.getOptMethod("mult"));
         result.defineFastMethod("**", callbackFactory.getMethod("power",RubyInteger.class));
         result.defineFastMethod("power", callbackFactory.getMethod("power",RubyInteger.class));
         result.defineFastMethod("+", callbackFactory.getOptMethod("add"));
         result.defineFastMethod("add", callbackFactory.getOptMethod("add"));
         result.defineFastMethod("-", callbackFactory.getOptMethod("sub"));
         result.defineFastMethod("sub", callbackFactory.getOptMethod("sub"));
         result.defineFastMethod("/", callbackFactory.getOptMethod("div"));
         result.defineFastMethod("div", callbackFactory.getOptMethod("div"));
         result.defineFastMethod("quo", callbackFactory.getOptMethod("div"));
         result.defineFastMethod("<=>", callbackFactory.getMethod("spaceship",IRubyObject.class));
         result.defineFastMethod("==", callbackFactory.getMethod("eql_p",IRubyObject.class));
         result.defineFastMethod("===", callbackFactory.getMethod("eql_p",IRubyObject.class));
         result.defineFastMethod("eql?", callbackFactory.getMethod("eql_p",IRubyObject.class));
         result.defineFastMethod("!=", callbackFactory.getMethod("ne",IRubyObject.class));
         result.defineFastMethod("<", callbackFactory.getMethod("lt",IRubyObject.class));
         result.defineFastMethod("<=", callbackFactory.getMethod("le",IRubyObject.class));
         result.defineFastMethod(">", callbackFactory.getMethod("gt",IRubyObject.class));
         result.defineFastMethod(">=", callbackFactory.getMethod("ge",IRubyObject.class));
         result.defineFastMethod("abs", callbackFactory.getMethod("abs"));
         result.defineFastMethod("ceil", callbackFactory.getMethod("ceil",RubyInteger.class));
         result.defineFastMethod("coerce", callbackFactory.getMethod("coerce",IRubyObject.class));
         result.defineFastMethod("divmod", callbackFactory.getMethod("divmod",IRubyObject.class)); 
         result.defineFastMethod("exponent", callbackFactory.getMethod("exponent"));
         result.defineFastMethod("finite?", callbackFactory.getMethod("finite_p"));
         result.defineFastMethod("fix", callbackFactory.getMethod("fix"));
         result.defineFastMethod("floor", callbackFactory.getMethod("floor",RubyInteger.class));
         result.defineFastMethod("frac", callbackFactory.getMethod("frac"));
         result.defineFastMethod("infinite?", callbackFactory.getMethod("infinite_p"));
         result.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
         result.defineFastMethod("nan?", callbackFactory.getMethod("nan_p"));
         result.defineFastMethod("nonzero?", callbackFactory.getMethod("nonzero_p"));
         result.defineFastMethod("precs", callbackFactory.getMethod("precs"));
         result.defineFastMethod("remainder", callbackFactory.getMethod("remainder",IRubyObject.class));
         result.defineFastMethod("round", callbackFactory.getOptMethod("round"));
         result.defineFastMethod("sign", callbackFactory.getMethod("sign"));
         result.defineFastMethod("split", callbackFactory.getMethod("split"));
         result.defineFastMethod("sqrt", callbackFactory.getOptMethod("sqrt"));
         result.defineFastMethod("to_f", callbackFactory.getMethod("to_f"));
         result.defineFastMethod("to_i", callbackFactory.getMethod("to_i"));
         result.defineFastMethod("to_int", callbackFactory.getMethod("to_int"));
         result.defineFastMethod("to_s", callbackFactory.getOptMethod("to_s"));
         result.defineFastMethod("truncate", callbackFactory.getOptMethod("truncate"));
         result.defineFastMethod("zero?", callbackFactory.getMethod("zero_p"));
 
         return result;
     }
 
     private BigDecimal value;
 
-    public RubyBigDecimal(IRuby runtime) {
-        this(runtime, new BigDecimal("0"));
+    public RubyBigDecimal(IRuby runtime, RubyClass klass) {
+        super(runtime, klass);
     }
 
     public RubyBigDecimal(IRuby runtime, BigDecimal value) {
-        super(runtime,runtime.getClass("BigDecimal"));
+        super(runtime, runtime.getClass("BigDecimal"));
         this.value = value;
     }
 
-    public static RubyBigDecimal newCreate(IRubyObject recv, IRubyObject[] args) {
-        RubyBigDecimal result = new RubyBigDecimal(recv.getRuntime());
+    public static RubyBigDecimal newInstance(IRubyObject recv, IRubyObject[] args) {
+        RubyClass klass = (RubyClass)recv;
+        
+        RubyBigDecimal result = (RubyBigDecimal)klass.allocate();
+        
         result.callInit(args);
+        
         return result;
     }
 
     public static IRubyObject ver(IRubyObject recv) {
         return recv.getRuntime().newString("1.0.1");
     }
 
     public static IRubyObject _load(IRubyObject recv, IRubyObject p1) {
         // TODO: implement
         return null;
     }
 
     public static IRubyObject double_fig(IRubyObject recv) {
         return recv.getRuntime().newFixnum(20);
     }
     
     public static IRubyObject limit(IRubyObject recv, RubyFixnum p1) {
         // TODO: implement
         return null;
     }
 
     public static IRubyObject mode(IRubyObject recv, RubyFixnum mode, RubyFixnum value) {
         // TODO: implement
         return null;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         String ss = args[0].toString();
         if(ss.trim().equals("")) {
             ss = "0";
         }
         this.value = new BigDecimal(ss);
         return this;
     }
 
     public IRubyObject mod(IRubyObject arg) {
         // TODO: implement
         return this;
     }
 
     public IRubyObject mult(IRubyObject[] args) {
         // TODO: better implementation
         RubyBigDecimal val = null;
         if(args[0] instanceof RubyBigDecimal) {
             val = (RubyBigDecimal)args[0];
         } else {
             val = (RubyBigDecimal)args[0].callMethod(getRuntime().getCurrentContext(), "to_d");
         }
         return new RubyBigDecimal(getRuntime(),value.multiply(val.value));
     }
 
     public IRubyObject power(RubyInteger arg) {
         // TODO: MUCH better implementation
         BigDecimal val = value;
         for(int i=0,j=RubyNumeric.fix2int(arg);i<j;i++) {
             val = val.multiply(val);
         }
         return new RubyBigDecimal(getRuntime(),val);
     }
 
     public IRubyObject add(IRubyObject[] args) {
         // TODO: better implementation
         RubyBigDecimal val = null;
         if(args[0] instanceof RubyBigDecimal) {
             val = (RubyBigDecimal)args[0];
         } else {
             val = (RubyBigDecimal)args[0].callMethod(getRuntime().getCurrentContext(), "to_d");
         }
         return new RubyBigDecimal(getRuntime(),value.add(val.value));
     }
 
     public IRubyObject sub(IRubyObject[] args) {
         // TODO: better implementation
         RubyBigDecimal val = null;
         if(args[0] instanceof RubyBigDecimal) {
             val = (RubyBigDecimal)args[0];
         } else {
             val = (RubyBigDecimal)args[0].callMethod(getRuntime().getCurrentContext(), "to_d");
         }
         return new RubyBigDecimal(getRuntime(),value.subtract(val.value));
     }
 
     public IRubyObject div(IRubyObject[] args) {
         // TODO: better implementation
         RubyBigDecimal val = null;
         if(args[0] instanceof RubyBigDecimal) {
             val = (RubyBigDecimal)args[0];
         } else {
             val = (RubyBigDecimal)args[0].callMethod(getRuntime().getCurrentContext(), "to_d");
         }
         return new RubyBigDecimal(getRuntime(),value.divide(val.value,BigDecimal.ROUND_HALF_EVEN));
     }
 
     private IRubyObject cmp(IRubyObject r, char op) {
         int e = 0;
         if(!(r instanceof RubyBigDecimal)) {
             e = RubyNumeric.fix2int(callCoerced("<=>",r));
         } else {
             RubyBigDecimal rb = (RubyBigDecimal)r;
             e = value.compareTo(rb.value);
         }
         switch(op) {
         case '*': return getRuntime().newFixnum(e);
         case '=': return (e==0)?getRuntime().getTrue():getRuntime().getFalse();
         case '!': return (e!=0)?getRuntime().getTrue():getRuntime().getFalse();
         case 'G': return (e>=0)?getRuntime().getTrue():getRuntime().getFalse();
         case '>': return (e> 0)?getRuntime().getTrue():getRuntime().getFalse();
         case 'L': return (e<=0)?getRuntime().getTrue():getRuntime().getFalse();
         case '<': return (e< 0)?getRuntime().getTrue():getRuntime().getFalse();
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject spaceship(IRubyObject arg) {
         return cmp(arg,'*');
     }
 
     public IRubyObject eql_p(IRubyObject arg) {
         return cmp(arg,'=');
     }
 
     public IRubyObject ne(IRubyObject arg) {
         return cmp(arg,'!');
     }
 
     public IRubyObject lt(IRubyObject arg) {
         return cmp(arg,'<');
     }
 
     public IRubyObject le(IRubyObject arg) {
         return cmp(arg,'L');
     }
 
     public IRubyObject gt(IRubyObject arg) {
         return cmp(arg,'>');
     }
 
     public IRubyObject ge(IRubyObject arg) {
         return cmp(arg,'G');
     }
 
     public RubyNumeric abs() {
         return new RubyBigDecimal(getRuntime(),value.abs());
     }
 
     public IRubyObject ceil(RubyInteger arg) {
         // TODO: implement correctly
         return this;
     }
 
     public IRubyObject coerce(IRubyObject other) {
         IRubyObject obj;
         if(other instanceof RubyFloat) {
             obj = getRuntime().newArray(other,to_f());
         } else {
-            obj = getRuntime().newArray(newCreate(other,new IRubyObject[]{other.callMethod(getRuntime().getCurrentContext(),"to_s")}),this);
+            obj = getRuntime().newArray(newInstance(other,new IRubyObject[]{other.callMethod(getRuntime().getCurrentContext(),"to_s")}),this);
         }
         return obj;
     }
 
     public double getDoubleValue() { return value.doubleValue(); }
     public long getLongValue() { return value.longValue(); }
 
     public IRubyObject divmod(IRubyObject arg) {
         // TODO: implement
         return getRuntime().getNil();
     }
 
     public IRubyObject exponent() {
         BigDecimal abs = value.abs();
         String unscaled = abs.unscaledValue().toString();
         int exponent = abs.toString().indexOf('.');
         return getRuntime().newFixnum(exponent);
     }
 
     public IRubyObject finite_p() {
         // TODO: implement correctly
         return getRuntime().getTrue();
     }
 
     public IRubyObject fix() {
         // TODO: implement correctly
         return this;
     }
 
     public IRubyObject floor(RubyInteger arg) {
         // TODO: implement correctly
         return this;
     }
  
     public IRubyObject frac() {
         // TODO: implement correctly
         return this;
     }
 
     public IRubyObject infinite_p() {
         // TODO: implement correctly
         return getRuntime().getFalse();
     }
 
     public IRubyObject inspect() {
         StringBuffer val = new StringBuffer("#<BigDecimal:").append(Integer.toHexString(System.identityHashCode(this))).append(",");
         val.append("'").append(this.callMethod(getRuntime().getCurrentContext(), "to_s")).append("'").append(",");
         int len = value.abs().unscaledValue().toString().length();
         int pow = len/4;
         val.append(len).append("(").append((pow+1)*4).append(")").append(">");
         return getRuntime().newString(val.toString());
     }
 
     public IRubyObject nan_p() {
         // TODO: implement correctly
         return getRuntime().getFalse();
     }
 
     public IRubyObject nonzero_p() {
         return value.signum() != 0 ? getRuntime().getTrue() : getRuntime().getFalse();
     }
  
     public IRubyObject precs() {
         // TODO: implement
         return getRuntime().getNil();
     }
 
     public IRubyObject remainder(IRubyObject arg) {
         // TODO: implement
         return this;
     }
 
     public IRubyObject round(IRubyObject[] args) {
         // TODO: implement
         return this;
     }
 
     public IRubyObject sign() {
         // TODO: implement correctly
         return getRuntime().newFixnum(value.signum());
     }
 
     public IRubyObject split() {
         // TODO: implement
         return getRuntime().getNil();
     }
 
     public IRubyObject sqrt(IRubyObject[] args) {
         // TODO: implement correctly
         return new RubyBigDecimal(getRuntime(),new BigDecimal(Math.sqrt(value.doubleValue())));
     }
 
     public IRubyObject to_f() {
         return RubyFloat.newFloat(getRuntime(),value.doubleValue());
     }
 
     public IRubyObject to_i() {
         return RubyNumeric.int2fix(getRuntime(),value.longValue());
     }
 
     public IRubyObject to_int() {
         // TODO: implement to handle infinity and stuff
         return RubyNumeric.int2fix(getRuntime(),value.longValue());
     }
 
     public IRubyObject to_s(IRubyObject[] args) {
         boolean engineering = true;
         boolean pos_sign = false;
         boolean pos_space = false;
         int groups = 0;
 
         if(args.length != 0 && !args[0].isNil()) {
             String format = args[0].toString();
             int start = 0;
             int end = format.length();
             if(format.length() > 0 && format.charAt(0) == '+') {
                 pos_sign = true;
                 start++;
             } else if(format.length() > 0 && format.charAt(0) == ' ') {
                 pos_sign = true;
                 pos_space = true;
                 start++;
             }
             if(format.length() > 0 && format.charAt(format.length()-1) == 'F') {
                 engineering = false;
                 end--;
             } else if(format.length() > 0 && format.charAt(format.length()-1) == 'E') {
                 engineering = true;
                 end--;
             }
             String nums = format.substring(start,end);
             if(nums.length()>0) {
                 groups = Integer.parseInt(nums);
             }
         }
 
         String out = null;
         if(engineering) {
             BigDecimal abs = value.abs();
             String unscaled = abs.unscaledValue().toString();
             int exponent = abs.toString().indexOf('.');
             if(-1 == exponent) {
                 exponent = abs.toString().length();
             }
             int signum = value.signum();
             StringBuffer build = new StringBuffer();
             build.append(signum == -1 ? "-" : (signum == 1 ? (pos_sign ? (pos_space ? " " : "+" ) : "") : ""));
             build.append("0.");
             if(0 == groups) {
                 build.append(unscaled);
             } else {
                 int index = 0;
                 String sep = "";
                 while(index < unscaled.length()) {
                     int next = index+groups;
                     if(next > unscaled.length()) {
                         next = unscaled.length();
                     }
                     build.append(sep).append(unscaled.substring(index,next));
                     sep = " ";
                     index += groups;
                 }
             }
             build.append("E").append(exponent);
             out = build.toString();
         } else {
             BigDecimal abs = value.abs();
             String unscaled = abs.unscaledValue().toString();
             int ix = abs.toString().indexOf('.');
             String whole = unscaled;
             String after = null;
             if(ix != -1) {
                 whole = unscaled.substring(0,ix);
                 after = unscaled.substring(ix);
             }
             int signum = value.signum();
             StringBuffer build = new StringBuffer();
             build.append(signum == -1 ? "-" : (signum == 1 ? (pos_sign ? (pos_space ? " " : "+" ) : "") : ""));
             if(0 == groups) {
                 build.append(whole);
                 if(null != after) {
                     build.append(".").append(after);
                 }
             } else {
                 int index = 0;
                 String sep = "";
                 while(index < whole.length()) {
                     int next = index+groups;
                     if(next > whole.length()) {
                         next = whole.length();
                     }
                     build.append(sep).append(whole.substring(index,next));
                     sep = " ";
                     index += groups;
                 }
                 if(null != after) {
                     build.append(".");
                     index = 0;
                     sep = "";
                     while(index < after.length()) {
                         int next = index+groups;
                         if(next > after.length()) {
                             next = after.length();
                         }
                         build.append(sep).append(after.substring(index,next));
                         sep = " ";
                         index += groups;
                     }
                 }
             }
             out = build.toString();
         }
 
         return getRuntime().newString(out);
     }
 
     public IRubyObject truncate(IRubyObject[] args) {
         // TODO: implement
         return this;
     }
 
     public RubyBoolean zero_p() {
         return value.signum() == 0 ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 }// RubyBigdecimal
diff --git a/src/org/jruby/RubyBoolean.java b/src/org/jruby/RubyBoolean.java
index bc4e57e68d..152fa99950 100644
--- a/src/org/jruby/RubyBoolean.java
+++ b/src/org/jruby/RubyBoolean.java
@@ -1,118 +1,119 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.marshal.MarshalStream;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyBoolean extends RubyObject {
 	private final IRuby runtime;
 	
 	private final boolean value;
 
 	public RubyBoolean(IRuby runtime, boolean value) {
 		super(runtime, null, // Don't initialize with class
 		false); // Don't put in object space
 		this.value = value;
 		this.runtime = runtime;
 	}
 	
 	public IRuby getRuntime() {
 		return runtime;
 	}
 	
 	public boolean isImmediate() {
 		return true;
 	}
 
 	public Class getJavaClass() {
 		return Boolean.TYPE;
 	}
 
 	public RubyClass getMetaClass() {
 		return value
 			? getRuntime().getClass("TrueClass")
 			: getRuntime().getClass("FalseClass");
 	}
 
 	public boolean isTrue() {
 		return value;
 	}
 
 	public boolean isFalse() {
 		return !value;
 	}
 
     public RubyFixnum id() {
         return getRuntime().newFixnum(value ? 2 : 0);
     }
 
     public static RubyClass createFalseClass(IRuby runtime) {
-		RubyClass falseClass = runtime.defineClass("FalseClass", runtime.getObject());
+		RubyClass falseClass = runtime.defineClass("FalseClass", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
 
 		falseClass.defineFastMethod("type", runtime.callbackFactory(RubyBoolean.class).getMethod("type"));
 
 		runtime.defineGlobalConstant("FALSE", runtime.getFalse());
 
 		return falseClass;
 	}
 
 	public static RubyClass createTrueClass(IRuby runtime) {
-		RubyClass trueClass = runtime.defineClass("TrueClass", runtime.getObject());
+		RubyClass trueClass = runtime.defineClass("TrueClass", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
 
 		trueClass.defineFastMethod("type", runtime.callbackFactory(RubyBoolean.class).getMethod("type"));
 
 		runtime.defineGlobalConstant("TRUE", runtime.getTrue());
 
 		return trueClass;
 	}
 
 	public static RubyBoolean newBoolean(IRuby runtime, boolean value) {
         return value ? runtime.getTrue() : runtime.getFalse();
 	}
 
 	/** false_type
 	 *  true_type
 	 *
 	 */
 	public RubyClass type() {
 		return getMetaClass();
 	}
 
 	public void marshalTo(MarshalStream output) throws java.io.IOException {
 		output.write(isTrue() ? 'T' : 'F');
 	}
 }
 
diff --git a/src/org/jruby/RubyClass.java b/src/org/jruby/RubyClass.java
index 98aac54977..0e4402d7e0 100644
--- a/src/org/jruby/RubyClass.java
+++ b/src/org/jruby/RubyClass.java
@@ -1,302 +1,303 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004-2005 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.HashMap;
 
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.runtime.marshal.UnmarshalStream;
 import org.jruby.util.collections.SinglyLinkedList;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyClass extends RubyModule {
 	
 	private final IRuby runtime;
     
     // the default allocator
     private final ObjectAllocator allocator;
 
     /**
      * @mri rb_boot_class
      */
     protected RubyClass(RubyClass superClass, ObjectAllocator allocator) {
         super(superClass.getRuntime(), superClass.getRuntime().getClass("Class"), superClass, null, null);
 
         infectBy(superClass);
         this.runtime = superClass.getRuntime();
         this.allocator = allocator;
     }
 
     protected RubyClass(IRuby runtime, RubyClass superClass, ObjectAllocator allocator) {
         super(runtime, null, superClass, null, null);
         this.allocator = allocator;
         this.runtime = runtime;
     }
 
     protected RubyClass(IRuby runtime, RubyClass metaClass, RubyClass superClass, ObjectAllocator allocator) {
         super(runtime, metaClass, superClass, null, null);
         this.allocator = allocator;
         this.runtime = runtime;
     }
     
     protected RubyClass(IRuby runtime, RubyClass metaClass, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef, String name) {
         super(runtime, metaClass, superClass, parentCRef, name);
         this.allocator = allocator;
         this.runtime = runtime;
     }
     
-    public IRubyObject allocate() {
+    public final IRubyObject allocate() {
         return getAllocator().allocate(getRuntime(), this);
     }
     
     public static RubyClass newClassClass(IRuby runtime, RubyClass moduleClass) {
         ObjectAllocator defaultAllocator = new ObjectAllocator() {
             public IRubyObject allocate(IRuby runtime, RubyClass klass) {
                 IRubyObject instance = new RubyObject(runtime, klass);
                 instance.setMetaClass(klass);
 
                 return instance;
             }
         };
         
         return new RubyClass(
                 runtime,
                 null /* FIXME: should be something else? */,
                 moduleClass,
                 defaultAllocator,
                 null,
                 "Class");
     }
     
     /* (non-Javadoc)
 	 * @see org.jruby.RubyObject#getRuntime()
 	 */
 	public IRuby getRuntime() {
 		return runtime;
 	}
 
     public boolean isModule() {
         return false;
     }
 
     public boolean isClass() {
         return true;
     }
 
     public static void createClassClass(RubyClass classClass) {
         CallbackFactory callbackFactory = classClass.getRuntime().callbackFactory(RubyClass.class);
         classClass.defineSingletonMethod("new", callbackFactory.getOptSingletonMethod("newClass"));
         classClass.defineMethod("allocate", callbackFactory.getMethod("allocate"));
         classClass.defineMethod("new", callbackFactory.getOptMethod("newInstance"));
         classClass.defineMethod("superclass", callbackFactory.getMethod("superclass"));
         classClass.defineSingletonMethod("inherited", callbackFactory.getSingletonMethod("inherited", IRubyObject.class));
         classClass.undefineMethod("module_function");
     }
     
     public static IRubyObject inherited(IRubyObject recv, IRubyObject arg) {
         return recv.getRuntime().getNil();
     }
 
     /** Invokes if  a class is inherited from an other  class.
      * 
      * MRI: rb_class_inherited
      * 
      * @since Ruby 1.6.7
      * 
      */
     public void inheritedBy(RubyClass superType) {
         if (superType == null) {
             superType = getRuntime().getObject();
         }
         superType.callMethod(getRuntime().getCurrentContext(), "inherited", this);
     }
 
     /** rb_singleton_class_clone
      *
      */
     public RubyClass getSingletonClassClone() {
         if (!isSingleton()) {
             return this;
         }
 
         MetaClass clone = new MetaClass(getRuntime(), getMetaClass(), getMetaClass().getAllocator(), getSuperClass().getCRef());
         clone.initCopy(this);
         clone.setInstanceVariables(new HashMap(getInstanceVariables()));
 
         return (RubyClass) cloneMethods(clone);
     }
 
     public boolean isSingleton() {
         return false;
     }
 
     public RubyClass getMetaClass() {
         RubyClass type = super.getMetaClass();
 
         return type != null ? type : getRuntime().getClass("Class");
     }
 
     public RubyClass getRealClass() {
         return this;
     }
 
     public MetaClass newSingletonClass(SinglyLinkedList parentCRef) {
         MetaClass newClass = new MetaClass(getRuntime(), this, this.getAllocator(), parentCRef);
         newClass.infectBy(this);
         return newClass;
     }
 
     public static RubyClass newClass(IRuby runtime, RubyClass superClass, SinglyLinkedList parentCRef, String name) {
         return new RubyClass(runtime, runtime.getClass("Class"), superClass, superClass.getAllocator(), parentCRef, name);
     }
 
     /** Create a new subclass of this class.
      * @return the new sublass
      * @throws TypeError if this is class `Class'
      * @mri rb_class_new
      */
     protected RubyClass subclass() {
         if (this == getRuntime().getClass("Class")) {
             throw getRuntime().newTypeError("can't make subclass of Class");
         }
         return new RubyClass(this, getAllocator());
     }
 
     /** rb_class_new_instance
      *
      */
     public IRubyObject newInstance(IRubyObject[] args) {
-        IRubyObject obj = (IRubyObject)getAllocator().allocate(getRuntime(), this);
+        IRubyObject obj = (IRubyObject)allocate();
         obj.callInit(args);
         return obj;
     }
     
     public ObjectAllocator getAllocator() {
         return allocator;
     }
 
     /** rb_class_s_new
      *
      */
     public static RubyClass newClass(IRubyObject recv, IRubyObject[] args) {
         final IRuby runtime = recv.getRuntime();
 
         RubyClass superClass;
         if (args.length > 0) {
             if (args[0] instanceof RubyClass) {
                 superClass = (RubyClass) args[0];
             } else {
                 throw runtime.newTypeError(
                     "wrong argument type " + args[0].getType().getName() + " (expected Class)");
             }
         } else {
             superClass = runtime.getObject();
         }
 
         ThreadContext tc = runtime.getCurrentContext();
-        RubyClass newClass = superClass.newSubClass(null,tc.peekCRef());
+        // use allocator of superclass, since this will be a pure Ruby class
+        RubyClass newClass = superClass.newSubClass(null, superClass.getAllocator(),tc.peekCRef());
 
         // call "initialize" method
         newClass.callInit(args);
 
         // call "inherited" method of the superclass
         newClass.inheritedBy(superClass);
 
 		if (tc.isBlockGiven()) {
             tc.getFrameBlock().yield(tc, null, newClass, newClass, false);
 		}
 
 		return newClass;
     }
 
     /** Return the real super class of this class.
      * 
      * rb_class_superclass
      *
      */
     public IRubyObject superclass() {
         RubyClass superClass = getSuperClass();
         while (superClass != null && superClass.isIncluded()) {
             superClass = superClass.getSuperClass();
         }
 
         return superClass != null ? superClass : getRuntime().getNil();
     }
 
     /** rb_class_s_inherited
      *
      */
     public static IRubyObject inherited(RubyClass recv) {
         throw recv.getRuntime().newTypeError("can't make subclass of Class");
     }
 
     public void marshalTo(MarshalStream output) throws java.io.IOException {
         output.write('c');
         output.dumpString(getName());
     }
 
     public static RubyModule unmarshalFrom(UnmarshalStream output) throws java.io.IOException {
         return (RubyClass) RubyModule.unmarshalFrom(output);
     }
 
-    public RubyClass newSubClass(String name, SinglyLinkedList parentCRef) {
+    public RubyClass newSubClass(String name, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
         RubyClass classClass = runtime.getClass("Class");
         
         // Cannot subclass 'Class' or metaclasses
         if (this == classClass) {
             throw runtime.newTypeError("can't make subclass of Class");
         } else if (this instanceof MetaClass) {
             throw runtime.newTypeError("can't make subclass of virtual class");
         }
 
-        RubyClass newClass = new RubyClass(runtime, classClass, this, getAllocator(), parentCRef, name);
+        RubyClass newClass = new RubyClass(runtime, classClass, this, allocator, parentCRef, name);
 
         newClass.makeMetaClass(getMetaClass(), newClass.getCRef());
         newClass.inheritedBy(this);
 
         if(null != name) {
             ((RubyModule)parentCRef.getValue()).setConstant(name, newClass);
         }
 
         return newClass;
     }
     
     protected IRubyObject doClone() {
     	return RubyClass.newClass(getRuntime(), getSuperClass(), null/*FIXME*/, getBaseName());
     }
 }
diff --git a/src/org/jruby/RubyDigest.java b/src/org/jruby/RubyDigest.java
index 69ad39ffb5..c3f3c74815 100644
--- a/src/org/jruby/RubyDigest.java
+++ b/src/org/jruby/RubyDigest.java
@@ -1,237 +1,246 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class RubyDigest {
     public static void createDigest(IRuby runtime) {
         RubyModule mDigest = runtime.defineModule("Digest");
-        RubyClass cDigestBase = mDigest.defineClassUnder("Base",runtime.getObject());
+        RubyClass cDigestBase = mDigest.defineClassUnder("Base",runtime.getObject(), Base.BASE_ALLOCATOR);
 
         CallbackFactory basecb = runtime.callbackFactory(Base.class);
         
         cDigestBase.defineFastSingletonMethod("new",basecb.getOptSingletonMethod("newInstance"));
         cDigestBase.defineFastSingletonMethod("digest",basecb.getSingletonMethod("s_digest",IRubyObject.class));
         cDigestBase.defineFastSingletonMethod("hexdigest",basecb.getSingletonMethod("s_hexdigest",IRubyObject.class));
 
         cDigestBase.defineMethod("initialize",basecb.getOptMethod("initialize"));
         cDigestBase.defineMethod("initialize_copy",basecb.getMethod("initialize_copy",IRubyObject.class));
         cDigestBase.defineFastMethod("clone",basecb.getMethod("rbClone"));
         cDigestBase.defineFastMethod("update",basecb.getMethod("update",IRubyObject.class));
         cDigestBase.defineFastMethod("<<",basecb.getMethod("update",IRubyObject.class));
         cDigestBase.defineFastMethod("digest",basecb.getMethod("digest"));
         cDigestBase.defineFastMethod("hexdigest",basecb.getMethod("hexdigest"));
         cDigestBase.defineFastMethod("to_s",basecb.getMethod("hexdigest"));
         cDigestBase.defineFastMethod("==",basecb.getMethod("eq",IRubyObject.class));
     }
 
     public static void createDigestMD5(IRuby runtime) {
         runtime.getLoadService().require("digest.so");
         RubyModule mDigest = runtime.getModule("Digest");
         RubyClass cDigestBase = mDigest.getClass("Base");
-        RubyClass cDigest_MD5 = mDigest.defineClassUnder("MD5",cDigestBase);
+        RubyClass cDigest_MD5 = mDigest.defineClassUnder("MD5",cDigestBase,cDigestBase.getAllocator());
         cDigest_MD5.setClassVar("metadata",runtime.newString("MD5"));
     }
 
     public static void createDigestRMD160(IRuby runtime) {
         runtime.getLoadService().require("digest.so");
         RubyModule mDigest = runtime.getModule("Digest");
         RubyClass cDigestBase = mDigest.getClass("Base");
-        RubyClass cDigest_RMD160 = mDigest.defineClassUnder("RMD160",cDigestBase);
+        RubyClass cDigest_RMD160 = mDigest.defineClassUnder("RMD160",cDigestBase,cDigestBase.getAllocator());
         cDigest_RMD160.setClassVar("metadata",runtime.newString("RIPEMD160"));
     }
 
     public static void createDigestSHA1(IRuby runtime) {
         runtime.getLoadService().require("digest.so");
         RubyModule mDigest = runtime.getModule("Digest");
         RubyClass cDigestBase = mDigest.getClass("Base");
-        RubyClass cDigest_SHA1 = mDigest.defineClassUnder("SHA1",cDigestBase);
+        RubyClass cDigest_SHA1 = mDigest.defineClassUnder("SHA1",cDigestBase,cDigestBase.getAllocator());
         cDigest_SHA1.setClassVar("metadata",runtime.newString("SHA1"));
     }
 
     public static void createDigestSHA2(IRuby runtime) {
         try {
             MessageDigest.getInstance("SHA-256");
         } catch(NoSuchAlgorithmException e) {
             throw runtime.newLoadError("SHA2 not supported");
         }
         runtime.getLoadService().require("digest.so");
         RubyModule mDigest = runtime.getModule("Digest");
         RubyClass cDigestBase = mDigest.getClass("Base");
-        RubyClass cDigest_SHA2_256 = mDigest.defineClassUnder("SHA256",cDigestBase);
+        RubyClass cDigest_SHA2_256 = mDigest.defineClassUnder("SHA256",cDigestBase,cDigestBase.getAllocator());
         cDigest_SHA2_256.setClassVar("metadata",runtime.newString("SHA-256"));
-        RubyClass cDigest_SHA2_384 = mDigest.defineClassUnder("SHA384",cDigestBase);
+        RubyClass cDigest_SHA2_384 = mDigest.defineClassUnder("SHA384",cDigestBase,cDigestBase.getAllocator());
         cDigest_SHA2_384.setClassVar("metadata",runtime.newString("SHA-384"));
-        RubyClass cDigest_SHA2_512 = mDigest.defineClassUnder("SHA512",cDigestBase);
+        RubyClass cDigest_SHA2_512 = mDigest.defineClassUnder("SHA512",cDigestBase,cDigestBase.getAllocator());
         cDigest_SHA2_512.setClassVar("metadata",runtime.newString("SHA-512"));
     }
 
     public static class Base extends RubyObject {
+        protected static ObjectAllocator BASE_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new Base(runtime, klass);
+            }
+        };
+        
         public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
             if(recv == recv.getRuntime().getModule("Digest").getClass("Base")) {
                 throw recv.getRuntime().newNotImplementedError("Digest::Base is an abstract class");
             }
 
             if(!((RubyClass)recv).isClassVarDefined("metadata")) {
                 throw recv.getRuntime().newNotImplementedError("the " + recv + "() function is unimplemented on this machine");
             }
 
-            Base result = new Base(recv.getRuntime(), (RubyClass)recv);
+            RubyClass klass = (RubyClass)recv;
+            
+            Base result = (Base)klass.allocate();
             try {
                 result.setAlgorithm(((RubyClass)recv).getClassVar("metadata"));
             } catch(NoSuchAlgorithmException e) {
                 throw recv.getRuntime().newNotImplementedError("the " + recv + "() function is unimplemented on this machine");
             }
             result.callInit(args);
             return result;
         }
         public static IRubyObject s_digest(IRubyObject recv, IRubyObject str) {
             String name = ((RubyClass)recv).getClassVar("metadata").toString();
             try {
                 MessageDigest md = MessageDigest.getInstance(name);
                 return recv.getRuntime().newString(new String(md.digest(str.toString().getBytes("PLAIN")),"ISO8859_1"));
             } catch(NoSuchAlgorithmException e) {
                 throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
             } catch(java.io.UnsupportedEncodingException e) {
                 throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
             }
         }
         public static IRubyObject s_hexdigest(IRubyObject recv, IRubyObject str) {
             String name = ((RubyClass)recv).getClassVar("metadata").toString();
             try {
                 MessageDigest md = MessageDigest.getInstance(name);
                 return recv.getRuntime().newString(toHex(md.digest(str.toString().getBytes("PLAIN"))));
             } catch(NoSuchAlgorithmException e) {
                 throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
             } catch(java.io.UnsupportedEncodingException e) {
                 throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
             }
         }
 
         private MessageDigest algo;
         private StringBuffer data;
 
         public Base(IRuby runtime, RubyClass type) {
             super(runtime,type);
             data = new StringBuffer();
         }
         
         public IRubyObject initialize(IRubyObject[] args) {
             if(args.length > 0 && !args[0].isNil()) {
                 update(args[0]);
             }
             return this;
         }
 
         public IRubyObject initialize_copy(IRubyObject obj) {
             if(this == obj) {
                 return this;
             }
             ((RubyObject)obj).checkFrozen();
 
             data = new StringBuffer(((Base)obj).data.toString());
             String name = ((Base)obj).algo.getAlgorithm();
             try {
                 algo = MessageDigest.getInstance(name);
             } catch(NoSuchAlgorithmException e) {
                 throw getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
             }
             return this;
         }
 
         public IRubyObject update(IRubyObject obj) {
             try {
                 data.append(obj);
                 algo.update(obj.toString().getBytes("PLAIN"));
             } catch(java.io.UnsupportedEncodingException e) {}
             return this;
         }
 
         public IRubyObject digest() {
             try {
                 algo.reset();
                 return getRuntime().newString(new String(algo.digest(data.toString().getBytes("PLAIN")),"ISO8859_1"));
             } catch(java.io.UnsupportedEncodingException e) {
                 return getRuntime().getNil();
             }
         }
 
         public IRubyObject hexdigest() {
             try {
                 algo.reset();
                 return getRuntime().newString(toHex(algo.digest(data.toString().getBytes("PLAIN"))));
             } catch(java.io.UnsupportedEncodingException e) {
                 return getRuntime().getNil();
             }
         }
 
         public IRubyObject eq(IRubyObject oth) {
             boolean ret = this == oth;
             if(!ret && oth instanceof Base) {
                 Base b = (Base)oth;
                 ret = this.algo.getAlgorithm().equals(b.algo.getAlgorithm()) &&
                     this.digest().equals(b.digest());
             }
 
             return ret ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject rbClone() {
             IRubyObject clone = new Base(getRuntime(),getMetaClass().getRealClass());
             clone.setMetaClass(getMetaClass().getSingletonClassClone());
             clone.setTaint(this.isTaint());
             clone.initCopy(this);
             clone.setFrozen(isFrozen());
             return clone;
         }
 
         private void setAlgorithm(IRubyObject algo) throws NoSuchAlgorithmException {
             this.algo = MessageDigest.getInstance(algo.toString());
         }
 
         private static String toHex(byte[] val) {
             StringBuffer out = new StringBuffer();
             for(int i=0,j=val.length;i<j;i++) {
                 String ve = Integer.toString((((int)((char)val[i])) & 0xFF),16);
                 if(ve.length() == 1) {
                     ve = "0" + ve;
                 }
                 out.append(ve);
             }
             return out.toString();
         }
     }
 }// RubyDigest
diff --git a/src/org/jruby/RubyDir.java b/src/org/jruby/RubyDir.java
index f4ac4af66a..5611198462 100644
--- a/src/org/jruby/RubyDir.java
+++ b/src/org/jruby/RubyDir.java
@@ -1,460 +1,460 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jruby.javasupport.JavaUtil;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.Glob;
 import org.jruby.util.JRubyFile;
 
 /**
  * .The Ruby built-in class Dir.
  *
  * @author  jvoegele
  */
 public class RubyDir extends RubyObject {
 	// What we passed to the constructor for method 'path'
     private RubyString    path;
     protected JRubyFile      dir;
     private   String[]  snapshot;   // snapshot of contents of directory
     private   int       pos;        // current position in directory
     private boolean isOpen = true;
 
     public RubyDir(IRuby runtime, RubyClass type) {
         super(runtime, type);
     }
+    
+    private static ObjectAllocator DIR_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyDir(runtime, klass);
+        }
+    };
 
     public static RubyClass createDirClass(IRuby runtime) {
-        RubyClass dirClass = runtime.defineClass("Dir", runtime.getObject());
+        RubyClass dirClass = runtime.defineClass("Dir", runtime.getObject(), DIR_ALLOCATOR);
 
         dirClass.includeModule(runtime.getModule("Enumerable"));
 
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyDir.class);
 
-		dirClass.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
         dirClass.defineSingletonMethod("glob", callbackFactory.getSingletonMethod("glob", RubyString.class));
         dirClass.defineFastSingletonMethod("entries", callbackFactory.getSingletonMethod("entries", RubyString.class));
         dirClass.defineSingletonMethod("[]", callbackFactory.getSingletonMethod("glob", RubyString.class));
         // dirClass.defineAlias("[]", "glob");
         dirClass.defineSingletonMethod("chdir", callbackFactory.getOptSingletonMethod("chdir"));
         dirClass.defineFastSingletonMethod("chroot", callbackFactory.getSingletonMethod("chroot", RubyString.class));
         //dirClass.defineSingletonMethod("delete", callbackFactory.getSingletonMethod(RubyDir.class, "delete", RubyString.class));
         dirClass.defineSingletonMethod("foreach", callbackFactory.getSingletonMethod("foreach", RubyString.class));
         dirClass.defineFastSingletonMethod("getwd", callbackFactory.getSingletonMethod("getwd"));
         dirClass.defineFastSingletonMethod("pwd", callbackFactory.getSingletonMethod("getwd"));
         // dirClass.defineAlias("pwd", "getwd");
         dirClass.defineFastSingletonMethod("mkdir", callbackFactory.getOptSingletonMethod("mkdir"));
         dirClass.defineSingletonMethod("open", callbackFactory.getSingletonMethod("open", RubyString.class));
         dirClass.defineFastSingletonMethod("rmdir", callbackFactory.getSingletonMethod("rmdir", RubyString.class));
         dirClass.defineFastSingletonMethod("unlink", callbackFactory.getSingletonMethod("rmdir", RubyString.class));
         dirClass.defineFastSingletonMethod("delete", callbackFactory.getSingletonMethod("rmdir", RubyString.class));
         // dirClass.defineAlias("unlink", "rmdir");
         // dirClass.defineAlias("delete", "rmdir");
 
         dirClass.defineFastMethod("close", callbackFactory.getMethod("close"));
         dirClass.defineMethod("each", callbackFactory.getMethod("each"));
         dirClass.defineFastMethod("entries", callbackFactory.getMethod("entries"));
         dirClass.defineFastMethod("path", callbackFactory.getMethod("path"));
         dirClass.defineFastMethod("tell", callbackFactory.getMethod("tell"));
         dirClass.defineAlias("pos", "tell");
         dirClass.defineFastMethod("seek", callbackFactory.getMethod("seek", RubyFixnum.class));
         dirClass.defineFastMethod("pos=", callbackFactory.getMethod("setPos", RubyFixnum.class));
         dirClass.defineFastMethod("read", callbackFactory.getMethod("read"));
         dirClass.defineFastMethod("rewind", callbackFactory.getMethod("rewind"));
 		dirClass.defineMethod("initialize", callbackFactory.getMethod("initialize", RubyString.class));
 
         return dirClass;
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyDir result = new RubyDir(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     /**
      * Creates a new <code>Dir</code>.  This method takes a snapshot of the
      * contents of the directory at creation time, so changes to the contents
      * of the directory will not be reflected during the lifetime of the
      * <code>Dir</code> object returned, so a new <code>Dir</code> instance
      * must be created to reflect changes to the underlying file system.
      */
     public IRubyObject initialize(RubyString newPath) {
         newPath.checkSafeString();
 
         dir = JRubyFile.create(getRuntime().getCurrentDirectory(),newPath.toString());
         if (!dir.isDirectory()) {
             dir = null;
             throw getRuntime().newErrnoENOENTError(newPath.toString() + " is not a directory");
         }
         path = newPath;
 		List snapshotList = new ArrayList();
 		snapshotList.add(".");
 		snapshotList.add("..");
 		snapshotList.addAll(getContents(dir));
 		snapshot = (String[]) snapshotList.toArray(new String[snapshotList.size()]);
 		pos = 0;
 
         return this;
     }
 
 // ----- Ruby Class Methods ----------------------------------------------------
 
     /**
      * Returns an array of filenames matching the specified wildcard pattern
      * <code>pat</code>. If a block is given, the array is iterated internally
      * with each filename is passed to the block in turn. In this case, Nil is
      * returned.  
      */
     public static IRubyObject glob(IRubyObject recv, RubyString pat) {
         String pattern = pat.toString();
         String[] files = new Glob(recv.getRuntime().getCurrentDirectory(), pattern).getNames();
         ThreadContext context = recv.getRuntime().getCurrentContext();
         if (context.isBlockGiven()) {
             for (int i = 0; i < files.length; i++) {
                 context.yield(JavaUtil.convertJavaToRuby(recv.getRuntime(), files[i]));
             }
             return recv.getRuntime().getNil();
         }            
         return recv.getRuntime().newArray(JavaUtil.convertJavaArrayToRuby(recv.getRuntime(), files));
     }
 
     /**
      * @return all entries for this Dir
      */
     public RubyArray entries() {
         return getRuntime().newArray(JavaUtil.convertJavaArrayToRuby(getRuntime(), snapshot));
     }
     
     /**
      * Returns an array containing all of the filenames in the given directory.
      */
     public static RubyArray entries(IRubyObject recv, RubyString path) {
         final JRubyFile directory = JRubyFile.create(recv.getRuntime().getCurrentDirectory(),path.toString());
         
         if (!directory.isDirectory()) {
             throw recv.getRuntime().newErrnoENOENTError("No such directory");
         }
         List fileList = getContents(directory);
 		fileList.add(0,".");
 		fileList.add(1,"..");
         Object[] files = fileList.toArray();
         return recv.getRuntime().newArray(JavaUtil.convertJavaArrayToRuby(recv.getRuntime(), files));
     }
 
     /** Changes the current directory to <code>path</code> */
     public static IRubyObject chdir(IRubyObject recv, IRubyObject[] args) {
         recv.checkArgumentCount(args, 0, 1);
         RubyString path = args.length == 1 ? 
             (RubyString) args[0].convertToString() : getHomeDirectoryPath(recv); 
         JRubyFile dir = getDir(recv.getRuntime(), path.toString(), true);
         String realPath = null;
         String oldCwd = recv.getRuntime().getCurrentDirectory();
         
         // We get canonical path to try and flatten the path out.
         // a dir '/subdir/..' should return as '/'
         // cnutter: Do we want to flatten path out?
         try {
             realPath = dir.getCanonicalPath();
         } catch (IOException e) {
             realPath = dir.getAbsolutePath();
         }
         
         IRubyObject result = null;
         ThreadContext tc = recv.getRuntime().getCurrentContext();
         if (tc.isBlockGiven()) {
         	// FIXME: Don't allow multiple threads to do this at once
             recv.getRuntime().setCurrentDirectory(realPath);
             try {
                 result = tc.yield(path);
             } finally {
                 recv.getRuntime().setCurrentDirectory(oldCwd);
             }
         } else {
         	recv.getRuntime().setCurrentDirectory(realPath);
         	result = recv.getRuntime().newFixnum(0);
         }
         
         return result;
     }
 
     /**
      * Changes the root directory (only allowed by super user).  Not available
      * on all platforms.
      */
     public static IRubyObject chroot(IRubyObject recv, RubyString path) {
         throw recv.getRuntime().newNotImplementedError("chroot not implemented: chroot is non-portable and is not supported.");
     }
 
     /**
      * Deletes the directory specified by <code>path</code>.  The directory must
      * be empty.
      */
     public static IRubyObject rmdir(IRubyObject recv, RubyString path) {
         JRubyFile directory = getDir(recv.getRuntime(), path.toString(), true);
         
         if (!directory.delete()) {
             throw recv.getRuntime().newSystemCallError("No such directory");
         }
         
         return recv.getRuntime().newFixnum(0);
     }
 
     /**
      * Executes the block once for each file in the directory specified by
      * <code>path</code>.
      */
     public static IRubyObject foreach(IRubyObject recv, RubyString path) {
         path.checkSafeString();
 
-        RubyDir dir = (RubyDir) newInstance(recv.getRuntime().getClass("Dir"),
-                                            new IRubyObject[] { path });
+        RubyClass dirClass = recv.getRuntime().getClass("Dir");
+        RubyDir dir = (RubyDir) dirClass.newInstance(new IRubyObject[] { path });
         
         dir.each();
         return recv.getRuntime().getNil();
     }
 
     /** Returns the current directory. */
     public static RubyString getwd(IRubyObject recv) {
         return recv.getRuntime().newString(recv.getRuntime().getCurrentDirectory());
     }
 
     /**
      * Creates the directory specified by <code>path</code>.  Note that the
      * <code>mode</code> parameter is provided only to support existing Ruby
      * code, and is ignored.
      */
     public static IRubyObject mkdir(IRubyObject recv, IRubyObject[] args) {
         if (args.length < 1) {
             throw recv.getRuntime().newArgumentError(args.length, 1);
         }
         if (args.length > 2) {
             throw recv.getRuntime().newArgumentError(args.length, 2);
         }
 
         args[0].checkSafeString();
         String path = args[0].toString();
 
         File newDir = getDir(recv.getRuntime(), path, false);
         if (File.separatorChar == '\\') {
             newDir = new File(newDir.getPath());
         }
         
         return newDir.mkdirs() ? RubyFixnum.zero(recv.getRuntime()) :
             RubyFixnum.one(recv.getRuntime());
     }
 
     /**
      * Returns a new directory object for <code>path</code>.  If a block is
      * provided, a new directory object is passed to the block, which closes the
      * directory object before terminating.
      */
     public static IRubyObject open(IRubyObject recv, RubyString path) {
         RubyDir directory = 
-            (RubyDir) newInstance(recv.getRuntime().getClass("Dir"),
+            (RubyDir) recv.getRuntime().getClass("Dir").newInstance(
                     new IRubyObject[] { path });
 
         ThreadContext tc = recv.getRuntime().getCurrentContext();
         if (tc.isBlockGiven()) {
             try {
                 tc.yield(directory);
             } finally {
                 directory.close();
             }
             
             return recv.getRuntime().getNil();
         }
         
         return directory;
     }
 
 // ----- Ruby Instance Methods -------------------------------------------------
 
     /**
      * Closes the directory stream.
      */
     public IRubyObject close() {
         // Make sure any read()s after close fail.
         isOpen = false;
 
         return getRuntime().getNil();
     }
 
     /**
      * Executes the block once for each entry in the directory.
      */
     public IRubyObject each() {
         String[] contents = snapshot;
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i=0; i<contents.length; i++) {
             context.yield(getRuntime().newString(contents[i]));
         }
         return this;
     }
 
     /**
      * Returns the current position in the directory.
      */
     public RubyInteger tell() {
         return getRuntime().newFixnum(pos);
     }
 
     /**
      * Moves to a position <code>d</code>.  <code>pos</code> must be a value
      * returned by <code>tell</code> or 0.
      */
     public IRubyObject seek(RubyFixnum newPos) {
         setPos(newPos);
         return this;
     }
     
     public IRubyObject setPos(RubyFixnum newPos) {
         this.pos = (int) newPos.getLongValue();
         return newPos;
     }
 
     public IRubyObject path() {
         if (!isOpen) {
             throw getRuntime().newIOError("closed directory");
         }
         
         return path;
     }
 
     /** Returns the next entry from this directory. */
     public IRubyObject read() {
 	if (!isOpen) {
 	    throw getRuntime().newIOError("Directory already closed");
 	}
 
         if (pos >= snapshot.length) {
             return getRuntime().getNil();
         }
         RubyString result = getRuntime().newString(snapshot[pos]);
         pos++;
         return result;
     }
 
     /** Moves position in this directory to the first entry. */
     public IRubyObject rewind() {
         pos = 0;
         return getRuntime().newFixnum(pos);
     }
 
 // ----- Helper Methods --------------------------------------------------------
 
     /** Returns a Java <code>File</code> object for the specified path.  If
      * <code>path</code> is not a directory, throws <code>IOError</code>.
      *
      * @param   path path for which to return the <code>File</code> object.
      * @param   mustExist is true the directory must exist.  If false it must not.
      * @throws  IOError if <code>path</code> is not a directory.
      */
     protected static JRubyFile getDir(final IRuby runtime, final String path, final boolean mustExist) {
         JRubyFile result = JRubyFile.create(runtime.getCurrentDirectory(),path);
         boolean isDirectory = result.isDirectory();
         
         if (mustExist && !isDirectory) {
             throw runtime.newErrnoENOENTError(path + " is not a directory");
         } else if (!mustExist && isDirectory) {
             throw runtime.newErrnoEEXISTError("File exists - " + path); 
         }
 
         return result;
     }
 
     /**
      * Returns the contents of the specified <code>directory</code> as an
      * <code>ArrayList</code> containing the names of the files as Java Strings.
      */
     protected static List getContents(File directory) {
         String[] contents = directory.list();
         List result = new ArrayList();
 
         // If an IO exception occurs (something odd, but possible)
         // A directory may return null.
         if (contents != null) {
             for (int i=0; i<contents.length; i++) {
                 result.add(contents[i]);
             }
         }
         return result;
     }
 
     /**
      * Returns the contents of the specified <code>directory</code> as an
      * <code>ArrayList</code> containing the names of the files as Ruby Strings.
      */
     protected static List getContents(File directory, IRuby runtime) {
         List result = new ArrayList();
         String[] contents = directory.list();
         
         for (int i = 0; i < contents.length; i++) {
             result.add(runtime.newString(contents[i]));
         }
         return result;
     }
 	
 	/*
 	 * Poor mans find home directory.  I am not sure how windows ruby behaves with '~foo', but
 	 * this mostly will work on any unix/linux/cygwin system.  When someone wants to extend this
 	 * to include the windows way, we should consider moving this to an external ruby file.
 	 */
 	public static IRubyObject getHomeDirectoryPath(IRubyObject recv, String user) {
 		// TODO: Having a return where I set user inside readlines created a JumpException.  It seems that
 		// evalScript should catch that and return?
 		return recv.getRuntime().evalScript("File.open('/etc/passwd') do |f| f.readlines.each do" +
 				"|l| f = l.split(':'); return f[5] if f[0] == '" + user + "'; end; end; nil");
 	}
 	
 	public static RubyString getHomeDirectoryPath(IRubyObject recv) {
 		RubyHash hash = (RubyHash) recv.getRuntime().getObject().getConstant("ENV_JAVA");
 		IRubyObject home = hash.aref(recv.getRuntime().newString("user.home"));
 		
 		if (home == null || home.isNil()) {
 			home = hash.aref(recv.getRuntime().newString("LOGDIR"));
 		}
 		
 		if (home == null || home.isNil()) {
 			throw recv.getRuntime().newArgumentError("user.home/LOGDIR not set");
 		}
 		
 		return (RubyString) home;
 	}
 }
diff --git a/src/org/jruby/RubyEnumerator.java b/src/org/jruby/RubyEnumerator.java
index bed9fcec7d..0a12912bb1 100644
--- a/src/org/jruby/RubyEnumerator.java
+++ b/src/org/jruby/RubyEnumerator.java
@@ -1,335 +1,344 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Michael Studman <me@michaelstudman.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.internal.runtime.methods.MultiStubMethod;
 import org.jruby.internal.runtime.methods.NoopMultiStub;
 
 import org.jruby.runtime.Arity;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.BlockCallback;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * Implementation of Ruby's Enumerator module.
  */
 public class RubyEnumerator extends RubyObject {
     /** target for each operation */
     private IRubyObject object;
     
     /** method to invoke for each operation */
     private IRubyObject method;
     
     /** args to each method */
     private IRubyObject[] methodArgs;
+    
+    private static ObjectAllocator ENUMERATOR_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyEnumerator(runtime, klass);
+        }
+    };
 
     public static void defineEnumerator(IRuby runtime) {
         RubyModule enumerableModule = runtime.getModule("Enumerable");
         RubyClass object = runtime.getObject();
-        RubyClass enumeratorClass = enumerableModule.defineClassUnder("Enumerator", object);
+        RubyClass enumeratorClass = enumerableModule.defineClassUnder("Enumerator", object, ENUMERATOR_ALLOCATOR);
         RubyEnumeratorStub0 enumeratorStub = RubyEnumeratorStub0.createStub(enumeratorClass, object, enumerableModule);
 
         enumeratorClass.includeModule(enumerableModule);
         enumeratorClass.addSingletonMethod("new", enumeratorStub.enumerator__new);
         enumeratorClass.addMethod("initialize", enumeratorStub.enumerator__initialize);
         enumeratorClass.addMethod("each", enumeratorStub.enumerator__each);
 
         object.addMethod("to_enum", enumeratorStub.object__to_enum);
         object.addMethod("enum_for", enumeratorStub.object__to_enum);
 
         enumerableModule.addMethod("enum_with_index", enumeratorStub.enumerable__enum_with_index);
         enumerableModule.addMethod("each_slice", enumeratorStub.enumerable__each_slice);
         enumerableModule.addMethod("enum_slice", enumeratorStub.enumerable__enum_slice);
         enumerableModule.addMethod("each_cons", enumeratorStub.enumerable__each_cons);
         enumerableModule.addMethod("enum_cons", enumeratorStub.enumerable__enum_cons);
     }
 
     private RubyEnumerator(IRuby runtime, RubyClass type) {
         super(runtime, type);
     }
 
     /** Primes the instance. Little validation is done at this stage */
     private IRubyObject initialize(ThreadContext tc, IRubyObject[] args) {
         checkArgumentCount(args, 1, -1);
            
         object = args[0];
         methodArgs = new IRubyObject[Math.max(0, args.length - 2)];
 
         if (args.length >= 2) {
             method = args[1];
         } else {
             method = RubySymbol.newSymbol(tc.getRuntime(), "each");
         }
 
         if (args.length >= 3) {
             System.arraycopy(args, 2, methodArgs, 0, args.length - 2);
         } else {
             methodArgs = new IRubyObject[0];
         }
 
         return this;
     }
 
     /**
      * Send current block and supplied args to method on target. According to MRI
      * Block may not be given and "each" should just ignore it and call on through to
      * underlying method.
      */
     private IRubyObject each(ThreadContext tc, IRubyObject[] args) {
         checkArgumentCount(args, 0, 0);
 
         boolean blockGiven = tc.isBlockGiven();
 
         if (blockGiven) {
             tc.setBlockAvailable();
         }
 
         try {
             return object.callMethod(tc, method.asSymbol(), methodArgs);
         } finally {
             if (blockGiven) {
                 tc.clearInBlock();
             }
         }
     }
 
     /** Block callback for slicing the results of calling the client block */
     public static class SlicedBlockCallback implements BlockCallback {
         protected RubyArray slice;
         protected final long sliceSize;
         protected final Block clientBlock;
         protected final IRuby runtime;
 
         public SlicedBlockCallback(IRuby runtime, Block clientBlock, long sliceSize) {
             this.runtime = runtime;
             this.clientBlock = clientBlock;
             this.sliceSize = sliceSize;
             this.slice = RubyArray.newArray(runtime, sliceSize);
         }
 
         public IRubyObject call(ThreadContext context, IRubyObject[] args, IRubyObject replacementSelf) {
             if (args.length > 1) {
                 slice.append(RubyArray.newArray(runtime, args));
             } else {
                 slice.append(args[0]);
             }
 
             if (slice.getLength() == sliceSize) {
                 //no need to dup slice as we create a new one momentarily
                 clientBlock.call(context, new IRubyObject[] { slice }, null);
 
                 slice = RubyArray.newArray(runtime, sliceSize);
             }
 
             return runtime.getNil();
         }
 
 
         /** Slice may be over but there weren't enough items to make the slice */
         public boolean hasLeftovers() {
             return (slice.getLength() > 0) && (slice.getLength() < sliceSize);
         }
 
         /** Pass slice dregs on to client blcok */
         public void yieldLeftovers(ThreadContext context) {
             clientBlock.call(context, new IRubyObject[] { slice }, null);
         }
     }
 
     /** Block callback for viewing consecutive results from calling the client block */
     public static class ConsecutiveBlockCallback implements BlockCallback {
         protected final RubyArray cont;
         protected final long contSize;
         protected final Block clientBlock;
         protected final IRuby runtime;
 
 
         public ConsecutiveBlockCallback(IRuby runtime, Block clientBlock, long contSize) {
             this.runtime = runtime;
             this.clientBlock = clientBlock;
             this.contSize = contSize;
             this.cont = RubyArray.newArray(runtime, contSize);
         }
 
         public IRubyObject call(ThreadContext context, IRubyObject[] args, IRubyObject replacementSelf) {
             if (cont.getLength() == contSize) {
                 cont.shift();
             }
 
             if (args.length > 1) {
                 cont.append(RubyArray.newArray(runtime, args));
             } else {
                 cont.append(args[0]);
             }
 
             if (cont.getLength() == contSize) {
                 //dup so we are in control of the array
                 clientBlock.call(context, new IRubyObject[] { cont.dup() }, null);
             }
 
             return runtime.getNil();
         }
     }
 
     /** Multi-stub for all enumerator methods */
     public static class RubyEnumeratorStub0 extends NoopMultiStub {
         private final RubyModule enumerator;
         private final IRuby runtime;
         
         public static RubyEnumeratorStub0 createStub(RubyClass enumeratorClass,
                 RubyClass objectClass, RubyModule enumerableModule) {
             return new RubyEnumeratorStub0(enumeratorClass, objectClass, enumerableModule);
         }
 
         public final MultiStubMethod enumerator__new;
         public final MultiStubMethod enumerator__initialize;
         public final MultiStubMethod enumerator__each;
         public final MultiStubMethod object__to_enum;
         public final MultiStubMethod enumerable__each_slice;
         public final MultiStubMethod enumerable__each_cons;
         public final MultiStubMethod enumerable__enum_with_index;
         public final MultiStubMethod enumerable__enum_slice;
         public final MultiStubMethod enumerable__enum_cons;
 
         private RubyEnumeratorStub0(RubyClass enumeratorClass,
                 RubyClass objectClass, RubyModule enumerableModule) {
             enumerator = enumeratorClass;
             runtime = enumeratorClass.getRuntime();
             enumerator__new = new MultiStubMethod(RubyEnumeratorStub0.this, 0, 
                     enumeratorClass, Arity.required(1), Visibility.PUBLIC);
             enumerator__initialize = new MultiStubMethod(RubyEnumeratorStub0.this, 1, 
                     enumeratorClass, Arity.required(1), Visibility.PRIVATE);          
             enumerator__each = new MultiStubMethod(RubyEnumeratorStub0.this, 2, 
                     enumeratorClass, Arity.optional(), Visibility.PUBLIC);
             object__to_enum = new MultiStubMethod(RubyEnumeratorStub0.this, 3, 
                     objectClass, Arity.optional(), Visibility.PUBLIC);
             enumerable__each_slice = new MultiStubMethod(RubyEnumeratorStub0.this, 4, 
                     enumerableModule, Arity.singleArgument(), Visibility.PUBLIC);
             enumerable__each_cons = new MultiStubMethod(RubyEnumeratorStub0.this, 5, 
                     enumerableModule, Arity.singleArgument(), Visibility.PUBLIC);
             enumerable__enum_with_index = new MultiStubMethod(RubyEnumeratorStub0.this, 6, 
                     enumerableModule, Arity.noArguments(), Visibility.PUBLIC);
             enumerable__enum_slice = new MultiStubMethod(RubyEnumeratorStub0.this, 7, 
                     enumerableModule, Arity.singleArgument(), Visibility.PUBLIC);
             enumerable__enum_cons = new MultiStubMethod(RubyEnumeratorStub0.this, 8, 
                     enumerableModule, Arity.singleArgument(), Visibility.PUBLIC);
         }
 
         /** Enumerable::Enumerator#new */
         public IRubyObject method0(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
-            RubyEnumerator result = new RubyEnumerator(runtime, (RubyClass)self);
+            RubyClass klass = (RubyClass)self;
+            
+            RubyEnumerator result = (RubyEnumerator)klass.allocate();
             
-            result.callMethod(tc, "initialize", args);
+            result.callInit(args);
             
             return result;
         }
 
         /** Enumerable::Enumerator#initialize */
         public IRubyObject method1(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             return ((RubyEnumerator) self).initialize(tc, args);
         }
 
         /** Enumerable::Enumerator#each */
         public IRubyObject method2(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             return ((RubyEnumerator) self).each(tc, args);
         }
 
         /** Object#to_enum and Object#enum_for. Just like Enumerable::Enumerator.new(self, arg_0) */
         public IRubyObject method3(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             IRubyObject[] newArgs = new IRubyObject[args.length + 1];
             newArgs[0] = self;
             System.arraycopy(args, 0, newArgs, 1, args.length);
 
             return enumerator.callMethod(tc, "new", newArgs);
         }
 
         /** Enumerable:#each_slice */
         public IRubyObject method4(final ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             self.checkArgumentCount(args, 1, 1);
 
             long sliceSize = args[0].convertToInteger().getLongValue();
 
             if (sliceSize <= 0L) {
                 throw runtime.newArgumentError("invalid slice size");
             } 
 
             SlicedBlockCallback sliceBlock = new SlicedBlockCallback(runtime, tc.getCurrentBlock(), sliceSize);
 
             RubyEnumerable.callEach(tc, self, self.getMetaClass(), sliceBlock);
 
             if (sliceBlock.hasLeftovers()) {
                 sliceBlock.yieldLeftovers(tc);
             }
 
             return runtime.getNil();
         }
 
         /** Enumerable:#each_cons */
         public IRubyObject method5(final ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             self.checkArgumentCount(args, 1, 1);
 
             long consecutiveSize = args[0].convertToInteger().getLongValue();
 
             if (consecutiveSize <= 0L) {
                 throw runtime.newArgumentError("invalid size");
             }
 
             RubyEnumerable.callEach(tc, self, self.getMetaClass(), 
                     new ConsecutiveBlockCallback(runtime, tc.getCurrentBlock(), consecutiveSize));
 
             return runtime.getNil();
         }
 
         /** Enumerable#enum_with_index */
         public IRubyObject method6(final ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             self.checkArgumentCount(args, 0, 0);
 
             return enumerator.callMethod(tc, "new", 
                     new IRubyObject[] { self, runtime.newSymbol("each_with_index") });
         }
 
         /** Enumerable#enum_slice */
         public IRubyObject method7(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             self.checkArgumentCount(args, 1, 1);
 
             return enumerator.callMethod(tc, "new", 
                     new IRubyObject[] { self, runtime.newSymbol("each_slice"), args[0] });
         }
 
         /** Enumerable#enum_cons */
         public IRubyObject method8(ThreadContext tc, IRubyObject self, IRubyObject[] args) {
             self.checkArgumentCount(args, 1, 1);
 
             return enumerator.callMethod(tc, "new", 
                     new IRubyObject[] { self, runtime.newSymbol("each_cons"), args[0] });
         }
     }
 }
diff --git a/src/org/jruby/RubyException.java b/src/org/jruby/RubyException.java
index 138dee8cf9..4e9d4a7aa9 100644
--- a/src/org/jruby/RubyException.java
+++ b/src/org/jruby/RubyException.java
@@ -1,214 +1,215 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2006 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Joey Gibson <joey@joeygibson.com>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 David Corbin <dcorbin@users.sf.net>
  * Copyright (C) 2006 Michael Studman <codehaus@michaelstudman.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.PrintStream;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyException extends RubyObject {
 
     private RubyArray backtrace;
     public IRubyObject message;
 	public static final int TRACE_HEAD = 8;
 	public static final int TRACE_TAIL = 4;
 	public static final int TRACE_MAX = TRACE_HEAD + TRACE_TAIL + 6;
 
     protected RubyException(IRuby runtime, RubyClass rubyClass) {
         this(runtime, rubyClass, null);
     }
 
     public RubyException(IRuby runtime, RubyClass rubyClass, String message) {
         super(runtime, rubyClass);
         
         this.message = message == null ? runtime.getNil() : runtime.newString(message);
     }
+    
+    private static ObjectAllocator EXCEPTION_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            RubyException instance = new RubyException(runtime, klass);
+            
+            // for future compatibility as constructors move toward not accepting metaclass?
+            instance.setMetaClass(klass);
+            
+            return instance;
+        }
+    };
 
     public static RubyClass createExceptionClass(IRuby runtime) {
-		RubyClass exceptionClass = runtime.defineClass("Exception", runtime.getObject());
+		RubyClass exceptionClass = runtime.defineClass("Exception", runtime.getObject(), EXCEPTION_ALLOCATOR);
     	
 		CallbackFactory callbackFactory = runtime.callbackFactory(RubyException.class);
-        
-		exceptionClass.defineFastSingletonMethod("new", 
-				callbackFactory.getOptSingletonMethod("newInstance"));		
-		exceptionClass.defineFastSingletonMethod("exception", 
-				callbackFactory.getOptSingletonMethod("newInstance"));		
+        CallbackFactory classCB = runtime.callbackFactory(RubyClass.class);
+        // TODO: could this just  be an alias for new?
+        exceptionClass.defineFastSingletonMethod("exception", 
+            classCB.getOptMethod("newInstance"));		
 		exceptionClass.defineMethod("initialize",
 			callbackFactory.getOptMethod("initialize"));
 		exceptionClass.defineFastMethod("exception", 
 			callbackFactory.getOptMethod("exception"));
 		exceptionClass.defineFastMethod("to_s", 
 			callbackFactory.getMethod("to_s"));
 		exceptionClass.defineFastMethod("to_str", 
 			callbackFactory.getMethod("to_s"));
 		exceptionClass.defineFastMethod("message", 
 			callbackFactory.getMethod("to_s"));
 		exceptionClass.defineFastMethod("inspect", 
 			callbackFactory.getMethod("inspect"));
 		exceptionClass.defineFastMethod("backtrace", 
 			callbackFactory.getMethod("backtrace"));		
 		exceptionClass.defineFastMethod("set_backtrace", 
 			callbackFactory.getMethod("set_backtrace", IRubyObject.class));		
 
 		return exceptionClass;
     }
 
     public static RubyException newException(IRuby runtime, RubyClass excptnClass, String msg) {
         return new RubyException(runtime, excptnClass, msg);
     }
 
-    // Exception methods
-
-    public static RubyException newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyException newException = new RubyException(recv.getRuntime(), (RubyClass) recv);
-
-        newException.callInit(args);
-
-        return newException;
-    }
-
     public IRubyObject initialize(IRubyObject[] args) {
         if (args.length > 0) {
             message = args[0];
         }
         return this;
     }
 
     public IRubyObject backtrace() {
         return backtrace == null ? getRuntime().getNil() : backtrace; 
     }
 
     public IRubyObject set_backtrace(IRubyObject obj) {
         if (obj.isNil()) {
             backtrace = null;
         } else if (!isArrayOfStrings(obj)) {
             throw getRuntime().newTypeError("backtrace must be Array of String");
         } else {
             backtrace = (RubyArray) obj;
         }
         return backtrace();
     }
     
     public RubyException exception(IRubyObject[] args) {
         switch (args.length) {
             case 0 :
                 return this;
             case 1 :
                 if(args[0] == this) {
                     return this;
                 }
                 RubyException ret = (RubyException)rbClone();
                 ret.initialize(args); // This looks wrong, but it's the way MRI does it.
                 return ret;
             default :
                 throw getRuntime().newArgumentError("Wrong argument count");
         }
     }
 
     public IRubyObject to_s() {
         if (message.isNil()) {
             return getRuntime().newString(getMetaClass().getName());
         }
         message.setTaint(isTaint());
         return (RubyString) message.callMethod(getRuntime().getCurrentContext(), "to_s");
     }
 
     /** inspects an object and return a kind of debug information
      * 
      *@return A RubyString containing the debug information.
      */
     public IRubyObject inspect() {
         RubyModule rubyClass = getMetaClass();
         RubyString exception = RubyString.stringValue(this);
 
         if (exception.getValue().length() == 0) {
             return getRuntime().newString(rubyClass.getName());
         }
         StringBuffer sb = new StringBuffer("#<");
         sb.append(rubyClass.getName()).append(": ").append(exception.getValue()).append(">");
         return getRuntime().newString(sb.toString());
     }
 
 	public void printBacktrace(PrintStream errorStream) {
 	    IRubyObject backtrace = callMethod(getRuntime().getCurrentContext(), "backtrace");
 	    if (!backtrace.isNil() && backtrace instanceof RubyArray) {
     		IRubyObject[] elements = ((RubyArray)backtrace.convertToArray()).toJavaArray();
 	
     		for (int i = 1; i < elements.length; i++) {
     		    IRubyObject stackTraceLine = elements[i];
     			if (stackTraceLine instanceof RubyString) {
     		        printStackTraceLine(errorStream, stackTraceLine);
     		    }
 	
     		    if (i == RubyException.TRACE_HEAD && elements.length > RubyException.TRACE_MAX) {
     		        int hiddenLevels = elements.length - RubyException.TRACE_HEAD - RubyException.TRACE_TAIL;
     				errorStream.print("\t ... " + hiddenLevels + " levels...\n");
     		        i = elements.length - RubyException.TRACE_TAIL;
     		    }
     		}
 		}
 	}
 
 	private void printStackTraceLine(PrintStream errorStream, IRubyObject stackTraceLine) {
 		errorStream.print("\tfrom " + stackTraceLine + '\n');
 	}
 	
     private boolean isArrayOfStrings(IRubyObject backtrace) {
         if (!(backtrace instanceof RubyArray)) return false; 
             
         IRubyObject[] elements = ((RubyArray) backtrace).toJavaArray();
         
         for (int i = 0 ; i < elements.length ; i++) {
             if (!(elements[i] instanceof RubyString)) return false;
         }
             
         return true;
     }
 
     protected IRubyObject doClone() {
         IRubyObject newObject = new RubyException(getRuntime(),getMetaClass().getRealClass());
         if (newObject.getType() != getMetaClass().getRealClass()) {
             throw getRuntime().newTypeError("wrong instance allocation");
         }
         return newObject;
     }
 }
diff --git a/src/org/jruby/RubyFileStat.java b/src/org/jruby/RubyFileStat.java
index 39e8608fb6..2ad4f8c432 100644
--- a/src/org/jruby/RubyFileStat.java
+++ b/src/org/jruby/RubyFileStat.java
@@ -1,185 +1,187 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Joey Gibson <joey@joeygibson.com>
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.JRubyFile;
 
 /**
  * note: renamed from FileStatClass.java
  * Implements File::Stat
  */
 public class RubyFileStat extends RubyObject {
     private static final int READ = 0222;
     private static final int WRITE = 0444;
 
     private RubyFixnum blksize;
     private RubyBoolean isDirectory;
     private RubyBoolean isFile;
     private RubyString ftype;
     private RubyFixnum mode;
     private RubyTime mtime;
     private RubyTime ctime;
     private RubyBoolean isReadable;
     private RubyBoolean isWritable;
     private RubyFixnum size;
     private RubyBoolean isSymlink;
 
     public static RubyClass createFileStatClass(IRuby runtime) {
-        final RubyClass fileStatClass = runtime.getClass("File").defineClassUnder("Stat",runtime.getObject());
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here. Confirm. JRUBY-415
+        final RubyClass fileStatClass = runtime.getClass("File").defineClassUnder("Stat",runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         final CallbackFactory callbackFactory = runtime.callbackFactory(RubyFileStat.class);
         //        fileStatClass.defineMethod("<=>", callbackFactory.getMethod(""));
         //        fileStateClass.includeModule(runtime.getModule("Comparable"));
         //        fileStatClass.defineMethod("atime", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("blksize", callbackFactory.getMethod("blksize"));
         //        fileStatClass.defineMethod("blockdev?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("blocks", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("chardev?", callbackFactory.getMethod(""));
         fileStatClass.defineMethod("ctime", callbackFactory.getMethod("ctime"));
         //        fileStatClass.defineMethod("dev", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("dev_major", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("dev_minor", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("directory?", callbackFactory.getMethod("directory_p"));
         //        fileStatClass.defineMethod("executable?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("executable_real?", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("file?", callbackFactory.getMethod("file_p"));
         fileStatClass.defineFastMethod("ftype", callbackFactory.getMethod("ftype"));
         //        fileStatClass.defineMethod("gid", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("grpowned?", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("ino", callbackFactory.getMethod("ino"));
         fileStatClass.defineFastMethod("mode", callbackFactory.getMethod("mode"));
         fileStatClass.defineFastMethod("mtime", callbackFactory.getMethod("mtime"));
         //        fileStatClass.defineMethod("nlink", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("owned?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("pipe?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("rdev", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("rdev_major", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("rdev_minor", callbackFactory.getMethod(""));
         fileStatClass.defineMethod("readable?", callbackFactory.getMethod("readable_p"));
         //        fileStatClass.defineMethod("readable_real?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("setgid?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("setuid?", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("size", callbackFactory.getMethod("size"));
         //        fileStatClass.defineMethod("size?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("socket?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("sticky?", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("symlink?", callbackFactory.getMethod("symlink_p"));
         //        fileStatClass.defineMethod("uid", callbackFactory.getMethod(""));
         fileStatClass.defineFastMethod("writable?", callbackFactory.getMethod("writable"));
         //        fileStatClass.defineMethod("writable_real?", callbackFactory.getMethod(""));
         //        fileStatClass.defineMethod("zero?", callbackFactory.getMethod(""));
     	
         return fileStatClass;
     }
 
     protected RubyFileStat(IRuby runtime, JRubyFile file) {
         super(runtime, runtime.getClass("File").getClass("Stat"));
 
         if(!file.exists()) {
             throw runtime.newErrnoENOENTError("No such file or directory - " + file.getPath());
         }
 
         // We cannot determine, so always return 4096 (better than blowing up)
         blksize = runtime.newFixnum(4096);
         isDirectory = runtime.newBoolean(file.isDirectory());
         isFile = runtime.newBoolean(file.isFile());
         ftype = file.isDirectory()? runtime.newString("directory") : (file.isFile() ? runtime.newString("file") : null);
 
     	// implementation to lowest common denominator...Windows has no file mode, but C ruby returns either 0100444 or 0100666
     	int baseMode = 0100000;
     	if (file.canRead()) {
             baseMode += READ;
     	}    	
     	if (file.canWrite()) {
             baseMode += WRITE;
     	}
     	mode = runtime.newFixnum(baseMode);
         mtime = runtime.newTime(file.lastModified());
         ctime = runtime.newTime(file.getParentFile().lastModified());
         isReadable = runtime.newBoolean(file.canRead());
         isWritable = runtime.newBoolean(file.canWrite());
         size = runtime.newFixnum(file.length());
         // We cannot determine this in Java, so we will always return false (better than blowing up)
         isSymlink = runtime.getFalse();
     }
     
     public RubyFixnum blksize() {
         return blksize;
     }
 
     public RubyBoolean directory_p() {
         return isDirectory;
     }
 
     public RubyBoolean file_p() {
         return isFile;
     }
     
     public RubyString ftype() {
         return ftype;
     }
     
     // Limitation: We have no pure-java way of getting inode.  webrick needs this defined to work.
     public IRubyObject ino() {
         return getRuntime().newFixnum(0);
     }
     
     public IRubyObject mode() {
         return mode;
     }
     
     public IRubyObject mtime() {
         return mtime;
     }
 
     public IRubyObject ctime() {
         return ctime;
     }
     
     public IRubyObject readable_p() {
         return isReadable;
     }
     
     public IRubyObject size() {
         return size;
     }
     
     public IRubyObject symlink_p() {
         return isSymlink;
     }
     
     public IRubyObject writable() {
     	return isWritable;
     }
 }
diff --git a/src/org/jruby/RubyFloat.java b/src/org/jruby/RubyFloat.java
index 47a84ff5e7..a56adb7639 100644
--- a/src/org/jruby/RubyFloat.java
+++ b/src/org/jruby/RubyFloat.java
@@ -1,484 +1,485 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Don Schwartz <schwardo@users.sourceforge.net>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.runtime.marshal.UnmarshalStream;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyFloat extends RubyNumeric {
     private final double value;
 
     public RubyFloat(IRuby runtime) {
         this(runtime, 0.0);
     }
 
     public RubyFloat(IRuby runtime, double value) {
         super(runtime, runtime.getClass("Float"));
         this.value = value;
     }
 
     public Class getJavaClass() {
         return Double.TYPE;
     }
 
     /** Getter for property value.
      * @return Value of property value.
      */
     public double getValue() {
         return this.value;
     }
 
     public double getDoubleValue() {
         return value;
     }
 
     public long getLongValue() {
         return (long) value;
     }
     
     public RubyFloat convertToFloat() {
     	return this;
     }
 
     public static RubyClass createFloatClass(IRuby runtime) {
-        RubyClass result = runtime.defineClass("Float", runtime.getClass("Numeric"));
+        RubyClass result = runtime.defineClass("Float", runtime.getClass("Numeric"), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyFloat.class);
         
         result.defineFastMethod("+", callbackFactory.getMethod("op_plus", IRubyObject.class));
         result.defineFastMethod("-", callbackFactory.getMethod("op_minus", IRubyObject.class));
         result.defineFastMethod("*", callbackFactory.getMethod("op_mul", IRubyObject.class));
         result.defineFastMethod("/", callbackFactory.getMethod("op_div", IRubyObject.class));
         result.defineFastMethod("%", callbackFactory.getMethod("op_mod", IRubyObject.class));
         result.defineFastMethod("**", callbackFactory.getMethod("op_pow", IRubyObject.class));
         // Although not explicitly documented in the Pickaxe, Ruby 1.8 Float
         // does have its own implementations of these relational operators.
         // These appear to be necessary if for no oher reason than proper NaN
         // handling.
         result.defineFastMethod("==", callbackFactory.getMethod("equal", IRubyObject.class));
         result.defineFastMethod("<=>", callbackFactory.getMethod("cmp",
                 IRubyObject.class));
         result.defineFastMethod(">", callbackFactory.getMethod("op_gt",
                 IRubyObject.class));
         result.defineFastMethod(">=", callbackFactory.getMethod("op_ge", IRubyObject.class));
         result.defineFastMethod("<", callbackFactory.getMethod("op_lt", IRubyObject.class));
         result.defineFastMethod("<=", callbackFactory.getMethod("op_le", IRubyObject.class));
         result.defineFastMethod("ceil", callbackFactory.getMethod("ceil"));
         result.defineFastMethod("finite?", callbackFactory.getMethod("finite_p"));
         result.defineFastMethod("floor", callbackFactory.getMethod("floor"));
         result.defineFastMethod("hash", callbackFactory.getMethod("hash"));
         result.defineFastMethod("infinite?", callbackFactory.getMethod("infinite_p"));
         result.defineFastMethod("nan?", callbackFactory.getMethod("nan_p"));
         result.defineFastMethod("round", callbackFactory.getMethod("round"));
         result.defineFastMethod("to_i", callbackFactory.getMethod("to_i"));
         result.defineAlias("to_int", "to_i");
         result.defineFastMethod("to_f", callbackFactory.getMethod("to_f"));
         result.defineFastMethod("to_s", callbackFactory.getMethod("to_s"));
         result.defineFastMethod("truncate", callbackFactory.getMethod("truncate"));
 
         result.getMetaClass().undefineMethod("new");
         result.defineFastSingletonMethod("induced_from", callbackFactory.getSingletonMethod("induced_from", IRubyObject.class));
         return result;
     }
 
     protected int compareValue(RubyNumeric other) {
         double otherVal = other.getDoubleValue();
         return getValue() > otherVal ? 1 : getValue() < otherVal ? -1 : 0;
     }
 
     public RubyFixnum hash() {
         return getRuntime().newFixnum(new Double(value).hashCode());
     }
 
     // Float methods (flo_*)
 
     public static RubyFloat newFloat(IRuby runtime, double value) {
         return new RubyFloat(runtime, value);
     }
 
     public static RubyFloat induced_from(IRubyObject recv, IRubyObject number) {
         if (number instanceof RubyFloat) {
             return (RubyFloat) number;
         } else if (number instanceof RubyInteger) {
             return (RubyFloat) number.callMethod(number.getRuntime().getCurrentContext(), "to_f");
         } else {
             throw recv.getRuntime().newTypeError("failed to convert " + number.getMetaClass() + " into Float");
         }
     }
 
     public RubyArray coerce(RubyNumeric other) {
         return getRuntime().newArray(newFloat(getRuntime(), other.getDoubleValue()), this);
     }
 
     public RubyInteger ceil() {
         double val = Math.ceil(getDoubleValue());
 
         if (val < RubyFixnum.MIN || val > RubyFixnum.MAX) {
             return RubyBignum.newBignum(getRuntime(), val);
         }
 		return getRuntime().newFixnum((long) val);
     }
 
     public RubyInteger floor() {
         double val = Math.floor(getDoubleValue());
 
         if (val < Long.MIN_VALUE || val > Long.MAX_VALUE) {
             return RubyBignum.newBignum(getRuntime(), val);
         }
 		return getRuntime().newFixnum((long) val);
     }
 
     public RubyInteger round() {
         double decimal = value % 1;
         double round = Math.round(value);
 
         // Ruby rounds differently than java for negative numbers.
         if (value < 0 && decimal == -0.5) {
             round -= 1;
         }
 
         if (value < RubyFixnum.MIN || value > RubyFixnum.MAX) {
             return RubyBignum.newBignum(getRuntime(), round);
         }
         return getRuntime().newFixnum((long) round);
     }
 
     public RubyInteger truncate() {
         if (value > 0.0) {
             return floor();
         } else if (value < 0.0) {
             return ceil();
         } else {
             return RubyFixnum.zero(getRuntime());
         }
     }
 
     public RubyNumeric multiplyWith(RubyNumeric other) {
         return other.multiplyWith(this);
     }
 
     public RubyNumeric multiplyWith(RubyFloat other) {
         return RubyFloat.newFloat(getRuntime(), getDoubleValue() * other.getDoubleValue());
     }
 
     public RubyNumeric multiplyWith(RubyInteger other) {
         return other.multiplyWith(this);
     }
 
     public RubyNumeric multiplyWith(RubyBignum other) {
         return other.multiplyWith(this);
     }
     
     public IRubyObject op_div(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             return RubyFloat.newFloat(getRuntime(), 
                 getDoubleValue() / ((RubyNumeric) other).getDoubleValue());
     	}
     	
     	return callCoerced("/", other);
     }
 
     public IRubyObject op_mod(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             // Modelled after c ruby implementation (java /,% not same as ruby)
             double x = getDoubleValue();
             double y = ((RubyNumeric) other).getDoubleValue();
             double mod = x % y;
 
             if (mod < 0 && y > 0 || mod > 0 && y < 0) {
                 mod += y;
             }
 
             return RubyFloat.newFloat(getRuntime(), mod);
     	}
     	
     	return callCoerced("%", other);
     }
 
     public IRubyObject op_minus(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             return RubyFloat.newFloat(getRuntime(), 
                 getDoubleValue() - ((RubyNumeric) other).getDoubleValue());
     	}
 
     	return callCoerced("-", other);
     }
 
     // TODO: Anders double-dispatch here does not seem like it has much benefit when we need
     // to dynamically check to see if we need to coerce first.
     public IRubyObject op_mul(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             return ((RubyNumeric) other).multiplyWith(this);
     	}
     	
     	return callCoerced("*", other);
     }
 
     public IRubyObject op_plus(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             return RubyFloat.newFloat(getRuntime(),
                 getDoubleValue() + ((RubyNumeric) other).getDoubleValue());
     	}
     	
     	return callCoerced("+", other);
     }
 
     public IRubyObject op_pow(IRubyObject other) {
     	if (other instanceof RubyNumeric) {
             return RubyFloat.newFloat(getRuntime(), 
                 Math.pow(getDoubleValue(), ((RubyNumeric) other).getDoubleValue()));
     	}
     	
     	return callCoerced("**", other);
     }
 
     public IRubyObject op_uminus() {
         return RubyFloat.newFloat(getRuntime(), -value);
     }
 
     public IRubyObject to_s() {
         return getRuntime().newString("" + getValue());
     }
 
     public RubyFloat to_f() {
         return this;
     }
 
     public RubyInteger to_i() {
     	if (value > Integer.MAX_VALUE) {
     		return RubyBignum.newBignum(getRuntime(), getValue());
     	}
         return getRuntime().newFixnum(getLongValue());
     }
 
     public IRubyObject infinite_p() {
         if (getValue() == Double.POSITIVE_INFINITY) {
             return getRuntime().newFixnum(1);
         } else if (getValue() == Double.NEGATIVE_INFINITY) {
             return getRuntime().newFixnum(-1);
         } else {
             return getRuntime().getNil();
         }
     }
 
     public RubyBoolean finite_p() {
         if (! infinite_p().isNil()) {
             return getRuntime().getFalse();
         }
         if (nan_p().isTrue()) {
             return getRuntime().getFalse();
         }
         return getRuntime().getTrue();
     }
 
     public RubyBoolean nan_p() {
         return getRuntime().newBoolean(Double.isNaN(getValue()));
     }
 
     public RubyBoolean zero_p() {
         return getRuntime().newBoolean(getValue() == 0);
     }
 
 	public void marshalTo(MarshalStream output) throws java.io.IOException {
 		output.write('f');
 		String strValue = this.toString();
 
 		if (Double.isInfinite(value)) {
 			strValue = value < 0 ? "-inf" : "inf";
 		} else if (Double.isNaN(value)) {
 			strValue = "nan";
 		}
 		output.dumpString(strValue);
 	}
 	
     public static RubyFloat unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
         return RubyFloat.newFloat(input.getRuntime(),
                                     Double.parseDouble(input.unmarshalString()));
     }
     
     /* flo_eq */
     public IRubyObject equal(IRubyObject other) {
         if (!(other instanceof RubyNumeric)) {
             return other.callMethod(getRuntime().getCurrentContext(), "==", this);
         }
 
         double otherValue = ((RubyNumeric) other).getDoubleValue();
         
         if (other instanceof RubyFloat && Double.isNaN(otherValue)) {
             return getRuntime().getFalse();
         }
         
         return (value == otherValue) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
     
 
     /* flo_cmp */
     public IRubyObject cmp(IRubyObject other) {
         if (!(other instanceof RubyNumeric)) {
             IRubyObject[] tmp = getCoerced(other, false);
             if (tmp == null) {
                 return getRuntime().getNil();
             }
             return tmp[1].callMethod(getRuntime().getCurrentContext(), "<=>", tmp[0]);
         }
 
         return doubleCompare(((RubyNumeric) other).getDoubleValue());
     }
 
     
     private void cmperr(IRubyObject other) {
         String message = "comparison of " + this.getType() + " with " + other.getType() + " failed";
 
         throw this.getRuntime().newArgumentError(message);
     }
 
     /* flo_gt */
     public IRubyObject op_gt(IRubyObject other) {
         if (Double.isNaN(value)) {
             return getRuntime().getFalse();
         }
 
         if (!(other instanceof RubyNumeric)) {
             IRubyObject[] tmp = getCoerced(other, false);
             if (tmp == null) {
                 cmperr(other);
             }
             
             return tmp[1].callMethod(getRuntime().getCurrentContext(), "<=>", tmp[0]);
         }
         
         double oth = ((RubyNumeric) other).getDoubleValue();
         
         if (other instanceof RubyFloat && Double.isNaN(oth)) { 
             return getRuntime().getFalse();
         }
         
         return value > oth ? getRuntime().getTrue() : getRuntime().getFalse();
     }
     
     /* flo_ge */
     public IRubyObject op_ge(IRubyObject other) {
         if (Double.isNaN(value)) {
             return getRuntime().getFalse();
         }
 
         if (!(other instanceof RubyNumeric)) {
             IRubyObject[] tmp = getCoerced(other, false);
             if (tmp == null) {
                 cmperr(other);
             }
             
             return tmp[1].callMethod(getRuntime().getCurrentContext(), "<=>", tmp[0]);
         }
         
         double oth = ((RubyNumeric) other).getDoubleValue();
         
         if (other instanceof RubyFloat && Double.isNaN(oth)) { 
             return getRuntime().getFalse();
         }
         
         return value >= oth ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     /* flo_lt */
     public IRubyObject op_lt(IRubyObject other) {
         if (Double.isNaN(value)) {
             return getRuntime().getFalse();
         }
 
         if (!(other instanceof RubyNumeric)) {
             IRubyObject[] tmp = getCoerced(other, false);
             if (tmp == null) {
                 cmperr(other);
             }
             
             return tmp[1].callMethod(getRuntime().getCurrentContext(), "<=>", tmp[0]);
         }
         
         double oth = ((RubyNumeric) other).getDoubleValue();
         
         if (other instanceof RubyFloat && Double.isNaN(oth)) { 
             return getRuntime().getFalse();
         }
         
         return value < oth ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     
     /* flo_le */
     public IRubyObject op_le(IRubyObject other) {
         if (Double.isNaN(value)) {
             return getRuntime().getFalse();
         }
 
         if (!(other instanceof RubyNumeric)) {
             IRubyObject[] tmp = getCoerced(other, false);
             if (tmp == null) {
                 cmperr(other);
             }
             
             return tmp[1].callMethod(getRuntime().getCurrentContext(), "<=>", tmp[0]);
         }
         
         double oth = ((RubyNumeric) other).getDoubleValue();
         
         if (other instanceof RubyFloat && Double.isNaN(oth)) { 
             return getRuntime().getFalse();
         }
         
         return value <= oth ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     
     /* dbl_cmp */
     private IRubyObject doubleCompare(double oth) {
         if (Double.isNaN(value) || Double.isNaN(oth)) {
             return getRuntime().getNil();
         }
         
         if (value == oth) {
             return getRuntime().newFixnum(0);
         }
         
         return value > oth ? getRuntime().newFixnum(1) : getRuntime().newFixnum(-1);
     }
     
 }
diff --git a/src/org/jruby/RubyIconv.java b/src/org/jruby/RubyIconv.java
index 40bbb8d68e..38cea75aee 100644
--- a/src/org/jruby/RubyIconv.java
+++ b/src/org/jruby/RubyIconv.java
@@ -1,170 +1,171 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Thomas E Enebo <enebo@acm.org>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CodingErrorAction;
 import java.nio.charset.UnmappableCharacterException;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class RubyIconv extends RubyObject {
     //private String toEncoding;
     //private String fromEncoding;
     
     public RubyIconv(IRuby runtime, RubyClass type) {
         super(runtime, type);
     }
+    
+    private static ObjectAllocator ICONV_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyIconv(runtime, klass);
+        }
+    };
 
     public static void createIconv(IRuby runtime) {
-        RubyClass iconvClass = runtime.defineClass("Iconv", runtime.getObject());
+        RubyClass iconvClass = runtime.defineClass("Iconv", runtime.getObject(), ICONV_ALLOCATOR);
 
-        iconvClass.defineClassUnder("IllegalEncoding", runtime.getClass("ArgumentError"));
-        iconvClass.defineClassUnder("IllegalSequence", runtime.getClass("ArgumentError"));
-        iconvClass.defineClassUnder("InvalidCharacter", runtime.getClass("ArgumentError"));
+        RubyClass argumentError = runtime.getClass("ArgumentError");
+        iconvClass.defineClassUnder("IllegalEncoding", argumentError, argumentError.getAllocator());
+        iconvClass.defineClassUnder("IllegalSequence", argumentError, argumentError.getAllocator());
+        iconvClass.defineClassUnder("InvalidCharacter", argumentError, argumentError.getAllocator());
         
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyIconv.class);
 
-        iconvClass.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
         iconvClass.defineFastSingletonMethod("iconv", callbackFactory.getOptSingletonMethod("iconv"));
         iconvClass.defineFastSingletonMethod("conv", callbackFactory.getOptSingletonMethod("conv"));
         
         iconvClass.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         //iconvClass.defineMethod("iconv", callbackFactory.getOptMethod("iconv"));
 
         // FIXME: JRUBY-310: Add all other iconv methods...Sopen, Iclose, Iiconv
         // FIXME: JRUBY-309: Implement IConv Exception classes (e.g. Iconv::IllegalSequence and friends)
     }
 
     // FIXME: I believe that we are suppose to keep partial character contents between calls
     // so that we can pass in arbitrary chunks of bytes.  Charset Encoder needs to be able to
     // handle this or we need to be able detect it somehow.
     /*
     public IRubyObject iconv(IRubyObject[] args) {
         RubyArray array = getRuntime().newArray();
         
         for (int i = 0; i < args.length; i++) {
             try {
                 array.append(convert(fromEncoding, toEncoding, args[i].convertToString()));
             } catch (UnsupportedEncodingException e) {
                 throw getRuntime().newErrnoEINVALError("iconv(" + toEncoding + ", " + 
                         fromEncoding + ", " + args[i] + ")");
             }
         }
 
         return array;
     }
     */
     
     public IRubyObject initialize(IRubyObject[] args) {
         checkArgumentCount(args, 2, 2);
         
         //toEncoding = args[0].convertToString().toString();
         //fromEncoding = args[1].convertToString().toString();
         
         return this;
     }
-    
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyIconv result = new RubyIconv(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
 
     public static IRubyObject iconv(IRubyObject recv, IRubyObject[] args) {
         return convertWithArgs(recv, args, "iconv");
     }
     
     public static IRubyObject conv(IRubyObject recv, IRubyObject[] args) {
         return convertWithArgs(recv, args, "conv").join(recv.getRuntime().newString(""));
     }
     
     public static RubyArray convertWithArgs(IRubyObject recv, IRubyObject[] args, String function) {
         recv.checkArgumentCount(args, 3, -1);
 
         String fromEncoding = args[1].convertToString().toString();
         String toEncoding = args[0].convertToString().toString();
         RubyArray array = recv.getRuntime().newArray();
         
         for (int i = 2; i < args.length; i++) {
             array.append(convert2(fromEncoding, toEncoding, args[i].convertToString()));
         }
 
         return array;
     }
     
     /*
     private static IRubyObject convert(String fromEncoding, String toEncoding, RubyString original) 
         throws UnsupportedEncodingException {
         // Get all bytes from ISO8859 string pretend they are not encoded in any way.
         byte[] string = original.toString().getBytes("ISO8859-1");
         // Now create a string pretending it is from fromEncoding
         string = new String(string, fromEncoding).getBytes(toEncoding);
         // Finally recode back to ISO8859-1
         return original.getRuntime().newString(new String(string, "ISO8859-1"));
     }
     */
 
     // FIXME: We are assuming that original string will be ISO8859-1 String.  If -Ku is provided
     // this will not be true, but that is ok for now.  Deal with that when someone needs it.
     private static IRubyObject convert2(String fromEncoding, String toEncoding, RubyString original) {
         try {
             // Get all bytes from ISO8859 string and pretend they are not encoded in any way.
             byte[] bytes = original.toString().getBytes("ISO8859-1");
             ByteBuffer buf = ByteBuffer.wrap(bytes);
 
             CharsetDecoder decoder = Charset.forName(fromEncoding).newDecoder();
             
             decoder.onUnmappableCharacter(CodingErrorAction.REPORT);
             CharBuffer cbuf = decoder.decode(buf);
             CharsetEncoder encoder = Charset.forName(toEncoding).newEncoder();
             
             encoder.onUnmappableCharacter(CodingErrorAction.REPORT);
             buf = encoder.encode(cbuf);
             byte[] arr = buf.array();
             bytes = new byte[buf.limit()];
             System.arraycopy(arr, 0, bytes, 0, bytes.length);
 
             return original.getRuntime().newString(new String(bytes, "ISO8859-1"));
         } catch (UnmappableCharacterException e) {
         } catch (CharacterCodingException e) {
         } catch (UnsupportedEncodingException e) {
 
         }
         return original.getRuntime().getNil();
     }
 
 
 }
diff --git a/src/org/jruby/RubyKernel.java b/src/org/jruby/RubyKernel.java
index c254efb9ce..1419c18923 100644
--- a/src/org/jruby/RubyKernel.java
+++ b/src/org/jruby/RubyKernel.java
@@ -1,1112 +1,1112 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2006 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 Kiel Hodges <jruby-devel@selfsosoft.com>
  * Copyright (C) 2006 Evan Buswell <evan@heron.sytes.net>
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * Copyright (C) 2006 Michael Studman <codehaus@michaelstudman.com>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.util.Iterator;
 import java.util.List;
 import java.util.StringTokenizer;
 import java.util.regex.Pattern;
 
 import org.jruby.ast.util.ArgsUtil;
 import org.jruby.exceptions.JumpException;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.exceptions.MainExitException;
 import org.jruby.runtime.CallType;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicMethod;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.builtin.meta.FileMetaClass;
 import org.jruby.runtime.builtin.meta.IOMetaClass;
 import org.jruby.runtime.builtin.meta.StringMetaClass;
 import org.jruby.runtime.load.IAutoloadMethod;
 import org.jruby.runtime.load.LoadService;
 import org.jruby.util.PrintfFormat;
 import org.jruby.util.UnsynchronizedStack;
 
 /**
  * Note: For CVS history, see KernelModule.java.
  *
  * @author jpetersen
  */
 public class RubyKernel {
     public static RubyModule createKernelModule(IRuby runtime) {
         RubyModule module = runtime.defineModule("Kernel");
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyKernel.class);
         CallbackFactory objectCallbackFactory = runtime.callbackFactory(RubyObject.class);
 
         module.defineFastModuleFunction("Array", callbackFactory.getSingletonMethod("new_array", IRubyObject.class));
         module.defineFastModuleFunction("Float", callbackFactory.getSingletonMethod("new_float", IRubyObject.class));
         module.defineFastModuleFunction("Integer", callbackFactory.getSingletonMethod("new_integer", IRubyObject.class));
         module.defineFastModuleFunction("String", callbackFactory.getSingletonMethod("new_string", IRubyObject.class));
         module.defineFastModuleFunction("`", callbackFactory.getSingletonMethod("backquote", IRubyObject.class));
         module.defineFastModuleFunction("abort", callbackFactory.getOptSingletonMethod("abort"));
         module.defineModuleFunction("at_exit", callbackFactory.getSingletonMethod("at_exit"));
         module.defineFastModuleFunction("autoload", callbackFactory.getSingletonMethod("autoload", IRubyObject.class, IRubyObject.class));
         module.defineFastPublicModuleFunction("autoload?", callbackFactory.getSingletonMethod("autoload_p", IRubyObject.class));
         module.defineModuleFunction("binding", callbackFactory.getSingletonMethod("binding"));
         module.defineModuleFunction("block_given?", callbackFactory.getSingletonMethod("block_given"));
         // TODO: Implement Kernel#callcc
         module.defineModuleFunction("caller", callbackFactory.getOptSingletonMethod("caller"));
         module.defineModuleFunction("catch", callbackFactory.getSingletonMethod("rbCatch", IRubyObject.class));
         module.defineFastModuleFunction("chomp", callbackFactory.getOptSingletonMethod("chomp"));
         module.defineFastModuleFunction("chomp!", callbackFactory.getOptSingletonMethod("chomp_bang"));
         module.defineFastModuleFunction("chop", callbackFactory.getSingletonMethod("chop"));
         module.defineFastModuleFunction("chop!", callbackFactory.getSingletonMethod("chop_bang"));
         module.defineModuleFunction("eval", callbackFactory.getOptSingletonMethod("eval"));
         module.defineFastModuleFunction("exit", callbackFactory.getOptSingletonMethod("exit"));
         module.defineFastModuleFunction("exit!", callbackFactory.getOptSingletonMethod("exit_bang"));
         module.defineFastModuleFunction("fail", callbackFactory.getOptSingletonMethod("raise"));
         // TODO: Implement Kernel#fork
         module.defineFastModuleFunction("format", callbackFactory.getOptSingletonMethod("sprintf"));
         module.defineFastModuleFunction("gets", callbackFactory.getOptSingletonMethod("gets"));
         module.defineFastModuleFunction("global_variables", callbackFactory.getSingletonMethod("global_variables"));
         module.defineModuleFunction("gsub", callbackFactory.getOptSingletonMethod("gsub"));
         module.defineModuleFunction("gsub!", callbackFactory.getOptSingletonMethod("gsub_bang"));
         // TODO: Add deprecation to Kernel#iterator? (maybe formal deprecation mech.)
         module.defineModuleFunction("iterator?", callbackFactory.getSingletonMethod("block_given"));
         module.defineModuleFunction("lambda", callbackFactory.getSingletonMethod("proc"));
         module.defineModuleFunction("load", callbackFactory.getOptSingletonMethod("load"));
         module.defineFastModuleFunction("local_variables", callbackFactory.getSingletonMethod("local_variables"));
         module.defineModuleFunction("loop", callbackFactory.getSingletonMethod("loop"));
         // Note: method_missing is documented as being in Object, but ruby appears to stick it in Kernel.
         module.defineModuleFunction("method_missing", callbackFactory.getOptSingletonMethod("method_missing"));
         module.defineModuleFunction("open", callbackFactory.getOptSingletonMethod("open"));
         module.defineFastModuleFunction("p", callbackFactory.getOptSingletonMethod("p"));
         module.defineFastModuleFunction("print", callbackFactory.getOptSingletonMethod("print"));
         module.defineFastModuleFunction("printf", callbackFactory.getOptSingletonMethod("printf"));
         module.defineModuleFunction("proc", callbackFactory.getSingletonMethod("proc"));
         // TODO: implement Kernel#putc
         module.defineFastModuleFunction("puts", callbackFactory.getOptSingletonMethod("puts"));
         module.defineModuleFunction("raise", callbackFactory.getOptSingletonMethod("raise"));
         module.defineFastModuleFunction("rand", callbackFactory.getOptSingletonMethod("rand"));
         module.defineFastModuleFunction("readline", callbackFactory.getOptSingletonMethod("readline"));
         module.defineFastModuleFunction("readlines", callbackFactory.getOptSingletonMethod("readlines"));
         module.defineModuleFunction("require", callbackFactory.getSingletonMethod("require", IRubyObject.class));
         module.defineModuleFunction("scan", callbackFactory.getSingletonMethod("scan", IRubyObject.class));
         module.defineFastModuleFunction("select", callbackFactory.getOptSingletonMethod("select"));
         module.defineModuleFunction("set_trace_func", callbackFactory.getSingletonMethod("set_trace_func", IRubyObject.class));
         module.defineFastModuleFunction("sleep", callbackFactory.getSingletonMethod("sleep", IRubyObject.class));
         module.defineFastModuleFunction("split", callbackFactory.getOptSingletonMethod("split"));
         module.defineFastModuleFunction("sprintf", callbackFactory.getOptSingletonMethod("sprintf"));
         module.defineFastModuleFunction("srand", callbackFactory.getOptSingletonMethod("srand"));
         module.defineModuleFunction("sub", callbackFactory.getOptSingletonMethod("sub"));
         module.defineModuleFunction("sub!", callbackFactory.getOptSingletonMethod("sub_bang"));
         // Skipping: Kernel#syscall (too system dependent)
         module.defineFastModuleFunction("system", callbackFactory.getOptSingletonMethod("system"));
         // TODO: Implement Kernel#exec differently?
         module.defineFastModuleFunction("exec", callbackFactory.getOptSingletonMethod("system"));
         // TODO: Implement Kernel#test (partial impl)
         module.defineModuleFunction("throw", callbackFactory.getOptSingletonMethod("rbThrow"));
         // TODO: Implement Kernel#trace_var
         module.defineModuleFunction("trap", callbackFactory.getOptSingletonMethod("trap"));
         // TODO: Implement Kernel#untrace_var
         module.defineFastModuleFunction("warn", callbackFactory.getSingletonMethod("warn", IRubyObject.class));
         
         // Defined p411 Pickaxe 2nd ed.
         module.defineModuleFunction("singleton_method_added", callbackFactory.getSingletonMethod("singleton_method_added", IRubyObject.class));
         
         // Object methods
         module.defineFastPublicModuleFunction("==", objectCallbackFactory.getMethod("equal", IRubyObject.class));
         module.defineAlias("===", "==");
         module.defineAlias("eql?", "==");
         module.defineFastPublicModuleFunction("to_s", objectCallbackFactory.getMethod("to_s"));
         module.defineFastPublicModuleFunction("nil?", objectCallbackFactory.getMethod("nil_p"));
         module.defineFastPublicModuleFunction("to_a", callbackFactory.getSingletonMethod("to_a"));
         module.defineFastPublicModuleFunction("hash", objectCallbackFactory.getMethod("hash"));
         module.defineFastPublicModuleFunction("id", objectCallbackFactory.getMethod("id"));
         module.defineAlias("__id__", "id");
         module.defineAlias("object_id", "id");
         module.defineFastPublicModuleFunction("is_a?", objectCallbackFactory.getMethod("kind_of", IRubyObject.class));
         module.defineAlias("kind_of?", "is_a?");
         module.defineFastPublicModuleFunction("dup", objectCallbackFactory.getMethod("dup"));
         module.defineFastPublicModuleFunction("equal?", objectCallbackFactory.getMethod("same", IRubyObject.class));
         module.defineFastPublicModuleFunction("type", objectCallbackFactory.getMethod("type_deprecated"));
         module.defineFastPublicModuleFunction("class", objectCallbackFactory.getMethod("type"));
         module.defineFastPublicModuleFunction("inspect", objectCallbackFactory.getMethod("inspect"));
         module.defineFastPublicModuleFunction("=~", objectCallbackFactory.getMethod("match", IRubyObject.class));
         module.defineFastPublicModuleFunction("clone", objectCallbackFactory.getMethod("rbClone"));
         module.defineFastPublicModuleFunction("display", objectCallbackFactory.getOptMethod("display"));
         module.defineFastPublicModuleFunction("extend", objectCallbackFactory.getOptMethod("extend"));
         module.defineFastPublicModuleFunction("freeze", objectCallbackFactory.getMethod("freeze"));
         module.defineFastPublicModuleFunction("frozen?", objectCallbackFactory.getMethod("frozen"));
         module.defineModuleFunction("initialize_copy", objectCallbackFactory.getMethod("initialize_copy", IRubyObject.class));
         module.definePublicModuleFunction("instance_eval", objectCallbackFactory.getOptMethod("instance_eval"));
         module.defineFastPublicModuleFunction("instance_of?", objectCallbackFactory.getMethod("instance_of", IRubyObject.class));
         module.defineFastPublicModuleFunction("instance_variables", objectCallbackFactory.getMethod("instance_variables"));
         module.defineFastPublicModuleFunction("instance_variable_get", objectCallbackFactory.getMethod("instance_variable_get", IRubyObject.class));
         module.defineFastPublicModuleFunction("instance_variable_set", objectCallbackFactory.getMethod("instance_variable_set", IRubyObject.class, IRubyObject.class));
         module.defineFastPublicModuleFunction("method", objectCallbackFactory.getMethod("method", IRubyObject.class));
         module.defineFastPublicModuleFunction("methods", objectCallbackFactory.getOptMethod("methods"));
         module.defineFastPublicModuleFunction("private_methods", objectCallbackFactory.getMethod("private_methods"));
         module.defineFastPublicModuleFunction("protected_methods", objectCallbackFactory.getMethod("protected_methods"));
         module.defineFastPublicModuleFunction("public_methods", objectCallbackFactory.getOptMethod("public_methods"));
         module.defineFastModuleFunction("remove_instance_variable", objectCallbackFactory.getMethod("remove_instance_variable", IRubyObject.class));
         module.defineFastPublicModuleFunction("respond_to?", objectCallbackFactory.getOptMethod("respond_to"));
         module.definePublicModuleFunction("send", objectCallbackFactory.getOptMethod("send"));
         module.defineAlias("__send__", "send");
         module.defineFastPublicModuleFunction("singleton_methods", objectCallbackFactory.getOptMethod("singleton_methods"));
         module.defineFastPublicModuleFunction("taint", objectCallbackFactory.getMethod("taint"));
         module.defineFastPublicModuleFunction("tainted?", objectCallbackFactory.getMethod("tainted"));
         module.defineFastPublicModuleFunction("untaint", objectCallbackFactory.getMethod("untaint"));
 
         return module;
     }
 
     public static IRubyObject at_exit(IRubyObject recv) {
         return recv.getRuntime().pushExitBlock(recv.getRuntime().newProc());
     }
 
     public static IRubyObject autoload_p(final IRubyObject recv, IRubyObject symbol) {
         String name = symbol.asSymbol();
         if(recv instanceof RubyModule) {
             name = ((RubyModule)recv).getName() + "::" + name;
         }
         IAutoloadMethod m = recv.getRuntime().getLoadService().autoloadFor(name);
         if(m == null) {
             return recv.getRuntime().getNil();
         } else {
             return recv.getRuntime().newString(m.file());
         }
     }
 
     public static IRubyObject autoload(final IRubyObject recv, IRubyObject symbol, final IRubyObject file) {
         final LoadService loadService = recv.getRuntime().getLoadService();
         final String baseName = symbol.asSymbol();
         String nm = baseName;
         if(recv instanceof RubyModule) {
             nm = ((RubyModule)recv).getName() + "::" + nm;
         }
         loadService.addAutoload(nm, new IAutoloadMethod() {
                 public String file() {
                     return file.toString();
                 }
             /**
              * @see org.jruby.runtime.load.IAutoloadMethod#load(IRuby, String)
              */
             public IRubyObject load(IRuby runtime, String name) {
                 loadService.require(file.toString());
                 if(recv instanceof RubyModule) {
                     return ((RubyModule)recv).getConstant(baseName);
                 }
                 return runtime.getObject().getConstant(baseName);
             }
         });
         return recv;
     }
 
     public static IRubyObject method_missing(IRubyObject recv, IRubyObject[] args) {
         IRuby runtime = recv.getRuntime();
         if (args.length == 0) {
             throw recv.getRuntime().newArgumentError("no id given");
         }
 
         String name = args[0].asSymbol();
         String description = recv.callMethod(runtime.getCurrentContext(), "inspect").toString();
         boolean noClass = description.length() > 0 && description.charAt(0) == '#';
         ThreadContext tc = runtime.getCurrentContext();
         Visibility lastVis = tc.getLastVisibility();
         CallType lastCallType = tc.getLastCallType();
         String format = lastVis.errorMessageFormat(lastCallType, name);
         String msg = new PrintfFormat(format).sprintf(new Object[] { name, description, 
             noClass ? "" : ":", noClass ? "" : recv.getType().getName()});
 
         throw lastCallType == CallType.VARIABLE ? runtime.newNameError(msg, name) : runtime.newNoMethodError(msg, name);
     }
 
     public static IRubyObject open(IRubyObject recv, IRubyObject[] args) {
         String arg = args[0].convertToString().toString();
 
         // Should this logic be pushed into RubyIO Somewhere?
         if (arg.startsWith("|")) {
             String command = arg.substring(1);
         	// exec process, create IO with process
         	try {
                 // TODO: may need to part cli parms out ourself?
                 Process p = Runtime.getRuntime().exec(command);
                 RubyIO io = new RubyIO(recv.getRuntime(), p);
                 ThreadContext tc = recv.getRuntime().getCurrentContext();
         		
         	    if (tc.isBlockGiven()) {
         	        try {
         	            tc.yield(io);
         	            
             	        return recv.getRuntime().getNil();
         	        } finally {
         	            io.close();
         	        }
         	    }
 
                 return io;
         	} catch (IOException ioe) {
         		throw recv.getRuntime().newIOErrorFromException(ioe);
         	}
         } 
 
         return ((FileMetaClass) recv.getRuntime().getClass("File")).open(args);
     }
 
     public static IRubyObject gets(IRubyObject recv, IRubyObject[] args) {
         RubyArgsFile argsFile = (RubyArgsFile) recv.getRuntime().getGlobalVariables().get("$<");
 
         IRubyObject line = argsFile.internalGets(args);
 
         recv.getRuntime().getCurrentContext().setLastline(line);
 
         return line;
     }
 
     public static IRubyObject abort(IRubyObject recv, IRubyObject[] args) {
         if(recv.checkArgumentCount(args,0,1) == 1) {
             recv.getRuntime().getGlobalVariables().get("$stderr").callMethod(recv.getRuntime().getCurrentContext(),"puts",args[0]);
         }
         throw new MainExitException(1,true);
     }
 
     public static IRubyObject new_array(IRubyObject recv, IRubyObject object) {
         IRubyObject value = object.convertToTypeWithCheck("Array", "to_ary");
         
         if (value.isNil()) {
             DynamicMethod method = object.getMetaClass().searchMethod("to_a");
             
             if (method.getImplementationClass() == recv.getRuntime().getKernel()) {
                 return recv.getRuntime().newArray(object);
             }
             
             // Strange that Ruby has custom code here and not convertToTypeWithCheck equivalent.
             value = object.callMethod(recv.getRuntime().getCurrentContext(), "to_a");
             if (value.getMetaClass() != recv.getRuntime().getClass("Array")) {
                 throw recv.getRuntime().newTypeError("`to_a' did not return Array");
                
             }
         }
         
         return value;
     }
     
     public static IRubyObject new_float(IRubyObject recv, IRubyObject object) {
         if(object instanceof RubyString) {
             return RubyNumeric.str2fnum(recv.getRuntime(),(RubyString)object,true);
         } else {
             return object.callMethod(recv.getRuntime().getCurrentContext(), "to_f");
         }
     }
     
     public static IRubyObject new_integer(IRubyObject recv, IRubyObject object) {
         ThreadContext context = recv.getRuntime().getCurrentContext();
         
         if(object instanceof RubyString) {
             String val = object.toString();
             if(val.length() > 0 && val.charAt(0) == '0') {
                 if(val.length() > 1) {
                     if(val.charAt(1) == 'x') {
                         return RubyNumeric.str2inum(recv.getRuntime(),recv.getRuntime().newString(val.substring(2)),16,true);
                     } else if(val.charAt(1) == 'b') {
                         return RubyNumeric.str2inum(recv.getRuntime(),recv.getRuntime().newString(val.substring(2)),2,true);
                     } else {
                         return RubyNumeric.str2inum(recv.getRuntime(),recv.getRuntime().newString(val.substring(1)),8,true);
                     }
                 }
             }
             return RubyNumeric.str2inum(recv.getRuntime(),(RubyString)object,10,true);
         }
         return object.callMethod(context,"to_i");
     }
     
     public static IRubyObject new_string(IRubyObject recv, IRubyObject object) {
         return object.callMethod(recv.getRuntime().getCurrentContext(), "to_s");
     }
     
     
     public static IRubyObject p(IRubyObject recv, IRubyObject[] args) {
         IRubyObject defout = recv.getRuntime().getGlobalVariables().get("$>");
         ThreadContext context = recv.getRuntime().getCurrentContext();
 
         for (int i = 0; i < args.length; i++) {
             if (args[i] != null) {
                 defout.callMethod(context, "write", args[i].callMethod(context, "inspect"));
                 defout.callMethod(context, "write", recv.getRuntime().newString("\n"));
             }
         }
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject puts(IRubyObject recv, IRubyObject[] args) {
         IRubyObject defout = recv.getRuntime().getGlobalVariables().get("$>");
         ThreadContext context = recv.getRuntime().getCurrentContext();
         
         defout.callMethod(context, "puts", args);
 
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject print(IRubyObject recv, IRubyObject[] args) {
         IRubyObject defout = recv.getRuntime().getGlobalVariables().get("$>");
         ThreadContext context = recv.getRuntime().getCurrentContext();
 
         defout.callMethod(context, "print", args);
 
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject printf(IRubyObject recv, IRubyObject[] args) {
         if (args.length != 0) {
             IRubyObject defout = recv.getRuntime().getGlobalVariables().get("$>");
 
             if (!(args[0] instanceof RubyString)) {
             	defout = args[0];
             	args = ArgsUtil.popArray(args);
             }
 
             ThreadContext context = recv.getRuntime().getCurrentContext();
 
             defout.callMethod(context, "write", RubyKernel.sprintf(recv, args));
         }
 
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject readline(IRubyObject recv, IRubyObject[] args) {
         IRubyObject line = gets(recv, args);
 
         if (line.isNil()) {
             throw recv.getRuntime().newEOFError();
         }
 
         return line;
     }
 
     public static RubyArray readlines(IRubyObject recv, IRubyObject[] args) {
         RubyArgsFile argsFile = (RubyArgsFile) recv.getRuntime().getGlobalVariables().get("$<");
 
         RubyArray lines = recv.getRuntime().newArray();
 
         IRubyObject line = argsFile.internalGets(args);
         while (!line.isNil()) {
             lines.append(line);
 
             line = argsFile.internalGets(args);
         }
 
         return lines;
     }
 
     /** Returns value of $_.
      *
      * @throws TypeError if $_ is not a String or nil.
      * @return value of $_ as String.
      */
     private static RubyString getLastlineString(IRuby runtime) {
         IRubyObject line = runtime.getCurrentContext().getLastline();
 
         if (line.isNil()) {
             throw runtime.newTypeError("$_ value need to be String (nil given).");
         } else if (!(line instanceof RubyString)) {
             throw runtime.newTypeError("$_ value need to be String (" + line.getMetaClass().getName() + " given).");
         } else {
             return (RubyString) line;
         }
     }
 
     public static IRubyObject sub_bang(IRubyObject recv, IRubyObject[] args) {
         return getLastlineString(recv.getRuntime()).sub_bang(args);
     }
 
     public static IRubyObject sub(IRubyObject recv, IRubyObject[] args) {
         RubyString str = (RubyString) getLastlineString(recv.getRuntime()).dup();
 
         if (!str.sub_bang(args).isNil()) {
             recv.getRuntime().getCurrentContext().setLastline(str);
         }
 
         return str;
     }
 
     public static IRubyObject gsub_bang(IRubyObject recv, IRubyObject[] args) {
         return getLastlineString(recv.getRuntime()).gsub_bang(args);
     }
 
     public static IRubyObject gsub(IRubyObject recv, IRubyObject[] args) {
         RubyString str = (RubyString) getLastlineString(recv.getRuntime()).dup();
 
         if (!str.gsub_bang(args).isNil()) {
             recv.getRuntime().getCurrentContext().setLastline(str);
         }
 
         return str;
     }
 
     public static IRubyObject chop_bang(IRubyObject recv) {
         return getLastlineString(recv.getRuntime()).chop_bang();
     }
 
     public static IRubyObject chop(IRubyObject recv) {
         RubyString str = getLastlineString(recv.getRuntime());
 
         if (str.getValue().length() > 0) {
             str = (RubyString) str.dup();
             str.chop_bang();
             recv.getRuntime().getCurrentContext().setLastline(str);
         }
 
         return str;
     }
 
     public static IRubyObject chomp_bang(IRubyObject recv, IRubyObject[] args) {
         return getLastlineString(recv.getRuntime()).chomp_bang(args);
     }
 
     public static IRubyObject chomp(IRubyObject recv, IRubyObject[] args) {
         RubyString str = getLastlineString(recv.getRuntime());
         RubyString dup = (RubyString) str.dup();
 
         if (dup.chomp_bang(args).isNil()) {
             return str;
         } 
 
         recv.getRuntime().getCurrentContext().setLastline(dup);
         return dup;
     }
 
     public static IRubyObject split(IRubyObject recv, IRubyObject[] args) {
         return getLastlineString(recv.getRuntime()).split(args);
     }
 
     public static IRubyObject scan(IRubyObject recv, IRubyObject pattern) {
         return getLastlineString(recv.getRuntime()).scan(pattern);
     }
 
     public static IRubyObject select(IRubyObject recv, IRubyObject[] args) {
         return IOMetaClass.select_static(recv.getRuntime(), args);
     }
 
     public static IRubyObject sleep(IRubyObject recv, IRubyObject seconds) {
     	long milliseconds = (long) (seconds.convertToFloat().getDoubleValue() * 1000);
     	long startTime = System.currentTimeMillis();
     	
     	RubyThread rubyThread = recv.getRuntime().getThreadService().getCurrentContext().getThread();
         try {
         	rubyThread.sleep(milliseconds);
         } catch (InterruptedException iExcptn) {
         }
 
         return recv.getRuntime().newFixnum(
         		Math.round((System.currentTimeMillis() - startTime) / 1000.0));
     }
 
     // FIXME: Add at_exit and finalizers to exit, then make exit_bang not call those.
     public static IRubyObject exit(IRubyObject recv, IRubyObject[] args) {
         recv.getRuntime().secure(4);
 
         int status = 1;
         if (args.length > 0) {
             RubyObject argument = (RubyObject)args[0];
             if (argument instanceof RubyFixnum) {
                 status = RubyNumeric.fix2int(argument);
             } else {
                 status = argument.isFalse() ? 1 : 0;
             }
         }
 
         throw recv.getRuntime().newSystemExit(status);
     }
 
     public static IRubyObject exit_bang(IRubyObject recv, IRubyObject[] args) {
         return exit(recv, args);
     }
 
 
     /** Returns an Array with the names of all global variables.
      *
      */
     public static RubyArray global_variables(IRubyObject recv) {
         RubyArray globalVariables = recv.getRuntime().newArray();
 
         Iterator iter = recv.getRuntime().getGlobalVariables().getNames();
         while (iter.hasNext()) {
             String globalVariableName = (String) iter.next();
 
             globalVariables.append(recv.getRuntime().newString(globalVariableName));
         }
 
         return globalVariables;
     }
 
     /** Returns an Array with the names of all local variables.
      *
      */
     public static RubyArray local_variables(IRubyObject recv) {
         final IRuby runtime = recv.getRuntime();
         RubyArray localVariables = runtime.newArray();
         
         String[] names = runtime.getCurrentContext().getCurrentScope().getAllNamesInScope();
         for (int i = 0; i < names.length; i++) {
             localVariables.append(runtime.newString(names[i]));
         }
 
         return localVariables;
     }
 
     public static RubyBinding binding(IRubyObject recv) {
         return recv.getRuntime().newBinding();
     }
 
     public static RubyBoolean block_given(IRubyObject recv) {
         return recv.getRuntime().newBoolean(recv.getRuntime().getCurrentContext().isFBlockGiven());
     }
 
     public static IRubyObject sprintf(IRubyObject recv, IRubyObject[] args) {
         if (args.length == 0) {
             throw recv.getRuntime().newArgumentError("sprintf must have at least one argument");
         }
 
         RubyString str = RubyString.stringValue(args[0]);
 
         RubyArray newArgs = recv.getRuntime().newArray(args);
         newArgs.shift();
 
         return str.format(newArgs);
     }
 
     public static IRubyObject raise(IRubyObject recv, IRubyObject[] args) {
         recv.checkArgumentCount(args, 0, 3); 
         IRuby runtime = recv.getRuntime();
 
         if (args.length == 0) {
             IRubyObject lastException = runtime.getGlobalVariables().get("$!");
             if (lastException.isNil()) {
                 throw new RaiseException(runtime, runtime.getClass("RuntimeError"), "", false);
             } 
             throw new RaiseException((RubyException) lastException);
         }
 
         IRubyObject exception;
         ThreadContext context = recv.getRuntime().getCurrentContext();
         
         if (args.length == 1) {
             if (args[0] instanceof RubyString) {
-                throw new RaiseException(RubyException.newInstance(runtime.getClass("RuntimeError"), args));
+                throw new RaiseException((RubyException)runtime.getClass("RuntimeError").newInstance(args));
             }
             
             if (!args[0].respondsTo("exception")) {
                 throw runtime.newTypeError("exception class/object expected");
             }
             exception = args[0].callMethod(context, "exception");
         } else {
             if (!args[0].respondsTo("exception")) {
                 throw runtime.newTypeError("exception class/object expected");
             }
             
             exception = args[0].callMethod(context, "exception", args[1]);
         }
         
         if (!exception.isKindOf(runtime.getClass("Exception"))) {
             throw runtime.newTypeError("exception object expected");
         }
         
         if (args.length == 3) {
             ((RubyException) exception).set_backtrace(args[2]);
         }
         
         throw new RaiseException((RubyException) exception);
     }
     
     /**
      * Require.
      * MRI allows to require ever .rb files or ruby extension dll (.so or .dll depending on system).
      * we allow requiring either .rb files or jars.
      * @param recv ruby object used to call require (any object will do and it won't be used anyway).
      * @param name the name of the file to require
      **/
     public static IRubyObject require(IRubyObject recv, IRubyObject name) {
         if (recv.getRuntime().getLoadService().require(name.toString())) {
             return recv.getRuntime().getTrue();
         }
         return recv.getRuntime().getFalse();
     }
 
     public static IRubyObject load(IRubyObject recv, IRubyObject[] args) {
         RubyString file = args[0].convertToString();
         recv.getRuntime().getLoadService().load(file.toString());
         return recv.getRuntime().getTrue();
     }
 
     public static IRubyObject eval(IRubyObject recv, IRubyObject[] args) {
         if (args == null || args.length == 0) {
             throw recv.getRuntime().newArgumentError(args.length, 1);
         }
             
         RubyString src = args[0].convertToString();
         IRubyObject scope = null;
         String file = "(eval)";
         
         if (args.length > 1) {
             if (!args[1].isNil()) {
                 scope = args[1];
             }
             
             if (args.length > 2) {
                 file = args[2].toString();
             }
         }
         // FIXME: line number is not supported yet
         //int line = args.length > 3 ? RubyNumeric.fix2int(args[3]) : 1;
 
         src.checkSafeString();
         ThreadContext context = recv.getRuntime().getCurrentContext();
         
         if (scope == null) {
             scope = recv.getRuntime().newBinding();
         }
         
         return recv.evalWithBinding(context, src, scope, file);
     }
 
     public static IRubyObject caller(IRubyObject recv, IRubyObject[] args) {
         int level = args.length > 0 ? RubyNumeric.fix2int(args[0]) : 1;
 
         if (level < 0) {
             throw recv.getRuntime().newArgumentError("negative level(" + level + ')');
         }
         
         return recv.getRuntime().getCurrentContext().createBacktrace(level, false);
     }
 
     public static IRubyObject rbCatch(IRubyObject recv, IRubyObject tag) {
         ThreadContext context = recv.getRuntime().getCurrentContext();
         try {
             context.pushCatch(tag.asSymbol());
             return context.yield(tag);
         } catch (JumpException je) {
         	if (je.getJumpType() == JumpException.JumpType.ThrowJump) {
 	            if (je.getPrimaryData().equals(tag.asSymbol())) {
 	                return (IRubyObject)je.getSecondaryData();
 	            }
         	}
        		throw je;
         } finally {
        		context.popCatch();
         }
     }
 
     public static IRubyObject rbThrow(IRubyObject recv, IRubyObject[] args) {
         IRuby runtime = recv.getRuntime();
 
         String tag = args[0].asSymbol();
         String[] catches = runtime.getCurrentContext().getActiveCatches();
 
         String message = "uncaught throw '" + tag + '\'';
 
         //Ordering of array traversal not important, just intuitive
         for (int i = catches.length - 1 ; i >= 0 ; i--) {
             if (tag.equals(catches[i])) {
                 //Catch active, throw for catch to handle
                 JumpException je = new JumpException(JumpException.JumpType.ThrowJump);
 
                 je.setPrimaryData(tag);
                 je.setSecondaryData(args.length > 1 ? args[1] : runtime.getNil());
                 throw je;
             }
         }
 
         //No catch active for this throw
         throw runtime.newNameError(message, tag);
     }
 
     public static IRubyObject trap(IRubyObject recv, IRubyObject[] args) {
         // FIXME: We can probably fake some basic signals, but obviously can't do everything. For now, stub.
         return recv.getRuntime().getNil();
     }
     
     public static IRubyObject warn(IRubyObject recv, IRubyObject message) {
     	IRubyObject out = recv.getRuntime().getObject().getConstant("STDERR");
         RubyIO io = (RubyIO) out.convertToType("IO", "to_io", true); 
 
         io.puts(new IRubyObject[] { message });
     	return recv.getRuntime().getNil();
     }
 
     public static IRubyObject set_trace_func(IRubyObject recv, IRubyObject trace_func) {
         if (trace_func.isNil()) {
             recv.getRuntime().setTraceFunction(null);
         } else if (!(trace_func instanceof RubyProc)) {
             throw recv.getRuntime().newTypeError("trace_func needs to be Proc.");
         } else {
             recv.getRuntime().setTraceFunction((RubyProc) trace_func);
         }
         return trace_func;
     }
 
     public static IRubyObject singleton_method_added(IRubyObject recv, IRubyObject symbolId) {
         return recv.getRuntime().getNil();
     }
 
     public static RubyProc proc(IRubyObject recv) {
         return RubyProc.newProc(recv.getRuntime(), true);
     }
 
     public static IRubyObject loop(IRubyObject recv) {
         ThreadContext context = recv.getRuntime().getCurrentContext();
         while (true) {
             context.yield(recv.getRuntime().getNil());
 
             Thread.yield();
         }
     }
 
     public static IRubyObject backquote(IRubyObject recv, IRubyObject aString) {
         IRuby runtime = recv.getRuntime();
         ByteArrayOutputStream output = new ByteArrayOutputStream();
         
         int resultCode = runInShell(runtime, new IRubyObject[] {aString}, output);
         
         recv.getRuntime().getGlobalVariables().set("$?", RubyProcess.RubyStatus.newProcessStatus(runtime, resultCode));
         
         return recv.getRuntime().newString(output.toString());
     }
     
     private static final Pattern PATH_SEPARATORS = Pattern.compile("[/\\\\]");
     
     /**
      * For the first full token on the command, most likely the actual executable to run, replace
      * all dir separators with that which is appropriate for the current platform. Return the new
      * with this executable string at the beginning.
      * 
      * @param command The all-forward-slashes command to be "fixed"
      * @return The "fixed" full command line
      */
     private static String repairDirSeps(String command) {
         String executable = "", remainder = "";
         command = command.trim();
         if (command.startsWith("'")) {
             String [] tokens = command.split("'", 3);
             executable = "'"+tokens[1]+"'";
             if (tokens.length > 2)
                 remainder = tokens[2];
         } else if (command.startsWith("\"")) {
             String [] tokens = command.split("\"", 3);
             executable = "\""+tokens[1]+"\"";
             if (tokens.length > 2)
                 remainder = tokens[2];
         } else {
             String [] tokens = command.split(" ", 2);
             executable = tokens[0];
             if (tokens.length > 1)
                 remainder = " "+tokens[1];
         }
         
         // Matcher.replaceAll treats backslashes in the replacement string as escaped characters
         String replacement = File.separator;
         if (File.separatorChar == '\\')
             replacement = "\\\\";
             
         return PATH_SEPARATORS.matcher(executable).replaceAll(replacement) + remainder;
                 }
 
     private static List parseCommandLine(IRubyObject[] rawArgs) {
         // first parse the first element of rawArgs since this may contain
         // the whole command line
         String command = rawArgs[0].toString();
         UnsynchronizedStack args = new UnsynchronizedStack();
         StringTokenizer st = new StringTokenizer(command, " ");
         String quoteChar = null;
 
         while (st.hasMoreTokens()) {
             String token = st.nextToken();
             if (quoteChar == null) {
                 // not currently in the middle of a quoted token
                 if (token.startsWith("'") || token.startsWith("\"")) {
                     // note quote char and remove from beginning of token
                     quoteChar = token.substring(0, 1);
                     token = token.substring(1);
                 }
                 if (quoteChar!=null && token.endsWith(quoteChar)) {
                     // quoted token self contained, remove from end of token
                     token = token.substring(0, token.length()-1);
                     quoteChar = null;
                 }
                 // add new token to list
                 args.push(token);
             } else {
                 // in the middle of quoted token
                 if (token.endsWith(quoteChar)) {
                     // end of quoted token
                     token = token.substring(0, token.length()-1);
                     quoteChar = null;
                 }
                 // update token at end of list
                 token = args.pop() + " " + token;
                 args.push(token);
             }
         }
         
         // now append the remaining raw args to the cooked arg list
         for (int i=1;i<rawArgs.length;i++) {
             args.push(rawArgs[i].toString());
         }
         
         return args;
     }
         
     private static boolean isRubyCommand(String command) {
         command = command.trim();
         String [] spaceDelimitedTokens = command.split(" ", 2);
         String [] slashDelimitedTokens = spaceDelimitedTokens[0].split("/");
         String finalToken = slashDelimitedTokens[slashDelimitedTokens.length-1];
         if (finalToken.indexOf("ruby") != -1 || finalToken.endsWith(".rb") || finalToken.indexOf("irb") != -1)
             return true;
         else
             return false;
     }
     
     private static class InProcessScript extends Thread {
     	private String[] argArray;
     	private InputStream in;
     	private PrintStream out;
     	private PrintStream err;
     	private int result;
     	private File dir;
     	
     	public InProcessScript(String[] argArray, InputStream in, PrintStream out, PrintStream err, File dir) {
     		this.argArray = argArray;
     		this.in = in;
     		this.out = out;
     		this.err = err;
     		this.dir = dir;
     	}
 
 		public int getResult() {
 			return result;
 		}
 
 		public void setResult(int result) {
 			this.result = result;
 		}
 		
         public void run() {
             String oldDir = System.getProperty("user.dir");
             try {
                 System.setProperty("user.dir", dir.getAbsolutePath());
                 result = new Main(in, out, err).run(argArray);
             } finally {
                 System.setProperty("user.dir", oldDir);
             }
         }
     }
 
     public static int runInShell(IRuby runtime, IRubyObject[] rawArgs) {
         return runInShell(runtime,rawArgs,runtime.getOutputStream());
     }
 
     public static int runInShell(IRuby runtime, IRubyObject[] rawArgs, OutputStream output) {
         OutputStream error = runtime.getErrorStream();
         InputStream input = runtime.getInputStream();
         try {
             // startup scripts set jruby.shell to /bin/sh for Unix, cmd.exe for Windows
             String shell = System.getProperty("jruby.shell");
             rawArgs[0] = runtime.newString(repairDirSeps(rawArgs[0].toString()));
             Process aProcess = null;
             InProcessScript ipScript = null;
             File pwd = new File(runtime.evalScript("Dir.pwd").toString());
             
             if (isRubyCommand(rawArgs[0].toString())) {
                 List args = parseCommandLine(rawArgs);
                 String command = (String)args.get(0);
 
                 // snip off ruby or jruby command from list of arguments
                 // leave alone if the command is the name of a script
                 int startIndex = command.endsWith(".rb") ? 0 : 1;
                 if(command.trim().endsWith("irb")) {
                     startIndex = 0;
                     args.set(0,runtime.getJRubyHome() + File.separator + "bin" + File.separator + "jirb");
                 }
                 String[] argArray = (String[])args.subList(startIndex,args.size()).toArray(new String[0]);
                 ipScript = new InProcessScript(argArray, runtime.getInputStream(), new PrintStream(output), new PrintStream(runtime.getErrorStream()), pwd);
                 
                 // execute ruby command in-process
                 ipScript.start();
                 ipScript.join();
             } else if (shell != null && rawArgs.length == 1) {
                 // execute command with sh -c or cmd.exe /c
                 // this does shell expansion of wildcards
                 String shellSwitch = shell.endsWith("sh") ? "-c" : "/c";
                 String[] argArray = new String[3];
                 argArray[0] = shell;
                 argArray[1] = shellSwitch;
                 argArray[2] = rawArgs[0].toString();
                 aProcess = Runtime.getRuntime().exec(argArray, new String[]{}, pwd);
             } else {
                 // execute command directly, no wildcard expansion
                 if (rawArgs.length > 1) {
                     String[] argArray = new String[rawArgs.length];
                     for (int i=0;i<rawArgs.length;i++) {
                         argArray[i] = rawArgs[i].toString();
                     }
                     aProcess = Runtime.getRuntime().exec(argArray, new String[]{}, pwd);
                 } else {
                     aProcess = Runtime.getRuntime().exec(rawArgs[0].toString(), new String[]{}, pwd);
                 }
             }
             
             if (aProcess != null) {
                 handleStreams(aProcess,input,output,error);
                 return aProcess.waitFor();
             } else if (ipScript != null) {
             	return ipScript.getResult();
             } else {
                 return 0;
             }
         } catch (IOException e) {
             throw runtime.newIOErrorFromException(e);
         } catch (InterruptedException e) {
             throw runtime.newThreadError("unexpected interrupt");
         }
     }
     
     private static void handleStreams(Process p, InputStream in, OutputStream out, OutputStream err) throws IOException {
         InputStream pOut = p.getInputStream();
         InputStream pErr = p.getErrorStream();
         OutputStream pIn = p.getOutputStream();
 
         boolean done = false;
         int b;
         boolean proc = false;
         while(!done) {
             if(pOut.available() > 0) {
                 byte[] input = new byte[pOut.available()];
                 if((b = pOut.read(input)) == -1) {
                     done = true;
                 } else {
                     out.write(input);
                 }
                 proc = true;
             }
             if(pErr.available() > 0) {
                 byte[] input = new byte[pErr.available()];
                 if((b = pErr.read(input)) != -1) {
                     err.write(input);
                 }
                 proc = true;
             }
             if(in.available() > 0) {
                 byte[] input = new byte[in.available()];
                 if((b = in.read(input)) != -1) {
                     pIn.write(input);
                 }
                 proc = true;
             }
             if(!proc) {
                 if((b = pOut.read()) == -1) {
                     if((b = pErr.read()) == -1) {
                         done = true;
                     } else {
                         err.write(b);
                     }
                 } else {
                     out.write(b);
                 }
             }
             proc = false;
         }
         pOut.close();
         pErr.close();
         pIn.close();
     }
 
     public static RubyInteger srand(IRubyObject recv, IRubyObject[] args) {
         IRuby runtime = recv.getRuntime();
         long oldRandomSeed = runtime.getRandomSeed();
 
         if (args.length > 0) {
             RubyInteger integerSeed = 
             	(RubyInteger) args[0].convertToType("Integer", "to_i", true);
             runtime.setRandomSeed(integerSeed.getLongValue());
         } else {
         	// Not sure how well this works, but it works much better than
         	// just currentTimeMillis by itself.
             runtime.setRandomSeed(System.currentTimeMillis() ^
 			  recv.hashCode() ^ runtime.incrementRandomSeedSequence() ^
 			  runtime.getRandom().nextInt(Math.abs((int)runtime.getRandomSeed())));
         }
         runtime.getRandom().setSeed(runtime.getRandomSeed());
         return runtime.newFixnum(oldRandomSeed);
     }
 
     public static RubyNumeric rand(IRubyObject recv, IRubyObject[] args) {
         long ceil;
         if (args.length == 0) {
             ceil = 0;
         } else if (args.length == 1) {
             RubyInteger integerCeil = (RubyInteger) args[0].convertToType("Integer", "to_i", true);
             ceil = integerCeil.getLongValue();
             ceil = Math.abs(ceil);
             if (ceil > Integer.MAX_VALUE) {
                 throw recv.getRuntime().newNotImplementedError("Random values larger than Integer.MAX_VALUE not supported");
             }
         } else {
             throw recv.getRuntime().newArgumentError("wrong # of arguments(" + args.length + " for 1)");
         }
 
         if (ceil == 0) {
             double result = recv.getRuntime().getRandom().nextDouble();
             return RubyFloat.newFloat(recv.getRuntime(), result);
         }
 		return recv.getRuntime().newFixnum(recv.getRuntime().getRandom().nextInt((int) ceil));
     }
 
     public static RubyBoolean system(IRubyObject recv, IRubyObject[] args) {
         IRuby runtime = recv.getRuntime();
         int resultCode = runInShell(runtime, args);
         recv.getRuntime().getGlobalVariables().set("$?", RubyProcess.RubyStatus.newProcessStatus(runtime, resultCode));
         return runtime.newBoolean(resultCode == 0);
     }
     
     public static RubyArray to_a(IRubyObject recv) {
         recv.getRuntime().getWarnings().warn("default 'to_a' will be obsolete");
         return recv.getRuntime().newArray(recv);
     }
 }
diff --git a/src/org/jruby/RubyMatchData.java b/src/org/jruby/RubyMatchData.java
index bb0370c4ea..3fcd01a678 100644
--- a/src/org/jruby/RubyMatchData.java
+++ b/src/org/jruby/RubyMatchData.java
@@ -1,285 +1,287 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  *
  * @author  amoore
  */
 public class RubyMatchData extends RubyObject {
     private String str;
     private int[] begin;
     private int[] end;
 
     public RubyMatchData(IRuby runtime, String str, int[] begin, int[] end) {
         super(runtime, runtime.getClass("MatchData"));
         this.str = str;
         this.begin = begin;
         this.end = end;
     }
 
     public static RubyClass createMatchDataClass(IRuby runtime) {
-        RubyClass matchDataClass = runtime.defineClass("MatchData", runtime.getObject());
+        // TODO: Is NOT_ALLOCATABLE_ALLOCATOR ok here, since you can't actually instanriate MatchData directly?
+        RubyClass matchDataClass = runtime.defineClass("MatchData", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         runtime.defineGlobalConstant("MatchingData", matchDataClass);
 
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyMatchData.class);
 
         matchDataClass.defineFastMethod("captures", callbackFactory.getMethod("captures"));
         matchDataClass.defineFastMethod("clone", callbackFactory.getMethod("rbClone"));
         matchDataClass.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
         matchDataClass.defineFastMethod("size", callbackFactory.getMethod("size"));
         matchDataClass.defineFastMethod("length", callbackFactory.getMethod("size"));
         matchDataClass.defineFastMethod("offset", callbackFactory.getMethod("offset", RubyFixnum.class));
         matchDataClass.defineFastMethod("begin", callbackFactory.getMethod("begin", RubyFixnum.class));
         matchDataClass.defineFastMethod("end", callbackFactory.getMethod("end", RubyFixnum.class));
         matchDataClass.defineFastMethod("to_a", callbackFactory.getMethod("to_a"));
         matchDataClass.defineFastMethod("[]", callbackFactory.getOptMethod("aref"));
         matchDataClass.defineFastMethod("pre_match", callbackFactory.getMethod("pre_match"));
         matchDataClass.defineFastMethod("post_match", callbackFactory.getMethod("post_match"));
         matchDataClass.defineFastMethod("to_s", callbackFactory.getMethod("to_s"));
         matchDataClass.defineFastMethod("string", callbackFactory.getMethod("string"));
 
         matchDataClass.getMetaClass().undefineMethod("new");
 
         return matchDataClass;
     }
     
     public IRubyObject captures() {
         RubyArray arr = getRuntime().newArray(begin.length);
         for (long i = 1; i < begin.length; i++) {
             arr.append(group(i));
         }
         return arr;
     }
 
     public IRubyObject subseq(long beg, long len) {
     	// Subsequence begins at a valid index and a positive length
         if (beg < 0 || beg > getSize() || len < 0) {
             getRuntime().getNil();
         }
 
         if (beg + len > getSize()) {
             len = getSize() - beg;
         }
         if (len < 0) {
             len = 0;
         }
         if (len == 0) {
             return getRuntime().newArray();
         }
         
         RubyArray arr = getRuntime().newArray(0);
         for (long i = beg; i < beg + len; i++) {
             arr.append(group(i));
         }
         return arr;
     }
 
     public long getSize() {
         return begin.length;
     }
 
     public IRubyObject group(long n) {
     	// Request an invalid group OR group is an empty match
         if (n < 0 || n >= getSize() || begin[(int) n] == -1) {
             return getRuntime().getNil();
         }
         // Fix for JRUBY-97: Temporary fix pending 
         // decision on UTF8-based string implementation.
         // String#substring reuses the storage of the original string
         // <http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4513622> 
         // Wrapping the String#substring in new String prevents this.
         // This wrapping alone was enough to fix the failing test cases in
         // JRUBY-97, but at the same time the testcase remained very slow
         // The additional minor optimizations to RubyString as part of the fix
         // dramatically improve the performance. 
         return getRuntime().newString(
         		new String(str.substring(begin[(int) n], end[(int) n])));
     }
 
     public int matchStartPosition() {
         return begin[0];
     }
 
     public int matchEndPosition() {
         return end[0];
     }
 
     private boolean outOfBounds(RubyFixnum index) {
         return outOfBounds(index.getLongValue());
     }
     
     // version to work with Java primitives for efficiency
     private boolean outOfBounds(long n) {
         return n < 0 || n >= getSize();
     }
 
     //
     // Methods of the MatchData Class:
     //
 
     /** match_aref
      *
      */
     public IRubyObject aref(IRubyObject[] args) {
         int argc = checkArgumentCount(args, 1, 2);
         if (argc == 2) {
             int beg = RubyNumeric.fix2int(args[0]);
             int len = RubyNumeric.fix2int(args[1]);
             if (beg < 0) {
                 beg += getSize();
             }
             return subseq(beg, len);
         }
         if (args[0] instanceof RubyFixnum) {
             return group(RubyNumeric.fix2int(args[0]));
         }
         if (args[0] instanceof RubyBignum) {
             throw getRuntime().newIndexError("index too big");
         }
         if (args[0] instanceof RubyRange) {
             long[] begLen = ((RubyRange) args[0]).getBeginLength(getSize(), true, false);
             if (begLen == null) {
                 return getRuntime().getNil();
             }
             return subseq(begLen[0], begLen[1]);
         }
         return group(RubyNumeric.num2long(args[0]));
     }
 
     /** match_begin
      *
      */
     public IRubyObject begin(RubyFixnum index) {
         long lIndex = index.getLongValue();
         long answer = begin(lIndex);
         
         return answer == -1 ? getRuntime().getNil() : getRuntime().newFixnum(answer);
     }
     
     public long begin(long index) {
         return outOfBounds(index) ? -1 : begin[(int) index];
     }
 
     /** match_end
      *
      */
     public IRubyObject end(RubyFixnum index) {
         int lIndex = RubyNumeric.fix2int(index);
         long answer = end(lIndex);
 
         return answer == -1 ? getRuntime().getNil() : getRuntime().newFixnum(answer);
     }
     
     public long end(long index) {
         return outOfBounds(index) ? -1 : end[(int) index]; 
     }
     
     public IRubyObject inspect() {
     	return anyToString();
     }
 
     /** match_size
      *
      */
     public RubyFixnum size() {
         return getRuntime().newFixnum(getSize());
     }
 
     /** match_offset
      *
      */
     public IRubyObject offset(RubyFixnum index) {
         if (outOfBounds(index)) {
             return getRuntime().getNil();
         }
         return getRuntime().newArray(new IRubyObject[] { begin(index), end(index)});
     }
 
     /** match_pre_match
      *
      */
     public RubyString pre_match() {
         return getRuntime().newString(str.substring(0, begin[0]));
     }
 
     /** match_post_match
      *
      */
     public RubyString post_match() {
         return getRuntime().newString(str.substring(end[0]));
     }
 
     /** match_string
      *
      */
     public RubyString string() {
         RubyString frozenString = getRuntime().newString(str);
         frozenString.freeze();
         return frozenString;
     }
 
     /** match_to_a
      *
      */
     public RubyArray to_a() {
         RubyArray arr = getRuntime().newArray(begin.length);
         for (long i = 0; i < begin.length; i++) {
             arr.append(group(i));
         }
         return arr;
     }
 
     /** match_to_s
      *
      */
     public IRubyObject to_s() {
         return getRuntime().newString(str.substring(begin[0], end[0]));
     }
 
     /** match_clone
      *
      */
     public IRubyObject rbClone() {
         int len = (int) getSize();
         int[] begin_p = new int[len];
         int[] end_p = new int[len];
         System.arraycopy(begin, 0, begin_p, 0, len);
         System.arraycopy(end, 0, end_p, 0, len);
         return new RubyMatchData(getRuntime(), str, begin_p, end_p);
     }
 }
diff --git a/src/org/jruby/RubyMethod.java b/src/org/jruby/RubyMethod.java
index 14cd05078d..cc997217d8 100644
--- a/src/org/jruby/RubyMethod.java
+++ b/src/org/jruby/RubyMethod.java
@@ -1,207 +1,209 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.exceptions.JumpException;
 import org.jruby.internal.runtime.methods.IterateCallable;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicMethod;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /** 
  * The RubyMethod class represents a RubyMethod object.
  * 
  * You can get such a method by calling the "method" method of an object.
  * 
  * Note: This was renamed from Method.java
  * 
  * @author  jpetersen
  * @since 0.2.3
  */
 public class RubyMethod extends RubyObject {
     protected RubyModule implementationModule;
     protected String methodName;
     protected RubyModule originModule;
     protected String originName;
     protected DynamicMethod method;
     protected IRubyObject receiver;
 
     protected RubyMethod(IRuby runtime, RubyClass rubyClass) {
         super(runtime, rubyClass);
     }
 
     /** Create the RubyMethod class and add it to the Ruby runtime.
      * 
      */
     public static RubyClass createMethodClass(IRuby runtime) {
-		RubyClass methodClass = runtime.defineClass("Method", runtime.getObject());
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here. Confirm. JRUBY-415
+		RubyClass methodClass = runtime.defineClass("Method", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
     	
 		CallbackFactory callbackFactory = runtime.callbackFactory(RubyMethod.class);
         
 		methodClass.defineFastMethod("arity", callbackFactory.getMethod("arity"));
 		methodClass.defineMethod("to_proc", callbackFactory.getMethod("to_proc"));
 		methodClass.defineMethod("unbind", callbackFactory.getMethod("unbind"));
 		methodClass.defineMethod("call", callbackFactory.getOptMethod("call"));
 		methodClass.defineMethod("[]", callbackFactory.getOptMethod("call"));
         methodClass.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
         methodClass.defineFastMethod("to_s", callbackFactory.getMethod("inspect"));
 
 		return methodClass;
     }
 
     public static RubyMethod newMethod(
         RubyModule implementationModule,
         String methodName,
         RubyModule originModule,
         String originName,
         DynamicMethod method,
         IRubyObject receiver) {
         IRuby runtime = implementationModule.getRuntime();
         RubyMethod newMethod = new RubyMethod(runtime, runtime.getClass("Method"));
 
         newMethod.implementationModule = implementationModule;
         newMethod.methodName = methodName;
         newMethod.originModule = originModule;
         newMethod.originName = originName;
         newMethod.method = method;
         newMethod.receiver = receiver;
 
         return newMethod;
     }
 
     /** Call the method.
      * 
      */
     public IRubyObject call(IRubyObject[] args) {
     	assert args != null;
         ThreadContext tc = getRuntime().getCurrentContext();
 
     	method.getArity().checkArity(getRuntime(), args);
         
         tc.setIfBlockAvailable();
         try {
             // FIXME: should lastClass be implementation module for a Method?
             return method.call(tc, receiver, implementationModule, methodName, args, false);
         } finally {
             tc.clearIfBlockAvailable();
         }
     }
 
     /** Returns the number of arguments a method accepted.
      * 
      * @return the number of arguments of a method.
      */
     public RubyFixnum arity() {
         return getRuntime().newFixnum(method.getArity().getValue());
     }
 
     /** Create a Proc object.
      * 
      */
     public IRubyObject to_proc() {
     	CallbackFactory f = getRuntime().callbackFactory(RubyMethod.class);
 		IRuby r = getRuntime();
         ThreadContext tc = r.getCurrentContext();
         tc.preToProc(Block.createBlock(tc, null, tc.getCurrentScope().cloneScope(), new IterateCallable(f.getBlockMethod("bmcall"), this), r.getTopSelf()));
         
 		try {
 		    while (true) {
 		        try {
 		            return f.getSingletonMethod("mproc").execute(getRuntime().getNil(), IRubyObject.NULL_ARRAY);
 		        } catch (JumpException je) {
 		        	if (je.getJumpType() == JumpException.JumpType.BreakJump) {
 		                IRubyObject breakValue = (IRubyObject)je.getPrimaryData();
 		                
 		                return breakValue == null ? r.getNil() : breakValue;
 		        	} else if (je.getJumpType() == JumpException.JumpType.ReturnJump) {
 		        		return (IRubyObject)je.getPrimaryData();
 		        	} else if (je.getJumpType() == JumpException.JumpType.RetryJump) {
 		        		// Execute iterateMethod again.
 		        	} else {
 		        		throw je;
 		        	}
 		        }
 		    }
 		} finally {
             tc.postToProc();
 		}
     }
 
     /** Create a Proc object which is called like a ruby method.
      *
      * Used by the RubyMethod#to_proc method.
      *
      */
     public static IRubyObject mproc(IRubyObject recv) {
     	IRuby runtime = recv.getRuntime();
     	ThreadContext tc = runtime.getCurrentContext();
         
         tc.preMproc();
         
         try {
             return RubyKernel.proc(recv);
         } finally {
             tc.postMproc();
         }
     }
 
     /** Delegate a block call to a bound method call.
      *
      * Used by the RubyMethod#to_proc method.
      *
      */
     public static IRubyObject bmcall(IRubyObject blockArg, IRubyObject arg1, IRubyObject self) {
         if (blockArg instanceof RubyArray) {
             return ((RubyMethod) arg1).call(((RubyArray) blockArg).toJavaArray());
         }
         return ((RubyMethod) arg1).call(new IRubyObject[] { blockArg });
     }
 
     public RubyUnboundMethod unbind() {
         RubyUnboundMethod unboundMethod =
         	RubyUnboundMethod.newUnboundMethod(implementationModule, methodName, originModule, originName, method);
         unboundMethod.receiver = this;
         unboundMethod.infectBy(this);
         
         return unboundMethod;
     }
     
     public IRubyObject inspect() {
         String cname = getMetaClass().getRealClass().getName();
         RubyString str = getRuntime().newString("#<" + cname + ": " + originModule.getName() + "#" + methodName + ">");
         str.setTaint(isTaint());
         return str;
     }
 }
 
diff --git a/src/org/jruby/RubyModule.java b/src/org/jruby/RubyModule.java
index 9c178c82d6..c10024500c 100644
--- a/src/org/jruby/RubyModule.java
+++ b/src/org/jruby/RubyModule.java
@@ -1,1621 +1,1626 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jruby.internal.runtime.methods.AliasMethod;
 import org.jruby.internal.runtime.methods.FullFunctionCallbackMethod;
 import org.jruby.internal.runtime.methods.SimpleCallbackMethod;
 import org.jruby.internal.runtime.methods.MethodMethod;
 import org.jruby.internal.runtime.methods.ProcMethod;
 import org.jruby.internal.runtime.methods.UndefinedMethod;
 import org.jruby.internal.runtime.methods.WrapperMethod;
 import org.jruby.runtime.Arity;
 import org.jruby.runtime.DynamicMethod;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.callback.Callback;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.runtime.marshal.UnmarshalStream;
 import org.jruby.util.IdUtil;
 import org.jruby.util.collections.SinglyLinkedList;
 import org.jruby.exceptions.RaiseException;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyModule extends RubyObject {
     private static final String CVAR_TAINT_ERROR =
         "Insecure: can't modify class variable";
     private static final String CVAR_FREEZE_ERROR = "class/module";
 
     // superClass may be null.
     private RubyClass superClass;
 
     // Containing class...The parent of Object is null. Object should always be last in chain.
     //public RubyModule parentModule;
 
     // CRef...to eventually replace parentModule
     public SinglyLinkedList cref;
 
     // ClassId is the name of the class/module sans where it is located.
     // If it is null, then it an anonymous class.
     private String classId;
 
     // All methods and all CACHED methods for the module.  The cached methods will be removed
     // when appropriate (e.g. when method is removed by source class or a new method is added
     // with same name by one of its subclasses).
     private Map methods = new HashMap();
 
     protected RubyModule(IRuby runtime, RubyClass metaClass, RubyClass superClass, SinglyLinkedList parentCRef, String name) {
         super(runtime, metaClass);
 
         this.superClass = superClass;
         //this.parentModule = parentModule;
 
         setBaseName(name);
 
         // If no parent is passed in, it is safe to assume Object.
         if (parentCRef == null) {
             if (runtime.getObject() != null) {
                 parentCRef = runtime.getObject().getCRef();
             }
         }
         this.cref = new SinglyLinkedList(this, parentCRef);
     }
 
     /** Getter for property superClass.
      * @return Value of property superClass.
      */
     public RubyClass getSuperClass() {
         return superClass;
     }
 
     private void setSuperClass(RubyClass superClass) {
         this.superClass = superClass;
     }
 
     public RubyModule getParent() {
         if (cref.getNext() == null) {
             return null;
         }
 
         return (RubyModule)cref.getNext().getValue();
     }
 
     public void setParent(RubyModule p) {
         cref.setNext(p.getCRef());
     }
 
     public Map getMethods() {
         return methods;
     }
 
     public boolean isModule() {
         return true;
     }
 
     public boolean isClass() {
         return false;
     }
 
     public boolean isSingleton() {
         return false;
     }
 
     /**
      * Is this module one that in an included one (e.g. an IncludedModuleWrapper). 
      */
     public boolean isIncluded() {
         return false;
     }
 
     public RubyModule getNonIncludedClass() {
         return this;
     }
 
     public String getBaseName() {
         return classId;
     }
 
     public void setBaseName(String name) {
         classId = name;
     }
 
     /**
      * Generate a fully-qualified class name or a #-style name for anonymous and singleton classes.
      * 
      * Ruby C equivalent = "classname"
      * 
      * @return The generated class name
      */
     public String getName() {
         if (getBaseName() == null) {
             if (isClass()) {
                 return "#<" + "Class" + ":01x" + Integer.toHexString(System.identityHashCode(this)) + ">";
             } else {
                 return "#<" + "Module" + ":01x" + Integer.toHexString(System.identityHashCode(this)) + ">";
             }
         }
 
         StringBuffer result = new StringBuffer(getBaseName());
         RubyClass objectClass = getRuntime().getObject();
 
         for (RubyModule p = this.getParent(); p != null && p != objectClass; p = p.getParent()) {
             result.insert(0, "::").insert(0, p.getBaseName());
         }
 
         return result.toString();
     }
 
     /**
      * Create a wrapper to use for including the specified module into this one.
      * 
      * Ruby C equivalent = "include_class_new"
      * 
      * @return The module wrapper
      */
     public IncludedModuleWrapper newIncludeClass(RubyClass superClazz) {
         IncludedModuleWrapper includedModule = new IncludedModuleWrapper(getRuntime(), superClazz, this);
 
         // include its parent (and in turn that module's parents)
         if (getSuperClass() != null) {
             includedModule.includeModule(getSuperClass());
         }
 
         return includedModule;
     }
 
     /**
      * Search this and parent modules for the named variable.
      * 
      * @param name The variable to search for
      * @return The module in which that variable is found, or null if not found
      */
     private RubyModule getModuleWithInstanceVar(String name) {
         for (RubyModule p = this; p != null; p = p.getSuperClass()) {
             if (p.getInstanceVariable(name) != null) {
                 return p;
             }
         }
         return null;
     }
 
     /**
      * Set the named class variable to the given value, provided taint and freeze allow setting it.
      * 
      * Ruby C equivalent = "rb_cvar_set"
      * 
      * @param name The variable name to set
      * @param value The value to set it to
      */
     public IRubyObject setClassVar(String name, IRubyObject value) {
         RubyModule module = getModuleWithInstanceVar(name);
 
         if (module == null) {
             module = this;
         }
 
         return module.setInstanceVariable(name, value, CVAR_TAINT_ERROR, CVAR_FREEZE_ERROR);
     }
 
     /**
      * Retrieve the specified class variable, searching through this module, included modules, and supermodules.
      * 
      * Ruby C equivalent = "rb_cvar_get"
      * 
      * @param name The name of the variable to retrieve
      * @return The variable's value, or throws NameError if not found
      */
     public IRubyObject getClassVar(String name) {
         RubyModule module = getModuleWithInstanceVar(name);
 
         if (module != null) {
             IRubyObject variable = module.getInstanceVariable(name);
 
             return variable == null ? getRuntime().getNil() : variable;
         }
 
         throw getRuntime().newNameError("uninitialized class variable " + name + " in " + getName(), name);
     }
 
     /**
      * Is class var defined?
      * 
      * Ruby C equivalent = "rb_cvar_defined"
      * 
      * @param name The class var to determine "is defined?"
      * @return true if true, false if false
      */
     public boolean isClassVarDefined(String name) {
         return getModuleWithInstanceVar(name) != null;
     }
 
     /**
      * Set the named constant on this module. Also, if the value provided is another Module and
      * that module has not yet been named, assign it the specified name.
      * 
      * @param name The name to assign
      * @param value The value to assign to it; if an unnamed Module, also set its basename to name
      * @return The result of setting the variable.
      * @see RubyObject#setInstanceVariable(String, IRubyObject, String, String)
      */
     public IRubyObject setConstant(String name, IRubyObject value) {
         IRubyObject result = setInstanceVariable(name, value, "Insecure: can't set constant",
                 "class/module");
 
         // if adding a module under a constant name, set that module's basename to the constant name
         if (value instanceof RubyModule) {
             RubyModule module = (RubyModule)value;
             if (module.getBaseName() == null) {
                 module.setBaseName(name);
                 module.setParent(this);
             }
             /*
             module.setParent(this);
             */
         }
         return result;
     }
 
     /**
      * Finds a class that is within the current module (or class).
      * 
      * @param name to be found in this module (or class)
      * @return the class or null if no such class
      */
     public RubyClass getClass(String name) {
         IRubyObject module = getConstantAt(name);
 
         return  (module instanceof RubyClass) ? (RubyClass) module : null;
     }
 
     /**
      * Base implementation of Module#const_missing, throws NameError for specific missing constant.
      * 
      * @param name The constant name which was found to be missing
      * @return Nothing! Absolutely nothing! (though subclasses might choose to return something)
      */
     public IRubyObject const_missing(IRubyObject name) {
         /* Uninitialized constant */
         if (this != getRuntime().getObject()) {
             throw getRuntime().newNameError("uninitialized constant " + getName() + "::" + name.asSymbol(), "" + getName() + "::" + name.asSymbol());
         }
 
         throw getRuntime().newNameError("uninitialized constant " + name.asSymbol(), name.asSymbol());
     }
 
     /**
      * Include a new module in this module or class.
      * 
      * @param arg The module to include
      */
     public synchronized void includeModule(IRubyObject arg) {
         assert arg != null;
 
         testFrozen("module");
         if (!isTaint()) {
             getRuntime().secure(4);
         }
 
         if (!(arg instanceof RubyModule)) {
             throw getRuntime().newTypeError("Wrong argument type " + arg.getMetaClass().getName() +
                     " (expected Module).");
         }
 
         RubyModule module = (RubyModule) arg;
 
         // Make sure the module we include does not already exist
         if (isSame(module)) {
             return;
         }
 
         infectBy(module);
 
         RubyModule p, c;
         boolean changed = false;
         boolean skip = false;
 
         c = this;
         while (module != null) {
             if (getNonIncludedClass() == module.getNonIncludedClass()) {
                 throw getRuntime().newArgumentError("cyclic include detected");
             }
 
             boolean superclassSeen = false;
             for (p = getSuperClass(); p != null; p = p.getSuperClass()) {
                 if (p instanceof IncludedModuleWrapper) {
                     if (p.getNonIncludedClass() == module.getNonIncludedClass()) {
                         if (!superclassSeen) {
                             c = p;
                         }
                         skip = true;
                         break;
                     }
                 } else {
                     superclassSeen = true;
                 }
             }
             if (!skip) {
                 // In the current logic, if we get here we know that module is not an 
                 // IncludedModuleWrapper, so there's no need to fish out the delegate. But just 
                 // in case the logic should change later, let's do it anyway:
                 c.setSuperClass(new IncludedModuleWrapper(getRuntime(), c.getSuperClass(),
                         module.getNonIncludedClass()));
                 c = c.getSuperClass();
                 changed = true;
             }
 
             module = module.getSuperClass();
             skip = false;
         }
 
         if (changed) {
             // MRI seems to blow away its cache completely after an include; is
             // what we're doing here really safe?
             List methodNames = new ArrayList(((RubyModule) arg).getMethods().keySet());
             for (Iterator iter = methodNames.iterator();
                  iter.hasNext();) {
                 String methodName = (String) iter.next();
                 getRuntime().getCacheMap().remove(methodName, searchMethod(methodName));
             }
         }
 
     }
 
     public void defineMethod(String name, Callback method) {
         Visibility visibility = name.equals("initialize") ?
                 Visibility.PRIVATE : Visibility.PUBLIC;
         addMethod(name, new FullFunctionCallbackMethod(this, method, visibility));
     }
 
     public void defineFastMethod(String name, Callback method) {
         Visibility visibility = name.equals("initialize") ?
                 Visibility.PRIVATE : Visibility.PUBLIC;
         addMethod(name, new SimpleCallbackMethod(this, method, visibility));
     }
 
     public void definePrivateMethod(String name, Callback method) {
         addMethod(name, new FullFunctionCallbackMethod(this, method, Visibility.PRIVATE));
     }
 
     public void defineFastPrivateMethod(String name, Callback method) {
         addMethod(name, new SimpleCallbackMethod(this, method, Visibility.PRIVATE));
     }
 
     public void undefineMethod(String name) {
         addMethod(name, UndefinedMethod.getInstance());
     }
 
     /** rb_undef
      *
      */
     public void undef(String name) {
         IRuby runtime = getRuntime();
         if (this == runtime.getObject()) {
             runtime.secure(4);
         }
         if (runtime.getSafeLevel() >= 4 && !isTaint()) {
             throw new SecurityException("Insecure: can't undef");
         }
         testFrozen("module");
         if (name.equals("__id__") || name.equals("__send__")) {
             getRuntime().getWarnings().warn("undefining `"+ name +"' may cause serious problem");
         }
         DynamicMethod method = searchMethod(name);
         if (method.isUndefined()) {
             String s0 = " class";
             RubyModule c = this;
 
             if (c.isSingleton()) {
                 IRubyObject obj = getInstanceVariable("__attached__");
 
                 if (obj != null && obj instanceof RubyModule) {
                     c = (RubyModule) obj;
                     s0 = "";
                 }
             } else if (c.isModule()) {
                 s0 = " module";
             }
 
             throw getRuntime().newNameError("Undefined method " + name + " for" + s0 + " '" + c.getName() + "'", name);
         }
         addMethod(name, UndefinedMethod.getInstance());
     }
 
     private void addCachedMethod(String name, DynamicMethod method) {
         // Included modules modify the original 'included' modules class.  Since multiple
         // classes can include the same module, we cannot cache in the original included module.
         if (!isIncluded()) {
             getMethods().put(name, method);
             getRuntime().getCacheMap().add(method, this);
         }
     }
 
     // TODO: Consider a better way of synchronizing 
     public void addMethod(String name, DynamicMethod method) {
         if (this == getRuntime().getObject()) {
             getRuntime().secure(4);
         }
 
         if (getRuntime().getSafeLevel() >= 4 && !isTaint()) {
             throw getRuntime().newSecurityError("Insecure: can't define method");
         }
         testFrozen("class/module");
 
         // We can safely reference methods here instead of doing getMethods() since if we
         // are adding we are not using a IncludedModuleWrapper.
         synchronized(getMethods()) {
             // If we add a method which already is cached in this class, then we should update the 
             // cachemap so it stays up to date.
             DynamicMethod existingMethod = (DynamicMethod) getMethods().remove(name);
             if (existingMethod != null) {
                 getRuntime().getCacheMap().remove(name, existingMethod);
             }
 
             getMethods().put(name, method);
         }
     }
 
     public void removeCachedMethod(String name) {
         getMethods().remove(name);
     }
 
     public void removeMethod(String name) {
         if (this == getRuntime().getObject()) {
             getRuntime().secure(4);
         }
         if (getRuntime().getSafeLevel() >= 4 && !isTaint()) {
             throw getRuntime().newSecurityError("Insecure: can't remove method");
         }
         testFrozen("class/module");
 
         // We can safely reference methods here instead of doing getMethods() since if we
         // are adding we are not using a IncludedModuleWrapper.
         synchronized(getMethods()) {
             DynamicMethod method = (DynamicMethod) getMethods().remove(name);
             if (method == null) {
                 throw getRuntime().newNameError("method '" + name + "' not defined in " + getName(), name);
             }
 
             getRuntime().getCacheMap().remove(name, method);
         }
     }
 
     /**
      * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
      * 
      * @param name The name of the method to search for
      * @return The method, or UndefinedMethod if not found
      */
     public DynamicMethod searchMethod(String name) {
         for (RubyModule searchModule = this; searchModule != null; searchModule = searchModule.getSuperClass()) {
             // included modules use delegates methods for we need to synchronize on result of getMethods
             synchronized(searchModule.getMethods()) {
                 // See if current class has method or if it has been cached here already
                 DynamicMethod method = (DynamicMethod) searchModule.getMethods().get(name);
                 if (method != null) {
                     if (searchModule != this) {
                         addCachedMethod(name, method);
                     }
 
                     return method;
                 }
             }
         }
 
         return UndefinedMethod.getInstance();
     }
 
     /**
      * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
      * 
      * @param name The name of the method to search for
      * @return The method, or UndefinedMethod if not found
      */
     public DynamicMethod retrieveMethod(String name) {
         return (DynamicMethod)getMethods().get(name);
     }
 
     /**
      * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
      * 
      * @param name The name of the method to search for
      * @return The method, or UndefinedMethod if not found
      */
     public RubyModule findImplementer(RubyModule clazz) {
         for (RubyModule searchModule = this; searchModule != null; searchModule = searchModule.getSuperClass()) {
             if (searchModule.isSame(clazz)) {
                 return searchModule;
             }
         }
 
         return null;
     }
 
     public void addModuleFunction(String name, DynamicMethod method) {
         addMethod(name, method);
         addSingletonMethod(name, method);
     }
 
     /** rb_define_module_function
      *
      */
     public void defineModuleFunction(String name, Callback method) {
         definePrivateMethod(name, method);
         defineSingletonMethod(name, method);
     }
 
     /** rb_define_module_function
      *
      */
     public void definePublicModuleFunction(String name, Callback method) {
         defineMethod(name, method);
         defineSingletonMethod(name, method);
     }
 
     /** rb_define_module_function
      *
      */
     public void defineFastModuleFunction(String name, Callback method) {
         defineFastPrivateMethod(name, method);
         defineFastSingletonMethod(name, method);
     }
 
     /** rb_define_module_function
      *
      */
     public void defineFastPublicModuleFunction(String name, Callback method) {
         defineFastMethod(name, method);
         defineFastSingletonMethod(name, method);
     }
 
     private IRubyObject getConstantInner(String name, boolean exclude) {
         IRubyObject objectClass = getRuntime().getObject();
         boolean retryForModule = false;
         RubyModule p = this;
 
         retry: while (true) {
             while (p != null) {
                 IRubyObject constant = p.getConstantAt(name);
 
                 if (constant == null) {
                     if (getRuntime().getLoadService().autoload(p.getName() + "::" + name) != null) {
                         continue;
                     }
                 }
                 if (constant != null) {
                     if (exclude && p == objectClass && this != objectClass) {
                         getRuntime().getWarnings().warn("toplevel constant " + name +
                                 " referenced by " + getName() + "::" + name);
                     }
 
                     return constant;
                 }
                 p = p.getSuperClass();
             }
 
             if (!exclude && !retryForModule && getClass().equals(RubyModule.class)) {
                 retryForModule = true;
                 p = getRuntime().getObject();
                 continue retry;
             }
 
             break;
         }
 
         return callMethod(getRuntime().getCurrentContext(), "const_missing", RubySymbol.newSymbol(getRuntime(), name));
     }
 
     /**
      * Retrieve the named constant, invoking 'const_missing' should that be appropriate.
      * 
      * @param name The constant to retrieve
      * @return The value for the constant, or null if not found
      */
     public IRubyObject getConstant(String name) {
         return getConstantInner(name, false);
     }
 
     public IRubyObject getConstantFrom(String name) {
         return getConstantInner(name, true);
     }
 
     public IRubyObject getConstantAt(String name) {
         return getInstanceVariable(name);
     }
 
     /** rb_alias
      *
      */
     public synchronized void defineAlias(String name, String oldName) {
         testFrozen("module");
         if (oldName.equals(name)) {
             return;
         }
         if (this == getRuntime().getObject()) {
             getRuntime().secure(4);
         }
         DynamicMethod method = searchMethod(oldName);
         if (method.isUndefined()) {
             if (isModule()) {
                 method = getRuntime().getObject().searchMethod(oldName);
             }
 
             if (method.isUndefined()) {
                 throw getRuntime().newNameError("undefined method `" + oldName + "' for " +
                         (isModule() ? "module" : "class") + " `" + getName() + "'", oldName);
             }
         }
         getRuntime().getCacheMap().remove(name, searchMethod(name));
         getMethods().put(name, new AliasMethod(method, oldName));
     }
 
     public RubyClass defineOrGetClassUnder(String name, RubyClass superClazz) {
+        // This method is intended only for defining new classes in Ruby code,
+        // so it uses the allocator of the specified superclass or default to
+        // the Object allocator. It should NOT be used to define classes that require a native allocator.
         IRubyObject type = getConstantAt(name);
+        ObjectAllocator allocator = superClazz == null ? getRuntime().getObject().getAllocator() : superClazz.getAllocator();
 
         if (type == null) {
             return (RubyClass) setConstant(name,
-                    getRuntime().defineClassUnder(name, superClazz, cref));
+                    getRuntime().defineClassUnder(name, superClazz, allocator, cref));
         } 
 
         if (!(type instanceof RubyClass)) {
             throw getRuntime().newTypeError(name + " is not a class.");
         } else if (superClazz != null && ((RubyClass) type).getSuperClass().getRealClass() != superClazz) {
             throw getRuntime().newTypeError("superclass mismatch for class " + name);
         }
 
         return (RubyClass) type;
     }
 
     /** rb_define_class_under
      *
      */
-    public RubyClass defineClassUnder(String name, RubyClass superClazz) {
+    public RubyClass defineClassUnder(String name, RubyClass superClazz, ObjectAllocator allocator) {
         IRubyObject type = getConstantAt(name);
 
         if (type == null) {
             return (RubyClass) setConstant(name,
-                    getRuntime().defineClassUnder(name, superClazz, cref));
+                    getRuntime().defineClassUnder(name, superClazz, allocator, cref));
         }
 
         if (!(type instanceof RubyClass)) {
             throw getRuntime().newTypeError(name + " is not a class.");
         } else if (((RubyClass) type).getSuperClass().getRealClass() != superClazz) {
             throw getRuntime().newNameError(name + " is already defined.", name);
         }
 
         return (RubyClass) type;
     }
 
     public RubyModule defineModuleUnder(String name) {
         IRubyObject type = getConstantAt(name);
 
         if (type == null) {
             return (RubyModule) setConstant(name,
                     getRuntime().defineModuleUnder(name, cref));
         }
 
         if (!(type instanceof RubyModule)) {
             throw getRuntime().newTypeError(name + " is not a module.");
         }
 
         return (RubyModule) type;
     }
 
     /** rb_define_const
      *
      */
     public void defineConstant(String name, IRubyObject value) {
         assert value != null;
 
         if (this == getRuntime().getClass("Class")) {
             getRuntime().secure(4);
         }
 
         if (!IdUtil.isConstant(name)) {
             throw getRuntime().newNameError("bad constant name " + name, name);
         }
 
         setConstant(name, value);
     }
 
     /** rb_mod_remove_cvar
      *
      */
     public IRubyObject removeCvar(IRubyObject name) { // Wrong Parameter ?
         if (!IdUtil.isClassVariable(name.asSymbol())) {
             throw getRuntime().newNameError("wrong class variable name " + name.asSymbol(), name.asSymbol());
         }
 
         if (!isTaint() && getRuntime().getSafeLevel() >= 4) {
             throw getRuntime().newSecurityError("Insecure: can't remove class variable");
         }
         testFrozen("class/module");
 
         IRubyObject value = removeInstanceVariable(name.asSymbol());
 
         if (value != null) {
             return value;
         }
 
         if (isClassVarDefined(name.asSymbol())) {
             throw cannotRemoveError(name.asSymbol());
         }
 
         throw getRuntime().newNameError("class variable " + name.asSymbol() + " not defined for " + getName(), name.asSymbol());
     }
 
     private void addAccessor(String name, boolean readable, boolean writeable) {
         ThreadContext tc = getRuntime().getCurrentContext();
 
         // Check the visibility of the previous frame, which will be the frame in which the class is being eval'ed
         Visibility attributeScope = tc.getCurrentVisibility();
         if (attributeScope.isPrivate()) {
             //FIXME warning
         } else if (attributeScope.isModuleFunction()) {
             attributeScope = Visibility.PRIVATE;
             // FIXME warning
         }
         final String variableName = "@" + name;
         final IRuby runtime = getRuntime();
         ThreadContext context = getRuntime().getCurrentContext();
         if (readable) {
             defineMethod(name, new Callback() {
                 public IRubyObject execute(IRubyObject self, IRubyObject[] args) {
                     checkArgumentCount(args, 0, 0);
 
                     IRubyObject variable = self.getInstanceVariable(variableName);
 
                     return variable == null ? runtime.getNil() : variable;
                 }
 
                 public Arity getArity() {
                     return Arity.noArguments();
                 }
             });
             callMethod(context, "method_added", RubySymbol.newSymbol(getRuntime(), name));
         }
         if (writeable) {
             name = name + "=";
             defineMethod(name, new Callback() {
                 public IRubyObject execute(IRubyObject self, IRubyObject[] args) {
                     IRubyObject[] fargs = runtime.getCurrentContext().getFrameArgs();
 
                     if (fargs.length != 1) {
                         throw runtime.newArgumentError("wrong # of arguments(" + fargs.length + "for 1)");
                     }
 
                     return self.setInstanceVariable(variableName, fargs[0]);
                 }
 
                 public Arity getArity() {
                     return Arity.singleArgument();
                 }
             });
             callMethod(context, "method_added", RubySymbol.newSymbol(getRuntime(), name));
         }
     }
 
     /** set_method_visibility
      *
      */
     public void setMethodVisibility(IRubyObject[] methods, Visibility visibility) {
         if (getRuntime().getSafeLevel() >= 4 && !isTaint()) {
             throw getRuntime().newSecurityError("Insecure: can't change method visibility");
         }
 
         for (int i = 0; i < methods.length; i++) {
             exportMethod(methods[i].asSymbol(), visibility);
         }
     }
 
     /** rb_export_method
      *
      */
     public void exportMethod(String name, Visibility visibility) {
         if (this == getRuntime().getObject()) {
             getRuntime().secure(4);
         }
 
         DynamicMethod method = searchMethod(name);
 
         if (method.isUndefined()) {
             throw getRuntime().newNameError("undefined method '" + name + "' for " +
                                 (isModule() ? "module" : "class") + " '" + getName() + "'", name);
         }
 
         if (method.getVisibility() != visibility) {
             if (this == method.getImplementationClass()) {
                 method.setVisibility(visibility);
             } else {
                 final ThreadContext context = getRuntime().getCurrentContext();
                 addMethod(name, new FullFunctionCallbackMethod(this, new Callback() {
                     public IRubyObject execute(IRubyObject self, IRubyObject[] args) {
                         return context.callSuper(context.getFrameArgs());
                     }
 
                     public Arity getArity() {
                         return Arity.optional();
                     }
                 }, visibility));
             }
         }
     }
 
     /**
      * MRI: rb_method_boundp
      *
      */
     public boolean isMethodBound(String name, boolean checkVisibility) {
         DynamicMethod method = searchMethod(name);
         if (!method.isUndefined()) {
             return !(checkVisibility && method.getVisibility().isPrivate());
         }
         return false;
     }
 
     public IRubyObject newMethod(IRubyObject receiver, String name, boolean bound) {
         DynamicMethod method = searchMethod(name);
         if (method.isUndefined()) {
             throw getRuntime().newNameError("undefined method `" + name +
                 "' for class `" + this.getName() + "'", name);
         }
 
         RubyMethod newMethod = null;
         if (bound) {
             newMethod = RubyMethod.newMethod(method.getImplementationClass(), name, this, name, method, receiver);
         } else {
             newMethod = RubyUnboundMethod.newUnboundMethod(method.getImplementationClass(), name, this, name, method);
         }
         newMethod.infectBy(this);
 
         return newMethod;
     }
 
     // What is argument 1 for in this method?
     public IRubyObject define_method(IRubyObject[] args) {
         if (args.length < 1 || args.length > 2) {
             throw getRuntime().newArgumentError("wrong # of arguments(" + args.length + " for 1)");
         }
 
         IRubyObject body;
         String name = args[0].asSymbol();
         DynamicMethod newMethod = null;
         ThreadContext tc = getRuntime().getCurrentContext();
         Visibility visibility = tc.getCurrentVisibility();
 
         if (visibility.isModuleFunction()) {
             visibility = Visibility.PRIVATE;
         }
 
 
         if (args.length == 1 || args[1].isKindOf(getRuntime().getClass("Proc"))) {
             // double-testing args.length here, but it avoids duplicating the proc-setup code in two places
             RubyProc proc = (args.length == 1) ? getRuntime().newProc() : (RubyProc)args[1];
             body = proc;
 
             proc.getBlock().isLambda = true;
             proc.getBlock().getFrame().setLastClass(this);
             proc.getBlock().getFrame().setLastFunc(name);
 
             newMethod = new ProcMethod(this, proc, visibility);
         } else if (args[1].isKindOf(getRuntime().getClass("Method"))) {
             RubyMethod method = (RubyMethod)args[1];
             body = method;
 
             newMethod = new MethodMethod(this, method.unbind(), visibility);
         } else {
             throw getRuntime().newTypeError("wrong argument type " + args[0].getType().getName() + " (expected Proc/Method)");
         }
 
         addMethod(name, newMethod);
 
         RubySymbol symbol = RubySymbol.newSymbol(getRuntime(), name);
         ThreadContext context = getRuntime().getCurrentContext();
 
         if (tc.getPreviousVisibility().isModuleFunction()) {
             getSingletonClass().addMethod(name, new WrapperMethod(getSingletonClass(), newMethod, Visibility.PUBLIC));
             callMethod(context, "singleton_method_added", symbol);
         }
 
         callMethod(context, "method_added", symbol);
 
         return body;
     }
 
     public IRubyObject executeUnder(Callback method, IRubyObject[] args) {
         ThreadContext context = getRuntime().getCurrentContext();
 
         context.preExecuteUnder(this);
 
         try {
             return method.execute(this, args);
         } finally {
             context.postExecuteUnder();
         }
     }
 
     // Methods of the Module Class (rb_mod_*):
 
     public static RubyModule newModule(IRuby runtime, String name) {
         return newModule(runtime, name, null);
     }
 
     public static RubyModule newModule(IRuby runtime, String name, SinglyLinkedList parentCRef) {
         // Modules do not directly define Object as their superClass even though in theory they
         // should.  The C version of Ruby may also do this (special checks in rb_alias for Module
         // makes me think this).
         // TODO cnutter: Shouldn't new modules have Module as their superclass?
         RubyModule newModule = new RubyModule(runtime, runtime.getClass("Module"), null, parentCRef, name);
         ThreadContext tc = runtime.getCurrentContext();
         if (tc.isBlockGiven()) {
             tc.getFrameBlock().yield(tc, null, newModule, newModule, false);
         }
         return newModule;
     }
 
     public RubyString name() {
         return getRuntime().newString(getBaseName() == null ? "" : getName());
     }
 
     /** rb_mod_class_variables
      *
      */
     public RubyArray class_variables() {
         RubyArray ary = getRuntime().newArray();
 
         for (RubyModule p = this; p != null; p = p.getSuperClass()) {
             for (Iterator iter = p.instanceVariableNames(); iter.hasNext();) {
                 String id = (String) iter.next();
                 if (IdUtil.isClassVariable(id)) {
                     RubyString kval = getRuntime().newString(id);
                     if (!ary.includes(kval)) {
                         ary.append(kval);
                     }
                 }
             }
         }
         return ary;
     }
 
     /** rb_mod_clone
      *
      */
     public IRubyObject rbClone() {
         return cloneMethods((RubyModule) super.rbClone());
     }
 
     protected IRubyObject cloneMethods(RubyModule clone) {
         RubyModule realType = this.getNonIncludedClass();
         for (Iterator iter = getMethods().entrySet().iterator(); iter.hasNext(); ) {
             Map.Entry entry = (Map.Entry) iter.next();
             DynamicMethod method = (DynamicMethod) entry.getValue();
 
             // Do not clone cached methods
             if (method.getImplementationClass() == realType) {
                 // A cloned method now belongs to a new class.  Set it.
                 // TODO: Make DynamicMethod immutable
                 DynamicMethod clonedMethod = (DynamicMethod)method.dup();
                 clonedMethod.setImplementationClass(clone);
                 clone.getMethods().put(entry.getKey(), clonedMethod);
             }
         }
 
         return clone;
     }
 
     protected IRubyObject doClone() {
         return RubyModule.newModule(getRuntime(), getBaseName(), cref.getNext());
     }
 
     /** rb_mod_dup
      *
      */
     public IRubyObject dup() {
         RubyModule dup = (RubyModule) rbClone();
         dup.setMetaClass(getMetaClass());
         dup.setFrozen(false);
         // +++ jpetersen
         // dup.setSingleton(isSingleton());
         // --- jpetersen
 
         return dup;
     }
 
     /** rb_mod_included_modules
      *
      */
     public RubyArray included_modules() {
         RubyArray ary = getRuntime().newArray();
 
         for (RubyModule p = getSuperClass(); p != null; p = p.getSuperClass()) {
             if (p.isIncluded()) {
                 ary.append(p.getNonIncludedClass());
             }
         }
 
         return ary;
     }
 
     /** rb_mod_ancestors
      *
      */
     public RubyArray ancestors() {
         RubyArray ary = getRuntime().newArray(getAncestorList());
 
         return ary;
     }
 
     public List getAncestorList() {
         ArrayList list = new ArrayList();
 
         for (RubyModule p = this; p != null; p = p.getSuperClass()) {
             if(!p.isSingleton()) {
                 list.add(p.getNonIncludedClass());
             }
         }
 
         return list;
     }
 
     public boolean hasModuleInHierarchy(RubyModule type) {
         // XXX: This check previously used callMethod("==") to check for equality between classes
         // when scanning the hierarchy. However the == check may be safe; we should only ever have
         // one instance bound to a given type/constant. If it's found to be unsafe, examine ways
         // to avoid the == call.
         for (RubyModule p = this; p != null; p = p.getSuperClass()) {
             if (p.getNonIncludedClass() == type) return true;
         }
 
         return false;
     }
 
     /** rb_mod_to_s
      *
      */
     public IRubyObject to_s() {
         return getRuntime().newString(getName());
     }
 
     /** rb_mod_eqq
      *
      */
     public RubyBoolean op_eqq(IRubyObject obj) {
         return getRuntime().newBoolean(obj.isKindOf(this));
     }
 
     /** rb_mod_le
     *
     */
    public IRubyObject op_le(IRubyObject obj) {
        if (!(obj instanceof RubyModule)) {
            throw getRuntime().newTypeError("compared with non class/module");
        }
 
        if (isKindOfModule((RubyModule)obj)) {
            return getRuntime().getTrue();
        } else if (((RubyModule)obj).isKindOfModule(this)) {
            return getRuntime().getFalse();
        }
 
        return getRuntime().getNil();
    }
 
    /** rb_mod_lt
     *
     */
    public IRubyObject op_lt(IRubyObject obj) {
     return obj == this ? getRuntime().getFalse() : op_le(obj);
    }
 
    /** rb_mod_ge
     *
     */
    public IRubyObject op_ge(IRubyObject obj) {
        if (!(obj instanceof RubyModule)) {
            throw getRuntime().newTypeError("compared with non class/module");
        }
 
        return ((RubyModule) obj).op_le(this);
    }
 
    /** rb_mod_gt
     *
     */
    public IRubyObject op_gt(IRubyObject obj) {
        return this == obj ? getRuntime().getFalse() : op_ge(obj);
    }
 
    /** rb_mod_cmp
     *
     */
    public IRubyObject op_cmp(IRubyObject obj) {
        if (this == obj) {
            return getRuntime().newFixnum(0);
        }
 
        if (!(obj instanceof RubyModule)) {
            throw getRuntime().newTypeError(
                "<=> requires Class or Module (" + getMetaClass().getName() + " given)");
        }
 
        RubyModule module = (RubyModule)obj;
 
        if (module.isKindOfModule(this)) {
            return getRuntime().newFixnum(1);
        } else if (this.isKindOfModule(module)) {
            return getRuntime().newFixnum(-1);
        }
 
        return getRuntime().getNil();
    }
 
    public boolean isKindOfModule(RubyModule type) {
        for (RubyModule p = this; p != null; p = p.getSuperClass()) {
            if (p.isSame(type)) {
                return true;
            }
        }
 
        return false;
    }
 
    public boolean isSame(RubyModule module) {
        return this == module;
    }
 
     /** rb_mod_initialize
      *
      */
     public IRubyObject initialize(IRubyObject[] args) {
         return getRuntime().getNil();
     }
 
     /** rb_mod_attr
      *
      */
     public IRubyObject attr(IRubyObject[] args) {
         checkArgumentCount(args, 1, 2);
         boolean writeable = args.length > 1 ? args[1].isTrue() : false;
 
         addAccessor(args[0].asSymbol(), true, writeable);
 
         return getRuntime().getNil();
     }
 
     /** rb_mod_attr_reader
      *
      */
     public IRubyObject attr_reader(IRubyObject[] args) {
         for (int i = 0; i < args.length; i++) {
             addAccessor(args[i].asSymbol(), true, false);
         }
 
         return getRuntime().getNil();
     }
 
     /** rb_mod_attr_writer
      *
      */
     public IRubyObject attr_writer(IRubyObject[] args) {
         for (int i = 0; i < args.length; i++) {
             addAccessor(args[i].asSymbol(), false, true);
         }
 
         return getRuntime().getNil();
     }
 
     /** rb_mod_attr_accessor
      *
      */
     public IRubyObject attr_accessor(IRubyObject[] args) {
         for (int i = 0; i < args.length; i++) {
             addAccessor(args[i].asSymbol(), true, true);
         }
 
         return getRuntime().getNil();
     }
 
     /** rb_mod_const_get
      *
      */
     public IRubyObject const_get(IRubyObject symbol) {
         String name = symbol.asSymbol();
 
         if (!IdUtil.isConstant(name)) {
             throw wrongConstantNameError(name);
         }
 
         return getConstant(name);
     }
 
     /** rb_mod_const_set
      *
      */
     public IRubyObject const_set(IRubyObject symbol, IRubyObject value) {
         String name = symbol.asSymbol();
 
         if (!IdUtil.isConstant(name)) {
             throw wrongConstantNameError(name);
         }
 
         return setConstant(name, value);
     }
 
     /** rb_mod_const_defined
      *
      */
     public RubyBoolean const_defined(IRubyObject symbol) {
         String name = symbol.asSymbol();
 
         if (!IdUtil.isConstant(name)) {
             throw wrongConstantNameError(name);
         }
 
         return getRuntime().newBoolean(getConstantAt(name) != null);
     }
 
     private RaiseException wrongConstantNameError(String name) {
         return getRuntime().newNameError("wrong constant name " + name, name);
     }
 
     private RubyArray instance_methods(IRubyObject[] args, final Visibility visibility) {
         boolean includeSuper = args.length > 0 ? args[0].isTrue() : true;
         RubyArray ary = getRuntime().newArray();
         HashMap undefinedMethods = new HashMap();
 
         for (RubyModule type = this; type != null; type = type.getSuperClass()) {
             RubyModule realType = type.getNonIncludedClass();
             for (Iterator iter = type.getMethods().entrySet().iterator(); iter.hasNext();) {
                 Map.Entry entry = (Map.Entry) iter.next();
                 DynamicMethod method = (DynamicMethod) entry.getValue();
                 String methodName = (String) entry.getKey();
 
                 if (method.isUndefined()) {
                     undefinedMethods.put(methodName, Boolean.TRUE);
                     continue;
                 }
                 if (method.getImplementationClass() == realType &&
                     method.getVisibility().is(visibility) && undefinedMethods.get(methodName) == null) {
                     RubyString name = getRuntime().newString(methodName);
 
                     if (!ary.includes(name)) {
                         ary.append(name);
                     }
                 }
             }
 
             if (!includeSuper) {
                 break;
             }
         }
 
         return ary;
     }
 
     public RubyArray instance_methods(IRubyObject[] args) {
         return instance_methods(args, Visibility.PUBLIC_PROTECTED);
     }
 
     public RubyArray public_instance_methods(IRubyObject[] args) {
         return instance_methods(args, Visibility.PUBLIC);
     }
 
     public IRubyObject instance_method(IRubyObject symbol) {
         return newMethod(null, symbol.asSymbol(), false);
     }
 
     /** rb_class_protected_instance_methods
      *
      */
     public RubyArray protected_instance_methods(IRubyObject[] args) {
         return instance_methods(args, Visibility.PROTECTED);
     }
 
     /** rb_class_private_instance_methods
      *
      */
     public RubyArray private_instance_methods(IRubyObject[] args) {
         return instance_methods(args, Visibility.PRIVATE);
     }
 
     /** rb_mod_constants
      *
      */
     public RubyArray constants() {
         ArrayList constantNames = new ArrayList();
         RubyModule objectClass = getRuntime().getObject();
 
         if (getRuntime().getClass("Module") == this) {
             for (Iterator vars = objectClass.instanceVariableNames();
                  vars.hasNext();) {
                 String name = (String) vars.next();
                 if (IdUtil.isConstant(name)) {
                     constantNames.add(getRuntime().newString(name));
                 }
             }
 
             return getRuntime().newArray(constantNames);
         } else if (getRuntime().getObject() == this) {
             for (Iterator vars = instanceVariableNames(); vars.hasNext();) {
                 String name = (String) vars.next();
                 if (IdUtil.isConstant(name)) {
                     constantNames.add(getRuntime().newString(name));
                 }
             }
 
             return getRuntime().newArray(constantNames);
         }
 
         for (RubyModule p = this; p != null; p = p.getSuperClass()) {
             if (objectClass == p) {
                 continue;
             }
 
             for (Iterator vars = p.instanceVariableNames(); vars.hasNext();) {
                 String name = (String) vars.next();
                 if (IdUtil.isConstant(name)) {
                     constantNames.add(getRuntime().newString(name));
                 }
             }
         }
 
         return getRuntime().newArray(constantNames);
     }
 
     /** rb_mod_remove_cvar
      *
      */
     public IRubyObject remove_class_variable(IRubyObject name) {
         String id = name.asSymbol();
 
         if (!IdUtil.isClassVariable(id)) {
             throw getRuntime().newNameError("wrong class variable name " + id, id);
         }
         if (!isTaint() && getRuntime().getSafeLevel() >= 4) {
             throw getRuntime().newSecurityError("Insecure: can't remove class variable");
         }
         testFrozen("class/module");
 
         IRubyObject variable = removeInstanceVariable(id);
         if (variable != null) {
             return variable;
         }
 
         if (isClassVarDefined(id)) {
             throw cannotRemoveError(id);
         }
         throw getRuntime().newNameError("class variable " + id + " not defined for " + getName(), id);
     }
 
     private RaiseException cannotRemoveError(String id) {
         return getRuntime().newNameError("cannot remove " + id + " for " + getName(), id);
     }
 
     public IRubyObject remove_const(IRubyObject name) {
         String id = name.asSymbol();
 
         if (!IdUtil.isConstant(id)) {
             throw wrongConstantNameError(id);
         }
         if (!isTaint() && getRuntime().getSafeLevel() >= 4) {
             throw getRuntime().newSecurityError("Insecure: can't remove class variable");
         }
         testFrozen("class/module");
 
         IRubyObject variable = getInstanceVariable(id);
         if (variable != null) {
             return removeInstanceVariable(id);
         }
 
         if (isClassVarDefined(id)) {
             throw cannotRemoveError(id);
         }
         throw getRuntime().newNameError("constant " + id + " not defined for " + getName(), id);
     }
 
     /** rb_mod_append_features
      *
      */
     // TODO: Proper argument check (conversion?)
     public RubyModule append_features(IRubyObject module) {
         ((RubyModule) module).includeModule(this);
         return this;
     }
 
     /** rb_mod_extend_object
      *
      */
     public IRubyObject extend_object(IRubyObject obj) {
         obj.extendObject(this);
         return obj;
     }
 
     /** rb_mod_include
      *
      */
     public RubyModule include(IRubyObject[] modules) {
         ThreadContext context = getRuntime().getCurrentContext();
 
         for (int i = modules.length - 1; i >= 0; i--) {
             modules[i].callMethod(context, "append_features", this);
             modules[i].callMethod(context, "included", this);
         }
 
         return this;
     }
 
     public IRubyObject included(IRubyObject other) {
         return getRuntime().getNil();
     }
 
     public IRubyObject extended(IRubyObject other) {
         return getRuntime().getNil();
     }
 
     private void setVisibility(IRubyObject[] args, Visibility visibility) {
         if (getRuntime().getSafeLevel() >= 4 && !isTaint()) {
             throw getRuntime().newSecurityError("Insecure: can't change method visibility");
         }
 
         if (args.length == 0) {
             getRuntime().getCurrentContext().setCurrentVisibility(visibility);
         } else {
             setMethodVisibility(args, visibility);
         }
     }
 
     /** rb_mod_public
      *
      */
     public RubyModule rbPublic(IRubyObject[] args) {
         setVisibility(args, Visibility.PUBLIC);
         return this;
     }
 
     /** rb_mod_protected
      *
      */
     public RubyModule rbProtected(IRubyObject[] args) {
         setVisibility(args, Visibility.PROTECTED);
         return this;
     }
 
     /** rb_mod_private
      *
      */
     public RubyModule rbPrivate(IRubyObject[] args) {
         setVisibility(args, Visibility.PRIVATE);
         return this;
     }
 
     /** rb_mod_modfunc
      *
      */
     public RubyModule module_function(IRubyObject[] args) {
         if (getRuntime().getSafeLevel() >= 4 && !isTaint()) {
             throw getRuntime().newSecurityError("Insecure: can't change method visibility");
         }
 
         ThreadContext context = getRuntime().getCurrentContext();
 
         if (args.length == 0) {
             context.setCurrentVisibility(Visibility.MODULE_FUNCTION);
         } else {
             setMethodVisibility(args, Visibility.PRIVATE);
 
             for (int i = 0; i < args.length; i++) {
                 String name = args[i].asSymbol();
                 DynamicMethod method = searchMethod(name);
                 assert !method.isUndefined() : "undefined method '" + name + "'";
                 getSingletonClass().addMethod(name, new WrapperMethod(getSingletonClass(), method, Visibility.PUBLIC));
                 callMethod(context, "singleton_method_added", RubySymbol.newSymbol(getRuntime(), name));
             }
         }
         return this;
     }
 
     public IRubyObject method_added(IRubyObject nothing) {
         return getRuntime().getNil();
     }
 
     public RubyBoolean method_defined(IRubyObject symbol) {
         return isMethodBound(symbol.asSymbol(), true) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public RubyModule public_class_method(IRubyObject[] args) {
         getMetaClass().setMethodVisibility(args, Visibility.PUBLIC);
         return this;
     }
 
     public RubyModule private_class_method(IRubyObject[] args) {
         getMetaClass().setMethodVisibility(args, Visibility.PRIVATE);
         return this;
     }
 
     public RubyModule alias_method(IRubyObject newId, IRubyObject oldId) {
         defineAlias(newId.asSymbol(), oldId.asSymbol());
         return this;
     }
 
     public RubyModule undef_method(IRubyObject name) {
         undef(name.asSymbol());
         return this;
     }
 
     public IRubyObject module_eval(IRubyObject[] args) {
         return specificEval(this, args);
     }
 
     public RubyModule remove_method(IRubyObject[] args) {
         for(int i=0;i<args.length;i++) {
             removeMethod(args[i].asSymbol());
         }
         return this;
     }
 
     public void marshalTo(MarshalStream output) throws java.io.IOException {
         output.write('m');
         output.dumpString(name().toString());
     }
 
     public static RubyModule unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
         String name = input.unmarshalString();
         IRuby runtime = input.getRuntime();
         RubyModule result = runtime.getClassFromPath(name);
         if (result == null) {
             throw runtime.newNameError("uninitialized constant " + name, name);
         }
         input.registerLinkTarget(result);
         return result;
     }
 
     public SinglyLinkedList getCRef() {
         return cref;
     }
 
     public IRubyObject inspect() {
         return callMethod(getRuntime().getCurrentContext(), "to_s");
     }
 }
diff --git a/src/org/jruby/RubyMutex.java b/src/org/jruby/RubyMutex.java
index f940a79268..2f016888c3 100644
--- a/src/org/jruby/RubyMutex.java
+++ b/src/org/jruby/RubyMutex.java
@@ -1,64 +1,72 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
+import org.jruby.runtime.builtin.IRubyObject;
 
 public class RubyMutex extends RubyObject {
     private boolean isLocked = false;
 
-    public RubyMutex(IRuby runtime) {
-        super(runtime, runtime.getClass("Mutex"));
+    public RubyMutex(IRuby runtime, RubyClass klass) {
+        super(runtime, klass);
     }
+    
+    private static ObjectAllocator MUTEX_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyMutex(runtime, klass);
+        }
+    };
 
     public static void createMutexClass(IRuby runtime) {
         RubyClass mutexClass =
-                runtime.defineClass("Mutex", runtime.getObject());
+                runtime.defineClass("Mutex", runtime.getObject(), MUTEX_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyMutex.class);
         mutexClass.defineFastMethod("lock", callbackFactory.getMethod("lock"));
         mutexClass.defineFastMethod("unlock", callbackFactory.getMethod("unlock"));
         mutexClass.defineFastMethod("locked?", callbackFactory.getMethod("locked_p"));
     }
 
     public RubyMutex lock() {
         isLocked = true;
         return this;
     }
 
     public RubyMutex unlock() {
         isLocked = false;
         return this;
     }
 
     public RubyBoolean locked_p() {
         return getRuntime().newBoolean(isLocked);
     }
 }
diff --git a/src/org/jruby/RubyNameError.java b/src/org/jruby/RubyNameError.java
index 3ee6921c79..35594d5214 100644
--- a/src/org/jruby/RubyNameError.java
+++ b/src/org/jruby/RubyNameError.java
@@ -1,86 +1,96 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 
 package org.jruby;
 
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.CallbackFactory;
 
 /**
  * @author Anders Bengtsson
  */
 public class RubyNameError extends RubyException {
     private IRubyObject name;
+    
+    private static ObjectAllocator NAMEERROR_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyNameError(runtime, klass);
+        }
+    };
 
     public static RubyClass createNameErrorClass(IRuby runtime, RubyClass standardErrorClass) {
-        RubyClass nameErrorClass = runtime.defineClass("NameError", standardErrorClass);
+        RubyClass nameErrorClass = runtime.defineClass("NameError", standardErrorClass, NAMEERROR_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyNameError.class);
         
         nameErrorClass.defineFastSingletonMethod("new", 
                 callbackFactory.getOptSingletonMethod("newRubyNameError"));		
         nameErrorClass.defineFastSingletonMethod("exception", 
 				callbackFactory.getOptSingletonMethod("newRubyNameError"));		
 
         nameErrorClass.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         nameErrorClass.defineFastMethod("name", callbackFactory.getMethod("name"));
 
         return nameErrorClass;
     }
 
     protected RubyNameError(IRuby runtime, RubyClass exceptionClass) {
         this(runtime, exceptionClass, exceptionClass.getName().toString());
     }
 
     public RubyNameError(IRuby runtime, RubyClass exceptionClass, String message) {
         this(runtime, exceptionClass, message, null);
     }
 
     public RubyNameError(IRuby runtime, RubyClass exceptionClass, String message, String name) {
         super(runtime, exceptionClass, message);
         this.name = name == null ? runtime.getNil() : runtime.newString(name);
     }
     
     public static RubyNameError newRubyNameError(IRubyObject recv, IRubyObject[] args) {
-        IRuby runtime = recv.getRuntime();
-        RubyNameError newError = new RubyNameError(runtime, (RubyClass)recv);
+        RubyClass klass = (RubyClass)recv;
+        
+        RubyNameError newError = (RubyNameError)klass.allocate();
+        
         newError.callInit(args);
+        
         return newError;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         super.initialize(args);
         if (args.length > 1) {
             name = args[1];
         }
         return this;
     }
 
     public IRubyObject name() {
         return name;
     }
 }
diff --git a/src/org/jruby/RubyNil.java b/src/org/jruby/RubyNil.java
index af960fab72..8dd2b9783c 100644
--- a/src/org/jruby/RubyNil.java
+++ b/src/org/jruby/RubyNil.java
@@ -1,184 +1,191 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  *
  * @author  jpetersen
  */
 public class RubyNil extends RubyObject {
 	private final IRuby runtime;
 	
 	public RubyNil(IRuby runtime) {
 		super(runtime, null);
 		this.runtime = runtime;
 	}
 	
 	public IRuby getRuntime() {
 		return runtime;
 	}
+    
+    public static ObjectAllocator NIL_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return runtime.getNil();
+        }
+    };
 	
     public static RubyClass createNilClass(IRuby runtime) {
-        RubyClass nilClass = runtime.defineClass("NilClass", runtime.getObject());
+        RubyClass nilClass = runtime.defineClass("NilClass", runtime.getObject(), NIL_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyNil.class);
         nilClass.defineFastMethod("type", callbackFactory.getSingletonMethod("type"));
         nilClass.defineFastMethod("to_i", callbackFactory.getSingletonMethod("to_i"));
         nilClass.defineFastMethod("to_s", callbackFactory.getSingletonMethod("to_s"));
         nilClass.defineFastMethod("to_a", callbackFactory.getSingletonMethod("to_a"));
         nilClass.defineFastMethod("to_f", callbackFactory.getSingletonMethod("to_f"));
         nilClass.defineFastMethod("inspect", callbackFactory.getSingletonMethod("inspect"));
         
         nilClass.defineFastMethod("&", callbackFactory.getSingletonMethod("op_and", IRubyObject.class));
         nilClass.defineFastMethod("|", callbackFactory.getSingletonMethod("op_or", IRubyObject.class));
         nilClass.defineFastMethod("^", callbackFactory.getSingletonMethod("op_xor", IRubyObject.class));
         nilClass.defineFastMethod("nil?", callbackFactory.getMethod("nil_p"));
         nilClass.defineFastMethod("id", callbackFactory.getSingletonMethod("id"));
         nilClass.defineFastMethod("taint", callbackFactory.getMethod("taint"));
         nilClass.defineFastMethod("freeze", callbackFactory.getMethod("freeze"));
 
         nilClass.getMetaClass().undefineMethod("new");
         
         runtime.defineGlobalConstant("NIL", runtime.getNil());
         
         return nilClass;
     }
     
     public RubyClass getMetaClass() {
         return runtime.getNilClass();
     }
 
     public boolean isImmediate() {
     	return true;
     }
     
     // Methods of the Nil Class (nil_*):
         
     /** nil_to_i
     *
     */
    public static RubyFixnum to_i(IRubyObject recv) {
        return RubyFixnum.zero(recv.getRuntime());
    }
 
    /**
     * nil_to_f
     *  
     */
 	public static RubyFloat to_f(IRubyObject recv) {
 		return RubyFloat.newFloat(recv.getRuntime(), 0.0D);
 	}
 
     /** nil_to_s
      *
      */
     public static RubyString to_s(IRubyObject recv) {
         return recv.getRuntime().newString("");
     }
     
     /** nil_to_a
      *
      */
     public static RubyArray to_a(IRubyObject recv) {
         return recv.getRuntime().newArray(0);
     }
     
     /** nil_inspect
      *
      */
     public static RubyString inspect(IRubyObject recv) {
         return recv.getRuntime().newString("nil");
     }
     
     /** nil_type
      *
      */
     public static RubyClass type(IRubyObject recv) {
         return recv.getRuntime().getClass("NilClass");
     }
     
     /** nil_and
      *
      */
     public static RubyBoolean op_and(IRubyObject recv, IRubyObject obj) {
         return recv.getRuntime().getFalse();
     }
     
     /** nil_or
      *
      */
     public static RubyBoolean op_or(IRubyObject recv, IRubyObject obj) {
         return recv.getRuntime().newBoolean(obj.isTrue());
     }
 
     /** nil_xor
      *
      */
     public static RubyBoolean op_xor(IRubyObject recv, IRubyObject obj) {
         return recv.getRuntime().newBoolean(obj.isTrue());
     }
 
     public static RubyFixnum id(IRubyObject recv) {
         return recv.getRuntime().newFixnum(4);
     }
 
     public boolean isNil() {
         return true;
     }
     
     public boolean isFalse() {
     	return true;
 	}
 
 	public boolean isTrue() {
 		return false;
 	}
 	
 	public IRubyObject freeze() {
 		return this;
 	}
 	
 	public IRubyObject nil_p() {
 		return getRuntime().getTrue();
 	}
 	
 	public IRubyObject taint() {
 		return this;
 	}
 
     public RubyFixnum id() {
         return getRuntime().newFixnum(4);
     }
 }
diff --git a/src/org/jruby/RubyProcess.java b/src/org/jruby/RubyProcess.java
index fb7154a8fe..8773aa2714 100644
--- a/src/org/jruby/RubyProcess.java
+++ b/src/org/jruby/RubyProcess.java
@@ -1,180 +1,182 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 
 /**
  *
  * @author  enebo
  */
 public class RubyProcess {
 
     public static RubyModule createProcessModule(IRuby runtime) {
         RubyModule process = runtime.defineModule("Process");
         
-        RubyModule process_status = process.defineClassUnder("Status", runtime.getObject()); 
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here. Confirm. JRUBY-415
+        RubyModule process_status = process.defineClassUnder("Status", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR); 
 
         CallbackFactory processCallbackFactory = runtime.callbackFactory(RubyProcess.class);
         CallbackFactory process_statusCallbackFactory = runtime.callbackFactory(RubyProcess.RubyStatus.class);
 
 //        process.defineModuleFunction("fork", processCallbackFactory.getSingletonMethod("fork"));
 //        process.defineModuleFunction("exit!", processCallbackFactory.getOptSingletonMethod("exit_bang"));
 //        process.defineModuleFunction("exit", processCallbackFactory.getOptSingletonMethod("exit"));
 //        process.defineModuleFunction("abort", processCallbackFactory.getOptSingletonMethod("abort"));
 //        process.defineModuleFunction("kill", processCallbackFactory.getOptSingletonMethod("kill"));
 //        process.defineModuleFunction("wait", processCallbackFactory.getOptSingletonMethod("wait"));
 //        process.defineModuleFunction("wait2", processCallbackFactory.getOptSingletonMethod("wait2"));
 //        process.defineModuleFunction("waitpid", processCallbackFactory.getOptSingletonMethod("waitpid"));
 //        process.defineModuleFunction("waitpid2", processCallbackFactory.getOptSingletonMethod("waitpid2"));
 //        process.defineModuleFunction("waitall", processCallbackFactory.getSingletonMethod("waitall"));
 //        process.defineModuleFunction("detach", processCallbackFactory.getSingletonMethod("detach", IRubyObject.class));
 //        process.defineModuleFunction("pid", processCallbackFactory.getSingletonMethod("pid"));
 //        process.defineModuleFunction("ppid", processCallbackFactory.getSingletonMethod("ppid"));
 //
 //        process.defineModuleFunction("getpgrp", processCallbackFactory.getSingletonMethod("getprgrp"));
 //        process.defineModuleFunction("setpgrp", processCallbackFactory.getSingletonMethod("setpgrp"));
 //        process.defineModuleFunction("getpgid", processCallbackFactory.getSingletonMethod("getpgid", IRubyObject.class));
 //        process.defineModuleFunction("setpgid", processCallbackFactory.getSingletonMethod("setpgid", IRubyObject.class, IRubyObject.class));
 //
 //        process.defineModuleFunction("setsid", processCallbackFactory.getSingletonMethod("setsid"));
 //
 //        process.defineModuleFunction("getpriority", processCallbackFactory.getSingletonMethod("getpriority", IRubyObject.class, IRubyObject.class));
 //        process.defineModuleFunction("setpriority", processCallbackFactory.getSingletonMethod("setpriority", IRubyObject.class, IRubyObject.class, IRubyObject.class));
 
 //    #ifdef HAVE_GETPRIORITY
 //        rb_define_const(rb_mProcess, "PRIO_PROCESS", INT2FIX(PRIO_PROCESS));
 //        rb_define_const(rb_mProcess, "PRIO_PGRP", INT2FIX(PRIO_PGRP));
 //        rb_define_const(rb_mProcess, "PRIO_USER", INT2FIX(PRIO_USER));
 //    #endif
 
 //        process.defineModuleFunction("uid", processCallbackFactory.getSingletonMethod("uid"));
 //        process.defineModuleFunction("uid=", processCallbackFactory.getSingletonMethod("uid_set", IRubyObject.class));
 //        process.defineModuleFunction("gid", processCallbackFactory.getSingletonMethod("gid"));
 //        process.defineModuleFunction("gid=", processCallbackFactory.getSingletonMethod("gid_set", IRubyObject.class));
 //        process.defineModuleFunction("euid", processCallbackFactory.getSingletonMethod("euid"));
 //        process.defineModuleFunction("euid=", processCallbackFactory.getSingletonMethod("euid_set", IRubyObject.class));
 //        process.defineModuleFunction("egid", processCallbackFactory.getSingletonMethod("egid"));
 //        process.defineModuleFunction("egid=", processCallbackFactory.getSingletonMethod("egid_set", IRubyObject.class));
 //        process.defineModuleFunction("initgroups", processCallbackFactory.getSingletonMethod("initgroups", IRubyObject.class, IRubyObject.class));
 //        process.defineModuleFunction("groups", processCallbackFactory.getSingletonMethod("groups"));
 //        process.defineModuleFunction("groups=", processCallbackFactory.getSingletonMethod("groups_set", IRubyObject.class));
 //        process.defineModuleFunction("maxgroups", processCallbackFactory.getSingletonMethod("maxgroups"));
 //        process.defineModuleFunction("maxgroups=", processCallbackFactory.getSingletonMethod("maxgroups_set", IRubyObject.class));
         process.defineModuleFunction("times", processCallbackFactory.getSingletonMethod("times"));
         
         // Process::Status methods  
         process_status.defineMethod("==", process_statusCallbackFactory.getMethod("op_eq", IRubyObject.class));
 //        process_status.defineMethod("&", process_statusCallbackFactory.getMethod("op_and"));
         process_status.defineMethod(">>", process_statusCallbackFactory.getMethod("rightshift_op", IRubyObject.class));
         process_status.defineMethod("to_i", process_statusCallbackFactory.getMethod("to_i"));
 //        process_status.defineMethod("to_int", process_statusCallbackFactory.getMethod("to_int"));
         process_status.defineMethod("to_s", process_statusCallbackFactory.getMethod("to_s"));
         process_status.defineMethod("inspect", process_statusCallbackFactory.getMethod("inspect"));
 //        process_status.defineMethod("pid", process_statusCallbackFactory.getMethod("pid"));
 //        process_status.defineMethod("stopped?", process_statusCallbackFactory.getMethod("stopped_p"));
 //        process_status.defineMethod("stopsig", process_statusCallbackFactory.getMethod("stopsig"));
 //        process_status.defineMethod("signaled?", process_statusCallbackFactory.getMethod("signaled_p"));
 //        process_status.defineMethod("termsig", process_statusCallbackFactory.getMethod("termsig"));
 //        process_status.defineMethod("exited?", process_statusCallbackFactory.getMethod("exited_p"));
         process_status.defineMethod("exitstatus", process_statusCallbackFactory.getMethod("exitstatus"));
         process_status.defineMethod("success?", process_statusCallbackFactory.getMethod("success_p"));
 //        process_status.defineMethod("coredump?", process_statusCallbackFactory.getMethod("coredump_p"));
         
         return process;
     }
     
     public static class RubyStatus extends RubyObject {
         private long status = 0L;
         
         private static final long EXIT_SUCCESS = 0L;
         public RubyStatus(IRuby runtime, RubyClass metaClass, long status) {
             super(runtime, metaClass);
             
             this.status = status;
         }
         
         public static RubyStatus newProcessStatus(IRuby runtime, long status) {
             return new RubyStatus(runtime, runtime.getModule("Process").getClass("Status"), status);
         }
         
         public IRubyObject exitstatus() {
             return getRuntime().newFixnum(status);
         }
         
         public IRubyObject rightshift_op(IRubyObject other) {
             long shiftValue = other.convertToInteger().getLongValue();
             
             
             return getRuntime().newFixnum(status >> shiftValue);
         }
         
         public IRubyObject op_eq(IRubyObject other) {
             return other.callMethod(getRuntime().getCurrentContext(),"==",this.to_i());
         }
 
         public IRubyObject to_i() {
             return exitstatus();
         }
         
         public IRubyObject to_s() {
             return getRuntime().newString(String.valueOf(status));
         }
         
         public IRubyObject inspect() {
             return to_s();
         }
         
         public IRubyObject success_p() {
             return getRuntime().newBoolean(status == EXIT_SUCCESS);
         }
     }
     
     public static IRubyObject times(IRubyObject recv) {
         IRuby runtime = recv.getRuntime();
         double currentTime = System.currentTimeMillis() / 1000.0;
         double startTime = runtime.getStartTime() / 1000.0;
         RubyFloat zero = runtime.newFloat(0.0);
         return RubyStruct.newStruct(runtime.getTmsStruct(), new IRubyObject[] {
                 runtime.newFloat(currentTime - startTime), 
                 zero,
                 zero, 
                 zero });
     }
 
     public static IRubyObject pid(IRubyObject recv) {
         return recv.getRuntime().newFixnum(0);
     }
 
     public static IRubyObject kill(IRubyObject recv, IRubyObject[] args) throws Exception {
         return recv.getRuntime().getNil();
     }
 }
diff --git a/src/org/jruby/RubyRange.java b/src/org/jruby/RubyRange.java
index 529f36bfa6..0e394f691d 100644
--- a/src/org/jruby/RubyRange.java
+++ b/src/org/jruby/RubyRange.java
@@ -1,384 +1,383 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001 Ed Sinjiashvili <slorcim@users.sourceforge.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2006 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author jpetersen
  */
 public class RubyRange extends RubyObject {
 
     private IRubyObject begin;
     private IRubyObject end;
     private boolean isExclusive;
 
     public RubyRange(IRuby runtime, RubyClass impl) {
         super(runtime, impl);
     }
 
     public void init(IRubyObject aBegin, IRubyObject aEnd, RubyBoolean aIsExclusive) {
         if (!(aBegin instanceof RubyFixnum && aEnd instanceof RubyFixnum)) {
             try {
                 aBegin.callMethod(getRuntime().getCurrentContext(), "<=>", aEnd);
             } catch (RaiseException rExcptn) {
                 throw getRuntime().newArgumentError("bad value for range");
             }
         }
 
         this.begin = aBegin;
         this.end = aEnd;
         this.isExclusive = aIsExclusive.isTrue();
     }
+    
+    private static ObjectAllocator RANGE_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyRange(runtime, klass);
+        }
+    };
 
     public static RubyClass createRangeClass(IRuby runtime) {
-        RubyClass result = runtime.defineClass("Range", runtime.getObject());
+        RubyClass result = runtime.defineClass("Range", runtime.getObject(), RANGE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyRange.class);
         
         result.includeModule(runtime.getModule("Enumerable"));
 
         result.defineMethod("==", callbackFactory.getMethod("equal", IRubyObject.class));
         result.defineMethod("begin", callbackFactory.getMethod("first"));
         result.defineMethod("each", callbackFactory.getMethod("each"));
         result.defineMethod("end", callbackFactory.getMethod("last"));
         result.defineMethod("exclude_end?", callbackFactory.getMethod("exclude_end_p"));
         result.defineMethod("first", callbackFactory.getMethod("first"));
         result.defineMethod("hash", callbackFactory.getMethod("hash"));
         result.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         result.defineMethod("inspect", callbackFactory.getMethod("inspect"));
         result.defineMethod("last", callbackFactory.getMethod("last"));
         result.defineMethod("length", callbackFactory.getMethod("length"));
         result.defineMethod("size", callbackFactory.getMethod("length"));
         result.defineMethod("step", callbackFactory.getOptMethod("step"));
         result.defineMethod("to_s", callbackFactory.getMethod("to_s"));
 
         result.defineMethod("to_a", callbackFactory.getMethod("to_a"));
         result.defineMethod("include?", callbackFactory.getMethod("include_p", IRubyObject.class));
 		// We override Enumerable#member? since ranges in 1.8.1 are continuous.
 		result.defineAlias("member?", "include?");
         result.defineAlias("===", "include?");
-		
-		result.defineSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
+        
+		CallbackFactory classCB = runtime.callbackFactory(RubyClass.class);
+		result.defineSingletonMethod("new", classCB.getOptMethod("newInstance"));
         
         return result;
     }
 
     /**
      * Converts this Range to a pair of integers representing a start position 
      * and length.  If either of the range's endpoints is negative, it is added to 
      * the <code>limit</code> parameter in an attempt to arrive at a position 
      * <i>p</i> such that <i>0&nbsp;&lt;=&nbsp;p&nbsp;&lt;=&nbsp;limit</i>. If 
      * <code>truncate</code> is true, the result will be adjusted, if possible, so 
      * that <i>begin&nbsp;+&nbsp;length&nbsp;&lt;=&nbsp;limit</i>.  If <code>strict</code> 
      * is true, an exception will be raised if the range can't be converted as 
      * described above; otherwise it just returns <b>null</b>. 
      * 
      * @param limit    the size of the object (e.g., a String or Array) that 
      *                 this range is being evaluated against.
      * @param truncate if true, result must fit within the range <i>(0..limit)</i>.
      * @param isStrict   if true, raises an exception if the range can't be converted.
      * @return         a two-element array representing a start value and a length, 
      *                 or <b>null</b> if the conversion failed.
      */
     public long[] getBeginLength(long limit, boolean truncate, boolean isStrict) {
         long beginLong = RubyNumeric.num2long(begin);
         long endLong = RubyNumeric.num2long(end);
         
         // Apparent legend for MRI 'err' param to JRuby 'truncate' and 'isStrict':
         // 0 =>  truncate && !strict
         // 1 => !truncate &&  strict
         // 2 =>  truncate &&  strict
 
         if (! isExclusive) {
             endLong++;
         }
 
         if (beginLong < 0) {
             beginLong += limit;
             if (beginLong < 0) {
                 if (isStrict) {
                     throw getRuntime().newRangeError(inspect().toString() + " out of range.");
                 }
                 return null;
             }
         }
 
         if (truncate && beginLong > limit) {
             if (isStrict) {
                 throw getRuntime().newRangeError(inspect().toString() + " out of range.");
             }
             return null;
         }
 
         if (truncate && endLong > limit) {
             endLong = limit;
         }
 
 		if (endLong < 0  || (!isExclusive && endLong == 0)) {
 			endLong += limit;
 			if (endLong < 0) {
 				if (isStrict) {
 					throw getRuntime().newRangeError(inspect().toString() + " out of range.");
 				}
 				return null;
 			}
 		}
 
         return new long[] { beginLong, Math.max(endLong - beginLong, 0L) };
     }
 
-    // public Range methods
-    public static RubyRange newInstance(IRubyObject recv, IRubyObject[] args) {
-    	RubyRange range = new RubyRange(recv.getRuntime(),(RubyClass)recv);
-    	
-    	range.initialize(args);
-    	
-    	return range;
-    }
-
     public static RubyRange newRange(IRuby runtime, IRubyObject begin, IRubyObject end, boolean isExclusive) {
         RubyRange range = new RubyRange(runtime, runtime.getClass("Range"));
         range.init(begin, end, isExclusive ? runtime.getTrue() : runtime.getFalse());
         return range;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         if (args.length == 3) {
             init(args[0], args[1], (RubyBoolean) args[2]);
         } else if (args.length == 2) {
             init(args[0], args[1], getRuntime().getFalse());
         } else {
             throw getRuntime().newArgumentError("Wrong arguments. (anObject, anObject, aBoolean = false) expected");
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject first() {
         return begin;
     }
 
     public IRubyObject last() {
         return end;
     }
     
     public RubyFixnum hash() {
         ThreadContext context = getRuntime().getCurrentContext();
         long baseHash = (isExclusive ? 1 : 0);
         long beginHash = ((RubyFixnum) begin.callMethod(context, "hash")).getLongValue();
         long endHash = ((RubyFixnum) end.callMethod(context, "hash")).getLongValue();
         
         long hash = baseHash;
         hash = hash ^ (beginHash << 1);
         hash = hash ^ (endHash << 9);
         hash = hash ^ (baseHash << 24);
         
         return getRuntime().newFixnum(hash);
     }
 
     private IRubyObject asString(String stringMethod) {
         ThreadContext context = getRuntime().getCurrentContext();
         RubyString begStr = (RubyString) begin.callMethod(context, stringMethod);
         RubyString endStr = (RubyString) end.callMethod(context, stringMethod);
 
         return begStr.cat(isExclusive ? "..." : "..").concat(endStr);
     }
     
     public IRubyObject inspect() {
         return asString("inspect");
     }
     
     public IRubyObject to_s() {
         return asString("to_s");
     }
 
     public RubyBoolean exclude_end_p() {
         return getRuntime().newBoolean(isExclusive);
     }
 
     public RubyFixnum length() {
         long size = 0;
         ThreadContext context = getRuntime().getCurrentContext();
 
         if (begin.callMethod(context, ">", end).isTrue()) {
             return getRuntime().newFixnum(0);
         }
 
         if (begin instanceof RubyFixnum && end instanceof RubyFixnum) {
             size = ((RubyNumeric) end).getLongValue() - ((RubyNumeric) begin).getLongValue();
             if (!isExclusive) {
                 size++;
             }
         } else { // Support length for arbitrary classes
             IRubyObject currentObject = begin;
 	    String compareMethod = isExclusive ? "<" : "<=";
 
 	    while (currentObject.callMethod(context, compareMethod, end).isTrue()) {
 		size++;
 		if (currentObject.equals(end)) {
 		    break;
 		}
 		currentObject = currentObject.callMethod(context, "succ");
 	    }
 	}
         return getRuntime().newFixnum(size);
     }
 
     public IRubyObject equal(IRubyObject obj) {
         if (!(obj instanceof RubyRange)) {
             return getRuntime().getFalse();
         }
         RubyRange otherRange = (RubyRange) obj;
         boolean result =
             begin.equals(otherRange.begin) &&
             end.equals(otherRange.end) &&
             isExclusive == otherRange.isExclusive;
         return getRuntime().newBoolean(result);
     }
 
     public IRubyObject each() {
         ThreadContext context = getRuntime().getCurrentContext();
         
         if (begin instanceof RubyFixnum && end instanceof RubyFixnum) {
             long endLong = ((RubyNumeric) end).getLongValue();
             long i = ((RubyNumeric) begin).getLongValue();
 
             if (!isExclusive) {
                 endLong += 1;
             }
 
             for (; i < endLong; i++) {
                 context.yield(getRuntime().newFixnum(i));
             }
         } else if (begin instanceof RubyString) {
             ((RubyString) begin).upto(end, isExclusive);
         } else if (begin.isKindOf(getRuntime().getClass("Numeric"))) {
             if (!isExclusive) {
                 end = end.callMethod(context, "+", RubyFixnum.one(getRuntime()));
             }
             while (begin.callMethod(context, "<", end).isTrue()) {
                 context.yield(begin);
                 begin = begin.callMethod(context, "+", RubyFixnum.one(getRuntime()));
             }
         } else {
             IRubyObject v = begin;
 
             if (isExclusive) {
                 while (v.callMethod(context, "<", end).isTrue()) {
                     if (v.equals(end)) {
                         break;
                     }
                     context.yield(v);
                     v = v.callMethod(context, "succ");
                 }
             } else {
                 while (v.callMethod(context, "<=", end).isTrue()) {
                     context.yield(v);
                     if (v.equals(end)) {
                         break;
                     }
                     v = v.callMethod(context, "succ");
                 }
             }
         }
 
         return this;
     }
     
     public IRubyObject step(IRubyObject[] args) {
         checkArgumentCount(args, 0, 1);
         
         IRubyObject currentObject = begin;
         String compareMethod = isExclusive ? "<" : "<=";
         int stepSize = (int) (args.length == 0 ? 1 : args[0].convertToInteger().getLongValue());
         
         if (stepSize <= 0) {
             throw getRuntime().newArgumentError("step can't be negative");
         }
 
         ThreadContext context = getRuntime().getCurrentContext();
         if (begin instanceof RubyNumeric && end instanceof RubyNumeric) {
             RubyFixnum stepNum = getRuntime().newFixnum(stepSize);
             while (currentObject.callMethod(context, compareMethod, end).isTrue()) {
                 context.yield(currentObject);
                 currentObject = currentObject.callMethod(context, "+", stepNum);
             }
         } else {
             while (currentObject.callMethod(context, compareMethod, end).isTrue()) {
                 context.yield(currentObject);
                 
                 for (int i = 0; i < stepSize; i++) {
                     currentObject = currentObject.callMethod(context, "succ");
                 }
             }
         }
         
         return this;
     }
     
     public RubyArray to_a() {
         IRubyObject currentObject = begin;
 	    String compareMethod = isExclusive ? "<" : "<=";
 	    RubyArray array = getRuntime().newArray();
         ThreadContext context = getRuntime().getCurrentContext();
         
 	    while (currentObject.callMethod(context, compareMethod, end).isTrue()) {
 	        array.append(currentObject);
 	        
 			if (currentObject.equals(end)) {
 			    break;
 			}
 			
 			currentObject = currentObject.callMethod(context, "succ");
 	    }
 	    
 	    return array;
     }
     
     // this could have been easily written in Ruby --sma
     public RubyBoolean include_p(IRubyObject obj) {
     	String compareMethod = isExclusive ? ">" : ">=";
     	IRubyObject[] arg = new IRubyObject[]{ obj };
     	IRubyObject f = obj.getRuntime().getFalse();
         ThreadContext context = getRuntime().getCurrentContext();
         
     	return f.getRuntime().newBoolean(
     			f != first().callMethod(context, "<=", arg) && f != last().callMethod(context, compareMethod, arg));
     }
 }
diff --git a/src/org/jruby/RubyRegexp.java b/src/org/jruby/RubyRegexp.java
index 933c30d0bc..44ac42f9ef 100644
--- a/src/org/jruby/RubyRegexp.java
+++ b/src/org/jruby/RubyRegexp.java
@@ -1,690 +1,708 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004-2005 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 David Corbin <dcorbin@users.sourceforge.net>
  * Copyright (C) 2006 Nick Sieger <nicksieger@gmail.com>
  * Copyright (C) 2006 Miguel Covarrubias <mlcovarrubias@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.jruby.parser.ReOptions;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.util.PrintfFormat;
 
 /**
  *
  * @author  amoore
  */
 public class RubyRegexp extends RubyObject implements ReOptions {
     private static final RegexpTranslator REGEXP_TRANSLATOR = new RegexpTranslator();
 
     // \013 is a vertical tab. Java does not support the \v notation used by
     // Ruby.
     private static final Pattern SPECIAL_CHARS = Pattern.compile("([\\\t\\\n\\\f\\\r\\ \\#\\\013\\+\\[\\]\\.\\?\\*\\(\\)\\{\\}\\|\\\\\\^\\$])");    
 
 	/** Class which represents the multibyte character set code.
 	 * (should be an enum in Java 5.0).
 	 * 
 	 * Warning: THIS IS NOT REALLY SUPPORTED BY JRUBY. 
 	 */
 
 	public static final class Code {
 		public static final Code NIL = new Code(null);
 		public static final Code NONE = new Code("none");
 		public static final Code UTF8 = new Code("utf8");
 		public static final Code SJIS = new Code("sjis");
 
 		private String kcode;
 
 		private Code(String kcode) {
 			this.kcode = kcode;
 		}
 
 		public static Code create(IRuby runtime, String lang) {
 			if (lang == null) {
 				return NIL;
 			} else if (lang.charAt(0) == 'n' || lang.charAt(0) == 'N') {
 				return NONE;
 			} else if (lang.charAt(0) == 'u' || lang.charAt(0) == 'U') {
 				return UTF8;
 			} else if (lang.charAt(0) == 's' || lang.charAt(0) == 'S') {
 				runtime.getWarnings().warn("JRuby supports only Unicode regexp.");
 				return SJIS;
 			}
 			return NIL;
 		}
 
 		public IRubyObject kcode(IRuby runtime) {
 			if (kcode == null) {
 				return runtime.getNil();
 			}
 			return runtime.newString(kcode);
 		}
 
 		public int flags() {
             int flags = 0;
 			if (this == UTF8) {
 				flags |= Pattern.UNICODE_CASE;
 			}
             flags |= Pattern.UNIX_LINES;
             
 			return flags;
 		}
 	}
 	
     private Pattern pattern;
     private Code code;
 
     Code getCode() {
         return code;
     }
 
 	// lastTarget and matcher currently only used by searchAgain
 	private String lastTarget = null;
 	private Matcher matcher = null;
 
-    public RubyRegexp(IRuby runtime) {
+    public RubyRegexp(IRuby runtime, RubyClass klass) {
+        super(runtime, klass);
+    }
+
+    private RubyRegexp(IRuby runtime) {
         super(runtime, runtime.getClass("Regexp"));
     }
+    
+    private static ObjectAllocator REGEXP_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            RubyRegexp instance = new RubyRegexp(runtime, klass);
+            
+            return instance;
+        }
+    };
 
     public static RubyClass createRegexpClass(IRuby runtime) {
-        RubyClass regexpClass = runtime.defineClass("Regexp", runtime.getObject());
+        RubyClass regexpClass = runtime.defineClass("Regexp", runtime.getObject(), REGEXP_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyRegexp.class);
         
         regexpClass.defineConstant("IGNORECASE", runtime.newFixnum(RE_OPTION_IGNORECASE));
         regexpClass.defineConstant("EXTENDED", runtime.newFixnum(RE_OPTION_EXTENDED));
         regexpClass.defineConstant("MULTILINE", runtime.newFixnum(RE_OPTION_MULTILINE));
 
         regexpClass.defineFastMethod("initialize", callbackFactory.getOptMethod("initialize"));
         regexpClass.defineFastMethod("clone", callbackFactory.getMethod("rbClone"));
         regexpClass.defineFastMethod("==", callbackFactory.getMethod("equal", IRubyObject.class));
         regexpClass.defineFastMethod("===", callbackFactory.getMethod("match", IRubyObject.class));
         regexpClass.defineFastMethod("=~", callbackFactory.getMethod("match", IRubyObject.class));
         regexpClass.defineFastMethod("~", callbackFactory.getMethod("match2"));
         regexpClass.defineFastMethod("match", callbackFactory.getMethod("match_m", IRubyObject.class));
         regexpClass.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
         regexpClass.defineFastMethod("source", callbackFactory.getMethod("source"));
         regexpClass.defineFastMethod("casefold?", callbackFactory.getMethod("casefold"));
         regexpClass.defineFastMethod("kcode", callbackFactory.getMethod("kcode"));
         regexpClass.defineFastMethod("to_s", callbackFactory.getMethod("to_s"));
 
         regexpClass.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
         regexpClass.defineFastSingletonMethod("compile", callbackFactory.getOptSingletonMethod("newInstance"));
         regexpClass.defineFastSingletonMethod("quote", callbackFactory.getSingletonMethod("quote", RubyString.class));
         regexpClass.defineFastSingletonMethod("escape", callbackFactory.getSingletonMethod("quote", RubyString.class));
         regexpClass.defineFastSingletonMethod("last_match", callbackFactory.getSingletonMethod("last_match_s"));
         regexpClass.defineFastSingletonMethod("union", callbackFactory.getOptSingletonMethod("union"));
 
         return regexpClass;
     }
 
     public void initialize(String regex, int options) {
         try {
             pattern = REGEXP_TRANSLATOR.translate(regex, options, code.flags());
         } catch(java.util.regex.PatternSyntaxException e) {
             throw getRuntime().newSyntaxError(e.getMessage());
         }
     }
 
     public static String escapeSpecialChars(String original) {
     	return SPECIAL_CHARS.matcher(original).replaceAll("\\\\$1");
     }
 
     private void recompileIfNeeded() {
         checkInitialized();
     }
 
     private void checkInitialized() {
         if (pattern == null) {
             throw getRuntime().newTypeError("uninitialized Regexp");
         }
     }
     
     public static RubyRegexp regexpValue(IRubyObject obj) {
         if (obj instanceof RubyRegexp) {
             return (RubyRegexp) obj;
         } else if (obj instanceof RubyString) {
             return newRegexp(obj.getRuntime().newString(escapeSpecialChars(((RubyString) obj).toString())), 0, null);
         } else {
             throw obj.getRuntime().newArgumentError("can't convert arg to Regexp");
         }
     }
 
     // Methods of the Regexp class (rb_reg_*):
 
     public static RubyRegexp newRegexp(RubyString str, int options, String lang) {
         return newRegexp(str.getRuntime(), str.toString(), options, lang);
     }
     
     public static RubyRegexp newRegexp(IRuby runtime, Pattern pattern, String lang) {
         RubyRegexp re = new RubyRegexp(runtime);
         re.code = Code.create(runtime, lang);
         re.pattern = pattern;
         return re;
     }
     
     public static RubyRegexp newRegexp(IRuby runtime, String str, int options, String kcode) {
         RubyRegexp re = new RubyRegexp(runtime);
         re.code = Code.create(runtime, kcode);
         re.initialize(str, options);
         return re;
     }
     
     public static RubyRegexp newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyRegexp re = new RubyRegexp(recv.getRuntime());
-        re.setMetaClass((RubyClass) recv);
-        re.initialize(args);
+        IRuby runtime = recv.getRuntime();
+        RubyClass klass = (RubyClass)recv;
+        
+        RubyRegexp re = (RubyRegexp)klass.allocate();
+        
+        re.callInit(args);
+        
         return re;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         String pat =
             (args[0] instanceof RubyRegexp)
                 ? ((RubyRegexp) args[0]).source().toString()
                 : RubyString.stringValue(args[0]).toString();
         int opts = 0;
         if (args.length > 1) {
             if (args[1] instanceof RubyFixnum) {
                 opts = (int) ((RubyFixnum) args[1]).getLongValue();
             } else if (args[1].isTrue()) {
                 opts |= RE_OPTION_IGNORECASE;
             }
         }
         if (args.length > 2) {
         	code = Code.create(getRuntime(), RubyString.stringValue (args[2]).toString());
         } else {
         	code = Code.create(getRuntime(), null);
         }
         initialize(pat, opts);
         return getRuntime().getNil();
     }
 
     /** rb_reg_s_quote
      * 
      */
     public static RubyString quote(IRubyObject recv, RubyString str) {
         return (RubyString) recv.getRuntime().newString(escapeSpecialChars(str.toString())).infectBy(str);
     }
 
     /** 
      * 
      */
     public static IRubyObject last_match_s(IRubyObject recv) {
         return recv.getRuntime().getCurrentContext().getBackref();
     }
 
     /** rb_reg_equal
      * 
      */
     public IRubyObject equal(IRubyObject other) {
         if (other == this) {
             return getRuntime().getTrue();
         }
         if (!(other instanceof RubyRegexp)) {
             return getRuntime().getFalse();
         }
         RubyRegexp re = (RubyRegexp) other;
         checkInitialized();
         if (!(re.pattern.pattern().equals(pattern.pattern()) && 
         	  re.pattern.flags() == pattern.flags())) {
             return getRuntime().getFalse();
         }
         
         if (code != re.code) {
         	return getRuntime().getFalse();
         }
         
         return getRuntime().getTrue();
     }
 
     /** rb_reg_match2
      * 
      */
     public IRubyObject match2() {
         IRubyObject target = getRuntime().getCurrentContext().getLastline();
         
         return target instanceof RubyString ? match(target) : getRuntime().getNil();
     }
     
     /** rb_reg_match
      * 
      */
     public IRubyObject match(IRubyObject target) {
         if (target.isNil()) {
             return getRuntime().getFalse();
         }
         // FIXME:  I think all String expecting functions has this magic via RSTRING
     	if (target instanceof RubySymbol || target instanceof RubyHash || target instanceof RubyArray) {
     		return getRuntime().getFalse();
     	}
     	
     	String string = RubyString.stringValue(target).toString();
     	
     	if (string.length() == 0) {
     		string = "\n";
     	}
     	
         int result = search(string, 0);
         
         return result < 0 ? getRuntime().getNil() :
         	getRuntime().newFixnum(result);
     }
 
     /** rb_reg_match_m
      * 
      */
     public IRubyObject match_m(IRubyObject target) {
         if (target.isNil()) {
             return target;
         }
         IRubyObject result = match(target);
         return result.isNil() ? result : getRuntime().getCurrentContext().getBackref().rbClone();
     }
 
     /** rb_reg_source
      * 
      */
     public RubyString source() {
         checkInitialized();
         return getRuntime().newString(pattern.pattern());
     }
 
     public IRubyObject kcode() {
         return code.kcode(getRuntime());
     }
 
     /** rb_reg_casefold_p
      * 
      */
     public RubyBoolean casefold() {
         checkInitialized();
         return getRuntime().newBoolean((pattern.flags() & Pattern.CASE_INSENSITIVE) != 0);
     }
 
     /** rb_reg_nth_match
      *
      */
     public static IRubyObject nth_match(int n, IRubyObject match) {
         IRubyObject nil = match.getRuntime().getNil();
         if (match.isNil()) {
             return nil;
         }
         
         RubyMatchData rmd = (RubyMatchData) match;
         
         if (n > rmd.getSize()) {
             return nil;
         }
         
         if (n < 0) {
             n += rmd.getSize();
             if (n <= 0) {
                 return nil;
             }
         }
         return rmd.group(n);
     }
 
     /** rb_reg_last_match
      *
      */
     public static IRubyObject last_match(IRubyObject match) {
         return match.isNil() ? match : ((RubyMatchData) match).group(0);
     }
 
     /** rb_reg_match_pre
      *
      */
     public static IRubyObject match_pre(IRubyObject match) {
         return match.isNil() ? match : ((RubyMatchData) match).pre_match();
     }
 
     /** rb_reg_match_post
      *
      */
     public static IRubyObject match_post(IRubyObject match) {
         return match.isNil() ? match : ((RubyMatchData) match).post_match();
     }
 
     /** rb_reg_match_last
      *
      */
     public static IRubyObject match_last(IRubyObject match) {
         if (match.isNil()) {
             return match;
         }
         RubyMatchData md = (RubyMatchData) match;
         for (long i = md.getSize() - 1; i > 0; i--) {
             if (!md.group(i).isNil()) {
                 return md.group(i);
             }
         }
         return md.getRuntime().getNil();
     }
 
     /** rb_reg_search
      *
      */
     public int search(String target, int pos) {
         if (pos > target.length()) {
             return -1;
         }
         recompileIfNeeded();
 
         // If nothing match then nil will be returned
         IRubyObject result = match(target, pos);
         getRuntime().getCurrentContext().setBackref(result);
 
         // If nothing match then -1 will be returned
         return result instanceof RubyMatchData ? ((RubyMatchData) result).matchStartPosition() : -1;
     }
     
     public IRubyObject search2(String str) {
         IRubyObject result = match(str, 0);
         
         getRuntime().getCurrentContext().setBackref(result);
         
     	return result;
     }
 	
     public int searchAgain(String target) {
         if (matcher == null || !target.equals(lastTarget)) {
 			matcher = pattern.matcher(target);
 			lastTarget = target;
         }
 			
 	    if (!matcher.find()) {
 			return -1;
         }
 		
 		int count = matcher.groupCount() + 1;
         int[] begin = new int[count];
         int[] end = new int[count];
         for (int i = 0; i < count; i++) {
             begin[i] = matcher.start(i);
             end[i] = matcher.end(i);
         }
 		
 		RubyMatchData match = new RubyMatchData(getRuntime(), target, begin, end);
 
 		getRuntime().getCurrentContext().setBackref(match);
             
 		return match.matchStartPosition(); 
     }
     
     public IRubyObject match(String target, int startPos) {
     	Matcher aMatcher = pattern.matcher(target);
     	
         if (aMatcher.find(startPos)) {
             int count = aMatcher.groupCount() + 1;
             int[] begin = new int[count];
             int[] end = new int[count];
             for (int i = 0; i < count; i++) {
                 begin[i] = aMatcher.start(i);
                 end[i] = aMatcher.end(i);
             }
             
             return new RubyMatchData(getRuntime(), target, begin, end);
         }
         return getRuntime().getNil();
     }
 
 
     /** rb_reg_regsub
      *
      */
     public IRubyObject regsub(IRubyObject str, RubyMatchData match) {
         String repl = RubyString.stringValue(str).toString();
         StringBuffer sb = new StringBuffer("");
         int pos = 0;
         int end = repl.length();
         char c;
         IRubyObject ins;
         while (pos < end) {
             c = repl.charAt(pos++);
             if (c == '\\' && pos < end) {
                 c = repl.charAt(pos++);
                 switch (c) {
                     case '0' :
                     case '1' :
                     case '2' :
                     case '3' :
                     case '4' :
                     case '5' :
                     case '6' :
                     case '7' :
                     case '8' :
                     case '9' :
                         ins = match.group(c - '0');
                         break;
                     case '&' :
                         ins = match.group(0);
                         break;
                     case '`' :
                         ins = match.pre_match();
                         break;
                     case '\'' :
                         ins = match.post_match();
                         break;
                     case '+' :
                         ins = match_last(match);
                         break;
                     case '\\' :
                         sb.append(c);
                         continue;
                     default :
                         sb.append('\\').append(c);
                         continue;
                 }
                 if (!ins.isNil()) {
                     sb.append(((RubyString) ins).getValue());
                 }
             } else {
                 sb.append(c);
             }
         }
         return getRuntime().newString(sb.toString());
     }
 
     // TODO: Could this be better hooked up to RubyObject#clone?
     public IRubyObject rbClone() {
     	RubyRegexp newObj = new RubyRegexp(getRuntime());
     	newObj.pattern = pattern;
     	newObj.code = code;
     	newObj.setTaint(isTaint());
     	newObj.initCopy(this);
     	newObj.setFrozen(isFrozen());
         return newObj;
     }
 
     /** rb_reg_inspect
      *
      */
     public IRubyObject inspect() {
         final String regex = pattern.pattern();
 		final int length = regex.length();
         StringBuffer sb = new StringBuffer(length + 2);
 
         sb.append('/');
         for (int i = 0; i < length; i++) {
             char c = regex.charAt(i);
 
             if (RubyString.isAlnum(c)) {
                 sb.append(c);
             } else if (c == '/') {
                 if (i == 0 || regex.charAt(i - 1) != '\\') {
                     sb.append("\\");
                 }
             	sb.append(c);
             } else if (RubyString.isPrint(c)) {
                 sb.append(c);
             } else if (c == '\n') {
                 sb.append('\\').append('n');
             } else if (c == '\r') {
                 sb.append('\\').append('r');
             } else if (c == '\t') {
                 sb.append('\\').append('t');
             } else if (c == '\f') {
                 sb.append('\\').append('f');
             } else if (c == '\u000B') {
                 sb.append('\\').append('v');
             } else if (c == '\u0007') {
                 sb.append('\\').append('a');
             } else if (c == '\u001B') {
                 sb.append('\\').append('e');
             } else {
                 sb.append(new PrintfFormat("\\%.3o").sprintf(c));
             }
         }
         sb.append('/');
 
         if(code == Code.NONE) {
             sb.append('n');
         } else if(code == Code.UTF8) {
             sb.append('u');
         } else if(code == Code.SJIS) {
             sb.append('s');
         }
   
         if ((pattern.flags() & Pattern.CASE_INSENSITIVE) > 0) {
             sb.append('i');
         }
   
         if ((pattern.flags() & Pattern.DOTALL) > 0) {
             sb.append('m');
         }
         
         if ((pattern.flags() & Pattern.COMMENTS) > 0) {
             sb.append('x');
         }
 
         return getRuntime().newString(sb.toString());
     }
     
     /**
      * rb_reg_s_union
      */
     public static IRubyObject union(IRubyObject recv, IRubyObject[] args) {
         if (args.length == 0) {
             return newInstance(recv, new IRubyObject[] {recv.getRuntime().newString("(?!)")});
         }
         
         if (args.length == 1) {
             IRubyObject arg = args[0].convertToType("Regexp", "to_regexp", false);
             if (!arg.isNil()) {
                 return arg;
             }
             return newInstance(recv, new IRubyObject[] {quote(recv, args[0].convertToString())});
         }
         
         StringBuffer buffer = new StringBuffer();
         for (int i = 0; i < args.length; i++) {
         	if (i > 0) {
         		buffer.append("|");
             }
         	IRubyObject arg = args[i].convertToType("Regexp", "to_regexp", false);
             if (arg.isNil()) {
                 arg = quote(recv, args[i].convertToString());
             }
             buffer.append(arg.toString());
         }
         
         return newInstance(recv, new IRubyObject[] {recv.getRuntime().newString(buffer.toString())});
     }
 
     
     public IRubyObject to_s() {
         return getRuntime().newString(toString());
     }
     
     public String toString() {
     	StringBuffer buffer = new StringBuffer(100);
     	StringBuffer off = new StringBuffer(3);
     	
     	buffer.append("(?");
     	
     	flagToString(buffer, off, Pattern.DOTALL, 'm');
     	flagToString(buffer, off, Pattern.CASE_INSENSITIVE, 'i');
     	flagToString(buffer, off, Pattern.COMMENTS, 'x');
 
 		if (off.length() > 0) {
 			buffer.append('-').append(off);
 		}
 
     	buffer.append(':');
         buffer.append(pattern.pattern().replaceAll("^/|([^\\\\])/", "$1\\\\/"));
 		buffer.append(')');
 
     	return buffer.toString();
     }
 
     /** Helper method for the {@link #toString() toString} method which creates
      * an <i>on-off</i> pattern of {@link Pattern Pattern} flags. 
      * 
 	 * @param buffer the default buffer for the output
 	 * @param off temporary buffer for the off flags
 	 * @param flag a Pattern flag
 	 * @param c the char which represents the flag
 	 */
 	private void flagToString(StringBuffer buffer, StringBuffer off, int flag, char c) {
 		if ((pattern.flags() & flag) != 0) {
     		buffer.append(c);
     	} else {
     		off.append(c);
     	}
 	}
 
 	public void marshalTo(MarshalStream output) throws java.io.IOException {
         output.write('/');
         output.dumpString(pattern.pattern());
 
         int flags = 0;
         if ((pattern.flags() & Pattern.DOTALL) > 0) {
             flags |= RE_OPTION_MULTILINE;
         }
         if ((pattern.flags() & Pattern.CASE_INSENSITIVE) > 0) {
             flags |= RE_OPTION_IGNORECASE;
         }
         if ((pattern.flags() & Pattern.COMMENTS) > 0) {
             flags |= RE_OPTION_EXTENDED;
         }
         output.dumpInt(flags);
     }
 	
 	public Pattern getPattern() {
 		return this.pattern;
 	}
+
 }
diff --git a/src/org/jruby/RubyStringIO.java b/src/org/jruby/RubyStringIO.java
index ce1aacc63e..a556fde766 100644
--- a/src/org/jruby/RubyStringIO.java
+++ b/src/org/jruby/RubyStringIO.java
@@ -1,480 +1,482 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * Copyright (C) 2006 Ryan Bell <ryan.l.bell@gmail.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 import org.jruby.util.IOHandler;
 
 public class RubyStringIO extends RubyObject {
+    private static ObjectAllocator STRINGIO_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyStringIO(runtime, klass);
+        }
+    };
+    
     public static RubyClass createStringIOClass(final IRuby runtime) {
-        final RubyClass stringIOClass = runtime.defineClass("StringIO",runtime.getObject());
+        final RubyClass stringIOClass = runtime.defineClass("StringIO", runtime.getObject(), STRINGIO_ALLOCATOR);
+        
         final CallbackFactory callbackFactory = runtime.callbackFactory(RubyStringIO.class);
+        
         stringIOClass.defineSingletonMethod("open", callbackFactory.getOptSingletonMethod("open"));
-        stringIOClass.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
         stringIOClass.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         stringIOClass.defineFastMethod("<<", callbackFactory.getMethod("append",IRubyObject.class));
         stringIOClass.defineFastMethod("binmode", callbackFactory.getMethod("binmode"));
         stringIOClass.defineFastMethod("close", callbackFactory.getMethod("close"));
         stringIOClass.defineFastMethod("closed?", callbackFactory.getMethod("closed_p"));
         stringIOClass.defineFastMethod("close_read", callbackFactory.getMethod("close_read"));
         stringIOClass.defineFastMethod("closed_read?", callbackFactory.getMethod("closed_read_p"));
         stringIOClass.defineFastMethod("close_write", callbackFactory.getMethod("close_write"));
         stringIOClass.defineFastMethod("closed_write?", callbackFactory.getMethod("closed_write_p"));
         stringIOClass.defineMethod("each", callbackFactory.getOptMethod("each"));
         stringIOClass.defineMethod("each_byte", callbackFactory.getMethod("each_byte"));
         stringIOClass.defineMethod("each_line", callbackFactory.getMethod("each_line"));
         stringIOClass.defineFastMethod("eof", callbackFactory.getMethod("eof"));
         stringIOClass.defineFastMethod("eof?", callbackFactory.getMethod("eof_p"));
         stringIOClass.defineFastMethod("fcntl", callbackFactory.getMethod("fcntl"));
         stringIOClass.defineFastMethod("fileno", callbackFactory.getMethod("fileno"));
         stringIOClass.defineFastMethod("flush", callbackFactory.getMethod("flush"));
         stringIOClass.defineFastMethod("fsync", callbackFactory.getMethod("fsync"));
         stringIOClass.defineFastMethod("getc", callbackFactory.getMethod("getc"));
         stringIOClass.defineFastMethod("gets", callbackFactory.getOptMethod("gets"));
         stringIOClass.defineFastMethod("isatty", callbackFactory.getMethod("isatty"));
         // FIXME: this should probably be an alias?
         stringIOClass.defineFastMethod("tty?", callbackFactory.getMethod("tty_p"));
         stringIOClass.defineFastMethod("length", callbackFactory.getMethod("length"));
         stringIOClass.defineFastMethod("lineno", callbackFactory.getMethod("lineno"));
         stringIOClass.defineFastMethod("lineno=", callbackFactory.getMethod("set_lineno", RubyFixnum.class));
         stringIOClass.defineFastMethod("path", callbackFactory.getMethod("path"));
         stringIOClass.defineFastMethod("pid", callbackFactory.getMethod("pid"));
         stringIOClass.defineFastMethod("pos", callbackFactory.getMethod("pos"));
         // FIXME: this should probably be an alias?
         stringIOClass.defineFastMethod("tell", callbackFactory.getMethod("tell"));
         stringIOClass.defineFastMethod("pos=", callbackFactory.getMethod("set_pos", RubyFixnum.class));
         stringIOClass.defineFastMethod("print", callbackFactory.getOptMethod("print"));
         stringIOClass.defineFastMethod("printf", callbackFactory.getOptMethod("printf"));
         stringIOClass.defineFastMethod("putc", callbackFactory.getMethod("putc", IRubyObject.class));
         stringIOClass.defineFastMethod("puts", callbackFactory.getOptMethod("puts"));
         stringIOClass.defineFastMethod("read", callbackFactory.getOptMethod("read"));
         stringIOClass.defineFastMethod("readchar", callbackFactory.getMethod("readchar"));
         stringIOClass.defineFastMethod("readline", callbackFactory.getOptMethod("readline"));
         stringIOClass.defineFastMethod("readlines", callbackFactory.getOptMethod("readlines"));
         stringIOClass.defineFastMethod("reopen", callbackFactory.getMethod("reopen", IRubyObject.class));
         stringIOClass.defineFastMethod("rewind", callbackFactory.getMethod("rewind"));
         stringIOClass.defineFastMethod("seek", callbackFactory.getOptMethod("seek"));
         stringIOClass.defineFastMethod("size", callbackFactory.getMethod("size"));
         stringIOClass.defineFastMethod("string", callbackFactory.getMethod("string"));
         stringIOClass.defineFastMethod("string=", callbackFactory.getMethod("set_string",RubyString.class));
         stringIOClass.defineFastMethod("sync", callbackFactory.getMethod("sync"));
         stringIOClass.defineFastMethod("sync=", callbackFactory.getMethod("set_sync", IRubyObject.class));
         stringIOClass.defineFastMethod("syswrite", callbackFactory.getMethod("syswrite", IRubyObject.class));
         stringIOClass.defineFastMethod("truncate", callbackFactory.getMethod("truncate", RubyFixnum.class));
         stringIOClass.defineFastMethod("ungetc", callbackFactory.getMethod("ungetc", RubyFixnum.class));
         stringIOClass.defineFastMethod("write", callbackFactory.getMethod("write", IRubyObject.class));
 
         return stringIOClass;
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyStringIO result = new RubyStringIO(recv.getRuntime());
-        result.callInit(args);
-        return result;
-    }
-
     public static IRubyObject open(IRubyObject recv, IRubyObject[] args) {
         RubyString str = recv.getRuntime().newString("");
         IRubyObject mode = recv.getRuntime().getNil();
         if (args.length > 0) {
             str = args[0].convertToString();
             if (args.length > 1) {
                 mode = args[1];
             }
         }
-        RubyStringIO strio = (RubyStringIO)newInstance(recv,new IRubyObject[]{str,mode});
+        RubyStringIO strio = (RubyStringIO)((RubyClass)recv).newInstance(new IRubyObject[]{str,mode});
         IRubyObject val = strio;
         ThreadContext tc = recv.getRuntime().getCurrentContext();
         
         if (tc.isBlockGiven()) {
             try {
                 val = tc.yield(strio);
             } finally {
                 strio.close();
             }
         }
         return val;
     }
 
 
-    protected RubyStringIO(IRuby runtime) {
-        super(runtime, runtime.getClass("StringIO"));
+    protected RubyStringIO(IRuby runtime, RubyClass klass) {
+        super(runtime, klass);
     }
 
     private long pos = 0L;
     private int lineno = 0;
     private boolean eof = false;
     private StringBuffer internal;
     private boolean closedRead = false;
     private boolean closedWrite = false;
 
     public IRubyObject initialize(IRubyObject[] args) {
         internal = new StringBuffer();
         if (checkArgumentCount(args, 0, 2) > 0) {
             internal.append(args[0].convertToString().getValue());
         }
         return this;
     }
 
     public IRubyObject append(IRubyObject obj) {
         String val = obj.toString();
         internal.replace((int)pos,(int)(pos+val.length()),val);
         pos += val.length();
         return this;
     }
 
     public IRubyObject binmode() {
         return getRuntime().getTrue();
     }
     
     public IRubyObject close() {
         closedRead = true;
         closedWrite = true;
         return getRuntime().getNil();
     }
 
     public IRubyObject closed_p() {
         return (closedRead && closedWrite) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject close_read() {
         closedRead = true;
         return getRuntime().getNil();
     }
 
     public IRubyObject closed_read_p() {
         return closedRead ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject close_write() {
         closedWrite = true;
         return getRuntime().getNil();
     }
 
     public IRubyObject closed_write_p() {
         return closedWrite ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
    public IRubyObject each(IRubyObject[] args) {
        IRubyObject line = gets(args);
        ThreadContext context = getRuntime().getCurrentContext();
        while (!line.isNil()) {
            context.yield(line);
            line = gets(args);
        }
        return this;
    }
 
     public IRubyObject each_byte() {
         getRuntime().newString(internal.substring((int)pos)).each_byte();
         return this;
     }
 
     public IRubyObject each_line() {
         return each(new RubyObject[0]);
     }
 
     public IRubyObject eof() {
         return (pos >= internal.length() || eof) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject eof_p() {
         return (pos >= internal.length() || eof) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject fcntl() {
         throw getRuntime().newNotImplementedError("fcntl not implemented");
     }
 
     public IRubyObject fileno() {
         return getRuntime().getNil();
     }
 
     public IRubyObject flush() {
         return this;
     }
 
     public IRubyObject fsync() {
         return RubyFixnum.zero(getRuntime());
     }
 
     public IRubyObject getc() {
         return getRuntime().newFixnum(internal.charAt((int)pos++));
     }
 
     public IRubyObject internalGets(IRubyObject[] args) {
         if (pos < internal.length() && !eof) {
             String sep = ((RubyString)getRuntime().getGlobalVariables().get("$/")).getValue().toString();
             if (args.length>0) {
                 if (args[0].isNil()) {
                     String buf = internal.substring((int)pos);
                     pos+=buf.length();
                     return getRuntime().newString(buf);
                 }
                 sep = args[0].toString();
             }
             int ix = internal.indexOf(sep,(int)pos);
             String add = sep;
             if (-1 == ix) {
                 ix = internal.length();
                 add = "";
             }
             String line = internal.substring((int)pos,ix)+add;
             pos = ix + add.length();
             lineno++;
             return getRuntime().newString(line);
         }
         
         return getRuntime().getNil();
     }
 
     public IRubyObject gets(IRubyObject[] args) {
         IRubyObject result = internalGets(args);
         if (!result.isNil()) {
             getRuntime().getCurrentContext().setLastline(result);
         }
         return result;
     }
 
     public IRubyObject isatty() {
         return getRuntime().getNil();
     }
 
     public IRubyObject tty_p() {
         return getRuntime().getNil();
     }
 
     public IRubyObject length() {
         return getRuntime().newFixnum(internal.length());
     }
 
     public IRubyObject lineno() {
         return getRuntime().newFixnum(lineno);
     }
 
     public IRubyObject set_lineno(RubyFixnum val) {
         lineno = (int)val.getLongValue();
         return getRuntime().getNil();
     }
 
     public IRubyObject path() {
         return getRuntime().getNil();
     }
 
     public IRubyObject pid() {
         return getRuntime().getNil();
     }
 
     public IRubyObject pos() {
         return getRuntime().newFixnum(pos);
     }
 
     public IRubyObject tell() {
         return getRuntime().newFixnum(pos);
     }
 
     public IRubyObject set_pos(RubyFixnum val) {
         pos = (int)val.getLongValue();
         return getRuntime().getNil();
     }
 
     public IRubyObject print(IRubyObject[] args) {
         if (args.length != 0) {
             for (int i=0,j=args.length;i<j;i++) {
                 append(args[i]);
             }
         }
         IRubyObject sep = getRuntime().getGlobalVariables().get("$\\");
         if (!sep.isNil()) {
             append(sep);
         }
         return getRuntime().getNil();
     }
     
     public IRubyObject printf(IRubyObject[] args) {
         append(RubyKernel.sprintf(this,args));
         return getRuntime().getNil();
     }
 
     public IRubyObject putc(IRubyObject obj) {
         append(obj);
         return obj;
     }
 
     public IRubyObject puts(IRubyObject[] obj) {
         if (obj.length == 0) {
             append(getRuntime().newString("\n"));
         }
         
         for (int i=0,j=obj.length;i<j;i++) {
             append(obj[i]);
             internal.replace((int)pos,(int)(++pos),("\n"));
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject read(IRubyObject[] args) {
         String buf = null;
         if (!(pos >= internal.length() || eof)) {
             if (args.length > 0 && !args[0].isNil()) {
                 int end = ((int)pos) + RubyNumeric.fix2int(args[0]);
                 if (end > internal.length()) {
                     buf = internal.substring((int)pos);
                 } else {
                     buf = internal.substring((int)pos,end);
                 }
             } else {
                 buf = internal.substring((int)pos);
             }
             pos+= buf.length();
         }
         IRubyObject ret = null;
         if (buf == null) {
             if (args.length > 0) {
                 return getRuntime().getNil();
             }
             return getRuntime().newString("");
         } else {
             if (args.length>1) {
                 ret = args[1].convertToString();
 								((RubyString)ret).setValue(buf);
             } else {
                 ret = getRuntime().newString(buf);
             }
         }
 
         return ret;
     }
 
     public IRubyObject readchar() {
         return getc();
     }
 
     public IRubyObject readline(IRubyObject[] args) {
         return gets(args);
     }
     
     public IRubyObject readlines(IRubyObject[] arg) {
         List lns = new ArrayList();
         while (!(pos >= internal.length() || eof)) {
             lns.add(gets(arg));
         }
         return getRuntime().newArray(lns);
     }
     
     public IRubyObject reopen(IRubyObject str) {
         if (str instanceof RubyStringIO) {
             pos = ((RubyStringIO)str).pos;
             lineno = ((RubyStringIO)str).lineno;
             eof = ((RubyStringIO)str).eof;
             closedRead = ((RubyStringIO)str).closedRead;
             closedWrite = ((RubyStringIO)str).closedWrite;
             internal = new StringBuffer(((RubyStringIO)str).internal.toString());
         } else {
             pos = 0L;
             lineno = 0;
             eof = false;
             closedRead = false;
             closedWrite = false;
             internal = new StringBuffer();
             internal.append(str.convertToString().getValue());
         }
         return this;
     }
 
     public IRubyObject rewind() {
         this.pos = 0L;
         this.lineno = 0;
         return RubyFixnum.zero(getRuntime());
     }
 
     public IRubyObject seek(IRubyObject[] args) {
         long amount = ((RubyNumeric)args[0]).getLongValue();
         int whence = IOHandler.SEEK_SET;
         if (args.length > 1) {
             whence = (int)(((RubyNumeric)args[1]).getLongValue());
         }
         if (whence == IOHandler.SEEK_CUR) {
             pos += amount;
         } else if (whence == IOHandler.SEEK_END) {
             pos = internal.length() + amount;
         } else {
             pos = amount;
         }
         return RubyFixnum.zero(getRuntime());
     }
 
     public IRubyObject size() {
         return getRuntime().newFixnum(internal.length());
     }
 
     public IRubyObject string() {
         return getRuntime().newString(internal.toString());
     }
 
     public IRubyObject set_string(RubyString arg) {
         return reopen(arg);
     }
 
     public IRubyObject sync() {
         return getRuntime().getTrue();
     }
 
     public IRubyObject set_sync(IRubyObject args) {
         return args;
     }
 
     public IRubyObject syswrite(IRubyObject args) {
         return write(args);
     }
 
     public IRubyObject truncate(RubyFixnum args) {
         int len = (int) args.getLongValue();
         internal.delete(len,internal.length());
         return RubyFixnum.zero(getRuntime());
     }
 
     public IRubyObject ungetc(RubyFixnum args) {
         char val = (char) args.getLongValue();
         internal.insert((int)pos,val);
         return getRuntime().getNil();
     }
 
     public IRubyObject write(IRubyObject args) {
         String obj = args.toString();
         append(args);
         return getRuntime().newFixnum(obj.length());
     }
 }
diff --git a/src/org/jruby/RubyStringScanner.java b/src/org/jruby/RubyStringScanner.java
index fa43fa448f..ddde4b6b88 100644
--- a/src/org/jruby/RubyStringScanner.java
+++ b/src/org/jruby/RubyStringScanner.java
@@ -1,277 +1,277 @@
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.StringScanner;
 
 /**
  * @author kscott
  *
  */
 public class RubyStringScanner extends RubyObject {
 	
 	private StringScanner scanner;
+    
+    private static ObjectAllocator STRINGSCANNER_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new RubyStringScanner(runtime, klass);
+        }
+    };
 	
 	public static RubyClass createScannerClass(final IRuby runtime) {
-		RubyClass scannerClass = runtime.defineClass("StringScanner",runtime.getObject());
+		RubyClass scannerClass = runtime.defineClass("StringScanner", runtime.getObject(), STRINGSCANNER_ALLOCATOR);
 		CallbackFactory callbackFactory = runtime.callbackFactory(RubyStringScanner.class);
 		
-		scannerClass.defineFastSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
 		scannerClass.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
 		scannerClass.defineFastMethod("<<", callbackFactory.getMethod("concat", IRubyObject.class));
 		scannerClass.defineFastMethod("concat", callbackFactory.getMethod("concat", IRubyObject.class));
 		scannerClass.defineFastMethod("[]", callbackFactory.getMethod("group", RubyFixnum.class));
 		scannerClass.defineFastMethod("beginning_of_line?", callbackFactory.getMethod("bol_p"));
 		scannerClass.defineFastMethod("bol?", callbackFactory.getMethod("bol_p"));
 		scannerClass.defineFastMethod("check", callbackFactory.getMethod("check", RubyRegexp.class));
 		scannerClass.defineFastMethod("check_until", callbackFactory.getMethod("check_until", RubyRegexp.class));
 		scannerClass.defineFastMethod("clear", callbackFactory.getMethod("terminate"));
 		scannerClass.defineFastMethod("empty?", callbackFactory.getMethod("eos_p"));
 		scannerClass.defineFastMethod("eos?", callbackFactory.getMethod("eos_p"));
 		scannerClass.defineFastMethod("exist?", callbackFactory.getMethod("exist_p", RubyRegexp.class));
 		scannerClass.defineFastMethod("get_byte", callbackFactory.getMethod("getch"));
 		scannerClass.defineFastMethod("getbyte", callbackFactory.getMethod("getch"));
 		scannerClass.defineFastMethod("getch", callbackFactory.getMethod("getch"));
 		scannerClass.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
 		scannerClass.defineFastMethod("match?", callbackFactory.getMethod("match_p", RubyRegexp.class));
 		scannerClass.defineFastMethod("matched", callbackFactory.getMethod("matched"));
 		scannerClass.defineFastMethod("matched?", callbackFactory.getMethod("matched_p"));
 		scannerClass.defineFastMethod("matched_size", callbackFactory.getMethod("matched_size"));
 		scannerClass.defineFastMethod("matchedsize", callbackFactory.getMethod("matched_size"));
 		scannerClass.defineFastMethod("peek", callbackFactory.getMethod("peek", RubyFixnum.class));
 		scannerClass.defineFastMethod("peep", callbackFactory.getMethod("peek", RubyFixnum.class));
 		scannerClass.defineMethod("pointer", callbackFactory.getMethod("pos"));
 		scannerClass.defineFastMethod("pointer=", callbackFactory.getMethod("set_pos", RubyFixnum.class));
 		scannerClass.defineFastMethod("pos=", callbackFactory.getMethod("set_pos", RubyFixnum.class));
 		scannerClass.defineFastMethod("pos", callbackFactory.getMethod("pos"));
 		scannerClass.defineFastMethod("post_match", callbackFactory.getMethod("post_match"));
 		scannerClass.defineFastMethod("pre_match", callbackFactory.getMethod("pre_match"));
 		scannerClass.defineFastMethod("reset", callbackFactory.getMethod("reset"));
 		scannerClass.defineFastMethod("rest", callbackFactory.getMethod("rest"));
 		scannerClass.defineFastMethod("rest?", callbackFactory.getMethod("rest_p"));
 		scannerClass.defineFastMethod("rest_size", callbackFactory.getMethod("rest_size"));
 		scannerClass.defineFastMethod("restsize", callbackFactory.getMethod("rest_size"));
 		scannerClass.defineFastMethod("scan", callbackFactory.getMethod("scan", RubyRegexp.class));
 		scannerClass.defineFastMethod("scan_full", callbackFactory.getMethod("scan_full", RubyRegexp.class, RubyBoolean.class, RubyBoolean.class));
 		scannerClass.defineFastMethod("scan_until", callbackFactory.getMethod("scan_until", RubyRegexp.class));
 		scannerClass.defineFastMethod("search_full", callbackFactory.getMethod("search_full", RubyRegexp.class, RubyBoolean.class, RubyBoolean.class));
 		scannerClass.defineFastMethod("skip", callbackFactory.getMethod("skip", RubyRegexp.class));
 		scannerClass.defineFastMethod("skip_until", callbackFactory.getMethod("skip_until", RubyRegexp.class));
 		scannerClass.defineFastMethod("string", callbackFactory.getMethod("string"));
 		scannerClass.defineFastMethod("string=", callbackFactory.getMethod("set_string", RubyString.class));
 		scannerClass.defineFastMethod("terminate", callbackFactory.getMethod("terminate"));
 		scannerClass.defineFastMethod("unscan", callbackFactory.getMethod("unscan"));
 		
 		return scannerClass;
 	}
 	
-	public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        RubyStringScanner result = new RubyStringScanner(recv.getRuntime(),(RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-	
 	protected RubyStringScanner(IRuby runtime, RubyClass type) {
 		super(runtime, type);
 	}
 	
 	public IRubyObject initialize(IRubyObject[] args) {
 		if (checkArgumentCount(args, 0, 2) > 0) {
 			scanner = new StringScanner(args[0].convertToString().getValue());
 		} else {
 			scanner = new StringScanner();
 		}
 		return this;
 	}
 	
 	public IRubyObject concat(IRubyObject obj) {
 		scanner.append(obj.convertToString().getValue());
 		return this;
 	}
 	
 	private RubyBoolean trueOrFalse(boolean p) {
 		if (p) {
 			return getRuntime().getTrue();
 		} else {
 			return getRuntime().getFalse();
 		}
 	}
 	
 	private IRubyObject positiveFixnumOrNil(int val) {
 		if (val > -1) {
 			return RubyFixnum.newFixnum(getRuntime(), (long)val);
 		} else {
 			return getRuntime().getNil();
 		}
 	}
 	
 	private IRubyObject stringOrNil(CharSequence cs) {
 		if (cs == null) {
 			return getRuntime().getNil();
 		} else {
 			return RubyString.newString(getRuntime(), cs);
 		}
 	}
 
 	public IRubyObject group(RubyFixnum num) {
 		return stringOrNil(scanner.group(RubyFixnum.fix2int(num)));
 	}
 	
 	public RubyBoolean bol_p() {
 		return trueOrFalse(scanner.isBeginningOfLine());
 	}
 	
 	public IRubyObject check(RubyRegexp rx) {
 		return stringOrNil(scanner.check(rx.getPattern()));
 	}
 	
 	public IRubyObject check_until(RubyRegexp rx) {
 		return stringOrNil(scanner.checkUntil(rx.getPattern()));
 	}
 	
 	public IRubyObject terminate() {
 		scanner.terminate();
 		return this;
 	}
 	
 	public RubyBoolean eos_p() {
 		return trueOrFalse(scanner.isEndOfString());
 	}
 	
 	public IRubyObject exist_p(RubyRegexp rx) {
 		return positiveFixnumOrNil(scanner.exists(rx.getPattern()));
 	}
 	
 	public IRubyObject getch() {
 		char c = scanner.getChar();
 		if (c == 0) {
 			return getRuntime().getNil();
 		} else {
 			return RubyString.newString(getRuntime(), new Character(c).toString());
 		}
 	}
 	
 	public IRubyObject inspect() {
 		return super.inspect();
 	}
 	
 	public IRubyObject match_p(RubyRegexp rx) {
 		return positiveFixnumOrNil(scanner.matches(rx.getPattern()));
 	}
 	
 	public IRubyObject matched() {
 		return stringOrNil(scanner.matchedValue());
 	}
 	
 	public RubyBoolean matched_p() {
 		return trueOrFalse(scanner.matched());
 	}
 	
 	public IRubyObject matched_size() {
 		return positiveFixnumOrNil(scanner.matchedSize());
 	}
 	
 	public IRubyObject peek(RubyFixnum length) {
 		return RubyString.newString(getRuntime(), scanner.peek(RubyFixnum.fix2int(length)));
 	}
 	
 	public RubyFixnum pos() {
 		return RubyFixnum.newFixnum(getRuntime(), (long)scanner.getPos());
 	}
 	 
 	public RubyFixnum set_pos(RubyFixnum pos) {
 		try {
 			scanner.setPos(RubyFixnum.fix2int(pos));
 		} catch (IllegalArgumentException e) {
 			throw getRuntime().newRangeError("index out of range");
 		}
 		return pos;
 	}
 	
 	public IRubyObject post_match() {
 		return stringOrNil(scanner.postMatch());
 	}
 	
 	public IRubyObject pre_match() {
 		return stringOrNil(scanner.preMatch());
 	}
 	
 	public IRubyObject reset() {
 		scanner.reset();
 		return this;
 	}
 	
 	public RubyString rest() {
 		return RubyString.newString(getRuntime(), scanner.rest());
 	}
 	
 	public RubyBoolean rest_p() {
 		return trueOrFalse(!scanner.isEndOfString());
 	}
 	
 	public RubyFixnum rest_size() {
 		return RubyFixnum.newFixnum(getRuntime(), (long)scanner.rest().length());
 	}
 	
 	public IRubyObject scan(RubyRegexp rx) {
 		return stringOrNil(scanner.scan(rx.getPattern()));
 	}
 	
 	public IRubyObject scan_full(RubyRegexp rx, RubyBoolean adv_ptr, RubyBoolean ret_str) {
 		if (adv_ptr.isTrue()) {
 			if (ret_str.isTrue()) {
 				return stringOrNil(scanner.scan(rx.getPattern()));
 			} else {
 				return positiveFixnumOrNil(scanner.skip(rx.getPattern()));
 			}
 		} else {
 			if (ret_str.isTrue()) {
 				return stringOrNil(scanner.check(rx.getPattern()));
 			} else {
 				return positiveFixnumOrNil(scanner.matches(rx.getPattern()));
 			}
 		}
 	}
 	
 	public IRubyObject scan_until(RubyRegexp rx) {
 		return stringOrNil(scanner.scanUntil(rx.getPattern()));
 	}
 	
 	public IRubyObject search_full(RubyRegexp rx, RubyBoolean adv_ptr, RubyBoolean ret_str) {
 		if (adv_ptr.isTrue()) {
 			if (ret_str.isTrue()) {
 				return stringOrNil(scanner.scanUntil(rx.getPattern()));
 			} else {
 				return positiveFixnumOrNil(scanner.skipUntil(rx.getPattern()));
 			}
 		} else {
 			if (ret_str.isTrue()) {
 				return stringOrNil(scanner.checkUntil(rx.getPattern()));
 			} else {
 				return positiveFixnumOrNil(scanner.exists(rx.getPattern()));
 			}
 		}
 	}
 	
 	public IRubyObject skip(RubyRegexp rx) {
 		return positiveFixnumOrNil(scanner.skip(rx.getPattern()));
 	}
 	
 	public IRubyObject skip_until(RubyRegexp rx) {
 		return positiveFixnumOrNil(scanner.skipUntil(rx.getPattern()));
 	}
 	
 	public RubyString string() {
 		return RubyString.newString(getRuntime(), scanner.getString());
 	}
 	
 	public RubyString set_string(RubyString str) {
 		scanner.setString(str.getValue());
 		return str;
 	}
 	
 	public IRubyObject unscan() {
 		scanner.unscan();
 		return this;
 	}
 }
diff --git a/src/org/jruby/RubyStruct.java b/src/org/jruby/RubyStruct.java
index fdf89fa334..22e0ab4099 100644
--- a/src/org/jruby/RubyStruct.java
+++ b/src/org/jruby/RubyStruct.java
@@ -1,451 +1,454 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.List;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.marshal.MarshalStream;
 import org.jruby.runtime.marshal.UnmarshalStream;
 import org.jruby.util.IdUtil;
 import org.jruby.exceptions.RaiseException;
 
 /**
  * @author  jpetersen
  */
 public class RubyStruct extends RubyObject {
     private IRubyObject[] values;
 
     /**
      * Constructor for RubyStruct.
      * @param runtime
      * @param rubyClass
      */
     public RubyStruct(IRuby runtime, RubyClass rubyClass) {
         super(runtime, rubyClass);
     }
 
     public static RubyClass createStructClass(IRuby runtime) {
-        RubyClass structClass = runtime.defineClass("Struct", runtime.getObject());
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR may be ok here, but it's unclear how Structs
+        // work with marshalling. Confirm behavior and ensure we're doing this correctly. JRUBY-415
+        RubyClass structClass = runtime.defineClass("Struct", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyStruct.class);
         structClass.includeModule(runtime.getModule("Enumerable"));
 
         structClass.defineSingletonMethod("new", callbackFactory.getOptSingletonMethod("newInstance"));
 
         structClass.defineMethod("initialize", callbackFactory.getOptMethod("initialize"));
         structClass.defineMethod("clone", callbackFactory.getMethod("rbClone"));
 
         structClass.defineFastMethod("==", callbackFactory.getMethod("equal", IRubyObject.class));
 
         structClass.defineFastMethod("to_s", callbackFactory.getMethod("to_s"));
         structClass.defineFastMethod("inspect", callbackFactory.getMethod("inspect"));
         structClass.defineFastMethod("to_a", callbackFactory.getMethod("to_a"));
         structClass.defineFastMethod("values", callbackFactory.getMethod("to_a"));
         structClass.defineFastMethod("size", callbackFactory.getMethod("size"));
         structClass.defineFastMethod("length", callbackFactory.getMethod("size"));
 
         structClass.defineMethod("each", callbackFactory.getMethod("each"));
         structClass.defineFastMethod("[]", callbackFactory.getMethod("aref", IRubyObject.class));
         structClass.defineFastMethod("[]=", callbackFactory.getMethod("aset", IRubyObject.class, IRubyObject.class));
 
         structClass.defineFastMethod("members", callbackFactory.getMethod("members"));
 
         return structClass;
     }
 
     private static IRubyObject getInstanceVariable(RubyClass type, String name) {
         RubyClass structClass = type.getRuntime().getClass("Struct");
 
         while (type != null && type != structClass) {
             IRubyObject variable = type.getInstanceVariable(name);
             if (variable != null) {
                 return variable;
             }
 
             type = type.getSuperClass();
         }
 
         return type.getRuntime().getNil();
     }
 
     private RubyClass classOf() {
         return getMetaClass() instanceof MetaClass ? getMetaClass().getSuperClass() : getMetaClass();
     }
 
     private void modify() {
         testFrozen("Struct is frozen");
 
         if (!isTaint() && getRuntime().getSafeLevel() >= 4) {
             throw getRuntime().newSecurityError("Insecure: can't modify struct");
         }
     }
 
     private IRubyObject setByName(String name, IRubyObject value) {
         RubyArray member = (RubyArray) getInstanceVariable(classOf(), "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         modify();
 
         for (int i = 0; i < member.getLength(); i++) {
             if (member.entry(i).asSymbol().equals(name)) {
                 return values[i] = value;
             }
         }
 
         throw notStructMemberError(name);
     }
 
     private IRubyObject getByName(String name) {
         RubyArray member = (RubyArray) getInstanceVariable(classOf(), "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         for (int i = 0; i < member.getLength(); i++) {
             if (member.entry(i).asSymbol().equals(name)) {
                 return values[i];
             }
         }
 
         throw notStructMemberError(name);
     }
 
     // Struct methods
 
     /** Create new Struct class.
      *
      * MRI: rb_struct_s_def / make_struct
      *
      */
     public static RubyClass newInstance(IRubyObject recv, IRubyObject[] args) {
         String name = null;
 
         if (args.length > 0 && args[0] instanceof RubyString) {
             name = args[0].toString();
         }
 
         RubyArray member = recv.getRuntime().newArray();
 
         for (int i = name == null ? 0 : 1; i < args.length; i++) {
             member.append(RubySymbol.newSymbol(recv.getRuntime(), args[i].asSymbol()));
         }
 
         RubyClass newStruct;
         RubyClass superClass = (RubyClass)recv;
 
         if (name == null) {
             newStruct = new RubyClass(superClass, superClass.getAllocator());
         } else {
             if (!IdUtil.isConstant(name)) {
                 throw recv.getRuntime().newNameError("identifier " + name + " needs to be constant", name);
             }
-            newStruct = ((RubyClass) recv).defineClassUnder(name, (RubyClass) recv);
+            newStruct = superClass.defineClassUnder(name, superClass, superClass.getAllocator());
         }
 
         newStruct.setInstanceVariable("__size__", member.length());
         newStruct.setInstanceVariable("__member__", member);
 
         CallbackFactory callbackFactory = recv.getRuntime().callbackFactory(RubyStruct.class);
         newStruct.defineSingletonMethod("new", callbackFactory.getOptSingletonMethod("newStruct"));
         newStruct.defineSingletonMethod("[]", callbackFactory.getOptSingletonMethod("newStruct"));
         newStruct.defineSingletonMethod("members", callbackFactory.getSingletonMethod("members"));
 
         // define access methods.
         for (int i = name == null ? 0 : 1; i < args.length; i++) {
             String memberName = args[i].asSymbol();
             newStruct.defineMethod(memberName, callbackFactory.getMethod("get"));
             newStruct.defineMethod(memberName + "=", callbackFactory.getMethod("set", IRubyObject.class));
         }
         
         ThreadContext context = recv.getRuntime().getCurrentContext();
         if (context.isBlockGiven()) {
             context.getFrameBlock().yield(context, null, newStruct, newStruct, false);
         }
 
         return newStruct;
     }
 
     /** Create new Structure.
      *
      * MRI: struct_alloc
      *
      */
     public static RubyStruct newStruct(IRubyObject recv, IRubyObject[] args) {
         RubyStruct struct = new RubyStruct(recv.getRuntime(), (RubyClass) recv);
 
         int size = RubyNumeric.fix2int(getInstanceVariable((RubyClass) recv, "__size__"));
 
         struct.values = new IRubyObject[size];
 
         struct.callInit(args);
 
         return struct;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         modify();
 
         int size = RubyNumeric.fix2int(getInstanceVariable(getMetaClass(), "__size__"));
 
         if (args.length > size) {
             throw getRuntime().newArgumentError("struct size differs (" + args.length +" for " + size + ")");
         }
 
         for (int i = 0; i < args.length; i++) {
             values[i] = args[i];
         }
 
         for (int i = args.length; i < size; i++) {
             values[i] = getRuntime().getNil();
         }
 
         return getRuntime().getNil();
     }
 
     public static RubyArray members(IRubyObject recv) {
         RubyArray member = (RubyArray) getInstanceVariable((RubyClass) recv, "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         RubyArray result = recv.getRuntime().newArray(member.getLength());
         for (int i = 0; i < member.getLength(); i++) {
             result.append(recv.getRuntime().newString(member.entry(i).asSymbol()));
         }
 
         return result;
     }
 
     public RubyArray members() {
         return members(classOf());
     }
 
     public IRubyObject set(IRubyObject value) {
         String name = getRuntime().getCurrentContext().getFrameLastFunc();
         if (name.endsWith("=")) {
             name = name.substring(0, name.length() - 1);
         }
 
         RubyArray member = (RubyArray) getInstanceVariable(classOf(), "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         modify();
 
         for (int i = 0; i < member.getLength(); i++) {
             if (member.entry(i).asSymbol().equals(name)) {
                 return values[i] = value;
             }
         }
 
         throw notStructMemberError(name);
     }
 
     private RaiseException notStructMemberError(String name) {
         return getRuntime().newNameError(name + " is not struct member", name);
     }
 
     public IRubyObject get() {
         String name = getRuntime().getCurrentContext().getFrameLastFunc();
 
         RubyArray member = (RubyArray) getInstanceVariable(classOf(), "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         for (int i = 0; i < member.getLength(); i++) {
             if (member.entry(i).asSymbol().equals(name)) {
                 return values[i];
             }
         }
 
         throw notStructMemberError(name);
     }
 
     public IRubyObject rbClone() {
         RubyStruct clone = new RubyStruct(getRuntime(), getMetaClass());
 
         clone.values = new IRubyObject[values.length];
         System.arraycopy(values, 0, clone.values, 0, values.length);
 
         clone.setFrozen(this.isFrozen());
         clone.setTaint(this.isTaint());
 
         return clone;
     }
 
     public IRubyObject equal(IRubyObject other) {
         if (this == other) {
             return getRuntime().getTrue();
         } else if (!(other instanceof RubyStruct)) {
             return getRuntime().getFalse();
         } else if (getMetaClass() != other.getMetaClass()) {
             return getRuntime().getFalse();
         } else {
             for (int i = 0; i < values.length; i++) {
                 if (!values[i].equals(((RubyStruct) other).values[i])) {
                     return getRuntime().getFalse();
                 }
             }
             return getRuntime().getTrue();
         }
     }
 
     public IRubyObject to_s() {
         return inspect();
     }
 
     public IRubyObject inspect() {
         RubyArray member = (RubyArray) getInstanceVariable(classOf(), "__member__");
 
         assert !member.isNil() : "uninitialized struct";
 
         StringBuffer sb = new StringBuffer(100);
 
         sb.append("#<struct ").append(getMetaClass().getName()).append(' ');
 
         for (int i = 0; i < member.getLength(); i++) {
             if (i > 0) {
                 sb.append(", ");
             }
 
             sb.append(member.entry(i).asSymbol()).append("=");
             sb.append(values[i].callMethod(getRuntime().getCurrentContext(), "inspect"));
         }
 
         sb.append('>');
 
         return getRuntime().newString(sb.toString()); // OBJ_INFECT
     }
 
     public RubyArray to_a() {
         return getRuntime().newArray(values);
     }
 
     public RubyFixnum size() {
         return getRuntime().newFixnum(values.length);
     }
 
     public IRubyObject each() {
         ThreadContext context = getRuntime().getCurrentContext();
         for (int i = 0; i < values.length; i++) {
             context.yield(values[i]);
         }
 
         return this;
     }
 
     public IRubyObject aref(IRubyObject key) {
         if (key instanceof RubyString || key instanceof RubySymbol) {
             return getByName(key.asSymbol());
         }
 
         int idx = RubyNumeric.fix2int(key);
 
         idx = idx < 0 ? values.length + idx : idx;
 
         if (idx < 0) {
             throw getRuntime().newIndexError("offset " + idx + " too large for struct (size:" + values.length + ")");
         } else if (idx >= values.length) {
             throw getRuntime().newIndexError("offset " + idx + " too large for struct (size:" + values.length + ")");
         }
 
         return values[idx];
     }
 
     public IRubyObject aset(IRubyObject key, IRubyObject value) {
         if (key instanceof RubyString || key instanceof RubySymbol) {
             return setByName(key.asSymbol(), value);
         }
 
         int idx = RubyNumeric.fix2int(key);
 
         idx = idx < 0 ? values.length + idx : idx;
 
         if (idx < 0) {
             throw getRuntime().newIndexError("offset " + idx + " too large for struct (size:" + values.length + ")");
         } else if (idx >= values.length) {
             throw getRuntime().newIndexError("offset " + idx + " too large for struct (size:" + values.length + ")");
         }
 
         modify();
         return values[idx] = value;
     }
 
     public void marshalTo(MarshalStream output) throws java.io.IOException {
         output.write('S');
 
         String className = getMetaClass().getName();
         if (className == null) {
             throw getRuntime().newArgumentError("can't dump anonymous class");
         }
         output.dumpObject(RubySymbol.newSymbol(getRuntime(), className));
 
         List members = ((RubyArray) getInstanceVariable(classOf(), "__member__")).getList();
         output.dumpInt(members.size());
 
         for (int i = 0; i < members.size(); i++) {
             RubySymbol name = (RubySymbol) members.get(i);
             output.dumpObject(name);
             output.dumpObject(values[i]);
         }
     }
 
     public static RubyStruct unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
         IRuby runtime = input.getRuntime();
 
         RubySymbol className = (RubySymbol) input.unmarshalObject();
         RubyClass rbClass = pathToClass(runtime, className.asSymbol());
         if (rbClass == null) {
             throw runtime.newNameError("uninitialized constant " + className, className.asSymbol());
         }
 
         int size = input.unmarshalInt();
 
         IRubyObject[] values = new IRubyObject[size];
         for (int i = 0; i < size; i++) {
             input.unmarshalObject(); // Read and discard a Symbol, which is the name
             values[i] = input.unmarshalObject();
         }
 
         RubyStruct result = newStruct(rbClass, values);
         input.registerLinkTarget(result);
         return result;
     }
 
     private static RubyClass pathToClass(IRuby runtime, String path) {
         // FIXME: Throw the right ArgumentError's if the class is missing
         // or if it's a module.
         return (RubyClass) runtime.getClassFromPath(path);
     }
 }
diff --git a/src/org/jruby/RubyThread.java b/src/org/jruby/RubyThread.java
index a2c4301946..dc4af6a3c8 100644
--- a/src/org/jruby/RubyThread.java
+++ b/src/org/jruby/RubyThread.java
@@ -1,631 +1,635 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002 Jason Voegele <jason@jvoegele.com>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004-2005 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jruby.exceptions.RaiseException;
 import org.jruby.exceptions.ThreadKill;
 import org.jruby.internal.runtime.NativeThread;
 import org.jruby.internal.runtime.ThreadService;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * Implementation of Ruby's <code>Thread</code> class.  Each Ruby thread is
  * mapped to an underlying Java Virtual Machine thread.
  * <p>
  * Thread encapsulates the behavior of a thread of execution, including the main
  * thread of the Ruby script.  In the descriptions that follow, the parameter
  * <code>aSymbol</code> refers to a symbol, which is either a quoted string or a
  * <code>Symbol</code> (such as <code>:name</code>).
  * 
  * Note: For CVS history, see ThreadClass.java.
  *
  * @author Jason Voegele (jason@jvoegele.com)
  */
 public class RubyThread extends RubyObject {
     private NativeThread threadImpl;
     private Map threadLocalVariables = new HashMap();
     private boolean abortOnException;
     private RaiseException exitingException;
     private IRubyObject receivedException;
     private RubyThreadGroup threadGroup;
 
     private ThreadService threadService;
     private Object hasStartedLock = new Object();
     private boolean hasStarted = false;
     private volatile boolean isStopped = false;
     public Object stopLock = new Object();
     
     private volatile boolean killed = false;
     public Object killLock = new Object();
     private RubyThread joinedByCriticalThread;
     
     public static RubyClass createThreadClass(IRuby runtime) {
-        RubyClass threadClass = runtime.defineClass("Thread", runtime.getObject());
+        // FIXME: In order for Thread to play well with the standard 'new' behavior,
+        // it must provide an allocator that can create empty object instances which
+        // initialize then fills with appropriate data.
+        RubyClass threadClass = runtime.defineClass("Thread", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyThread.class);
 
         threadClass.defineFastMethod("[]", 
                 callbackFactory.getMethod("aref", IRubyObject.class));
         threadClass.defineFastMethod("[]=", 
                 callbackFactory.getMethod("aset", IRubyObject.class, IRubyObject.class));
         threadClass.defineFastMethod("abort_on_exception", 
                 callbackFactory.getMethod("abort_on_exception"));
         threadClass.defineFastMethod("abort_on_exception=", 
                 callbackFactory.getMethod("abort_on_exception_set", IRubyObject.class));
         threadClass.defineFastMethod("alive?", 
                 callbackFactory.getMethod("is_alive"));
         threadClass.defineFastMethod("group", 
                 callbackFactory.getMethod("group"));
         threadClass.defineFastMethod("join", 
                 callbackFactory.getOptMethod("join"));
         threadClass.defineFastMethod("key?", 
                 callbackFactory.getMethod("has_key", IRubyObject.class));
         threadClass.defineFastMethod("priority", 
                 callbackFactory.getMethod("priority"));
         threadClass.defineFastMethod("priority=", 
                 callbackFactory.getMethod("priority_set", IRubyObject.class));
         threadClass.defineFastMethod("raise", 
                 callbackFactory.getMethod("raise", IRubyObject.class));
         threadClass.defineFastMethod("run",
         		callbackFactory.getMethod("run"));
         threadClass.defineFastMethod("status", 
                 callbackFactory.getMethod("status"));
         threadClass.defineFastMethod("stop?", 
                 callbackFactory.getMethod("isStopped"));
         threadClass.defineFastMethod("wakeup", 
                 callbackFactory.getMethod("wakeup"));
         //        threadClass.defineMethod("value", 
         //                callbackFactory.getMethod("value"));
         threadClass.defineFastMethod("kill", 
                 callbackFactory.getMethod("kill"));
         threadClass.defineMethod("exit",
         		callbackFactory.getMethod("exit"));
         
         threadClass.defineFastSingletonMethod("current",
                 callbackFactory.getSingletonMethod("current"));
         threadClass.defineSingletonMethod("fork",
                 callbackFactory.getOptSingletonMethod("newInstance"));
         threadClass.defineSingletonMethod("new",
                 callbackFactory.getOptSingletonMethod("newInstance"));
         threadClass.defineFastSingletonMethod("list",
                 callbackFactory.getSingletonMethod("list"));
         threadClass.defineFastSingletonMethod("pass",
                 callbackFactory.getSingletonMethod("pass"));
         threadClass.defineSingletonMethod("start",
                 callbackFactory.getOptSingletonMethod("start"));
         threadClass.defineFastSingletonMethod("critical=", 
                 callbackFactory.getSingletonMethod("critical_set", RubyBoolean.class));
         threadClass.defineFastSingletonMethod("critical", 
                 callbackFactory.getSingletonMethod("critical"));
         threadClass.defineFastSingletonMethod("stop", 
                 callbackFactory.getSingletonMethod("stop"));
         threadClass.defineSingletonMethod("kill", 
                 callbackFactory.getSingletonMethod("s_kill", RubyThread.class));
         threadClass.defineSingletonMethod("exit", 
                 callbackFactory.getSingletonMethod("s_exit"));
         threadClass.defineFastSingletonMethod("abort_on_exception",
                 callbackFactory.getSingletonMethod("abort_on_exception"));
         threadClass.defineFastSingletonMethod("abort_on_exception=",
                 callbackFactory.getSingletonMethod("abort_on_exception_set", IRubyObject.class));
 
         RubyThread rubyThread = new RubyThread(runtime, threadClass);
         // set hasStarted to true, otherwise Thread.main.status freezes
         rubyThread.hasStarted = true;
         // TODO: need to isolate the "current" thread from class creation
         rubyThread.threadImpl = new NativeThread(rubyThread, Thread.currentThread());
         runtime.getThreadService().setMainThread(rubyThread);
         
         threadClass.defineFastSingletonMethod("main",
         		callbackFactory.getSingletonMethod("main"));
         
         return threadClass;
     }
 
     /**
      * <code>Thread.new</code>
      * <p>
      * Thread.new( <i>[ arg ]*</i> ) {| args | block } -> aThread
      * <p>
      * Creates a new thread to execute the instructions given in block, and
      * begins running it. Any arguments passed to Thread.new are passed into the
      * block.
      * <pre>
      * x = Thread.new { sleep .1; print "x"; print "y"; print "z" }
      * a = Thread.new { print "a"; print "b"; sleep .2; print "c" }
      * x.join # Let the threads finish before
      * a.join # main thread exits...
      * </pre>
      * <i>produces:</i> abxyzc
      */
     public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
         return startThread(recv, args, true);
     }
 
     /**
      * Basically the same as Thread.new . However, if class Thread is
      * subclassed, then calling start in that subclass will not invoke the
      * subclass's initialize method.
      */
     public static RubyThread start(IRubyObject recv, IRubyObject[] args) {
         return startThread(recv, args, false);
     }
     
     public static RubyThread adopt(IRubyObject recv, Thread t) {
         return adoptThread(recv, t);
     }
 
     private static RubyThread adoptThread(final IRubyObject recv, Thread t) {
         final IRuby runtime = recv.getRuntime();
         final RubyThread rubyThread = new RubyThread(runtime, (RubyClass) recv, false);
         
         rubyThread.threadImpl = new NativeThread(rubyThread, t);
         runtime.getThreadService().registerNewThread(rubyThread);
         
         runtime.getCurrentContext().preAdoptThread();
         
         rubyThread.callInit(new IRubyObject[0]);
         
         rubyThread.notifyStarted();
         
         return rubyThread;
     }
 
     private static RubyThread startThread(final IRubyObject recv, final IRubyObject[] args, boolean callInit) {
         final IRuby runtime = recv.getRuntime();
         if (!runtime.getCurrentContext().isBlockGiven()) {
             throw runtime.newThreadError("must be called with a block");
         }
         final RubyThread rubyThread = new RubyThread(runtime, (RubyClass) recv);
         if (callInit) {
             rubyThread.callInit(args);
         }
 
         rubyThread.threadImpl = new NativeThread(rubyThread, args);
         rubyThread.threadImpl.start();
         
         // make sure the thread has started before continuing, so it will appear "runnable" to the rest of Ruby
         rubyThread.ensureStarted();
         
         return rubyThread;
     }
     
     public void cleanTerminate() {
     	try {
     		isStopped = true;
     		waitIfCriticalized();
     	} catch (InterruptedException ie) {
     		// ignore
     	}
     }
 	
 	public void waitIfCriticalized() throws InterruptedException {
         RubyThread criticalThread = getRuntime().getThreadService().getCriticalThread();
 		if (criticalThread != null && criticalThread != this && criticalThread != joinedByCriticalThread) {
 			synchronized (criticalThread) {
                 criticalThread.wait();
 			}
 		}
 	}
     
     public void notifyStarted() {
         assert isCurrent();
         synchronized (hasStartedLock) {
             hasStarted = true;
             hasStartedLock.notifyAll();
         }
     }
 
     public void pollThreadEvents() {
         // Asserts.isTrue(isCurrent());
         pollReceivedExceptions();
         
         // TODO: should exceptions trump thread control, or vice versa?
         criticalizeOrDieIfKilled();
     }
 
     private void pollReceivedExceptions() {
         if (receivedException != null) {
             // clear this so we don't keep re-throwing
             IRubyObject raiseException = receivedException;
             receivedException = null;
             RubyModule kernelModule = getRuntime().getModule("Kernel");
             kernelModule.callMethod(getRuntime().getCurrentContext(), "raise", raiseException);
         }
     }
 
     public void criticalizeOrDieIfKilled() {
     	try {
     		waitIfCriticalized();
     	} catch (InterruptedException ie) {
     		throw new ThreadKill();
     	}
     	dieIfKilled();
     }
 
     private RubyThread(IRuby runtime, RubyClass type) {
         super(runtime, type);
         this.threadService = runtime.getThreadService();
         // set to default thread group
         RubyThreadGroup defaultThreadGroup = (RubyThreadGroup)runtime.getClass("ThreadGroup").getConstant("Default");
         defaultThreadGroup.add(this);
         
     }
 
     private RubyThread(IRuby runtime, RubyClass type, boolean narf) {
         super(runtime, type);
         this.threadService = runtime.getThreadService();
         
         // set to default thread group
         RubyThreadGroup defaultThreadGroup = (RubyThreadGroup)runtime.getClass("ThreadGroup").getConstant("Default");
         defaultThreadGroup.add(this);
     }
 
     /**
      * Returns the status of the global ``abort on exception'' condition. The
      * default is false. When set to true, will cause all threads to abort (the
      * process will exit(0)) if an exception is raised in any thread. See also
      * Thread.abort_on_exception= .
      */
     public static RubyBoolean abort_on_exception(IRubyObject recv) {
     	IRuby runtime = recv.getRuntime();
         return runtime.isGlobalAbortOnExceptionEnabled() ? recv.getRuntime().getTrue() : recv.getRuntime().getFalse();
     }
 
     public static IRubyObject abort_on_exception_set(IRubyObject recv, IRubyObject value) {
         recv.getRuntime().setGlobalAbortOnExceptionEnabled(value.isTrue());
         return value;
     }
 
     public static RubyThread current(IRubyObject recv) {
         return recv.getRuntime().getCurrentContext().getThread();
     }
 
     public static RubyThread main(IRubyObject recv) {
         return recv.getRuntime().getThreadService().getMainThread();
     }
 
     public static IRubyObject pass(IRubyObject recv) {
         IRuby runtime = recv.getRuntime();
         ThreadService ts = runtime.getThreadService();
         RubyThread criticalThread = ts.getCriticalThread();
         RubyThread currentThread = ts.getCurrentContext().getThread();
         
         if (criticalThread == currentThread) {
             // we're currently the critical thread; decriticalize for pass
             ts.setCritical(false);
         }
         
         Thread.yield();
         
         if (criticalThread != null) {
             // recriticalize
             ts.setCritical(true);
         }
         
         return recv.getRuntime().getNil();
     }
 
     public static RubyArray list(IRubyObject recv) {
     	RubyThread[] activeThreads = recv.getRuntime().getThreadService().getActiveRubyThreads();
         
         return recv.getRuntime().newArray(activeThreads);
     }
 
     public IRubyObject aref(IRubyObject key) {
         String name = keyName(key);
         if (!threadLocalVariables.containsKey(name)) {
             return getRuntime().getNil();
         }
         return (IRubyObject) threadLocalVariables.get(name);
     }
 
     public IRubyObject aset(IRubyObject key, IRubyObject value) {
         String name = keyName(key);
         threadLocalVariables.put(name, value);
         return value;
     }
 
     private String keyName(IRubyObject key) {
         String name;
         if (key instanceof RubySymbol) {
             name = key.asSymbol();
         } else if (key instanceof RubyString) {
             name = ((RubyString) key).toString();
         } else {
             throw getRuntime().newArgumentError(key.inspect() + " is not a symbol");
         }
         return name;
     }
 
     public RubyBoolean abort_on_exception() {
         return abortOnException ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject abort_on_exception_set(IRubyObject val) {
         abortOnException = val.isTrue();
         return val;
     }
 
     public RubyBoolean is_alive() {
         return threadImpl.isAlive() ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public RubyThread join(IRubyObject[] args) {
         if (isCurrent()) {
             throw getRuntime().newThreadError("thread tried to join itself");
         }
         ensureStarted();
         try {
             RubyThread criticalThread = getRuntime().getThreadService().getCriticalThread();
             if (criticalThread != null) {
                 // set the target thread's joinedBy, so it knows it can execute during a critical section
                 joinedByCriticalThread = criticalThread;
                 threadImpl.interrupt(); // break target thread out of critical
             }
             threadImpl.join();
         } catch (InterruptedException iExcptn) {
             assert false : iExcptn;
         }
         if (exitingException != null) {
             throw exitingException;
         }
         return this;
     }
 
     public IRubyObject group() {
         if (threadGroup == null) {
         	return getRuntime().getNil();
         }
         
         return threadGroup;
     }
     
     void setThreadGroup(RubyThreadGroup rubyThreadGroup) {
     	threadGroup = rubyThreadGroup;
     }
 
     public RubyBoolean has_key(IRubyObject key) {
         String name = keyName(key);
         return getRuntime().newBoolean(threadLocalVariables.containsKey(name));
     }
     
     public static IRubyObject critical_set(IRubyObject receiver, RubyBoolean value) {
     	receiver.getRuntime().getThreadService().setCritical(value.isTrue());
     	
     	return value;
     }
 
     public static IRubyObject critical(IRubyObject receiver) {
     	return receiver.getRuntime().newBoolean(receiver.getRuntime().getThreadService().getCriticalThread() != null);
     }
 
     public static IRubyObject stop(IRubyObject receiver) {
     	RubyThread rubyThread = receiver.getRuntime().getThreadService().getCurrentContext().getThread();
     	Object stopLock = rubyThread.stopLock;
     	
     	synchronized (stopLock) {
     		try {
     			rubyThread.isStopped = true;
     			// attempt to decriticalize all if we're the critical thread
     			receiver.getRuntime().getThreadService().setCritical(false);
 
     			stopLock.wait();
     		} catch (InterruptedException ie) {
     			// ignore, continue;
     		}
     		rubyThread.isStopped = false;
     	}
     	
     	return receiver.getRuntime().getNil();
     }
     
     public static IRubyObject s_kill(IRubyObject receiver, RubyThread rubyThread) {
     	return rubyThread.kill();
     }
 
     public static IRubyObject s_exit(IRubyObject receiver) {
     	RubyThread rubyThread = receiver.getRuntime().getThreadService().getCurrentContext().getThread();
     	
 		rubyThread.killed = true;
 		// attempt to decriticalize all if we're the critical thread
 		receiver.getRuntime().getThreadService().setCritical(false);
 		
 		throw new ThreadKill();
     }
 
     public RubyBoolean isStopped() {
     	// not valid for "dead" state
     	return getRuntime().newBoolean(isStopped);
     }
     
     public RubyThread wakeup() {
     	synchronized (stopLock) {
     		stopLock.notifyAll();
     	}
     	
     	return this;
     }
     
     public RubyFixnum priority() {
         return getRuntime().newFixnum(threadImpl.getPriority());
     }
 
     public IRubyObject priority_set(IRubyObject priority) {
         // FIXME: This should probably do some translation from Ruby priority levels to Java priority levels (until we have green threads)
         int iPriority = RubyNumeric.fix2int(priority);
         
         if (iPriority < Thread.MIN_PRIORITY) {
             iPriority = Thread.MIN_PRIORITY;
         } else if (iPriority > Thread.MAX_PRIORITY) {
             iPriority = Thread.MAX_PRIORITY;
         }
         
         threadImpl.setPriority(iPriority);
         return priority;
     }
 
     public IRubyObject raise(IRubyObject exc) {
         receivedException = exc;
 
         // FIXME: correct raise call
 
         // FIXME: call the IRaiseListener#exceptionRaised method
 
         return this;
     }
     
     public IRubyObject run() {
     	// if stopped, unstop
     	if (isStopped) {
     		synchronized (stopLock) {
     			isStopped = false;
     			stopLock.notifyAll();
     		}
     	}
     	
     	// Abort any sleep()s
     	// CON: Sleep now waits on the same stoplock, so it will have been woken up by the notify above
     	//threadImpl.interrupt();
     	
     	return this;
     }
     
     public void sleep(long millis) throws InterruptedException {
     	try {
 	    	synchronized (stopLock) {
 	    		isStopped = true;
 	    		stopLock.wait(millis);
 	    	}
     	} finally {
     		isStopped = false;
     	}
     }
 
     public IRubyObject status() {
         if (threadImpl.isAlive()) {
         	if (isStopped) {
             	return getRuntime().newString("sleep");
             } else if (killed) {
                 return getRuntime().newString("aborting");
             }
         	
             return getRuntime().newString("run");
         } else if (exitingException != null) {
             return getRuntime().getNil();
         } else {
             return getRuntime().newBoolean(false);
         }
     }
 
     public IRubyObject kill() {
     	// need to reexamine this
     	synchronized (this) {
     		if (killed) return this;
     		
     		killed = true;
             
     		threadImpl.interrupt(); // break out of wait states and blocking IO
     		try {
     			if (!threadImpl.isInterrupted()) {
                     // we did not interrupt the thread, so wait for it to complete
                     // TODO: test that this is correct...should killer wait for killee to die?
                     threadImpl.join();
     			}
     		} catch (InterruptedException ie) {
     			throw new ThreadKill();
     		}
     	}
 
     	return this;
     }
     
     public IRubyObject exit() {
     	return kill();
     }
     
     public void dieIfKilled() {
     	if (killed) throw new ThreadKill();
     }
 
     private boolean isCurrent() {
         return threadImpl.isCurrent();
     }
 
     private void ensureStarted() {
         // The JVM's join() method may return immediately
         // and isAlive() give the wrong result if the thread
         // hasn't started yet. We give it a chance to start
         // before we try to do anything.
 
 
         // Yes, I know double-check locking is broken.
         if (!hasStarted) {
             synchronized (hasStartedLock) {
                 if (!hasStarted) {
                     try {
                         hasStartedLock.wait();
                     } catch (InterruptedException iExcptn) {
                         assert false : iExcptn;
                     }
                 }
             }
         }
     }
 
     public void exceptionRaised(RaiseException exception) {
         assert isCurrent();
 
         IRuby runtime = exception.getException().getRuntime();
         if (abortOnException(runtime)) {
             // FIXME: printError explodes on some nullpointer
             //getRuntime().getRuntime().printError(exception.getException());
         	// TODO: Doesn't SystemExit have its own method to make this less wordy..
             RubyException re = RubyException.newException(getRuntime(), getRuntime().getClass("SystemExit"), exception.getMessage());
             re.setInstanceVariable("status", getRuntime().newFixnum(1));
             threadService.getMainThread().raise(re);
         } else {
             exitingException = exception;
         }
     }
 
     private boolean abortOnException(IRuby runtime) {
         return (runtime.isGlobalAbortOnExceptionEnabled() || abortOnException);
     }
 
     public static RubyThread mainThread(IRubyObject receiver) {
         return receiver.getRuntime().getThreadService().getMainThread();
     }
 }
diff --git a/src/org/jruby/RubyThreadGroup.java b/src/org/jruby/RubyThreadGroup.java
index 7cc74ac3b8..9d3b1becc5 100644
--- a/src/org/jruby/RubyThreadGroup.java
+++ b/src/org/jruby/RubyThreadGroup.java
@@ -1,114 +1,115 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * Implementation of Ruby's <code>ThreadGroup</code> class. This is currently
  * just a stub.
  * <p>
  *
  * @author Charles O Nutter (headius@headius.com)
  */
 public class RubyThreadGroup extends RubyObject {
     private Map rubyThreadList = new HashMap();
     private boolean enclosed = false;
 
     public static RubyClass createThreadGroupClass(IRuby runtime) {
-        RubyClass threadGroupClass = runtime.defineClass("ThreadGroup", runtime.getObject());
+        RubyClass threadGroupClass = runtime.defineClass("ThreadGroup", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyThreadGroup.class);
         
         threadGroupClass.defineMethod("add",
         		callbackFactory.getMethod("add", RubyThread.class));
         threadGroupClass.defineMethod("enclose",
         		callbackFactory.getMethod("enclose"));
         threadGroupClass.defineMethod("enclosed?",
         		callbackFactory.getMethod("isEnclosed"));
         threadGroupClass.defineMethod("list",
         		callbackFactory.getMethod("list"));
         threadGroupClass.defineSingletonMethod("new",
                 callbackFactory.getSingletonMethod("newInstance"));
         
         // create the default thread group
         RubyThreadGroup defaultThreadGroup = new RubyThreadGroup(runtime, threadGroupClass);
         threadGroupClass.defineConstant("Default", defaultThreadGroup);
 
         return threadGroupClass;
     }
     
     public static IRubyObject newInstance(IRubyObject recv) {
         return new RubyThreadGroup(recv.getRuntime(), (RubyClass)recv);
     }
 
     public IRubyObject add(RubyThread rubyThread) {
     	if (isFrozen()) {
         	throw getRuntime().newTypeError("can't add to frozen ThreadGroup");
     	}
     	
     	if (rubyThread.group() != getRuntime().getNil()) {
     		RubyThreadGroup threadGroup = (RubyThreadGroup)rubyThread.group();
     		threadGroup.rubyThreadList.remove(new Integer(System.identityHashCode(rubyThread)));
     	}
     	
     	rubyThread.setThreadGroup(this);
 		rubyThreadList.put(new Integer(System.identityHashCode(rubyThread)), rubyThread);
 	
 		return this;
     }
     
     public void remove(RubyThread rubyThread) {
     	rubyThread.setThreadGroup(null);
     	rubyThreadList.remove(new Integer(System.identityHashCode(rubyThread)));
     }
     
     public IRubyObject enclose() {
     	enclosed = true;
     	
     	return this;
     }
     
     public IRubyObject isEnclosed() {
     	return new RubyBoolean(getRuntime(), enclosed);
     }
     
     public IRubyObject list() {
     	return getRuntime().newArray((IRubyObject[])rubyThreadList.values().toArray(new IRubyObject[rubyThreadList.size()]));
     }
 
     private RubyThreadGroup(IRuby runtime, RubyClass type) {
         super(runtime, type);
     }
 
 }
diff --git a/src/org/jruby/RubyUnboundMethod.java b/src/org/jruby/RubyUnboundMethod.java
index a149abbeef..0c775d876a 100644
--- a/src/org/jruby/RubyUnboundMethod.java
+++ b/src/org/jruby/RubyUnboundMethod.java
@@ -1,107 +1,109 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2004 Charles O Nutter <headius@headius.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicMethod;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * 
  * Note: This was renamed from UnboundMethod.java
  * 
  * @author jpetersen
  */
 public class RubyUnboundMethod extends RubyMethod {
     protected RubyUnboundMethod(IRuby runtime) {
         super(runtime, runtime.getClass("UnboundMethod"));
     }
 
     public static RubyUnboundMethod newUnboundMethod(
         RubyModule implementationModule,
         String methodName,
         RubyModule originModule,
         String originName,
         DynamicMethod method) {
         RubyUnboundMethod newMethod = new RubyUnboundMethod(implementationModule.getRuntime());
 
         newMethod.implementationModule = implementationModule;
         newMethod.methodName = methodName;
         newMethod.originModule = originModule;
         newMethod.originName = originName;
         newMethod.method = method;
 
         return newMethod;
     }
 
     public static RubyClass defineUnboundMethodClass(IRuby runtime) {
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here. Confirm. JRUBY-415
         RubyClass newClass = 
-        	runtime.defineClass("UnboundMethod", runtime.getClass("Method"));
+        	runtime.defineClass("UnboundMethod", runtime.getClass("Method"), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
 
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyUnboundMethod.class);
         newClass.defineMethod("[]", callbackFactory.getOptMethod("call"));
         newClass.defineMethod("bind", callbackFactory.getMethod("bind", IRubyObject.class));
         newClass.defineMethod("call", callbackFactory.getOptMethod("call"));
         newClass.defineMethod("to_proc", callbackFactory.getMethod("to_proc"));
         newClass.defineMethod("unbind", callbackFactory.getMethod("unbind"));
 
         return newClass;
     }
 
     /**
      * @see org.jruby.RubyMethod#call(IRubyObject[])
      */
     public IRubyObject call(IRubyObject[] args) {
         throw getRuntime().newTypeError("you cannot call unbound method; bind first");
     }
 
     /**
      * @see org.jruby.RubyMethod#unbind()
      */
     public RubyUnboundMethod unbind() {
         return this;
     }
 
     public RubyMethod bind(IRubyObject aReceiver) {
         RubyClass receiverClass = aReceiver.getMetaClass();
         
         if (!aReceiver.isKindOf(originModule)) {
             if (originModule instanceof MetaClass) {
                 throw getRuntime().newTypeError("singleton method called for a different object");
             } else if (receiverClass instanceof MetaClass && receiverClass.getMethods().containsKey(originName)) {
                 throw getRuntime().newTypeError("method `" + originName + "' overridden");
             } else if (
                 !(originModule.isModule() ? aReceiver.isKindOf(originModule) : aReceiver.getType() == originModule)) {
                 // FIX replace type() == ... with isInstanceOf(...)
                 throw getRuntime().newTypeError("bind argument must be an instance of " + originModule.getName());
             }
         }
         return RubyMethod.newMethod(implementationModule, methodName, receiverClass, originName, method, aReceiver);
     }
 }
diff --git a/src/org/jruby/RubyZlib.java b/src/org/jruby/RubyZlib.java
index ae9c107fd1..1d56d7b825 100644
--- a/src/org/jruby/RubyZlib.java
+++ b/src/org/jruby/RubyZlib.java
@@ -1,1041 +1,1060 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby;
 
 import java.io.InputStream;
 import java.io.IOException;
 
 import java.util.List;
 import java.util.ArrayList;
 
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 
 import org.jruby.exceptions.RaiseException;
 
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 import org.jruby.util.IOInputStream;
 import org.jruby.util.IOOutputStream;
 import org.jruby.util.CRC32Ext;
 import org.jruby.util.Adler32Ext;
 import org.jruby.util.ZlibInflate;
 import org.jruby.util.ZlibDeflate;
 
 public class RubyZlib {
     /** Create the Zlib module and add it to the Ruby runtime.
      * 
      */
     public static RubyModule createZlibModule(IRuby runtime) {
         RubyModule result = runtime.defineModule("Zlib");
 
-        RubyClass gzfile = result.defineClassUnder("GzipFile", runtime.getObject());
+        RubyClass gzfile = result.defineClassUnder("GzipFile", runtime.getObject(), RubyGzipFile.GZIPFILE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(RubyGzipFile.class);
         gzfile.defineSingletonMethod("wrap", callbackFactory.getSingletonMethod("wrap", RubyGzipFile.class, IRubyObject.class));
-        gzfile.defineSingletonMethod("new", callbackFactory.getSingletonMethod("newCreate"));
+        gzfile.defineSingletonMethod("new", callbackFactory.getSingletonMethod("newInstance"));
         gzfile.defineMethod("os_code", callbackFactory.getMethod("os_code"));
         gzfile.defineMethod("closed?", callbackFactory.getMethod("closed_p"));
         gzfile.defineMethod("orig_name", callbackFactory.getMethod("orig_name"));
         gzfile.defineMethod("to_io", callbackFactory.getMethod("to_io"));
         gzfile.defineMethod("finish", callbackFactory.getMethod("finish"));
         gzfile.defineMethod("comment", callbackFactory.getMethod("comment"));
         gzfile.defineMethod("crc", callbackFactory.getMethod("crc"));
         gzfile.defineMethod("mtime", callbackFactory.getMethod("mtime"));
         gzfile.defineMethod("sync", callbackFactory.getMethod("sync"));
         gzfile.defineMethod("close", callbackFactory.getMethod("close"));
         gzfile.defineMethod("level", callbackFactory.getMethod("level"));
         gzfile.defineMethod("sync=", callbackFactory.getMethod("set_sync", IRubyObject.class));
         
-        RubyClass gzreader = result.defineClassUnder("GzipReader", gzfile);
+        CallbackFactory classCB = runtime.callbackFactory(RubyClass.class);
+        RubyClass gzreader = result.defineClassUnder("GzipReader", gzfile, RubyGzipReader.GZIPREADER_ALLOCATOR);
         gzreader.includeModule(runtime.getModule("Enumerable"));
         CallbackFactory callbackFactory2 = runtime.callbackFactory(RubyGzipReader.class);
         gzreader.defineSingletonMethod("open", callbackFactory2.getSingletonMethod("open", RubyString.class));
-        gzreader.defineSingletonMethod("new", callbackFactory2.getOptSingletonMethod("newCreate"));
+        gzreader.defineSingletonMethod("new", classCB.getOptMethod("newInstance"));
         gzreader.defineMethod("initialize", callbackFactory2.getMethod("initialize", IRubyObject.class));
         gzreader.defineMethod("rewind", callbackFactory2.getMethod("rewind"));
         gzreader.defineMethod("lineno", callbackFactory2.getMethod("lineno"));
         gzreader.defineMethod("readline", callbackFactory2.getMethod("readline"));
         gzreader.defineMethod("read", callbackFactory2.getOptMethod("read"));
         gzreader.defineMethod("lineno=", callbackFactory2.getMethod("set_lineno", RubyNumeric.class));
         gzreader.defineMethod("pos", callbackFactory2.getMethod("pos"));
         gzreader.defineMethod("readchar", callbackFactory2.getMethod("readchar"));
         gzreader.defineMethod("readlines", callbackFactory2.getOptMethod("readlines"));
         gzreader.defineMethod("each_byte", callbackFactory2.getMethod("each_byte"));
         gzreader.defineMethod("getc", callbackFactory2.getMethod("getc"));
         gzreader.defineMethod("eof", callbackFactory2.getMethod("eof"));
         gzreader.defineMethod("ungetc", callbackFactory2.getMethod("ungetc", RubyNumeric.class));
         gzreader.defineMethod("each", callbackFactory2.getOptMethod("each"));
         gzreader.defineMethod("unused", callbackFactory2.getMethod("unused"));
         gzreader.defineMethod("eof?", callbackFactory2.getMethod("eof_p"));
         gzreader.defineMethod("gets", callbackFactory2.getOptMethod("gets"));
         gzreader.defineMethod("tell", callbackFactory2.getMethod("tell"));
         
-        RubyClass zlibError = result.defineClassUnder("Error", runtime.getClass("StandardError"));
-        gzreader.defineClassUnder("Error", zlibError);
+        RubyClass standardError = runtime.getClass("StandardError");
+        RubyClass zlibError = result.defineClassUnder("Error", standardError, standardError.getAllocator());
+        gzreader.defineClassUnder("Error", zlibError, zlibError.getAllocator());
 
-        RubyClass gzwriter = result.defineClassUnder("GzipWriter", gzfile);
+        RubyClass gzwriter = result.defineClassUnder("GzipWriter", gzfile, RubyGzipWriter.GZIPWRITER_ALLOCATOR);
         CallbackFactory callbackFactory3 = runtime.callbackFactory(RubyGzipWriter.class);
         gzwriter.defineSingletonMethod("open", callbackFactory3.getOptSingletonMethod("open"));
-        gzwriter.defineSingletonMethod("new", callbackFactory3.getOptSingletonMethod("newCreate"));
+        gzwriter.defineSingletonMethod("new", classCB.getOptMethod("newInstance"));
         gzwriter.defineMethod("initialize", callbackFactory3.getOptMethod("initialize2"));
         gzwriter.defineMethod("<<", callbackFactory3.getMethod("append", IRubyObject.class));
         gzwriter.defineMethod("printf", callbackFactory3.getOptMethod("printf"));
         gzwriter.defineMethod("pos", callbackFactory3.getMethod("pos"));
         gzwriter.defineMethod("orig_name=", callbackFactory3.getMethod("set_orig_name", RubyString.class));
         gzwriter.defineMethod("putc", callbackFactory3.getMethod("putc", RubyNumeric.class));
         gzwriter.defineMethod("comment=", callbackFactory3.getMethod("set_comment", RubyString.class));
         gzwriter.defineMethod("puts", callbackFactory3.getOptMethod("puts"));
         gzwriter.defineMethod("flush", callbackFactory3.getOptMethod("flush"));
         gzwriter.defineMethod("mtime=", callbackFactory3.getMethod("set_mtime", IRubyObject.class));
         gzwriter.defineMethod("tell", callbackFactory3.getMethod("tell"));
         gzwriter.defineMethod("write", callbackFactory3.getMethod("write", IRubyObject.class));
 
         result.defineConstant("ZLIB_VERSION",runtime.newString("1.2.1"));
         result.defineConstant("VERSION",runtime.newString("0.6.0"));
 
         result.defineConstant("BINARY",runtime.newFixnum(0));
         result.defineConstant("ASCII",runtime.newFixnum(1));
         result.defineConstant("UNKNOWN",runtime.newFixnum(2));
 
         result.defineConstant("DEF_MEM_LEVEL",runtime.newFixnum(8));
         result.defineConstant("MAX_MEM_LEVEL",runtime.newFixnum(9));
 
         result.defineConstant("OS_UNIX",runtime.newFixnum(3));
         result.defineConstant("OS_UNKNOWN",runtime.newFixnum(255));
         result.defineConstant("OS_CODE",runtime.newFixnum(11));
         result.defineConstant("OS_ZSYSTEM",runtime.newFixnum(8));
         result.defineConstant("OS_VMCMS",runtime.newFixnum(4));
         result.defineConstant("OS_VMS",runtime.newFixnum(2));
         result.defineConstant("OS_RISCOS",runtime.newFixnum(13));
         result.defineConstant("OS_MACOS",runtime.newFixnum(7));
         result.defineConstant("OS_OS2",runtime.newFixnum(6));
         result.defineConstant("OS_AMIGA",runtime.newFixnum(1));
         result.defineConstant("OS_QDOS",runtime.newFixnum(12));
         result.defineConstant("OS_WIN32",runtime.newFixnum(11));
         result.defineConstant("OS_ATARI",runtime.newFixnum(5));
         result.defineConstant("OS_MSDOS",runtime.newFixnum(0));
         result.defineConstant("OS_CPM",runtime.newFixnum(9));
         result.defineConstant("OS_TOPS20",runtime.newFixnum(10));
 
         result.defineConstant("DEFAULT_STRATEGY",runtime.newFixnum(0));
         result.defineConstant("FILTERED",runtime.newFixnum(1));
         result.defineConstant("HUFFMAN_ONLY",runtime.newFixnum(2));
 
         result.defineConstant("NO_FLUSH",runtime.newFixnum(0));
         result.defineConstant("SYNC_FLUSH",runtime.newFixnum(2));
         result.defineConstant("FULL_FLUSH",runtime.newFixnum(3));
         result.defineConstant("FINISH",runtime.newFixnum(4));
 
         result.defineConstant("NO_COMPRESSION",runtime.newFixnum(0));
         result.defineConstant("BEST_SPEED",runtime.newFixnum(1));
         result.defineConstant("DEFAULT_COMPRESSION",runtime.newFixnum(-1));
         result.defineConstant("BEST_COMPRESSION",runtime.newFixnum(9));
 
         result.defineConstant("MAX_WBITS",runtime.newFixnum(15));
 
         CallbackFactory cf = runtime.callbackFactory(RubyZlib.class);
         result.defineModuleFunction("zlib_version",cf.getSingletonMethod("zlib_version"));
         result.defineModuleFunction("version",cf.getSingletonMethod("version"));
         result.defineModuleFunction("adler32",cf.getOptSingletonMethod("adler32"));
         result.defineModuleFunction("crc32",cf.getOptSingletonMethod("crc32"));
         result.defineModuleFunction("crc_table",cf.getSingletonMethod("crc_table"));
 
-        result.defineClassUnder("StreamEnd",zlibError);
-        result.defineClassUnder("StreamError",zlibError);
-        result.defineClassUnder("BufError",zlibError);
-        result.defineClassUnder("NeedDict",zlibError);
-        result.defineClassUnder("MemError",zlibError);
-        result.defineClassUnder("VersionError",zlibError);
-        result.defineClassUnder("DataError",zlibError);
-
-        RubyClass gzError = gzfile.defineClassUnder("Error",zlibError);
-        gzfile.defineClassUnder("CRCError",gzError);
-        gzfile.defineClassUnder("NoFooter",gzError);
-        gzfile.defineClassUnder("LengthError",gzError);
-
-        RubyClass zstream = result.defineClassUnder("ZStream", runtime.getObject());
+        result.defineClassUnder("StreamEnd",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("StreamError",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("BufError",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("NeedDict",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("MemError",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("VersionError",zlibError, zlibError.getAllocator());
+        result.defineClassUnder("DataError",zlibError, zlibError.getAllocator());
+
+        RubyClass gzError = gzfile.defineClassUnder("Error",zlibError, zlibError.getAllocator());
+        gzfile.defineClassUnder("CRCError",gzError, gzError.getAllocator());
+        gzfile.defineClassUnder("NoFooter",gzError, gzError.getAllocator());
+        gzfile.defineClassUnder("LengthError",gzError, gzError.getAllocator());
+
+        // ZStream actually *isn't* allocatable
+        RubyClass zstream = result.defineClassUnder("ZStream", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory zstreamcb = runtime.callbackFactory(ZStream.class);
         zstream.defineMethod("initialize",zstreamcb.getMethod("initialize"));
         zstream.defineMethod("flush_next_out",zstreamcb.getMethod("flush_next_out"));
         zstream.defineMethod("total_out",zstreamcb.getMethod("total_out"));
         zstream.defineMethod("stream_end?",zstreamcb.getMethod("stream_end_p"));
         zstream.defineMethod("data_type",zstreamcb.getMethod("data_type"));
         zstream.defineMethod("closed?",zstreamcb.getMethod("closed_p"));
         zstream.defineMethod("ended?",zstreamcb.getMethod("ended_p"));
         zstream.defineMethod("end",zstreamcb.getMethod("end"));
         zstream.defineMethod("reset",zstreamcb.getMethod("reset"));
         zstream.defineMethod("avail_out",zstreamcb.getMethod("avail_out"));
         zstream.defineMethod("avail_out=",zstreamcb.getMethod("set_avail_out",IRubyObject.class));
         zstream.defineMethod("adler",zstreamcb.getMethod("adler"));
         zstream.defineMethod("finish",zstreamcb.getMethod("finish"));
         zstream.defineMethod("avail_in",zstreamcb.getMethod("avail_in"));
         zstream.defineMethod("flush_next_in",zstreamcb.getMethod("flush_next_in"));
         zstream.defineMethod("total_in",zstreamcb.getMethod("total_in"));
         zstream.defineMethod("finished?",zstreamcb.getMethod("finished_p"));
         zstream.defineMethod("close",zstreamcb.getMethod("close"));
+        zstream.undefineMethod("new");
 
-        RubyClass infl = result.defineClassUnder("Inflate", zstream);
+        RubyClass infl = result.defineClassUnder("Inflate", zstream, Inflate.INFLATE_ALLOCATOR);
         CallbackFactory inflcb = runtime.callbackFactory(Inflate.class);
-        infl.defineSingletonMethod("new",inflcb.getOptSingletonMethod("newInstance"));
+        CallbackFactory classcb = runtime.callbackFactory(RubyClass.class);
         infl.defineSingletonMethod("inflate",inflcb.getSingletonMethod("s_inflate",IRubyObject.class));
         infl.defineMethod("initialize",inflcb.getOptMethod("_initialize"));
         infl.defineMethod("<<",inflcb.getMethod("append",IRubyObject.class));
         infl.defineMethod("sync_point?",inflcb.getMethod("sync_point_p"));
         infl.defineMethod("set_dictionary",inflcb.getMethod("set_dictionary",IRubyObject.class));
         infl.defineMethod("inflate",inflcb.getMethod("inflate",IRubyObject.class));
         infl.defineMethod("sync",inflcb.getMethod("sync",IRubyObject.class));
 
-        RubyClass defl = result.defineClassUnder("Deflate", zstream);
+        RubyClass defl = result.defineClassUnder("Deflate", zstream, Deflate.DEFLATE_ALLOCATOR);
         CallbackFactory deflcb = runtime.callbackFactory(Deflate.class);
-        defl.defineSingletonMethod("new",deflcb.getOptSingletonMethod("newInstance"));
         defl.defineSingletonMethod("deflate",deflcb.getOptSingletonMethod("s_deflate"));
         defl.defineMethod("initialize",deflcb.getOptMethod("_initialize"));
         defl.defineMethod("<<",deflcb.getMethod("append",IRubyObject.class));
         defl.defineMethod("params",deflcb.getMethod("params",IRubyObject.class,IRubyObject.class));
         defl.defineMethod("set_dictionary",deflcb.getMethod("set_dictionary",IRubyObject.class));
         defl.defineMethod("flush",deflcb.getOptMethod("flush"));
         defl.defineMethod("deflate",deflcb.getOptMethod("deflate"));
 
         runtime.getModule("Kernel").callMethod(runtime.getCurrentContext(),"require",runtime.newString("stringio"));
 
         return result;
     }
 
     public static IRubyObject zlib_version(IRubyObject recv) {
         return ((RubyModule)recv).getConstant("ZLIB_VERSION");
     }
 
     public static IRubyObject version(IRubyObject recv) {
         return ((RubyModule)recv).getConstant("VERSION");
     }
 
     public static IRubyObject crc32(IRubyObject recv, IRubyObject[] args) throws Exception {
         args = recv.scanArgs(args,0,2);
         int crc = 0;
         String str = null;
         if(!args[0].isNil()) {
             str = args[0].toString();
         }
         if(!args[1].isNil()) {
             crc = RubyNumeric.fix2int(args[1]);
         }
         CRC32Ext ext = new CRC32Ext(crc);
         if(str != null) {
             ext.update(str.getBytes("PLAIN"));
         }
         return recv.getRuntime().newFixnum(ext.getValue());
     }
 
     public static IRubyObject adler32(IRubyObject recv, IRubyObject[] args) throws Exception {
         args = recv.scanArgs(args,0,2);
         int adler = 1;
         String str = null;
         if(!args[0].isNil()) {
             str = args[0].toString();
         }
         if(!args[1].isNil()) {
             adler = RubyNumeric.fix2int(args[1]);
         }
         Adler32Ext ext = new Adler32Ext(adler);
         if(str != null) {
             ext.update(str.getBytes("PLAIN"));
         }
         return recv.getRuntime().newFixnum(ext.getValue());
     }
 
     private final static long[] crctab = new long[]{
         0L, 1996959894L, 3993919788L, 2567524794L, 124634137L, 1886057615L, 3915621685L, 2657392035L, 249268274L, 2044508324L, 3772115230L, 2547177864L, 162941995L, 
         2125561021L, 3887607047L, 2428444049L, 498536548L, 1789927666L, 4089016648L, 2227061214L, 450548861L, 1843258603L, 4107580753L, 2211677639L, 325883990L, 
         1684777152L, 4251122042L, 2321926636L, 335633487L, 1661365465L, 4195302755L, 2366115317L, 997073096L, 1281953886L, 3579855332L, 2724688242L, 1006888145L, 
         1258607687L, 3524101629L, 2768942443L, 901097722L, 1119000684L, 3686517206L, 2898065728L, 853044451L, 1172266101L, 3705015759L, 2882616665L, 651767980L, 
         1373503546L, 3369554304L, 3218104598L, 565507253L, 1454621731L, 3485111705L, 3099436303L, 671266974L, 1594198024L, 3322730930L, 2970347812L, 795835527L, 
         1483230225L, 3244367275L, 3060149565L, 1994146192L, 31158534L, 2563907772L, 4023717930L, 1907459465L, 112637215L, 2680153253L, 3904427059L, 2013776290L, 
         251722036L, 2517215374L, 3775830040L, 2137656763L, 141376813L, 2439277719L, 3865271297L, 1802195444L, 476864866L, 2238001368L, 4066508878L, 1812370925L, 
         453092731L, 2181625025L, 4111451223L, 1706088902L, 314042704L, 2344532202L, 4240017532L, 1658658271L, 366619977L, 2362670323L, 4224994405L, 1303535960L, 
         984961486L, 2747007092L, 3569037538L, 1256170817L, 1037604311L, 2765210733L, 3554079995L, 1131014506L, 879679996L, 2909243462L, 3663771856L, 1141124467L, 
         855842277L, 2852801631L, 3708648649L, 1342533948L, 654459306L, 3188396048L, 3373015174L, 1466479909L, 544179635L, 3110523913L, 3462522015L, 1591671054L, 
         702138776L, 2966460450L, 3352799412L, 1504918807L, 783551873L, 3082640443L, 3233442989L, 3988292384L, 2596254646L, 62317068L, 1957810842L, 3939845945L, 
         2647816111L, 81470997L, 1943803523L, 3814918930L, 2489596804L, 225274430L, 2053790376L, 3826175755L, 2466906013L, 167816743L, 2097651377L, 4027552580L, 
         2265490386L, 503444072L, 1762050814L, 4150417245L, 2154129355L, 426522225L, 1852507879L, 4275313526L, 2312317920L, 282753626L, 1742555852L, 4189708143L, 
         2394877945L, 397917763L, 1622183637L, 3604390888L, 2714866558L, 953729732L, 1340076626L, 3518719985L, 2797360999L, 1068828381L, 1219638859L, 3624741850L, 
         2936675148L, 906185462L, 1090812512L, 3747672003L, 2825379669L, 829329135L, 1181335161L, 3412177804L, 3160834842L, 628085408L, 1382605366L, 3423369109L, 
         3138078467L, 570562233L, 1426400815L, 3317316542L, 2998733608L, 733239954L, 1555261956L, 3268935591L, 3050360625L, 752459403L, 1541320221L, 2607071920L, 
         3965973030L, 1969922972L, 40735498L, 2617837225L, 3943577151L, 1913087877L, 83908371L, 2512341634L, 3803740692L, 2075208622L, 213261112L, 2463272603L, 
         3855990285L, 2094854071L, 198958881L, 2262029012L, 4057260610L, 1759359992L, 534414190L, 2176718541L, 4139329115L, 1873836001L, 414664567L, 2282248934L, 
         4279200368L, 1711684554L, 285281116L, 2405801727L, 4167216745L, 1634467795L, 376229701L, 2685067896L, 3608007406L, 1308918612L, 956543938L, 2808555105L, 
         3495958263L, 1231636301L, 1047427035L, 2932959818L, 3654703836L, 1088359270L, 936918000L, 2847714899L, 3736837829L, 1202900863L, 817233897L, 3183342108L, 
         3401237130L, 1404277552L, 615818150L, 3134207493L, 3453421203L, 1423857449L, 601450431L, 3009837614L, 3294710456L, 1567103746L, 711928724L, 3020668471L, 
         3272380065L, 1510334235L, 755167117};
 
     public static IRubyObject crc_table(IRubyObject recv) {
         List ll = new ArrayList(crctab.length);
         for(int i=0;i<crctab.length;i++) {
             ll.add(recv.getRuntime().newFixnum(crctab[i]));
         }
         return recv.getRuntime().newArray(ll);
     }
 
 
     public static abstract class ZStream extends RubyObject {
         protected boolean closed = false;
         protected boolean ended = false;
         protected boolean finished = false;
 
         protected abstract int internalTotalOut();
         protected abstract boolean internalStreamEndP();
         protected abstract void internalEnd();
         protected abstract void internalReset();
         protected abstract int internalAdler();
         protected abstract IRubyObject internalFinish() throws Exception;
         protected abstract int internalTotalIn();
         protected abstract void internalClose();
 
         public ZStream(IRuby runtime, RubyClass type) {
             super(runtime, type);
         }
 
         public IRubyObject initialize() {
             return this;
         }
 
         public IRubyObject flush_next_out() {
             return getRuntime().getNil();
         }
 
         public IRubyObject total_out() {
             return getRuntime().newFixnum(internalTotalOut());
         }
 
         public IRubyObject stream_end_p() {
             return internalStreamEndP() ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject data_type() {
             return getRuntime().getModule("Zlib").getConstant("UNKNOWN");
         }
 
         public IRubyObject closed_p() {
             return closed ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject ended_p() {
             return ended ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject end() {
             if(!ended) {
                 internalEnd();
                 ended = true;
             }
             return getRuntime().getNil();
         }
 
         public IRubyObject reset() {
             internalReset();
             return getRuntime().getNil();
         }
 
         public IRubyObject avail_out() {
             return RubyFixnum.zero(getRuntime());
         }
 
         public IRubyObject set_avail_out(IRubyObject p1) {
             return p1;
         }
 
         public IRubyObject adler() {
             return getRuntime().newFixnum(internalAdler());
         }
 
         public IRubyObject finish() throws Exception {
             if(!finished) {
                 finished = true;
                 return internalFinish();
             }
             return getRuntime().newString("");
         }
 
         public IRubyObject avail_in() {
             return RubyFixnum.zero(getRuntime());
         }
 
         public IRubyObject flush_next_in() {
             return getRuntime().getNil();
         }
 
         public IRubyObject total_in() {
             return getRuntime().newFixnum(internalTotalIn());
         }
 
         public IRubyObject finished_p() {
             return finished ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject close() {
             if(!closed) {
                 internalClose();
                 closed = true;
             }
             return getRuntime().getNil();
         }
     }
 
     public static class Inflate extends ZStream {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            IRubyObject result = new Inflate(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
+        protected static ObjectAllocator INFLATE_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new Inflate(runtime, klass);
+            }
+        };
 
         public static IRubyObject s_inflate(IRubyObject recv, IRubyObject string) throws Exception {
             return ZlibInflate.s_inflate(recv,string.toString());
         }
 
         public Inflate(IRuby runtime, RubyClass type) {
             super(runtime, type);
         }
 
         private ZlibInflate infl;
 
         public IRubyObject _initialize(IRubyObject[] args) throws Exception {
             infl = new ZlibInflate(this);
             return this;
         }
 
         public IRubyObject append(IRubyObject arg) {
             infl.append(arg);
             return this;
         }
 
         public IRubyObject sync_point_p() {
             return infl.sync_point();
         }
 
         public IRubyObject set_dictionary(IRubyObject arg) throws Exception {
             return infl.set_dictionary(arg);
         }
 
         public IRubyObject inflate(IRubyObject string) throws Exception {
             return infl.inflate(string.toString());
         }
 
         public IRubyObject sync(IRubyObject string) {
             return infl.sync(string);
         }
 
         protected int internalTotalOut() {
             return infl.getInflater().getTotalOut();
         }
 
         protected boolean internalStreamEndP() {
             return infl.getInflater().finished();
         }
 
         protected void internalEnd() {
             infl.getInflater().end();
         }
 
         protected void internalReset() {
             infl.getInflater().reset();
         }
 
         protected int internalAdler() {
             return infl.getInflater().getAdler();
         }
 
         protected IRubyObject internalFinish() throws Exception {
             infl.finish();
             return getRuntime().getNil();
         }
 
         public IRubyObject finished_p() {
             return infl.getInflater().finished() ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         protected int internalTotalIn() {
             return infl.getInflater().getTotalIn();
         }
 
         protected void internalClose() {
             infl.close();
         }
     }
 
     public static class Deflate extends ZStream {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            IRubyObject result = new Deflate(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
+        protected static ObjectAllocator DEFLATE_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new Deflate(runtime, klass);
+            }
+        };
 
         public static IRubyObject s_deflate(IRubyObject recv, IRubyObject[] args) throws Exception {
             args = recv.scanArgs(args,1,1);
             int level = -1;
             if(!args[1].isNil()) {
                 level = RubyNumeric.fix2int(args[1]);
             }
             return ZlibDeflate.s_deflate(recv,args[0].toString(),level);
         }
 
         public Deflate(IRuby runtime, RubyClass type) {
             super(runtime, type);
         }
 
         private ZlibDeflate defl;
 
         public IRubyObject _initialize(IRubyObject[] args) throws Exception {
             args = scanArgs(args,0,4);
             int level = -1;
             int window_bits = 15;
             int memlevel = 8;
             int strategy = 0;
             if(!args[0].isNil()) {
                 level = RubyNumeric.fix2int(args[0]);
             }
             if(!args[1].isNil()) {
                 window_bits = RubyNumeric.fix2int(args[1]);
             }
             if(!args[2].isNil()) {
                 memlevel = RubyNumeric.fix2int(args[2]);
             }
             if(!args[3].isNil()) {
                 strategy = RubyNumeric.fix2int(args[3]);
             }
             defl = new ZlibDeflate(this,level,window_bits,memlevel,strategy);
             return this;
         }
 
         public IRubyObject append(IRubyObject arg) throws Exception {
             defl.append(arg);
             return this;
         }
 
         public IRubyObject params(IRubyObject level, IRubyObject strategy) {
             defl.params(RubyNumeric.fix2int(level),RubyNumeric.fix2int(strategy));
             return getRuntime().getNil();
         }
 
         public IRubyObject set_dictionary(IRubyObject arg) throws Exception {
             return defl.set_dictionary(arg);
         }
         
         public IRubyObject flush(IRubyObject[] args) throws Exception {
             int flush = 2; // SYNC_FLUSH
             if(checkArgumentCount(args,0,1) == 1) {
                 if(!args[0].isNil()) {
                     flush = RubyNumeric.fix2int(args[0]);
                 }
             }
             return defl.flush(flush);
         }
 
         public IRubyObject deflate(IRubyObject[] args) throws Exception {
             args = scanArgs(args,1,1);
             int flush = 0; // NO_FLUSH
             if(!args[1].isNil()) {
                 flush = RubyNumeric.fix2int(args[1]);
             }
             return defl.deflate(args[0].toString(),flush);
         }
 
         protected int internalTotalOut() {
             return defl.getDeflater().getTotalOut();
         }
 
         protected boolean internalStreamEndP() {
             return defl.getDeflater().finished();
         }
 
         protected void internalEnd() {
             defl.getDeflater().end();
         }
 
         protected void internalReset() {
             defl.getDeflater().reset();
         }
 
         protected int internalAdler() {
             return defl.getDeflater().getAdler();
         }
 
         protected IRubyObject internalFinish() throws Exception {
             return defl.finish();
         }
 
         protected int internalTotalIn() {
             return defl.getDeflater().getTotalIn();
         }
 
         protected void internalClose() {
             defl.close();
         }
     }
 
     public static class RubyGzipFile extends RubyObject {
         public static IRubyObject wrap(IRubyObject recv, RubyGzipFile io, IRubyObject proc) throws IOException {
             if (!proc.isNil()) {
                 try {
                     ((RubyProc)proc).call(new IRubyObject[]{io});
                 } finally {
                     if (!io.isClosed()) {
                         io.close();
                     }
                 }
                 return recv.getRuntime().getNil();
             }
 
             return io;
         }
+        
+        protected static ObjectAllocator GZIPFILE_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new RubyGzipFile(runtime, klass);
+            }
+        };
 
-        public static RubyGzipFile newCreate(IRubyObject recv) {
-            RubyGzipFile result = new RubyGzipFile(recv.getRuntime(), (RubyClass) recv);
+        public static RubyGzipFile newInstance(IRubyObject recv) {
+            RubyClass klass = (RubyClass)recv;
+            
+            RubyGzipFile result = (RubyGzipFile)klass.allocate();
+            
             result.callInit(new IRubyObject[0]);
+            
             return result;
         }
 
         protected boolean closed = false;
         protected boolean finished = false;
         private int os_code = 255;
         private int level = -1;
         private String orig_name;
         private String comment;
         protected IRubyObject realIo;
         private IRubyObject mtime;
 
         public RubyGzipFile(IRuby runtime, RubyClass type) {
             super(runtime, type);
             mtime = runtime.getNil();
         }
         
         public IRubyObject os_code() {
             return getRuntime().newFixnum(os_code);
         }
         
         public IRubyObject closed_p() {
             return closed ? getRuntime().getTrue() : getRuntime().getFalse();
         }
         
         protected boolean isClosed() {
             return closed;
         }
         
         public IRubyObject orig_name() {
             return orig_name == null ? getRuntime().getNil() : getRuntime().newString(orig_name);
         }
         
         public Object to_io() {
             return realIo;
         }
         
         public IRubyObject comment() {
             return comment == null ? getRuntime().getNil() : getRuntime().newString(comment);
         }
         
         public IRubyObject crc() {
             return RubyFixnum.zero(getRuntime());
         }
         
         public IRubyObject mtime() {
             return mtime;
         }
         
         public IRubyObject sync() {
             return getRuntime().getNil();
         }
         
         public IRubyObject finish() throws IOException {
             if (!finished) {
                 //io.finish();
             }
             finished = true;
             return realIo;
         }
 
         public IRubyObject close() throws IOException {
             return null;
         }
         
         public IRubyObject level() {
             return getRuntime().newFixnum(level);
         }
         
         public IRubyObject set_sync(IRubyObject ignored) {
             return getRuntime().getNil();
         }
     }
 
     public static class RubyGzipReader extends RubyGzipFile {
+        protected static ObjectAllocator GZIPREADER_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new RubyGzipReader(runtime, klass);
+            }
+        };
+        
         private static RubyGzipReader newInstance(IRubyObject recv, IRubyObject[] args) {
-            RubyGzipReader result = new RubyGzipReader(recv.getRuntime(), recv.getRuntime().getModule("Zlib").getClass("GzipReader"));
-            result.callInit(args);
-            return result;
-        }
-
-        public static RubyGzipReader newCreate(IRubyObject recv, IRubyObject[] args) {
-            RubyGzipReader result = new RubyGzipReader(recv.getRuntime(), (RubyClass)recv);
+            RubyClass klass = (RubyClass)recv;
+            
+            RubyGzipReader result = (RubyGzipReader)klass.allocate();
             result.callInit(args);
             return result;
         }
 
         public static IRubyObject open(IRubyObject recv, RubyString filename) throws IOException {
             RubyObject proc = (recv.getRuntime().getCurrentContext().isBlockGiven()) ? (RubyObject)recv.getRuntime().newProc() : (RubyObject)recv.getRuntime().getNil();
             RubyGzipReader io = newInstance(recv,new IRubyObject[]{recv.getRuntime().getClass("File").callMethod(recv.getRuntime().getCurrentContext(),"open", new IRubyObject[]{filename,recv.getRuntime().newString("rb")})});
             
             return RubyGzipFile.wrap(recv, io, proc);
         }
 
         public RubyGzipReader(IRuby runtime, RubyClass type) {
             super(runtime, type);
         }
         
         private int line;
         private InputStream io;
         
         public IRubyObject initialize(IRubyObject io) {
             realIo = io;
             try {
                 this.io = new GZIPInputStream(new IOInputStream(io));
             } catch (IOException e) {
                 IRuby runtime = io.getRuntime();
                 RubyClass errorClass = runtime.getModule("Zlib").getClass("GzipReader").getClass("Error");
                 throw new RaiseException(RubyException.newException(runtime, errorClass, e.getMessage()));
             }
 
             line = 1;
             
             return this;
         }
         
         public IRubyObject rewind() {
             return getRuntime().getNil();
         }
         
         public IRubyObject lineno() {
             return getRuntime().newFixnum(line);
         }
 
         public IRubyObject readline() throws IOException {
             IRubyObject dst = gets(new IRubyObject[0]);
             if (dst.isNil()) {
                 throw getRuntime().newEOFError();
             }
             return dst;
         }
 
         public IRubyObject internalGets(IRubyObject[] args) throws IOException {
             String sep = ((RubyString)getRuntime().getGlobalVariables().get("$/")).getValue().toString();
             if (args.length > 0) {
                 sep = args[0].toString();
             }
             return internalSepGets(sep);
         }
 
         private IRubyObject internalSepGets(String sep) throws IOException {
             StringBuffer result = new StringBuffer();
             char ce = (char) io.read();
             while (ce != -1 && sep.indexOf(ce) == -1) {
                 result.append((char) ce);
                 ce = (char) io.read();
             }
             line++;
             return getRuntime().newString(result.append(sep).toString());
         }
 
         public IRubyObject gets(IRubyObject[] args) throws IOException {
             IRubyObject result = internalGets(args);
             if (!result.isNil()) {
                 getRuntime().getCurrentContext().setLastline(result);
             }
             return result;
         }
 
         private final static int BUFF_SIZE = 4096;
         public IRubyObject read(IRubyObject[] args) throws IOException {
             if (args.length == 0 || args[0].isNil()) {
                 StringBuffer val = new StringBuffer();
                 byte[] buffer = new byte[BUFF_SIZE];
                 int read = io.read(buffer);
                 while (read != -1) {
                     val.append(new String(buffer,0,read));
                     read = io.read(buffer);
                 }
                 return getRuntime().newString(val.toString());
             } 
 
             int len = RubyNumeric.fix2int(args[0]);
             if (len < 0) {
             	throw getRuntime().newArgumentError("negative length " + len + " given");
             } else if (len > 0) {
             	byte[] buffer = new byte[len];
             	int toRead = len;
             	int offset = 0;
             	int read = 0;
             	while (toRead > 0) {
             		read = io.read(buffer,offset,toRead);
             		if (read == -1) {
             			break;
             		}
             		toRead -= read;
             		offset += read;
             	}
             	return getRuntime().newString(new String(buffer,0,len-toRead, "PLAIN"));
             }
                 
             return getRuntime().newString("");
         }
 
         public IRubyObject set_lineno(RubyNumeric lineArg) {
             line = RubyNumeric.fix2int(lineArg);
             return lineArg;
         }
 
         public IRubyObject pos() {
             return RubyFixnum.zero(getRuntime());
         }
         
         public IRubyObject readchar() throws IOException {
             int value = io.read();
             if (value == -1) {
                 throw getRuntime().newEOFError();
             }
             return getRuntime().newFixnum(value);
         }
 
         public IRubyObject getc() throws IOException {
             int value = io.read();
             return value == -1 ? getRuntime().getNil() : getRuntime().newFixnum(value);
         }
 
         private boolean isEof() throws IOException {
             return ((GZIPInputStream)io).available() != 1;
         }
 
         public IRubyObject close() throws IOException {
             if (!closed) {
                 io.close();
             }
             this.closed = true;
             return getRuntime().getNil();
         }
         
         public IRubyObject eof() throws IOException {
             return isEof() ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject eof_p() throws IOException {
             return eof();
         }
 
         public IRubyObject unused() {
             return getRuntime().getNil();
         }
 
         public IRubyObject tell() {
             return getRuntime().getNil();
         }
 
         public IRubyObject each(IRubyObject[] args) throws IOException {
             String sep = ((RubyString)getRuntime().getGlobalVariables().get("$/")).getValue().toString();
             
             if (args.length > 0 && !args[0].isNil()) {
                 sep = args[0].toString();
             }
 
             ThreadContext context = getRuntime().getCurrentContext();
             while (!isEof()) {
                 context.yield(internalSepGets(sep));
             }
             
             return getRuntime().getNil();
         }
     
         public IRubyObject ungetc(RubyNumeric arg) {
             return getRuntime().getNil();
         }
 
         public IRubyObject readlines(IRubyObject[] args) throws IOException {
             List array = new ArrayList();
             
             if (args.length != 0 && args[0].isNil()) {
                 array.add(read(new IRubyObject[0]));
             } else {
                 String seperator = ((RubyString)getRuntime().getGlobalVariables().get("$/")).getValue().toString();
                 if (args.length > 0) {
                     seperator = args[0].toString();
                 }
                 while (!isEof()) {
                     array.add(internalSepGets(seperator));
                 }
             }
             return getRuntime().newArray(array);
         }
 
         public IRubyObject each_byte() throws IOException {
             int value = io.read();
 
             ThreadContext context = getRuntime().getCurrentContext();
             while (value != -1) {
                 context.yield(getRuntime().newFixnum(value));
                 value = io.read();
             }
             
             return getRuntime().getNil();
         }
     }
 
     public static class RubyGzipWriter extends RubyGzipFile {
-        private static RubyGzipWriter newInstance(IRubyObject recv, IRubyObject[] args) {
-            RubyGzipWriter result = new RubyGzipWriter(recv.getRuntime(), recv.getRuntime().getModule("Zlib").getClass("GzipWriter"));
+        protected static ObjectAllocator GZIPWRITER_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new RubyGzipWriter(runtime, klass);
+            }
+        };
+        
+        private static RubyGzipWriter newGzipWriter(IRubyObject recv, IRubyObject[] args) {
+            RubyClass klass = (RubyClass)recv;
+            
+            RubyGzipWriter result = (RubyGzipWriter)klass.allocate();
             result.callInit(args);
             return result;
         }
 
-        public static RubyGzipWriter newCreate(IRubyObject recv, IRubyObject[] args) {
-            RubyGzipWriter result = new RubyGzipWriter(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
         public static IRubyObject open(IRubyObject recv, IRubyObject[] args) throws IOException {
             IRubyObject level = recv.getRuntime().getNil();
             IRubyObject strategy = recv.getRuntime().getNil();
             ThreadContext context = recv.getRuntime().getCurrentContext();
             if (args.length>1) {
                 level = args[1];
                 if (args.length>2) {
                     strategy = args[2];
                 }
             }
 
             RubyObject proc = (context.isBlockGiven()) ? (RubyObject)recv.getRuntime().newProc() : (RubyObject)recv.getRuntime().getNil();
-            RubyGzipWriter io = newInstance(recv,new IRubyObject[]{recv.getRuntime().getClass("File").callMethod(context,"open", new IRubyObject[]{args[0],recv.getRuntime().newString("wb")}),level,strategy});
+            RubyGzipWriter io = newGzipWriter(recv,new IRubyObject[]{recv.getRuntime().getClass("File").callMethod(context,"open", new IRubyObject[]{args[0],recv.getRuntime().newString("wb")}),level,strategy});
             return RubyGzipFile.wrap(recv, io, proc);
         }
 
         public RubyGzipWriter(IRuby runtime, RubyClass type) {
             super(runtime, type);
         }
 
         private GZIPOutputStream io;
         public IRubyObject initialize2(IRubyObject[] args) throws IOException {
             realIo = (RubyObject)args[0];
             this.io = new GZIPOutputStream(new IOOutputStream(args[0]));
             
             return this;
         }
 
         public IRubyObject close() throws IOException {
             if (!closed) {
                 io.close();
             }
             this.closed = true;
             
             return getRuntime().getNil();
         }
 
         public IRubyObject append(IRubyObject p1) throws IOException {
             this.write(p1);
             return this;
         }
 
         public IRubyObject printf(IRubyObject[] args) throws IOException {
             write(RubyKernel.sprintf(this, args));
             return getRuntime().getNil();
         }
 
         public IRubyObject print(IRubyObject[] args) throws IOException {
             if (args.length != 0) {
                 for (int i = 0, j = args.length; i < j; i++) {
                     write(args[i]);
                 }
             }
             
             IRubyObject sep = getRuntime().getGlobalVariables().get("$\\");
             if (!sep.isNil()) {
                 write(sep);
             }
             
             return getRuntime().getNil();
         }
 
         public IRubyObject pos() {
             return getRuntime().getNil();
         }
 
         public IRubyObject set_orig_name(RubyString ignored) {
             return getRuntime().getNil();
         }
 
         public IRubyObject set_comment(RubyString ignored) {
             return getRuntime().getNil();
         }
 
         public IRubyObject putc(RubyNumeric p1) throws IOException {
             io.write(RubyNumeric.fix2int(p1));
             return p1;
         }
         
         public IRubyObject puts(IRubyObject[] args) throws IOException {
-            RubyStringIO sio = (RubyStringIO)RubyStringIO.newInstance(this, new IRubyObject[0]);
+            RubyStringIO sio = (RubyStringIO)getRuntime().getClass("StringIO").newInstance(new IRubyObject[0]);
             sio.puts(args);
             write(sio.string());
             
             return getRuntime().getNil();
         }
 
         public IRubyObject finish() throws IOException {
             if (!finished) {
                 io.finish();
             }
             finished = true;
             return realIo;
         }
 
         public IRubyObject flush(IRubyObject[] args) throws IOException {
             if (args.length == 0 || args[0].isNil() || RubyNumeric.fix2int(args[0]) != 0) { // Zlib::NO_FLUSH
                 io.flush();
             }
             return getRuntime().getNil();
         }
 
         public IRubyObject set_mtime(IRubyObject ignored) {
             return getRuntime().getNil();
         }
 
         public IRubyObject tell() {
             return getRuntime().getNil();
         }
 
         public IRubyObject write(IRubyObject p1) throws IOException {
             String str = p1.toString();
             io.write(str.getBytes("ISO8859_1"));
             return getRuntime().newFixnum(str.length());
         }
     }
 }
diff --git a/src/org/jruby/evaluator/EvaluationState.java b/src/org/jruby/evaluator/EvaluationState.java
index 2381e04a76..c842272322 100644
--- a/src/org/jruby/evaluator/EvaluationState.java
+++ b/src/org/jruby/evaluator/EvaluationState.java
@@ -1,1356 +1,1363 @@
 /*******************************************************************************
  * BEGIN LICENSE BLOCK *** Version: CPL 1.0/GPL 2.0/LGPL 2.1
  * 
  * The contents of this file are subject to the Common Public License Version
  * 1.0 (the "License"); you may not use this file except in compliance with the
  * License. You may obtain a copy of the License at
  * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
  * the specific language governing rights and limitations under the License.
  * 
  * Copyright (C) 2006 Charles Oliver Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"), in
  * which case the provisions of the GPL or the LGPL are applicable instead of
  * those above. If you wish to allow use of your version of this file only under
  * the terms of either the GPL or the LGPL, and not to allow others to use your
  * version of this file under the terms of the CPL, indicate your decision by
  * deleting the provisions above and replace them with the notice and other
  * provisions required by the GPL or the LGPL. If you do not delete the
  * provisions above, a recipient may use your version of this file under the
  * terms of any one of the CPL, the GPL or the LGPL. END LICENSE BLOCK ****
  ******************************************************************************/
 
 package org.jruby.evaluator;
 
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.jruby.IRuby;
 import org.jruby.MetaClass;
 import org.jruby.RubyArray;
 import org.jruby.RubyBignum;
 import org.jruby.RubyClass;
 import org.jruby.RubyException;
 import org.jruby.RubyFloat;
 import org.jruby.RubyHash;
 import org.jruby.RubyKernel;
 import org.jruby.RubyModule;
 import org.jruby.RubyProc;
 import org.jruby.RubyRange;
 import org.jruby.RubyRegexp;
 import org.jruby.RubyString;
 import org.jruby.ast.AliasNode;
 import org.jruby.ast.ArgsCatNode;
 import org.jruby.ast.ArgsNode;
 import org.jruby.ast.ArgsPushNode;
 import org.jruby.ast.ArrayNode;
 import org.jruby.ast.AttrAssignNode;
 import org.jruby.ast.BackRefNode;
 import org.jruby.ast.BeginNode;
 import org.jruby.ast.BignumNode;
 import org.jruby.ast.BinaryOperatorNode;
 import org.jruby.ast.BlockAcceptingNode;
 import org.jruby.ast.BlockNode;
 import org.jruby.ast.BlockPassNode;
 import org.jruby.ast.BreakNode;
 import org.jruby.ast.CallNode;
 import org.jruby.ast.CaseNode;
 import org.jruby.ast.ClassNode;
 import org.jruby.ast.ClassVarAsgnNode;
 import org.jruby.ast.ClassVarDeclNode;
 import org.jruby.ast.ClassVarNode;
 import org.jruby.ast.Colon2Node;
 import org.jruby.ast.Colon3Node;
 import org.jruby.ast.ConstDeclNode;
 import org.jruby.ast.ConstNode;
 import org.jruby.ast.DAsgnNode;
 import org.jruby.ast.DRegexpNode;
 import org.jruby.ast.DStrNode;
 import org.jruby.ast.DSymbolNode;
 import org.jruby.ast.DVarNode;
 import org.jruby.ast.DXStrNode;
 import org.jruby.ast.DefinedNode;
 import org.jruby.ast.DefnNode;
 import org.jruby.ast.DefsNode;
 import org.jruby.ast.DotNode;
 import org.jruby.ast.EnsureNode;
 import org.jruby.ast.EvStrNode;
 import org.jruby.ast.FCallNode;
 import org.jruby.ast.FixnumNode;
 import org.jruby.ast.FlipNode;
 import org.jruby.ast.FloatNode;
 import org.jruby.ast.ForNode;
 import org.jruby.ast.GlobalAsgnNode;
 import org.jruby.ast.GlobalVarNode;
 import org.jruby.ast.HashNode;
 import org.jruby.ast.IfNode;
 import org.jruby.ast.InstAsgnNode;
 import org.jruby.ast.InstVarNode;
 import org.jruby.ast.IterNode;
 import org.jruby.ast.ListNode;
 import org.jruby.ast.LocalAsgnNode;
 import org.jruby.ast.LocalVarNode;
 import org.jruby.ast.Match2Node;
 import org.jruby.ast.Match3Node;
 import org.jruby.ast.MatchNode;
 import org.jruby.ast.ModuleNode;
 import org.jruby.ast.MultipleAsgnNode;
 import org.jruby.ast.NewlineNode;
 import org.jruby.ast.NextNode;
 import org.jruby.ast.Node;
 import org.jruby.ast.NodeTypes;
 import org.jruby.ast.NotNode;
 import org.jruby.ast.NthRefNode;
 import org.jruby.ast.OpAsgnNode;
 import org.jruby.ast.OpAsgnOrNode;
 import org.jruby.ast.OpElementAsgnNode;
 import org.jruby.ast.OptNNode;
 import org.jruby.ast.OrNode;
 import org.jruby.ast.RegexpNode;
 import org.jruby.ast.RescueBodyNode;
 import org.jruby.ast.RescueNode;
 import org.jruby.ast.ReturnNode;
 import org.jruby.ast.RootNode;
 import org.jruby.ast.SClassNode;
 import org.jruby.ast.SValueNode;
 import org.jruby.ast.SplatNode;
 import org.jruby.ast.StrNode;
 import org.jruby.ast.SuperNode;
 import org.jruby.ast.SymbolNode;
 import org.jruby.ast.ToAryNode;
 import org.jruby.ast.UndefNode;
 import org.jruby.ast.UntilNode;
 import org.jruby.ast.VAliasNode;
 import org.jruby.ast.VCallNode;
 import org.jruby.ast.WhenNode;
 import org.jruby.ast.WhileNode;
 import org.jruby.ast.XStrNode;
 import org.jruby.ast.YieldNode;
 import org.jruby.ast.types.INameNode;
 import org.jruby.ast.util.ArgsUtil;
 import org.jruby.exceptions.JumpException;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.exceptions.JumpException.JumpType;
 import org.jruby.internal.runtime.methods.DefaultMethod;
 import org.jruby.internal.runtime.methods.WrapperMethod;
 import org.jruby.lexer.yacc.ISourcePosition;
 import org.jruby.parser.StaticScope;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.CallType;
 import org.jruby.runtime.DynamicMethod;
 import org.jruby.runtime.DynamicScope;
 import org.jruby.runtime.ICallable;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class EvaluationState {
     public static IRubyObject eval(ThreadContext context, Node node, IRubyObject self) {
         try {
             return evalInternal(context, node, self);
         } catch (StackOverflowError sfe) {
+            sfe.printStackTrace();
             throw context.getRuntime().newSystemStackError("stack level too deep");
         }
     }
 
     private static IRubyObject evalInternal(ThreadContext context, Node node, IRubyObject self) {
         IRuby runtime = context.getRuntime();
         
         bigloop: do {
             if (node == null) return runtime.getNil();
 
             switch (node.nodeId) {
             case NodeTypes.ALIASNODE: {
                 AliasNode iVisited = (AliasNode) node;
     
                 if (context.getRubyClass() == null) {
                     throw runtime.newTypeError("no class to make alias");
                 }
     
                 context.getRubyClass().defineAlias(iVisited.getNewName(), iVisited.getOldName());
                 context.getRubyClass().callMethod(context, "method_added", runtime.newSymbol(iVisited.getNewName()));
     
                 return runtime.getNil();
             }
             case NodeTypes.ANDNODE: {
                 BinaryOperatorNode iVisited = (BinaryOperatorNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getFirstNode(), self);
                 if (!result.isTrue()) return result;
                 node = iVisited.getSecondNode();
                 continue bigloop;
             }
             case NodeTypes.ARGSCATNODE: {
                 ArgsCatNode iVisited = (ArgsCatNode) node;
     
                 IRubyObject args = evalInternal(context, iVisited.getFirstNode(), self);
                 IRubyObject secondArgs = splatValue(evalInternal(context, iVisited.getSecondNode(), self));
                 RubyArray list = args instanceof RubyArray ? (RubyArray) args : runtime.newArray(args);
     
                 return list.concat(secondArgs);
             }
             case NodeTypes.ARGSPUSHNODE: {
                 ArgsPushNode iVisited = (ArgsPushNode) node;
                 
                 RubyArray args = (RubyArray) evalInternal(context, iVisited.getFirstNode(), self).dup();
                 return args.append(evalInternal(context, iVisited.getSecondNode(), self));
             }
                 //                case NodeTypes.ARGSNODE:
                 //                EvaluateVisitor.argsNodeVisitor.execute(this, node);
                 //                break;
                 //                case NodeTypes.ARGUMENTNODE:
                 //                EvaluateVisitor.argumentNodeVisitor.execute(this, node);
                 //                break;
             case NodeTypes.ARRAYNODE: {
                 ArrayNode iVisited = (ArrayNode) node;
                 IRubyObject[] array = new IRubyObject[iVisited.size()];
                 int i = 0;
                 for (Iterator iterator = iVisited.iterator(); iterator.hasNext();) {
                     Node next = (Node) iterator.next();
     
                     array[i++] = evalInternal(context, next, self);
                 }
     
                 return runtime.newArray(array);
             }
                 //                case NodeTypes.ASSIGNABLENODE:
                 //                EvaluateVisitor.assignableNodeVisitor.execute(this, node);
                 //                break;
             case NodeTypes.ATTRASSIGNNODE: {
                 AttrAssignNode iVisited = (AttrAssignNode) node;
     
                 IRubyObject receiver = evalInternal(context, iVisited.getReceiverNode(), self);
                 IRubyObject[] args = setupArgs(context, iVisited.getArgsNode(), self);
                 
                 assert receiver.getMetaClass() != null : receiver.getClass().getName();
                 
                 // If reciever is self then we do the call the same way as vcall
                 CallType callType = (receiver == self ? CallType.VARIABLE : CallType.NORMAL);
     
                 receiver.callMethod(context, iVisited.getName(), args, callType);
                 
                 return args[args.length - 1]; 
             }
             case NodeTypes.BACKREFNODE: {
                 BackRefNode iVisited = (BackRefNode) node;
                 IRubyObject backref = context.getBackref();
                 switch (iVisited.getType()) {
                 case '~':
                     return backref;
                 case '&':
                     return RubyRegexp.last_match(backref);
                 case '`':
                     return RubyRegexp.match_pre(backref);
                 case '\'':
                     return RubyRegexp.match_post(backref);
                 case '+':
                     return RubyRegexp.match_last(backref);
                 }
                 break;
             }
             case NodeTypes.BEGINNODE: {
                 BeginNode iVisited = (BeginNode) node;
     
                 node = iVisited.getBodyNode();
                 continue bigloop;
             }
             case NodeTypes.BIGNUMNODE: {
                 BignumNode iVisited = (BignumNode) node;
                 return RubyBignum.newBignum(runtime, iVisited.getValue());
             }
                 //                case NodeTypes.BINARYOPERATORNODE:
                 //                EvaluateVisitor.binaryOperatorNodeVisitor.execute(this, node);
                 //                break;
                 //                case NodeTypes.BLOCKARGNODE:
                 //                EvaluateVisitor.blockArgNodeVisitor.execute(this, node);
                 //                break;
             case NodeTypes.BLOCKNODE: {
                 BlockNode iVisited = (BlockNode) node;
     
                 IRubyObject result = runtime.getNil();
                 for (Iterator iter = iVisited.iterator(); iter.hasNext();) {
                     result = evalInternal(context, (Node) iter.next(), self);
                 }
     
                 return result;
             }
             case NodeTypes.BLOCKPASSNODE: {
                 BlockPassNode iVisited = (BlockPassNode) node;
                 IRubyObject proc = evalInternal(context, iVisited.getBodyNode(), self);
                 
                 if (proc.isNil()) {
                     context.setNoBlock();
                     try {
                         return evalInternal(context, iVisited.getIterNode(), self);
                     } finally {
                         context.clearNoBlock();
                     }
                 }
     
                 // If not already a proc then we should try and make it one.
                 if (!(proc instanceof RubyProc)) {
                     proc = proc.convertToType("Proc", "to_proc", false);
     
                     if (!(proc instanceof RubyProc)) {
                         throw runtime.newTypeError("wrong argument type "
                                 + proc.getMetaClass().getName() + " (expected Proc)");
                     }
                 }
     
                 // TODO: Add safety check for taintedness
     
                 Block block = (Block) context.getCurrentBlock();
                 if (block != null) {
                     IRubyObject blockObject = block.getBlockObject();
                     // The current block is already associated with the proc.  No need to create new
                     // block for it.  Just eval!
                     if (blockObject != null && blockObject == proc) {
                         try {
                             context.setBlockAvailable();
                             return evalInternal(context, iVisited.getIterNode(), self);
                         } finally {
                             context.clearBlockAvailable();
                         }
                     }
                 }
     
                 context.preBlockPassEval(((RubyProc) proc).getBlock());
     
                 try {
                     return evalInternal(context, iVisited.getIterNode(), self);
                 } finally {
                     context.postBlockPassEval();
                 }
             }
             case NodeTypes.BREAKNODE: {
                 BreakNode iVisited = (BreakNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
     
                 JumpException je = new JumpException(JumpException.JumpType.BreakJump);
     
                 je.setPrimaryData(result);
                 je.setSecondaryData(node);
     
                 throw je;
             }
             case NodeTypes.CALLNODE: {
                 CallNode iVisited = (CallNode) node;
                 IterNode iterNode = iVisited.getIterNode();
     
                 IRubyObject receiver = evalInternal(context, iVisited.getReceiverNode(), self);
                 IRubyObject[] args = setupArgs(context, iVisited.getArgsNode(), self);
                 
                 assert receiver.getMetaClass() != null : receiver.getClass().getName();
                 // If reciever is self then we do the call the same way as vcall
                 CallType callType = (receiver == self ? CallType.VARIABLE : CallType.NORMAL);
     
                 // if no block passed, do a simple call
                 if (iterNode == null) {
+                    try {
                     return receiver.callMethod(context, iVisited.getName(), args, callType);
+                    } catch (ClassCastException cce) {
+                        cce.printStackTrace();
+                        System.out.println(receiver.getClass());
+                        System.out.println(iVisited.getName());
+                    }
                 }
                 
                 // if block passed, prepare the block and then do the call, handling breaks and retries correctly
                 context.preIterEval(Block.createBlock(context, iterNode.getVarNode(), 
                         new DynamicScope(iterNode.getScope(), context.getCurrentScope()), 
                         iterNode.getCallable(), self));
                 
                 try {
                     while (true) {
                         try {
                             context.setBlockAvailable();
                             return receiver.callMethod(context, iVisited.getName(), args, callType);
                         } catch (JumpException je) {
                             switch (je.getJumpType().getTypeId()) {
                             case JumpType.RETRY:
                                 // allow loop to retry
                                 break;
                             default:
                                 throw je;
                             }
                         } finally {
                             context.clearBlockAvailable();
                         }
                     }
                 } catch (JumpException je) {
                     switch (je.getJumpType().getTypeId()) {
                     case JumpType.BREAK:
                         IRubyObject breakValue = (IRubyObject) je.getPrimaryData();
     
                         return breakValue == null ? runtime.getNil() : breakValue;
                     default:
                         throw je;
                     }
                 } finally {
                     context.postIterEval();
                 }
             }
             case NodeTypes.CASENODE: {
                 CaseNode iVisited = (CaseNode) node;
                 IRubyObject expression = null;
                 if (iVisited.getCaseNode() != null) {
                     expression = evalInternal(context, iVisited.getCaseNode(), self);
                 }
     
                 context.pollThreadEvents();
     
                 IRubyObject result = runtime.getNil();
     
                 Node firstWhenNode = iVisited.getFirstWhenNode();
                 while (firstWhenNode != null) {
                     if (!(firstWhenNode instanceof WhenNode)) {
                         node = firstWhenNode;
                         continue bigloop;
                     }
     
                     WhenNode whenNode = (WhenNode) firstWhenNode;
     
                     if (whenNode.getExpressionNodes() instanceof ArrayNode) {
                         for (Iterator iter = ((ArrayNode) whenNode.getExpressionNodes()).iterator(); iter
                                 .hasNext();) {
                             Node tag = (Node) iter.next();
     
                             context.setPosition(tag.getPosition());
                             if (isTrace(runtime)) {
                                 callTraceFunction(context, "line", self);
                             }
     
                             // Ruby grammar has nested whens in a case body because of
                             // productions case_body and when_args.
                             if (tag instanceof WhenNode) {
                                 RubyArray expressions = (RubyArray) evalInternal(context, ((WhenNode) tag)
                                                 .getExpressionNodes(), self);
     
                                 for (int j = 0; j < expressions.getLength(); j++) {
                                     IRubyObject condition = expressions.entry(j);
     
                                     if ((expression != null && condition.callMethod(context, "===", expression)
                                             .isTrue())
                                             || (expression == null && condition.isTrue())) {
                                         node = ((WhenNode) firstWhenNode).getBodyNode();
                                         continue bigloop;
                                     }
                                 }
                                 continue;
                             }
     
                             result = evalInternal(context, tag, self);
     
                             if ((expression != null && result.callMethod(context, "===", expression).isTrue())
                                     || (expression == null && result.isTrue())) {
                                 node = whenNode.getBodyNode();
                                 continue bigloop;
                             }
                         }
                     } else {
                         result = evalInternal(context, whenNode.getExpressionNodes(), self);
     
                         if ((expression != null && result.callMethod(context, "===", expression).isTrue())
                                 || (expression == null && result.isTrue())) {
                             node = ((WhenNode) firstWhenNode).getBodyNode();
                             continue bigloop;
                         }
                     }
     
                     context.pollThreadEvents();
     
                     firstWhenNode = whenNode.getNextCase();
                 }
     
                 return runtime.getNil();
             }
             case NodeTypes.CLASSNODE: {
                 ClassNode iVisited = (ClassNode) node;
                 Node superNode = iVisited.getSuperNode();
                 RubyClass superClass = superNode == null ? null : (RubyClass) evalInternal(context, superNode, self);
                 Node classNameNode = iVisited.getCPath();
                 String name = ((INameNode) classNameNode).getName();
                 RubyModule enclosingClass = getEnclosingModule(context, classNameNode, self);
                 RubyClass rubyClass = enclosingClass.defineOrGetClassUnder(name, superClass);
     
                 if (context.getWrapper() != null) {
                     rubyClass.extendObject(context.getWrapper());
                     rubyClass.includeModule(context.getWrapper());
                 }
                 return evalClassDefinitionBody(context, iVisited.getScope(), iVisited.getBodyNode(), rubyClass, self);
             }
             case NodeTypes.CLASSVARASGNNODE: {
                 ClassVarAsgnNode iVisited = (ClassVarAsgnNode) node;
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
                 RubyModule rubyClass = (RubyModule) context.peekCRef().getValue();
     
                 if (rubyClass == null) {
                     rubyClass = self.getMetaClass();
                 } else if (rubyClass.isSingleton()) {
                     rubyClass = (RubyModule) rubyClass.getInstanceVariable("__attached__");
                 }
     
                 rubyClass.setClassVar(iVisited.getName(), result);
     
                 return result;
             }
             case NodeTypes.CLASSVARDECLNODE: {
     
                 ClassVarDeclNode iVisited = (ClassVarDeclNode) node;
     
                 // FIXME: shouldn't we use cref here?
                 if (context.getRubyClass() == null) {
                     throw runtime.newTypeError("no class/module to define class variable");
                 }
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
                 ((RubyModule) context.peekCRef().getValue()).setClassVar(iVisited.getName(),
                         result);
     
                 return runtime.getNil();
             }
             case NodeTypes.CLASSVARNODE: {
                 ClassVarNode iVisited = (ClassVarNode) node;
                 RubyModule rubyClass = (RubyModule) context.peekCRef().getValue();
     
                 if (rubyClass == null) {
                     rubyClass = self.getMetaClass();
                 } else if (rubyClass.isSingleton()) {
                     rubyClass = (RubyModule)rubyClass.getInstanceVariable("__attached__");
                 }
                 
                     return rubyClass.getClassVar(iVisited.getName());
                     }
             case NodeTypes.COLON2NODE: {
                 Colon2Node iVisited = (Colon2Node) node;
                 Node leftNode = iVisited.getLeftNode();
     
                 // TODO: Made this more colon3 friendly because of cpath production
                 // rule in grammar (it is convenient to think of them as the same thing
                 // at a grammar level even though evaluation is).
                 if (leftNode == null) {
                     return runtime.getObject().getConstantFrom(iVisited.getName());
                 } else {
                     IRubyObject result = evalInternal(context, iVisited.getLeftNode(), self);
                     if (result instanceof RubyModule) {
                         return ((RubyModule) result).getConstantFrom(iVisited.getName());
                     } else {
                         return result.callMethod(context, iVisited.getName());
                     }
                 }
             }
             case NodeTypes.COLON3NODE: {
                 Colon3Node iVisited = (Colon3Node) node;
                 return runtime.getObject().getConstantFrom(iVisited.getName());
             }
             case NodeTypes.CONSTDECLNODE: {
                 ConstDeclNode iVisited = (ConstDeclNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
                 IRubyObject module;
     
                 if (iVisited.getPathNode() != null) {
                     module = evalInternal(context, iVisited.getPathNode(), self);
                 } else {
                     
     
                     // FIXME: why do we check RubyClass and then use CRef?
                     if (context.getRubyClass() == null) {
                         // TODO: wire into new exception handling mechanism
                         throw runtime.newTypeError("no class/module to define constant");
                     }
                     module = (RubyModule) context.peekCRef().getValue();
                 }
     
                 // FIXME: shouldn't we use the result of this set in setResult?
                 ((RubyModule) module).setConstant(iVisited.getName(), result);
     
                 return result;
             }
             case NodeTypes.CONSTNODE: {
                 ConstNode iVisited = (ConstNode) node;
                 return context.getConstant(iVisited.getName());
             }
             case NodeTypes.DASGNNODE: {
                 DAsgnNode iVisited = (DAsgnNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
 
                 // System.out.println("DSetting: " + iVisited.getName() + " at index " + iVisited.getIndex() + " and at depth " + iVisited.getDepth() + " and set " + result);
                 context.getCurrentScope().setValue(iVisited.getIndex(), result, iVisited.getDepth());
     
                 return result;
             }
             case NodeTypes.DEFINEDNODE: {
                 DefinedNode iVisited = (DefinedNode) node;
                 String definition = getDefinition(context, iVisited.getExpressionNode(), self);
                 if (definition != null) {
                     return runtime.newString(definition);
                 } else {
                     return runtime.getNil();
                 }
             }
             case NodeTypes.DEFNNODE: {
                 DefnNode iVisited = (DefnNode) node;
                 
                 RubyModule containingClass = context.getRubyClass();
     
                 if (containingClass == null) {
                     throw runtime.newTypeError("No class to add method.");
                 }
     
                 String name = iVisited.getName();
                 if (containingClass == runtime.getObject() && name == "initialize") {
                     runtime.getWarnings().warn("redefining Object#initialize may cause infinite loop");
                 }
     
                 Visibility visibility = context.getCurrentVisibility();
                 if (name == "initialize" || visibility.isModuleFunction()) {
                     visibility = Visibility.PRIVATE;
                 }
                 
                 if (containingClass.isSingleton()) {
                     IRubyObject attachedObject = ((MetaClass) containingClass).getAttachedObject();
                     
                     if (!attachedObject.singletonMethodsAllowed()) {
                         throw runtime.newTypeError("can't define singleton method \"" + 
                                 iVisited.getName() + "\" for " + attachedObject.getType());
                     }
                 }    
                 DefaultMethod newMethod = new DefaultMethod(containingClass, iVisited.getScope(), 
                         iVisited.getBodyNode(), (ArgsNode) iVisited.getArgsNode(), visibility, context.peekCRef());
     
                 containingClass.addMethod(name, newMethod);
     
                 if (context.getCurrentVisibility().isModuleFunction()) {
                     containingClass.getSingletonClass().addMethod(
                             name,
                             new WrapperMethod(containingClass.getSingletonClass(), newMethod,
                                     Visibility.PUBLIC));
                     containingClass.callMethod(context, "singleton_method_added", runtime.newSymbol(name));
                 }
     
                 // 'class << state.self' and 'class << obj' uses defn as opposed to defs
                 if (containingClass.isSingleton()) {
                     ((MetaClass) containingClass).getAttachedObject().callMethod(
                             context, "singleton_method_added", runtime.newSymbol(iVisited.getName()));
                 } else {
                     containingClass.callMethod(context, "method_added", runtime.newSymbol(name));
                 }
     
                 return runtime.getNil();
             }
             case NodeTypes.DEFSNODE: {
                 DefsNode iVisited = (DefsNode) node;
                 IRubyObject receiver = evalInternal(context, iVisited.getReceiverNode(), self);
     
                 RubyClass rubyClass;
     
                 if (receiver.isNil()) {
                     rubyClass = runtime.getNilClass();
                 } else if (receiver == runtime.getTrue()) {
                     rubyClass = runtime.getClass("TrueClass");
                 } else if (receiver == runtime.getFalse()) {
                     rubyClass = runtime.getClass("FalseClass");
                 } else {
                     if (runtime.getSafeLevel() >= 4 && !receiver.isTaint()) {
                         throw runtime.newSecurityError("Insecure; can't define singleton method.");
                     }
                     if (receiver.isFrozen()) {
                         throw runtime.newFrozenError("object");
                     }
                     if (!receiver.singletonMethodsAllowed()) {
                         throw runtime.newTypeError("can't define singleton method \"" + iVisited.getName()
                                                    + "\" for " + receiver.getType());
                     }
     
                     rubyClass = receiver.getSingletonClass();
                 }
     
                 if (runtime.getSafeLevel() >= 4) {
                     Object method = rubyClass.getMethods().get(iVisited.getName());
                     if (method != null) {
                         throw runtime.newSecurityError("Redefining method prohibited.");
                     }
                 }
     
                 DefaultMethod newMethod = new DefaultMethod(rubyClass, iVisited.getScope(), 
                         iVisited.getBodyNode(), (ArgsNode) iVisited.getArgsNode(), 
                         Visibility.PUBLIC, context.peekCRef());
     
                 rubyClass.addMethod(iVisited.getName(), newMethod);
                 receiver.callMethod(context, "singleton_method_added", runtime.newSymbol(iVisited.getName()));
     
                 return runtime.getNil();
             }
             case NodeTypes.DOTNODE: {
                 DotNode iVisited = (DotNode) node;
                 return RubyRange.newRange(runtime, evalInternal(context, iVisited.getBeginNode(), self), evalInternal(context, iVisited
                                 .getEndNode(), self), iVisited.isExclusive());
             }
             case NodeTypes.DREGEXPNODE: {
                 DRegexpNode iVisited = (DRegexpNode) node;
     
                 StringBuffer sb = new StringBuffer();
                 for (Iterator iterator = iVisited.iterator(); iterator.hasNext();) {
                     Node iterNode = (Node) iterator.next();
     
                     sb.append(evalInternal(context, iterNode, self).toString());
                 }
     
                 String lang = null;
                 int opts = iVisited.getOptions();
                 if((opts & 16) != 0) { // param n
                     lang = "n";
                 } else if((opts & 48) != 0) { // param s
                     lang = "s";
                 } else if((opts & 64) != 0) { // param s
                     lang = "u";
                 }
 
                 return RubyRegexp.newRegexp(runtime, sb.toString(), iVisited.getOptions(), lang);
             }
             case NodeTypes.DSTRNODE: {
                 DStrNode iVisited = (DStrNode) node;
     
                 StringBuffer sb = new StringBuffer();
                 for (Iterator iterator = iVisited.iterator(); iterator.hasNext();) {
                     Node iterNode = (Node) iterator.next();
     
                     sb.append(evalInternal(context, iterNode, self).toString());
                 }
     
                 return runtime.newString(sb.toString());
             }
             case NodeTypes.DSYMBOLNODE: {
                 DSymbolNode iVisited = (DSymbolNode) node;
     
                 StringBuffer sb = new StringBuffer();
                 for (Iterator iterator = iVisited.getNode().iterator(); iterator.hasNext();) {
                     Node iterNode = (Node) iterator.next();
     
                     sb.append(evalInternal(context, iterNode, self).toString());
                 }
     
                 return runtime.newSymbol(sb.toString());
             }
             case NodeTypes.DVARNODE: {
                 DVarNode iVisited = (DVarNode) node;
 
                 // System.out.println("DGetting: " + iVisited.getName() + " at index " + iVisited.getIndex() + " and at depth " + iVisited.getDepth());
                 IRubyObject obj = context.getCurrentScope().getValue(iVisited.getIndex(), iVisited.getDepth());
 
                 // FIXME: null check is removable once we figure out how to assign to unset named block args
                 return obj == null ? runtime.getNil() : obj;
             }
             case NodeTypes.DXSTRNODE: {
                 DXStrNode iVisited = (DXStrNode) node;
     
                 StringBuffer sb = new StringBuffer();
                 for (Iterator iterator = iVisited.iterator(); iterator.hasNext();) {
                     Node iterNode = (Node) iterator.next();
     
                     sb.append(evalInternal(context, iterNode, self).toString());
                 }
     
                 return self.callMethod(context, "`", runtime.newString(sb.toString()));
             }
             case NodeTypes.ENSURENODE: {
                 EnsureNode iVisited = (EnsureNode) node;
     
                 // save entering the try if there's nothing to ensure
                 if (iVisited.getEnsureNode() != null) {
                     IRubyObject result = runtime.getNil();
     
                     try {
                         result = evalInternal(context, iVisited.getBodyNode(), self);
                     } finally {
                         evalInternal(context, iVisited.getEnsureNode(), self);
                     }
     
                     return result;
                 }
     
                 node = iVisited.getBodyNode();
                 continue bigloop;
             }
             case NodeTypes.EVSTRNODE: {
                 EvStrNode iVisited = (EvStrNode) node;
     
                 node = iVisited.getBody();
                 continue bigloop;
             }
             case NodeTypes.FALSENODE: {
                 context.pollThreadEvents();
                 return runtime.getFalse();
             }
             case NodeTypes.FCALLNODE: {
                 FCallNode iVisited = (FCallNode) node;
                 IterNode iterNode = iVisited.getIterNode();
                 
                 IRubyObject[] args = setupArgs(context, iVisited.getArgsNode(), self);
     
                 // if no block passed, do a simple call
                 if (iterNode == null) {
                     return self.callMethod(context, iVisited.getName(), args, CallType.FUNCTIONAL);
                 }
                 
                 // if block passed, prepare the block and then do the call, handling breaks and retries correctly
                 context.preIterEval(Block.createBlock(context, iterNode.getVarNode(), 
                         new DynamicScope(iterNode.getScope(), context.getCurrentScope()), 
                         iterNode.getCallable(), self));
                 
                 try {
                     while (true) {
                         try {
                             context.setBlockAvailable();
                             return self.callMethod(context, iVisited.getName(), args, CallType.FUNCTIONAL);
                         } catch (JumpException je) {
                             switch (je.getJumpType().getTypeId()) {
                             case JumpType.RETRY:
                                 // allow loop to retry
                                 break;
                             default:
                                 throw je;
                             }
                         } finally {
                             context.clearBlockAvailable();
                         }
                     }
                 } catch (JumpException je) {
                     switch (je.getJumpType().getTypeId()) {
                     case JumpType.BREAK:
                         IRubyObject breakValue = (IRubyObject) je.getPrimaryData();
     
                         return breakValue == null ? runtime.getNil() : breakValue;
                     default:
                         throw je;
                     }
                 } finally {
                     context.postIterEval();
                 }
             }
             case NodeTypes.FIXNUMNODE: {
                 FixnumNode iVisited = (FixnumNode) node;
                 return iVisited.getFixnum(runtime);
             }
             case NodeTypes.FLIPNODE: {
                 FlipNode iVisited = (FlipNode) node;
                 IRubyObject result = runtime.getNil();
     
                 if (iVisited.isExclusive()) {
                     if (!context.getCurrentScope().getValue(iVisited.getIndex(), iVisited.getDepth()).isTrue()) {
                         result = evalInternal(context, iVisited.getBeginNode(), self).isTrue() ? runtime.getFalse()
                                 : runtime.getTrue();
                         context.getCurrentScope().setValue(iVisited.getIndex(), result, iVisited.getDepth());
                         return result;
                     } else {
                         if (evalInternal(context, iVisited.getEndNode(), self).isTrue()) {
                             context.getCurrentScope().setValue(iVisited.getIndex(), runtime.getFalse(), iVisited.getDepth());
                         }
                         return runtime.getTrue();
                     }
                 } else {
                     if (!context.getCurrentScope().getValue(iVisited.getIndex(), iVisited.getDepth()).isTrue()) {
                         if (evalInternal(context, iVisited.getBeginNode(), self).isTrue()) {
                             context.getCurrentScope().setValue(
                                     iVisited.getIndex(),
                                     evalInternal(context, iVisited.getEndNode(), self).isTrue() ? runtime.getFalse()
                                             : runtime.getTrue(), iVisited.getDepth());
                             return runtime.getTrue();
                         } else {
                             return runtime.getFalse();
                         }
                     } else {
                         if (evalInternal(context, iVisited.getEndNode(), self).isTrue()) {
                             context.getCurrentScope().setValue(iVisited.getIndex(), runtime.getFalse(), iVisited.getDepth());
                         }
                         return runtime.getTrue();
                     }
                 }
             }
             case NodeTypes.FLOATNODE: {
                 FloatNode iVisited = (FloatNode) node;
                 return RubyFloat.newFloat(runtime, iVisited.getValue());
             }
             case NodeTypes.FORNODE: {
                 ForNode iVisited = (ForNode) node;
                 
                 // For nodes do not have to create an addition scope so we just pass null
                 context.preForLoopEval(Block.createBlock(context, iVisited.getVarNode(), null,
                         iVisited.getCallable(), self));
     
                 try {
                     while (true) {
                         try {
                             ISourcePosition position = context.getPosition();
                             context.beginCallArgs();
     
                             IRubyObject recv = null;
                             try {
                                 recv = evalInternal(context, iVisited.getIterNode(), self);
                             } finally {
                                 context.setPosition(position);
                                 context.endCallArgs();
                             }
     
                             return recv.callMethod(context, "each", IRubyObject.NULL_ARRAY, CallType.NORMAL);
                         } catch (JumpException je) {
                             switch (je.getJumpType().getTypeId()) {
                             case JumpType.RETRY:
                                 // do nothing, allow loop to retry
                                 break;
                             default:
                                 throw je;
                             }
                         }
                     }
                 } catch (JumpException je) {
                     switch (je.getJumpType().getTypeId()) {
                     case JumpType.BREAK:
                         IRubyObject breakValue = (IRubyObject) je.getPrimaryData();
     
                         return breakValue == null ? runtime.getNil() : breakValue;
                     default:
                         throw je;
                     }
                 } finally {
                     context.postForLoopEval();
                 }
             }
             case NodeTypes.GLOBALASGNNODE: {
                 GlobalAsgnNode iVisited = (GlobalAsgnNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
     
                 runtime.getGlobalVariables().set(iVisited.getName(), result);
     
                 return result;
             }
             case NodeTypes.GLOBALVARNODE: {
                 GlobalVarNode iVisited = (GlobalVarNode) node;
                 return runtime.getGlobalVariables().get(iVisited.getName());
             }
             case NodeTypes.HASHNODE: {
                 HashNode iVisited = (HashNode) node;
     
                 Map hash = null;
                 if (iVisited.getListNode() != null) {
                     hash = new HashMap(iVisited.getListNode().size() / 2);
     
                     for (Iterator iterator = iVisited.getListNode().iterator(); iterator.hasNext();) {
                         // insert all nodes in sequence, hash them in the final instruction
                         // KEY
                         IRubyObject key = evalInternal(context, (Node) iterator.next(), self);
                         IRubyObject value = evalInternal(context, (Node) iterator.next(), self);
     
                         hash.put(key, value);
                     }
                 }
     
                 if (hash == null) {
                     return RubyHash.newHash(runtime);
                 }
     
                 return RubyHash.newHash(runtime, hash, runtime.getNil());
             }
             case NodeTypes.IFNODE: {
                 IfNode iVisited = (IfNode) node;
                 IRubyObject result = evalInternal(context, iVisited.getCondition(), self);
     
                 if (result.isTrue()) {
                     node = iVisited.getThenBody();
                     continue bigloop;
                 } else {
                     node = iVisited.getElseBody();
                     continue bigloop;
                 }
             }
             case NodeTypes.INSTASGNNODE: {
                 InstAsgnNode iVisited = (InstAsgnNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
                 self.setInstanceVariable(iVisited.getName(), result);
     
                 return result;
             }
             case NodeTypes.INSTVARNODE: {
                 InstVarNode iVisited = (InstVarNode) node;
                 IRubyObject variable = self.getInstanceVariable(iVisited.getName());
     
                 return variable == null ? runtime.getNil() : variable;
             }
                 //                case NodeTypes.ISCOPINGNODE:
                 //                EvaluateVisitor.iScopingNodeVisitor.execute(this, node);
                 //                break;
             case NodeTypes.ITERNODE: {
                 IterNode iVisited = (IterNode) node;
                 
                 // new-style handling of blocks, for nodes that support it
                 // don't process the block until it's needed, to avoid nasty iter tricks
                 if (iVisited.getIterNode() instanceof BlockAcceptingNode) {
                     ((BlockAcceptingNode)iVisited.getIterNode()).setIterNode(iVisited);
                     
                     node = iVisited.getIterNode();
                     continue bigloop;
                 } 
                 
                 // otherwise do it the same as the old way
                 context.preIterEval(Block.createBlock(context, iVisited.getVarNode(), 
                         new DynamicScope(iVisited.getScope(), context.getCurrentScope()), 
                         iVisited.getCallable(), self));
                 
                 try {
                     while (true) {
                         try {
                             context.setBlockAvailable();
                             return evalInternal(context, iVisited.getIterNode(), self);
                         } catch (JumpException je) {
                             switch (je.getJumpType().getTypeId()) {
                             case JumpType.RETRY:
                                 // allow loop to retry
                                 break;
                             default:
                                 throw je;
                             }
                         } finally {
                             context.clearBlockAvailable();
                         }
                     }
                 } catch (JumpException je) {
                     switch (je.getJumpType().getTypeId()) {
                     case JumpType.BREAK:
                         IRubyObject breakValue = (IRubyObject) je.getPrimaryData();
     
                         return breakValue == null ? runtime.getNil() : breakValue;
                     default:
                         throw je;
                     }
                 } finally {
                     context.postIterEval();
                 }
             }
             case NodeTypes.LOCALASGNNODE: {
                 LocalAsgnNode iVisited = (LocalAsgnNode) node;
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
                 
                 // System.out.println("LSetting: " + iVisited.getName() + " at index " + iVisited.getIndex() + " and at depth " + iVisited.getDepth() + " and set " + result);
                 context.getCurrentScope().setValue(iVisited.getIndex(), result, iVisited.getDepth());
 
                 return result;
             }
             case NodeTypes.LOCALVARNODE: {
                 LocalVarNode iVisited = (LocalVarNode) node;
 
                 //System.out.println("DGetting: " + iVisited.getName() + " at index " + iVisited.getIndex() + " and at depth " + iVisited.getDepth());
                 IRubyObject result = context.getCurrentScope().getValue(iVisited.getIndex(), iVisited.getDepth());
 
                 return result == null ? runtime.getNil() : result;
             }
             case NodeTypes.MATCH2NODE: {
                 Match2Node iVisited = (Match2Node) node;
                 IRubyObject recv = evalInternal(context, iVisited.getReceiverNode(), self);
                 IRubyObject value = evalInternal(context, iVisited.getValueNode(), self);
     
                 return ((RubyRegexp) recv).match(value);
             }
             case NodeTypes.MATCH3NODE: {
                 Match3Node iVisited = (Match3Node) node;
                 IRubyObject recv = evalInternal(context, iVisited.getReceiverNode(), self);
                 IRubyObject value = evalInternal(context, iVisited.getValueNode(), self);
     
                 if (value instanceof RubyString) {
                     return ((RubyRegexp) recv).match(value);
                 } else {
                     return value.callMethod(context, "=~", recv);
                 }
             }
             case NodeTypes.MATCHNODE: {
                 MatchNode iVisited = (MatchNode) node;
                 return ((RubyRegexp) evalInternal(context, iVisited.getRegexpNode(), self)).match2();
             }
             case NodeTypes.MODULENODE: {
                 ModuleNode iVisited = (ModuleNode) node;
                 Node classNameNode = iVisited.getCPath();
                 String name = ((INameNode) classNameNode).getName();
                 RubyModule enclosingModule = getEnclosingModule(context, classNameNode, self);
     
                 if (enclosingModule == null) {
                     throw runtime.newTypeError("no outer class/module");
                 }
     
                 RubyModule module;
                 if (enclosingModule == runtime.getObject()) {
                     module = runtime.getOrCreateModule(name);
                 } else {
                     module = enclosingModule.defineModuleUnder(name);
                 }
                 return evalClassDefinitionBody(context, iVisited.getScope(), iVisited.getBodyNode(), module, self);
             }
             case NodeTypes.MULTIPLEASGNNODE: {
                 MultipleAsgnNode iVisited = (MultipleAsgnNode) node;
                 return AssignmentVisitor.assign(context, self, iVisited, evalInternal(context,
                         iVisited.getValueNode(), self), false);
             }
             case NodeTypes.NEWLINENODE: {
                 NewlineNode iVisited = (NewlineNode) node;
     
                 // something in here is used to build up ruby stack trace...
                 context.setPosition(iVisited.getPosition());
     
                 if (isTrace(runtime)) {
                     callTraceFunction(context, "line", self);
                 }
     
                 // TODO: do above but not below for additional newline nodes
                 node = iVisited.getNextNode();
                 continue bigloop;
             }
             case NodeTypes.NEXTNODE: {
                 NextNode iVisited = (NextNode) node;
     
                 context.pollThreadEvents();
     
                 IRubyObject result = evalInternal(context, iVisited.getValueNode(), self);
     
                 // now used as an interpreter event
                 JumpException je = new JumpException(JumpException.JumpType.NextJump);
     
                 je.setPrimaryData(result);
                 je.setSecondaryData(iVisited);
     
                 //state.setCurrentException(je);
                 throw je;
             }
             case NodeTypes.NILNODE:
                 return runtime.getNil();
             case NodeTypes.NOTNODE: {
                 NotNode iVisited = (NotNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getConditionNode(), self);
                 return result.isTrue() ? runtime.getFalse() : runtime.getTrue();
             }
             case NodeTypes.NTHREFNODE: {
                 NthRefNode iVisited = (NthRefNode) node;
                 return RubyRegexp.nth_match(iVisited.getMatchNumber(), context.getBackref());
             }
             case NodeTypes.OPASGNANDNODE: {
                 BinaryOperatorNode iVisited = (BinaryOperatorNode) node;
     
                 // add in reverse order
                 IRubyObject result = evalInternal(context, iVisited.getFirstNode(), self);
                 if (!result.isTrue()) return result;
                 node = iVisited.getSecondNode();
                 continue bigloop;
             }
             case NodeTypes.OPASGNNODE: {
                 OpAsgnNode iVisited = (OpAsgnNode) node;
                 IRubyObject receiver = evalInternal(context, iVisited.getReceiverNode(), self);
                 IRubyObject value = receiver.callMethod(context, iVisited.getVariableName());
     
                 if (iVisited.getOperatorName() == "||") {
                     if (value.isTrue()) {
                         return value;
                     }
                     value = evalInternal(context, iVisited.getValueNode(), self);
                 } else if (iVisited.getOperatorName() == "&&") {
                     if (!value.isTrue()) {
                         return value;
                     }
                     value = evalInternal(context, iVisited.getValueNode(), self);
                 } else {
                     value = value.callMethod(context, iVisited.getOperatorName(), evalInternal(context,
                             iVisited.getValueNode(), self));
                 }
     
                 receiver.callMethod(context, iVisited.getVariableNameAsgn(), value);
     
                 context.pollThreadEvents();
     
                 return value;
             }
             case NodeTypes.OPASGNORNODE: {
                 OpAsgnOrNode iVisited = (OpAsgnOrNode) node;
                 String def = getDefinition(context, iVisited.getFirstNode(), self);
     
                 IRubyObject result = runtime.getNil();
                 if (def != null) {
                     result = evalInternal(context, iVisited.getFirstNode(), self);
                 }
                 if (!result.isTrue()) {
                     result = evalInternal(context, iVisited.getSecondNode(), self);
                 }
     
                 return result;
             }
             case NodeTypes.OPELEMENTASGNNODE: {
                 OpElementAsgnNode iVisited = (OpElementAsgnNode) node;
                 IRubyObject receiver = evalInternal(context, iVisited.getReceiverNode(), self);
     
                 IRubyObject[] args = setupArgs(context, iVisited.getArgsNode(), self);
     
                 IRubyObject firstValue = receiver.callMethod(context, "[]", args);
     
                 if (iVisited.getOperatorName() == "||") {
                     if (firstValue.isTrue()) {
                         return firstValue;
                     }
                     firstValue = evalInternal(context, iVisited.getValueNode(), self);
                 } else if (iVisited.getOperatorName() == "&&") {
                     if (!firstValue.isTrue()) {
                         return firstValue;
                     }
                     firstValue = evalInternal(context, iVisited.getValueNode(), self);
                 } else {
                     firstValue = firstValue.callMethod(context, iVisited.getOperatorName(), evalInternal(context, iVisited
                                     .getValueNode(), self));
                 }
     
                 IRubyObject[] expandedArgs = new IRubyObject[args.length + 1];
                 System.arraycopy(args, 0, expandedArgs, 0, args.length);
                 expandedArgs[expandedArgs.length - 1] = firstValue;
                 return receiver.callMethod(context, "[]=", expandedArgs);
             }
             case NodeTypes.OPTNNODE: {
                 OptNNode iVisited = (OptNNode) node;
     
                 IRubyObject result = runtime.getNil();
                 while (RubyKernel.gets(runtime.getTopSelf(), IRubyObject.NULL_ARRAY).isTrue()) {
                     loop: while (true) { // Used for the 'redo' command
                         try {
                             result = evalInternal(context, iVisited.getBodyNode(), self);
                             break;
                         } catch (JumpException je) {
                             switch (je.getJumpType().getTypeId()) {
                             case JumpType.REDO:
                                 // do nothing, this iteration restarts
                                 break;
                             case JumpType.NEXT:
                                 // recheck condition
                                 break loop;
                             case JumpType.BREAK:
                                 // end loop
                                 return (IRubyObject) je.getPrimaryData();
                             default:
                                 throw je;
                             }
                         }
                     }
                 }
                 return result;
             }
             case NodeTypes.ORNODE: {
                 OrNode iVisited = (OrNode) node;
     
                 IRubyObject result = evalInternal(context, iVisited.getFirstNode(), self);
     
                 if (!result.isTrue()) {
                     result = evalInternal(context, iVisited.getSecondNode(), self);
                 }
     
                 return result;
             }
                 //                case NodeTypes.POSTEXENODE:
                 //                EvaluateVisitor.postExeNodeVisitor.execute(this, node);
                 //                break;
             case NodeTypes.REDONODE: {
                 context.pollThreadEvents();
     
                 // now used as an interpreter event
                 JumpException je = new JumpException(JumpException.JumpType.RedoJump);
     
                 je.setSecondaryData(node);
     
                 throw je;
             }
             case NodeTypes.REGEXPNODE: {
                 RegexpNode iVisited = (RegexpNode) node;
                 String lang = null;
                 int opts = iVisited.getOptions();
                 if((opts & 16) != 0) { // param n
                     lang = "n";
                 } else if((opts & 48) != 0) { // param s
                     lang = "s";
                 } else if((opts & 64) != 0) { // param s
                     lang = "u";
                 }
                 try {
                     return RubyRegexp.newRegexp(runtime, iVisited.getPattern(), lang);
                 } catch(java.util.regex.PatternSyntaxException e) {
                     throw runtime.newSyntaxError(e.getMessage());
                 }
             }
             case NodeTypes.RESCUEBODYNODE: {
                 RescueBodyNode iVisited = (RescueBodyNode) node;
                 node = iVisited.getBodyNode();
                 continue bigloop;
             }
             case NodeTypes.RESCUENODE: {
                 RescueNode iVisited = (RescueNode)node;
                 RescuedBlock : while (true) {
                     IRubyObject globalExceptionState = runtime.getGlobalVariables().get("$!");
                     boolean anotherExceptionRaised = false;
                     try {
                         // Execute rescue block
                         IRubyObject result = evalInternal(context, iVisited.getBodyNode(), self);
 
                         // If no exception is thrown execute else block
                         if (iVisited.getElseNode() != null) {
                             if (iVisited.getRescueNode() == null) {
                                 runtime.getWarnings().warn(iVisited.getElseNode().getPosition(), "else without rescue is useless");
                             }
                             result = evalInternal(context, iVisited.getElseNode(), self);
                         }
 
                         return result;
                     } catch (RaiseException raiseJump) {
                         RubyException raisedException = raiseJump.getException();
                         // TODO: Rubicon TestKernel dies without this line.  A cursory glance implies we
                         // falsely set $! to nil and this sets it back to something valid.  This should 
                         // get fixed at the same time we address bug #1296484.
                         runtime.getGlobalVariables().set("$!", raisedException);
 
                         RescueBodyNode rescueNode = iVisited.getRescueNode();
 
                         while (rescueNode != null) {
                             Node  exceptionNodes = rescueNode.getExceptionNodes();
                             ListNode exceptionNodesList;
                             
                             if (exceptionNodes instanceof SplatNode) {                    
                                 exceptionNodesList = (ListNode) evalInternal(context, exceptionNodes, self);
                             } else {
                                 exceptionNodesList = (ListNode) exceptionNodes;
                             }
                             
                             if (isRescueHandled(context, raisedException, exceptionNodesList, self)) {
                                 try {
                                     return evalInternal(context, rescueNode, self);
                                 } catch (JumpException je) {
                                     if (je.getJumpType() == JumpException.JumpType.RetryJump) {
                                         // should be handled in the finally block below
                                         //state.runtime.getGlobalVariables().set("$!", state.runtime.getNil());
                                         //state.threadContext.setRaisedException(null);
                                         continue RescuedBlock;
                                         
                                     } else {
                                         anotherExceptionRaised = true;
                                         throw je;
                                     }
                                 }
                             }
                             
                             rescueNode = rescueNode.getOptRescueNode();
                         }
 
                         // no takers; bubble up
                         throw raiseJump;
                     } finally {
                         // clear exception when handled or retried
                         if (!anotherExceptionRaised)
                             runtime.getGlobalVariables().set("$!", globalExceptionState);
                     }
                 }
             }
             case NodeTypes.RETRYNODE: {
                 context.pollThreadEvents();
     
diff --git a/src/org/jruby/exceptions/RaiseException.java b/src/org/jruby/exceptions/RaiseException.java
index 63dfd2cd56..6a627101f0 100644
--- a/src/org/jruby/exceptions/RaiseException.java
+++ b/src/org/jruby/exceptions/RaiseException.java
@@ -1,128 +1,128 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Joey Gibson <joey@joeygibson.com>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.exceptions;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 
 import org.jruby.*;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class RaiseException extends JumpException {
 	private static final long serialVersionUID = -7612079169559973951L;
 	
 	private RubyException exception;
 
     public RaiseException(RubyException actException) {
     	this(actException, false);
     }
 
     public RaiseException(IRuby runtime, RubyClass excptnClass, String msg, boolean nativeException) {
 		super(msg, JumpType.RaiseJump);
         if (msg == null) {
             msg = "No message available";
         }
-        setException((RubyException) excptnClass.callMethod(runtime.getCurrentContext(), "new", excptnClass.getRuntime().newString(msg)), nativeException);
+        setException((RubyException) excptnClass.newInstance(new IRubyObject[] {excptnClass.getRuntime().newString(msg)}), nativeException);
     }
 
     public RaiseException(RubyException exception, boolean isNativeException) {
         super(JumpType.RaiseJump);
         setException(exception, isNativeException);
     }
 
     public static RaiseException createNativeRaiseException(IRuby runtime, Throwable cause) {
         NativeException nativeException = new NativeException(runtime, runtime.getClass(NativeException.CLASS_NAME), cause);
         return new RaiseException(cause, nativeException);
     }
 
     private static String buildMessage(Throwable exception) {
 	    StringBuffer sb = new StringBuffer();
 	    StringWriter stackTrace = new StringWriter();
 	    exception.printStackTrace(new PrintWriter(stackTrace));
 	
 	    sb.append("Native Exception: '").append(exception.getClass()).append("'; ");
 	    sb.append("Message: ").append(exception.getMessage()).append("; ");
 	    sb.append("StackTrace: ").append(stackTrace.getBuffer().toString());
 
 	    return sb.toString();
     }
 
     public RaiseException(Throwable cause, NativeException nativeException) {
         super(buildMessage(cause), cause, JumpType.RaiseJump);
         setException(nativeException, false);
     }
 
     /**
      * Gets the exception
      * @return Returns a RubyException
      */
     public RubyException getException() {
         return exception;
     }
 
     /**
      * Sets the exception
      * @param newException The exception to set
      */
     protected void setException(RubyException newException, boolean nativeException) {
         IRuby runtime = newException.getRuntime();
         ThreadContext context = runtime.getCurrentContext();
 
         if (!context.isWithinDefined()) {
             runtime.getGlobalVariables().set("$!", newException);
         }
 
         if (runtime.getTraceFunction() != null) {
             runtime.callTraceFunction(context, "return", context.getPosition(),
                     context.getFrameSelf(), context.getFrameLastFunc(), context.getFrameLastClass());
         }
 
         this.exception = newException;
 
         if (runtime.getStackTraces() > 5) {
             return;
         }
 
         runtime.setStackTraces(runtime.getStackTraces() + 1);
 
         if (newException.callMethod(context, "backtrace").isNil() && context.getSourceFile() != null) {
             IRubyObject backtrace = context.createBacktrace(0, nativeException);
             newException.callMethod(context, "set_backtrace", backtrace);
         }
 
         runtime.setStackTraces(runtime.getStackTraces() - 1);
     }
 }
diff --git a/src/org/jruby/ext/Generator.java b/src/org/jruby/ext/Generator.java
index b0ab924122..e1e20e0fc6 100644
--- a/src/org/jruby/ext/Generator.java
+++ b/src/org/jruby/ext/Generator.java
@@ -1,335 +1,337 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext;
 
 import java.io.IOException;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyObject;
 import org.jruby.RubyProc;
 
 import org.jruby.runtime.Arity;
 import org.jruby.runtime.CallBlock;
 import org.jruby.runtime.BlockCallback;
 import org.jruby.runtime.Iter;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 import org.jruby.runtime.load.Library;
 import org.jruby.runtime.builtin.IRubyObject;
 
 import org.jruby.internal.runtime.methods.MultiStub;
 import org.jruby.internal.runtime.methods.MultiStubMethod;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Generator {
     public static class Service implements Library {
         public void load(final IRuby runtime) throws IOException {
             createGenerator(runtime);
         }
     }
 
     public static void createGenerator(IRuby runtime) throws IOException {
-        RubyClass cGen = runtime.defineClass("Generator",runtime.getObject());
+        // FIXME: Is NOT_ALLOCATABLE_ALLOCATOR ok here. Confirm. JRUBY-415
+        RubyClass cGen = runtime.defineClass("Generator",runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         cGen.includeModule(runtime.getModule("Enumerable"));
 
         GenStub0 gstub = new GenStub0();
         gstub.gen_new = new MultiStubMethod(gstub,0,cGen,Arity.optional(),Visibility.PUBLIC);
         gstub.gen_initialize = new MultiStubMethod(gstub,1,cGen,Arity.optional(),Visibility.PUBLIC);
         gstub.gen_yield = new MultiStubMethod(gstub,2,cGen,Arity.singleArgument(),Visibility.PUBLIC);
         gstub.gen_end_p = new MultiStubMethod(gstub,3,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_next_p = new MultiStubMethod(gstub,4,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_index = new MultiStubMethod(gstub,5,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_next = new MultiStubMethod(gstub,6,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_current = new MultiStubMethod(gstub,7,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_rewind = new MultiStubMethod(gstub,8,cGen,Arity.noArguments(),Visibility.PUBLIC);
         gstub.gen_each = new MultiStubMethod(gstub,9,cGen,Arity.noArguments(),Visibility.PUBLIC);
        
         cGen.addSingletonMethod("new",gstub.gen_new);
         cGen.addMethod("initialize",gstub.gen_initialize);
         cGen.addMethod("yield",gstub.gen_yield);
         cGen.addMethod("end?",gstub.gen_end_p);
         cGen.addMethod("next?",gstub.gen_next_p);
         cGen.addMethod("index",gstub.gen_index);
         cGen.defineAlias("pos","index");
         cGen.addMethod("next",gstub.gen_next);
         cGen.addMethod("current",gstub.gen_current);
         cGen.addMethod("rewind",gstub.gen_rewind);
         cGen.addMethod("each",gstub.gen_each);
     }
 
     static class GeneratorData implements Runnable {
         private IRubyObject gen;
         private Object mutex = new Object();
 
         private IRubyObject enm;
         private RubyProc proc;
 
         private Thread t;
         private boolean end;
         private IterBlockCallback ibc;
 
         public GeneratorData(IRubyObject gen) {
             this.gen = gen;
         }
 
         public void setEnum(IRubyObject enm) {
             this.proc = null;
             this.enm = enm;
             start();
         }
 
         public void setProc(RubyProc proc) {
             this.proc = proc;
             this.enm = null;
             start();
         }
 
         public void start() {
             end = false;
             ibc = new IterBlockCallback();
             t = new Thread(this);
             t.setDaemon(true);
             t.start();
             generate();
         }
 
         public boolean isEnd() {
             return end;
         }
 
         private boolean available = false;
 
         public void doWait() {
             available = true;
             if(proc != null) {
                 boolean inter = true;
                 synchronized(mutex) {
                     mutex.notifyAll();
                     while(inter) {
                         try {
                             mutex.wait();
                             inter = false;
                         } catch(InterruptedException e) {
                         }
                     }
                 }
             }
         }
 
         public void generate() {
             if(proc == null) {
                 boolean inter = true;
                 synchronized(mutex) {
                     while(!ibc.haveValue() && !end) {
                         mutex.notifyAll();
                         inter = true;
                         while(inter) {
                             try {
                                 mutex.wait();
                                 inter = false;
                             } catch(InterruptedException e) {
                             }
                         }
                     }
                     if(!end && proc == null) {
                         gen.callMethod(gen.getRuntime().getCurrentContext(),"yield",ibc.pop());
                     }
                 }
             } else {
                 synchronized(mutex) {
                     while(!available && !end) {
                         boolean inter = true;
                         mutex.notifyAll();
                         while(inter) {
                             try {
                                 mutex.wait(20);
                                 inter = false;
                             } catch(InterruptedException e) {
                             }
                         }
                     }
                     available = false;
                 }
             }
 
         }
 
         private class IterBlockCallback implements BlockCallback {
             private IRubyObject obj;
             public IRubyObject call(ThreadContext context, IRubyObject[] iargs, IRubyObject iself) {
                 boolean inter = true;
                 synchronized(mutex) {
                     mutex.notifyAll();
                     while(inter) {
                         try {
                             mutex.wait();
                             inter = false;
                         } catch(InterruptedException e) {
                         }
                     }
                     if(iargs.length > 1) {
                         obj = gen.getRuntime().newArray(iargs);
                     } else {
                         obj = iargs[0];
                     }
                     mutex.notifyAll();
                     return gen.getRuntime().getNil();
                 }
             }
             public boolean haveValue() {
                 return obj != null;
             }
             public IRubyObject pop() {
                 IRubyObject a = obj;
                 obj = null;
                 return a;
             }
         }
 
         public void run() {
             if(enm != null) {
                 ThreadContext context = gen.getRuntime().getCurrentContext();
                 Iter bef = context.getFrameIter();
                 context.preBlockPassEval(new CallBlock(enm,enm.getMetaClass().getRealClass(),Arity.noArguments(),ibc,context));
                 enm.callMethod(context, "each");
                 context.postBlockPassEval();
                 context.setFrameIter(bef);
                 end = true;
             } else {
                 proc.call(new IRubyObject[]{gen});
                 end = true;
             }
         }
     }
 
     public static class GenStub0 implements MultiStub {
         public MultiStubMethod gen_new;
         public MultiStubMethod gen_initialize;
         public MultiStubMethod gen_yield;
         public MultiStubMethod gen_end_p;
         public MultiStubMethod gen_next_p;
         public MultiStubMethod gen_index;
         public MultiStubMethod gen_next;
         public MultiStubMethod gen_current;
         public MultiStubMethod gen_rewind;
         public MultiStubMethod gen_each;
 
         public IRubyObject method0(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#new
             IRubyObject result = new RubyObject(self.getRuntime(),(RubyClass)self);
             result.dataWrapStruct(new GeneratorData(result));
             result.callInit(args);
             return result;
         }
 
         public IRubyObject method1(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#initialize
             GeneratorData d = (GeneratorData)self.dataGetStruct();
 
             self.setInstanceVariable("@queue",self.getRuntime().newArray());
             self.setInstanceVariable("@index",self.getRuntime().newFixnum(0));
 
             if(self.checkArgumentCount(args,0,1) == 1) {
                 d.setEnum(args[0]);
             } else {
                 d.setProc(RubyProc.newProc(self.getRuntime(),false));
             }
             return self;
         }
 
         public IRubyObject method2(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#yield
             self.getInstanceVariable("@queue").callMethod(context,"<<",args[0]);
             GeneratorData d = (GeneratorData)self.dataGetStruct();
             d.doWait();
             return self;
         }
 
         public IRubyObject method3(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#end_p
             GeneratorData d = (GeneratorData)self.dataGetStruct();
             return d.isEnd() ? self.getRuntime().getTrue() : self.getRuntime().getFalse();
         }
 
         public IRubyObject method4(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#next_p
             GeneratorData d = (GeneratorData)self.dataGetStruct();
             return !d.isEnd() ? self.getRuntime().getTrue() : self.getRuntime().getFalse();
         }
 
         public IRubyObject method5(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#index
             return self.getInstanceVariable("@index");
         }
 
         public IRubyObject method6(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#next
             GeneratorData d = (GeneratorData)self.dataGetStruct();
             if(d.isEnd()) {
                 throw self.getRuntime().newEOFError();
             }
             d.generate();
             self.setInstanceVariable("@index",self.getInstanceVariable("@index").callMethod(context,"+",self.getRuntime().newFixnum(1)));
             return self.getInstanceVariable("@queue").callMethod(context,"shift");
         }
 
         public IRubyObject method7(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#current
             if(self.getInstanceVariable("@queue").callMethod(context,"empty?").isTrue()) {
                 throw self.getRuntime().newEOFError();
             }
             return self.getInstanceVariable("@queue").callMethod(context,"first");
         }
 
         public IRubyObject method8(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#rewind
             if(self.getInstanceVariable("@index").callMethod(context,"nonzero?").isTrue()) {
                 GeneratorData d = (GeneratorData)self.dataGetStruct();
 
                 self.setInstanceVariable("@queue",self.getRuntime().newArray());
                 self.setInstanceVariable("@index",self.getRuntime().newFixnum(0));
             
                 d.start();
             }
 
             return self;
         }
 
         public IRubyObject method9(ThreadContext context, IRubyObject self, IRubyObject[] args) {
             // Generator#each
             self.callMethod(context,"rewind");
             while(self.callMethod(context,"next?").isTrue()) {
                 context.yield(self.callMethod(context,"next"));
             }
             return self;
         }
     }
 }// Generator
diff --git a/src/org/jruby/ext/openssl/ASN1.java b/src/org/jruby/ext/openssl/ASN1.java
index c08d8bc90b..9f2f4f77bd 100644
--- a/src/org/jruby/ext/openssl/ASN1.java
+++ b/src/org/jruby/ext/openssl/ASN1.java
@@ -1,895 +1,877 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.math.BigInteger;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.bouncycastle.asn1.ASN1Encodable;
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.ASN1Sequence;
 import org.bouncycastle.asn1.DERBitString;
 import org.bouncycastle.asn1.DERBoolean;
 import org.bouncycastle.asn1.DEREncodableVector;
 import org.bouncycastle.asn1.DERInteger;
 import org.bouncycastle.asn1.DERNull;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DEROctetString;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERSet;
 import org.bouncycastle.asn1.DERString;
 import org.bouncycastle.asn1.DERTaggedObject;
 import org.bouncycastle.asn1.DERUTCTime;
 import org.bouncycastle.asn1.DERUTF8String;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyBignum;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.RubyString;
 import org.jruby.RubySymbol;
 import org.jruby.RubyTime;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class ASN1 {
     private static Map SYM_TO_OID = new IdentityHashMap();
     private static Map OID_TO_SYM = new IdentityHashMap();
     private static Map OID_TO_NID = new IdentityHashMap();
     private static Map NID_TO_OID = new IdentityHashMap();
     private static Map NID_TO_SN = new IdentityHashMap();
     private static Map NID_TO_LN = new IdentityHashMap();
 
 
     static void addObject(IRuby runtime, int nid, String sn, String ln, String oid) {
         Map s2o = (Map)SYM_TO_OID.get(runtime);
         Map o2s = (Map)OID_TO_SYM.get(runtime);
         Map o2n = (Map)OID_TO_NID.get(runtime);
         Map n2o = (Map)NID_TO_OID.get(runtime);
         Map n2s = (Map)NID_TO_SN.get(runtime);
         Map n2l = (Map)NID_TO_LN.get(runtime);
         if(null != oid && (null != sn || null != ln)) {
             DERObjectIdentifier ident = new DERObjectIdentifier(oid);
             Integer i_nid = new Integer(nid);
             if(sn != null) {
                 s2o.put(sn.toLowerCase(),ident);
             }
             if(ln != null) {
                 s2o.put(ln.toLowerCase(),ident);
             }
             o2s.put(ident,sn == null ? ln : sn);
             o2n.put(ident,i_nid);
             n2o.put(i_nid,ident);
             n2s.put(i_nid,sn);
             n2l.put(i_nid,ln);
         }        
     }
 
     private synchronized static void initMaps(IRuby runtime) {
         Object val = new HashMap(org.bouncycastle.asn1.x509.X509Name.DefaultLookUp);
         Object val2 = new HashMap(org.bouncycastle.asn1.x509.X509Name.DefaultSymbols);
         SYM_TO_OID.put(runtime,val);
         OID_TO_SYM.put(runtime,val2);
         OID_TO_NID.put(runtime,new HashMap());
         NID_TO_OID.put(runtime,new HashMap());
         NID_TO_SN.put(runtime,new HashMap());
         NID_TO_LN.put(runtime,new HashMap());
         OpenSSLImpl.defaultObjects(runtime);
     }
 
     synchronized static Integer obj2nid(IRuby runtime, String oid) {
         return obj2nid(runtime, new DERObjectIdentifier(oid));
     }
 
     synchronized static Integer obj2nid(IRuby runtime, DERObjectIdentifier oid) {
         Map o2n = (Map)OID_TO_NID.get(runtime);
         if(null == o2n) {
             initMaps(runtime);
             o2n = (Map)OID_TO_NID.get(runtime);
         }
         return (Integer)o2n.get(oid);
     }
 
     synchronized static String o2a(IRuby runtime, DERObjectIdentifier obj) {
         Integer nid = obj2nid(runtime,obj);
         Map n2l = (Map)NID_TO_LN.get(runtime);
         Map n2s = (Map)NID_TO_SN.get(runtime);
         String one = (String)n2l.get(nid);
         if(one == null) {
             one = (String)n2s.get(nid);
         }
         return one;
     }
 
     synchronized static String nid2ln(IRuby runtime, int nid) {
         return nid2ln(runtime, new Integer(nid));
     }
 
     synchronized static String nid2ln(IRuby runtime, Integer nid) {
         Map n2l = (Map)NID_TO_LN.get(runtime);
         if(null == n2l) {
             initMaps(runtime);
             n2l = (Map)NID_TO_LN.get(runtime);
         }
         return (String)n2l.get(nid);
     }
     
     synchronized static Map getOIDLookup(IRuby runtime) {
         Object val = SYM_TO_OID.get(runtime);
         if(null == val) {
             initMaps(runtime);
             val = SYM_TO_OID.get(runtime);
         }
         return (Map)val;
     }
 
     synchronized static Map getSymLookup(IRuby runtime) {
         Object val = OID_TO_SYM.get(runtime);
         if(null == val) {
             initMaps(runtime);
             val = OID_TO_SYM.get(runtime);
         }
         return (Map)val;
     }
 
     private final static Object[][] ASN1_INFO = {
         {"EOC", null, null },
         {"BOOLEAN", org.bouncycastle.asn1.DERBoolean.class, "Boolean" },
         {"INTEGER", org.bouncycastle.asn1.DERInteger.class, "Integer" }, 
         {"BIT_STRING",  org.bouncycastle.asn1.DERBitString.class, "BitString" },
         {"OCTET_STRING",  org.bouncycastle.asn1.DEROctetString.class, "OctetString" },
         {"NULL",  org.bouncycastle.asn1.DERNull.class, "Null" },
         {"OBJECT",  org.bouncycastle.asn1.DERObjectIdentifier.class, "ObjectId" },
         {"OBJECT_DESCRIPTOR",  null, null },
         {"EXTERNAL",  null, null },
         {"REAL",  null, null },
         {"ENUMERATED",  org.bouncycastle.asn1.DEREnumerated.class, "Enumerated" },
         {"EMBEDDED_PDV",  null, null },
         {"UTF8STRING",  org.bouncycastle.asn1.DERUTF8String.class, "UTF8String" },
         {"RELATIVE_OID",  null, null },
         {"[UNIVERSAL 14]",  null, null },
         {"[UNIVERSAL 15]",  null, null },
         {"SEQUENCE",  org.bouncycastle.asn1.DERSequence.class, "Sequence" },
         {"SET",  org.bouncycastle.asn1.DERSet.class, "Set" },
         {"NUMERICSTRING",  org.bouncycastle.asn1.DERNumericString.class, "NumericString" },
         {"PRINTABLESTRING",  org.bouncycastle.asn1.DERPrintableString.class, "PrintableString" },
         {"T61STRING",  org.bouncycastle.asn1.DERT61String.class, "T61String" },
         {"VIDEOTEXSTRING", null, null },
         {"IA5STRING",  org.bouncycastle.asn1.DERIA5String.class, "IA5String" },
         {"UTCTIME",  org.bouncycastle.asn1.DERUTCTime.class, "UTCTime" },
         {"GENERALIZEDTIME",  org.bouncycastle.asn1.DERGeneralizedTime.class, "GeneralizedTime" },
         {"GRAPHICSTRING",  null, null },
         {"ISO64STRING",  null, null },
         {"GENERALSTRING",  org.bouncycastle.asn1.DERGeneralString.class, "GeneralString" },
         {"UNIVERSALSTRING",  org.bouncycastle.asn1.DERUniversalString.class, "UniversalString" },
         {"CHARACTER_STRING",  null, null },
         {"BMPSTRING", org.bouncycastle.asn1.DERBMPString.class, "BMPString" }};
 
     private final static Map CLASS_TO_ID = new HashMap();
     private final static Map RUBYNAME_TO_ID = new HashMap();
     
     static {
         for(int i=0;i<ASN1_INFO.length;i++) {
             if(ASN1_INFO[i][1] != null) {
                 CLASS_TO_ID.put(ASN1_INFO[i][1],new Integer(i));
             }
             if(ASN1_INFO[i][2] != null) {
                 RUBYNAME_TO_ID.put(ASN1_INFO[i][2],new Integer(i));
             }
         }
     }
 
     public static int idForClass(Class type) {
         Integer v = null;
         while(type != Object.class && v == null) {
             v = (Integer)CLASS_TO_ID.get(type);
             if(v == null) {
                 type = type.getSuperclass();
             }
         }
         return null == v ? -1 : v.intValue();
     }
 
     public static int idForRubyName(String name) {
         Integer v = (Integer)RUBYNAME_TO_ID.get(name);
         return null == v ? -1 : v.intValue();
     }
 
     public static Class classForId(int id) {
         return (Class)(ASN1_INFO[id][1]);
     }
     
     public static void createASN1(IRuby runtime, RubyModule ossl) {
         RubyModule mASN1 = ossl.defineModuleUnder("ASN1");
-        mASN1.defineClassUnder("ASN1Error",ossl.getClass("OpenSSLError"));
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mASN1.defineClassUnder("ASN1Error",openSSLError, openSSLError.getAllocator());
 
         CallbackFactory asncb = runtime.callbackFactory(ASN1.class);
         mASN1.defineSingletonMethod("traverse",asncb.getSingletonMethod("traverse",IRubyObject.class));
         mASN1.defineSingletonMethod("decode",asncb.getSingletonMethod("decode",IRubyObject.class));
         mASN1.defineSingletonMethod("decode_all",asncb.getSingletonMethod("decode_all",IRubyObject.class));
 
         List ary = new ArrayList();
         mASN1.setConstant("UNIVERSAL_TAG_NAME",runtime.newArray(ary));
         for(int i=0;i<ASN1_INFO.length;i++) {
             if(((String)(ASN1_INFO[i][0])).charAt(0) != '[') {
                 ary.add(runtime.newString(((String)(ASN1_INFO[i][0]))));
                 mASN1.setConstant(((String)(ASN1_INFO[i][0])),runtime.newFixnum(i));
             } else {
                 ary.add(runtime.getNil());
             }
         }
 
-        RubyClass cASN1Data = mASN1.defineClassUnder("ASN1Data",runtime.getObject());
+        RubyClass cASN1Data = mASN1.defineClassUnder("ASN1Data",runtime.getObject(), runtime.getObject().getAllocator());
         cASN1Data.attr_accessor(new IRubyObject[]{runtime.newString("value"),runtime.newString("tag"),runtime.newString("tag_class")});
         CallbackFactory asn1datacb = runtime.callbackFactory(ASN1Data.class);
-        cASN1Data.defineSingletonMethod("new",asn1datacb.getOptSingletonMethod("newInstance"));
         cASN1Data.defineMethod("initialize",asn1datacb.getOptMethod("initialize"));
         cASN1Data.defineMethod("to_der",asn1datacb.getMethod("to_der"));
 
-        RubyClass cASN1Primitive = mASN1.defineClassUnder("Primitive",cASN1Data);
+        RubyClass cASN1Primitive = mASN1.defineClassUnder("Primitive",cASN1Data, cASN1Data.getAllocator());
         cASN1Primitive.attr_accessor(new IRubyObject[]{runtime.newString("tagging")});
         CallbackFactory primcb = runtime.callbackFactory(ASN1Primitive.class);
-        cASN1Primitive.defineSingletonMethod("new",primcb.getOptSingletonMethod("newInstance"));
         cASN1Primitive.defineMethod("initialize",primcb.getOptMethod("initialize"));
         cASN1Primitive.defineMethod("to_der",primcb.getMethod("to_der"));
 
-        RubyClass cASN1Constructive = mASN1.defineClassUnder("Constructive",cASN1Data);
+        RubyClass cASN1Constructive = mASN1.defineClassUnder("Constructive",cASN1Data,cASN1Data.getAllocator());
         cASN1Constructive.includeModule(runtime.getModule("Enumerable"));
         cASN1Constructive.attr_accessor(new IRubyObject[]{runtime.newString("tagging")});
         CallbackFactory concb = runtime.callbackFactory(ASN1Constructive.class);
-        cASN1Constructive.defineSingletonMethod("new",concb.getOptSingletonMethod("newInstance"));
         cASN1Constructive.defineMethod("initialize",concb.getOptMethod("initialize"));
         cASN1Constructive.defineMethod("to_der",concb.getMethod("to_der"));
         cASN1Constructive.defineMethod("each",concb.getMethod("each"));
 
         mASN1.defineSingletonMethod("Boolean",asncb.getOptSingletonMethod("fact_Boolean"));
         mASN1.defineSingletonMethod("Integer",asncb.getOptSingletonMethod("fact_Integer"));
         mASN1.defineSingletonMethod("Enumerated",asncb.getOptSingletonMethod("fact_Enumerated"));
         mASN1.defineSingletonMethod("BitString",asncb.getOptSingletonMethod("fact_BitString"));
         mASN1.defineSingletonMethod("OctetString",asncb.getOptSingletonMethod("fact_OctetString"));
         mASN1.defineSingletonMethod("UTF8String",asncb.getOptSingletonMethod("fact_UTF8String"));
         mASN1.defineSingletonMethod("NumericString",asncb.getOptSingletonMethod("fact_NumericString"));
         mASN1.defineSingletonMethod("PrintableString",asncb.getOptSingletonMethod("fact_PrintableString"));
         mASN1.defineSingletonMethod("T61String",asncb.getOptSingletonMethod("fact_T61String"));
         mASN1.defineSingletonMethod("VideotexString",asncb.getOptSingletonMethod("fact_VideotexString"));
         mASN1.defineSingletonMethod("IA5String",asncb.getOptSingletonMethod("fact_IA5String"));
         mASN1.defineSingletonMethod("GraphicString",asncb.getOptSingletonMethod("fact_GraphicString"));
         mASN1.defineSingletonMethod("ISO64String",asncb.getOptSingletonMethod("fact_ISO64String"));
         mASN1.defineSingletonMethod("GeneralString",asncb.getOptSingletonMethod("fact_GeneralString"));
         mASN1.defineSingletonMethod("UniversalString",asncb.getOptSingletonMethod("fact_UniversalString"));
         mASN1.defineSingletonMethod("BMPString",asncb.getOptSingletonMethod("fact_BMPString"));
         mASN1.defineSingletonMethod("Null",asncb.getOptSingletonMethod("fact_Null"));
         mASN1.defineSingletonMethod("ObjectId",asncb.getOptSingletonMethod("fact_ObjectId"));
         mASN1.defineSingletonMethod("UTCTime",asncb.getOptSingletonMethod("fact_UTCTime"));
         mASN1.defineSingletonMethod("GeneralizedTime",asncb.getOptSingletonMethod("fact_GeneralizedTime"));
         mASN1.defineSingletonMethod("Sequence",asncb.getOptSingletonMethod("fact_Sequence"));
         mASN1.defineSingletonMethod("Set",asncb.getOptSingletonMethod("fact_Set"));
 
-        mASN1.defineClassUnder("Boolean",cASN1Primitive);
-        mASN1.defineClassUnder("Integer",cASN1Primitive);
-        mASN1.defineClassUnder("Enumerated",cASN1Primitive);
-        RubyClass cASN1BitString = mASN1.defineClassUnder("BitString",cASN1Primitive);
-        mASN1.defineClassUnder("OctetString",cASN1Primitive);
-        mASN1.defineClassUnder("UTF8String",cASN1Primitive);
-        mASN1.defineClassUnder("NumericString",cASN1Primitive);
-        mASN1.defineClassUnder("PrintableString",cASN1Primitive);
-        mASN1.defineClassUnder("T61String",cASN1Primitive);
-        mASN1.defineClassUnder("VideotexString",cASN1Primitive);
-        mASN1.defineClassUnder("IA5String",cASN1Primitive);
-        mASN1.defineClassUnder("GraphicString",cASN1Primitive);
-        mASN1.defineClassUnder("ISO64String",cASN1Primitive);
-        mASN1.defineClassUnder("GeneralString",cASN1Primitive);
-        mASN1.defineClassUnder("UniversalString",cASN1Primitive);
-        mASN1.defineClassUnder("BMPString",cASN1Primitive);
-        mASN1.defineClassUnder("Null",cASN1Primitive);
-        RubyClass cASN1ObjectId = mASN1.defineClassUnder("ObjectId",cASN1Primitive);
-        mASN1.defineClassUnder("UTCTime",cASN1Primitive);
-        mASN1.defineClassUnder("GeneralizedTime",cASN1Primitive);
-        mASN1.defineClassUnder("Sequence",cASN1Constructive);
-        mASN1.defineClassUnder("Set",cASN1Constructive);
+        mASN1.defineClassUnder("Boolean",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("Integer",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("Enumerated",cASN1Primitive,cASN1Primitive.getAllocator());
+        RubyClass cASN1BitString = mASN1.defineClassUnder("BitString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("OctetString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("UTF8String",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("NumericString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("PrintableString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("T61String",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("VideotexString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("IA5String",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("GraphicString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("ISO64String",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("GeneralString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("UniversalString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("BMPString",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("Null",cASN1Primitive,cASN1Primitive.getAllocator());
+        RubyClass cASN1ObjectId = mASN1.defineClassUnder("ObjectId",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("UTCTime",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("GeneralizedTime",cASN1Primitive,cASN1Primitive.getAllocator());
+        mASN1.defineClassUnder("Sequence",cASN1Constructive,cASN1Constructive.getAllocator());
+        mASN1.defineClassUnder("Set",cASN1Constructive,cASN1Constructive.getAllocator());
 
         cASN1ObjectId.defineSingletonMethod("register",asncb.getOptSingletonMethod("objectid_register"));
         cASN1ObjectId.defineMethod("sn",asncb.getSingletonMethod("objectid_sn"));
         cASN1ObjectId.defineMethod("ln",asncb.getSingletonMethod("objectid_ln"));
         cASN1ObjectId.defineMethod("short_name",asncb.getSingletonMethod("objectid_sn"));
         cASN1ObjectId.defineMethod("long_name",asncb.getSingletonMethod("objectid_ln"));
         cASN1ObjectId.defineMethod("oid",asncb.getSingletonMethod("objectid_oid"));
 
         cASN1BitString.attr_accessor(new IRubyObject[]{runtime.newSymbol("unused_bits")});
     }
 
     public static IRubyObject objectid_register(IRubyObject recv, IRubyObject[] args) {
         DERObjectIdentifier deroi = new DERObjectIdentifier(args[0].toString());
         getOIDLookup(recv.getRuntime()).put(args[1].toString().toLowerCase(),deroi);
         getOIDLookup(recv.getRuntime()).put(args[2].toString().toLowerCase(),deroi);
         getSymLookup(recv.getRuntime()).put(deroi,args[1].toString());
         return recv.getRuntime().getTrue();
     }
 
     public static IRubyObject objectid_sn(IRubyObject self) {
         return self.getRuntime().newString(getShortNameFor(self.getRuntime(),self.callMethod(self.getRuntime().getCurrentContext(),"value").toString()));
     }
 
     public static IRubyObject objectid_ln(IRubyObject self) {
         return self.getRuntime().newString(getLongNameFor(self.getRuntime(),self.callMethod(self.getRuntime().getCurrentContext(),"value").toString()));
     }
 
     public static IRubyObject objectid_oid(IRubyObject self) {
         return self.getRuntime().newString(getObjectIdentifier(self.getRuntime(),self.callMethod(self.getRuntime().getCurrentContext(),"value").toString()).getId());
     }
 
     private static String getShortNameFor(IRuby runtime, String nameOrOid) {
         DERObjectIdentifier oid = getObjectIdentifier(runtime,nameOrOid);
         Map em = getOIDLookup(runtime);
         String name = null;
         for(Iterator iter = em.keySet().iterator();iter.hasNext();) {
             Object key = iter.next();
             if(oid.equals(em.get(key))) {
                 if(name == null || ((String)key).length() < name.length()) {
                     name = (String)key;
                 }
             }
         }
         return name;
     }
 
     private static String getLongNameFor(IRuby runtime, String nameOrOid) {
         DERObjectIdentifier oid = getObjectIdentifier(runtime,nameOrOid);
         Map em = getOIDLookup(runtime);
         String name = null;
         for(Iterator iter = em.keySet().iterator();iter.hasNext();) {
             Object key = iter.next();
             if(oid.equals(em.get(key))) {
                 if(name == null || ((String)key).length() > name.length()) {
                     name = (String)key;
                 }
             }
         }
         return name;
     }
 
     private static DERObjectIdentifier getObjectIdentifier(IRuby runtime, String nameOrOid) {
         Object val1 = ASN1.getOIDLookup(runtime).get(nameOrOid.toLowerCase());
         if(null != val1) {
             return (DERObjectIdentifier)val1;
         }
         DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
         return val2;
     }
     
     public static IRubyObject fact_Boolean(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Boolean").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_Integer(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Integer").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_Enumerated(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Enumerated").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_BitString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("BitString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_OctetString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("OctetString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_UTF8String(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("UTF8String").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_NumericString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("NumericString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_PrintableString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("PrintableString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_T61String(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("T61String").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_VideotexString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("VideotexString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_IA5String(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("IA5String").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_GraphicString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("GraphicString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_ISO64String(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("ISO64String").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_GeneralString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("GeneralString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_UniversalString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("UniversalString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_BMPString(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("BMPString").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_Null(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Null").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_ObjectId(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("ObjectId").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_UTCTime(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("UTCTime").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_GeneralizedTime(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("GeneralizedTime").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_Sequence(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Sequence").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject fact_Set(IRubyObject recv, IRubyObject[] args) {
         return ((RubyModule)recv).getClass("Set").callMethod(recv.getRuntime().getCurrentContext(),"new",args);
     }
 
     public static IRubyObject traverse(IRubyObject recv, IRubyObject a) {
         System.err.println("WARNING: unimplemented method called: traverse");
         return null;
     }
 
     private final static DateFormat dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
     private static IRubyObject decodeObj(RubyModule asnM,Object v) throws Exception {
         int ix = idForClass(v.getClass());
         String v_name = ix == -1 ? null : (String)(ASN1_INFO[ix][2]);
         ThreadContext tc = asnM.getRuntime().getCurrentContext();
         if(null != v_name) {
             RubyClass c = asnM.getClass(v_name);
             if(v instanceof DERBitString) {
                 String va = new String(((DERBitString)v).getBytes(),"ISO8859_1");
                 IRubyObject bString = c.callMethod(tc,"new",asnM.getRuntime().newString(va));
                 bString.callMethod(tc,"unused_bits=",asnM.getRuntime().newFixnum(((DERBitString)v).getPadBits()));
                 return bString;
             } else if(v instanceof DERString) {
                 String val = ((DERString)v).getString();
                 if(v instanceof DERUTF8String) {
                     val = new String(val.getBytes("UTF-8"),"ISO8859-1");
                 }
                 return c.callMethod(tc,"new",asnM.getRuntime().newString(val));
             } else if(v instanceof ASN1Sequence) {
                 List l = new ArrayList();
                 for(Enumeration enm = ((ASN1Sequence)v).getObjects(); enm.hasMoreElements(); ) {
                     l.add(decodeObj(asnM,enm.nextElement()));
                 }
                 return c.callMethod(tc,"new",asnM.getRuntime().newArray(l));
             } else if(v instanceof DERSet) {
                 List l = new ArrayList();
                 for(Enumeration enm = ((DERSet)v).getObjects(); enm.hasMoreElements(); ) {
                     l.add(decodeObj(asnM,enm.nextElement()));
                 }
                 return c.callMethod(tc,"new",asnM.getRuntime().newArray(l));
             } else if(v instanceof DERNull) {
                 return c.callMethod(tc,"new",asnM.getRuntime().getNil());
             } else if(v instanceof DERInteger) {
                 return c.callMethod(tc,"new",RubyNumeric.str2inum(asnM.getRuntime(),asnM.getRuntime().newString(((DERInteger)v).getValue().toString()),10));
             } else if(v instanceof DERUTCTime) {
                 Date d = dateF.parse(((DERUTCTime)v).getAdjustedTime());
                 Calendar cal = Calendar.getInstance();
                 cal.setTime(d);
                 IRubyObject[] argv = new IRubyObject[6];
                 argv[0] = asnM.getRuntime().newFixnum(cal.get(Calendar.YEAR));
                 argv[1] = asnM.getRuntime().newFixnum(cal.get(Calendar.MONTH)+1);
                 argv[2] = asnM.getRuntime().newFixnum(cal.get(Calendar.DAY_OF_MONTH));
                 argv[3] = asnM.getRuntime().newFixnum(cal.get(Calendar.HOUR_OF_DAY));
                 argv[4] = asnM.getRuntime().newFixnum(cal.get(Calendar.MINUTE));
                 argv[5] = asnM.getRuntime().newFixnum(cal.get(Calendar.SECOND));
                 return c.callMethod(tc,"new",asnM.getRuntime().getClass("Time").callMethod(tc,"local",argv));
             } else if(v instanceof DERObjectIdentifier) {
                 String av = ((DERObjectIdentifier)v).getId();
                 return c.callMethod(tc,"new",asnM.getRuntime().newString(av));
             } else if(v instanceof DEROctetString) {
                 String va = new String(((DEROctetString)v).getOctets(),"ISO8859_1");
                 return c.callMethod(tc,"new",asnM.getRuntime().newString(va));
             } else if(v instanceof DERBoolean) {
                 return c.callMethod(tc,"new",((DERBoolean)v).isTrue() ? asnM.getRuntime().getTrue() : asnM.getRuntime().getFalse());
             } else {
                 System.out.println("Should handle: " + v.getClass().getName());
             }
         } else if(v instanceof DERTaggedObject) {
             RubyClass c = asnM.getClass("ASN1Data");
             IRubyObject val = decodeObj(asnM, ((DERTaggedObject)v).getObject());
             IRubyObject tag = asnM.getRuntime().newFixnum(((DERTaggedObject)v).getTagNo());
             IRubyObject tag_class = asnM.getRuntime().newSymbol("CONTEXT_SPECIFIC");
             return c.callMethod(tc,"new",new IRubyObject[]{asnM.getRuntime().newArray(val),tag,tag_class});
         }
 
         //        System.err.println("v: " + v + "[" + v.getClass().getName() + "]");
         return null;
     }
 
     public static IRubyObject decode(IRubyObject recv, IRubyObject obj) throws Exception {
         obj = OpenSSLImpl.to_der_if_possible(obj);
         RubyModule asnM = (RubyModule)recv;
         ASN1InputStream asis = new ASN1InputStream(obj.toString().getBytes("PLAIN"));
         IRubyObject ret = decodeObj(asnM, asis.readObject());
         return ret;
     }
 
     public static IRubyObject decode_all(IRubyObject recv, IRubyObject a) {
         System.err.println("WARNING: unimplemented method called: decode_all");
         return null;
     }
 
     public static class ASN1Data extends RubyObject {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            ASN1Data result = new ASN1Data(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
 
         public ASN1Data(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         protected void asn1Error() {
             asn1Error(null);
         }
 
         protected void asn1Error(String msg) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("ASN1"))).getConstant("ASN1Error")), msg, true);
         }
 
         public IRubyObject initialize(IRubyObject[] args) {
             checkArgumentCount(args,3,3);
             IRubyObject value = args[0];
             IRubyObject tag = args[1];
             IRubyObject tag_class = args[2];
             if(!(tag_class instanceof RubySymbol)) {
                 asn1Error("invalid tag class");
             }
             if(tag_class.toString().equals(":UNIVERSAL") && RubyNumeric.fix2int(tag) > 31) {
                 asn1Error("tag number for Universal too large");
             }
             ThreadContext tc = getRuntime().getCurrentContext();
             this.callMethod(tc,"tag=", tag);
             this.callMethod(tc,"value=", value);
             this.callMethod(tc,"tag_class=", tag_class);
 
             return this;
         }
 
         ASN1Encodable toASN1() throws Exception {
             //            System.err.println(getMetaClass().getRealClass().getBaseName()+"#toASN1");
             ThreadContext tc = getRuntime().getCurrentContext();
             int tag = RubyNumeric.fix2int(callMethod(tc,"tag"));
             IRubyObject val = callMethod(tc,"value");
             if(val instanceof RubyArray) {
                 RubyArray arr = (RubyArray)callMethod(tc,"value");
                 if(arr.getList().size() > 1) {
                     ASN1EncodableVector vec = new ASN1EncodableVector();
                     for(Iterator iter = arr.getList().iterator();iter.hasNext();) {
                         vec.add(((ASN1Data)iter.next()).toASN1());
                     }
                     return new DERTaggedObject(tag, new DERSequence(vec));
                 } else {
                     return new DERTaggedObject(tag,((ASN1Data)(arr.getList().get(0))).toASN1());
                 }
             } else {
                 return new DERTaggedObject(tag, ((ASN1Data)val).toASN1());
             }
         }
 
         public IRubyObject to_der() throws Exception {
             return getRuntime().newString(new String(toASN1().getDEREncoded(),"ISO8859_1"));
         }
 
         protected IRubyObject defaultTag() {
             int i = idForRubyName(getMetaClass().getRealClass().getBaseName());
             if(i != -1) {
                 return getRuntime().newFixnum(i);
             } else {
                 return getRuntime().getNil();
             }
         }
 
         protected void print() {
             print(0);
         }
 
         protected void printIndent(int indent) {
             for(int i=0;i<indent;i++) {
                 System.out.print(" ");
             }
         }
 
         protected void print(int indent) {
             printIndent(indent);
             System.out.println("ASN1Data: ");
             IRubyObject val = callMethod(getRuntime().getCurrentContext(),"value");
             if(val instanceof RubyArray) {
                 RubyArray arr = (RubyArray)val;
                 for(Iterator iter = arr.getList().iterator();iter.hasNext();) {
                     ((ASN1Data)iter.next()).print(indent+1);
                 }
             } else {
                 ((ASN1Data)val).print(indent+1);
             }
         }
     }
 
     public static class ASN1Primitive extends ASN1Data {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            ASN1Data result = new ASN1Primitive(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public ASN1Primitive(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         public String toString() {
             return this.callMethod(getRuntime().getCurrentContext(),"value").toString();
         }
 
         public IRubyObject initialize(IRubyObject[] args) {
             checkArgumentCount(args,1,4);
             IRubyObject value = args[0];
             IRubyObject tag = getRuntime().getNil();
             IRubyObject tagging = getRuntime().getNil();
             IRubyObject tag_class = getRuntime().getNil();
             if(args.length>1) {
                 tag = args[1];
                 if(args.length>2) {
                     tagging = args[2];
                     if(args.length>3) {
                         tag_class = args[3];
                     }
                 }
                 if(tag.isNil()) {
                     asn1Error("must specify tag number");
                 }
                 if(tagging.isNil()) {
                     tagging = getRuntime().newSymbol("EXPLICIT");
                 }
                 if(!(tagging instanceof RubySymbol)) {
                     asn1Error("invalid tag default");
                 }
                 if(tag_class.isNil()) {
                     tag_class = getRuntime().newSymbol("CONTEXT_SPECIFIC");
                 }
                 if(!(tag_class instanceof RubySymbol)) {
                     asn1Error("invalid tag class");
                 }
                 if(tagging.toString().equals(":IMPLICIT") && RubyNumeric.fix2int(tag) > 31) {
                     asn1Error("tag number for Universal too large");
                 }
             } else {
                 tag = defaultTag();
                 tagging = getRuntime().getNil();
                 tag_class = getRuntime().newSymbol("UNIVERSAL");
             }
             if("ObjectId".equals(getMetaClass().getRealClass().getBaseName())) {
                 String v = (String)(getSymLookup(getRuntime()).get(getObjectIdentifier(value.toString())));
                 if(v != null) {
                     value = getRuntime().newString(v);
                 }
             }
             ThreadContext tc = getRuntime().getCurrentContext();
             this.callMethod(tc,"tag=",tag);
             this.callMethod(tc,"value=",value);
             this.callMethod(tc,"tagging=",tagging);
             this.callMethod(tc,"tag_class=",tag_class);
 
             return this;
         }
 
         private DERObjectIdentifier getObjectIdentifier(String nameOrOid) {
             Object val1 = ASN1.getOIDLookup(getRuntime()).get(nameOrOid.toLowerCase());
             if(null != val1) {
                 return (DERObjectIdentifier)val1;
             }
             DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
             return val2;
         }
 
         ASN1Encodable toASN1() throws Exception {
             //            System.err.println(getMetaClass().getRealClass().getBaseName()+"#toASN1");
             int tag = idForRubyName(getMetaClass().getRealClass().getBaseName());
             Class imp = (Class)ASN1_INFO[tag][1];
             IRubyObject val = callMethod(getRuntime().getCurrentContext(),"value");
             if(imp == DERObjectIdentifier.class) {
                 return getObjectIdentifier(val.toString());
             } else if(imp == DERNull.class) {
                 return new DERNull();
             } else if(imp == DERBoolean.class) {
                 return new DERBoolean(val.isTrue());
             } else if(imp == DERUTCTime.class) {
                 return new DERUTCTime(((RubyTime)val).getJavaDate());
             } else if(imp == DERInteger.class && val instanceof RubyBignum) {
                 return new DERInteger(((RubyBignum)val).getValue());
             } else if(imp == DERInteger.class) {
                 return new DERInteger(new BigInteger(val.toString()));
             } else if(imp == DEROctetString.class) {
                 return new DEROctetString(val.toString().getBytes("PLAIN"));
             } else if(imp == DERBitString.class) {
                 byte[] bs = val.toString().getBytes("PLAIN");
                 int unused = 0;
                 for(int i = (bs.length-1); i>-1; i--) {
                     if(bs[i] == 0) {
                         unused += 8;
                     } else {
                         byte v2 = bs[i];
                         int x = 8;
                         while(v2 != 0) {
                             v2 <<= 1;
                             x--;
                         }
                         unused += x;
                         break;
                     }
                 }
                 return new DERBitString(bs,unused);
             } else if(val instanceof RubyString) {
                 return (ASN1Encodable)imp.getConstructor(new Class[]{String.class}).newInstance(new Object[]{val.toString()});
             }
             System.err.println("object with tag: " + tag + " and value: " + val + " and val.class: " + val.getClass().getName() + " and impl: " + imp.getName());
             System.err.println("WARNING: unimplemented method called: asn1data#toASN1");
             return null;
         }
 
         protected void print(int indent) {
             printIndent(indent);
             System.out.println(getMetaClass().getRealClass().getBaseName() + ": " + callMethod(getRuntime().getCurrentContext(),"value").callMethod(getRuntime().getCurrentContext(),"inspect").toString());
         }
     }
 
     public static class ASN1Constructive extends ASN1Data {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            ASN1Data result = new ASN1Constructive(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public ASN1Constructive(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         public IRubyObject initialize(IRubyObject[] args) {
             checkArgumentCount(args,1,4);
             IRubyObject value = args[0];
             IRubyObject tag = getRuntime().getNil();
             IRubyObject tagging = getRuntime().getNil();
             IRubyObject tag_class = getRuntime().getNil();
             if(args.length>1) {
                 tag = args[1];
                 if(args.length>2) {
                     tagging = args[2];
                     if(args.length>3) {
                         tag_class = args[3];
                     }
                 }
                 if(tag.isNil()) {
                     asn1Error("must specify tag number");
                 }
                 if(tagging.isNil()) {
                     tagging = getRuntime().newSymbol("EXPLICIT");
                 }
                 if(!(tagging instanceof RubySymbol)) {
                     asn1Error("invalid tag default");
                 }
                 if(tag_class.isNil()) {
                     tag_class = getRuntime().newSymbol("CONTEXT_SPECIFIC");
                 }
                 if(!(tag_class instanceof RubySymbol)) {
                     asn1Error("invalid tag class");
                 }
                 if(tagging.toString().equals(":IMPLICIT") && RubyNumeric.fix2int(tag) > 31) {
                     asn1Error("tag number for Universal too large");
                 }
             } else {
                 tag = defaultTag();
                 tagging = getRuntime().getNil();
                 tag_class = getRuntime().newSymbol("UNIVERSAL");
             }
             ThreadContext tc = getRuntime().getCurrentContext();
             this.callMethod(tc,"tag=",tag);
             this.callMethod(tc,"value=",value);
             this.callMethod(tc,"tagging=",tagging);
             this.callMethod(tc,"tag_class=",tag_class);
 
             return this;
         }
 
         ASN1Encodable toASN1() throws Exception {
             //            System.err.println(getMetaClass().getRealClass().getBaseName()+"#toASN1");
             int id = idForRubyName(getMetaClass().getRealClass().getBaseName());
             if(id != -1) {
                 ASN1EncodableVector vec = new ASN1EncodableVector();
                 RubyArray arr = (RubyArray)callMethod(getRuntime().getCurrentContext(),"value");
                 for(Iterator iter = arr.getList().iterator();iter.hasNext();) {
                     IRubyObject v = (IRubyObject)iter.next();
                     if(v instanceof ASN1Data) {
                         vec.add(((ASN1Data)v).toASN1());
                     } else {
                         vec.add(((ASN1Data)ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),OpenSSLImpl.to_der_if_possible(v))).toASN1());
                     }
                 }
                 return (ASN1Encodable)(((Class)(ASN1_INFO[id][1])).getConstructor(new Class[]{DEREncodableVector.class}).newInstance(new Object[]{vec}));
             }
             return null;
         }
 
         public IRubyObject each() {
             RubyArray arr = (RubyArray)callMethod(getRuntime().getCurrentContext(),"value");
             for(Iterator iter = arr.getList().iterator();iter.hasNext();) {
                 getRuntime().getCurrentContext().yield((IRubyObject)iter.next());
             }
             return getRuntime().getNil();
         }
 
         protected void print(int indent) {
             printIndent(indent);
             System.out.println(getMetaClass().getRealClass().getBaseName() + ": ");
             RubyArray arr = (RubyArray)callMethod(getRuntime().getCurrentContext(),"value");
             for(Iterator iter = arr.getList().iterator();iter.hasNext();) {
                 ((ASN1Data)iter.next()).print(indent+1);
             }
         }
     }
 }// ASN1
diff --git a/src/org/jruby/ext/openssl/Attribute.java b/src/org/jruby/ext/openssl/Attribute.java
index 19d1276eda..b176f0f9a9 100644
--- a/src/org/jruby/ext/openssl/Attribute.java
+++ b/src/org/jruby/ext/openssl/Attribute.java
@@ -1,131 +1,132 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.DERObject;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERSet;
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Attribute extends RubyObject {
+    private static ObjectAllocator ATTRIBUTE_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new Attribute(runtime, klass);
+        }
+    };
+    
     public static void createAttribute(IRuby runtime, RubyModule mX509) {
-        RubyClass cAttribute = mX509.defineClassUnder("Attribute",runtime.getObject());
+        RubyClass cAttribute = mX509.defineClassUnder("Attribute",runtime.getObject(), ATTRIBUTE_ALLOCATOR);
 
-        mX509.defineClassUnder("AttributeError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("AttributeError",openSSLError, openSSLError.getAllocator());
 
         CallbackFactory attrcb = runtime.callbackFactory(Attribute.class);
 
-        cAttribute.defineSingletonMethod("new",attrcb.getOptSingletonMethod("newInstance"));
         cAttribute.defineMethod("initialize",attrcb.getOptMethod("_initialize"));
         cAttribute.defineMethod("to_der",attrcb.getMethod("to_der"));
         cAttribute.defineMethod("oid",attrcb.getMethod("oid"));
         cAttribute.defineMethod("oid=",attrcb.getMethod("set_oid",IRubyObject.class));
         cAttribute.defineMethod("value",attrcb.getMethod("value"));
         cAttribute.defineMethod("value=",attrcb.getMethod("set_value",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        Attribute result = new Attribute(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public Attribute(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private IRubyObject oid;
     private IRubyObject value;
 
     private DERObjectIdentifier getObjectIdentifier(String nameOrOid) {
         Object val1 = ASN1.getOIDLookup(getRuntime()).get(nameOrOid.toLowerCase());
         if(null != val1) {
             return (DERObjectIdentifier)val1;
         }
         DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
         return val2;
     }
 
     DERObject toASN1() throws Exception {
         ASN1EncodableVector v1 = new ASN1EncodableVector();
         v1.add(getObjectIdentifier(oid.toString()));
         if(value instanceof ASN1.ASN1Constructive) {
             v1.add(((ASN1.ASN1Constructive)value).toASN1());
         } else {
             ASN1EncodableVector v2 = new ASN1EncodableVector();
             v2.add(((ASN1.ASN1Data)value).toASN1());
             v1.add(new DERSet(v2));
         }
         return new DERSequence(v1);
     }
 
     public IRubyObject _initialize(IRubyObject[] str) throws Exception {
         if(checkArgumentCount(str,1,2) == 1) {
             IRubyObject _oid = OpenSSLImpl.to_der_if_possible(str[0]);
             set_oid(_oid);
             return this;
         }
         set_oid(str[0]);
         set_value(str[1]);
         return this;
     }
 
     public IRubyObject to_der() {
         System.err.println("WARNING: unimplemented method called: attr#to_der");
         return getRuntime().getNil();
     }
 
     public IRubyObject oid() {
         return oid;
     }
 
     public IRubyObject set_oid(IRubyObject val) {
         this.oid = val;
         return val;
     }
 
     public IRubyObject value() {
         return value;
     }
 
     public IRubyObject set_value(IRubyObject val) throws Exception {
         IRubyObject tmp = OpenSSLImpl.to_der_if_possible(val);
         this.value = ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),tmp);
         return val;
     }
 }// Attribute
diff --git a/src/org/jruby/ext/openssl/Cipher.java b/src/org/jruby/ext/openssl/Cipher.java
index 05ff668b5c..027ba27275 100644
--- a/src/org/jruby/ext/openssl/Cipher.java
+++ b/src/org/jruby/ext/openssl/Cipher.java
@@ -1,485 +1,486 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import javax.crypto.spec.IvParameterSpec;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Cipher extends RubyObject {
+    private static ObjectAllocator CIPHER_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new Cipher(runtime, klass);
+        }
+    };
+    
     public static void createCipher(IRuby runtime, RubyModule ossl) {
         RubyModule mCipher = ossl.defineModuleUnder("Cipher");
-        RubyClass cCipher = mCipher.defineClassUnder("Cipher",runtime.getObject());
+        RubyClass cCipher = mCipher.defineClassUnder("Cipher",runtime.getObject(), CIPHER_ALLOCATOR);
 
-        mCipher.defineClassUnder("CipherError",ossl.getClass("OpenSSLError"));
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mCipher.defineClassUnder("CipherError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory ciphercb = runtime.callbackFactory(Cipher.class);
 
         mCipher.defineSingletonMethod("ciphers",ciphercb.getSingletonMethod("ciphers"));
-        cCipher.defineSingletonMethod("new",ciphercb.getOptSingletonMethod("newInstance"));
         cCipher.defineMethod("initialize",ciphercb.getMethod("initialize",IRubyObject.class));
         cCipher.defineMethod("initialize_copy",ciphercb.getMethod("initialize_copy",IRubyObject.class));
         cCipher.defineMethod("clone",ciphercb.getMethod("rbClone"));
         cCipher.defineMethod("name",ciphercb.getMethod("name"));
         cCipher.defineMethod("key_len",ciphercb.getMethod("key_len"));
         cCipher.defineMethod("key_len=",ciphercb.getMethod("set_key_len",IRubyObject.class));
         cCipher.defineMethod("iv_len",ciphercb.getMethod("iv_len"));
         cCipher.defineMethod("block_size",ciphercb.getMethod("block_size"));
         cCipher.defineMethod("encrypt",ciphercb.getOptMethod("encrypt"));
         cCipher.defineMethod("decrypt",ciphercb.getOptMethod("decrypt"));
         cCipher.defineMethod("key=",ciphercb.getMethod("set_key",IRubyObject.class));
         cCipher.defineMethod("iv=",ciphercb.getMethod("set_iv",IRubyObject.class));
         cCipher.defineMethod("reset",ciphercb.getMethod("reset"));
         cCipher.defineMethod("pkcs5_keyivgen",ciphercb.getOptMethod("pkcs5_keyivgen"));
         cCipher.defineMethod("update",ciphercb.getMethod("update",IRubyObject.class));
         cCipher.defineMethod("<<",ciphercb.getMethod("update_deprecated",IRubyObject.class));
         cCipher.defineMethod("final",ciphercb.getMethod("_final"));
         cCipher.defineMethod("padding=",ciphercb.getMethod("set_padding",IRubyObject.class));
     }
 
     private static final Set BLOCK_MODES = new HashSet();
     static {
         BLOCK_MODES.add("CBC");
         BLOCK_MODES.add("CFB");
         BLOCK_MODES.add("CFB1");
         BLOCK_MODES.add("CFB8");
         BLOCK_MODES.add("ECB");
         BLOCK_MODES.add("OFB");
     }
 
     private static String[] rubyToJavaCipher(String inName) {
         String[] split = inName.split("-");
         String cryptoBase = split[0];
         String cryptoVersion = null;
         String cryptoMode = null;
         String realName = null;
         String padding_type = "PKCS5Padding";
 
         if("bf".equalsIgnoreCase(cryptoBase)) {
             cryptoBase = "Blowfish";
         }
 
         if(split.length == 3) {
             cryptoVersion = split[1];
             cryptoMode = split[2];
         } else {
             if(split.length == 2) {
                 cryptoMode = split[1];
             } else {
                 cryptoMode = "ECB";
             }
         }
 
         if(cryptoBase.equalsIgnoreCase("DES") && "EDE3".equalsIgnoreCase(cryptoVersion)) {
             realName = "DESede";
         } else {
             realName = cryptoBase;
         }
 
         if(!BLOCK_MODES.contains(cryptoMode.toUpperCase())) {
             cryptoVersion = cryptoMode;
             cryptoMode = "CBC";
         }
 
         realName = realName + "/" + cryptoMode + "/" + padding_type;
 
         return new String[]{cryptoBase,cryptoVersion,cryptoMode,realName,padding_type};
     }
 
     private static boolean tryCipher(String rubyName) {
         try {
             javax.crypto.Cipher.getInstance(rubyToJavaCipher(rubyName)[3],"BC");
             return true;
         } catch(Exception e) {
             return false;
         }
     }
 
     public static IRubyObject ciphers(IRubyObject recv) {
         List ciphers = new ArrayList();
         String[] other = {"AES128","AES192","AES256","BLOWFISH", "RC2-40-CBC", "RC2-64-CBC","RC4","RC4-40", "CAST","CAST-CBC"};
         String[] bases = {"AES-128","AES-192","AES-256","BF", "DES", "DES-EDE","DES-EDE3", "RC2","CAST5"};
         String[] suffixes = {"","-CBC","-CFB","-CFB1","-CFB8","-ECB","-OFB"};
         for(int i=0,j=bases.length;i<j;i++) {
             for(int k=0,l=suffixes.length;k<l;k++) {
                 String val = bases[i]+suffixes[k];
                 if(tryCipher(val)) {
                     ciphers.add(recv.getRuntime().newString(val));
                     ciphers.add(recv.getRuntime().newString((val).toLowerCase()));
                 }
             }
         }
         for(int i=0,j=other.length;i<j;i++) {
             if(tryCipher(other[i])) {
                 ciphers.add(recv.getRuntime().newString(other[i]));
                 ciphers.add(recv.getRuntime().newString(other[i].toLowerCase()));
             }
         }
         return recv.getRuntime().newArray(ciphers);
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        Cipher result = new Cipher(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private RubyClass ciphErr;
     public Cipher(IRuby runtime, RubyClass type) {
         super(runtime,type);
         ciphErr = (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("Cipher"))).getConstant("CipherError"));
     }
 
     private javax.crypto.Cipher ciph;
     private String name;
     private String cryptoBase;
     private String cryptoVersion;
     private String cryptoMode;
     private String padding_type;
     private String realName;
     private int keyLen = -1;
     private int ivLen = -1;
     private boolean encryptMode = true;
     private IRubyObject[] modeParams;
     private boolean ciphInited = false;
     private byte[] key;
     private byte[] iv;
     private String padding;
 
     public IRubyObject initialize(IRubyObject str) {
         name = str.toString();
         String[] values = rubyToJavaCipher(name);
         cryptoBase = values[0];
         cryptoVersion = values[1];
         cryptoMode = values[2];
         realName = values[3];
         padding_type = values[4];
 
         try {
             ciph = javax.crypto.Cipher.getInstance(realName,"BC");
         } catch(NoSuchAlgorithmException e) {
             throw getRuntime().newLoadError("unsupported cipher algorithm (" + realName + ")");
         } catch(NoSuchProviderException e) {
             throw getRuntime().newLoadError("unsupported cipher algorithm (" + realName + ")");
         } catch(javax.crypto.NoSuchPaddingException e) {
             throw getRuntime().newLoadError("unsupported cipher padding (" + realName + ")");
         }
 
         if(hasLen() && null != cryptoVersion) {
             try {
                 keyLen = Integer.parseInt(cryptoVersion);
             } catch(NumberFormatException e) {
                 keyLen = -1;
             }
         }
         if(keyLen == -1) {
             if("DES".equalsIgnoreCase(cryptoBase)) {
                 if("EDE3".equalsIgnoreCase(cryptoVersion)) {
                     keyLen = 168;
                 } else {
                     keyLen = 56;
                 }
             } else {
                 keyLen = 128;
             }
         }
 
         if(ivLen == -1) {
             if("AES".equalsIgnoreCase(cryptoBase)) {
                 ivLen = 16*8;
             } else {
                 ivLen = 8*8;
             }
         }
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         if(this == obj) {
             return this;
         }
 
         checkFrozen();
 
         cryptoBase = ((Cipher)obj).cryptoBase;
         cryptoVersion = ((Cipher)obj).cryptoVersion;
         cryptoMode = ((Cipher)obj).cryptoMode;
         padding_type = ((Cipher)obj).padding_type;
         realName = ((Cipher)obj).realName;
         name = ((Cipher)obj).name;
         keyLen = ((Cipher)obj).keyLen;
         ivLen = ((Cipher)obj).ivLen;
         encryptMode = ((Cipher)obj).encryptMode;
         ciphInited = false;
         if(((Cipher)obj).key != null) {
             key = new byte[((Cipher)obj).key.length];
             System.arraycopy(((Cipher)obj).key,0,key,0,key.length);
         } else {
             key = null;
         }
         if(((Cipher)obj).iv != null) {
             iv = new byte[((Cipher)obj).iv.length];
             System.arraycopy(((Cipher)obj).iv,0,iv,0,iv.length);
         } else {
             iv = null;
         }
         padding = ((Cipher)obj).padding;
 
         try {
             ciph = javax.crypto.Cipher.getInstance(realName,"BC");
         } catch(NoSuchAlgorithmException e) {
             throw getRuntime().newLoadError("unsupported cipher algorithm (" + realName + ")");
         } catch(NoSuchProviderException e) {
             throw getRuntime().newLoadError("unsupported cipher algorithm (" + realName + ")");
         } catch(javax.crypto.NoSuchPaddingException e) {
             throw getRuntime().newLoadError("unsupported cipher padding (" + realName + ")");
         }
 
         return this;
     }
 
     public IRubyObject name() {
         return getRuntime().newString(name);
     }
 
     public IRubyObject key_len() {
         return getRuntime().newFixnum(keyLen);
     }
 
     public IRubyObject iv_len() {
         return getRuntime().newFixnum(ivLen);
     }
 
     public IRubyObject set_key_len(IRubyObject len) {
         this.keyLen = RubyNumeric.fix2int(len);
         return len;
     }
 
     public IRubyObject set_key(IRubyObject key) {
         if(key.toString().length()*8 < keyLen) {
             throw new RaiseException(getRuntime(), ciphErr, "key length to short", true);
         }
         try {
             this.key = key.toString().getBytes("PLAIN");
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
         return key;
     }
 
     public IRubyObject set_iv(IRubyObject iv) {
         if(iv.toString().length()*8 < ivLen) {
             throw new RaiseException(getRuntime(), ciphErr, "iv length to short", true);
         }
         try {
             this.iv = iv.toString().getBytes("PLAIN");
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
         return iv;
     }
 
     public IRubyObject block_size() {
         return getRuntime().newFixnum(ciph.getBlockSize());
     }
 
     public IRubyObject encrypt(IRubyObject[] args) {
         //TODO: implement backwards compat
         checkArgumentCount(args,0,2);
         encryptMode = true;
         modeParams = args;
         ciphInited = false;
         return this;
     }
 
     public IRubyObject decrypt(IRubyObject[] args) {
         //TODO: implement backwards compat
         checkArgumentCount(args,0,2);
         encryptMode = false;
         modeParams = args;
         ciphInited = false;
         return this;
     }
 
     public IRubyObject reset() {
         doInitialize();
         return this;
     }
 
     private boolean hasLen() {
         return hasLen(this.cryptoBase);
     }
 
     private static boolean hasLen(String cryptoBase) {
         return "AES".equalsIgnoreCase(cryptoBase) || "RC2".equalsIgnoreCase(cryptoBase) || "RC4".equalsIgnoreCase(cryptoBase);
     }
 
     public IRubyObject pkcs5_keyivgen(IRubyObject[] args) {
         checkArgumentCount(args,1,4);
         String pass = args[0].toString();
         String salt = null;
         byte[] ssalt = null;
         int iter = 2048;
         IRubyObject vdigest = getRuntime().getNil();
         MessageDigest digest = null;
         if(args.length>1) {
             if(!args[1].isNil()) {
                 salt = args[1].toString();
             }
             if(args.length>2) {
                 if(!args[2].isNil()) {
                     iter = RubyNumeric.fix2int(args[2]);
                 }
                 if(args.length>3) {
                     vdigest = args[3];
                 }
             }
         }
         try {
             if(null != salt) {
                 if(salt.length() != 8) {
                     throw new RaiseException(getRuntime(), ciphErr, "salt must be an 8-octet string", true);
                 }
                 ssalt = salt.getBytes("PLAIN");
             }
             if(vdigest.isNil()) {
                 digest = MessageDigest.getInstance("MD5","BC");
             } else {
                 digest = MessageDigest.getInstance(((Digest)vdigest).getAlgorithm(),"BC");
             }
 
             OpenSSLImpl.KeyAndIv result = OpenSSLImpl.EVP_BytesToKey(keyLen/8,ivLen/8,digest,ssalt,pass.getBytes("PLAIN"),iter);
             this.key = result.getKey();
             this.iv = result.getIv();
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
 
         doInitialize();
 
         return getRuntime().getNil();
     }
 
     private void doInitialize() {
         ciphInited = true;
         try {
             if(!"ECB".equalsIgnoreCase(cryptoMode) && this.iv != null) {
                 this.ciph.init(encryptMode ? javax.crypto.Cipher.ENCRYPT_MODE : javax.crypto.Cipher.DECRYPT_MODE, new SimpleSecretKey(this.key), new IvParameterSpec(this.iv));
             } else {
                 this.ciph.init(encryptMode ? javax.crypto.Cipher.ENCRYPT_MODE : javax.crypto.Cipher.DECRYPT_MODE, new SimpleSecretKey(this.key));
             }
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
     }
 
     public IRubyObject update(IRubyObject data) {
         //TODO: implement correctly
         String val = data.toString();
         if(val.length() == 0) {
             throw getRuntime().newArgumentError("data must not be empty");
         }
 
         if(!ciphInited) {
             doInitialize();
         }
 
         String str = "";
         try {
             byte[] out = ciph.update(val.toString().getBytes("PLAIN"));
             if(out != null) {
                 str = new String(out,"ISO8859_1");
             }
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
 
         return getRuntime().newString(str);
     }
 
     public IRubyObject update_deprecated(IRubyObject data) {
         getRuntime().getWarnings().warn("" + this.getMetaClass().getRealClass().getName() + "#<< is deprecated; use " + this.getMetaClass().getRealClass().getName() + "#update instead");
         return update(data);
     }
 
     public IRubyObject _final() {
         if(!ciphInited) {
             doInitialize();
         }
 
         //TODO: implement correctly
         String str = "";
         try {
             byte[] out = ciph.doFinal();
             if(out != null) {
                 str = new String(out,"ISO8859_1");
             }
         } catch(Exception e) {
             throw new RaiseException(getRuntime(), ciphErr, null, true);
         }
 
         return getRuntime().newString(str);
     }
 
     public IRubyObject set_padding(IRubyObject padding) {
         this.padding = padding.toString();
         return padding;
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new Cipher(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 
     String getAlgorithm() {
         return this.ciph.getAlgorithm();
     }
 }
 
diff --git a/src/org/jruby/ext/openssl/Config.java b/src/org/jruby/ext/openssl/Config.java
index e704c4ca3c..8ca2dd696e 100644
--- a/src/org/jruby/ext/openssl/Config.java
+++ b/src/org/jruby/ext/openssl/Config.java
@@ -1,49 +1,49 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Config {
     public static void createConfig(IRuby runtime, RubyModule ossl) {
-        RubyClass cConfig = ossl.defineClassUnder("Config", runtime.getObject());
+        RubyClass cConfig = ossl.defineClassUnder("Config", runtime.getObject(), runtime.getObject().getAllocator());
         CallbackFactory confcb = runtime.callbackFactory(Config.class);
         cConfig.defineSingletonMethod("parse",confcb.getOptSingletonMethod("parse"));
     }
 
     public static IRubyObject parse(IRubyObject recv, IRubyObject[] args) {
         throw recv.getRuntime().newNotImplementedError("should be implemented. TODO: this");
     }
 }// Config
diff --git a/src/org/jruby/ext/openssl/Digest.java b/src/org/jruby/ext/openssl/Digest.java
index 71dbd11e38..8f4285040b 100644
--- a/src/org/jruby/ext/openssl/Digest.java
+++ b/src/org/jruby/ext/openssl/Digest.java
@@ -1,230 +1,238 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Digest extends RubyObject {
+    private static ObjectAllocator DIGEST_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new Digest(runtime, klass);
+        }
+    };
+    
     public static void createDigest(IRuby runtime, RubyModule ossl) {
         RubyModule mDigest = ossl.defineModuleUnder("Digest");
-        RubyClass cDigest = mDigest.defineClassUnder("Digest",runtime.getObject());
-        mDigest.defineClassUnder("DigestError",ossl.getClass("OpenSSLError"));
+        RubyClass cDigest = mDigest.defineClassUnder("Digest",runtime.getObject(),DIGEST_ALLOCATOR);
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mDigest.defineClassUnder("DigestError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory digestcb = runtime.callbackFactory(Digest.class);
 
         cDigest.defineSingletonMethod("new",digestcb.getOptSingletonMethod("newInstance"));
         cDigest.defineSingletonMethod("digest",digestcb.getSingletonMethod("s_digest",IRubyObject.class,IRubyObject.class));
         cDigest.defineSingletonMethod("hexdigest",digestcb.getSingletonMethod("s_hexdigest",IRubyObject.class,IRubyObject.class));
         cDigest.defineMethod("initialize",digestcb.getOptMethod("initialize"));
         cDigest.defineMethod("initialize_copy",digestcb.getMethod("initialize_copy",IRubyObject.class));
         cDigest.defineMethod("clone",digestcb.getMethod("rbClone"));
         cDigest.defineMethod("update",digestcb.getMethod("update",IRubyObject.class));
         cDigest.defineMethod("<<",digestcb.getMethod("update",IRubyObject.class));
         cDigest.defineMethod("digest",digestcb.getMethod("digest"));
         cDigest.defineMethod("hexdigest",digestcb.getMethod("hexdigest"));
         cDigest.defineMethod("inspect",digestcb.getMethod("hexdigest"));
         cDigest.defineMethod("to_s",digestcb.getMethod("hexdigest"));
         cDigest.defineMethod("==",digestcb.getMethod("eq",IRubyObject.class));
         cDigest.defineMethod("reset",digestcb.getMethod("reset"));
         cDigest.defineMethod("name",digestcb.getMethod("name"));
         cDigest.defineMethod("size",digestcb.getMethod("size"));
     }
 
     private static String transformDigest(String inp) {
         String[] sp = inp.split("::");
         if(sp.length > 1) { // We only want Digest names from the last part of class name
             inp = sp[sp.length-1];
         }
 
         if("DSS".equalsIgnoreCase(inp)) {
             return "SHA";
         } else if("DSS1".equalsIgnoreCase(inp)) {
             return "SHA1";
         }
         return inp;
     }
 
     public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        Digest result = new Digest(recv.getRuntime(), (RubyClass)recv);
+        Digest result = (Digest)((RubyClass)recv).allocate();
         if(!(recv.toString().equals("OpenSSL::Digest::Digest"))) {
             try {
                 result.name = recv.toString();
                 result.md = MessageDigest.getInstance(transformDigest(recv.toString()));
             } catch(NoSuchAlgorithmException e) {
                 throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + recv.toString() + ")");
             }
         }
         result.callInit(args);
         return result;
     }
 
     public static IRubyObject s_digest(IRubyObject recv, IRubyObject str, IRubyObject data) {
         String name = str.toString();
         try {
             MessageDigest md = MessageDigest.getInstance(transformDigest(name));
             return recv.getRuntime().newString(new String(md.digest(data.toString().getBytes("PLAIN")),"ISO8859_1"));
         } catch(NoSuchAlgorithmException e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         } catch(java.io.UnsupportedEncodingException e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         }
     }
 
     public static IRubyObject s_hexdigest(IRubyObject recv, IRubyObject str, IRubyObject data) {
         String name = str.toString();
         try {
             MessageDigest md = MessageDigest.getInstance(transformDigest(name));
             return recv.getRuntime().newString(Utils.toHex(md.digest(data.toString().getBytes("PLAIN"))));
         } catch(NoSuchAlgorithmException e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         } catch(java.io.UnsupportedEncodingException e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         }
     }
 
     public Digest(IRuby runtime, RubyClass type) {
         super(runtime,type);
         data = new StringBuffer();
     }
 
     private MessageDigest md;
     private StringBuffer data;
     private String name;
 
     public IRubyObject initialize(IRubyObject[] args) {
         IRubyObject type;
         IRubyObject data = getRuntime().getNil();
         if(checkArgumentCount(args,1,2) == 2) {
             data = args[1];
         }
         type = args[0];
 
         name = type.toString();
         try {
             md = MessageDigest.getInstance(transformDigest(name));
         } catch(NoSuchAlgorithmException e) {
             throw getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         }
         if(!data.isNil()) {
             update(data);
         }
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         if(this == obj) {
             return this;
         }
         checkFrozen();
         data = new StringBuffer(((Digest)obj).data.toString());
         name = ((Digest)obj).md.getAlgorithm();
         try {
             md = MessageDigest.getInstance(transformDigest(name));
         } catch(NoSuchAlgorithmException e) {
             throw getRuntime().newNotImplementedError("Unsupported digest algorithm (" + name + ")");
         }
 
         return this;
     }
 
     public IRubyObject update(IRubyObject obj) {
         try {
             data.append(obj);
             md.update(obj.toString().getBytes("PLAIN"));
         } catch(java.io.UnsupportedEncodingException e) {}
         return this;
     }
 
     public IRubyObject reset() {
         md.reset();
         data = new StringBuffer();
         return this;
     }
 
     public IRubyObject digest() {
         try {
             md.reset();
             return getRuntime().newString(new String(md.digest(data.toString().getBytes("PLAIN")),"ISO8859_1"));
         } catch(java.io.UnsupportedEncodingException e) {
             return getRuntime().getNil();
         }
     }
 
     public IRubyObject name() {
         return getRuntime().newString(name);
     }
 
     public IRubyObject size() {
         return getRuntime().newFixnum(md.getDigestLength());
     }
 
     public IRubyObject hexdigest() {
         try {
             md.reset();
             return getRuntime().newString(Utils.toHex(md.digest(data.toString().getBytes("PLAIN"))));
         } catch(java.io.UnsupportedEncodingException e) {
             return getRuntime().getNil();
         }
     }
 
     public IRubyObject eq(IRubyObject oth) {
         boolean ret = this == oth;
         if(!ret && oth instanceof Digest) {
             Digest b = (Digest)oth;
             ret = this.md.getAlgorithm().equals(b.md.getAlgorithm()) &&
                 this.digest().equals(b.digest());
         }
 
         return ret ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new Digest(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 
     String getAlgorithm() {
         return this.md.getAlgorithm();
     }
 }
 
diff --git a/src/org/jruby/ext/openssl/HMAC.java b/src/org/jruby/ext/openssl/HMAC.java
index 4dcd2f78b4..5e36cae0ff 100644
--- a/src/org/jruby/ext/openssl/HMAC.java
+++ b/src/org/jruby/ext/openssl/HMAC.java
@@ -1,173 +1,174 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import javax.crypto.Mac;
 import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class HMAC extends RubyObject {
+    private static ObjectAllocator HMAC_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new HMAC(runtime, klass);
+        }
+    };
+    
     public static void createHMAC(IRuby runtime, RubyModule ossl) {
-        RubyClass cHMAC = ossl.defineClassUnder("HMAC",runtime.getObject());
-        ossl.defineClassUnder("HMACError",ossl.getClass("OpenSSLError"));
+        RubyClass cHMAC = ossl.defineClassUnder("HMAC",runtime.getObject(),HMAC_ALLOCATOR);
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        ossl.defineClassUnder("HMACError",openSSLError,openSSLError.getAllocator());
         
         CallbackFactory hmaccb = runtime.callbackFactory(HMAC.class);
 
-        cHMAC.defineSingletonMethod("new",hmaccb.getOptSingletonMethod("newInstance"));
         cHMAC.defineSingletonMethod("digest",hmaccb.getSingletonMethod("s_digest",IRubyObject.class,IRubyObject.class,IRubyObject.class));
         cHMAC.defineSingletonMethod("hexdigest",hmaccb.getSingletonMethod("s_hexdigest",IRubyObject.class,IRubyObject.class,IRubyObject.class));
         cHMAC.defineMethod("initialize",hmaccb.getMethod("initialize",IRubyObject.class,IRubyObject.class));
         cHMAC.defineMethod("initialize_copy",hmaccb.getMethod("initialize_copy",IRubyObject.class));
         cHMAC.defineMethod("clone",hmaccb.getMethod("rbClone"));
         cHMAC.defineMethod("update",hmaccb.getMethod("update",IRubyObject.class));
         cHMAC.defineMethod("<<",hmaccb.getMethod("update",IRubyObject.class));
         cHMAC.defineMethod("digest",hmaccb.getMethod("digest"));
         cHMAC.defineMethod("hexdigest",hmaccb.getMethod("hexdigest"));
         cHMAC.defineMethod("inspect",hmaccb.getMethod("hexdigest"));
         cHMAC.defineMethod("to_s",hmaccb.getMethod("hexdigest"));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        HMAC result = new HMAC(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public static IRubyObject s_digest(IRubyObject recv, IRubyObject digest, IRubyObject kay, IRubyObject data) {
         String name = "HMAC" + ((Digest)digest).getAlgorithm();
         try {
             Mac mac = Mac.getInstance(name);
             byte[] key = kay.toString().getBytes("PLAIN");
             SecretKey keysp = new SecretKeySpec(key,name);
             mac.init(keysp);
             return recv.getRuntime().newString(new String(mac.doFinal(data.toString().getBytes("PLAIN")),"ISO8859_1"));
         } catch(Exception e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported HMAC algorithm (" + name + ")");
         }
     }
 
     public static IRubyObject s_hexdigest(IRubyObject recv, IRubyObject digest, IRubyObject kay, IRubyObject data) {
         String name = "HMAC" + ((Digest)digest).getAlgorithm();
         try {
             Mac mac = Mac.getInstance(name);
             byte[] key = kay.toString().getBytes("PLAIN");
             SecretKey keysp = new SecretKeySpec(key,name);
             mac.init(keysp);
             return recv.getRuntime().newString(Utils.toHex(mac.doFinal(data.toString().getBytes("PLAIN"))));
         } catch(Exception e) {
             throw recv.getRuntime().newNotImplementedError("Unsupported HMAC algorithm (" + name + ")");
         }
     }
 
     public HMAC(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private Mac mac;
     private byte[] key;
     private StringBuffer data = new StringBuffer();
 
     public IRubyObject initialize(IRubyObject kay, IRubyObject digest) {
         String name = "HMAC" + ((Digest)digest).getAlgorithm();
         try {
             mac = Mac.getInstance(name);
             key = kay.toString().getBytes("PLAIN");
             SecretKey keysp = new SecretKeySpec(key,name);
             mac.init(keysp);
         } catch(Exception e) {
             throw getRuntime().newNotImplementedError("Unsupported MAC algorithm (" + name + ")");
         }
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         if(this == obj) {
             return this;
         }
         checkFrozen();
         String name = ((HMAC)obj).mac.getAlgorithm();
         try {
             mac = Mac.getInstance(name);
             key = ((HMAC)obj).key;
             SecretKey keysp = new SecretKeySpec(key,name);
             mac.init(keysp);
         } catch(Exception e) {
             throw getRuntime().newNotImplementedError("Unsupported MAC algorithm (" + name + ")");
         }
         
         data = new StringBuffer(((HMAC)obj).data.toString());
 
         return this;
     }
 
     public IRubyObject update(IRubyObject obj) {
         data.append(obj);
         return this;
     }
 
     public IRubyObject digest() {
         try {
             mac.reset();
             return getRuntime().newString(new String(mac.doFinal(data.toString().getBytes("PLAIN")),"ISO8859_1"));
         } catch(java.io.UnsupportedEncodingException e) {
             return getRuntime().getNil();
         }
     }
 
     public IRubyObject hexdigest() {
         try {
             mac.reset();
             return getRuntime().newString(Utils.toHex(mac.doFinal(data.toString().getBytes("PLAIN"))));
         } catch(java.io.UnsupportedEncodingException e) {
             return getRuntime().getNil();
         }
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new HMAC(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 
     String getAlgorithm() {
         return this.mac.getAlgorithm();
     }
 }// HMAC
diff --git a/src/org/jruby/ext/openssl/NetscapeSPKI.java b/src/org/jruby/ext/openssl/NetscapeSPKI.java
index 7f31d866a3..15bbcab284 100644
--- a/src/org/jruby/ext/openssl/NetscapeSPKI.java
+++ b/src/org/jruby/ext/openssl/NetscapeSPKI.java
@@ -1,178 +1,179 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.DERBitString;
 import org.bouncycastle.asn1.DERIA5String;
 import org.bouncycastle.asn1.DERNull;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
 import org.bouncycastle.jce.netscape.NetscapeCertRequest;
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jvyaml.util.Base64Coder;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class NetscapeSPKI extends RubyObject {
+    private static ObjectAllocator NETSCAPESPKI_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new NetscapeSPKI(runtime, klass);
+        }
+    };
+    
     public static void createNetscapeSPKI(IRuby runtime, RubyModule ossl) {
         RubyModule mNetscape = ossl.defineModuleUnder("Netscape");
-        RubyClass cSPKI = mNetscape.defineClassUnder("SPKI",runtime.getObject());
-        mNetscape.defineClassUnder("SPKIError",ossl.getClass("OpenSSLError"));
+        RubyClass cSPKI = mNetscape.defineClassUnder("SPKI",runtime.getObject(),NETSCAPESPKI_ALLOCATOR);
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mNetscape.defineClassUnder("SPKIError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory spkicb = runtime.callbackFactory(NetscapeSPKI.class);
-        cSPKI.defineSingletonMethod("new",spkicb.getOptSingletonMethod("newInstance"));
         cSPKI.defineMethod("initialize",spkicb.getOptMethod("_initialize"));
         cSPKI.defineMethod("to_der",spkicb.getMethod("to_der"));
         cSPKI.defineMethod("to_pem",spkicb.getMethod("to_pem"));
         cSPKI.defineMethod("to_s",spkicb.getMethod("to_pem"));
         cSPKI.defineMethod("to_text",spkicb.getMethod("to_text"));
         cSPKI.defineMethod("public_key",spkicb.getMethod("public_key"));
         cSPKI.defineMethod("public_key=",spkicb.getMethod("set_public_key",IRubyObject.class));
         cSPKI.defineMethod("sign",spkicb.getMethod("sign",IRubyObject.class,IRubyObject.class));
         cSPKI.defineMethod("verify",spkicb.getMethod("verify",IRubyObject.class));
         cSPKI.defineMethod("challenge",spkicb.getMethod("challenge"));
         cSPKI.defineMethod("challenge=",spkicb.getMethod("set_challenge",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        NetscapeSPKI result = new NetscapeSPKI(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public NetscapeSPKI(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private IRubyObject public_key;
     private IRubyObject challenge;
 
     private NetscapeCertRequest cert;
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         if(args.length > 0) {
             byte[] b = args[0].toString().getBytes("PLAIN");
             try {
                 b = Base64Coder.decode(args[0].toString()).getBytes("PLAIN");
             } catch(Exception e) {
                 b = args[0].toString().getBytes("PLAIN");
             }
             cert = new NetscapeCertRequest(b);
             this.challenge = getRuntime().newString(cert.getChallenge());
             String algo = cert.getPublicKey().getAlgorithm();;
             byte[] enc = cert.getPublicKey().getEncoded();
             if("RSA".equalsIgnoreCase(algo)) {
                 this.public_key = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getClass("RSA").callMethod(getRuntime().getCurrentContext(),"new",getRuntime().newString(new String(enc,"ISO8859_1")));
             } else if("DSA".equalsIgnoreCase(algo)) {
                 this.public_key = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getClass("DSA").callMethod(getRuntime().getCurrentContext(),"new",getRuntime().newString(new String(enc,"ISO8859_1")));
             } else {
                 throw getRuntime().newLoadError("not implemented algo for public key: " + algo);
             }
         }
         return this;
     }
 
     public IRubyObject to_der() throws Exception {
         DERSequence b = (DERSequence)cert.toASN1Object();
         DERObjectIdentifier encType = null;
         DERBitString publicKey = new DERBitString(((PKey)public_key).to_der().toString().getBytes("PLAIN"));
         DERIA5String challenge = new DERIA5String(this.challenge.toString());
         DERObjectIdentifier sigAlg = null;
         DERBitString sig = null;
         encType = (DERObjectIdentifier)((DERSequence)((DERSequence)((DERSequence)b.getObjectAt(0)).getObjectAt(0)).getObjectAt(0)).getObjectAt(0);
         sigAlg = ((AlgorithmIdentifier)b.getObjectAt(1)).getObjectId();
         sig = (DERBitString)b.getObjectAt(2);
 
         ASN1EncodableVector v1 = new ASN1EncodableVector();
         ASN1EncodableVector v1_2 = new ASN1EncodableVector();
         ASN1EncodableVector v2 = new ASN1EncodableVector();
         ASN1EncodableVector v3 = new ASN1EncodableVector();
         ASN1EncodableVector v4 = new ASN1EncodableVector();
         v4.add(encType);
         v4.add(new DERNull());
         v3.add(new DERSequence(v4));
         v3.add(publicKey);
         v2.add(new DERSequence(v3));
         v2.add(challenge);
         v1.add(new DERSequence(v2));
         v1_2.add(sigAlg);
         v1_2.add(new DERNull());
         v1.add(new DERSequence(v1_2));
         v1.add(sig);
         return getRuntime().newString(new String(new DERSequence(v1).getEncoded(),"ISO8859_1"));
     }
 
     public IRubyObject to_pem() throws Exception {
         return getRuntime().newString(Base64Coder.encode(to_der().toString()));
     }
 
     public IRubyObject to_text() {
         System.err.println("WARNING: calling unimplemented method: to_text");
         return getRuntime().getNil();
     }
 
     public IRubyObject public_key() {
         return this.public_key;
     }
 
     public IRubyObject set_public_key(IRubyObject arg) {
         this.public_key = arg;
         return arg;
     }
 
     public IRubyObject sign(IRubyObject key, IRubyObject digest) throws Exception {
         String keyAlg = ((PKey)key).getAlgorithm();
         String digAlg = ((Digest)digest).getAlgorithm();
         DERObjectIdentifier alg = (DERObjectIdentifier)(ASN1.getOIDLookup(getRuntime()).get(keyAlg.toLowerCase() + "-" + digAlg.toLowerCase()));
         cert = new NetscapeCertRequest(challenge.toString(),new AlgorithmIdentifier(alg),((PKey)public_key).getPublicKey());
         cert.sign(((PKey)key).getPrivateKey());
         return this;
     }
 
     public IRubyObject verify(IRubyObject pkey) throws Exception {
         cert.setPublicKey(((PKey)pkey).getPublicKey());
         return cert.verify(challenge.toString()) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject challenge() {
         return this.challenge;
     }
 
     public IRubyObject set_challenge(IRubyObject arg) {
         this.challenge = arg;
         return arg;
     }
 }// NetscapeSPKI
diff --git a/src/org/jruby/ext/openssl/OpenSSLReal.java b/src/org/jruby/ext/openssl/OpenSSLReal.java
index f2decc5826..d40e4eee3f 100644
--- a/src/org/jruby/ext/openssl/OpenSSLReal.java
+++ b/src/org/jruby/ext/openssl/OpenSSLReal.java
@@ -1,63 +1,65 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.jruby.IRuby;
+import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class OpenSSLReal {
     public static void createOpenSSL(IRuby runtime) {
         RubyModule ossl = runtime.defineModule("OpenSSL");
-        ossl.defineClassUnder("OpenSSLError",runtime.getClass("StandardError"));
+        RubyClass standardError = runtime.getClass("StandardError");
+        ossl.defineClassUnder("OpenSSLError",standardError,standardError.getAllocator());
 
         ASN1.createASN1(runtime, ossl);
         Digest.createDigest(runtime, ossl);
         Cipher.createCipher(runtime, ossl);
         Random.createRandom(runtime, ossl);
         PKey.createPKey(runtime,ossl);
         HMAC.createHMAC(runtime,ossl);
         X509.createX509(runtime,ossl);
         Config.createConfig(runtime,ossl);
         NetscapeSPKI.createNetscapeSPKI(runtime,ossl);
         PKCS7.createPKCS7(runtime,ossl);
         SSL.createSSL(runtime,ossl);
 
         ossl.setConstant("VERSION",runtime.newString("1.0.0"));
         ossl.setConstant("OPENSSL_VERSION",runtime.newString("OpenSSL 0.9.8b 04 May 2006 (Java fake)"));
         
         try {
             java.security.MessageDigest.getInstance("SHA224");
             ossl.setConstant("OPENSSL_VERSION_NUMBER",runtime.newFixnum(9469999));
         } catch(java.security.NoSuchAlgorithmException e) {
             ossl.setConstant("OPENSSL_VERSION_NUMBER",runtime.newFixnum(9469952));
         }
     }
 }// OpenSSLReal
diff --git a/src/org/jruby/ext/openssl/PKCS7.java b/src/org/jruby/ext/openssl/PKCS7.java
index dddf9b0f55..62267fd3a1 100644
--- a/src/org/jruby/ext/openssl/PKCS7.java
+++ b/src/org/jruby/ext/openssl/PKCS7.java
@@ -1,476 +1,470 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStreamReader;
 import java.io.StringWriter;
 import java.security.PrivateKey;
 import java.security.cert.CertStore;
 import java.security.cert.CollectionCertStoreParameters;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.cms.ContentInfo;
 import org.bouncycastle.cms.CMSProcessableByteArray;
 import org.bouncycastle.cms.CMSSignedData;
 import org.bouncycastle.cms.CMSSignedDataGenerator;
 import org.bouncycastle.cms.SignerInformation;
 import org.bouncycastle.cms.SignerInformationStore;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.ext.openssl.x509store.PEM;
 import org.jruby.ext.openssl.x509store.X509AuxCertificate;
 import org.jruby.ext.openssl.x509store.X509_STORE_CTX;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
-public class PKCS7 extends RubyObject {
+public class PKCS7 extends RubyObject {    
     public static void createPKCS7(IRuby runtime, RubyModule mOSSL) {
         RubyModule mPKCS7 = mOSSL.defineModuleUnder("PKCS7");
-        mPKCS7.defineClassUnder("PKCS7Error",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
-        RubyClass cPKCS7 = mPKCS7.defineClassUnder("PKCS7",runtime.getObject());
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mPKCS7.defineClassUnder("PKCS7Error",openSSLError,openSSLError.getAllocator());
+        RubyClass cPKCS7 = mPKCS7.defineClassUnder("PKCS7",runtime.getObject(),runtime.getObject().getAllocator());
 
         cPKCS7.attr_accessor(new IRubyObject[]{runtime.newSymbol("data"),runtime.newSymbol("error_string")});
 
         CallbackFactory p7cb = runtime.callbackFactory(PKCS7.class);
         mPKCS7.defineSingletonMethod("read_smime",p7cb.getSingletonMethod("read_smime",IRubyObject.class));
         mPKCS7.defineSingletonMethod("write_smime",p7cb.getOptSingletonMethod("write_smime"));
         mPKCS7.defineSingletonMethod("sign",p7cb.getOptSingletonMethod("sign"));
         mPKCS7.defineSingletonMethod("encrypt",p7cb.getOptSingletonMethod("encrypt"));
         cPKCS7.defineSingletonMethod("new",p7cb.getOptSingletonMethod("newInstance"));
         cPKCS7.defineMethod("initialize",p7cb.getOptMethod("_initialize"));
         cPKCS7.defineMethod("initialize_copy",p7cb.getMethod("initialize_copy",IRubyObject.class));
         cPKCS7.defineMethod("clone",p7cb.getMethod("rbClone"));
         cPKCS7.defineMethod("type=",p7cb.getMethod("set_type",IRubyObject.class));
         cPKCS7.defineMethod("type",p7cb.getMethod("get_type"));
         cPKCS7.defineMethod("detached=",p7cb.getMethod("set_detached",IRubyObject.class));
         cPKCS7.defineMethod("detached",p7cb.getMethod("detached"));
         cPKCS7.defineMethod("detached?",p7cb.getMethod("detached_p"));
         cPKCS7.defineMethod("cipher=",p7cb.getMethod("set_cipher",IRubyObject.class));
         cPKCS7.defineMethod("add_signer",p7cb.getMethod("add_signer",IRubyObject.class));
         cPKCS7.defineMethod("signers",p7cb.getMethod("signers"));
         cPKCS7.defineMethod("add_recipient",p7cb.getMethod("add_recipient",IRubyObject.class));
         cPKCS7.defineMethod("recipients",p7cb.getMethod("recipients"));
         cPKCS7.defineMethod("add_certificate",p7cb.getMethod("add_certificate",IRubyObject.class));
         cPKCS7.defineMethod("certificates=",p7cb.getMethod("set_certificates",IRubyObject.class));
         cPKCS7.defineMethod("certificates",p7cb.getMethod("certificates"));
         cPKCS7.defineMethod("add_crl",p7cb.getMethod("add_crl",IRubyObject.class));
         cPKCS7.defineMethod("crls=",p7cb.getMethod("set_crls",IRubyObject.class));
         cPKCS7.defineMethod("crls",p7cb.getMethod("crls"));
         cPKCS7.defineMethod("add_data",p7cb.getMethod("add_data",IRubyObject.class));
         cPKCS7.defineMethod("data=",p7cb.getMethod("add_data",IRubyObject.class));
         cPKCS7.defineMethod("verify",p7cb.getOptMethod("verify"));
         cPKCS7.defineMethod("decrypt",p7cb.getOptMethod("decrypt"));
         cPKCS7.defineMethod("to_pem",p7cb.getMethod("to_pem"));
         cPKCS7.defineMethod("to_s",p7cb.getMethod("to_pem"));
         cPKCS7.defineMethod("to_der",p7cb.getMethod("to_der"));
 
         SignerInfo.createSignerInfo(runtime,mPKCS7);
         RecipientInfo.createRecipientInfo(runtime,mPKCS7);
 
         mPKCS7.setConstant("TEXT",runtime.newFixnum(1));
         mPKCS7.setConstant("NOCERTS",runtime.newFixnum(2));
         mPKCS7.setConstant("NOSIGS",runtime.newFixnum(4));
         mPKCS7.setConstant("NOCHAIN",runtime.newFixnum(8));
         mPKCS7.setConstant("NOINTERN",runtime.newFixnum(16));
         mPKCS7.setConstant("NOVERIFY",runtime.newFixnum(32));
         mPKCS7.setConstant("DETACHED",runtime.newFixnum(64));
         mPKCS7.setConstant("BINARY",runtime.newFixnum(128));
         mPKCS7.setConstant("NOATTR",runtime.newFixnum(256));
         mPKCS7.setConstant("NOSMIMECAP",runtime.newFixnum(512));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        IRubyObject result = new PKCS7(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public static IRubyObject read_smime(IRubyObject recv, IRubyObject arg) {
         System.err.println("WARNING: un-implemented method called PKCS7#read_smime");
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject write_smime(IRubyObject recv, IRubyObject[] args) {
         System.err.println("WARNING: un-implemented method called PKCS7#write_smime");
         return recv.getRuntime().getNil();
     }
 
     public static IRubyObject sign(IRubyObject recv, IRubyObject[] args) throws Exception {
         IRubyObject cert = recv.getRuntime().getNil();
         IRubyObject key = recv.getRuntime().getNil();
         IRubyObject data = recv.getRuntime().getNil();
         IRubyObject certs = recv.getRuntime().getNil();
         IRubyObject flags = recv.getRuntime().getNil();
         recv.checkArgumentCount(args,3,5);
         switch(args.length) {
         case 5:
             flags = args[4];
         case 4:
             certs = args[3];
         case 3:
             cert = args[0];
             key = args[1];
             data = args[2];
         }
 
         X509AuxCertificate x509 = ((X509Cert)cert).getAuxCert();
         PrivateKey pkey = ((PKey)key).getPrivateKey();
         String in = data.toString();
         List x509s = null;
         if(!certs.isNil()) {
             x509s = new ArrayList();
             for(Iterator iter = ((RubyArray)certs).getList().iterator();iter.hasNext();) {
                 x509s.add(((X509Cert)iter.next()).getAuxCert());
             }
             x509s.add(x509);
         }
 
         CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
 
         gen.addSigner(pkey,x509,"1.3.14.3.2.26"); //SHA1 OID
         if(x509s != null) {
             CertStore store = CertStore.getInstance("Collection", new CollectionCertStoreParameters(x509s));
             gen.addCertificatesAndCRLs(store);
         }
         CMSSignedData sdata = gen.generate(new CMSProcessableByteArray(in.getBytes("PLAIN")),"BC");
         
         PKCS7 ret = new PKCS7(recv.getRuntime(),((RubyClass)((RubyModule)(recv.getRuntime().getModule("OpenSSL").getConstant("PKCS7"))).getConstant("PKCS7")));
         ret.setInstanceVariable("@data",recv.getRuntime().getNil());
         ret.setInstanceVariable("@error_string",recv.getRuntime().getNil());
         ret.signedData = sdata;
 
         return ret;
     }
 
     public static IRubyObject encrypt(IRubyObject recv, IRubyObject[] args) {
         System.err.println("WARNING: un-implemented method called PKCS7#encrypt");
         return recv.getRuntime().getNil();
     }
 
     public PKCS7(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private CMSSignedData signedData;
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         if(checkArgumentCount(args,0,1) == 0) {
             return this;
         }
         IRubyObject arg = OpenSSLImpl.to_der_if_possible(args[0]);
         byte[] b = arg.toString().getBytes("PLAIN");
         signedData = PEM.read_PKCS7(new InputStreamReader(new ByteArrayInputStream(b)),null);
         if(null == signedData) {
             signedData = new CMSSignedData(ContentInfo.getInstance(new ASN1InputStream(b).readObject()));
         }
         this.setInstanceVariable("@data",getRuntime().getNil());
         this.setInstanceVariable("@error_string",getRuntime().getNil());
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#init_copy");
         if(this == obj) {
             return this;
         }
         checkFrozen();
         return this;
     }
 
     public IRubyObject set_type(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#type=");
         return getRuntime().getNil();
     }
 
     public IRubyObject get_type() {
         System.err.println("WARNING: un.implemented method called PKCS7#type");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_detached(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#detached=");
         return getRuntime().getNil();
     }
 
     public IRubyObject detached() {
         System.err.println("WARNING: un.implemented method called PKCS7#detached");
         return getRuntime().getNil();
     }
 
     public IRubyObject detached_p() {
         System.err.println("WARNING: un.implemented method called PKCS7#detached?");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_cipher(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#cipher=");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_signer(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#add_signer");
         return getRuntime().getNil();
     }
 
     public IRubyObject signers() {
         System.err.println("WARNING: un.implemented method called PKCS7#signers");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_recipient(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#add_recipient");
         return getRuntime().getNil();
     }
 
     public IRubyObject recipients() {
         System.err.println("WARNING: un.implemented method called PKCS7#recipients");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_certificate(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#add_certificate");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_certificates(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#certificates=");
         return getRuntime().getNil();
     }
 
     public IRubyObject certificates() throws Exception {
         CertStore cc = signedData.getCertificatesAndCRLs("Collection","BC");
         List l = X509_STORE_CTX.transform(cc.getCertificates(null));
         return getRuntime().newArray(l);
     }
 
     public IRubyObject add_crl(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#add_crl");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_crls(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#crls=");
         return getRuntime().getNil();
     }
 
     public IRubyObject crls() {
         System.err.println("WARNING: un.implemented method called PKCS7#crls");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_data(IRubyObject obj) {
         System.err.println("WARNING: un.implemented method called PKCS7#add_data");
         return getRuntime().getNil();
     }
 
     public IRubyObject verify(IRubyObject[] args) throws Exception {
         IRubyObject certs, store;
         IRubyObject indata = getRuntime().getNil();
         IRubyObject flags = getRuntime().getNil();
         switch(checkArgumentCount(args,2,4)) {
         case 4:
             flags = args[3];
         case 3:
             indata = args[2];
         default:
             certs = args[0];
             store = args[1];
         }
         
         if(indata.isNil()) {
             indata = getInstanceVariable("@data");
         }
         List x509s = null;
         if(!certs.isNil()) {
             x509s = new ArrayList();
             for(Iterator iter = ((RubyArray)certs).getList().iterator();iter.hasNext();) {
                 x509s.add(((X509Cert)iter.next()).getAuxCert());
             }
         }
 
         CertStore _x509s = CertStore.getInstance("Collection", new CollectionCertStoreParameters(x509s));
 
         int verified = 0;
 
         SignerInformationStore  signers =  signedData.getSignerInfos();
         CertStore  cs =                    signedData.getCertificatesAndCRLs("Collection","BC");
         Collection              c = signers.getSigners();
         Iterator                it = c.iterator();
   
         while(it.hasNext()) {
             SignerInformation   signer = (SignerInformation)it.next();
             System.err.println(signer.getSignedAttributes().toHashtable());
 
             Collection          certCollection = _x509s.getCertificates(signer.getSID());
             Iterator        certIt = certCollection.iterator();
             X509Certificate cert = null;
 
             if(certIt.hasNext()) {
                 cert = (X509AuxCertificate)certIt.next();
             }
             if(cert == null) {
                 Collection          certCollection2 = cs.getCertificates(signer.getSID());
                 Iterator        certIt2 = certCollection2.iterator();
                 if(certIt2.hasNext()) {
                     cert = (X509Certificate)certIt2.next();
                 }                
             }
             if(null != cert && signer.verify(cert,"BC")) {
                 verified++;
             }   
         }
 
         return (verified != 0) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject decrypt(IRubyObject[] args) {
         System.err.println("WARNING: un.implemented method called PKCS7#decrypt");
         return getRuntime().getNil();
     }
 
     public IRubyObject to_pem() throws Exception {
         StringWriter w = new StringWriter();
         PEM.write_PKCS7(w,signedData);
         w.close();
         return getRuntime().newString(w.toString());
     }
 
     public IRubyObject to_der() throws Exception {
         return getRuntime().newString(new String(signedData.getEncoded(),"ISO8859_1"));
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new PKCS7(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 
     public static class SignerInfo extends RubyObject {
+        private static ObjectAllocator SIGNERINFO_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new SignerInfo(runtime, klass);
+            }
+        };
+    
         public static void createSignerInfo(IRuby runtime, RubyModule mPKCS7) {
-            RubyClass cPKCS7Signer = mPKCS7.defineClassUnder("SignerInfo",runtime.getObject());
+            RubyClass cPKCS7Signer = mPKCS7.defineClassUnder("SignerInfo",runtime.getObject(),SIGNERINFO_ALLOCATOR);
             mPKCS7.defineConstant("Signer",cPKCS7Signer);
 
             CallbackFactory p7scb = runtime.callbackFactory(SignerInfo.class);
-            cPKCS7Signer.defineSingletonMethod("new",p7scb.getOptSingletonMethod("newInstance"));
             cPKCS7Signer.defineMethod("initialize",p7scb.getMethod("initialize",IRubyObject.class,IRubyObject.class,IRubyObject.class));
             cPKCS7Signer.defineMethod("issuer",p7scb.getMethod("issuer"));
             cPKCS7Signer.defineMethod("name",p7scb.getMethod("issuer"));
             cPKCS7Signer.defineMethod("serial",p7scb.getMethod("serial"));
             cPKCS7Signer.defineMethod("signed_time",p7scb.getMethod("signed_time"));
         }
 
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            IRubyObject result = new SignerInfo(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public SignerInfo(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         public IRubyObject initialize(IRubyObject arg1, IRubyObject arg2, IRubyObject arg3) {
             System.err.println("WARNING: un-implemented method called SignerInfo#initialize");
             return this;
         }
 
         public IRubyObject issuer() {
             System.err.println("WARNING: un-implemented method called SignerInfo#issuer");
             return getRuntime().getNil();
         }
 
         public IRubyObject serial() {
             System.err.println("WARNING: un-implemented method called SignerInfo#serial");
             return getRuntime().getNil();
         }
 
         public IRubyObject signed_time() {
             System.err.println("WARNING: un-implemented method called SignerInfo#signed_time");
             return getRuntime().getNil();
         }
     }
 
     public static class RecipientInfo extends RubyObject {
+        private static ObjectAllocator RECIPIENTINFO_ALLOCATOR = new ObjectAllocator() {
+            public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+                return new RecipientInfo(runtime, klass);
+            }
+        };
+    
         public static void createRecipientInfo(IRuby runtime, RubyModule mPKCS7) {
-            RubyClass cPKCS7Recipient = mPKCS7.defineClassUnder("RecipientInfo",runtime.getObject());
+            RubyClass cPKCS7Recipient = mPKCS7.defineClassUnder("RecipientInfo",runtime.getObject(),RECIPIENTINFO_ALLOCATOR);
 
             CallbackFactory p7rcb = runtime.callbackFactory(RecipientInfo.class);
-            cPKCS7Recipient.defineSingletonMethod("new",p7rcb.getOptSingletonMethod("newInstance"));
             cPKCS7Recipient.defineMethod("initialize",p7rcb.getMethod("initialize",IRubyObject.class));
             cPKCS7Recipient.defineMethod("issuer",p7rcb.getMethod("issuer"));
             cPKCS7Recipient.defineMethod("serial",p7rcb.getMethod("serial"));
             cPKCS7Recipient.defineMethod("enc_key",p7rcb.getMethod("enc_key"));
         }
 
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            IRubyObject result = new RecipientInfo(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public RecipientInfo(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         public IRubyObject initialize(IRubyObject arg) {
             System.err.println("WARNING: un-implemented method called RecipientInfo#initialize");
             return this;
         }
 
         public IRubyObject issuer() {
             System.err.println("WARNING: un-implemented method called RecipientInfo#issuer");
             return getRuntime().getNil();
         }
 
         public IRubyObject serial() {
             System.err.println("WARNING: un-implemented method called RecipientInfo#serial");
             return getRuntime().getNil();
         }
 
         public IRubyObject enc_key() {
             System.err.println("WARNING: un-implemented method called RecipientInfo#enc_key");
             return getRuntime().getNil();
         }
     }
 }// PKCS7
diff --git a/src/org/jruby/ext/openssl/PKey.java b/src/org/jruby/ext/openssl/PKey.java
index a11ecbb136..f08b551a63 100644
--- a/src/org/jruby/ext/openssl/PKey.java
+++ b/src/org/jruby/ext/openssl/PKey.java
@@ -1,133 +1,131 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.security.Signature;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public abstract class PKey extends RubyObject {
     public static void createPKey(IRuby runtime, RubyModule ossl) {
         RubyModule mPKey = ossl.defineModuleUnder("PKey");
-        RubyClass cPKey = mPKey.defineClassUnder("PKey",runtime.getObject());
-        mPKey.defineClassUnder("PKeyError",ossl.getClass("OpenSSLError"));
+        // PKey is abstract
+        RubyClass cPKey = mPKey.defineClassUnder("PKey",runtime.getObject(),ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mPKey.defineClassUnder("PKeyError",openSSLError,openSSLError.getAllocator());
         
         CallbackFactory pkeycb = runtime.callbackFactory(PKey.class);
 
-        cPKey.defineSingletonMethod("new",pkeycb.getSingletonMethod("newInstance"));
         cPKey.defineMethod("initialize",pkeycb.getMethod("initialize"));
         cPKey.defineMethod("sign",pkeycb.getMethod("sign",IRubyObject.class,IRubyObject.class));
         cPKey.defineMethod("verify",pkeycb.getMethod("verify",IRubyObject.class,IRubyObject.class,IRubyObject.class));
 
         PKeyRSA.createPKeyRSA(runtime,mPKey);
         PKeyDSA.createPKeyDSA(runtime,mPKey);
         //        createPKeyDH(runtime,mPKey);
     }
 
-    public static IRubyObject newInstance(IRubyObject recv) {
-        throw recv.getRuntime().newNotImplementedError("OpenSSL::PKey::PKey is an abstract class.");
-    }
-
     public PKey(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     public IRubyObject initialize() {
         return this;
     }
 
     PublicKey getPublicKey() {
         return null;
     }
 
     PrivateKey getPrivateKey() {
         return null;
     }
 
     String getAlgorithm() {
         return "NONE";
     }
 
     public abstract IRubyObject to_der() throws Exception;
 
     public IRubyObject sign(IRubyObject digest, IRubyObject data) throws Exception {
         if(!this.callMethod(getRuntime().getCurrentContext(),"private?").isTrue()) {
             throw getRuntime().newArgumentError("Private key is needed.");
         }
         Signature sig = Signature.getInstance(((Digest)digest).getAlgorithm() + "WITH" + getAlgorithm(),"BC");
         sig.initSign(getPrivateKey());
         byte[] inp = data.toString().getBytes("PLAIN");
         sig.update(inp);
         byte[] sigge = sig.sign();
         return getRuntime().newString(new String(sigge,"ISO8859_1"));
         /*
     GetPKey(self, pkey);
     EVP_SignInit(&ctx, GetDigestPtr(digest));
     StringValue(data);
     EVP_SignUpdate(&ctx, RSTRING(data)->ptr, RSTRING(data)->len);
     str = rb_str_new(0, EVP_PKEY_size(pkey)+16);
     if (!EVP_SignFinal(&ctx, RSTRING(str)->ptr, &buf_len, pkey))
 	ossl_raise(ePKeyError, NULL);
     assert(buf_len <= RSTRING(str)->len);
     RSTRING(str)->len = buf_len;
     RSTRING(str)->ptr[buf_len] = 0;
 
     return str;
          */
     }
 
     public IRubyObject verify(IRubyObject digest, IRubyObject sig, IRubyObject data) {
         System.err.println("WARNING: unimplemented method PKey#verify called");
         /*
     GetPKey(self, pkey);
     EVP_VerifyInit(&ctx, GetDigestPtr(digest));
     StringValue(sig);
     StringValue(data);
     EVP_VerifyUpdate(&ctx, RSTRING(data)->ptr, RSTRING(data)->len);
     switch (EVP_VerifyFinal(&ctx, RSTRING(sig)->ptr, RSTRING(sig)->len, pkey)) {
     case 0:
 	return Qfalse;
     case 1:
 	return Qtrue;
     default:
 	ossl_raise(ePKeyError, NULL);
     }
         */
         return getRuntime().getNil();
     }
 }// PKey
diff --git a/src/org/jruby/ext/openssl/PKeyDSA.java b/src/org/jruby/ext/openssl/PKeyDSA.java
index b8502172cf..c0808035f8 100644
--- a/src/org/jruby/ext/openssl/PKeyDSA.java
+++ b/src/org/jruby/ext/openssl/PKeyDSA.java
@@ -1,266 +1,267 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.security.KeyFactory;
 import java.security.KeyPair;
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.security.interfaces.DSAParams;
 import java.security.interfaces.DSAPrivateKey;
 import java.security.interfaces.DSAPublicKey;
 import java.security.spec.PKCS8EncodedKeySpec;
 import java.security.spec.X509EncodedKeySpec;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.DERInteger;
 import org.bouncycastle.asn1.DERSequence;
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyModule;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.PEM;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class PKeyDSA extends PKey {
+    private static ObjectAllocator PKEYDSA_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new PKeyDSA(runtime, klass);
+        }
+    };
+    
     public static void createPKeyDSA(IRuby runtime, RubyModule mPKey) {
-        RubyClass cDSA = mPKey.defineClassUnder("DSA",mPKey.getClass("PKey"));
-        mPKey.defineClassUnder("DSAError",mPKey.getClass("PKeyError"));
+        RubyClass cDSA = mPKey.defineClassUnder("DSA",mPKey.getClass("PKey"),PKEYDSA_ALLOCATOR);
+        RubyClass pkeyError = mPKey.getClass("PKeyError");
+        mPKey.defineClassUnder("DSAError",pkeyError,pkeyError.getAllocator());
         
         CallbackFactory dsacb = runtime.callbackFactory(PKeyDSA.class);
 
-        cDSA.defineSingletonMethod("new",dsacb.getOptSingletonMethod("newInstance"));
         cDSA.defineMethod("initialize",dsacb.getOptMethod("initialize"));
 
         cDSA.defineMethod("public?",dsacb.getMethod("public_p"));
         cDSA.defineMethod("private?",dsacb.getMethod("private_p"));
         cDSA.defineMethod("to_der",dsacb.getMethod("to_der"));
         cDSA.defineMethod("to_text",dsacb.getMethod("to_text"));
         cDSA.defineMethod("public_key",dsacb.getMethod("public_key"));
         cDSA.defineMethod("export",dsacb.getOptMethod("export"));
         cDSA.defineMethod("to_pem",dsacb.getOptMethod("export"));
         cDSA.defineMethod("to_s",dsacb.getOptMethod("export"));
         cDSA.defineMethod("syssign",dsacb.getMethod("syssign",IRubyObject.class));
         cDSA.defineMethod("sysverify",dsacb.getMethod("sysverify",IRubyObject.class,IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        PKeyDSA result = new PKeyDSA(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public PKeyDSA(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private DSAPrivateKey privKey;
     private DSAPublicKey pubKey;
 
     PublicKey getPublicKey() {
         return pubKey;
     }
 
     PrivateKey getPrivateKey() {
         return privKey;
     }
 
     String getAlgorithm() {
         return "DSA";
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         Object rsa;
         IRubyObject arg;
         IRubyObject pass = null;
         char[] passwd = null;
         if(checkArgumentCount(args,0,2) == 0) {
             rsa = null; //DSA.new
         } else {
             arg = args[0];
             if(args.length > 1) {
                 pass = args[1];
             }
             if(arg instanceof RubyFixnum) {
             } else {
                 if(pass != null && !pass.isNil()) {
                     passwd = pass.toString().toCharArray();
                 }
                 String input = arg.toString();
 
                 Object val = null;
                 KeyFactory fact = null;
                 try {
                     fact = KeyFactory.getInstance("DSA");
                 } catch(Exception e) {
                     throw getRuntime().newLoadError("unsupported key algorithm (DSA)");
                 }
                 if(null == val) {
                     try {
                         val = PEM.read_DSAPrivateKey(new StringReader(input),passwd);
                     } catch(Exception e3) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = PEM.read_DSAPublicKey(new StringReader(input),passwd);
                     } catch(Exception e3) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = PEM.read_DSA_PUBKEY(new StringReader(input),passwd);
                     } catch(Exception e3) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = fact.generatePrivate(new PKCS8EncodedKeySpec(input.getBytes("PLAIN")));
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = fact.generatePublic(new X509EncodedKeySpec(input.getBytes("PLAIN")));
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("DSAError")), "Neither PUB key nor PRIV key:", true);
                 }
 
                 if(val instanceof KeyPair) {
                     privKey = (DSAPrivateKey)(((KeyPair)val).getPrivate());
                     pubKey = (DSAPublicKey)(((KeyPair)val).getPublic());
                 } else if(val instanceof DSAPrivateKey) {
                     privKey = (DSAPrivateKey)val;
                 } else if(val instanceof DSAPublicKey) {
                     pubKey = (DSAPublicKey)val;
                     privKey = null;
                 } else {
                     throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("DSAError")), "Neither PUB key nor PRIV key:", true);
                 }
             }
         }
 
         return this;
     }
 
     public IRubyObject public_p() {
         return pubKey != null ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject private_p() {
         return privKey != null ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject to_der() throws Exception {
         if(pubKey != null && privKey == null) {
             return getRuntime().newString( new String(pubKey.getEncoded(),"ISO8859_1"));
         } else if(privKey != null && pubKey != null) {
             DSAParams params = privKey.getParams();
             ASN1EncodableVector v1 = new ASN1EncodableVector();
             v1.add(new DERInteger(0));
             v1.add(new DERInteger(params.getP()));
             v1.add(new DERInteger(params.getQ()));
             v1.add(new DERInteger(params.getG()));
             v1.add(new DERInteger(pubKey.getY()));
             v1.add(new DERInteger(privKey.getX()));
             return getRuntime().newString( new String(new DERSequence(v1).getEncoded(),"ISO8859_1"));
         } else {
             return getRuntime().newString( new String(privKey.getEncoded(),"ISO8859_1"));
         }
     }
 
     public IRubyObject to_text() throws Exception {
         return getRuntime().getNil();
     }
 
     public IRubyObject public_key() {
         PKeyDSA val = new PKeyDSA(getRuntime(),getMetaClass().getRealClass());
         val.privKey = null;
         val.pubKey = this.pubKey;
         return val;
     }
 
     public IRubyObject export(IRubyObject[] args) throws Exception {
         StringWriter w = new StringWriter();
         checkArgumentCount(args,0,2);
         char[] passwd = null;
         String algo = null;
         if(args.length > 0 && !args[0].isNil()) {
             algo = ((Cipher)args[0]).getAlgorithm();
             if(args.length > 1 && !args[1].isNil()) {
                 passwd = args[1].toString().toCharArray();
             }
         }
         if(privKey != null) {
             PEM.write_DSAPrivateKey(w,privKey,algo,passwd);
         } else {
             PEM.write_DSAPublicKey(w,pubKey);
         }
         w.close();
         return getRuntime().newString(w.toString());
     }
 
     private String getPadding(int padding) {
         if(padding < 1 || padding > 4) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("DSAError")), null, true);
         }
 
         String p = "/NONE/PKCS1Padding";
         if(padding == 3) {
             p = "/NONE/NoPadding";
         } else if(padding == 4) {
             p = "/NONE/OAEPWithMD5AndMGF1Padding";
         } else if(padding == 2) {
             p = "/NONE/ISO9796-1Padding";
         }
         return p;
     }        
 
     public IRubyObject syssign(IRubyObject arg) {
         return getRuntime().getNil();
     }
 
     public IRubyObject sysverify(IRubyObject arg, IRubyObject arg2) {
         return getRuntime().getNil();
     }
 }// PKeyDSA
diff --git a/src/org/jruby/ext/openssl/PKeyRSA.java b/src/org/jruby/ext/openssl/PKeyRSA.java
index 78303196f9..c7960284d2 100644
--- a/src/org/jruby/ext/openssl/PKeyRSA.java
+++ b/src/org/jruby/ext/openssl/PKeyRSA.java
@@ -1,388 +1,389 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.math.BigInteger;
 import java.security.KeyFactory;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.security.interfaces.RSAPrivateCrtKey;
 import java.security.interfaces.RSAPublicKey;
 import java.security.spec.PKCS8EncodedKeySpec;
 import java.security.spec.RSAKeyGenParameterSpec;
 import java.security.spec.RSAPrivateCrtKeySpec;
 import java.security.spec.RSAPublicKeySpec;
 import java.security.spec.X509EncodedKeySpec;
 
 import javax.crypto.Cipher;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.DERInteger;
 import org.bouncycastle.asn1.DERSequence;
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.PEM;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class PKeyRSA extends PKey {
+    private static ObjectAllocator PKEYRSA_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new PKeyRSA(runtime, klass);
+        }
+    };
+    
     public static void createPKeyRSA(IRuby runtime, RubyModule mPKey) {
-        RubyClass cRSA = mPKey.defineClassUnder("RSA",mPKey.getClass("PKey"));
-        mPKey.defineClassUnder("RSAError",mPKey.getClass("PKeyError"));
+        RubyClass cRSA = mPKey.defineClassUnder("RSA",mPKey.getClass("PKey"),PKEYRSA_ALLOCATOR);
+        RubyClass pkeyError = mPKey.getClass("PKeyError");
+        mPKey.defineClassUnder("RSAError",pkeyError,pkeyError.getAllocator());
         
         CallbackFactory rsacb = runtime.callbackFactory(PKeyRSA.class);
 
-        cRSA.defineSingletonMethod("new",rsacb.getOptSingletonMethod("newInstance"));
         cRSA.defineMethod("initialize",rsacb.getOptMethod("initialize"));
         cRSA.defineMethod("public?",rsacb.getMethod("public_p"));
         cRSA.defineMethod("private?",rsacb.getMethod("private_p"));
         cRSA.defineMethod("to_der",rsacb.getMethod("to_der"));
         cRSA.defineMethod("public_key",rsacb.getMethod("public_key"));
         cRSA.defineMethod("export",rsacb.getOptMethod("export"));
         cRSA.defineMethod("to_pem",rsacb.getOptMethod("export"));
         cRSA.defineMethod("to_s",rsacb.getOptMethod("export"));
         cRSA.defineMethod("private_encrypt",rsacb.getOptMethod("private_encrypt"));
         cRSA.defineMethod("private_decrypt",rsacb.getOptMethod("private_decrypt"));
         cRSA.defineMethod("public_encrypt",rsacb.getOptMethod("public_encrypt"));
         cRSA.defineMethod("public_decrypt",rsacb.getOptMethod("public_decrypt"));
 
         cRSA.setConstant("PKCS1_PADDING",runtime.newFixnum(1));
         cRSA.setConstant("SSLV23_PADDING",runtime.newFixnum(2));
         cRSA.setConstant("NO_PADDING",runtime.newFixnum(3));
         cRSA.setConstant("PKCS1_OAEP_PADDING",runtime.newFixnum(4));
    }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        PKeyRSA result = new PKeyRSA(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public PKeyRSA(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private RSAPrivateCrtKey privKey;
     private RSAPublicKey pubKey;
 
     PublicKey getPublicKey() {
         return pubKey;
     }
 
     PrivateKey getPrivateKey() {
         return privKey;
     }
 
     String getAlgorithm() {
         return "RSA";
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         Object rsa;
         IRubyObject arg;
         IRubyObject pass = null;
         char[] passwd = null;
         if(checkArgumentCount(args,0,2) == 0) {
             rsa = null; //RSA.new
         } else {
             arg = args[0];
             if(args.length > 1) {
                 pass = args[1];
             }
             if(arg instanceof RubyFixnum) {
                 int keyLen = RubyNumeric.fix2int(arg);
                 BigInteger pubExp = RSAKeyGenParameterSpec.F4;
                 if(null != pass && !pass.isNil()) {
                     pubExp = BigInteger.valueOf(RubyNumeric.num2long(pass));
                 }
                 try {
                     KeyPairGenerator gen = KeyPairGenerator.getInstance("RSA");
                     gen.initialize(new RSAKeyGenParameterSpec(keyLen,pubExp));
                     KeyPair pair = gen.generateKeyPair();
                     privKey = (RSAPrivateCrtKey)(pair.getPrivate());
                     pubKey = (RSAPublicKey)(pair.getPublic());
                 } catch(Exception e) {
                     throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), null, true);
                 }
             } else {
                 if(pass != null && !pass.isNil()) {
                     passwd = pass.toString().toCharArray();
                 }
                 String input = arg.toString();
 
                 Object val = null;
                 KeyFactory fact = null;
                 try {
                     fact = KeyFactory.getInstance("RSA");
                 } catch(Exception e) {
                     throw getRuntime().newLoadError("unsupported key algorithm (RSA)");
                 }
 
                 if(null == val) {
                     try {
                         val = PEM.read_RSAPrivateKey(new StringReader(input),passwd);
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = PEM.read_RSAPublicKey(new StringReader(input),passwd);
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = PEM.read_RSA_PUBKEY(new StringReader(input),passwd);
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         DERSequence seq = (DERSequence)(new ASN1InputStream(input.getBytes("PLAIN")).readObject());
                         if(seq.size() == 9) {
                             BigInteger mod = ((DERInteger)seq.getObjectAt(1)).getValue();
                             BigInteger pubexp = ((DERInteger)seq.getObjectAt(2)).getValue();
                             BigInteger privexp = ((DERInteger)seq.getObjectAt(3)).getValue();
                             BigInteger primep = ((DERInteger)seq.getObjectAt(4)).getValue();
                             BigInteger primeq = ((DERInteger)seq.getObjectAt(5)).getValue();
                             BigInteger primeep = ((DERInteger)seq.getObjectAt(6)).getValue();
                             BigInteger primeeq = ((DERInteger)seq.getObjectAt(7)).getValue();
                             BigInteger crtcoeff = ((DERInteger)seq.getObjectAt(8)).getValue();
                             val = fact.generatePrivate(new RSAPrivateCrtKeySpec(mod,pubexp,privexp,primep,primeq,primeep,primeeq,crtcoeff));
                         } else {
                             val = null;
                         }
                     } catch(Exception ex) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         DERSequence seq = (DERSequence)(new ASN1InputStream(input.getBytes("PLAIN")).readObject());
                         if(seq.size() == 2) {
                             BigInteger mod = ((DERInteger)seq.getObjectAt(0)).getValue();
                             BigInteger pubexp = ((DERInteger)seq.getObjectAt(1)).getValue();
                             val = fact.generatePublic(new RSAPublicKeySpec(mod,pubexp));
                         } else {
                             val = null;
                         }
                     } catch(Exception ex) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = fact.generatePublic(new X509EncodedKeySpec(input.getBytes("PLAIN")));
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     try {
                         val = fact.generatePrivate(new PKCS8EncodedKeySpec(input.getBytes("PLAIN")));
                     } catch(Exception e) {
                         val = null;
                     }
                 }
                 if(null == val) {
                     throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), "Neither PUB key nor PRIV key:", true);
                 }
 
                 if(val instanceof KeyPair) {
                     privKey = (RSAPrivateCrtKey)(((KeyPair)val).getPrivate());
                     pubKey = (RSAPublicKey)(((KeyPair)val).getPublic());
                 } else if(val instanceof RSAPrivateCrtKey) {
                     privKey = (RSAPrivateCrtKey)val;
                     try {
                         pubKey = (RSAPublicKey)(fact.generatePublic(new RSAPublicKeySpec(privKey.getModulus(),privKey.getPublicExponent())));
                     } catch(Exception e) {
                         throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), "Something rotten with private key", true);
                     }
                 } else if(val instanceof RSAPublicKey) {
                     pubKey = (RSAPublicKey)val;
                     privKey = null;
                 } else {
                     throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), "Neither PUB key nor PRIV key:", true);
                 }
             }
         }
 
         return this;
     }
 
     public IRubyObject public_p() {
         return pubKey != null ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject private_p() {
         return privKey != null ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject to_der() throws Exception {
         if(pubKey != null && privKey == null) {
             ASN1EncodableVector v1 = new ASN1EncodableVector();
             v1.add(new DERInteger(pubKey.getModulus()));
             v1.add(new DERInteger(pubKey.getPublicExponent()));
             return getRuntime().newString( new String(new DERSequence(v1).getEncoded(),"ISO8859_1"));
         } else {
             ASN1EncodableVector v1 = new ASN1EncodableVector();
             v1.add(new DERInteger(0));
             v1.add(new DERInteger(privKey.getModulus()));
             v1.add(new DERInteger(privKey.getPublicExponent()));
             v1.add(new DERInteger(privKey.getPrivateExponent()));
             v1.add(new DERInteger(privKey.getPrimeP()));
             v1.add(new DERInteger(privKey.getPrimeQ()));
             v1.add(new DERInteger(privKey.getPrimeExponentP()));
             v1.add(new DERInteger(privKey.getPrimeExponentQ()));
             v1.add(new DERInteger(privKey.getCrtCoefficient()));
             return getRuntime().newString( new String(new DERSequence(v1).getEncoded(),"ISO8859_1"));
         }
     }
 
     public IRubyObject public_key() {
         PKeyRSA val = new PKeyRSA(getRuntime(),getMetaClass().getRealClass());
         val.privKey = null;
         val.pubKey = this.pubKey;
         return val;
     }
 
     public IRubyObject export(IRubyObject[] args) throws Exception {
         StringWriter w = new StringWriter();
         checkArgumentCount(args,0,2);
         char[] passwd = null;
         String algo = null;
         if(args.length > 0 && !args[0].isNil()) {
             algo = ((Cipher)args[0]).getAlgorithm();
             if(args.length > 1 && !args[1].isNil()) {
                 passwd = args[1].toString().toCharArray();
             }
         }
         if(privKey != null) {
             PEM.write_RSAPrivateKey(w,privKey,algo,passwd);
         } else {
             PEM.write_RSAPublicKey(w,pubKey);
         }
         w.close();
         return getRuntime().newString(w.toString());
     }
 
     private String getPadding(int padding) {
         if(padding < 1 || padding > 4) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), null, true);
         }
 
         String p = "/NONE/PKCS1Padding";
         if(padding == 3) {
             p = "/NONE/NoPadding";
         } else if(padding == 4) {
             p = "/NONE/OAEPWithMD5AndMGF1Padding";
         } else if(padding == 2) {
             p = "/NONE/ISO9796-1Padding";
         }
         return p;
     }        
 
     public IRubyObject private_encrypt(IRubyObject[] args) throws Exception {
         int padding = 1;
         if(checkArgumentCount(args,1,2) == 2 && !args[1].isNil()) {
             padding = RubyNumeric.fix2int(args[1]);
         }
         String p = getPadding(padding);
 
         String buffer = args[0].toString();
         if(privKey == null) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), "private key needed.", true);
         }
 
         Cipher engine = Cipher.getInstance("RSA"+p);
         engine.init(Cipher.ENCRYPT_MODE,privKey);
         byte[] outp = engine.doFinal(buffer.getBytes("PLAIN"));
         return getRuntime().newString(new String(outp,"ISO8859_1"));
     }
 
     public IRubyObject private_decrypt(IRubyObject[] args) throws Exception {
         int padding = 1;
         if(checkArgumentCount(args,1,2) == 2 && !args[1].isNil()) {
             padding = RubyNumeric.fix2int(args[1]);
         }
         String p = getPadding(padding);
 
         String buffer = args[0].toString();
         if(privKey == null) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getConstant("RSAError")), "private key needed.", true);
         }
 
         Cipher engine = Cipher.getInstance("RSA"+p);
         engine.init(Cipher.DECRYPT_MODE,privKey);
         byte[] outp = engine.doFinal(buffer.getBytes("PLAIN"));
         return getRuntime().newString(new String(outp,"ISO8859_1"));
     }
 
     public IRubyObject public_encrypt(IRubyObject[] args) throws Exception {
         int padding = 1;
         if(checkArgumentCount(args,1,2) == 2 && !args[1].isNil()) {
             padding = RubyNumeric.fix2int(args[1]);
         }
         String p = getPadding(padding);
 
         String buffer = args[0].toString();
         Cipher engine = Cipher.getInstance("RSA"+p);
         engine.init(Cipher.ENCRYPT_MODE,pubKey);
         byte[] outp = engine.doFinal(buffer.getBytes("PLAIN"));
         return getRuntime().newString(new String(outp,"ISO8859_1"));
     }
 
     public IRubyObject public_decrypt(IRubyObject[] args) throws Exception {
         int padding = 1;
         if(checkArgumentCount(args,1,2) == 2 && !args[1].isNil()) {
             padding = RubyNumeric.fix2int(args[1]);
         }
         String p = getPadding(padding);
 
         String buffer = args[0].toString();
         Cipher engine = Cipher.getInstance("RSA"+p);
         engine.init(Cipher.DECRYPT_MODE,pubKey);
         byte[] outp = engine.doFinal(buffer.getBytes("PLAIN"));
         return getRuntime().newString(new String(outp,"ISO8859_1"));
     }
 }// PKeyRSA
diff --git a/src/org/jruby/ext/openssl/Request.java b/src/org/jruby/ext/openssl/Request.java
index 26328e5a1f..75a2f2ef7d 100644
--- a/src/org/jruby/ext/openssl/Request.java
+++ b/src/org/jruby/ext/openssl/Request.java
@@ -1,288 +1,288 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1Set;
 import org.bouncycastle.asn1.DERObject;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERSet;
 import org.bouncycastle.asn1.DERString;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class Request extends RubyObject {
+    private static ObjectAllocator REQUEST_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new Request(runtime, klass);
+        }
+    };
+    
     public static void createRequest(IRuby runtime, RubyModule mX509) {
-        RubyClass cRequest = mX509.defineClassUnder("Request",runtime.getObject());
-
-        mX509.defineClassUnder("RequestError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cRequest = mX509.defineClassUnder("Request",runtime.getObject(),REQUEST_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("RequestError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory reqcb = runtime.callbackFactory(Request.class);
 
-        cRequest.defineSingletonMethod("new",reqcb.getOptSingletonMethod("newInstance"));
         cRequest.defineMethod("initialize",reqcb.getOptMethod("_initialize"));
         cRequest.defineMethod("initialize_copy",reqcb.getMethod("initialize_copy",IRubyObject.class));
         cRequest.defineMethod("clone",reqcb.getMethod("rbClone"));
         cRequest.defineMethod("to_pem",reqcb.getMethod("to_pem"));
         cRequest.defineMethod("to_der",reqcb.getMethod("to_der"));
         cRequest.defineMethod("to_s",reqcb.getMethod("to_pem"));
         cRequest.defineMethod("to_text",reqcb.getMethod("to_text"));
         cRequest.defineMethod("version",reqcb.getMethod("version"));
         cRequest.defineMethod("version=",reqcb.getMethod("set_version",IRubyObject.class));
         cRequest.defineMethod("subject",reqcb.getMethod("subject"));
         cRequest.defineMethod("subject=",reqcb.getMethod("set_subject",IRubyObject.class));
         cRequest.defineMethod("signature_algorithm",reqcb.getMethod("signature_algorithm"));
         cRequest.defineMethod("public_key",reqcb.getMethod("public_key"));
         cRequest.defineMethod("public_key=",reqcb.getMethod("set_public_key",IRubyObject.class));
         cRequest.defineMethod("sign",reqcb.getMethod("sign",IRubyObject.class,IRubyObject.class));
         cRequest.defineMethod("verify",reqcb.getMethod("verify",IRubyObject.class));
         cRequest.defineMethod("attributes",reqcb.getMethod("attributes"));
         cRequest.defineMethod("attributes=",reqcb.getMethod("set_attributes",IRubyObject.class));
         cRequest.defineMethod("add_attribute",reqcb.getMethod("add_attribute",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        Request result = new Request(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private IRubyObject version;
     private IRubyObject subject;
     private IRubyObject public_key;
     private boolean valid = false;
 
     private List attrs;
 
     private PKCS10CertificationRequestExt req;
 
     public Request(IRuby runtime, RubyClass type) {
         super(runtime,type);
         attrs = new ArrayList();
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         if(checkArgumentCount(args,0,1) == 0) {
             return this;
         }
         req = new PKCS10CertificationRequestExt(args[0].toString().getBytes("PLAIN"));
         version = getRuntime().newFixnum(req.getVersion());
         String algo = req.getPublicKey().getAlgorithm();;
         byte[] enc = req.getPublicKey().getEncoded();
         ThreadContext tc = getRuntime().getCurrentContext();
         if("RSA".equalsIgnoreCase(algo)) {
             this.public_key = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getClass("RSA").callMethod(tc,"new",getRuntime().newString(new String(enc,"ISO8859_1")));
         } else if("DSA".equalsIgnoreCase(algo)) {
             this.public_key = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("PKey"))).getClass("DSA").callMethod(tc,"new",getRuntime().newString(new String(enc,"ISO8859_1")));
         } else {
             throw getRuntime().newLoadError("not implemented algo for public key: " + algo);
         }
         org.bouncycastle.asn1.x509.X509Name subName = req.getCertificationRequestInfo().getSubject();
         subject = ((RubyModule)getRuntime().getModule("OpenSSL").getConstant("X509")).getClass("Name").callMethod(tc,"new");
         DERSequence subNameD = (DERSequence)subName.toASN1Object();
         for(int i=0;i<subNameD.size();i++) {
             DERSequence internal = (DERSequence)((DERSet)subNameD.getObjectAt(i)).getObjectAt(0);
             Object oid = internal.getObjectAt(0);
             Object v = null;
             if(internal.getObjectAt(1) instanceof DERString) {
                 v = ((DERString)internal.getObjectAt(1)).getString();
             }
             Object t = getRuntime().newFixnum(ASN1.idForClass(internal.getObjectAt(1).getClass()));
             ((X509Name)subject).addEntry(oid,v,t);
         }
         ASN1Set in_attrs = req.getCertificationRequestInfo().getAttributes();
         for(Enumeration enm = in_attrs.getObjects();enm.hasMoreElements();) {
             DERSet obj = (DERSet)enm.nextElement();
             for(Enumeration enm2 = obj.getObjects();enm2.hasMoreElements();) {
                 DERSequence val = (DERSequence)enm2.nextElement();
                 DERObjectIdentifier v0 = (DERObjectIdentifier)val.getObjectAt(0);
                 DERObject v1 = (DERObject)val.getObjectAt(1);
                 IRubyObject a1 = getRuntime().newString(((String)(ASN1.getSymLookup(getRuntime()).get(v0))));
                 IRubyObject a2 = ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),getRuntime().newString(new String(v1.getDEREncoded(),"ISO8859_1")));
                 add_attribute(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Attribute").callMethod(tc,"new",new IRubyObject[]{a1,a2}));
             }
         }
         this.valid = true;
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         System.err.println("WARNING: unimplemented method called: init_copy");
         if(this == obj) {
             return this;
         }
         checkFrozen();
         version = getRuntime().getNil();
         subject = getRuntime().getNil();
         public_key = getRuntime().getNil();
         return this;
     }
 
     public IRubyObject to_pem() {
         System.err.println("WARNING: unimplemented method called: to_pem");
         return getRuntime().getNil();
     }
 
     public IRubyObject to_der() throws Exception {
         return getRuntime().newString(new String(req.getDEREncoded(),"ISO8859_1"));
     }
 
     public IRubyObject to_text() {
         System.err.println("WARNING: unimplemented method called: to_text");
         return getRuntime().getNil();
     }
 
     public IRubyObject version() {
         return this.version;
     }
 
     public IRubyObject set_version(IRubyObject val) {
         if(val != version) {
             valid = false;
         }
         this.version = val;
         if(!val.isNil() && req != null) {
             req.setVersion(RubyNumeric.fix2int(val));
         }
         return val;
     }
 
     public IRubyObject subject() {
         return this.subject;
     }
 
     public IRubyObject set_subject(IRubyObject val) {
         if(val != subject) {
             valid = false;
         }
         this.subject = val;
         return val;
     }
 
     public IRubyObject signature_algorithm() {
         System.err.println("WARNING: unimplemented method called: signature_algorithm");
         return getRuntime().getNil();
     }
 
     public IRubyObject public_key() {
         return this.public_key;
     }
 
     public IRubyObject set_public_key(IRubyObject val) {
         if(val != public_key) {
             valid = false;
         }
         this.public_key = val;
         return val;
     }
 
     public IRubyObject sign(IRubyObject key, IRubyObject digest) throws Exception {
         String keyAlg = ((PKey)public_key).getAlgorithm();
         String digAlg = ((Digest)digest).getAlgorithm();
         
         if(("DSA".equalsIgnoreCase(keyAlg) && "MD5".equalsIgnoreCase(digAlg)) || 
            ("RSA".equalsIgnoreCase(keyAlg) && "DSS1".equals(((Digest)digest).name().toString())) ||
            ("DSA".equalsIgnoreCase(keyAlg) && "SHA1".equals(((Digest)digest).name().toString()))) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("RequestError")), null, true);
         }
 
         ASN1EncodableVector v1 = new ASN1EncodableVector();
         for(Iterator iter = attrs.iterator();iter.hasNext();) {
             v1.add(((Attribute)iter.next()).toASN1());
         }
         req = new PKCS10CertificationRequestExt(digAlg + "WITH" + keyAlg,((X509Name)this.subject).getRealName(),((PKey)public_key).getPublicKey(),new DERSet(v1),((PKey)key).getPrivateKey());
         req.setVersion(RubyNumeric.fix2int(version));
         valid = true;
         return this;
     }
 
     public IRubyObject verify(IRubyObject key) {
         try {
             return valid && req.verify(((PKey)(key.callMethod(getRuntime().getCurrentContext(),"public_key"))).getPublicKey()) ? getRuntime().getTrue() : getRuntime().getFalse();
         } catch(Exception e) {
             return getRuntime().getFalse();
         }
     }
 
     public IRubyObject attributes() {
         return getRuntime().newArray(attrs);
     }
 
     public IRubyObject set_attributes(IRubyObject val) throws Exception {
         valid = false;
         attrs.clear();
         attrs.addAll(((RubyArray)val).getList());
         if(req != null) {
             ASN1EncodableVector v1 = new ASN1EncodableVector();
             for(Iterator iter = attrs.iterator();iter.hasNext();) {
                 v1.add(((Attribute)iter.next()).toASN1());
             }
             req.setAttributes(new DERSet(v1));
         }
         return val;
     }
 
     public IRubyObject add_attribute(IRubyObject val) throws Exception {
         valid = false;
         attrs.add(val);
         if(req != null) {
             ASN1EncodableVector v1 = new ASN1EncodableVector();
             for(Iterator iter = attrs.iterator();iter.hasNext();) {
                 v1.add(((Attribute)iter.next()).toASN1());
             }
             req.setAttributes(new DERSet(v1));
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new Request(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 }// Request
diff --git a/src/org/jruby/ext/openssl/SSL.java b/src/org/jruby/ext/openssl/SSL.java
index 1dd16ed108..76c7347e2a 100644
--- a/src/org/jruby/ext/openssl/SSL.java
+++ b/src/org/jruby/ext/openssl/SSL.java
@@ -1,64 +1,66 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.jruby.IRuby;
+import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class SSL {
     public static void createSSL(IRuby runtime, RubyModule ossl) {
         RubyModule mSSL = ossl.defineModuleUnder("SSL");
-        mSSL.defineClassUnder("SSLError",ossl.getClass("OpenSSLError"));
+        RubyClass openSSLError = ossl.getClass("OpenSSLError");
+        mSSL.defineClassUnder("SSLError",openSSLError,openSSLError.getAllocator());
 
         SSLContext.createSSLContext(runtime,mSSL);
         SSLSocket.createSSLSocket(runtime,mSSL);
 
         mSSL.setConstant("VERIFY_NONE",runtime.newFixnum(0));
         mSSL.setConstant("VERIFY_PEER",runtime.newFixnum(1));
         mSSL.setConstant("VERIFY_FAIL_IF_NO_PEER_CERT",runtime.newFixnum(2));
         mSSL.setConstant("VERIFY_CLIENT_ONCE",runtime.newFixnum(4));
 
         mSSL.setConstant("OP_ALL",runtime.newFixnum(4095));
         mSSL.setConstant("OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION",runtime.newFixnum(65536));
         mSSL.setConstant("OP_SINGLE_ECDH_USE",runtime.newFixnum(524288));
         mSSL.setConstant("OP_SINGLE_DH_USE",runtime.newFixnum(1048576));
         mSSL.setConstant("OP_EPHEMERAL_RSA",runtime.newFixnum(2097152));
         mSSL.setConstant("OP_CIPHER_SERVER_PREFERENCE",runtime.newFixnum(4194304));
         mSSL.setConstant("OP_TLS_ROLLBACK_BUG",runtime.newFixnum(8388608));
         mSSL.setConstant("OP_NO_SSLv2",runtime.newFixnum(16777216));
         mSSL.setConstant("OP_NO_SSLv3",runtime.newFixnum(33554432));
         mSSL.setConstant("OP_NO_TLSv1",runtime.newFixnum(67108864));
         mSSL.setConstant("OP_PKCS1_CHECK_1",runtime.newFixnum(134217728));
         mSSL.setConstant("OP_PKCS1_CHECK_2",runtime.newFixnum(268435456));
         mSSL.setConstant("OP_NETSCAPE_CA_DN_BUG",runtime.newFixnum(536870912));
         mSSL.setConstant("OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG",runtime.newFixnum(-1073741824));
     }    
 }// SSL
diff --git a/src/org/jruby/ext/openssl/SSLContext.java b/src/org/jruby/ext/openssl/SSLContext.java
index 59e004ca99..6f638d5522 100644
--- a/src/org/jruby/ext/openssl/SSLContext.java
+++ b/src/org/jruby/ext/openssl/SSLContext.java
@@ -1,303 +1,303 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import javax.net.ssl.SSLEngine;
 
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.ext.openssl.x509store.X509AuxCertificate;
 import org.jruby.ext.openssl.x509store.X509_STORE;
 import org.jruby.ext.openssl.x509store.X509_STORE_CTX;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class SSLContext extends RubyObject {
     private final static String[] ctx_attrs = {
     "cert", "key", "client_ca", "ca_file", "ca_path",
     "timeout", "verify_mode", "verify_depth",
     "verify_callback", "options", "cert_store", "extra_chain_cert",
     "client_cert_cb", "tmp_dh_callback", "session_id_context"};
 
+    private static ObjectAllocator SSLCONTEXT_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new SSLContext(runtime, klass);
+        }
+    };
+    
     public static void createSSLContext(IRuby runtime, RubyModule mSSL) {
-        RubyClass cSSLContext = mSSL.defineClassUnder("SSLContext",runtime.getObject());
+        RubyClass cSSLContext = mSSL.defineClassUnder("SSLContext",runtime.getObject(),SSLCONTEXT_ALLOCATOR);
         for(int i=0;i<ctx_attrs.length;i++) {
             cSSLContext.attr_accessor(new IRubyObject[]{runtime.newSymbol(ctx_attrs[i])});
         }
 
         CallbackFactory ctxcb = runtime.callbackFactory(SSLContext.class);
-        cSSLContext.defineSingletonMethod("new",ctxcb.getOptSingletonMethod("newInstance"));
         cSSLContext.defineMethod("initialize",ctxcb.getOptMethod("initialize"));
         cSSLContext.defineMethod("ciphers",ctxcb.getMethod("ciphers"));
         cSSLContext.defineMethod("ciphers=",ctxcb.getMethod("set_ciphers",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        SSLContext result = new SSLContext(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public SSLContext(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private IRubyObject ciphers;
     private PKey t_key = null;
     private X509Cert t_cert = null;
     
     private java.security.cert.X509Certificate peer_cert;
 
     public void setPeer(java.security.cert.X509Certificate p) {
         this.peer_cert = p;
     }
 
     public java.security.cert.X509Certificate getPeer() {
         return this.peer_cert;
     }
 
     private void initFromCallback(IRubyObject cb) {
         IRubyObject out = cb.callMethod(getRuntime().getCurrentContext(),"call",this);
         t_cert = (X509Cert)(((RubyArray)out).getList().get(0));
         t_key = (PKey)(((RubyArray)out).getList().get(1));
     }
 
     public PKey getCallbackKey() {
         IRubyObject cb = callMethod(getRuntime().getCurrentContext(),"client_cert_cb");
         if(t_key == null && !cb.isNil()) {
             initFromCallback(cb);
         }
         return t_key;
     }
 
     public X509Cert getCallbackCert() {
         IRubyObject cb = callMethod(getRuntime().getCurrentContext(),"client_cert_cb");
         if(t_cert == null && !cb.isNil()) {
             initFromCallback(cb);
         }
         return t_cert;
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         ciphers = getRuntime().getNil();
         return this;
     }
 
     public IRubyObject ciphers() {
         return this.ciphers;
     }
 
     public IRubyObject set_ciphers(IRubyObject val) {
         this.ciphers = val;
         return val;
     }
 
     String[] getCipherSuites(SSLEngine engine) {
         List ciphs = new ArrayList();
         if(this.ciphers.isNil()) {
             return engine.getSupportedCipherSuites();
         } else if(this.ciphers instanceof RubyArray) {
             for(Iterator iter = ((RubyArray)this.ciphers).getList().iterator();iter.hasNext();) {
                 addCipher(ciphs, iter.next().toString(),engine);
             }
         } else {
             addCipher(ciphs,this.ciphers.toString(),engine);
         }
         return (String[])ciphs.toArray(new String[ciphs.size()]);
     }
 
     private void addCipher(List lst, String cipher, SSLEngine engine) {
         String[] supported = engine.getSupportedCipherSuites();
         if("ADH".equals(cipher)) {
             for(int i=0;i<supported.length;i++) {
                 if(supported[i].indexOf("DH_anon") != -1) {
                     lst.add(supported[i]);
                 }
             }
         } else {
             for(int i=0;i<supported.length;i++) {
                 if(supported[i].indexOf(cipher) != -1) {
                     lst.add(supported[i]);
                 }
             }
         }
     }
 
     public KM getKM() {
         return new KM(this);
     }
 
     public TM getTM() {
         return new TM(this);
     }
 
     private static class KM extends javax.net.ssl.X509ExtendedKeyManager {
         private SSLContext ctt;
         public KM(SSLContext ctt) {
             super();
             this.ctt = ctt;
         }
 
         public String 	chooseEngineClientAlias(String[] keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
             PKey k = null;
             if(!ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key").isNil()) {
                 k = (PKey)ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key");
             } else {
                 k = ctt.getCallbackKey();
             }
             if(k == null) {
                 return null;
             }
             for(int i=0;i<keyType.length;i++) {
                 if(keyType[i].equalsIgnoreCase(k.getAlgorithm())) {
                     return keyType[i];
                 }
             }
             return null;
         }
         public String 	chooseEngineServerAlias(String keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
             PKey k = null;
             if(!ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key").isNil()) {
                 k = (PKey)ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key");
             } else {
                 k = ctt.getCallbackKey();
             }
             if(k == null) {
                 return null;
             }
             if(keyType.equalsIgnoreCase(k.getAlgorithm())) {
                 return keyType;
             }
             return null;
         }
         public String 	chooseClientAlias(String[] keyType, java.security.Principal[] issuers, java.net.Socket socket) {
             return null;
         }
         public String 	chooseServerAlias(String keyType, java.security.Principal[] issuers, java.net.Socket socket) {
             return null;
         }
         public java.security.cert.X509Certificate[] 	getCertificateChain(String alias) {
             X509Cert c = null;
             if(!ctt.callMethod(ctt.getRuntime().getCurrentContext(),"cert").isNil()) {
                 c = (X509Cert)ctt.callMethod(ctt.getRuntime().getCurrentContext(),"cert");
             } else {
                 c = ctt.getCallbackCert();
             }
             if(c == null) {
                 return null;
             }
             return new java.security.cert.X509Certificate[]{c.getAuxCert()};
         }
         public String[] 	getClientAliases(String keyType, java.security.Principal[] issuers) {
             return null;
         }
         public java.security.PrivateKey 	getPrivateKey(String alias) {
             PKey k = null;
             if(!ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key").isNil()) {
                 k = (PKey)ctt.callMethod(ctt.getRuntime().getCurrentContext(),"key");
             } else {
                 k = ctt.getCallbackKey();
             }
             if(k == null) {
                 return null;
             }
             return k.getPrivateKey();
         }
         public String[] 	getServerAliases(String keyType, java.security.Principal[] issuers) {
             return null;
         }
     }
 
     private static class TM implements javax.net.ssl.X509TrustManager {
         private SSLContext ctt;
         public TM(SSLContext ctt) {
             this.ctt = ctt;
         }
 
         public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {
             if(chain != null && chain.length > 0) {
                 ctt.setPeer(chain[0]);
             }
         }
 
         public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
             if(ctt.callMethod(ctt.getRuntime().getCurrentContext(),"verify_mode").isNil()) {
                 if(chain != null && chain.length > 0) {
                     ctt.setPeer(chain[0]);
                 }
                 return;
             }
 
             int verify_mode = RubyNumeric.fix2int(ctt.callMethod(ctt.getRuntime().getCurrentContext(),"verify_mode"));
             if(chain != null && chain.length > 0) {
                 ctt.setPeer(chain[0]);
                 if((verify_mode & 0x1) != 0) { // verify_peer
                     X509AuxCertificate x = X509_STORE_CTX.transform(chain[0]);
                     X509_STORE_CTX ctx = new X509_STORE_CTX();
                     IRubyObject str = ctt.callMethod(ctt.getRuntime().getCurrentContext(),"cert_store");
                     X509_STORE store = null;
                     if(!str.isNil()) {
                         store = ((X509Store)str).getStore();
                     }
                     if(ctx.init(store,x,X509_STORE_CTX.transform(chain)) == 0) {
                         throw new CertificateException("couldn't initialize store");
                     }
 
                     ctx.set_default("ssl_client");
                     try {
                         if(ctx.verify_cert() == 0) {
                             throw new CertificateException("certificate verify failed");
                         }
                     } catch(Exception e) {
                         throw new CertificateException("certificate verify failed");
                     }
                 }
             } else {
                 if((verify_mode & 0x2) != 0) { // fail if no peer cer
                     throw new CertificateException("no peer certificate");
                 }
             }
         }
 
         public java.security.cert.X509Certificate[] getAcceptedIssuers() {
             return new java.security.cert.X509Certificate[0];
         }
     }
 }// SSLContext
diff --git a/src/org/jruby/ext/openssl/SSLSocket.java b/src/org/jruby/ext/openssl/SSLSocket.java
index a6c4926433..37466a1eca 100644
--- a/src/org/jruby/ext/openssl/SSLSocket.java
+++ b/src/org/jruby/ext/openssl/SSLSocket.java
@@ -1,483 +1,483 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
 import java.util.Iterator;
 
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLEngineResult;
 import javax.net.ssl.SSLSession;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyIO;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallType;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class SSLSocket extends RubyObject {
+    private static ObjectAllocator SSLSOCKET_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new SSLSocket(runtime, klass);
+        }
+    };
+    
     public static void createSSLSocket(IRuby runtime, RubyModule mSSL) {
-        RubyClass cSSLSocket = mSSL.defineClassUnder("SSLSocket",runtime.getObject());
+        RubyClass cSSLSocket = mSSL.defineClassUnder("SSLSocket",runtime.getObject(),SSLSOCKET_ALLOCATOR);
 
         cSSLSocket.attr_accessor(new IRubyObject[]{runtime.newSymbol("io")});
         cSSLSocket.attr_accessor(new IRubyObject[]{runtime.newSymbol("context")});
         cSSLSocket.attr_accessor(new IRubyObject[]{runtime.newSymbol("sync_close")});
 
         CallbackFactory sockcb = runtime.callbackFactory(SSLSocket.class);
-        cSSLSocket.defineSingletonMethod("new",sockcb.getOptSingletonMethod("newInstance"));
         cSSLSocket.defineAlias("to_io","io");
         cSSLSocket.defineMethod("initialize",sockcb.getOptMethod("_initialize"));
         cSSLSocket.defineMethod("connect",sockcb.getMethod("connect"));
         cSSLSocket.defineMethod("accept",sockcb.getMethod("accept"));
         cSSLSocket.defineMethod("sysread",sockcb.getOptMethod("sysread"));
         cSSLSocket.defineMethod("syswrite",sockcb.getMethod("syswrite",IRubyObject.class));
         cSSLSocket.defineMethod("sysclose",sockcb.getMethod("sysclose"));
         cSSLSocket.defineMethod("cert",sockcb.getMethod("cert"));
         cSSLSocket.defineMethod("peer_cert",sockcb.getMethod("peer_cert"));
         cSSLSocket.defineMethod("peer_cert_chain",sockcb.getMethod("peer_cert_chain"));
         cSSLSocket.defineMethod("cipher",sockcb.getMethod("cipher"));
         cSSLSocket.defineMethod("state",sockcb.getMethod("state"));
         cSSLSocket.defineMethod("pending",sockcb.getMethod("pending"));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        SSLSocket result = new SSLSocket(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private RubyClass sslError;
 
     public SSLSocket(IRuby runtime, RubyClass type) {
         super(runtime,type);
         sslError = ((RubyClass)((RubyModule)runtime.getModule("OpenSSL").getConstant("SSL")).getConstant("SSLError"));
     }
 
     private SSLEngine engine;
     private SocketChannel c = null;
 
     private ByteBuffer peerAppData;
     private ByteBuffer peerNetData;
     private ByteBuffer netData;
     private ByteBuffer dummy;
     
     private boolean initialHandshake = false;
 	
     private SSLEngineResult.HandshakeStatus hsStatus;
     private SSLEngineResult.Status status = null;
 
     private String type = null;
 
     private Selector rsel;
     private Selector wsel;
     private Selector asel;
     
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         IRubyObject io, ctx;
         ThreadContext tc = getRuntime().getCurrentContext();
         if(checkArgumentCount(args,1,2) == 1) {
             ctx = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("SSL"))).getClass("SSLContext").callMethod(tc,"new");
         } else {
             ctx = args[1];
         }
         io = args[0];
         callMethod(tc,"io=",io);
         c = (SocketChannel)(((RubyIO)io).getChannel());
         callMethod(tc,"context=",ctx);
         callMethod(tc,"sync_close=",getRuntime().getFalse());
         return callMethod(tc,getMetaClass().getSuperClass(),"initialize",args,CallType.SUPER);
     }
 
     private void ossl_ssl_setup() throws Exception {
         if(null == engine) {
             ThreadContext tc = getRuntime().getCurrentContext();
             SSLContext ctx = SSLContext.getInstance("SSL");
             IRubyObject store = callMethod(tc,"context").callMethod(tc,"cert_store");
             callMethod(tc,"context").callMethod(tc,"verify_mode");
 
             if(store.isNil()) {
                 ctx.init(new javax.net.ssl.KeyManager[]{((org.jruby.ext.openssl.SSLContext)callMethod(tc,"context")).getKM()},new javax.net.ssl.TrustManager[]{((org.jruby.ext.openssl.SSLContext)callMethod(tc,"context")).getTM()},null);
             } else {
                 ctx.init(new javax.net.ssl.KeyManager[]{((org.jruby.ext.openssl.SSLContext)callMethod(tc,"context")).getKM()},new javax.net.ssl.TrustManager[]{((X509Store)store).getStore()},null);
             }
 
             String peerHost = ((SocketChannel)c).socket().getInetAddress().getHostName();
             int peerPort = ((SocketChannel)c).socket().getPort();
             engine = ctx.createSSLEngine(peerHost,peerPort);
             engine.setEnabledCipherSuites(((org.jruby.ext.openssl.SSLContext)callMethod(tc,"context")).getCipherSuites(engine));
             SSLSession session = engine.getSession();
             peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());
             peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());		
             netData = ByteBuffer.allocate(session.getPacketBufferSize());
             peerNetData.limit(0);
             peerAppData.limit(0);
             netData.limit(0);
             dummy = ByteBuffer.allocate(0);
             rsel = Selector.open();
             wsel = Selector.open();
             asel = Selector.open();
             c.register(rsel,SelectionKey.OP_READ);
             c.register(wsel,SelectionKey.OP_WRITE);
             c.register(asel,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
         }
     }
 
     public IRubyObject connect() throws Exception {
         try {
             ossl_ssl_setup();
             engine.setUseClientMode(true);
             engine.beginHandshake();
             type = "client";
             hsStatus = engine.getHandshakeStatus();
             initialHandshake = true;
             doHandshake();
         } catch(javax.net.ssl.SSLHandshakeException e) {
             Throwable v = e;
             while(v.getCause() != null && (v instanceof javax.net.ssl.SSLHandshakeException)) {
                 v = v.getCause();
             }
             if(v instanceof java.security.cert.CertificateException) {
                 throw new RaiseException(getRuntime(),sslError,v.getMessage(),true);
             } else {
                 throw new RaiseException(getRuntime(),sslError,null,true);
             }
         }
         return this;
     }
 
     public IRubyObject accept() throws Exception {
         try {
             ThreadContext tc = getRuntime().getCurrentContext();
             int vfy = 0;
             ossl_ssl_setup();
             engine.setUseClientMode(false);
             IRubyObject ccc = callMethod(tc,"context");
             if(!ccc.isNil() && !ccc.callMethod(tc,"verify_mode").isNil()) {
                 vfy = RubyNumeric.fix2int(ccc.callMethod(tc,"verify_mode"));
                 if(vfy == 0) { //VERIFY_NONE
                     engine.setNeedClientAuth(false);
                     engine.setWantClientAuth(false);
                 }
                 if((vfy & 1) != 0) { //VERIFY_PEER
                     engine.setWantClientAuth(true);
                 }
                 if((vfy & 2) != 0) { //VERIFY_FAIL_IF_NO_PEER_CERT
                     engine.setNeedClientAuth(true);
                 }
             }
             engine.beginHandshake();
             type = "server";
             hsStatus = engine.getHandshakeStatus();
             initialHandshake = true;
             doHandshake();
         } catch(javax.net.ssl.SSLHandshakeException e) {
             throw new RaiseException(getRuntime(),sslError,null,true);
         }
 
         return this;
     }
 
     private void waitSelect(Selector sel) {
         try {
             sel.select();
         } catch(Exception e) {
             return;
         }
         Iterator it = sel.selectedKeys().iterator();
         while(it.hasNext()) {
             it.next();
             it.remove();
         }
     }
 
     private void doHandshake() throws Exception {
         while (true) {
             SSLEngineResult res;
             waitSelect(asel);
             if(hsStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                 if (initialHandshake) {
                     finishInitialHandshake();
                 }
                 return;
             } else if(hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                 doTasks();
             } else if(hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                 if(readAndUnwrap() == -1 && hsStatus != SSLEngineResult.HandshakeStatus.FINISHED) {
                     throw new javax.net.ssl.SSLHandshakeException("Socket closed");
                 }
             } else if(hsStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                 if (netData.hasRemaining()) {
                     while(flushData());
                 }
                 netData.clear();
                 res = engine.wrap(dummy, netData);
                 hsStatus = res.getHandshakeStatus();
                 netData.flip();
                 flushData();
             } else {
                 assert false : "doHandshake() should never reach the NOT_HANDSHAKING state";
                 return;
             }
         }
     }
 
     private void doTasks() {
         Runnable task;
         while ((task = engine.getDelegatedTask()) != null) {
             task.run();
         }
         hsStatus = engine.getHandshakeStatus();
     }
 
     private boolean flushData() throws IOException {		
         try {
             c.write(netData);
         } catch (IOException ioe) {
             netData.position(netData.limit());
             throw ioe;
         }
         if (netData.hasRemaining()) {
             return false;
         }  else {
             return true;
         }
     }
 
     private void finishInitialHandshake() {
         initialHandshake = false;
     }
 
     public int write(ByteBuffer src) throws Exception {
         if(initialHandshake) {
             return 0;
         }
         if(netData.hasRemaining()) {
             return 0;
         }
         netData.clear();
         SSLEngineResult res = engine.wrap(src, netData);
         netData.flip();
         flushData();
         return res.bytesConsumed();
     }
 
     public int read(ByteBuffer dst) throws Exception {
         if(initialHandshake) {
             return 0;
         }
         if (engine.isInboundDone()) {
             return -1;
         }
         if (!peerAppData.hasRemaining()) {
             int appBytesProduced = readAndUnwrap(); 
             if (appBytesProduced == -1 || appBytesProduced == 0) {
                 return appBytesProduced;
             } 
         }
         int limit = Math.min(peerAppData.remaining(), dst.remaining());
         for (int i = 0; i < limit; i++) {
             dst.put(peerAppData.get());
         }
         return limit;
     }
 
     private int readAndUnwrap() throws Exception {
         int bytesRead = c.read(peerNetData);
         if(bytesRead == -1) {
             //            engine.closeInbound();			
             return -1;
         }
         peerAppData.clear();
         peerNetData.flip();
         SSLEngineResult res;
         do {
             res = engine.unwrap(peerNetData, peerAppData);
         } while (res.getStatus() == SSLEngineResult.Status.OK &&
 				res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&
 				res.bytesProduced() == 0);
         if(res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
             finishInitialHandshake();
         }
         if(peerAppData.position() == 0 && 
             res.getStatus() == SSLEngineResult.Status.OK &&
             peerNetData.hasRemaining()) {
             res = engine.unwrap(peerNetData, peerAppData);
         }
         status = res.getStatus();
         hsStatus = res.getHandshakeStatus();
         
         if(status == SSLEngineResult.Status.CLOSED) {
             doShutdown();
             return -1;
         }	
         peerNetData.compact();
         peerAppData.flip();
         if(!initialHandshake && (hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK ||
                                  hsStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP ||
                                  hsStatus == SSLEngineResult.HandshakeStatus.FINISHED)) {
             doHandshake();
         }
         return peerAppData.remaining();
     }
 
     private void doShutdown() throws IOException {
         if (engine.isOutboundDone()) {
             return;
         }
         netData.clear();
         try {
             engine.wrap(dummy, netData);
         } catch(Exception e1) {
             return;
         }
         netData.flip();
         flushData();
     }
 
     public IRubyObject sysread(IRubyObject[] args) throws Exception {
         //        System.err.println("WARNING: unimplemented method called: SSLSocket#sysread");
         checkArgumentCount(args,1,2);
         int len = RubyNumeric.fix2int(args[0]);
         IRubyObject str = args.length == 2 ? args[1] : getRuntime().newString("");
         if(len == 0) {
             return str;
         }
         waitSelect(rsel);
         ByteBuffer dst = ByteBuffer.allocate(len);
         String bef_dst = dst.toString();
         int rr = -1;
         if(engine == null) {
             rr = c.read(dst);
         } else {
             rr = read(dst);
         }
         String aft_dst = dst.toString();
         String out = null;
         boolean eof = false;
         if(rr == -1) {
             eof = true;
         } else {
             byte[] bss = new byte[rr];
             dst.position(dst.position()-rr);
             dst.get(bss);
             out = new String(bss,"ISO8859_1");
         }
         String aft_ag_dst = dst.toString();
         if(eof){
             throw getRuntime().newEOFError();
         }
         str.callMethod(getRuntime().getCurrentContext(),"<<",getRuntime().newString(out));
         return str;
     }
 
     public IRubyObject syswrite(IRubyObject arg) throws Exception {
         ///        System.err.println("WARNING: unimplemented method called: SSLSocket#syswrite");
         //        System.err.println(type + ".syswrite(" + arg + ")");
         if(engine == null) {
             waitSelect(wsel);
             byte[] bls = arg.toString().getBytes("PLAIN");
             ByteBuffer b1 = ByteBuffer.wrap(bls);
             c.write(b1);
             return getRuntime().newFixnum(bls.length);
         } else {
             waitSelect(wsel);
             byte[] bls = arg.toString().getBytes("PLAIN");
             ByteBuffer b1 = ByteBuffer.wrap(bls);
             write(b1);
             return getRuntime().newFixnum(bls.length);
         }
     }
 
     private void close() throws Exception {
         engine.closeOutbound();
         if (netData.hasRemaining()) {
             return;
         } else {
             doShutdown();
         }
     }
 
     public IRubyObject sysclose() throws Exception {
         //        System.err.println("WARNING: unimplemented method called: SSLSocket#sysclose");
         //        System.err.println(type + ".sysclose");
         close();
         ThreadContext tc = getRuntime().getCurrentContext();
         if(callMethod(tc,"sync_close").isTrue()) {
             c.close();
             callMethod(tc,"io").callMethod(tc,"close");
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject cert() {
         System.err.println("WARNING: unimplemented method called: SSLSocket#cert");
         return getRuntime().getNil();
     }
 
     public IRubyObject peer_cert() throws Exception {
         java.security.cert.Certificate[] c = engine.getSession().getPeerCertificates();
         if(c.length > 0) {
             return X509Cert.wrap(getRuntime(),c[0]);
         }
         return getRuntime().getNil();
     }
 
     public IRubyObject peer_cert_chain() {
         System.err.println("WARNING: unimplemented method called: SSLSocket#peer_cert_chain");
         return getRuntime().getNil();
     }
 
     public IRubyObject cipher() {
         System.err.println("WARNING: unimplemented method called: SSLSocket#cipher");
         return getRuntime().getNil();
     }
 
     public IRubyObject state() {
         System.err.println("WARNING: unimplemented method called: SSLSocket#state");
         return getRuntime().getNil();
     }
 
     public IRubyObject pending() {
         System.err.println("WARNING: unimplemented method called: SSLSocket#pending");
         return getRuntime().getNil();
     }
 }// SSLSocket
diff --git a/src/org/jruby/ext/openssl/X509CRL.java b/src/org/jruby/ext/openssl/X509CRL.java
index e64f3cbd80..56448a071c 100644
--- a/src/org/jruby/ext/openssl/X509CRL.java
+++ b/src/org/jruby/ext/openssl/X509CRL.java
@@ -1,422 +1,423 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.ByteArrayInputStream;
 import java.io.StringWriter;
 import java.math.BigInteger;
 import java.security.cert.CertificateFactory;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.DERBoolean;
 import org.bouncycastle.asn1.DEREncodable;
 import org.bouncycastle.asn1.DERInteger;
 import org.bouncycastle.asn1.DERObject;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERTaggedObject;
 import org.bouncycastle.x509.X509V2CRLGenerator;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.RubyTime;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.PEM;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509CRL extends RubyObject {
+    private static ObjectAllocator X509CRL_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509CRL(runtime, klass);
+        }
+    };
+    
     public static void createX509CRL(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509CRL = mX509.defineClassUnder("CRL",runtime.getObject());
-        mX509.defineClassUnder("CRLError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509CRL = mX509.defineClassUnder("CRL",runtime.getObject(),X509CRL_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("CRLError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory crlcb = runtime.callbackFactory(X509CRL.class);
 
-        cX509CRL.defineSingletonMethod("new",crlcb.getOptSingletonMethod("newInstance"));
         cX509CRL.defineMethod("initialize",crlcb.getOptMethod("_initialize"));
         cX509CRL.defineMethod("initialize_copy",crlcb.getMethod("initialize_copy",IRubyObject.class));
         cX509CRL.defineMethod("clone",crlcb.getMethod("rbClone"));
 
         cX509CRL.defineMethod("version",crlcb.getMethod("version"));
         cX509CRL.defineMethod("version=",crlcb.getMethod("set_version",IRubyObject.class));
         cX509CRL.defineMethod("signature_algorithm",crlcb.getMethod("signature_algorithm"));
         cX509CRL.defineMethod("issuer",crlcb.getMethod("issuer"));
         cX509CRL.defineMethod("issuer=",crlcb.getMethod("set_issuer",IRubyObject.class));
         cX509CRL.defineMethod("last_update",crlcb.getMethod("last_update"));
         cX509CRL.defineMethod("last_update=",crlcb.getMethod("set_last_update",IRubyObject.class));
         cX509CRL.defineMethod("next_update",crlcb.getMethod("next_update"));
         cX509CRL.defineMethod("next_update=",crlcb.getMethod("set_next_update",IRubyObject.class));
         cX509CRL.defineMethod("revoked",crlcb.getMethod("revoked"));
         cX509CRL.defineMethod("revoked=",crlcb.getMethod("set_revoked",IRubyObject.class));
         cX509CRL.defineMethod("add_revoked",crlcb.getMethod("add_revoked",IRubyObject.class));
 
         cX509CRL.defineMethod("sign",crlcb.getMethod("sign",IRubyObject.class,IRubyObject.class));
         cX509CRL.defineMethod("verify",crlcb.getMethod("verify",IRubyObject.class));
 
         cX509CRL.defineMethod("to_der",crlcb.getMethod("to_der"));
         cX509CRL.defineMethod("to_pem",crlcb.getMethod("to_pem"));
         cX509CRL.defineMethod("to_s",crlcb.getMethod("to_pem")); 
         cX509CRL.defineMethod("to_text",crlcb.getMethod("to_text"));
         cX509CRL.defineMethod("extensions",crlcb.getMethod("extensions"));
         cX509CRL.defineMethod("extensions=",crlcb.getMethod("set_extensions",IRubyObject.class));
         cX509CRL.defineMethod("add_extension",crlcb.getMethod("add_extension",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        IRubyObject result = new X509CRL(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private IRubyObject version;
     private IRubyObject issuer;
     private IRubyObject last_update;
     private IRubyObject next_update;
     private IRubyObject revoked;
     private List extensions;
 
     private IRubyObject sig_alg;
 
     private boolean changed = true;
 
     private X509V2CRLGenerator generator = new X509V2CRLGenerator();
     private java.security.cert.X509CRL crl;
 
     private DERObject crl_v;
 
     java.security.cert.X509CRL getCRL() {
         return crl;
     }
 
     public X509CRL(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         //        System.err.println("WARNING: unimplemented method called: CRL#initialize");
         extensions = new ArrayList();
         if(checkArgumentCount(args,0,1) == 0) {
             version = getRuntime().getNil();
             issuer = getRuntime().getNil();
             last_update = getRuntime().getNil();
             next_update = getRuntime().getNil();
             revoked = getRuntime().newArray();
             return this;
         }
         
         ByteArrayInputStream bis = new ByteArrayInputStream(args[0].toString().getBytes("PLAIN"));
         CertificateFactory cf = CertificateFactory.getInstance("X.509","BC");
         crl = (java.security.cert.X509CRL)cf.generateCRL(bis);
         crl_v = new ASN1InputStream(new ByteArrayInputStream(args[0].toString().getBytes("PLAIN"))).readObject();
         DEREncodable v0 = ((DERSequence)(((DERSequence)crl_v).getObjectAt(0))).getObjectAt(0);
         if(v0 instanceof DERInteger) {
             set_version(getRuntime().newFixnum(((DERInteger)v0).getValue().intValue()));
         } else {
             set_version(getRuntime().newFixnum(2));
         }
         set_last_update(RubyTime.newTime(getRuntime(),crl.getThisUpdate().getTime()));
         set_next_update(RubyTime.newTime(getRuntime(),crl.getNextUpdate().getTime()));
         ThreadContext tc = getRuntime().getCurrentContext();
         set_issuer(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Name").callMethod(tc,"new",getRuntime().newString(new String(crl.getIssuerX500Principal().getEncoded(),"PLAIN"))));
 
         revoked = getRuntime().newArray();
 
         DERSequence seqa = (DERSequence)((DERSequence)crl_v).getObjectAt(0);
         DERObject maybe_ext = (DERObject)seqa.getObjectAt(seqa.size()-1);
         if(maybe_ext instanceof DERTaggedObject && ((DERTaggedObject)maybe_ext).getTagNo() == 0) {
             DERSequence exts = (DERSequence)((DERTaggedObject)maybe_ext).getObject();
             for(int i=0;i<exts.size();i++) {
                 DERSequence seq2 = (DERSequence)exts.getObjectAt(i);
                 boolean critical = false;
                 String oid = ((DERObjectIdentifier)seq2.getObjectAt(0)).getId();
                 if(seq2.getObjectAt(1) == DERBoolean.TRUE) {
                     critical = true;
                 }
                 byte[] value = crl.getExtensionValue(oid);
                 IRubyObject mASN1 = ((RubyModule)(getRuntime().getModule("OpenSSL"))).getConstant("ASN1");
                 IRubyObject rValue = null;
                 try {
                     rValue = ASN1.decode(mASN1,ASN1.decode(mASN1,getRuntime().newString(new String(value,"PLAIN"))).callMethod(tc,"value"));
                 } catch(Exception e) {
                     rValue = getRuntime().newString(new String(value,"PLAIN"));
                 }
                 X509Extensions.Extension ext1 = (X509Extensions.Extension)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Extension").callMethod(tc,"new"));
                 ext1.setRealOid(ext1.getObjectIdentifier(oid));
                 ext1.setRealValue(rValue);
                 ext1.setRealCritical(critical);
                 add_extension(ext1);
             }
         }
 
         changed = false;
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         System.err.println("WARNING: unimplemented method called: CRL#init_copy");
         if(this == obj) {
             return this;
         }
         checkFrozen();
         return this;
     }
 
     public IRubyObject to_pem() throws Exception {
         StringWriter w = new StringWriter();
         PEM.write_X509_CRL(w,crl);
         w.close();
         return getRuntime().newString(w.toString());
     }
 
     public IRubyObject to_der() throws Exception {
         return getRuntime().newString(new String(crl_v.getEncoded(),"ISO8859_1"));
     }
 
     private static final String IND8 = "        ";
     private static final String IND12 = "            ";
     private static final String IND16 = "                ";
     private static final DateFormat ASN_DATE = new SimpleDateFormat("MMM dd HH:mm:ss yyyy zzz");
     public IRubyObject to_text() throws Exception {
         StringBuffer sbe = new StringBuffer();
         sbe.append("Certificate Revocation List (CRL):\n");
         sbe.append(IND8).append("Version ").append(RubyNumeric.fix2int(version)+1).append(" (0x");
         sbe.append(Integer.toString(RubyNumeric.fix2int(version),16)).append(")\n");
         sbe.append(IND8).append("Signature Algorithm: ").append(ASN1.nid2ln(getRuntime(),ASN1.obj2nid(getRuntime(),((DERObjectIdentifier)((DERSequence)((DERSequence)crl_v).getObjectAt(1)).getObjectAt(0))))).append("\n");
         sbe.append(IND8).append("Issuer: ").append(issuer()).append("\n");
         sbe.append(IND8).append("Last Update: ").append(ASN_DATE.format(((RubyTime)last_update()).getJavaDate())).append("\n");
         if(!next_update().isNil()) {
             sbe.append(IND8).append("Next Update: ").append(ASN_DATE.format(((RubyTime)next_update()).getJavaDate())).append("\n");
         } else {
             sbe.append(IND8).append("Next Update: NONE\n");
         }
         if(extensions.size()>0) {
             sbe.append(IND8).append("CRL extensions\n");
             for(Iterator iter = extensions.iterator();iter.hasNext();) {
                 X509Extensions.Extension ext = (X509Extensions.Extension)iter.next();
                 DERObjectIdentifier oiden = ext.getRealOid();
                 sbe.append(IND12).append(ASN1.o2a(getRuntime(),oiden)).append(": ");
                 if(ext.getRealCritical()) {
                     sbe.append("critical");
                 }
                 sbe.append("\n");
                 sbe.append(IND16).append(ext.value()).append("\n");
             }
         }
         /*
     114         rev = X509_CRL_get_REVOKED(x);
     115
     116         if(sk_X509_REVOKED_num(rev) > 0)
     117             BIO_printf(out, "Revoked Certificates:\n");
     118         else BIO_printf(out, "No Revoked Certificates.\n");
     119
     120         for(i = 0; i < sk_X509_REVOKED_num(rev); i++) {
     121                 r = sk_X509_REVOKED_value(rev, i);
     122                 BIO_printf(out,"    Serial Number: ");
     123                 i2a_ASN1_INTEGER(out,r->serialNumber);
     124                 BIO_printf(out,"\n        Revocation Date: ");
     125                 ASN1_TIME_print(out,r->revocationDate);
     126                 BIO_printf(out,"\n");
     127                 X509V3_extensions_print(out, "CRL entry extensions",
     128                                                 r->extensions, 0, 8);
     129         }
     130         X509_signature_print(out, x->sig_alg, x->signature);
     131
         */
         return getRuntime().newString(sbe.toString());
     }
 
     public IRubyObject version() {
         return this.version;
     }
 
     public IRubyObject set_version(IRubyObject val) {
         if(!val.equals(this.version)) {
             changed = true;
         }
         this.version = val;
         return val;
     }
 
     public IRubyObject signature_algorithm() {
         return sig_alg;
     }
 
     public IRubyObject issuer() {
         return this.issuer;
     }
 
     public IRubyObject set_issuer(IRubyObject val) {
         if(!val.equals(this.issuer)) {
             changed = true;
         }
         this.issuer = val;
         generator.setIssuerDN(((X509Name)issuer).getRealName());
         return val;
     }
 
     public IRubyObject last_update() {
         return this.last_update;
     }
 
     public IRubyObject set_last_update(IRubyObject val) {
         changed = true;
         last_update = val.callMethod(getRuntime().getCurrentContext(),"getutc");
         ((RubyTime)last_update).setMicroseconds(0);
         generator.setThisUpdate(((RubyTime)last_update).getJavaDate());
         this.last_update = val;
         return val;
     }
 
     public IRubyObject next_update() {
         return this.next_update;
     }
 
     public IRubyObject set_next_update(IRubyObject val) {
         changed = true;
         next_update = val.callMethod(getRuntime().getCurrentContext(),"getutc");
         ((RubyTime)next_update).setMicroseconds(0);
         generator.setNextUpdate(((RubyTime)next_update).getJavaDate());
         this.next_update = val;
         return val;
     }
 
     public IRubyObject revoked() {
         return this.revoked;
     }
 
     public IRubyObject set_revoked(IRubyObject val) {
         changed = true;
         this.revoked = val;
         return val;
     }
 
     public IRubyObject add_revoked(IRubyObject val) {
         changed = true;
         this.revoked.callMethod(getRuntime().getCurrentContext(),"<<",val);
         return val;
     }
 
     public IRubyObject extensions() {
         return getRuntime().newArray(this.extensions);
     }
 
     public IRubyObject set_extensions(IRubyObject val) {
         this.extensions = ((RubyArray)val).getList();
         return val;
     }
 
     public IRubyObject add_extension(IRubyObject val) {
         this.extensions.add(val);
         return val;
     }
 
     public IRubyObject sign(IRubyObject key, IRubyObject digest) throws Exception {
         //System.err.println("WARNING: unimplemented method called: CRL#sign");
         // Have to obey some artificial constraints of the OpenSSL implementation. Stupid.
         String keyAlg = ((PKey)key).getAlgorithm();
         String digAlg = ((Digest)digest).getAlgorithm();
         
         if(("DSA".equalsIgnoreCase(keyAlg) && "MD5".equalsIgnoreCase(digAlg)) || 
            ("RSA".equalsIgnoreCase(keyAlg) && "DSS1".equals(((Digest)digest).name().toString())) ||
            ("DSA".equalsIgnoreCase(keyAlg) && "SHA1".equals(((Digest)digest).name().toString()))) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("CRLError")), null, true);
         }
 
         sig_alg = getRuntime().newString(digAlg);
         generator.setSignatureAlgorithm(digAlg + "WITH" + keyAlg);
 
         for(Iterator iter = ((RubyArray)revoked).getList().iterator();iter.hasNext();) {
             X509Revoked rev = (X509Revoked)iter.next();
             BigInteger serial = new BigInteger(rev.callMethod(getRuntime().getCurrentContext(),"serial").toString());
             IRubyObject t1 = rev.callMethod(getRuntime().getCurrentContext(),"time").callMethod(getRuntime().getCurrentContext(),"getutc");
             ((RubyTime)t1).setMicroseconds(0);
             // Extensions ignored, for now
             generator.addCRLEntry(serial,((RubyTime)t1).getJavaDate(),new org.bouncycastle.asn1.x509.X509Extensions(new Hashtable()));
         }
 
         for(Iterator iter = extensions.iterator();iter.hasNext();) {
             Object arg = iter.next();
             generator.addExtension(((X509Extensions.Extension)arg).getRealOid(),((X509Extensions.Extension)arg).getRealCritical(),((X509Extensions.Extension)arg).getRealValueBytes());
         }
 
         crl = generator.generateX509CRL(((PKey)key).getPrivateKey());
         crl_v = new ASN1InputStream(new ByteArrayInputStream(crl.getEncoded())).readObject();
         DERSequence v1 = (DERSequence)(((DERSequence)crl_v).getObjectAt(0));
         ASN1EncodableVector build1 = new ASN1EncodableVector();
         int copyIndex = 0;
         if(v1.getObjectAt(0) instanceof DERInteger) {
             copyIndex++;
         }
         build1.add(new DERInteger(new java.math.BigInteger(version.toString())));
         while(copyIndex < v1.size()) {
             build1.add(v1.getObjectAt(copyIndex++));
         }
         ASN1EncodableVector build2 = new ASN1EncodableVector();
         build2.add(new DERSequence(build1));
         build2.add(((DERSequence)crl_v).getObjectAt(1));
         build2.add(((DERSequence)crl_v).getObjectAt(2));
         crl_v = new DERSequence(build2);
         changed = false;
         return this;
     }
 
     public IRubyObject verify(IRubyObject key) {
         if(changed) {
             return getRuntime().getFalse();
         }
         try {
             crl.verify(((PKey)key).getPublicKey());
             return getRuntime().getTrue();
         } catch(Exception e) {
             return getRuntime().getFalse();
         }
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new X509CRL(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 }// X509CRL
diff --git a/src/org/jruby/ext/openssl/X509Cert.java b/src/org/jruby/ext/openssl/X509Cert.java
index d6c0e76bd5..56beb5fd0b 100644
--- a/src/org/jruby/ext/openssl/X509Cert.java
+++ b/src/org/jruby/ext/openssl/X509Cert.java
@@ -1,408 +1,409 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.io.ByteArrayInputStream;
 import java.io.StringWriter;
 import java.math.BigInteger;
 import java.security.InvalidKeyException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.x509.GeneralName;
 import org.bouncycastle.asn1.x509.GeneralNames;
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.RubyTime;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.PEM;
 import org.jruby.ext.openssl.x509store.X509AuxCertificate;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509Cert extends RubyObject {
+    private static ObjectAllocator X509CERT_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509Cert(runtime, klass);
+        }
+    };
+    
     public static void createX509Cert(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509Cert = mX509.defineClassUnder("Certificate",runtime.getObject());
-        mX509.defineClassUnder("CertificateError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509Cert = mX509.defineClassUnder("Certificate",runtime.getObject(),X509CERT_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("CertificateError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory certcb = runtime.callbackFactory(X509Cert.class);
-        cX509Cert.defineSingletonMethod("new",certcb.getOptSingletonMethod("newInstance"));
         cX509Cert.defineMethod("initialize",certcb.getOptMethod("_initialize"));
         cX509Cert.defineMethod("initialize_copy",certcb.getMethod("initialize_copy",IRubyObject.class));
         cX509Cert.defineMethod("clone",certcb.getMethod("rbClone"));
         cX509Cert.defineMethod("to_der",certcb.getMethod("to_der"));
         cX509Cert.defineMethod("to_pem",certcb.getMethod("to_pem"));
         cX509Cert.defineMethod("to_s",certcb.getMethod("to_pem"));
         cX509Cert.defineMethod("to_text",certcb.getMethod("to_text"));
         cX509Cert.defineMethod("version",certcb.getMethod("version"));
         cX509Cert.defineMethod("version=",certcb.getMethod("set_version",IRubyObject.class));
         cX509Cert.defineMethod("signature_algorithm",certcb.getMethod("signature_algorithm"));
         cX509Cert.defineMethod("serial",certcb.getMethod("serial"));
         cX509Cert.defineMethod("serial=",certcb.getMethod("set_serial",IRubyObject.class));
         cX509Cert.defineMethod("subject",certcb.getMethod("subject"));
         cX509Cert.defineMethod("subject=",certcb.getMethod("set_subject",IRubyObject.class));
         cX509Cert.defineMethod("issuer",certcb.getMethod("issuer"));
         cX509Cert.defineMethod("issuer=",certcb.getMethod("set_issuer",IRubyObject.class));
         cX509Cert.defineMethod("not_before",certcb.getMethod("not_before"));
         cX509Cert.defineMethod("not_before=",certcb.getMethod("set_not_before",IRubyObject.class));
         cX509Cert.defineMethod("not_after",certcb.getMethod("not_after"));
         cX509Cert.defineMethod("not_after=",certcb.getMethod("set_not_after",IRubyObject.class));
         cX509Cert.defineMethod("public_key",certcb.getMethod("public_key"));
         cX509Cert.defineMethod("public_key=",certcb.getMethod("set_public_key",IRubyObject.class));
         cX509Cert.defineMethod("sign",certcb.getMethod("sign",IRubyObject.class,IRubyObject.class));
         cX509Cert.defineMethod("verify",certcb.getMethod("verify",IRubyObject.class));
         cX509Cert.defineMethod("check_private_key",certcb.getMethod("check_private_key",IRubyObject.class));
         cX509Cert.defineMethod("extensions",certcb.getMethod("extensions"));
         cX509Cert.defineMethod("extensions=",certcb.getMethod("set_extensions",IRubyObject.class));
         cX509Cert.defineMethod("add_extension",certcb.getMethod("add_extension",IRubyObject.class));
         cX509Cert.defineMethod("inspect",certcb.getMethod("inspect"));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        X509Cert result = new X509Cert(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public X509Cert(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     private IRubyObject serial;
     private IRubyObject not_before;
     private IRubyObject not_after;
     private IRubyObject issuer;
     private IRubyObject subject;
     private IRubyObject public_key;
 
     private IRubyObject sig_alg;
     private IRubyObject version;
 
     private List extensions;
 
     private boolean changed = true;
 
     private X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
     private X509Certificate cert;
 
     X509AuxCertificate getAuxCert() {
         if(null == cert) {
             return null;
         }
         if(cert instanceof X509AuxCertificate) {
             return (X509AuxCertificate)cert;
         }
         return new X509AuxCertificate(cert);
     }
 
     public static IRubyObject wrap(IRuby runtime, Certificate c) throws Exception {
         RubyClass cr = (RubyClass)(((RubyModule)(runtime.getModule("OpenSSL").getConstant("X509"))).getConstant("Certificate"));
         return cr.callMethod(runtime.getCurrentContext(),"new",runtime.newString(new String(c.getEncoded(),"ISO8859_1")));
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         extensions = new ArrayList();
         if(checkArgumentCount(args,0,1) == 0) {
             return this;
         }
         ThreadContext tc = getRuntime().getCurrentContext();
         IRubyObject arg = OpenSSLImpl.to_der_if_possible(args[0]);
         ByteArrayInputStream bis = new ByteArrayInputStream(arg.toString().getBytes("PLAIN"));
         CertificateFactory cf = CertificateFactory.getInstance("X.509","BC");
         cert = (X509Certificate)cf.generateCertificate(bis);
 
         set_serial(RubyNumeric.str2inum(getRuntime(),getRuntime().newString(cert.getSerialNumber().toString()),10));
         set_not_before(RubyTime.newTime(getRuntime(),cert.getNotBefore().getTime()));
         set_not_after(RubyTime.newTime(getRuntime(),cert.getNotAfter().getTime()));
         set_subject(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Name").callMethod(tc,"new",getRuntime().newString(new String(cert.getSubjectX500Principal().getEncoded(),"ISO8859_1"))));
         set_issuer(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Name").callMethod(tc,"new",getRuntime().newString(new String(cert.getIssuerX500Principal().getEncoded(),"ISO8859_1"))));
 
         IRubyObject extFact = ((RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("ExtensionFactory"))).callMethod(tc,"new");
         extFact.callMethod(tc,"subject_certificate=",this);
 
         Set crit = cert.getCriticalExtensionOIDs();
         if(crit != null) {
             for(Iterator iter = crit.iterator();iter.hasNext();) {
                 String critOid = (String)iter.next();
                 byte[] value = cert.getExtensionValue(critOid);
                 IRubyObject rValue = ASN1.decode(((RubyModule)(getRuntime().getModule("OpenSSL"))).getConstant("ASN1"),getRuntime().newString(new String(value,"PLAIN"))).callMethod(tc,"value");
                 //                add_extension(extFact.callMethod("create_ext", new IRubyObject[]{getRuntime().newString(critOid),getRuntime().newString(Utils.toHex(rValue.toString().substring(2).getBytes("PLAIN"),':')),getRuntime().getTrue()}));
                 if(critOid.equals("2.5.29.17")) {
                     add_extension(extFact.callMethod(tc,"create_ext", new IRubyObject[]{getRuntime().newString(critOid),getRuntime().newString(rValue.toString()),getRuntime().getTrue()}));
                 } else {
                     add_extension(extFact.callMethod(tc,"create_ext", new IRubyObject[]{getRuntime().newString(critOid),getRuntime().newString(rValue.toString().substring(2)),getRuntime().getTrue()}));
                 }
             }
         }
 
         Set ncrit = cert.getNonCriticalExtensionOIDs();
         if(ncrit != null) {
             for(Iterator iter = ncrit.iterator();iter.hasNext();) {
                 String ncritOid = (String)iter.next();
                 byte[] value = cert.getExtensionValue(ncritOid);
                 IRubyObject rValue = ASN1.decode(((RubyModule)(getRuntime().getModule("OpenSSL"))).getConstant("ASN1"),getRuntime().newString(new String(value,"PLAIN"))).callMethod(tc,"value");
                 //                add_extension(extFact.callMethod("create_ext", new IRubyObject[]{getRuntime().newString(ncritOid),getRuntime().newString(Utils.toHex(rValue.toString().substring(2).getBytes("PLAIN"),':')),getRuntime().getFalse()}));
 
                 if(ncritOid.equals("2.5.29.17")) {
                     add_extension(extFact.callMethod(tc,"create_ext", new IRubyObject[]{getRuntime().newString(ncritOid),getRuntime().newString(rValue.toString()),getRuntime().getFalse()}));
                 } else {
                     add_extension(extFact.callMethod(tc,"create_ext", new IRubyObject[]{getRuntime().newString(ncritOid),getRuntime().newString(rValue.toString().substring(2)),getRuntime().getFalse()}));
                 }
             }
         }
         changed = false;
 
         return this;
     }
 
     public IRubyObject initialize_copy(IRubyObject obj) {
         if(this == obj) {
             return this;
         }
         checkFrozen();
         return this;
     }
 
     public IRubyObject to_der() throws Exception {
         return getRuntime().newString(new String(cert.getEncoded(),"ISO8859_1"));
     }
 
     public IRubyObject to_pem() throws Exception {
         StringWriter w = new StringWriter();
         PEM.write_X509(w,getAuxCert());
         w.close();
         return getRuntime().newString(w.toString());
     }
 
     public IRubyObject to_text() {
         return getRuntime().getNil();
     }
 
     public IRubyObject inspect() {
         return getRuntime().getNil();
     }
 
     public IRubyObject version() {
         return version;
     }
 
     public IRubyObject set_version(IRubyObject arg) {
         if(!arg.equals(this.version)) {
             changed = true;
         }
         this.version = arg;
         return arg;
     }
 
     public IRubyObject signature_algorithm() {
         return sig_alg;
     }
 
     public IRubyObject serial() {
         return serial;
     }
 
     public IRubyObject set_serial(IRubyObject num) {
         if(!num.equals(this.serial)) {
             changed = true;
         }
         serial = num;
         generator.setSerialNumber(new BigInteger(serial.toString()));
         return num;
     }
 
     public IRubyObject subject() {
         return subject;
     }
 
     public IRubyObject set_subject(IRubyObject arg) {
         if(!arg.equals(this.subject)) {
             changed = true;
         }
         subject = arg;
         generator.setSubjectDN(((X509Name)subject).getRealName());
         return arg;
     }
 
     public IRubyObject issuer() {
         return issuer;
     }
 
     public IRubyObject set_issuer(IRubyObject arg) {
         if(!arg.equals(this.issuer)) {
             changed = true;
         }
         issuer = arg;
         generator.setIssuerDN(((X509Name)issuer).getRealName());
         return arg;
     }
 
     public IRubyObject not_before() {
         return not_before;
     }
 
     public IRubyObject set_not_before(IRubyObject arg) {
         changed = true;
         not_before = arg.callMethod(getRuntime().getCurrentContext(),"getutc");
         ((RubyTime)not_before).setMicroseconds(0);
         generator.setNotBefore(((RubyTime)not_before).getJavaDate());
         return arg;
     }
 
     public IRubyObject not_after() {
         return not_after;
     }
 
     public IRubyObject set_not_after(IRubyObject arg) {
         changed = true;
         not_after = arg.callMethod(getRuntime().getCurrentContext(),"getutc");
         ((RubyTime)not_after).setMicroseconds(0);
         generator.setNotAfter(((RubyTime)not_after).getJavaDate());
         return arg;
     }
 
     public IRubyObject public_key() {
         return public_key;
     }
 
     public IRubyObject set_public_key(IRubyObject arg) {
         if(!arg.equals(this.public_key)) {
             changed = true;
         }
         public_key = arg;
         generator.setPublicKey(((PKey)public_key).getPublicKey());
         return arg;
     }
 
     public IRubyObject sign(IRubyObject key, IRubyObject digest) throws Exception {
         // Have to obey some artificial constraints of the OpenSSL implementation. Stupid.
         String keyAlg = ((PKey)key).getAlgorithm();
         String digAlg = ((Digest)digest).getAlgorithm();
         
         if(("DSA".equalsIgnoreCase(keyAlg) && "MD5".equalsIgnoreCase(digAlg)) || 
            ("RSA".equalsIgnoreCase(keyAlg) && "DSS1".equals(((Digest)digest).name().toString())) ||
            ("DSA".equalsIgnoreCase(keyAlg) && "SHA1".equals(((Digest)digest).name().toString()))) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("CertificateError")), null, true);
         }
 
         for(Iterator iter = extensions.iterator();iter.hasNext();) {
             X509Extensions.Extension ag = (X509Extensions.Extension)iter.next();
             generator.addExtension(ag.getRealOid(),ag.getRealCritical(),ag.getRealValueBytes());
         }
 
         sig_alg = getRuntime().newString(digAlg);
         generator.setSignatureAlgorithm(digAlg + "WITH" + keyAlg);
         cert = generator.generateX509Certificate(((PKey)key).getPrivateKey());
         changed = false;
         return this;
     }
 
     public IRubyObject verify(IRubyObject key) throws Exception {
         if(changed) {
             return getRuntime().getFalse();
         }
         try {
             cert.verify(((PKey)key).getPublicKey());
             return getRuntime().getTrue();
         } catch(InvalidKeyException e) {
             return getRuntime().getFalse();
         }
     }
 
     public IRubyObject check_private_key(IRubyObject arg) {
         return getRuntime().getNil();
     }
 
     public IRubyObject extensions() {
         return getRuntime().newArray(extensions);
     }
 
     public IRubyObject set_extensions(IRubyObject arg) {
         extensions = ((RubyArray)arg).getList();
         return arg;
     }
 
     public IRubyObject add_extension(IRubyObject arg) throws Exception {
         changed = true;
         if(((X509Extensions.Extension)arg).getRealOid().equals(new DERObjectIdentifier("2.5.29.17"))) {
             boolean one = true;
             for(Iterator iter = extensions.iterator();iter.hasNext();) {
                 X509Extensions.Extension ag = (X509Extensions.Extension)iter.next();
                 if(ag.getRealOid().equals(new DERObjectIdentifier("2.5.29.17"))) {
                     GeneralName[] n1 = GeneralNames.getInstance(new ASN1InputStream(ag.getRealValueBytes()).readObject()).getNames();
                     GeneralName[] n2 = GeneralNames.getInstance(new ASN1InputStream(((X509Extensions.Extension)arg).getRealValueBytes()).readObject()).getNames();
                     ASN1EncodableVector v1 = new ASN1EncodableVector();
 
                     for(int i=0;i<n1.length;i++) {
                         v1.add(n1[i]);
                     }
                     for(int i=0;i<n2.length;i++) {
                         v1.add(n2[i]);
                     }
                     ag.setRealValue(new String(new GeneralNames(new DERSequence(v1)).getDEREncoded(),"ISO8859_1"));
                     one = false;
                     break;
                 }
             }
             if(one) {
                 extensions.add(arg);
             }
         } else {
             extensions.add(arg);
         }
         return arg;
     }
 
     public IRubyObject rbClone() {
         IRubyObject clone = new X509Cert(getRuntime(),getMetaClass().getRealClass());
         clone.setMetaClass(getMetaClass().getSingletonClassClone());
         clone.setTaint(this.isTaint());
         clone.initCopy(this);
         clone.setFrozen(isFrozen());
         return clone;
     }
 }// X509Cert
 
diff --git a/src/org/jruby/ext/openssl/X509Extensions.java b/src/org/jruby/ext/openssl/X509Extensions.java
index 5a54d9a148..d79a911fff 100644
--- a/src/org/jruby/ext/openssl/X509Extensions.java
+++ b/src/org/jruby/ext/openssl/X509Extensions.java
@@ -1,641 +1,628 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.security.MessageDigest;
 import java.util.Iterator;
 import java.util.List;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.ASN1Sequence;
 import org.bouncycastle.asn1.DERBitString;
 import org.bouncycastle.asn1.DERBoolean;
 import org.bouncycastle.asn1.DERIA5String;
 import org.bouncycastle.asn1.DERInteger;
 import org.bouncycastle.asn1.DERObject;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DEROctetString;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERString;
 import org.bouncycastle.asn1.DERUnknownTag;
 import org.bouncycastle.asn1.x509.GeneralName;
 import org.bouncycastle.asn1.x509.GeneralNames;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.RubyString;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509Extensions {
     public static void createX509Ext(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509ExtFactory = mX509.defineClassUnder("ExtensionFactory",runtime.getObject());
-        mX509.defineClassUnder("ExtensionError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509ExtFactory = mX509.defineClassUnder("ExtensionFactory",runtime.getObject(),runtime.getObject().getAllocator());
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("ExtensionError",openSSLError,openSSLError.getAllocator());
         
         CallbackFactory extfcb = runtime.callbackFactory(ExtensionFactory.class);
-        cX509ExtFactory.defineSingletonMethod("new",extfcb.getOptSingletonMethod("newInstance"));
         cX509ExtFactory.defineMethod("initialize",extfcb.getOptMethod("initialize"));
 
         cX509ExtFactory.attr_reader(new IRubyObject[]{runtime.newString("issuer_certificate"),runtime.newString("subject_certificate"),
                                             runtime.newString("subject_request"),runtime.newString("crl"),
                                             runtime.newString("config")});
         cX509ExtFactory.defineMethod("issuer_certificate=",extfcb.getMethod("set_issuer_cert",IRubyObject.class));
         cX509ExtFactory.defineMethod("subject_certificate=",extfcb.getMethod("set_subject_cert",IRubyObject.class));
         cX509ExtFactory.defineMethod("subject_request=",extfcb.getMethod("set_subject_req",IRubyObject.class));
         cX509ExtFactory.defineMethod("crl=",extfcb.getMethod("set_crl",IRubyObject.class));
         cX509ExtFactory.defineMethod("config=",extfcb.getMethod("set_config",IRubyObject.class));
         cX509ExtFactory.defineMethod("create_ext",extfcb.getOptMethod("create_ext"));
 
-        RubyClass cX509Ext = mX509.defineClassUnder("Extension",runtime.getObject());
+        RubyClass cX509Ext = mX509.defineClassUnder("Extension",runtime.getObject(),runtime.getObject().getAllocator());
         CallbackFactory extcb = runtime.callbackFactory(Extension.class);
-        cX509Ext.defineSingletonMethod("new",extcb.getOptSingletonMethod("newInstance"));
         cX509Ext.defineMethod("initialize",extcb.getOptMethod("_initialize"));
         cX509Ext.defineMethod("oid=",extcb.getMethod("set_oid",IRubyObject.class));
         cX509Ext.defineMethod("value=",extcb.getMethod("set_value",IRubyObject.class));
         cX509Ext.defineMethod("critical=",extcb.getMethod("set_critical",IRubyObject.class));
         cX509Ext.defineMethod("oid",extcb.getMethod("oid"));
         cX509Ext.defineMethod("value",extcb.getMethod("value"));
         cX509Ext.defineMethod("critical?",extcb.getMethod("critical_p"));
         cX509Ext.defineMethod("to_der",extcb.getMethod("to_der"));
     }
 
     public static class ExtensionFactory extends RubyObject {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            ExtensionFactory result = new ExtensionFactory(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public ExtensionFactory(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         public IRubyObject initialize(IRubyObject[] args) {
             checkArgumentCount(args,0,4);
             if(args.length > 0 && !args[0].isNil()) {
                 set_issuer_cert(args[0]);
             }
             if(args.length > 1 && !args[1].isNil()) {
                 set_subject_cert(args[1]);
             }
             if(args.length > 2 && !args[2].isNil()) {
                 set_subject_req(args[2]);
             }
             if(args.length > 3 && !args[3].isNil()) {
                 set_crl(args[3]);
             }
             return this;
         }
 
         public IRubyObject set_issuer_cert(IRubyObject arg) {
             setInstanceVariable("@issuer_certificate",arg);
             return arg;
         }
 
         public IRubyObject set_subject_cert(IRubyObject arg) {
             setInstanceVariable("@subject_certificate",arg);
             return arg;
         }
 
         public IRubyObject set_subject_req(IRubyObject arg) {
             setInstanceVariable("@subject_request",arg);
             return arg;
         }
 
         public IRubyObject set_crl(IRubyObject arg) {
             setInstanceVariable("@crl",arg);
             return arg;
         }
 
         public IRubyObject set_config(IRubyObject arg) {
             setInstanceVariable("@config",arg);
             return arg;
         }
 
         private DERObjectIdentifier getObjectIdentifier(String nameOrOid) {
             Object val1 = ASN1.getOIDLookup(getRuntime()).get(nameOrOid.toLowerCase());
             if(null != val1) {
                 return (DERObjectIdentifier)val1;
             }
             DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
             return val2;
         }
 
         private static boolean isHexDigit(char c) {
             return ('0'<=c && c<='9') || ('A'<= c && c <= 'F') || ('a'<= c && c <= 'f');
         }
 
         public IRubyObject create_ext(IRubyObject[] args) throws Exception {
             IRubyObject critical = getRuntime().getFalse();
             if(checkArgumentCount(args,2,3) == 3 && !args[2].isNil()) {
                 critical = args[2];
             }
             String oid = args[0].toString();
             String valuex = args[1].toString();
             Object value = valuex;
 
             DERObjectIdentifier r_oid = null;
 
             try {
                 r_oid = getObjectIdentifier(oid);
             } catch(IllegalArgumentException e) {
                 r_oid = null;
             }
             if(null == r_oid) {
                 throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("ExtensionError")), "unknown OID `" + oid + "'", true);
             }
 
             ThreadContext tc = getRuntime().getCurrentContext();
             Extension ext = (Extension)(((RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("Extension"))).callMethod(tc,"new"));
 
             if(valuex.startsWith("critical,")) {
                 critical = getRuntime().getTrue();
                 value = valuex.substring(9).trim();
             }
 
             if(r_oid.equals(new DERObjectIdentifier("2.5.29.14"))) { //subjectKeyIdentifier
                 if("hash".equalsIgnoreCase(valuex)) {
                     IRubyObject pkey = getInstanceVariable("@subject_certificate").callMethod(tc,"public_key");
                     IRubyObject val = null;
                     if(pkey instanceof PKeyRSA) {
                         val = pkey.callMethod(tc,"to_der");
                     } else {
                         val = ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),pkey.callMethod(tc,"to_der")).callMethod(tc,"value").callMethod(tc,"[]",getRuntime().newFixnum(1)).callMethod(tc,"value");
                     }
                     byte[] b = MessageDigest.getInstance("SHA-1").digest(val.toString().getBytes("PLAIN"));
                     value = new String(new DEROctetString(b).getDEREncoded(),"ISO8859_1");
                 } else if(valuex.length() == 20) {
                     value = new String(new DEROctetString(valuex.getBytes("PLAIN")).getDEREncoded(),"ISO8859_1");
                 } else {
                     StringBuffer nstr = new StringBuffer();
                     for(int i = 0; i < valuex.length(); i+=2) {
                         if(i+1 >= valuex.length()) {
                             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("ExtensionError")), oid + " = " + value + ": odd number of digits", true);
                         }
 
                         char c1 = valuex.charAt(i);
                         char c2 = valuex.charAt(i+1);
                         if(isHexDigit(c1) && isHexDigit(c2)) {
                             nstr.append(Character.toUpperCase(c1)).append(Character.toUpperCase(c2));
                         } else {
                             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("ExtensionError")), oid + " = " + value + ": illegal hex digit", true);
                         }
                         while((i+2) < valuex.length() && valuex.charAt(i+2) == ':') {
                             i++;
                         }
                     }
                     String v = nstr.toString();
                     byte[] arr = new byte[v.length()/2];
                     for(int i=0;i<v.length();i+=2) {
                         arr[i/2] = (byte)Integer.parseInt(v.substring(i,i+2),16);
                     }
                     value = new String(new DEROctetString(arr).getDEREncoded(),"ISO8859_1");
                 }
             } else if(r_oid.equals(new DERObjectIdentifier("2.5.29.35"))) { //authorityKeyIdentifier
                 String ourV = valuex;
                 ASN1EncodableVector asnv = new ASN1EncodableVector();
                
                 if(ourV.startsWith("keyid:always")) {
                     ourV = ourV.substring("keyid:always".length());
                     IRubyObject pkey = getInstanceVariable("@issuer_certificate").callMethod(tc,"public_key");
                     IRubyObject val = null;
                     if(pkey instanceof PKeyRSA) {
                         val = pkey.callMethod(tc,"to_der");
                     } else {
                         val = ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),pkey.callMethod(tc,"to_der")).callMethod(tc,"value").callMethod(tc,"[]",getRuntime().newFixnum(1)).callMethod(tc,"value");
                     }
                     byte[] b = MessageDigest.getInstance("SHA-1").digest(val.toString().getBytes("PLAIN"));
                     asnv.add(new DEROctetString(b));
                 } else if(ourV.startsWith("keyid")) {
                     ourV = ourV.substring("keyid".length());
                     IRubyObject pkey = getInstanceVariable("@issuer_certificate").callMethod(tc,"public_key");
                     IRubyObject val = null;
                     if(pkey instanceof PKeyRSA) {
                         val = pkey.callMethod(tc,"to_der");
                     } else {
                         val = ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),pkey.callMethod(tc,"to_der")).callMethod(tc,"value").callMethod(tc,"[]",getRuntime().newFixnum(1)).callMethod(tc,"value");
                     }
                     byte[] b = MessageDigest.getInstance("SHA-1").digest(val.toString().getBytes("PLAIN"));
                     asnv.add(new DEROctetString(b));
                 }
                 value = new String(new DERSequence(asnv).getDEREncoded(),"ISO8859_1");
             } else if(r_oid.equals(new DERObjectIdentifier("2.5.29.18"))) { //issuerAltName
                 if(valuex.startsWith("issuer:copy")) {
                     List exts = ((RubyArray)getInstanceVariable("@issuer_certificate").callMethod(tc,"extensions")).getList();
                     for(Iterator iter = exts.iterator();iter.hasNext();) {
                         Extension exta = (Extension)iter.next();
                         if(exta.getRealOid().equals(new DERObjectIdentifier("2.5.29.17"))) {
                             value = exta.getRealValue();
                             break;
                         }
                     }
                 }
             } else if(r_oid.equals(new DERObjectIdentifier("2.5.29.19"))) { //basicConstraints
                 String[] spl = valuex.split(",");
                 for(int i=0;i<spl.length;i++) {
                     spl[i] = spl[i].trim();
                 }
                 ASN1EncodableVector asnv = new ASN1EncodableVector();
                 for(int i=0;i<spl.length;i++) {
                     if(spl[i].length() > 3 && spl[i].substring(0,3).equalsIgnoreCase("CA:")) {
                         asnv.add(new DERBoolean("TRUE".equalsIgnoreCase(spl[i].substring(3).trim())));
                     }
                 }
                 for(int i=0;i<spl.length;i++) {
                     if(spl[i].length() > 8 && spl[i].substring(0,8).equalsIgnoreCase("pathlen:")) {
                         asnv.add(new DERInteger(Integer.parseInt(spl[i].substring(8).trim())));
                     }
                 }
                 value = new String(new DERSequence(asnv).getDEREncoded(),"ISO8859_1");
             } else if(r_oid.equals(new DERObjectIdentifier("2.5.29.15"))) { //keyUsage
                 byte[] inp = null;
                 inp = null;
                 try {
                     String[] exx = valuex.split(":");
                     if(exx != null) {
                         inp = new byte[exx.length];
                         for(int i=0;i<exx.length;i++) {
                             inp[i] = (byte)Integer.parseInt(exx[i],16);
                         }
                     }
                 } catch(Exception e) {
                     inp = null;
                 }
 
                 if(null == inp && valuex.length()<3) {
                     inp = valuex.getBytes("PLAIN");
                 }
 
                 if(inp == null) {
                     byte v1 = 0;
                     byte v2 = 0;
                     String[] spl = valuex.split(",");
                     for(int i=0;i<spl.length;i++) {
                         spl[i] = spl[i].trim();
                     }
                     for(int i=0;i<spl.length;i++) {
                         if("decipherOnly".equals(spl[i].trim()) || "Decipher Only".equals(spl[i].trim())) {
                             v2 |= (byte)128;
                         } else if("digitalSignature".equals(spl[i].trim()) || "Digital Signature".equals(spl[i].trim())) {
                             v1 |= (byte)128;
                         } else if("nonRepudiation".equals(spl[i].trim()) || "Non Repudiation".equals(spl[i].trim())) {
                             v1 |= (byte)64;
                         } else if("keyEncipherment".equals(spl[i].trim()) || "Key Encipherment".equals(spl[i].trim())) {
                             v1 |= (byte)32;
                         } else if("dataEncipherment".equals(spl[i].trim()) || "Data Encipherment".equals(spl[i].trim())) {
                             v1 |= (byte)16;
                         } else if("keyAgreement".equals(spl[i].trim()) || "Key Agreement".equals(spl[i].trim())) {
                             v1 |= (byte)8;
                         } else if("keyCertSign".equals(spl[i].trim()) || "Key Cert Sign".equals(spl[i].trim())) {
                             v1 |= (byte)4;
                         } else if("cRLSign".equals(spl[i].trim())) {
                             v1 |= (byte)2;
                         } else if("encipherOnly".equals(spl[i].trim()) || "Encipher Only".equals(spl[i].trim())) {
                             v1 |= (byte)1;
                         } else {
                             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("ExtensionError")), oid + " = " + valuex + ": unknown bit string argument", true);
                         }
                     }
                     if(v2 != 0) {
                         inp = new byte[]{v1,v2};
                     } else {
                         inp = new byte[]{v1};
                     }
                 }
 
                 int unused = 0;
                 for(int i = (inp.length-1); i>-1; i--) {
                     if(inp[i] == 0) {
                         unused += 8;
                     } else {
                         byte a2 = inp[i];
                         int x = 8;
                         while(a2 != 0) {
                             a2 <<= 1;
                             x--;
                         }
                         unused += x;
                         break;
                     }
                 }
                 
                 value = new String(new DERBitString(inp,unused).getDEREncoded(),"ISO8859_1");
             } else if(r_oid.equals(new DERObjectIdentifier("2.5.29.17"))) { //subjectAltName
                 if(valuex.startsWith("DNS:")) {
                     value = new String(new GeneralNames(new GeneralName(GeneralName.dNSName,new DERIA5String(valuex.substring(4)))).getDEREncoded(),"ISO8859_1");
                 } else if(valuex.startsWith("IP:")) {
                     String[] numbers = valuex.substring(3).split("\\.");
                     byte[] bs = new byte[4];
                     bs[0] = (byte) (Integer.parseInt(numbers[0]) & 0xff);
                     bs[1] = (byte) (Integer.parseInt(numbers[1]) & 0xff);
                     bs[2] = (byte) (Integer.parseInt(numbers[2]) & 0xff);
                     bs[3] = (byte) (Integer.parseInt(numbers[3]) & 0xff);
                     value = new String(new GeneralNames(new GeneralName(GeneralName.iPAddress,new DEROctetString(bs))).getDEREncoded(),"ISO8859_1");
                 } else if(valuex.startsWith("IP Address:")) {
                     String[] numbers = valuex.substring(11).split("\\.");
                     byte[] bs = new byte[4];
                     bs[0] = (byte) (Integer.parseInt(numbers[0]) & 0xff);
                     bs[1] = (byte) (Integer.parseInt(numbers[1]) & 0xff);
                     bs[2] = (byte) (Integer.parseInt(numbers[2]) & 0xff);
                     bs[3] = (byte) (Integer.parseInt(numbers[3]) & 0xff);
                     value = new String(new GeneralNames(new GeneralName(GeneralName.iPAddress,new DEROctetString(bs))).getDEREncoded(),"ISO8859_1");
                 }
             } else {
                 value = new DEROctetString(new DEROctetString(valuex.getBytes("PLAIN")).getDEREncoded());
             }
 
             ext.setRealOid(r_oid);
             ext.setRealValue(value);
             ext.setRealCritical(critical.isTrue());
 
             return ext;
         }
     }
 
     public static class Extension extends RubyObject {
-        public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-            Extension result = new Extension(recv.getRuntime(), (RubyClass)recv);
-            result.callInit(args);
-            return result;
-        }
-
         public Extension(IRuby runtime, RubyClass type) {
             super(runtime,type);
         }
 
         private DERObjectIdentifier oid;
         private Object value;
         private boolean critical;
 
         void setRealOid(DERObjectIdentifier oid) {
             this.oid = oid;
         }
 
         void setRealValue(Object value) {
             this.value = value;
         }
 
         void setRealCritical(boolean critical) {
             this.critical = critical;
         }
         
         DERObjectIdentifier getRealOid() {
             return oid;
         }
 
         Object getRealValue() {
             return value;
         }
 
         byte[] getRealValueBytes() throws Exception {
             if((value instanceof RubyString) || (value instanceof String)) {
                 return value.toString().getBytes("PLAIN");
             } else if(value instanceof DEROctetString) {
                 return ((DEROctetString)value).getOctets();
             } else {
                 return ((ASN1.ASN1Data)value).toASN1().getDEREncoded();
             }
         }
 
         boolean getRealCritical() {
             return critical;
         }
 
         DERObjectIdentifier getObjectIdentifier(String nameOrOid) {
             Object val1 = ASN1.getOIDLookup(getRuntime()).get(nameOrOid.toLowerCase());
             if(null != val1) {
                 return (DERObjectIdentifier)val1;
             }
             DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
             return val2;
         }
 
         public IRubyObject _initialize(IRubyObject[] args) throws Exception {
             byte[] octets = null;
             if(args.length == 1) {
                 ASN1InputStream is = new ASN1InputStream(OpenSSLImpl.to_der_if_possible(args[0]).toString().getBytes("PLAIN"));
                 Object obj = is.readObject();
                 ASN1Sequence seq = (ASN1Sequence)obj;
                 setRealOid((DERObjectIdentifier)(seq.getObjectAt(0)));
                 setRealCritical(((DERBoolean)(seq.getObjectAt(1))).isTrue());
                 octets = ((DEROctetString)(seq.getObjectAt(2))).getOctets();
             } else if(args.length > 1) {
                 setRealOid(getObjectIdentifier(args[0].toString()));
                 setRealValue(args[1]);
             }
             if(args.length > 2) {
                 setRealCritical(args[2].isTrue());
             }
             if(args.length > 0 && octets != null) {
                 setRealValue(new String(octets,"ISO8859_1"));
             }
 
             return this;
         }
 
         public IRubyObject set_oid(IRubyObject arg) {
             System.err.println("WARNING: calling ext#oid=");
             return getRuntime().getNil();
         }
 
         public IRubyObject set_value(IRubyObject arg) {
             System.err.println("WARNING: calling ext#value=");
             return getRuntime().getNil();
         }
 
         public IRubyObject set_critical(IRubyObject arg) {
             System.err.println("WARNING: calling ext#critical=");
             return getRuntime().getNil();
         }
 
         public IRubyObject oid() {
             return getRuntime().newString((String)(ASN1.getSymLookup(getRuntime()).get(oid)));
         }
 
         public IRubyObject value() throws Exception {
             if(getRealOid().equals(new DERObjectIdentifier("2.5.29.19"))) { //basicConstraints
                 ASN1Sequence seq2 = (ASN1Sequence)(new ASN1InputStream(getRealValueBytes()).readObject());
                 String c = "";
                 String path = "";
                 if(seq2.size()>0) {
                     c = "CA:" + (((DERBoolean)(seq2.getObjectAt(0))).isTrue() ? "TRUE" : "FALSE");
                 }
                 if(seq2.size()>1) {
                     path = ", pathlen:" + seq2.getObjectAt(1).toString();
                 }
                 return getRuntime().newString(c+path);
             } else if(getRealOid().equals(new DERObjectIdentifier("2.5.29.15"))) { //keyUsage
                 byte[] bx = getRealValueBytes();
                 byte[] bs = new byte[bx.length-2];
                 System.arraycopy(bx,2,bs,0,bs.length);
                 byte b1 = 0;
                 byte b2 = bs[0];
                 if(bs.length>1) {
                     b1 = bs[1];
                 }
                 StringBuffer sbe = new StringBuffer();
                 String sep = "";
                 if((b2 & (byte)128) != 0) {
                     sbe.append(sep).append("Decipher Only");
                     sep = ", ";
                 }
                 if((b1 & (byte)128) != 0) {
                     sbe.append(sep).append("Digital Signature");
                     sep = ", ";
                 }
                 if((b1 & (byte)64) != 0) {
                     sbe.append(sep).append("Non Repudiation");
                     sep = ", ";
                 }
                 if((b1 & (byte)32) != 0) {
                     sbe.append(sep).append("Key Encipherment");
                     sep = ", ";
                 }
                 if((b1 & (byte)16) != 0) {
                     sbe.append(sep).append("Data Encipherment");
                     sep = ", ";
                 }
                 if((b1 & (byte)8) != 0) {
                     sbe.append(sep).append("Key Agreement");
                     sep = ", ";
                 }
                 if((b1 & (byte)4) != 0) {
                     sbe.append(sep).append("Key Cert Sign");
                     sep = ", ";
                 }
                 if((b1 & (byte)2) != 0) {
                     sbe.append(sep).append("cRLSign");
                     sep = ", ";
                 }
                 if((b1 & (byte)1) != 0) {
                     sbe.append(sep).append("Encipher Only");
                 }
                 return getRuntime().newString(sbe.toString());
             } else if(getRealOid().equals(new DERObjectIdentifier("2.5.29.14"))) { //subjectKeyIdentifier
                 byte[] b1 = getRealValueBytes();
                 byte[] b2 = new byte[b1.length-2];
                 System.arraycopy(b1,2,b2,0,b2.length);
                 return getRuntime().newString(Utils.toHex(b2,':'));
             } else if(getRealOid().equals(new DERObjectIdentifier("2.5.29.35"))) { // authorityKeyIdentifier
                 DERSequence seq = (DERSequence)(new ASN1InputStream(getRealValueBytes()).readObject());
                 StringBuffer out1 = new StringBuffer();
                 if(seq.size() > 0) {
                     out1.append("keyid:");
                     out1.append(Utils.toHex(((DEROctetString)seq.getObjectAt(0)).getOctets(),':'));
                 }
                 return getRuntime().newString(out1.toString());
             } else if(getRealOid().equals(new DERObjectIdentifier("2.5.29.21"))) { // CRLReason
                 switch(RubyNumeric.fix2int(((IRubyObject)value).callMethod(getRuntime().getCurrentContext(),"value"))) {
                 case 0:
                     return getRuntime().newString("Unspecified");
                 case 1:
                     return getRuntime().newString("Key Compromise");
                 case 2:
                     return getRuntime().newString("CA Compromise");
                 case 3:
                     return getRuntime().newString("Affiliation Changed");
                 case 4:
                     return getRuntime().newString("Superseded");
                 case 5:
                     return getRuntime().newString("Cessation Of Operation");
                 case 6:
                     return getRuntime().newString("Certificate Hold");
                 case 8:
                     return getRuntime().newString("Remove From CRL");
                 case 9:
                     return getRuntime().newString("Privilege Withdrawn");
                 default:
                     return getRuntime().newString("Unspecified");
                 }
             } else if(getRealOid().equals(new DERObjectIdentifier("2.5.29.17"))) { //subjectAltName
                 try {
                     DERObject seq = new ASN1InputStream(getRealValueBytes()).readObject();
                     GeneralName[] n1 = null;
                     if(seq instanceof DERUnknownTag) {
                         n1 = new GeneralName[]{GeneralName.getInstance(seq)};
                     } else if(seq instanceof org.bouncycastle.asn1.DERTaggedObject) {
                         n1 = new GeneralName[]{GeneralName.getInstance(seq)};
                     } else {
                         n1 = GeneralNames.getInstance(seq).getNames();
                     }
                     StringBuffer sbe = new StringBuffer();
                     String sep = "";
                     for(int i=0;i<n1.length;i++) {
                         sbe.append(sep);
                         if(n1[i].getTagNo() == GeneralName.dNSName) {
                             sbe.append("DNS:");
                             sbe.append(((DERString)n1[i].getName()).getString());
                         } else if(n1[i].getTagNo() == GeneralName.iPAddress) {
                             sbe.append("IP Address:");
                             byte[] bs = ((DEROctetString)n1[i].getName()).getOctets();
                             String sep2 = "";
                             for(int j=0;j<bs.length;j++) {
                                 sbe.append(sep2);
                                 sbe.append(((int)bs[j]) & 0xff);
                                 sep2 = ".";
                             }
                         } else {
                             sbe.append(n1[i].toString());
                         }
                         sep = ", ";
                     }
                     return getRuntime().newString(sbe.toString());
                 } catch(Exception e) {
                     return getRuntime().newString(getRealValue().toString());
                 }
             } else {
                 try {
                     return ASN1.decode(getRuntime().getModule("OpenSSL").getConstant("ASN1"),getRuntime().newString(new String(getRealValueBytes(),"ISO8859_1"))).callMethod(getRuntime().getCurrentContext(),"value").callMethod(getRuntime().getCurrentContext(),"to_s");
                 } catch(Exception e) {
                     return getRuntime().newString(getRealValue().toString());
                 }
             }
         }
 
         public IRubyObject critical_p() {
             return critical ? getRuntime().getTrue() : getRuntime().getFalse();
         }
 
         public IRubyObject to_der() throws Exception {
             ASN1EncodableVector all = new ASN1EncodableVector();
             all.add(getRealOid());
             all.add(getRealCritical() ? DERBoolean.TRUE : DERBoolean.FALSE);
             all.add(new DEROctetString(getRealValueBytes()));
             return getRuntime().newString(new String(new DERSequence(all).getDEREncoded(),"ISO8859_1"));
         }
     }
 }// X509Extensions
diff --git a/src/org/jruby/ext/openssl/X509Name.java b/src/org/jruby/ext/openssl/X509Name.java
index 87df1e8f40..9e4ada6ef1 100644
--- a/src/org/jruby/ext/openssl/X509Name.java
+++ b/src/org/jruby/ext/openssl/X509Name.java
@@ -1,392 +1,393 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Vector;
 
 import org.bouncycastle.asn1.ASN1EncodableVector;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.ASN1Sequence;
 import org.bouncycastle.asn1.ASN1Set;
 import org.bouncycastle.asn1.DERObject;
 import org.bouncycastle.asn1.DERObjectIdentifier;
 import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.DERSet;
 import org.bouncycastle.asn1.DERString;
 import org.bouncycastle.asn1.DERTags;
 import org.bouncycastle.asn1.x509.X509DefaultEntryConverter;
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyHash;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509Name extends RubyObject {
+    private static ObjectAllocator X509NAME_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509Name(runtime, klass);
+        }
+    };
+    
     public static void createX509Name(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509Name = mX509.defineClassUnder("Name",runtime.getObject());
-        mX509.defineClassUnder("NameError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509Name = mX509.defineClassUnder("Name",runtime.getObject(),X509NAME_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("NameError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory namecb = runtime.callbackFactory(X509Name.class);
 
-        cX509Name.defineSingletonMethod("new",namecb.getOptSingletonMethod("newInstance"));
         cX509Name.defineMethod("initialize",namecb.getOptMethod("initialize"));
         cX509Name.defineMethod("add_entry",namecb.getOptMethod("add_entry"));
         cX509Name.defineMethod("to_s",namecb.getOptMethod("_to_s"));
         cX509Name.defineMethod("to_a",namecb.getMethod("to_a"));
         cX509Name.defineMethod("cmp",namecb.getMethod("cmp",IRubyObject.class));
         cX509Name.defineMethod("<=>",namecb.getMethod("cmp",IRubyObject.class));
         cX509Name.defineMethod("eql?",namecb.getMethod("eql_p",IRubyObject.class));
         cX509Name.defineMethod("hash",namecb.getMethod("hash"));
         cX509Name.defineMethod("to_der",namecb.getMethod("to_der"));
         
         cX509Name.setConstant("COMPAT",runtime.newFixnum(COMPAT));
         cX509Name.setConstant("RFC2253",runtime.newFixnum(RFC2253));
         cX509Name.setConstant("ONELINE",runtime.newFixnum(ONELINE));
         cX509Name.setConstant("MULTILINE",runtime.newFixnum(MULTILINE));
 
         cX509Name.setConstant("DEFAULT_OBJECT_TYPE",runtime.newFixnum(DERTags.UTF8_STRING));
 
         Map val = new HashMap();
         val.put(runtime.newString("C"),runtime.newFixnum(DERTags.PRINTABLE_STRING));
         val.put(runtime.newString("countryName"),runtime.newFixnum(DERTags.PRINTABLE_STRING));
         val.put(runtime.newString("serialNumber"),runtime.newFixnum(DERTags.PRINTABLE_STRING));
         val.put(runtime.newString("dnQualifier"),runtime.newFixnum(DERTags.PRINTABLE_STRING));
         val.put(runtime.newString("DC"),runtime.newFixnum(DERTags.IA5_STRING));
         val.put(runtime.newString("domainComponent"),runtime.newFixnum(DERTags.IA5_STRING));
         val.put(runtime.newString("emailAddress"),runtime.newFixnum(DERTags.IA5_STRING));
         cX509Name.setConstant("OBJECT_TYPE_TEMPLATE",new RubyHash(runtime,val,runtime.newFixnum(DERTags.UTF8_STRING)));
     }
 
     public static final int COMPAT = 0;
     public static final int RFC2253 = 17892119;
     public static final int ONELINE = 8520479;
     public static final int MULTILINE = 44302342;
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        X509Name result = new X509Name(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     public X509Name(IRuby runtime, RubyClass type) {
         super(runtime,type);
         oids = new ArrayList();
         values = new ArrayList();
         types = new ArrayList();
     }
 
     private org.bouncycastle.asn1.x509.X509Name name;
 
     private List oids;
     private List values;
     private List types;
 
     void addEntry(Object oid, Object value, Object type) {
         oids.add(oid);
         values.add(value);
         types.add(type);
     }
 
     public IRubyObject initialize(IRubyObject[] args) {
         if(checkArgumentCount(args,0,2) == 0) {
             return this;
         }
         IRubyObject arg = args[0];
         IRubyObject template = getRuntime().getNil();
         if(args.length > 1) {
             template = args[1];
         }
         IRubyObject tmp = (arg instanceof RubyArray) ? arg : getRuntime().getNil();
         if(!tmp.isNil()) {
             if(template.isNil()) {
                 template = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getClass("Name").getConstant("OBJECT_TYPE_TEMPLATE");
             }
             for(Iterator iter = ((RubyArray)tmp).getList().iterator();iter.hasNext();) {
                 RubyArray arr = (RubyArray)iter.next();
                 IRubyObject[] entry = new IRubyObject[3];
                 List l = arr.getList();
                 entry[0] = (IRubyObject)l.get(0);
                 entry[1] = (IRubyObject)l.get(1);
                 if(l.size()>2) {
                     entry[2] = (IRubyObject)l.get(2);
                 }
                 if(entry[2] == null || entry[2].isNil()) {
                     entry[2] = template.callMethod(getRuntime().getCurrentContext(),"[]",entry[0]);
                 }
                 if(entry[2] == null || entry[2].isNil()) {
                     entry[2] = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getClass("Name").getConstant("DEFAULT_OBJECT_TYPE");
                 }
                 add_entry(entry);
             }
         } else {
             try {
                 ASN1Sequence seq = (ASN1Sequence)new ASN1InputStream(OpenSSLImpl.to_der_if_possible(arg).toString().getBytes("PLAIN")).readObject();
                 oids = new ArrayList();
                 values = new ArrayList();
                 types = new ArrayList();
                 for(Enumeration enm = seq.getObjects();enm.hasMoreElements();) {
                     ASN1Sequence value = (ASN1Sequence)(((ASN1Set)enm.nextElement()).getObjectAt(0));
                     oids.add(value.getObjectAt(0));
                     if(value.getObjectAt(1) instanceof DERString) {
                         values.add(((DERString)value.getObjectAt(1)).getString());
                     } else {
                         values.add(null);
                     }
                     types.add(getRuntime().newFixnum(ASN1.idForClass(value.getObjectAt(1).getClass())));
                 }
             } catch(Exception e) {
                 System.err.println("exception in init for X509Name: " + e);
             }
         }
         return this;
     }
 
     private void printASN(org.bouncycastle.asn1.DERObject obj) {
         printASN(obj,0);
     }
     private void printASN(org.bouncycastle.asn1.DERObject obj, int indent) {
         if(obj instanceof org.bouncycastle.asn1.ASN1Sequence) {
             for(int i=0;i<indent;i++) {
                 System.err.print(" ");
             }
             System.err.println("- Sequence:");
             for(java.util.Enumeration enm = ((org.bouncycastle.asn1.ASN1Sequence)obj).getObjects();enm.hasMoreElements();) {
                 printASN((org.bouncycastle.asn1.DERObject)enm.nextElement(),indent+1);
             }
         } else if(obj instanceof org.bouncycastle.asn1.ASN1Set) {
             for(int i=0;i<indent;i++) {
                 System.err.print(" ");
             }
             System.err.println("- Set:");
             for(java.util.Enumeration enm = ((org.bouncycastle.asn1.ASN1Set)obj).getObjects();enm.hasMoreElements();) {
                 printASN((org.bouncycastle.asn1.DERObject)enm.nextElement(),indent+1);
             }
         } else {
             for(int i=0;i<indent;i++) {
                 System.err.print(" ");
             }
             if(obj instanceof org.bouncycastle.asn1.DERString) {
                 System.err.println("- " + obj + "=" + ((org.bouncycastle.asn1.DERString)obj).getString() + "[" + obj.getClass() + "]");
             } else {
                 System.err.println("- " + obj + "[" + obj.getClass() + "]");
             }
         }
     }
 
     private DERObjectIdentifier getObjectIdentifier(String nameOrOid) {
         Object val1 = ASN1.getOIDLookup(getRuntime()).get(nameOrOid.toLowerCase());
         if(null != val1) {
             return (DERObjectIdentifier)val1;
         }
         DERObjectIdentifier val2 = new DERObjectIdentifier(nameOrOid);
         return val2;
     }
 
     public IRubyObject add_entry(IRubyObject[] args) {
         checkArgumentCount(args,2,3);
         String oid = args[0].toString();
         String value = args[1].toString();
         IRubyObject type = ((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getClass("Name").getConstant("OBJECT_TYPE_TEMPLATE").callMethod(getRuntime().getCurrentContext(),"[]",args[0]);
         if(args.length > 2 && !args[2].isNil()) {
             type = args[2];
         }
 
         DERObjectIdentifier oid_v;
         try {
             oid_v = getObjectIdentifier(oid);
         } catch(IllegalArgumentException e) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("NameError")), "invalid field name", true);
         }
         if(null == oid_v) {
             throw new RaiseException(getRuntime(), (RubyClass)(((RubyModule)(getRuntime().getModule("OpenSSL").getConstant("X509"))).getConstant("NameError")), null, true);
         }
         oids.add(oid_v);
         values.add(value);
         types.add(type);
 
         return this;
     }
 
     public IRubyObject _to_s(IRubyObject[] args) {
         /*
 Should follow parameters like this: 
 if 0 (COMPAT):
 irb(main):025:0> x.to_s(OpenSSL::X509::Name::COMPAT)
 => "CN=ola.bini, O=sweden/streetAddress=sweden, O=sweden/2.5.4.43343=sweden"
 irb(main):026:0> x.to_s(OpenSSL::X509::Name::ONELINE)
 => "CN = ola.bini, O = sweden, streetAddress = sweden, O = sweden, 2.5.4.43343 = sweden"
 irb(main):027:0> x.to_s(OpenSSL::X509::Name::MULTILINE)
 => "commonName                = ola.bini\norganizationName          = sweden\nstreetAddress             = sweden\norganizationName          = sweden\n2.5.4.43343 = sweden"
 irb(main):028:0> x.to_s(OpenSSL::X509::Name::RFC2253)
 => "2.5.4.43343=#0C0673776564656E,O=sweden,streetAddress=sweden,O=sweden,CN=ola.bini"
 else
 => /CN=ola.bini/O=sweden/streetAddress=sweden/O=sweden/2.5.4.43343=sweden
 
          */
 
         int flag = -1;
         if(args.length > 0 && !args[0].isNil()) {
             flag = RubyNumeric.fix2int(args[0]);
         }
 
         StringBuffer sb = new StringBuffer();
         Map lookup = ASN1.getSymLookup(getRuntime());
         Iterator oiter = null;
         Iterator viter = null;
         if(flag == RFC2253) {
             List ao = new ArrayList(oids);
             List av = new ArrayList(values);
             java.util.Collections.reverse(ao);
             java.util.Collections.reverse(av);
             oiter = ao.iterator();
             viter = av.iterator();
         } else {
             oiter = oids.iterator();
             viter = values.iterator();
         }
 
         String sep = "";
         for(;oiter.hasNext();) {
             DERObjectIdentifier oid = (DERObjectIdentifier)oiter.next();
             String val = (String)viter.next();
             String outOid = (String)lookup.get(oid);
             if(null == outOid) {
                 outOid = oid.toString();
             }
             if(flag == RFC2253) {
                 sb.append(sep).append(outOid).append("=").append(val);
                 sep = ",";
             } else {
                 sb.append("/").append(outOid).append("=").append(val);
             }
         }
         return getRuntime().newString(sb.toString());
     }
 
     public IRubyObject to_a() {
         List entries = new ArrayList();
         Map lookup = ASN1.getSymLookup(getRuntime());
         Iterator oiter = oids.iterator();
         Iterator viter = values.iterator();
         Iterator titer = types.iterator();
         for(;oiter.hasNext();) {
             DERObjectIdentifier oid = (DERObjectIdentifier)oiter.next();
             String val = (String)viter.next();
             String outOid = (String)lookup.get(oid);
             if(null == outOid) {
                 outOid = "UNDEF";
             }
             IRubyObject type = (IRubyObject)titer.next();
             entries.add(getRuntime().newArray(new IRubyObject[]{getRuntime().newString(outOid),getRuntime().newString(val),type}));
         }
         return getRuntime().newArray(entries);
     }
 
     public IRubyObject cmp(IRubyObject other) {
         if(eql_p(other).isTrue()) {
             return RubyFixnum.zero(getRuntime());
         }
 
         return RubyFixnum.one(getRuntime());
     }
 
     org.bouncycastle.asn1.x509.X509Name getRealName() {
         return new org.bouncycastle.asn1.x509.X509Name(new Vector(oids),new Vector(values));
     }
 
     public IRubyObject eql_p(IRubyObject other) {
         if(!(other instanceof X509Name)) {
             return getRuntime().getFalse();
         }
         X509Name o = (X509Name)other;
         org.bouncycastle.asn1.x509.X509Name nm = new org.bouncycastle.asn1.x509.X509Name(new Vector(oids),new Vector(values));
         org.bouncycastle.asn1.x509.X509Name o_nm = new org.bouncycastle.asn1.x509.X509Name(new Vector(o.oids),new Vector(o.values));
         return nm.equals(o_nm) ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public RubyFixnum hash() {
         return getRuntime().newFixnum(new org.bouncycastle.asn1.x509.X509Name(new Vector(oids),new Vector(values)).hashCode());
     }
 
     public IRubyObject to_der() throws Exception {
         DERSequence seq = null;
         if(oids.size()>0) {
             ASN1EncodableVector  vec = new ASN1EncodableVector();
             ASN1EncodableVector  sVec = new ASN1EncodableVector();
             DERObjectIdentifier  lstOid = null;
             for (int i = 0; i != oids.size(); i++) {
                 ASN1EncodableVector     v = new ASN1EncodableVector();
                 DERObjectIdentifier     oid = (DERObjectIdentifier)oids.get(i);
                 v.add(oid);
                 String  str = (String)values.get(i);
                 v.add(convert(oid,str,RubyNumeric.fix2int(((RubyFixnum)types.get(i)))));
  
                 if (lstOid == null) {
                     sVec.add(new DERSequence(v));
                 } else {
                     vec.add(new DERSet(sVec));
                     sVec = new ASN1EncodableVector();
                     sVec.add(new DERSequence(v));
                 }
                 lstOid = oid;
             }
             vec.add(new DERSet(sVec));
             seq = new DERSequence(vec);
         } else {
             seq = new DERSequence();
         }
 
         return getRuntime().newString(new String(seq.getDEREncoded(),"ISO8859_1"));
     }
 
     private DERObject convert(DERObjectIdentifier oid, String value, int type) throws Exception {
         Class clzz = ASN1.classForId(type);
         if(clzz != null) {
             java.lang.reflect.Constructor ctor = clzz.getConstructor(new Class[]{String.class});
             if(null != ctor) {
                 return (DERObject)ctor.newInstance(new Object[]{value});
             }
         }
         return new X509DefaultEntryConverter().getConvertedValue(oid, value);
     }
 }// X509Name
diff --git a/src/org/jruby/ext/openssl/X509Revoked.java b/src/org/jruby/ext/openssl/X509Revoked.java
index 5f3babc41b..a2be6bba8e 100644
--- a/src/org/jruby/ext/openssl/X509Revoked.java
+++ b/src/org/jruby/ext/openssl/X509Revoked.java
@@ -1,110 +1,111 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509Revoked extends RubyObject {
+    private static ObjectAllocator X509REVOKED_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509Revoked(runtime, klass);
+        }
+    };
+    
     public static void createX509Revoked(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509Rev = mX509.defineClassUnder("Revoked",runtime.getObject());
-        mX509.defineClassUnder("RevokedError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509Rev = mX509.defineClassUnder("Revoked",runtime.getObject(),X509REVOKED_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("RevokedError",openSSLError,openSSLError.getAllocator());
 
         CallbackFactory revcb = runtime.callbackFactory(X509Revoked.class);
 
-        cX509Rev.defineSingletonMethod("new",revcb.getOptSingletonMethod("newInstance"));
         cX509Rev.defineMethod("initialize",revcb.getOptMethod("_initialize"));
         cX509Rev.defineMethod("serial",revcb.getMethod("serial"));
         cX509Rev.defineMethod("serial=",revcb.getMethod("set_serial",IRubyObject.class));
         cX509Rev.defineMethod("time",revcb.getMethod("time"));
         cX509Rev.defineMethod("time=",revcb.getMethod("set_time",IRubyObject.class));
         cX509Rev.defineMethod("extensions",revcb.getMethod("extensions"));
         cX509Rev.defineMethod("extensions=",revcb.getMethod("set_extensions",IRubyObject.class));
         cX509Rev.defineMethod("add_extension",revcb.getMethod("add_extension",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        IRubyObject result = new X509Revoked(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private IRubyObject serial;
     private IRubyObject extensions;
     private IRubyObject time;
 
     public X509Revoked(IRuby runtime, RubyClass type) {
         super(runtime,type);
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         serial = getRuntime().getNil();
         time = getRuntime().getNil();
         extensions = getRuntime().newArray();
         return this;
     }
 
     public IRubyObject serial() {
         return this.serial;
     }
 
     public IRubyObject set_serial(IRubyObject val) {
         this.serial = val;
         return val;
     }
 
     public IRubyObject time() {
         return this.time;
     }
 
     public IRubyObject set_time(IRubyObject val) {
         this.time = val;
         return val;
     }
 
     public IRubyObject extensions() {
         return this.extensions;
     }
 
     public IRubyObject set_extensions(IRubyObject val) {
         this.extensions = val;
         return val;
     }
 
     public IRubyObject add_extension(IRubyObject val) {
         this.extensions.callMethod(getRuntime().getCurrentContext(),"<<",val);
         return val;
     }
 }// X509Revoked
diff --git a/src/org/jruby/ext/openssl/X509Store.java b/src/org/jruby/ext/openssl/X509Store.java
index 589cb89c92..4ec8f7a09d 100644
--- a/src/org/jruby/ext/openssl/X509Store.java
+++ b/src/org/jruby/ext/openssl/X509Store.java
@@ -1,237 +1,238 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyObject;
 import org.jruby.RubyProc;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.Function2;
 import org.jruby.ext.openssl.x509store.X509AuxCertificate;
 import org.jruby.ext.openssl.x509store.X509_STORE;
 import org.jruby.ext.openssl.x509store.X509_STORE_CTX;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509Store extends RubyObject {
+    private static ObjectAllocator X509STORE_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509Store(runtime, klass);
+        }
+    };
+    
     public static void createX509Store(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509Store = mX509.defineClassUnder("Store",runtime.getObject());
-        mX509.defineClassUnder("StoreError",runtime.getModule("OpenSSL").getClass("OpenSSLError"));
+        RubyClass cX509Store = mX509.defineClassUnder("Store",runtime.getObject(),X509STORE_ALLOCATOR);
+        RubyClass openSSLError = runtime.getModule("OpenSSL").getClass("OpenSSLError");
+        mX509.defineClassUnder("StoreError",openSSLError,openSSLError.getAllocator());
         cX509Store.attr_accessor(new IRubyObject[]{runtime.newSymbol("verify_callback"),runtime.newSymbol("error"),
                                                    runtime.newSymbol("error_string"),runtime.newSymbol("chain")});
 
         CallbackFactory storecb = runtime.callbackFactory(X509Store.class);
 
-        cX509Store.defineSingletonMethod("new",storecb.getOptSingletonMethod("newInstance"));
         cX509Store.defineMethod("initialize",storecb.getOptMethod("_initialize"));
         cX509Store.defineMethod("verify_callback=",storecb.getMethod("set_verify_callback",IRubyObject.class));
         cX509Store.defineMethod("flags=",storecb.getMethod("set_flags",IRubyObject.class));
         cX509Store.defineMethod("purpose=",storecb.getMethod("set_purpose",IRubyObject.class));
         cX509Store.defineMethod("trust=",storecb.getMethod("set_trust",IRubyObject.class));
         cX509Store.defineMethod("time=",storecb.getMethod("set_time",IRubyObject.class));
         cX509Store.defineMethod("add_path",storecb.getMethod("add_path",IRubyObject.class));
         cX509Store.defineMethod("add_file",storecb.getMethod("add_file",IRubyObject.class));
         cX509Store.defineMethod("set_default_paths",storecb.getMethod("set_default_paths"));
         cX509Store.defineMethod("add_cert",storecb.getMethod("add_cert",IRubyObject.class));
         cX509Store.defineMethod("add_crl",storecb.getMethod("add_crl",IRubyObject.class));
         cX509Store.defineMethod("verify",storecb.getOptMethod("verify"));
         
         X509StoreCtx.createX509StoreCtx(runtime, mX509);
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        IRubyObject result = new X509Store(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private RubyClass cStoreError;
     private RubyClass cStoreContext;
 
     public X509Store(IRuby runtime, RubyClass type) {
         super(runtime,type);
         store = new X509_STORE();
         cStoreError = (RubyClass)(((RubyModule)(runtime.getModule("OpenSSL").getConstant("X509"))).getConstant("StoreError"));
         cStoreContext = (RubyClass)(((RubyModule)(runtime.getModule("OpenSSL").getConstant("X509"))).getConstant("StoreContext"));
     }
 
     private X509_STORE store;
 
     X509_STORE getStore() {
         return store;
     }
 
     private void raise(String msg) {
         throw new RaiseException(getRuntime(),cStoreError, msg, true);
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         store.set_verify_cb_func(ossl_verify_cb);
         this.set_verify_callback(getRuntime().getNil());
         this.setInstanceVariable("@flags",RubyFixnum.zero(getRuntime()));
         this.setInstanceVariable("@purpose",RubyFixnum.zero(getRuntime()));
         this.setInstanceVariable("@trust",RubyFixnum.zero(getRuntime()));
         
         this.setInstanceVariable("@error",getRuntime().getNil());
         this.setInstanceVariable("@error_string",getRuntime().getNil());
         this.setInstanceVariable("@chain",getRuntime().getNil());
         this.setInstanceVariable("@time",getRuntime().getNil());
         return this;
     }
 
     public IRubyObject set_verify_callback(IRubyObject cb) {
         store.set_ex_data(1, cb);
         this.setInstanceVariable("@verify_callback", cb);
         return cb;
     }
 
     public IRubyObject set_flags(IRubyObject arg) {
         store.set_flags(RubyNumeric.fix2long(arg));
         return arg;
     }
 
     public IRubyObject set_purpose(IRubyObject arg) throws Exception {
         store.set_purpose(RubyNumeric.fix2int(arg));
         return arg;
     }
 
     public IRubyObject set_trust(IRubyObject arg) {
         store.set_trust(RubyNumeric.fix2int(arg));
         return arg;
     }
 
     public IRubyObject set_time(IRubyObject arg) {
         setInstanceVariable("@time",arg);
         return arg;
     }
 
     public IRubyObject add_path(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: Store#add_path");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_file(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: Store#add_file");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_default_paths() {
         System.err.println("WARNING: unimplemented method called: Store#set_default_paths");
         return getRuntime().getNil();
     }
 
     public IRubyObject add_cert(IRubyObject _cert) {
         X509AuxCertificate cert = (_cert instanceof X509Cert) ? ((X509Cert)_cert).getAuxCert() : (X509AuxCertificate)null;
         if(store.add_cert(cert) != 1) {
             raise(null);
         }
         return this;
     }
 
     public IRubyObject add_crl(IRubyObject arg) {
         java.security.cert.X509CRL crl = (arg instanceof X509CRL) ? ((X509CRL)arg).getCRL() : null;
         if(store.add_crl(crl) != 1) {
             raise(null);
         }
         return this;
     }
 
     public IRubyObject verify(IRubyObject[] args) throws Exception {
         IRubyObject cert, chain;
         if(checkArgumentCount(args,1,2) == 2) {
             chain = args[1];
         } else {
             chain = getRuntime().getNil();
         }
         cert = args[0];
         IRubyObject proc, result;
         X509StoreCtx ctx = (X509StoreCtx)cStoreContext.callMethod(getRuntime().getCurrentContext(),"new",new IRubyObject[]{this,cert,chain});
         if(getRuntime().getCurrentContext().isBlockGiven()) {
             proc = RubyProc.newProc(getRuntime(),false);
         } else {
             proc = getInstanceVariable("@verify_callback");
         }
         ctx.setInstanceVariable("@verify_callback",proc);
         result = ctx.callMethod(getRuntime().getCurrentContext(),"verify");
         this.setInstanceVariable("@error",ctx.error());
         this.setInstanceVariable("@error_string",ctx.error_string());
         this.setInstanceVariable("@chain",ctx.chain());
         return result;
     }
 
     private final static Function2 ossl_verify_cb = new Function2() {
             public int call(Object a1, Object a2) throws Exception {
                 X509_STORE_CTX ctx = (X509_STORE_CTX)a2;
                 int ok = ((Integer)a1).intValue();
                 IRubyObject proc = (IRubyObject)ctx.get_ex_data(1);
                 if(null == proc) {
                     proc = (IRubyObject)ctx.ctx.get_ex_data(0);
                 }
                 if(null == proc) {
                     return ok;
                 }
                 if(!proc.isNil()) {
                     System.err.println("WARNING: unimplemented method called: ossl_verify_cb");
                     System.err.println("GOJS");
                 }
 
                 /*
     if (!NIL_P(proc)) {
 	rctx = rb_protect((VALUE(*)(VALUE))ossl_x509stctx_new,
 			  (VALUE)ctx, &state);
 	ret = Qfalse;
 	if (!state) {
 	    args.proc = proc;
 	    args.preverify_ok = ok ? Qtrue : Qfalse;
 	    args.store_ctx = rctx;
 	    ret = rb_ensure(ossl_call_verify_cb_proc, (VALUE)&args,
 			    ossl_x509stctx_clear_ptr, rctx);
 	}
 	if (ret == Qtrue) {
 	    X509_STORE_CTX_set_error(ctx, X509_V_OK);
 	    ok = 1;
 	}
 	else{
 	    if (X509_STORE_CTX_get_error(ctx) == X509_V_OK) {
 		X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REJECTED);
 	    }
 	    ok = 0;
 	}
     }
                 */
                 return ok;
             }
         };
 }// X509Store
diff --git a/src/org/jruby/ext/openssl/X509StoreCtx.java b/src/org/jruby/ext/openssl/X509StoreCtx.java
index aa5f3a29b0..f54f66538b 100644
--- a/src/org/jruby/ext/openssl/X509StoreCtx.java
+++ b/src/org/jruby/ext/openssl/X509StoreCtx.java
@@ -1,201 +1,201 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2006 Ola Bini <ola@ologix.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.ext.openssl;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.RubyTime;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.ext.openssl.x509store.X509AuxCertificate;
 import org.jruby.ext.openssl.x509store.X509_STORE;
 import org.jruby.ext.openssl.x509store.X509_STORE_CTX;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  * @author <a href="mailto:ola.bini@ki.se">Ola Bini</a>
  */
 public class X509StoreCtx extends RubyObject {
+    private static ObjectAllocator X509STORECTX_ALLOCATOR = new ObjectAllocator() {
+        public IRubyObject allocate(IRuby runtime, RubyClass klass) {
+            return new X509StoreCtx(runtime, klass);
+        }
+    };
+    
     public static void createX509StoreCtx(IRuby runtime, RubyModule mX509) {
-        RubyClass cX509StoreContext = mX509.defineClassUnder("StoreContext",runtime.getObject());
+        RubyClass cX509StoreContext = mX509.defineClassUnder("StoreContext",runtime.getObject(),X509STORECTX_ALLOCATOR);
         CallbackFactory storectxcb = runtime.callbackFactory(X509StoreCtx.class);
-        cX509StoreContext.defineSingletonMethod("new",storectxcb.getOptSingletonMethod("newInstance"));
         cX509StoreContext.defineMethod("initialize",storectxcb.getOptMethod("_initialize"));
         cX509StoreContext.defineMethod("verify",storectxcb.getMethod("verify"));
         cX509StoreContext.defineMethod("chain",storectxcb.getMethod("chain"));
         cX509StoreContext.defineMethod("error",storectxcb.getMethod("error"));
         cX509StoreContext.defineMethod("error=",storectxcb.getMethod("set_error",IRubyObject.class));
         cX509StoreContext.defineMethod("error_string",storectxcb.getMethod("error_string"));
         cX509StoreContext.defineMethod("error_depth",storectxcb.getMethod("error_depth"));
         cX509StoreContext.defineMethod("current_cert",storectxcb.getMethod("current_cert"));
         cX509StoreContext.defineMethod("current_crl",storectxcb.getMethod("current_crl"));
         cX509StoreContext.defineMethod("cleanup",storectxcb.getMethod("cleanup"));
         cX509StoreContext.defineMethod("flags=",storectxcb.getMethod("set_flags",IRubyObject.class));
         cX509StoreContext.defineMethod("purpose=",storectxcb.getMethod("set_purpose",IRubyObject.class));
         cX509StoreContext.defineMethod("trust=",storectxcb.getMethod("set_trust",IRubyObject.class));
         cX509StoreContext.defineMethod("time=",storectxcb.getMethod("set_time",IRubyObject.class));
     }
 
-    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
-        IRubyObject result = new X509StoreCtx(recv.getRuntime(), (RubyClass)recv);
-        result.callInit(args);
-        return result;
-    }
-
     private X509_STORE_CTX ctx;
     private RubyClass cStoreError;
     private RubyClass cX509Cert;
 
     public X509StoreCtx(IRuby runtime, RubyClass type) {
         super(runtime,type);
         ctx = new X509_STORE_CTX();
         cStoreError = (RubyClass)(((RubyModule)(runtime.getModule("OpenSSL").getConstant("X509"))).getConstant("StoreError")); 
         cX509Cert = (RubyClass)(((RubyModule)(runtime.getModule("OpenSSL").getConstant("X509"))).getConstant("Certificate"));
    }
 
     private void raise(String msg) {
         throw new RaiseException(getRuntime(),cStoreError, msg, true);
     }
 
     public IRubyObject _initialize(IRubyObject[] args) throws Exception {
         IRubyObject store;
         IRubyObject cert = getRuntime().getNil();
         IRubyObject chain = getRuntime().getNil();
         X509_STORE x509st;
         X509AuxCertificate x509 = null;
         List x509s = new ArrayList();
 
         if(checkArgumentCount(args,1,3) > 1) {
             cert = args[1];
         }
         if(args.length > 2) {
             chain = args[2];
         }
         store = args[0];
         x509st = ((X509Store)store).getStore();
         if(!cert.isNil()) {
             x509 = ((X509Cert)cert).getAuxCert();
         }
         if(!chain.isNil()) {
             x509s = new ArrayList();
             for(Iterator iter = ((RubyArray)chain).getList().iterator();iter.hasNext();) {
                 x509s.add(((X509Cert)iter.next()).getAuxCert());
             }
         }
         if(ctx.init(x509st,x509,x509s) != 1) {
             raise(null);
         }
         IRubyObject t = store.getInstanceVariable("@time");
         if(!t.isNil()) {
             set_time(t);
         }
         setInstanceVariable("@verify_callback",store.getInstanceVariable("@verify_callback"));
         setInstanceVariable("@cert",cert);
         return this;
     }
 
     public IRubyObject verify() throws Exception {
         ctx.set_ex_data(1,getInstanceVariable("@verify_callback"));
         int result = ctx.verify_cert();
         return result != 0 ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public IRubyObject chain() throws Exception {
         List chain = ctx.get_chain();
         if(chain == null) {
             return getRuntime().getNil();
         }
         List ary = new ArrayList();
         for(Iterator iter = chain.iterator();iter.hasNext();) {
             X509AuxCertificate x509 = (X509AuxCertificate)iter.next();
             ary.add(cX509Cert.callMethod(getRuntime().getCurrentContext(),"new",getRuntime().newString(new String(x509.getEncoded(),"ISO8859_1"))));
         }
         return getRuntime().newArray(ary);
    }
 
     public IRubyObject error() {
         return getRuntime().newFixnum(ctx.get_error());
     }
 
     public IRubyObject set_error(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: StoreContext#set_error");
         return getRuntime().getNil();
     }
 
     public IRubyObject error_string() {
         int err = ctx.get_error();
         return getRuntime().newString(org.jruby.ext.openssl.x509store.X509.verify_cert_error_string(err));
     }
 
     public IRubyObject error_depth() {
         System.err.println("WARNING: unimplemented method called: StoreContext#error_depth");
         return getRuntime().getNil();
     }
 
     public IRubyObject current_cert() {
         System.err.println("WARNING: unimplemented method called: StoreContext#current_cert");
         return getRuntime().getNil();
     }
 
     public IRubyObject current_crl() {
         System.err.println("WARNING: unimplemented method called: StoreContext#current_crl");
         return getRuntime().getNil();
     }
 
     public IRubyObject cleanup() {
         System.err.println("WARNING: unimplemented method called: StoreContext#cleanup");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_flags(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: StoreContext#set_flags");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_purpose(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: StoreContext#set_purpose");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_trust(IRubyObject arg) {
         System.err.println("WARNING: unimplemented method called: StoreContext#set_trust");
         return getRuntime().getNil();
     }
 
     public IRubyObject set_time(IRubyObject arg) {
         ctx.set_time(0,((RubyTime)arg).getJavaDate());
         return arg;
     }
 }// X509StoreCtx
diff --git a/src/org/jruby/javasupport/JavaArray.java b/src/org/jruby/javasupport/JavaArray.java
index b236ad4ba3..475b4c7893 100644
--- a/src/org/jruby/javasupport/JavaArray.java
+++ b/src/org/jruby/javasupport/JavaArray.java
@@ -1,100 +1,103 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import java.lang.reflect.Array;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyInteger;
 import org.jruby.RubyModule;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class JavaArray extends JavaObject {
 
     public JavaArray(IRuby runtime, Object array) {
         super(runtime, runtime.getModule("Java").getClass("JavaArray"), array);
         assert array.getClass().isArray();
     }
 
     public static RubyClass createJavaArrayClass(IRuby runtime, RubyModule javaModule) {
-        return javaModule.defineClassUnder("JavaArray", javaModule.getClass("JavaObject"));
+        // FIXME: NOT_ALLOCATABLE_ALLOCATOR is probably not right here, since we might
+        // eventually want JavaArray to be marshallable. JRUBY-414
+        return javaModule.defineClassUnder("JavaArray", javaModule.getClass("JavaObject"), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
     }
 
     public RubyFixnum length() {
         return getRuntime().newFixnum(getLength());
     }
 
     private int getLength() {
         return Array.getLength(getValue());
     }
 
     public IRubyObject aref(IRubyObject index) {
         if (! (index instanceof RubyInteger)) {
             throw getRuntime().newTypeError(index, getRuntime().getClass("Integer"));
         }
         int intIndex = (int) ((RubyInteger) index).getLongValue();
         if (intIndex < 0 || intIndex >= getLength()) {
             throw getRuntime().newArgumentError(
                                     "index out of bounds for java array (" + intIndex +
                                     " for length " + getLength() + ")");
         }
         Object result = Array.get(getValue(), intIndex);
         if (result == null) {
             return getRuntime().getNil();
         }
         return JavaObject.wrap(getRuntime(), result);
     }
 
     public IRubyObject aset(IRubyObject index, IRubyObject value) {
          if (! (index instanceof RubyInteger)) {
             throw getRuntime().newTypeError(index, getRuntime().getClass("Integer"));
         }
         int intIndex = (int) ((RubyInteger) index).getLongValue();
         if (! (value instanceof JavaObject)) {
             throw getRuntime().newTypeError("not a java object:" + value);
         }
         Object javaObject = ((JavaObject) value).getValue();
         try {
             Array.set(getValue(), intIndex, javaObject);
         } catch (IndexOutOfBoundsException e) {
             throw getRuntime().newArgumentError(
                                     "index out of bounds for java array (" + intIndex +
                                     " for length " + getLength() + ")");
         } catch (ArrayStoreException e) {
             throw getRuntime().newArgumentError(
                                     "wrong element type " + javaObject.getClass() + "(array is " +
                                     getValue().getClass() + ")");
         }
         return value;
     }
 }
diff --git a/src/org/jruby/javasupport/JavaClass.java b/src/org/jruby/javasupport/JavaClass.java
index f9f95f3ace..949f9f5451 100644
--- a/src/org/jruby/javasupport/JavaClass.java
+++ b/src/org/jruby/javasupport/JavaClass.java
@@ -1,586 +1,592 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004-2005 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 David Corbin <dcorbin@users.sourceforge.net>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import java.beans.BeanInfo;
 import java.beans.IntrospectionException;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyBoolean;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyInteger;
 import org.jruby.RubyModule;
 import org.jruby.RubyString;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.runtime.Arity;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.callback.Callback;
 
 public class JavaClass extends JavaObject {
 
     private JavaClass(IRuby runtime, Class javaClass) {
         super(runtime, (RubyClass) runtime.getModule("Java").getClass("JavaClass"), javaClass);
     }
     
     public static synchronized JavaClass get(IRuby runtime, Class klass) {
         JavaClass javaClass = runtime.getJavaSupport().getJavaClassFromCache(klass);
         if (javaClass == null) {
             javaClass = new JavaClass(runtime, klass);
             runtime.getJavaSupport().putJavaClassIntoCache(javaClass);
         }
         return javaClass;
     }
 
     public static RubyClass createJavaClassClass(IRuby runtime, RubyModule javaModule) {
-        RubyClass result = javaModule.defineClassUnder("JavaClass", javaModule.getClass("JavaObject")); 
+        // FIXME: Determine if a real allocator is needed here. Do people want to extend
+        // JavaClass? Do we want them to do that? Can you Class.new(JavaClass)? Should
+        // you be able to?
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here, since we don't intend for people to monkey with
+        // this type and it can't be marshalled. Confirm. JRUBY-415
+        RubyClass result = javaModule.defineClassUnder("JavaClass", javaModule.getClass("JavaObject"), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR); 
 
     	CallbackFactory callbackFactory = runtime.callbackFactory(JavaClass.class);
         
         result.includeModule(runtime.getModule("Comparable"));
         
         JavaObject.registerRubyMethods(runtime, result);
         
         result.defineSingletonMethod("for_name", 
                 callbackFactory.getSingletonMethod("for_name", IRubyObject.class));
         result.defineMethod("public?", 
                 callbackFactory.getMethod("public_p"));
         result.defineMethod("protected?", 
                 callbackFactory.getMethod("protected_p"));
         result.defineMethod("private?", 
                 callbackFactory.getMethod("private_p"));
         result.defineMethod("final?", 
                 callbackFactory.getMethod("final_p"));
         result.defineMethod("interface?", 
                 callbackFactory.getMethod("interface_p"));
         result.defineMethod("array?", 
                 callbackFactory.getMethod("array_p"));
         result.defineMethod("name", 
                 callbackFactory.getMethod("name"));
         result.defineMethod("to_s", 
                 callbackFactory.getMethod("name"));
         result.defineMethod("superclass", 
                 callbackFactory.getMethod("superclass"));
         result.defineMethod("<=>", 
                 callbackFactory.getMethod("op_cmp", IRubyObject.class));
         result.defineMethod("java_instance_methods", 
                 callbackFactory.getMethod("java_instance_methods"));
         result.defineMethod("java_class_methods", 
                 callbackFactory.getMethod("java_class_methods"));
         result.defineMethod("java_method", 
                 callbackFactory.getOptMethod("java_method"));
         result.defineMethod("constructors", 
                 callbackFactory.getMethod("constructors"));
         result.defineMethod("constructor", 
                 callbackFactory.getOptMethod("constructor"));
         result.defineMethod("array_class", 
                 callbackFactory.getMethod("array_class"));
         result.defineMethod("new_array", 
                 callbackFactory.getMethod("new_array", IRubyObject.class));
         result.defineMethod("fields", 
                 callbackFactory.getMethod("fields"));
         result.defineMethod("field", 
                 callbackFactory.getMethod("field", IRubyObject.class));
         result.defineMethod("interfaces", 
                 callbackFactory.getMethod("interfaces"));
         result.defineMethod("primitive?", 
                 callbackFactory.getMethod("primitive_p"));
         result.defineMethod("assignable_from?", 
                 callbackFactory.getMethod("assignable_from_p", IRubyObject.class));
         result.defineMethod("component_type", 
                 callbackFactory.getMethod("component_type"));
 		result.defineMethod("declared_instance_methods", 
                 callbackFactory.getMethod("declared_instance_methods"));
         result.defineMethod("declared_class_methods", 
                 callbackFactory.getMethod("declared_class_methods"));
         result.defineMethod("declared_fields", 
                 callbackFactory.getMethod("declared_fields"));
         result.defineMethod("declared_field", 
                 callbackFactory.getMethod("declared_field", IRubyObject.class));
         result.defineMethod("declared_constructors", 
                 callbackFactory.getMethod("declared_constructors"));
         result.defineMethod("declared_constructor", 
                 callbackFactory.getOptMethod("declared_constructor"));
         result.defineMethod("declared_method", 
                 callbackFactory.getOptMethod("declared_method"));
         result.defineMethod("define_instance_methods_for_proxy", 
                 callbackFactory.getMethod("define_instance_methods_for_proxy", IRubyObject.class));
         
         result.getMetaClass().undefineMethod("new");
 
         return result;
     }
     
     public static synchronized JavaClass for_name(IRubyObject recv, IRubyObject name) {
         String className = name.asSymbol();
         Class klass = recv.getRuntime().getJavaSupport().loadJavaClass(className);
         return JavaClass.get(recv.getRuntime(), klass);
     }
     
     /**
      *  Get all methods grouped by name (e.g. 'new => {new(), new(int), new(int, int)}, ...')
      *  @param isStatic determines whether you want static or instance methods from the class
      */
     private Map getMethodsClumped(boolean isStatic) {
         Map map = new HashMap();
         if(((Class)getValue()).isInterface()) {
             return map;
         }
 
         Method methods[] = javaClass().getMethods();
         
         for (int i = 0; i < methods.length; i++) {
             if (isStatic != Modifier.isStatic(methods[i].getModifiers())) {
                 continue;
             }
             
             String key = methods[i].getName();
             RubyArray methodsWithName = (RubyArray) map.get(key); 
             
             if (methodsWithName == null) {
                 methodsWithName = getRuntime().newArray();
                 map.put(key, methodsWithName);
             }
             
             methodsWithName.append(JavaMethod.create(getRuntime(), methods[i]));
         }
         
         return map;
     }
     
     private Map getPropertysClumped() {
         Map map = new HashMap();
         BeanInfo info;
         
         try {
             info = Introspector.getBeanInfo(javaClass());
         } catch (IntrospectionException e) {
             return map;
         }
         
         PropertyDescriptor[] descriptors = info.getPropertyDescriptors();
         
         for (int i = 0; i < descriptors.length; i++) {
             Method readMethod = descriptors[i].getReadMethod();
             
             if (readMethod != null) {
                 String key = readMethod.getName();
                 List aliases = (List) map.get(key);
                 
                 if (aliases == null) {
                     aliases = new ArrayList();
                     
                     map.put(key, aliases);    
                 }
 
                 if (readMethod.getReturnType() == Boolean.class ||
                     readMethod.getReturnType() == boolean.class) {
                     aliases.add(descriptors[i].getName() + "?");
                 }
                 aliases.add(descriptors[i].getName());
             }
             
             Method writeMethod = descriptors[i].getWriteMethod();
 
             if (writeMethod != null) {
                 String key = writeMethod.getName();
                 List aliases = (List) map.get(key);
                 
                 if (aliases == null) {
                     aliases = new ArrayList();
                     map.put(key, aliases);
                 }
                 
                 aliases.add(descriptors[i].getName()  + "=");
             }
         }
         
         return map;
     }
     
     private void define_instance_method_for_proxy(final RubyClass proxy, List names, 
             final RubyArray methods) {
         final RubyModule javaUtilities = getRuntime().getModule("JavaUtilities");
         Callback method = new Callback() {
             public IRubyObject execute(IRubyObject self, IRubyObject[] args) {
                 IRubyObject[] argsArray = new IRubyObject[args.length + 1];
                 ThreadContext context = self.getRuntime().getCurrentContext();
                 
                 argsArray[0] = self.callMethod(context, "java_object");
                 RubyArray argsAsArray = getRuntime().newArray();
                 for (int j = 0; j < args.length; j++) {
                     argsArray[j+1] = Java.ruby_to_java(proxy, args[j]);
                     argsAsArray.append(argsArray[j+1]);
                 }
 
                 IRubyObject[] mmArgs = new IRubyObject[] {methods, argsAsArray};
                 IRubyObject result = javaUtilities.callMethod(context, "matching_method", mmArgs);
                 return Java.java_to_ruby(self, result.callMethod(context, "invoke", argsArray));
             }
 
             public Arity getArity() {
                 return Arity.optional();
             }
         };
         
         for(Iterator iter = names.iterator(); iter.hasNext(); ) {
             String methodName = (String) iter.next();
             
             // We do not override class since it is too important to be overridden by getClass
             // short name.
             if (!methodName.equals("class")) {
                 proxy.defineMethod(methodName, method);
                 
                 String rubyCasedName = getRubyCasedName(methodName);
                 if (rubyCasedName != null) {
                     proxy.defineAlias(rubyCasedName, methodName);
                 }
             }
         }
     }
     
     private static final Pattern CAMEL_CASE_SPLITTER = Pattern.compile("([a-z])([A-Z])");
     
     private String getRubyCasedName(String javaCasedName) {
         Matcher m = CAMEL_CASE_SPLITTER.matcher(javaCasedName);
 
         String rubyCasedName = m.replaceAll("$1_$2").toLowerCase();
         
         if (rubyCasedName.equals(javaCasedName)) {
             return null;
         }
         
         return rubyCasedName;
     }
     
     public IRubyObject define_instance_methods_for_proxy(IRubyObject arg) {
         assert arg instanceof RubyClass;
         
         Map aliasesClump = getPropertysClumped();
         Map methodsClump = getMethodsClumped(false);
         RubyClass proxy = (RubyClass) arg;
         
         for (Iterator iter = methodsClump.keySet().iterator(); iter.hasNext(); ) {
             String name = (String) iter.next();
             RubyArray methods = (RubyArray) methodsClump.get(name);
             List aliases = (List) aliasesClump.get(name);
 
             if (aliases == null) {
                 aliases = new ArrayList();
             }
 
             aliases.add(name);
             
             define_instance_method_for_proxy(proxy, aliases, methods);
         }
         
         return getRuntime().getNil();
     }
 
     public RubyBoolean public_p() {
         return getRuntime().newBoolean(Modifier.isPublic(javaClass().getModifiers()));
     }
 
     public RubyBoolean protected_p() {
         return getRuntime().newBoolean(Modifier.isProtected(javaClass().getModifiers()));
     }
 
     public RubyBoolean private_p() {
         return getRuntime().newBoolean(Modifier.isPrivate(javaClass().getModifiers()));
     }
 
 	Class javaClass() {
 		return (Class) getValue();
 	}
 
     public RubyBoolean final_p() {
         return getRuntime().newBoolean(Modifier.isFinal(javaClass().getModifiers()));
     }
 
     public RubyBoolean interface_p() {
         return getRuntime().newBoolean(javaClass().isInterface());
     }
 
     public RubyBoolean array_p() {
         return getRuntime().newBoolean(javaClass().isArray());
     }
     
     public RubyString name() {
         return getRuntime().newString(javaClass().getName());
     }
 
     public IRubyObject superclass() {
         Class superclass = javaClass().getSuperclass();
         if (superclass == null) {
             return getRuntime().getNil();
         }
         return JavaClass.get(getRuntime(), superclass);
     }
 
     public RubyFixnum op_cmp(IRubyObject other) {
         if (! (other instanceof JavaClass)) {
             throw getRuntime().newTypeError("<=> requires JavaClass (" + other.getType() + " given)");
         }
         JavaClass otherClass = (JavaClass) other;
         if (this.javaClass() == otherClass.javaClass()) {
             return getRuntime().newFixnum(0);
         }
         if (otherClass.javaClass().isAssignableFrom(this.javaClass())) {
             return getRuntime().newFixnum(-1);
         }
         return getRuntime().newFixnum(1);
     }
 
     public RubyArray java_instance_methods() {
         return java_methods(javaClass().getMethods(), false);
     }
 
     public RubyArray declared_instance_methods() {
         return java_methods(javaClass().getDeclaredMethods(), false);
     }
 
 	private RubyArray java_methods(Method[] methods, boolean isStatic) {
         RubyArray result = getRuntime().newArray(methods.length);
         for (int i = 0; i < methods.length; i++) {
             Method method = methods[i];
             if (isStatic == Modifier.isStatic(method.getModifiers())) {
                 result.append(JavaMethod.create(getRuntime(), method));
             }
         }
         return result;
 	}
 
 	public RubyArray java_class_methods() {
 	    return java_methods(javaClass().getMethods(), true);
     }
 
 	public RubyArray declared_class_methods() {
 	    return java_methods(javaClass().getDeclaredMethods(), true);
     }
 
 	public JavaMethod java_method(IRubyObject[] args) throws ClassNotFoundException {
         String methodName = args[0].asSymbol();
         Class[] argumentTypes = buildArgumentTypes(args);
         return JavaMethod.create(getRuntime(), javaClass(), methodName, argumentTypes);
     }
 
     public JavaMethod declared_method(IRubyObject[] args) throws ClassNotFoundException {
         String methodName = args[0].asSymbol();
         Class[] argumentTypes = buildArgumentTypes(args);
         return JavaMethod.createDeclared(getRuntime(), javaClass(), methodName, argumentTypes);
     }
 
     private Class[] buildArgumentTypes(IRubyObject[] args) throws ClassNotFoundException {
         if (args.length < 1) {
             throw getRuntime().newArgumentError(args.length, 1);
         }
         Class[] argumentTypes = new Class[args.length - 1];
         for (int i = 1; i < args.length; i++) {
             JavaClass type = for_name(this, args[i]);
             argumentTypes[i - 1] = type.javaClass();
         }
         return argumentTypes;
     }
 
     public RubyArray constructors() {
         return buildConstructors(javaClass().getConstructors());
     }
 
     public RubyArray declared_constructors() {
         return buildConstructors(javaClass().getDeclaredConstructors());
     }
 
     private RubyArray buildConstructors(Constructor[] constructors) {
         RubyArray result = getRuntime().newArray(constructors.length);
         for (int i = 0; i < constructors.length; i++) {
             result.append(new JavaConstructor(getRuntime(), constructors[i]));
         }
         return result;
     }
 
     public JavaConstructor constructor(IRubyObject[] args) {
         try {
             Class[] parameterTypes = buildClassArgs(args);
             Constructor constructor;
             constructor = javaClass().getConstructor(parameterTypes);
             return new JavaConstructor(getRuntime(), constructor);
         } catch (NoSuchMethodException nsme) {
             throw getRuntime().newNameError("no matching java constructor", null);
         }
     }
 
     public JavaConstructor declared_constructor(IRubyObject[] args) {
         try {
             Class[] parameterTypes = buildClassArgs(args);
             Constructor constructor;
             constructor = javaClass().getDeclaredConstructor (parameterTypes);
             return new JavaConstructor(getRuntime(), constructor);
         } catch (NoSuchMethodException nsme) {
             throw getRuntime().newNameError("no matching java constructor", null);
         }
     }
 
     private Class[] buildClassArgs(IRubyObject[] args) {
         Class[] parameterTypes = new Class[args.length];
         for (int i = 0; i < args.length; i++) {
             String name = args[i].asSymbol();
             parameterTypes[i] = getRuntime().getJavaSupport().loadJavaClass(name);
         }
         return parameterTypes;
     }
 
     public JavaClass array_class() {
         return JavaClass.get(getRuntime(), Array.newInstance(javaClass(), 0).getClass());
     }
 
     public JavaObject new_array(IRubyObject lengthArgument) {
         if (! (lengthArgument instanceof RubyInteger)) {
             throw getRuntime().newTypeError(lengthArgument, getRuntime().getClass("Integer"));
         }
         int length = (int) ((RubyInteger) lengthArgument).getLongValue();
         return new JavaArray(getRuntime(), Array.newInstance(javaClass(), length));
     }
 
     public RubyArray fields() {
         return buildFieldResults(javaClass().getFields());
     }
 
     public RubyArray declared_fields() {
         return buildFieldResults(javaClass().getDeclaredFields());
     }
     
 	private RubyArray buildFieldResults(Field[] fields) {
         RubyArray result = getRuntime().newArray(fields.length);
         for (int i = 0; i < fields.length; i++) {
             result.append(new JavaField(getRuntime(), fields[i]));
         }
         return result;
 	}
 
 	public JavaField field(IRubyObject name) {
 		String stringName = name.asSymbol();
         try {
             Field field = javaClass().getField(stringName);
 			return new JavaField(getRuntime(),field);
         } catch (NoSuchFieldException nsfe) {
             throw undefinedFieldError(stringName);
         }
     }
 
 	public JavaField declared_field(IRubyObject name) {
 		String stringName = name.asSymbol();
         try {
             Field field = javaClass().getDeclaredField(stringName);
 			return new JavaField(getRuntime(),field);
         } catch (NoSuchFieldException nsfe) {
             throw undefinedFieldError(stringName);
         }
     }
 
     private RaiseException undefinedFieldError(String name) {
         return getRuntime().newNameError("undefined field '" + name + "' for class '" + javaClass().getName() + "'", name);
     }
 
     public RubyArray interfaces() {
         Class[] interfaces = javaClass().getInterfaces();
         RubyArray result = getRuntime().newArray(interfaces.length);
         for (int i = 0; i < interfaces.length; i++) {
             result.append(JavaClass.get(getRuntime(), interfaces[i]));
         }
         return result;
     }
 
     public RubyBoolean primitive_p() {
         return getRuntime().newBoolean(isPrimitive());
     }
 
     public RubyBoolean assignable_from_p(IRubyObject other) {
         if (! (other instanceof JavaClass)) {
             throw getRuntime().newTypeError("assignable_from requires JavaClass (" + other.getType() + " given)");
         }
 
         Class otherClass = ((JavaClass) other).javaClass();
 
         if (!javaClass().isPrimitive() && otherClass == Void.TYPE ||
             javaClass().isAssignableFrom(otherClass)) {
             return getRuntime().getTrue();
         }
         otherClass = JavaUtil.primitiveToWrapper(otherClass);
         Class thisJavaClass = JavaUtil.primitiveToWrapper(javaClass());
         if (thisJavaClass.isAssignableFrom(otherClass)) {
             return getRuntime().getTrue();
         }
         if (Number.class.isAssignableFrom(thisJavaClass)) {
             if (Number.class.isAssignableFrom(otherClass)) {
                 return getRuntime().getTrue();
             }
             if (otherClass.equals(Character.class)) {
                 return getRuntime().getTrue();
             }
         }
         if (thisJavaClass.equals(Character.class)) {
             if (Number.class.isAssignableFrom(otherClass)) {
                 return getRuntime().getTrue();
             }
         }
         return getRuntime().getFalse();
     }
 
     private boolean isPrimitive() {
         return javaClass().isPrimitive();
     }
 
     public JavaClass component_type() {
         if (! javaClass().isArray()) {
             throw getRuntime().newTypeError("not a java array-class");
         }
         return JavaClass.get(getRuntime(), javaClass().getComponentType());
     }
 }
diff --git a/src/org/jruby/javasupport/JavaConstructor.java b/src/org/jruby/javasupport/JavaConstructor.java
index ce1c7f841d..3087fe9186 100644
--- a/src/org/jruby/javasupport/JavaConstructor.java
+++ b/src/org/jruby/javasupport/JavaConstructor.java
@@ -1,121 +1,124 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 David Corbin <dcorbin@users.sourceforge.net>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class JavaConstructor extends JavaCallable {
     private Constructor constructor;
 
     public static RubyClass createJavaConstructorClass(IRuby runtime, RubyModule javaModule) {
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here, since we don't intend for people to monkey with
+        // this type and it can't be marshalled. Confirm. JRUBY-415
         RubyClass result =
-                javaModule.defineClassUnder("JavaConstructor", runtime.getObject());
+                javaModule.defineClassUnder("JavaConstructor", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(JavaConstructor.class);
 
         JavaCallable.registerRubyMethods(runtime, result, JavaConstructor.class);
         result.defineMethod("arity", 
                 callbackFactory.getMethod("arity"));
         result.defineMethod("inspect", 
                 callbackFactory.getMethod("inspect"));
         result.defineMethod("argument_types", 
                 callbackFactory.getMethod("argument_types"));
         result.defineMethod("new_instance", 
                 callbackFactory.getOptMethod("new_instance"));
         
         return result;
     }
 
     public JavaConstructor(IRuby runtime, Constructor constructor) {
         super(runtime, runtime.getModule("Java").getClass("JavaConstructor"));
         this.constructor = constructor;
     }
 
     public int getArity() {
         return constructor.getParameterTypes().length;
     }
 
     public IRubyObject new_instance(IRubyObject[] args) {
         if (args.length != getArity()) {
             throw getRuntime().newArgumentError(args.length, getArity());
         }
         Object[] constructorArguments = new Object[args.length];
         Class[] types = constructor.getParameterTypes();
         for (int i = 0; i < args.length; i++) {
             constructorArguments[i] = JavaUtil.convertArgument(args[i], types[i]);
         }
         try {
             Object result = constructor.newInstance(constructorArguments);
             return JavaObject.wrap(getRuntime(), result);
 
         } catch (IllegalArgumentException iae) {
             throw getRuntime().newTypeError("expected " + argument_types().inspect() +
                                               ", got [" + constructorArguments[0].getClass().getName() + ", ...]");
         } catch (IllegalAccessException iae) {
             throw getRuntime().newTypeError("illegal access");
         } catch (InvocationTargetException ite) {
             getRuntime().getJavaSupport().handleNativeException(ite.getTargetException());
             // not reached
             assert false;
             return null;
         } catch (InstantiationException ie) {
             throw getRuntime().newTypeError("can't make instance of " + constructor.getDeclaringClass().getName());
         }
     }
 
 
     protected String nameOnInspection() {
         return getType().toString();
     }
 
     protected Class[] parameterTypes() {
         return constructor.getParameterTypes();
     }
 
     protected int getModifiers() {
         return constructor.getModifiers();
     }
 
     protected AccessibleObject accesibleObject() {
         return constructor;
     }
 }
diff --git a/src/org/jruby/javasupport/JavaField.java b/src/org/jruby/javasupport/JavaField.java
index 82f67b7f67..ef762d2d2f 100644
--- a/src/org/jruby/javasupport/JavaField.java
+++ b/src/org/jruby/javasupport/JavaField.java
@@ -1,162 +1,165 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2002-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2004-2005 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 David Corbin <dcorbin@users.sourceforge.net>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
 import org.jruby.IRuby;
 import org.jruby.RubyBoolean;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyString;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class JavaField extends JavaAccessibleObject {
     private Field field;
 
     public static RubyClass createJavaFieldClass(IRuby runtime, RubyModule javaModule) {
-        RubyClass result = javaModule.defineClassUnder("JavaField", runtime.getObject());
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here, since we don't intend for people to monkey with
+        // this type and it can't be marshalled. Confirm. JRUBY-415
+        RubyClass result = javaModule.defineClassUnder("JavaField", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(JavaField.class);
 
         JavaAccessibleObject.registerRubyMethods(runtime, result);
         result.defineMethod("value_type", 
             callbackFactory.getMethod("value_type"));
         result.defineMethod("public?", 
             callbackFactory.getMethod("public_p"));
         result.defineMethod("static?", 
             callbackFactory.getMethod("static_p"));
         result.defineMethod("value", 
             callbackFactory.getMethod("value", IRubyObject.class));
         result.defineMethod("set_value", 
             callbackFactory.getMethod("set_value", IRubyObject.class, IRubyObject.class));
         result.defineMethod("final?", 
             callbackFactory.getMethod("final_p"));
         result.defineMethod("static_value", 
             callbackFactory.getMethod("static_value"));
         result.defineMethod("name", 
             callbackFactory.getMethod("name"));
         result.defineMethod("==", callbackFactory.getMethod("equal", IRubyObject.class));
         result.defineAlias("===", "==");
 
         return result;
     }
 
     public JavaField(IRuby runtime, Field field) {
         super(runtime, (RubyClass) runtime.getModule("Java").getClass("JavaField"));
         this.field = field;
     }
 
     public RubyString value_type() {
         return getRuntime().newString(field.getType().getName());
     }
 
     public IRubyObject equal(IRubyObject other) {
     	if (!(other instanceof JavaField)) {
     		return getRuntime().getFalse();
     	}
     	
         return getRuntime().newBoolean(field.equals(((JavaField) other).field));
     }
 
     public RubyBoolean public_p() {
         return getRuntime().newBoolean(Modifier.isPublic(field.getModifiers()));
     }
 
     public RubyBoolean static_p() {
         return getRuntime().newBoolean(Modifier.isStatic(field.getModifiers()));
     }
 
     public JavaObject value(IRubyObject object) {
         if (! (object instanceof JavaObject)) {
             throw getRuntime().newTypeError("not a java object");
         }
         Object javaObject = ((JavaObject) object).getValue();
         try {
             return JavaObject.wrap(getRuntime(), field.get(javaObject));
         } catch (IllegalAccessException iae) {
             throw getRuntime().newTypeError("illegal access");
         }
     }
 
     public JavaObject set_value(IRubyObject object, IRubyObject value) {
          if (! (object instanceof JavaObject)) {
             throw getRuntime().newTypeError("not a java object: " + object);
         }
         if (! (value instanceof JavaObject)) {
             throw getRuntime().newTypeError("not a java object:" + value);
         }
         Object javaObject = ((JavaObject) object).getValue();
         try {
             Object convertedValue = JavaUtil.convertArgument(((JavaObject) value).getValue(),
                                                              field.getType());
 
             field.set(javaObject, convertedValue);
         } catch (IllegalAccessException iae) {
             throw getRuntime().newTypeError(
                                 "illegal access on setting variable: " + iae.getMessage());
         } catch (IllegalArgumentException iae) {
             throw getRuntime().newTypeError(
                                 "wrong type for " + field.getType().getName() + ": " +
                                 ((JavaObject) value).getValue().getClass().getName());
         }
         return (JavaObject) value;
     }
 
     public RubyBoolean final_p() {
         return getRuntime().newBoolean(Modifier.isFinal(field.getModifiers()));
     }
 
     public JavaObject static_value() {
         try {
 	    // TODO: Only setAccessible to account for pattern found by
 	    // accessing constants included from a non-public interface.
 	    // (aka java.util.zip.ZipConstants being implemented by many
 	    // classes)
 	    field.setAccessible(true);
             return JavaObject.wrap(getRuntime(), field.get(null));
         } catch (IllegalAccessException iae) {
 	    throw getRuntime().newTypeError("illegal static value access: " + iae.getMessage());
         }
     }
 
     public RubyString name() {
         return getRuntime().newString(field.getName());
     }
     
     protected AccessibleObject accesibleObject() {
         return field;
     }
 }
diff --git a/src/org/jruby/javasupport/JavaMethod.java b/src/org/jruby/javasupport/JavaMethod.java
index 4f49af4d16..3b39edea36 100644
--- a/src/org/jruby/javasupport/JavaMethod.java
+++ b/src/org/jruby/javasupport/JavaMethod.java
@@ -1,225 +1,228 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Chad Fowler <chadfowler@chadfowler.com>
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 David Corbin <dcorbin@users.sourceforge.net>
  * Copyright (C) 2005 Charles O Nutter <headius@headius.com>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
 import org.jruby.IRuby;
 import org.jruby.RubyBoolean;
 import org.jruby.RubyClass;
 import org.jruby.RubyModule;
 import org.jruby.RubyString;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 public class JavaMethod extends JavaCallable {
     private final Method method;
 
     public static RubyClass createJavaMethodClass(IRuby runtime, RubyModule javaModule) {
+        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here, since we don't intend for people to monkey with
+        // this type and it can't be marshalled. Confirm. JRUBY-415
         RubyClass result = 
-            javaModule.defineClassUnder("JavaMethod", runtime.getObject());
+            javaModule.defineClassUnder("JavaMethod", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
         CallbackFactory callbackFactory = runtime.callbackFactory(JavaMethod.class);
 
         JavaAccessibleObject.registerRubyMethods(runtime, result);
         
         result.defineMethod("name", 
                 callbackFactory.getMethod("name"));
         result.defineMethod("arity", 
                 callbackFactory.getMethod("arity"));
         result.defineMethod("public?", 
                 callbackFactory.getMethod("public_p"));
         result.defineMethod("final?", 
                 callbackFactory.getMethod("final_p"));
         result.defineMethod("static?", 
                 callbackFactory.getMethod("static_p"));
         result.defineMethod("invoke", 
                 callbackFactory.getOptMethod("invoke"));
         result.defineMethod("invoke_static", 
                 callbackFactory.getOptMethod("invoke_static"));
         result.defineMethod("argument_types", 
                 callbackFactory.getMethod("argument_types"));
         result.defineMethod("inspect", 
                 callbackFactory.getMethod("inspect"));
         result.defineMethod("return_type", 
                 callbackFactory.getMethod("return_type"));
 
         return result;
     }
 
     public JavaMethod(IRuby runtime, Method method) {
         super(runtime, (RubyClass) runtime.getModule("Java").getClass("JavaMethod"));
         this.method = method;
 
         // Special classes like Collections.EMPTY_LIST are inner classes that are private but 
         // implement public interfaces.  Their methods are all public methods for the public 
         // interface.  Let these public methods execute via setAccessible(true). 
         if (Modifier.isPublic(method.getModifiers()) &&
             Modifier.isPublic(method.getClass().getModifiers()) &&
             !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
             accesibleObject().setAccessible(true);
         }
     }
 
     public static JavaMethod create(IRuby runtime, Method method) {
         return new JavaMethod(runtime, method);
     }
 
     public static JavaMethod create(IRuby runtime, Class javaClass, String methodName, Class[] argumentTypes) {
         try {
             Method method = javaClass.getMethod(methodName, argumentTypes);
             return create(runtime, method);
         } catch (NoSuchMethodException e) {
             throw runtime.newNameError("undefined method '" + methodName + "' for class '" + javaClass.getName() + "'",
                     methodName);
         }
     }
 
     public static JavaMethod createDeclared(IRuby runtime, Class javaClass, String methodName, Class[] argumentTypes) {
         try {
             Method method = javaClass.getDeclaredMethod(methodName, argumentTypes);
             return create(runtime, method);
         } catch (NoSuchMethodException e) {
             throw runtime.newNameError("undefined method '" + methodName + "' for class '" + javaClass.getName() + "'",
                     methodName);
         }
     }
 
     public RubyString name() {
         return getRuntime().newString(method.getName());
     }
 
     protected int getArity() {
         return method.getParameterTypes().length;
     }
 
     public RubyBoolean public_p() {
         return getRuntime().newBoolean(Modifier.isPublic(method.getModifiers()));
     }
 
     public RubyBoolean final_p() {
         return getRuntime().newBoolean(Modifier.isFinal(method.getModifiers()));
     }
 
     public IRubyObject invoke(IRubyObject[] args) {
         if (args.length != 1 + getArity()) {
             throw getRuntime().newArgumentError(args.length, 1 + getArity());
         }
 
         IRubyObject invokee = args[0];
         if (! (invokee instanceof JavaObject)) {
             throw getRuntime().newTypeError("invokee not a java object");
         }
         Object javaInvokee = ((JavaObject) invokee).getValue();
         Object[] arguments = new Object[args.length - 1];
         System.arraycopy(args, 1, arguments, 0, arguments.length);
         convertArguments(arguments);
 
         if (! method.getDeclaringClass().isInstance(javaInvokee)) {
             throw getRuntime().newTypeError("invokee not instance of method's class (" +
                                               "got" + javaInvokee.getClass().getName() + " wanted " +
                                               method.getDeclaringClass().getName() + ")");
         }
         return invokeWithExceptionHandling(javaInvokee, arguments);
     }
 
     public IRubyObject invoke_static(IRubyObject[] args) {
         if (args.length != getArity()) {
             throw getRuntime().newArgumentError(args.length, getArity());
         }
         Object[] arguments = new Object[args.length];
         System.arraycopy(args, 0, arguments, 0, arguments.length);
         convertArguments(arguments);
         return invokeWithExceptionHandling(null, arguments);
     }
 
     public IRubyObject return_type() {
         Class klass = method.getReturnType();
         
         if (klass.equals(void.class)) {
             return getRuntime().getNil();
         }
         return JavaClass.get(getRuntime(), klass);
     }
 
     private IRubyObject invokeWithExceptionHandling(Object javaInvokee, Object[] arguments) {
         try {
             Object result = method.invoke(javaInvokee, arguments);
             return JavaObject.wrap(getRuntime(), result);
         } catch (IllegalArgumentException iae) {
             throw getRuntime().newTypeError("expected " + argument_types().inspect());
         } catch (IllegalAccessException iae) {
             throw getRuntime().newTypeError("illegal access on '" + method.getName() + "': " + iae.getMessage());
         } catch (InvocationTargetException ite) {
             getRuntime().getJavaSupport().handleNativeException(ite.getTargetException());
             // This point is only reached if there was an exception handler installed.
             return getRuntime().getNil();
         }
     }
 
     private void convertArguments(Object[] arguments) {
         Class[] parameterTypes = parameterTypes();
         for (int i = 0; i < arguments.length; i++) {
             arguments[i] = JavaUtil.convertArgument(arguments[i], parameterTypes[i]);
         }
     }
 
     protected Class[] parameterTypes() {
         return method.getParameterTypes();
     }
 
     protected String nameOnInspection() {
         return "#<" + getType().toString() + "/" + method.getName() + "(";
     }
 
     public RubyBoolean static_p() {
         return getRuntime().newBoolean(isStatic());
     }
 
     private boolean isStatic() {
         return Modifier.isStatic(method.getModifiers());
     }
 
     protected int getModifiers() {
         return method.getModifiers();
     }
 
     protected AccessibleObject accesibleObject() {
         return method;
     }
 }
diff --git a/src/org/jruby/javasupport/JavaObject.java b/src/org/jruby/javasupport/JavaObject.java
index d75f08a0c4..5c91413824 100644
--- a/src/org/jruby/javasupport/JavaObject.java
+++ b/src/org/jruby/javasupport/JavaObject.java
@@ -1,201 +1,204 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2001 Alan Moore <alan_moore@gmx.net>
  * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>
  * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>
  * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>
  * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>
  * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>
  * Copyright (C) 2004 David Corbin <dcorbin@users.sourceforge.net>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.javasupport;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyModule;
 import org.jruby.RubyObject;
 import org.jruby.RubyString;
 import org.jruby.runtime.CallbackFactory;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 
 /**
  *
  * @author  jpetersen
  */
 public class JavaObject extends RubyObject {
     private static Object NULL_LOCK = new Object();
     private final Object value;
 
     protected JavaObject(IRuby runtime, RubyClass rubyClass, Object value) {
         super(runtime, rubyClass);
         this.value = value;
     }
 
     protected JavaObject(IRuby runtime, Object value) {
         this(runtime, runtime.getModule("Java").getClass("JavaObject"), value);
     }
 
     public static JavaObject wrap(IRuby runtime, Object value) {
         Object lock = value == null ? NULL_LOCK : value;
         
         synchronized (lock) {
             JavaObject wrapper = runtime.getJavaSupport().getJavaObjectFromCache(value);
             if (wrapper == null) {
             	if (value == null) {
             		wrapper = new JavaObject(runtime, value);
             	} else if (value.getClass().isArray()) {
                 	wrapper = new JavaArray(runtime, value);
                 } else if (value.getClass().equals(Class.class)) {
                 	wrapper = JavaClass.get(runtime, (Class)value);
                 } else {
                 	wrapper = new JavaObject(runtime, value);
                 }
                 runtime.getJavaSupport().putJavaObjectIntoCache(wrapper);
             }
             return wrapper;
         }
     }
 
     public Class getJavaClass() {
         return value != null ? value.getClass() : Void.TYPE;
     }
 
     public Object getValue() {
         return value;
     }
 
     public static RubyClass createJavaObjectClass(IRuby runtime, RubyModule javaModule) {
-    	RubyClass result = javaModule.defineClassUnder("JavaObject", runtime.getObject());
+        // FIXME: Ideally JavaObject instances should be marshallable, which means that
+        // the JavaObject metaclass should have an appropriate allocator. JRUBY-414
+    	RubyClass result = javaModule.defineClassUnder("JavaObject", runtime.getObject(), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);
 
     	registerRubyMethods(runtime, result);
 
         result.getMetaClass().undefineMethod("new");
 
         return result;
     }
 
 	protected static void registerRubyMethods(IRuby runtime, RubyClass result) {
 		CallbackFactory callbackFactory = runtime.callbackFactory(JavaObject.class);
 
         result.defineMethod("to_s", 
             callbackFactory.getMethod("to_s"));
         result.defineMethod("==", 
             callbackFactory.getMethod("equal", IRubyObject.class));
         result.defineMethod("eql?", 
             callbackFactory.getMethod("equal", IRubyObject.class));
         result.defineMethod("equal?", 
             callbackFactory.getMethod("same", IRubyObject.class));
         result.defineMethod("hash", 
             callbackFactory.getMethod("hash"));
         result.defineMethod("java_type", 
             callbackFactory.getMethod("java_type"));
         result.defineMethod("java_class", 
             callbackFactory.getMethod("java_class"));
         result.defineMethod("java_proxy?", 
             callbackFactory.getMethod("is_java_proxy"));
         result.defineMethod("synchronized",
             callbackFactory.getMethod("ruby_synchronized"));
         result.defineMethod("length", 
             callbackFactory.getMethod("length"));
         result.defineMethod("[]", 
             callbackFactory.getMethod("aref", IRubyObject.class));
         result.defineMethod("[]=", 
             callbackFactory.getMethod("aset", IRubyObject.class, IRubyObject.class));
 	}
 
 	public RubyFixnum hash() {
         return getRuntime().newFixnum(value == null ? 0 : value.hashCode());
     }
 
     public IRubyObject to_s() {
         return getRuntime().newString(
            value == null ? "null" : value.toString());
     }
 
     public IRubyObject equal(IRubyObject other) {
         if (!(other instanceof JavaObject)) {
             other = other.getInstanceVariable("@java_object");
             if (!(other instanceof JavaObject)) {
                 return getRuntime().getFalse();
             }
         }
     	
         if (getValue() == null && ((JavaObject) other).getValue() == null) {
             return getRuntime().getTrue();
         }
     	
         boolean isEqual = getValue().equals(((JavaObject) other).getValue());
         return isEqual ? getRuntime().getTrue() : getRuntime().getFalse();
     }
     
     public IRubyObject same(IRubyObject other) {
         if (!(other instanceof JavaObject)) {
             other = other.getInstanceVariable("@java_object");
             if (!(other instanceof JavaObject)) {
               return getRuntime().getFalse();
             }
         }
       
         if (getValue() == null && ((JavaObject) other).getValue() == null) {
             return getRuntime().getTrue();
         }
       
         boolean isSame = getValue() == ((JavaObject) other).getValue();
         return isSame ? getRuntime().getTrue() : getRuntime().getFalse();
     }
 
     public RubyString java_type() {
         return getRuntime().newString(getJavaClass().getName());
     }
 
     public IRubyObject java_class() {
         return JavaClass.get(getRuntime(), getJavaClass());
     }
 
     public RubyFixnum length() {
         throw getRuntime().newTypeError("not a java array");
     }
 
     public IRubyObject aref(IRubyObject index) {
         throw getRuntime().newTypeError("not a java array");
     }
 
     public IRubyObject aset(IRubyObject index, IRubyObject someValue) {
         throw getRuntime().newTypeError("not a java array");
     }
     
     public IRubyObject is_java_proxy() {
         return getRuntime().getTrue();
     }
 
     public IRubyObject ruby_synchronized() {
         Object lock = getValue();
         synchronized (lock != null ? lock : NULL_LOCK) {
             return getRuntime().getCurrentContext().yield(null);
         }
     }
 }
diff --git a/src/org/jruby/runtime/builtin/meta/ArrayMetaClass.java b/src/org/jruby/runtime/builtin/meta/ArrayMetaClass.java
index f8756315e6..c43fb1d6a7 100644
--- a/src/org/jruby/runtime/builtin/meta/ArrayMetaClass.java
+++ b/src/org/jruby/runtime/builtin/meta/ArrayMetaClass.java
@@ -1,160 +1,158 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2005 Thomas E Enebo <enebo@acm.org>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.runtime.builtin.meta;
 
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.runtime.Arity;
+import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.collections.SinglyLinkedList;
 
 public class ArrayMetaClass extends ObjectMetaClass {
     public ArrayMetaClass(IRuby runtime) {
         super("Array", RubyArray.class, runtime.getObject(), ARRAY_ALLOCATOR);
     }
     
 	public ArrayMetaClass(String name, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
 		super(name, RubyArray.class, superClass, allocator, parentCRef);
 	}
 
 	protected class ArrayMeta extends Meta {
 		protected void initializeClass() {
 	        includeModule(getRuntime().getModule("Enumerable"));
 	
 	        defineFastMethod("+", Arity.singleArgument(), "op_plus");
 	        defineFastMethod("*", Arity.singleArgument(), "op_times");
 	        defineFastMethod("-", Arity.singleArgument(), "op_diff");
 	        defineFastMethod("&", Arity.singleArgument(), "op_and");
 	        defineFastMethod("|", Arity.singleArgument(), "op_or");
 	        defineFastMethod("[]", Arity.optional(), "aref");
 	        defineFastMethod("[]=", Arity.optional(), "aset");
 	        defineFastMethod("<=>", Arity.singleArgument(), "op_cmp");
 	        defineFastMethod("<<", Arity.singleArgument(), "append");
 	        defineFastMethod("==", Arity.singleArgument(), "array_op_equal");
 	        defineFastMethod("assoc", Arity.singleArgument());
 	        defineFastMethod("at", Arity.singleArgument(), "at");
 	        defineFastMethod("clear", Arity.noArguments(), "rb_clear");
 	        defineFastMethod("clone", Arity.noArguments(), "rbClone");
 	        defineMethod("collect", Arity.noArguments());
 	        defineMethod("collect!", Arity.noArguments(), "collect_bang");
 	        defineFastMethod("compact", Arity.noArguments());
 	        defineFastMethod("compact!", Arity.noArguments(), "compact_bang");
 	        defineFastMethod("concat", Arity.singleArgument());
 	        defineMethod("delete", Arity.singleArgument());
 	        defineFastMethod("delete_at", Arity.singleArgument());
 	        defineMethod("delete_if", Arity.noArguments());
 	        defineMethod("each", Arity.noArguments());
 	        defineMethod("each_index", Arity.noArguments());
 	        defineFastMethod("eql?", Arity.singleArgument(), "eql");
 	        defineFastMethod("empty?", Arity.noArguments(), "empty_p");
 	        defineMethod("fetch", Arity.optional());
 	        defineMethod("fill", Arity.optional());
 	        defineFastMethod("first", Arity.optional());
 	        defineFastMethod("flatten", Arity.noArguments());
 	        defineFastMethod("flatten!", Arity.noArguments(), "flatten_bang");
 	        defineFastMethod("frozen?", Arity.noArguments(), "frozen");
 	        defineFastMethod("hash", Arity.noArguments());
 	        defineFastMethod("include?", Arity.singleArgument(), "include_p");
 	        defineFastMethod("index", Arity.singleArgument());
 	        defineFastMethod("indices", Arity.optional());
             // FIXME: shouldn't this be private?
 	        defineMethod("initialize", Arity.optional());
 	        defineFastMethod("insert", Arity.optional());
 	        defineFastMethod("inspect", Arity.noArguments());
 	        defineFastMethod("join", Arity.optional());
 	        defineFastMethod("last", Arity.optional());
 	        defineFastMethod("length", Arity.noArguments());
 	        defineFastMethod("nitems", Arity.noArguments());
 	        defineFastMethod("pack", Arity.singleArgument());
 	        defineFastMethod("pop", Arity.noArguments());
 	        defineFastMethod("push", Arity.optional());
 	        defineFastMethod("rassoc", Arity.singleArgument());
 	        defineMethod("reject!", Arity.noArguments(), "reject_bang");
 	        defineFastMethod("replace", Arity.singleArgument(), "replace");
 	        defineFastMethod("reverse", Arity.noArguments());
 	        defineFastMethod("reverse!", Arity.noArguments(), "reverse_bang");
 	        defineMethod("reverse_each", Arity.noArguments());
 	        defineFastMethod("rindex", Arity.singleArgument());
 	        defineFastMethod("shift", Arity.noArguments());
 	        defineMethod("sort", Arity.noArguments());
 	        defineMethod("sort!", Arity.noArguments(), "sort_bang");
 	        defineFastMethod("slice", Arity.optional(), "aref");
 	        defineFastMethod("slice!", Arity.optional(), "slice_bang");
 	        defineFastMethod("to_a", Arity.noArguments());
 	        defineFastMethod("to_ary", Arity.noArguments());
 	        defineFastMethod("to_s", Arity.noArguments());
 	        defineFastMethod("transpose", Arity.noArguments());
 	        defineFastMethod("uniq", Arity.noArguments());
 	        defineFastMethod("uniq!", Arity.noArguments(), "uniq_bang");
 	        defineFastMethod("unshift", Arity.optional());
 	        defineFastMethod("values_at", Arity.optional());
 	        defineAlias("===", "==");
 	        defineAlias("size", "length");
 	        defineAlias("indexes", "indices");
 	        defineAlias("filter", "collect!");
 	        defineAlias("map!", "collect!");
+            
+            CallbackFactory arrayCB = getRuntime().callbackFactory(ArrayMetaClass.class);
 	
-	        defineSingletonMethod("new", Arity.optional(), "newInstance");
-	        defineSingletonMethod("[]", Arity.optional(), "create");
+            defineSingletonMethod("[]", arrayCB.getOptSingletonMethod("create"));
 		}
 	};
 
 	protected Meta getMeta() {
 		return new ArrayMeta();
 	}
 	
 	public RubyClass newSubClass(String name, SinglyLinkedList parentCRef) {
 		return new ArrayMetaClass(name, this, ARRAY_ALLOCATOR, parentCRef);
 	}
     
     private static ObjectAllocator ARRAY_ALLOCATOR = new ObjectAllocator() {
         public IRubyObject allocate(IRuby runtime, RubyClass klass) {
-            // FIXME: not sure how much I like this call back to the runtime...
-            RubyArray instance = runtime.newArray();
-
-            instance.setMetaClass(klass);
-
-            return instance;
+            return new RubyArray(runtime, klass);
         }
     };
     
-    public IRubyObject create(IRubyObject[] args) {
-        // FIXME: Why is this calling allocate directly instead of the normal newInstance process? Performance?
-        RubyArray array = (RubyArray)ARRAY_ALLOCATOR.allocate(getRuntime(), this);
+    public static IRubyObject create(IRubyObject klass, IRubyObject[] args) {
+        // FIXME: Why is this calling newArray directly instead of the normal newInstance process? Performance?
+        RubyArray array = (RubyArray)((RubyClass)klass).allocate();
+        array.callInit(IRubyObject.NULL_ARRAY);
         
         if (args.length >= 1) {
             for (int i = 0; i < args.length; i++) {
                 array.add(args[i]);
             }
         }
         
         return array;
     }
 }
diff --git a/src/org/jruby/runtime/builtin/meta/HashMetaClass.java b/src/org/jruby/runtime/builtin/meta/HashMetaClass.java
index 45810ee16f..25416810d0 100644
--- a/src/org/jruby/runtime/builtin/meta/HashMetaClass.java
+++ b/src/org/jruby/runtime/builtin/meta/HashMetaClass.java
@@ -1,133 +1,137 @@
 /*
  * Created on Jun 21, 2005
  *
  * To change the template for this generated file go to
  * Window - Preferences - Java - Code Generation - Code and Comments
  */
 package org.jruby.runtime.builtin.meta;
 
 import java.util.HashMap;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyHash;
 import org.jruby.runtime.Arity;
+import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.collections.SinglyLinkedList;
 
 public class HashMetaClass extends ObjectMetaClass {
     public HashMetaClass(IRuby runtime) {
         super("Hash", RubyHash.class, runtime.getObject(), HASH_ALLOCATOR);
     }
     
 	public HashMetaClass(String name, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
 		super(name, RubyHash.class, superClass, allocator, parentCRef);
 	}
 
 	protected class HashMeta extends Meta {
 		protected void initializeClass() {
 	        includeModule(getRuntime().getModule("Enumerable"));
 	
 	        defineFastMethod("==", Arity.singleArgument(), "equal");
 	        defineFastMethod("[]", Arity.singleArgument(), "aref");
 	        defineFastMethod("[]=", Arity.twoArguments(), "aset");
 			defineFastMethod("clear", Arity.noArguments(), "rb_clear");
 			defineFastMethod("clone", Arity.noArguments(), "rbClone");
 			defineMethod("default", Arity.optional(), "getDefaultValue");
             defineMethod("default_proc", Arity.noArguments()); 
 			defineMethod("default=", Arity.singleArgument(), "setDefaultValue");
 			defineMethod("delete", Arity.singleArgument());
 			defineMethod("delete_if", Arity.noArguments());
 			defineMethod("each", Arity.noArguments());
 			defineMethod("each_pair", Arity.noArguments());
 			defineMethod("each_value", Arity.noArguments());
 			defineMethod("each_key", Arity.noArguments());
 	        defineFastMethod("empty?", Arity.noArguments(), "empty_p");
 	        defineMethod("fetch", Arity.optional());
 	        defineFastMethod("has_value?", Arity.singleArgument(), "has_value");
 	        defineFastMethod("index", Arity.singleArgument());
 	        defineFastMethod("indices", Arity.optional());
 	        defineMethod("initialize", Arity.optional());
 	        defineFastMethod("inspect", Arity.noArguments());
 			defineFastMethod("invert", Arity.noArguments());
 	        defineFastMethod("include?", Arity.singleArgument(), "has_key");
 			defineFastMethod("keys", Arity.noArguments());
 	        defineMethod("merge", Arity.singleArgument());
 	        defineFastMethod("rehash", Arity.noArguments());
 			defineMethod("reject", Arity.noArguments());
 			defineMethod("reject!", Arity.noArguments(), "reject_bang");
 	        defineFastMethod("replace", Arity.singleArgument());
 			defineFastMethod("shift", Arity.noArguments());
 	        defineFastMethod("size", Arity.noArguments(), "rb_size");
 			defineMethod("sort", Arity.noArguments());
 	        defineFastMethod("to_a", Arity.noArguments());
 	        defineFastMethod("to_hash", Arity.noArguments());
 	        defineFastMethod("to_s", Arity.noArguments());
 	        defineMethod("update", Arity.singleArgument());
 			defineFastMethod("values", Arity.noArguments(), "rb_values");
 	        defineFastMethod("values_at", Arity.optional());
 
 	        defineAlias("has_key?", "include?");
 			defineAlias("indexes", "indices");
 	        defineAlias("key?", "include?");
 			defineAlias("length", "size");
 	        defineAlias("member?", "include?");
 	        defineAlias("merge!", "update");
 	        defineAlias("store", "[]=");
 	        defineAlias("value?", "has_value?");
+            
+            CallbackFactory hashCB = getRuntime().callbackFactory(HashMetaClass.class);
 	        
-	        defineSingletonMethod("new", Arity.optional(), "newInstance");
-	        defineFastSingletonMethod("[]", Arity.optional(), "create");
+            defineSingletonMethod("new", hashCB.getOptSingletonMethod("newInstance"));
+            defineFastSingletonMethod("[]", hashCB.getOptSingletonMethod("create"));
 		}
 	};
 	
 	protected Meta getMeta() {
 		return new HashMeta();
 	}
 	
 	public RubyClass newSubClass(String name, SinglyLinkedList parentCRef) {
 		return new HashMetaClass(name, this, HASH_ALLOCATOR, parentCRef);
 	}
 
     private static ObjectAllocator HASH_ALLOCATOR = new ObjectAllocator() {
         public IRubyObject allocate(IRuby runtime, RubyClass klass) {
             RubyHash instance = new RubyHash(runtime);
 
             instance.setMetaClass(klass);
 
             return instance;
         }
     };
 
-    public IRubyObject newInstance(IRubyObject[] args) {
+    public static IRubyObject newInstance(IRubyObject recv, IRubyObject[] args) {
         // FIXME: This is pretty ugly, but I think it's being done to capture the block. Confirm that.
-    	IRuby runtime = getRuntime();
-        RubyHash hash = (RubyHash)HASH_ALLOCATOR.allocate(runtime, this);
+    	IRuby runtime = recv.getRuntime();
+        RubyHash hash = (RubyHash)((RubyClass)recv).allocate();
 
         // A block to represent 'default' value for unknown values
         if (runtime.getCurrentContext().isBlockGiven()) {
         	hash.setDefaultProc(runtime.newProc());
         }
         
-        hash.setMetaClass(this);
         hash.callInit(args);
         
         return hash;
     }
     
-    public IRubyObject create(IRubyObject[] args) {
-        RubyHash hash = (RubyHash)HASH_ALLOCATOR.allocate(getRuntime(), this);
+    public static IRubyObject create(IRubyObject recv, IRubyObject[] args) {
+        IRuby runtime = recv.getRuntime();
+        RubyClass klass = (RubyClass)recv;
+        RubyHash hash = (RubyHash)klass.allocate();
 
         if (args.length == 1) {
             hash.setValueMap(new HashMap(((RubyHash) args[0]).getValueMap()));
         } else if (args.length % 2 != 0) {
-            throw getRuntime().newArgumentError("odd number of args for Hash");
+            throw runtime.newArgumentError("odd number of args for Hash");
         } else {
             for (int i = 0; i < args.length; i += 2) {
                 hash.aset(args[i], args[i + 1]);
             }
         }
         return hash;
     }
 }
diff --git a/src/org/jruby/runtime/builtin/meta/NumericMetaClass.java b/src/org/jruby/runtime/builtin/meta/NumericMetaClass.java
index ad9d5d13e9..8f97d760ad 100644
--- a/src/org/jruby/runtime/builtin/meta/NumericMetaClass.java
+++ b/src/org/jruby/runtime/builtin/meta/NumericMetaClass.java
@@ -1,110 +1,109 @@
 /***** BEGIN LICENSE BLOCK *****
  * Version: CPL 1.0/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Common Public
  * License Version 1.0 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.eclipse.org/legal/cpl-v10.html
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing
  * rights and limitations under the License.
  *
  * Copyright (C) 2005 Thomas E Enebo <enebo@acm.org>
  * 
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the CPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the CPL, the GPL or the LGPL.
  ***** END LICENSE BLOCK *****/
 package org.jruby.runtime.builtin.meta;
 
 import org.jruby.IRuby;
 import org.jruby.RubyClass;
 import org.jruby.RubyNumeric;
 import org.jruby.runtime.Arity;
+import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.util.collections.SinglyLinkedList;
 
 public class NumericMetaClass extends ObjectMetaClass {
 	public NumericMetaClass(IRuby runtime) {
         super("Numeric", RubyNumeric.class, runtime.getObject(), NUMERIC_ALLOCATOR);
     }
 	    
 	public NumericMetaClass(String name, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
         super(name, RubyNumeric.class, superClass, allocator, parentCRef);
     }
 
     public NumericMetaClass(String name, Class clazz, RubyClass superClass, ObjectAllocator allocator) {
     	super(name, clazz, superClass, allocator);
     }
 
     public NumericMetaClass(String name, Class clazz, RubyClass superClass, ObjectAllocator allocator, SinglyLinkedList parentCRef) {
     	super(name, clazz, superClass, allocator, parentCRef);
     }
     
     protected class NumericMeta extends Meta {
 	    protected void initializeClass() {
 	        includeModule(getRuntime().getModule("Comparable"));
 	
 	        defineFastMethod("+@", Arity.noArguments(), "op_uplus");
 	        defineFastMethod("-@", Arity.noArguments(), "op_uminus");
 	        defineFastMethod("<=>", Arity.singleArgument(), "cmp");
 	        defineFastMethod("==", Arity.singleArgument(), "equal");
 	        defineFastMethod("equal?", Arity.singleArgument(), "veryEqual");
 	        defineFastMethod("===", Arity.singleArgument(), "equal");
 	        defineFastMethod("abs", Arity.noArguments());
 	        defineFastMethod("ceil", Arity.noArguments());
 	        defineFastMethod("coerce", Arity.singleArgument());
 	        defineFastMethod("clone", Arity.noArguments(), "rbClone");
 	        defineFastMethod("divmod", Arity.singleArgument(), "divmod");
 	        defineFastMethod("eql?", Arity.singleArgument(), "eql");
 	        defineFastMethod("floor", Arity.noArguments());
 	        defineFastMethod("integer?", Arity.noArguments(), "int_p");
 	        defineFastMethod("modulo", Arity.singleArgument());
 	        defineFastMethod("nonzero?", Arity.noArguments(), "nonzero_p");
 	        defineFastMethod("remainder", Arity.singleArgument());
 	        defineFastMethod("round", Arity.noArguments());
 	        defineFastMethod("truncate", Arity.noArguments());
 	        defineFastMethod("to_int", Arity.noArguments());
 	        defineFastMethod("zero?", Arity.noArguments(), "zero_p");
             defineMethod("step", Arity.required(1), "step");
             
             // Add relational operators that are faster than comparable's implementations
             defineFastMethod(">=", Arity.singleArgument(), "op_ge");
             defineFastMethod(">", Arity.singleArgument(), "op_gt");
             defineFastMethod("<=", Arity.singleArgument(), "op_le");
             defineFastMethod("<", Arity.singleArgument(), "op_lt");
-	        
-	        defineFastSingletonMethod("new", Arity.optional(), "newInstance"); 
 	    }
     };
     
     protected Meta getMeta() {
     	return new NumericMeta();
     }
 		
     public RubyClass newSubClass(String name, SinglyLinkedList parentCRef) {
         // FIXME: this and the other newSubClass impls should be able to defer to the default impl
         return new NumericMetaClass(name, this, NUMERIC_ALLOCATOR, parentCRef);
     }
 
     private static ObjectAllocator NUMERIC_ALLOCATOR = new ObjectAllocator() {
         public IRubyObject allocate(IRuby runtime, RubyClass klass) {
             RubyNumeric instance = runtime.newNumeric();
 
             instance.setMetaClass(klass);
 
             return instance;
         }
     };
 }
diff --git a/test/org/jruby/test/BaseMockRuby.java b/test/org/jruby/test/BaseMockRuby.java
index 93cd462d81..376ac0e884 100644
--- a/test/org/jruby/test/BaseMockRuby.java
+++ b/test/org/jruby/test/BaseMockRuby.java
@@ -1,715 +1,716 @@
 package org.jruby.test;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.io.Reader;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
 import org.jruby.IRuby;
 import org.jruby.RubyArray;
 import org.jruby.RubyBinding;
 import org.jruby.RubyBoolean;
 import org.jruby.RubyClass;
 import org.jruby.RubyException;
 import org.jruby.RubyFileStat;
 import org.jruby.RubyFixnum;
 import org.jruby.RubyFloat;
 import org.jruby.RubyModule;
 import org.jruby.RubyNumeric;
 import org.jruby.RubyProc;
 import org.jruby.RubyString;
 import org.jruby.RubySymbol;
 import org.jruby.RubyTime;
 import org.jruby.Profile;
 import org.jruby.RubySymbol.SymbolTable;
 import org.jruby.ast.Node;
 import org.jruby.common.RubyWarnings;
 import org.jruby.exceptions.RaiseException;
 import org.jruby.internal.runtime.GlobalVariables;
 import org.jruby.internal.runtime.ThreadService;
 import org.jruby.javasupport.JavaSupport;
 import org.jruby.lexer.yacc.ISourcePosition;
 import org.jruby.parser.Parser;
 import org.jruby.runtime.Block;
 import org.jruby.runtime.CacheMap;
 import org.jruby.runtime.CallbackFactory;
 import org.jruby.runtime.DynamicScope;
 import org.jruby.runtime.GlobalVariable;
+import org.jruby.runtime.ObjectAllocator;
 import org.jruby.runtime.ObjectSpace;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.Visibility;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.load.LoadService;
 import org.jruby.util.collections.SinglyLinkedList;
 
 public class BaseMockRuby implements IRuby {
 
 	public CacheMap getCacheMap() {
 		throw new MockException();
 	}
 
 	public IRubyObject evalScript(String script) {
 		throw new MockException();
 	}
 
 	public IRubyObject eval(Node node) {
 		throw new MockException();
 	}
 
     public RubyClass getObject() {
         throw new MockException();
     }
 
     public RubyModule getKernel() {
         throw new MockException();
     }
     
     public RubyClass getString() {
         throw new MockException();
     }
     
     public RubyClass getFixnum() {
         throw new MockException();
     }
 
 	public RubyBoolean getTrue() {
 		throw new MockException();
 	}
 
 	public RubyBoolean getFalse() {
 		throw new MockException();
 	}
 
 	public IRubyObject getNil() {
 		throw new MockException();
 	}
 
     public RubyClass getNilClass() {
         throw new MockException();
     }
 
 	public RubyModule getModule(String name) {
 		throw new MockException();
 	}
 
 	public RubyClass getClass(String name) {
 		throw new MockException();
 	}
 
-	public RubyClass defineClass(String name, RubyClass superClass) {
+	public RubyClass defineClass(String name, RubyClass superClass, ObjectAllocator allocator) {
 		throw new MockException();
 	}
 
-	public RubyClass defineClassUnder(String name, RubyClass superClass,
+	public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator,
             SinglyLinkedList parentCRef) {
 		throw new MockException();
 	}
 
 	public RubyModule defineModule(String name) {
 		throw new MockException();
 	}
 
 	public RubyModule defineModuleUnder(String name, SinglyLinkedList parentCRef) {
 		throw new MockException();
 	}
 
 	public RubyModule getOrCreateModule(String name) {
 		throw new MockException();
 	}
 
 	public int getSafeLevel() {
 		throw new MockException();
 	}
 
 	public void setSafeLevel(int safeLevel) {
 		throw new MockException();
 	}
 
 	public void secure(int level) {
 		throw new MockException();
 	}
 
 	public void defineGlobalConstant(String name, IRubyObject value) {
 		throw new MockException();
 	}
 
 	public IRubyObject getTopConstant(String name) {
 		throw new MockException();
 	}
 
 	public boolean isClassDefined(String name) {
 		throw new MockException();
 	}
 
 	public IRubyObject yield(IRubyObject value) {
 		throw new MockException();
 	}
 
 	public IRubyObject yield(IRubyObject value, IRubyObject self,
 			RubyModule klass, boolean checkArguments) {
 		throw new MockException();
 	}
 
 	public IRubyObject getTopSelf() {
 		throw new MockException();
 	}
 
 	public String getSourceFile() {
 		throw new MockException();
 	}
 
 	public int getSourceLine() {
 		throw new MockException();
 	}
 
 	public IRubyObject getVerbose() {
 		throw new MockException();
 	}
 
 	public IRubyObject getDebug() {
 		throw new MockException();
 	}
 
 	public boolean isBlockGiven() {
 		throw new MockException();
 	}
 
 	public boolean isFBlockGiven() {
 		throw new MockException();
 		
 	}
 
 	public void setVerbose(IRubyObject verbose) {
 		throw new MockException();
 
 	}
 
 	public void setDebug(IRubyObject debug) {
 		throw new MockException();
 	}
 
 	public Visibility getCurrentVisibility() {
 		throw new MockException();
 		
 	}
 
 	public void setCurrentVisibility(Visibility visibility) {
 		throw new MockException();
 
 	}
 
 	public void defineVariable(GlobalVariable variable) {
 		throw new MockException();
 
 	}
 
 	public void defineReadonlyVariable(String name, IRubyObject value) {
 		throw new MockException();
 
 	}
 
 	public Node parse(Reader content, String file) {
 		throw new MockException();
 		
 	}
 
 	public Node parse(String content, String file) {
 		throw new MockException();
 		
 	}
 
 	public Parser getParser() {
 		throw new MockException();
 		
 	}
 
 	public ThreadService getThreadService() {
 		throw new MockException();
 		
 	}
 
 	public ThreadContext getCurrentContext() {
 		throw new MockException();
 		
 	}
 
 	public LoadService getLoadService() {
 		throw new MockException();
 		
 	}
 
 	public RubyWarnings getWarnings() {
 		throw new MockException();
 		
 	}
 
 	public PrintStream getErrorStream() {
 		throw new MockException();
 		
 	}
 
 	public InputStream getInputStream() {
 		throw new MockException();
 		
 	}
 
 	public PrintStream getOutputStream() {
 		throw new MockException();
 		
 	}
 
 	public RubyModule getClassFromPath(String path) {
 		throw new MockException();
 		
 	}
 
 	public void printError(RubyException excp) {
 		throw new MockException();
 
 	}
 
 	public void loadScript(RubyString scriptName, RubyString source,
 			boolean wrap) {
 		throw new MockException();
 
 	}
 
 	public void loadScript(String scriptName, Reader source, boolean wrap) {
 		throw new MockException();
 
 	}
 
 	public void loadNode(String scriptName, Node node, boolean wrap) {
 		throw new MockException();
 
 	}
 
 	public void loadFile(File file, boolean wrap) {
 		throw new MockException();
 
 	}
 
 	public void callTraceFunction(ThreadContext context, String event, ISourcePosition position,
 			IRubyObject self, String name, IRubyObject type) {
 		throw new MockException();
 
 	}
 
 	public RubyProc getTraceFunction() {
 		throw new MockException();
 		
 	}
 
 	public void setTraceFunction(RubyProc traceFunction) {
 		throw new MockException();
 
 	}
 
 	public GlobalVariables getGlobalVariables() {
 		throw new MockException();
 		
 	}
 
 	public void setGlobalVariables(GlobalVariables variables) {
 		throw new MockException();
 		
 	}
 
 	public CallbackFactory callbackFactory(Class type) {
 		throw new MockException();
 		
 	}
 
 	public IRubyObject pushExitBlock(RubyProc proc) {
 		throw new MockException();
 		
 	}
 
 	public void tearDown() {
 		throw new MockException();
 
 	}
 
 	public RubyArray newArray() {
 		throw new MockException();
 		
 	}
 
 	public RubyArray newArray(IRubyObject object) {
 		throw new MockException();
 		
 	}
 
 	public RubyArray newArray(IRubyObject car, IRubyObject cdr) {
 		throw new MockException();
 		
 	}
 
 	public RubyArray newArray(IRubyObject[] objects) {
 		throw new MockException();
 		
 	}
 
 	public RubyArray newArray(List list) {
 		throw new MockException();
 		
 	}
 
 	public RubyArray newArray(int size) {
 		throw new MockException();
 		
 	}
 
 	public RubyBoolean newBoolean(boolean value) {
 		throw new MockException();
 		
 	}
 
 	public RubyFileStat newRubyFileStat(File file) {
 		throw new MockException();
 		
 	}
 
 	public RubyFixnum newFixnum(long value) {
 		throw new MockException();
 		
 	}
 
 	public RubyFloat newFloat(double value) {
 		throw new MockException();
 		
 	}
 
 	public RubyNumeric newNumeric() {
 		throw new MockException();
 
     }
 
     public RubyProc newProc() {
         throw new MockException();
         
     }
 
     public RubyBinding newBinding() {
         throw new MockException();
         
     }
 
     public RubyBinding newBinding(Block block) {
         throw new MockException();
         
     }
 
 	public RubyString newString(String string) {
 		throw new MockException();
 		
 	}
 
 	public RubySymbol newSymbol(String string) {
 		throw new MockException();
 		
 	}
     
     public RubyTime newTime(long milliseconds) {
         throw new MockException();
     }
 
 	public RaiseException newArgumentError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newArgumentError(int got, int expected) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoEBADFError() {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoEINVALError() {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoENOENTError() {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoESPIPEError() {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoEBADFError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoEINVALError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoENOENTError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoESPIPEError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newErrnoEEXISTError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newIndexError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newSecurityError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newSystemCallError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newTypeError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newThreadError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newSyntaxError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newRangeError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newNotImplementedError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newNoMethodError(String message, String name) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newNameError(String message, String name) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newLocalJumpError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newLoadError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newFrozenError(String objectType) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newSystemStackError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newSystemExit(int status) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newIOError(String message) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newIOErrorFromException(IOException ioe) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newTypeError(IRubyObject receivedObject,
 			RubyClass expectedType) {
 		throw new MockException();
 		
 	}
 
 	public RaiseException newEOFError() {
 		throw new MockException();
 		
 	}
 
 	public SymbolTable getSymbolTable() {
 		throw new MockException();
 		
 	}
 
 	public void setStackTraces(int stackTraces) {
 		throw new MockException();
 
 	}
 
 	public int getStackTraces() {
 		throw new MockException();
 		
 	}
 
 	public void setRandomSeed(long randomSeed) {
 		throw new MockException();
 
 	}
 
 	public long getRandomSeed() {
 		throw new MockException();
 		
 	}
 
 	public Random getRandom() {
 		throw new MockException();
 		
 	}
 
 	public ObjectSpace getObjectSpace() {
 		throw new MockException();
 		
 	}
 
 	public Hashtable getIoHandlers() {
 		throw new MockException();
 		
 	}
 
 	public RubyFixnum[] getFixnumCache() {
 		throw new MockException();
 		
 	}
 
 	public long incrementRandomSeedSequence() {
 		throw new MockException();
 		
 	}
 
 	public JavaSupport getJavaSupport() {
 		throw new MockException();
 	}
 
     public String getCurrentDirectory() {
         throw new MockException();
     }
 
     public void setCurrentDirectory(String dir) {
         throw new MockException();
     }
 
 	public RaiseException newZeroDivisionError() {
         throw new MockException();
 	}
 
 	public InputStream getIn() {
         throw new MockException();
 	}
 
 	public PrintStream getOut() {
         throw new MockException();
 	}
 
 	public PrintStream getErr() {
         throw new MockException();
 	}
 
 	public boolean isGlobalAbortOnExceptionEnabled() {
         throw new MockException();
 	}
 
 	public void setGlobalAbortOnExceptionEnabled(boolean b) {
         throw new MockException();
 	}
 
 	public boolean isDoNotReverseLookupEnabled() {
         throw new MockException();
 	}
 
 	public void setDoNotReverseLookupEnabled(boolean b) {
         throw new MockException();
 	}
 
     public boolean registerInspecting(Object o) {
         throw new MockException();
     }
     public void unregisterInspecting(Object o) {
         throw new MockException();
     }
 
     public boolean isObjectSpaceEnabled() {
         return true;
     }
 
     public IRubyObject compileAndRun(Node node) {
         // TODO Auto-generated method stub
         return null;
     }
 
     public Node parse(Reader content, String file, DynamicScope scope) {
         // TODO Auto-generated method stub
         return null;
     }
 
     public Node parse(String content, String file, DynamicScope scope) {
         // TODO Auto-generated method stub
         return null;
     }
     
     public IRubyObject getTmsStruct() {
         return null;
     }
     
     public long getStartTime() {
         return 0;
     }
     
     public void setEncoding(String encoding) {}
     public String getEncoding() { return null; }
 
     public Profile getProfile() {
         return null;
     }
     
     public Map getRuntimeInformation() {
         return null;
     }
     
     public String getJRubyHome() {
         return null;
     }
 }
