diff --git a/build.gradle b/build.gradle
index 8bbe585607..097e4261f1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,338 +1,339 @@
 apply plugin: 'eclipse'
 apply plugin: 'idea'
 apply from: "./libraries.gradle"
 
 
 buildscript {
 	repositories {
 		mavenCentral()
 		mavenLocal()
 		jcenter()
 
 		maven {
 			name 'jboss-nexus'
 			url "http://repository.jboss.org/nexus/content/groups/public/"
 		}
 		maven {
 			name "jboss-snapshots"
 			url "http://snapshots.jboss.org/maven2/"
 		}
 	}
 	dependencies {
 		classpath 'org.hibernate.build.gradle:gradle-maven-publish-auth:2.0.1'
 		classpath 'org.hibernate.build.gradle:hibernate-matrix-testing:1.0.0-SNAPSHOT'
 		classpath 'org.hibernate.build.gradle:version-injection-plugin:1.0.0'
 		classpath 'org.hibernate.build.gradle:gradle-xjc-plugin:1.0.2.Final'
 		classpath 'com.github.lburgazzoli:lb-karaf-features-gen:1.0.0-SNAPSHOT'
 	}
 }
 
 allprojects {
     repositories {
         mavenCentral()
         mavenLocal()
 
         maven {
             name 'jboss-nexus'
             url "http://repository.jboss.org/nexus/content/groups/public/"
         }
         maven {
             name "jboss-snapshots"
             url "http://snapshots.jboss.org/maven2/"
         }
     }
 }
 
 ext {
     expectedGradleVersion = '2.4'
     hibernateTargetVersion = '5.0.1-SNAPSHOT'
 
     osgiExportVersion = hibernateTargetVersion.replaceAll( '-SNAPSHOT', '.SNAPSHOT' )
 }
 
 idea {
     project {
 		jdkName = '1.6'
 		languageLevel = '1.6'
 
 		vcs = 'Git'
     }
     module {
         name = "hibernate-orm"
     }
 }
 
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 // Used in MANIFEST.MF for OSGi Bundles
 def osgiDescription() {
 	return "A module of the Hibernate O/RM project"
 }
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 subprojects { subProject ->
     apply plugin: 'idea'
     apply plugin: 'eclipse'
 
     defaultTasks 'build'
 
     group = 'org.hibernate'
     version = rootProject.hibernateTargetVersion
 
     ext.exportPackageVersion = rootProject.osgiExportVersion
 
     // minimize changes, at least for now (gradle uses 'build' by default)..
     buildDir = "target"
 
 	if ( subProject.name.startsWith( 'release' ) || subProject.name.startsWith( 'documentation' ) ) {
 		return;
 	}
 
 	// everything below here in the closure applies to java projects
 	apply plugin: 'java'
 	apply plugin: 'maven-publish'
 	apply plugin: 'maven-publish-auth'
 	apply plugin: 'osgi'
 
 	apply plugin: 'findbugs'
 	apply plugin: 'checkstyle'
 	apply plugin: 'build-dashboard'
 	apply plugin: 'project-report'
 
 	apply plugin: org.hibernate.build.HibernateBuildPlugin
 
 	configurations {
 		provided {
 			// todo : need to make sure these are non-exported
 			description = 'Non-exported compile-time dependencies.'
 		}
 		jbossLoggingTool {
 			description = 'Dependencies for running the jboss-logging tooling.'
 		}
 		configurations {
 			all*.exclude group: 'xml-apis', module: 'xml-apis'
 		}
 	}
 
 	// appropriately inject the common dependencies into each sub-project
 	dependencies {
-		compile( libraries.logging )
+		compile libraries.logging
+
+		provided libraries.logging_annotations
 
-		jbossLoggingTool( libraries.logging_annotations )
 		jbossLoggingTool( libraries.logging_processor )
 
 		testCompile( libraries.junit )
 		testCompile( libraries.byteman )
 		testCompile( libraries.byteman_install )
 		testCompile( libraries.byteman_bmunit )
 
 		testRuntime( libraries.log4j )
 		testRuntime( libraries.javassist )
 		testRuntime( libraries.h2 )
 		testRuntime( libraries.woodstox )
 
 		// 6.6 gave me some NPE problems from within checkstyle...
 		checkstyle 'com.puppycrawl.tools:checkstyle:6.5'
 	}
 
 	// mac-specific stuff ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// should really use Jvm.current().toolsJar
 	ext.toolsJar = file("${System.getProperty('java.home')}/../lib/tools.jar")
 	if ( ext.toolsJar.exists() ) {
 		dependencies{
 			testCompile files( toolsJar )
 		}
 	}
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	task compile
 	compile.dependsOn compileJava, processResources, compileTestJava, processTestResources
 
 	sourceSets.main {
 		compileClasspath += configurations.provided
 		compileClasspath += configurations.jbossLoggingTool
 	}
 
 	jar {
 		manifest = osgiManifest {
 			// GRADLE-1411: Even if we override Imports and Exports
 			// auto-generation with instructions, classesDir and classpath
 			// need to be here (temporarily).
 			classesDir = sourceSets.main.output.classesDir
 			classpath = configurations.runtime
 
 			instruction 'Import-Package',
 				// Temporarily support JTA 1.1 -- Karaf and other frameworks still
 				// use it.  Without this, the plugin generates [1.2,2).
 				'javax.transaction;version="[1.1,2)"',
 				// Tell Gradle OSGi to still dynamically import the other packages.
 				// IMPORTANT: Do not include the * in the modules' .gradle files.
 				// If it exists more than once, the manifest will physically contain a *.
 				'*'
 
 			instruction 'Bundle-Vendor', 'Hibernate.org'
 			instruction 'Bundle-Description', subProject.osgiDescription()
 			instruction 'Implementation-Url', 'http://hibernate.org'
 			instruction 'Implementation-Version', version
 			instruction 'Implementation-Vendor', 'Hibernate.org'
 			instruction 'Implementation-Vendor-Id', 'org.hibernate'
 		}
 	}
 
 	test {
 		systemProperties['hibernate.test.validatefailureexpected'] = true
 		systemProperties += System.properties.findAll { it.key.startsWith( "hibernate.") }
 
 //		beforeTest { descriptor ->
 //			println "Starting test: " + descriptor
 //		}
 
 //		afterTest { descriptor ->
 //			println "Completed test: " + descriptor
 //		}
 	}
 
 	processTestResources.doLast( {
 		copy {
 			from( sourceSets.test.java.srcDirs ) {
 				include '**/*.properties'
 				include '**/*.xml'
 			}
 			into sourceSets.test.output.classesDir
 		}
 	} )
 
 	idea {
 		module {
 			jdkName = javaTarget.version
 
 			excludeDirs = [file( ".gradle" )]
 			excludeDirs += file( "$buildDir/classes" )
 			excludeDirs += file( "$buildDir/bundles" )
 			excludeDirs += file( "$buildDir/packages" )
 			excludeDirs += file( "$buildDir/dependency-cache" )
 			excludeDirs += file( "$buildDir/libs" )
 			excludeDirs += file( "$buildDir/reports" )
 			excludeDirs += file( "$buildDir/test-results" )
 			excludeDirs += file( "$buildDir/tmp" )
 			excludeDirs += file( "$buildDir/matrix" )
 			excludeDirs += file( "$buildDir/resources" )
 
 			downloadSources = true
 			scopes.PROVIDED.plus += [configurations.provided]
 		}
 	}
 
 	eclipse {
 		jdt {
 			sourceCompatibility = javaTarget.version
 			targetCompatibility = javaTarget.version
 		}
 		classpath {
 			plusConfigurations.add( configurations.provided )
 		}
 	}
 
 	// eclipseClasspath will not add sources to classpath unless the dirs actually exist.
 	// TODO: Eclipse's annotation processor handling is also fairly stupid (and completely lacks in the
 	// Gradle plugin).  For now, just compile first in order to get the logging classes.
 	eclipseClasspath.dependsOn compile
 
 
 	// Report configs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	checkstyle {
 		sourceSets = [ subProject.sourceSets.main ]
 		configFile = rootProject.file( 'shared/config/checkstyle/checkstyle.xml' )
 		showViolations = false
 	}
 	// exclude generated java sources - by explicitly setting the base source dir
 	checkstyleMain.source = 'src/main/java'
 
 	findbugs {
 		sourceSets = [ subProject.sourceSets.main, subProject.sourceSets.test ]
 		ignoreFailures = true
 		toolVersion = '3.0.1'
 		// for now we need to set this to low so that FindBugs will actually report the DM_CONVERT_CASE warning we care about
 		reportLevel = 'low'
 		// remove all low level bug warnings except DM_CONVERT_CASE
 		excludeFilterConfig=resources.text.fromString(excludeAllLowLevelBugsExcept('DM_CONVERT_CASE'))
 	}
 
 	// exclude generated java sources and cfg package is a mess mainly from annotation stuff
 	findbugsMain.doFirst {
 		classes = classes.filter {
 			!it.path.contains( 'org/hibernate/hql/internal/antlr' ) &&
 					!it.path.contains( 'org/hibernate/boot/jaxb/cfg/spi' ) &&
 					!it.path.contains( 'org/hibernate/sql/ordering/antlr/Generated' ) &&
 					!it.path.contains( 'org/hibernate/sql/ordering/antlr/OrderByTemplateTokenTypes' ) &&
 					!it.path.contains( 'org/hibernate/boot/jaxb/hbm/spi/Jaxb' ) &&
 					!it.path.contains( 'org/hibernate/boot/jaxb/hbm/spi/Adapter' ) &&
 					!it.path.contains( 'org/hibernate/boot/jaxb/hbm/spi/ObjectFactory' ) &&
 					!it.path.contains( 'org/hibernate/cfg' ) &&
 					!it.path.contains( '_\$logger' )
 		}
 	}
 
 		// because cfg package is a mess mainly from annotation stuff
 	checkstyleMain.exclude '**/org/hibernate/cfg/**'
 	checkstyleMain.exclude '**/org/hibernate/cfg/*'
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
 	publishing {
 		publications {
 			mavenJava(MavenPublication) {
 				from components.java
 
 				artifact( sourcesJar ) {
 					classifier 'sources'
 				}
 			}
 			// http://issues.gradle.org/browse/GRADLE-2966
 			// Once ^^ is resolved:
 			//		1) Move hibernate-testing module into hibernate-core tests
 			//		2) Define a second publication on hibernate-core for publishing the testing jar
 			// We could kind of do this now, but it would just be the jar.  Every module would still need
 			// to duplicate the testing dependencies.  Well, on second thought, we could centralize the
 			// testing dependencies here within the subprojects block
 		}
 	}
 
 	model {
 		tasks.generatePomFileForMavenJavaPublication {
 			destination = file( "$subProject.buildDir/generated-pom.xml" )
 		}
 	}
 
 	task sourcesJar(type: Jar, dependsOn: compileJava) {
 		from sourceSets.main.allSource
 		classifier = 'sources'
 	}
 }
 
 task release(type: Task, dependsOn: 'release:release')
 
 task wrapper(type: Wrapper) {
     gradleVersion = expectedGradleVersion
 }
 
 def excludeAllLowLevelBugsExcept(String[] bugTypes){
 	def writer = new StringWriter()
 	def xml = new groovy.xml.MarkupBuilder(writer);
 	xml.FindBugsFilter {
 		Match {
 			Confidence( value: '3' )
 			bugTypes.each { bug ->
 				Not {
 					Bug( pattern: "${bug}" )
 				}
 			}
 		}
 	}
 	return writer.toString(  )
 }
diff --git a/documentation/src/main/docbook/manual/en-US/content/basic_mapping.xml b/documentation/src/main/docbook/manual/en-US/content/basic_mapping.xml
index d7829a5d06..42d35ba610 100644
--- a/documentation/src/main/docbook/manual/en-US/content/basic_mapping.xml
+++ b/documentation/src/main/docbook/manual/en-US/content/basic_mapping.xml
@@ -2036,2001 +2036,2001 @@ public class CustomerInventory implements Serializable {
   @Id
   @TableGenerator(name = "inventory",
     table = "U_SEQUENCES",
     pkColumnName = "S_ID",
     valueColumnName = "S_NEXTNUM",
     pkColumnValue = "inventory",
     allocationSize = 1000)
   @GeneratedValue(strategy = GenerationType.TABLE, generator = "inventory")
   Integer id;
 
 
   @Id @ManyToOne(cascade = CascadeType.MERGE)
   Customer customer;
 }
 
 @Entity
 public class Customer implements Serializable {
    @Id
    private int id;
 }</programlisting>
 
         <para>You can also generate properties inside an
         <classname>@EmbeddedId</classname> class.</para>
       </section>
     </section>
 
     <section>
       <title>Optimistic locking properties (optional)</title>
 
       <para>When using long transactions or conversations that span several
       database transactions, it is useful to store versioning data to ensure
       that if the same entity is updated by two conversations, the last to
       commit changes will be informed and not override the other
       conversation's work. It guarantees some isolation while still allowing
       for good scalability and works particularly well in read-often
       write-sometimes situations.</para>
 
       <para>You can use two approaches: a dedicated version number or a
       timestamp.</para>
 
       <para>A version or timestamp property should never be null for a
       detached instance. Hibernate will detect any instance with a null
       version or timestamp as transient, irrespective of what other
       <literal>unsaved-value</literal> strategies are specified.
       <emphasis>Declaring a nullable version or timestamp property is an easy
       way to avoid problems with transitive reattachment in Hibernate. It is
       especially useful for people using assigned identifiers or composite
       keys</emphasis>.</para>
 
       <section xml:id="entity-mapping-entity-version">
         <title>Version number</title>
 
         <para>You can add optimistic locking capability to an entity using the
         <literal>@Version</literal> annotation:</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 public class Flight implements Serializable {
 ...
     @Version
     @Column(name="OPTLOCK")
     public Integer getVersion() { ... }
 }           </programlisting>
 
         <para>The version property will be mapped to the
         <literal>OPTLOCK</literal> column, and the entity manager will use it
         to detect conflicting updates (preventing lost updates you might
         otherwise see with the last-commit-wins strategy).</para>
 
         <para>The version column may be a numeric. Hibernate supports any kind
         of type provided that you define and implement the appropriate
         <classname>UserVersionType</classname>.</para>
 
         <para>The application must not alter the version number set up by
         Hibernate in any way. To artificially increase the version number,
         check in Hibernate Entity Manager's reference documentation
         <literal>LockModeType.OPTIMISTIC_FORCE_INCREMENT</literal> or
         <literal>LockModeType.PESSIMISTIC_FORCE_INCREMENT</literal>.</para>
 
         <para>If the version number is generated by the database (via a
         trigger for example), make sure to use
         <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code></para>
 
         <para>To declare a version property in hbm.xml, use:</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="version1" />
 
             <area coords="3" xml:id="version2" />
 
             <area coords="4" xml:id="version3" />
 
             <area coords="5" xml:id="version4" />
 
             <area coords="6" xml:id="version5" />
 
             <area coords="7" xml:id="version6" />
 
             <area coords="8" xml:id="version7" />
           </areaspec>
 
           <programlisting>&lt;version
         column="version_column"
         name="propertyName"
         type="typename"
         access="field|property|ClassName"
         unsaved-value="null|negative|undefined"
         generated="never|always"
         insert="true|false"
         node="element-name|@attribute-name|element/@attribute|."
 /&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="version1">
               <para><literal>column</literal> (optional - defaults to the
               property name): the name of the column holding the version
               number.</para>
             </callout>
 
             <callout arearefs="version2">
               <para><literal>name</literal>: the name of a property of the
               persistent class.</para>
             </callout>
 
             <callout arearefs="version3">
               <para><literal>type</literal> (optional - defaults to
               <literal>integer</literal>): the type of the version
               number.</para>
             </callout>
 
             <callout arearefs="version4">
               <para><literal>access</literal> (optional - defaults to
               <literal>property</literal>): the strategy Hibernate uses to
               access the property value.</para>
             </callout>
 
             <callout arearefs="version5">
               <para><literal>unsaved-value</literal> (optional - defaults to
               <literal>undefined</literal>): a version property value that
               indicates that an instance is newly instantiated (unsaved),
               distinguishing it from detached instances that were saved or
               loaded in a previous session. <literal>Undefined</literal>
               specifies that the identifier property value should be
               used.</para>
             </callout>
 
             <callout arearefs="version6">
               <para><literal>generated</literal> (optional - defaults to
               <literal>never</literal>): specifies that this version property
               value is generated by the database. See the discussion of <link
               linkend="mapping-generated">generated properties</link> for more
               information.</para>
             </callout>
 
             <callout arearefs="version7">
               <para><literal>insert</literal> (optional - defaults to
               <literal>true</literal>): specifies whether the version column
               should be included in SQL insert statements. It can be set to
               <literal>false</literal> if the database column is defined with
               a default value of <literal>0</literal>.</para>
             </callout>
           </calloutlist>
         </programlistingco>
       </section>
 
       <section xml:id="mapping-declaration-timestamp" revision="4">
         <title>Timestamp</title>
 
         <para>Alternatively, you can use a timestamp. Timestamps are a less
         safe implementation of optimistic locking. However, sometimes an
         application might use the timestamps in other ways as well.</para>
 
         <para>Simply mark a property of type <classname>Date</classname> or
         <classname>Calendar</classname> as
         <classname>@Version</classname>.</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 public class Flight implements Serializable {
 ...
     @Version
     public Date getLastUpdate() { ... }
 }           </programlisting>
 
         <para>When using timestamp versioning you can tell Hibernate where to
         retrieve the timestamp value from - database or JVM - by optionally
         adding the <classname>@org.hibernate.annotations.Source</classname>
         annotation to the property. Possible values for the value attribute of
         the annotation are
         <classname>org.hibernate.annotations.SourceType.VM</classname> and
         <classname>org.hibernate.annotations.SourceType.DB</classname>. The
         default is <classname>SourceType.DB</classname> which is also used in
         case there is no <classname>@Source</classname> annotation at
         all.</para>
 
         <para>Like in the case of version numbers, the timestamp can also be
         generated by the database instead of Hibernate. To do that, use
         <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code></para>
 
         <para>In hbm.xml, use the <literal>&lt;timestamp&gt;</literal>
         element:</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="timestamp1" />
 
             <area coords="3" xml:id="timestamp2" />
 
             <area coords="4" xml:id="timestamp3" />
 
             <area coords="5" xml:id="timestamp4" />
 
             <area coords="6" xml:id="timestamp5" />
 
             <area coords="7" xml:id="timestamp6" />
           </areaspec>
 
           <programlisting>&lt;timestamp
         column="timestamp_column"
         name="propertyName"
         access="field|property|ClassName"
         unsaved-value="null|undefined"
         source="vm|db"
         generated="never|always"
         node="element-name|@attribute-name|element/@attribute|."
 /&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="timestamp1">
               <para><literal>column</literal> (optional - defaults to the
               property name): the name of a column holding the
               timestamp.</para>
             </callout>
 
             <callout arearefs="timestamp2">
               <para><literal>name</literal>: the name of a JavaBeans style
               property of Java type <literal>Date</literal> or
               <literal>Timestamp</literal> of the persistent class.</para>
             </callout>
 
             <callout arearefs="timestamp3">
               <para><literal>access</literal> (optional - defaults to
               <literal>property</literal>): the strategy Hibernate uses for
               accessing the property value.</para>
             </callout>
 
             <callout arearefs="timestamp4">
               <para><literal>unsaved-value</literal> (optional - defaults to
               <literal>null</literal>): a version property value that
               indicates that an instance is newly instantiated (unsaved),
               distinguishing it from detached instances that were saved or
               loaded in a previous session. <literal>Undefined</literal>
               specifies that the identifier property value should be
               used.</para>
             </callout>
 
             <callout arearefs="timestamp5">
               <para><literal>source</literal> (optional - defaults to
               <literal>vm</literal>): Where should Hibernate retrieve the
               timestamp value from? From the database, or from the current
               JVM? Database-based timestamps incur an overhead because
               Hibernate must hit the database in order to determine the "next
               value". It is safer to use in clustered environments. Not all
               <literal>Dialects</literal> are known to support the retrieval
               of the database's current timestamp. Others may also be unsafe
               for usage in locking due to lack of precision (Oracle 8, for
               example).</para>
             </callout>
 
             <callout arearefs="timestamp6">
               <para><literal>generated</literal> (optional - defaults to
               <literal>never</literal>): specifies that this timestamp
               property value is actually generated by the database. See the
               discussion of <link linkend="mapping-generated">generated
               properties</link> for more information.</para>
             </callout>
           </calloutlist>
         </programlistingco>
 
         <note>
           <title>Note</title>
 
           <para><literal>&lt;Timestamp&gt;</literal> is equivalent to
           <literal>&lt;version type="timestamp"&gt;</literal>. And
           <literal>&lt;timestamp source="db"&gt;</literal> is equivalent to
           <literal>&lt;version type="dbtimestamp"&gt;</literal></para>
         </note>
       </section>
     </section>
 
     <section xml:id="mapping-declaration-property" revision="5">
       <title>Property</title>
 
       <para>You need to decide which property needs to be made persistent in a
       given entity. This differs slightly between the annotation driven
       metadata and the hbm.xml files.</para>
 
       <section>
         <title>Property mapping with annotations</title>
 
         <para>In the annotations world, every non static non transient
         property (field or method depending on the access type) of an entity
         is considered persistent, unless you annotate it as
         <literal>@Transient</literal>. Not having an annotation for your
         property is equivalent to the appropriate <literal>@Basic</literal>
         annotation.</para>
 
         <para>The <literal>@Basic</literal> annotation allows you to declare
         the fetching strategy for a property. If set to
         <literal>LAZY</literal>, specifies that this property should be
         fetched lazily when the instance variable is first accessed. It
         requires build-time bytecode instrumentation, if your classes are not
         instrumented, property level lazy loading is silently ignored. The
         default is <literal>EAGER</literal>. You can also mark a property as
         not optional thanks to the <classname>@Basic.optional</classname>
         attribute. This will ensure that the underlying column are not
         nullable (if possible). Note that a better approach is to use the
         <classname>@NotNull</classname> annotation of the Bean Validation
         specification.</para>
 
         <para>Let's look at a few examples:</para>
 
         <programlisting language="JAVA" role="JAVA">public transient int counter; //transient property
 
 private String firstname; //persistent property
 
 @Transient
 String getLengthInMeter() { ... } //transient property
 
 String getName() {... } // persistent property
 
 @Basic
 int getLength() { ... } // persistent property
 
 @Basic(fetch = FetchType.LAZY)
 String getDetailedComment() { ... } // persistent property
 
 @Temporal(TemporalType.TIME)
 java.util.Date getDepartureTime() { ... } // persistent property           
 
 @Enumerated(EnumType.STRING)
 Starred getNote() { ... } //enum persisted as String in database</programlisting>
 
         <para><literal>counter</literal>, a transient field, and
         <literal>lengthInMeter</literal>, a method annotated as
         <literal>@Transient</literal>, and will be ignored by the Hibernate.
         <literal>name</literal>, <literal>length</literal>, and
         <literal>firstname</literal> properties are mapped persistent and
         eagerly fetched (the default for simple properties). The
         <literal>detailedComment</literal> property value will be lazily
         fetched from the database once a lazy property of the entity is
         accessed for the first time. Usually you don't need to lazy simple
         properties (not to be confused with lazy association fetching). The
         recommended alternative is to use the projection capability of JP-QL
         (Java Persistence Query Language) or Criteria queries.</para>
 
         <para>JPA support property mapping of all basic types supported by
         Hibernate (all basic Java types , their respective wrappers and
         serializable classes). Hibernate Annotations supports out of the box
         enum type mapping either into a ordinal column (saving the enum
         ordinal) or a string based column (saving the enum string
         representation): the persistence representation, defaulted to ordinal,
         can be overridden through the <literal>@Enumerated</literal>
         annotation as shown in the <literal>note</literal> property
         example.</para>
 
         <para>In plain Java APIs, the temporal precision of time is not
         defined. When dealing with temporal data you might want to describe
         the expected precision in database. Temporal data can have
         <literal>DATE</literal>, <literal>TIME</literal>, or
         <literal>TIMESTAMP</literal> precision (ie the actual date, only the
         time, or both). Use the <literal>@Temporal</literal> annotation to
         fine tune that.</para>
 
         <para><literal>@Lob</literal> indicates that the property should be
         persisted in a Blob or a Clob depending on the property type:
         <classname>java.sql.Clob</classname>,
         <classname>Character[]</classname>, <classname>char[]</classname> and
         java.lang.<classname>String</classname> will be persisted in a Clob.
         <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>,
         <classname>byte[] </classname>and <classname>Serializable</classname>
         type will be persisted in a Blob.</para>
 
         <programlisting language="JAVA" role="JAVA">@Lob
 public String getFullText() {
     return fullText;
 }
 
 @Lob
 public byte[] getFullCode() {
     return fullCode;
 }</programlisting>
 
         <para>If the property type implements
         <classname>java.io.Serializable</classname> and is not a basic type,
         and if the property is not annotated with <literal>@Lob</literal>,
         then the Hibernate <literal>serializable</literal> type is
         used.</para>
 
         <section>
           <title>Type</title>
 
           <para>You can also manually specify a type using the
           <literal>@org.hibernate.annotations.Type</literal> and some
           parameters if needed. <classname>@Type.type</classname> could
           be:</para>
 
           <orderedlist spacing="compact">
             <listitem>
               <para>The name of a Hibernate basic type: <literal>integer,
               string, character, date, timestamp, float, binary, serializable,
               object, blob</literal> etc.</para>
             </listitem>
 
             <listitem>
               <para>The name of a Java class with a default basic type:
               <literal>int, float, char, java.lang.String, java.util.Date,
               java.lang.Integer, java.sql.Clob</literal> etc.</para>
             </listitem>
 
             <listitem>
               <para>The name of a serializable Java class.</para>
             </listitem>
 
             <listitem>
               <para>The class name of a custom type:
               <literal>com.illflow.type.MyCustomType</literal> etc.</para>
             </listitem>
           </orderedlist>
 
           <para>If you do not specify a type, Hibernate will use reflection
           upon the named property and guess the correct Hibernate type.
           Hibernate will attempt to interpret the name of the return class of
           the property getter using, in order, rules 2, 3, and 4.</para>
 
           <para><literal>@org.hibernate.annotations.TypeDef</literal> and
           <literal>@org.hibernate.annotations.TypeDefs</literal> allows you to
           declare type definitions. These annotations can be placed at the
           class or package level. Note that these definitions are global for
           the session factory (even when defined at the class level). If the
           type is used on a single entity, you can place the definition on the
           entity itself. Otherwise, it is recommended to place the definition
           at the package level. In the example below, when Hibernate
           encounters a property of class <literal>PhoneNumer</literal>, it
           delegates the persistence strategy to the custom mapping type
           <literal>PhoneNumberType</literal>. However, properties belonging to
           other classes, too, can delegate their persistence strategy to
           <literal>PhoneNumberType</literal>, by explicitly using the
           <literal>@Type</literal> annotation.</para>
 
           <note>
             <para>Package level annotations are placed in a file named
             <filename>package-info.java</filename> in the appropriate package.
             Place your annotations before the package declaration.</para>
           </note>
 
           <programlisting language="JAVA" role="JAVA">@TypeDef(
    name = "phoneNumber",
    defaultForType = PhoneNumber.class,
    typeClass = PhoneNumberType.class
 )
 
 @Entity
 public class ContactDetails {
    [...]
    private PhoneNumber localPhoneNumber;
    @Type(type="phoneNumber")
    private OverseasPhoneNumber overseasPhoneNumber;
    [...]
 }</programlisting>
 
           <para>The following example shows the usage of the
           <literal>parameters</literal> attribute to customize the
           TypeDef.</para>
 
           <programlisting language="JAVA" role="JAVA">//in org/hibernate/test/annotations/entity/package-info.java
 @TypeDefs(
     {
     @TypeDef(
         name="caster",
         typeClass = CasterStringType.class,
         parameters = {
             @Parameter(name="cast", value="lower")
         }
     )
     }
 )
 package org.hibernate.test.annotations.entity;
 
 //in org/hibernate/test/annotations/entity/Forest.java
 public class Forest {
     @Type(type="caster")
     public String getSmallText() {
     ...
 }      </programlisting>
 
           <para>When using composite user type, you will have to express
           column definitions. The <literal>@Columns</literal> has been
           introduced for that purpose.</para>
 
           <programlisting language="JAVA" role="JAVA">@Type(type="org.hibernate.test.annotations.entity.MonetaryAmountUserType")
 @Columns(columns = {
     @Column(name="r_amount"),
     @Column(name="r_currency")
 })
 public MonetaryAmount getAmount() {
     return amount;
 }
 
 
 public class MonetaryAmount implements Serializable {
     private BigDecimal amount;
     private Currency currency;
     ...
 }</programlisting>
         </section>
 
         <section>
           <title>Access type</title>
 
           <para>By default the access type of a class hierarchy is defined by
           the position of the <classname>@Id</classname> or
           <classname>@EmbeddedId</classname> annotations. If these annotations
           are on a field, then only fields are considered for persistence and
           the state is accessed via the field. If these annotations are on a
           getter, then only the getters are considered for persistence and the
           state is accessed via the getter/setter. That works well in practice
           and is the recommended approach.<note>
               <para>The placement of annotations within a class hierarchy has
               to be consistent (either field or on property) to be able to
               determine the default access type. It is recommended to stick to
               one single annotation placement strategy throughout your whole
               application.</para>
             </note></para>
 
           <para>However in some situations, you need to:</para>
 
           <itemizedlist>
             <listitem>
               <para>force the access type of the entity hierarchy</para>
             </listitem>
 
             <listitem>
               <para>override the access type of a specific entity in the class
               hierarchy</para>
             </listitem>
 
             <listitem>
               <para>override the access type of an embeddable type</para>
             </listitem>
           </itemizedlist>
 
           <para>The best use case is an embeddable class used by several
           entities that might not use the same access type. In this case it is
           better to force the access type at the embeddable class
           level.</para>
 
           <para>To force the access type on a given class, use the
           <classname>@Access</classname> annotation as showed below:</para>
 
           <programlisting language="JAVA" role="JAVA">@Entity
 public class Order {
    @Id private Long id;
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
 
    @Embedded private Address address;
    public Address getAddress() { return address; }
    public void setAddress() { this.address = address; }
 }
 
 @Entity
 public class User {
    private Long id;
    @Id public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
 
    private Address address;
    @Embedded public Address getAddress() { return address; }
    public void setAddress() { this.address = address; }
 }
 
 @Embeddable
 @Access(AcessType.PROPERTY)
 public class Address {
    private String street1;
    public String getStreet1() { return street1; }
    public void setStreet1() { this.street1 = street1; }
 
    private hashCode; //not persistent
 }</programlisting>
 
           <para>You can also override the access type of a single property
           while keeping the other properties standard.</para>
 
           <programlisting language="JAVA" role="JAVA">@Entity
 public class Order {
    @Id private Long id;
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    @Transient private String userId;
    @Transient private String orderId;
 
    @Access(AccessType.PROPERTY)
    public String getOrderNumber() { return userId + ":" + orderId; }
    public void setOrderNumber() { this.userId = ...; this.orderId = ...; }
 }</programlisting>
 
           <para>In this example, the default access type is
           <classname>FIELD</classname> except for the
           <literal>orderNumber</literal> property. Note that the corresponding
           field, if any must be marked as <classname>@Transient</classname> or
           <code>transient</code>.</para>
 
           <note>
             <title>@org.hibernate.annotations.AccessType</title>
 
             <para>The annotation
             <classname>@org.hibernate.annotations.AccessType</classname>
             should be considered deprecated for FIELD and PROPERTY access. It
             is still useful however if you need to use a custom access
             type.</para>
           </note>
         </section>
 
         <section>
           <title>Optimistic lock</title>
 
           <para>It is sometimes useful to avoid increasing the version number
           even if a given property is dirty (particularly collections). You
           can do that by annotating the property (or collection) with
           <literal>@OptimisticLock(excluded=true)</literal>.</para>
 
           <para>More formally, specifies that updates to this property do not
           require acquisition of the optimistic lock.</para>
         </section>
 
         <section xml:id="entity-mapping-property-column">
           <title>Declaring column attributes</title>
 
           <para>The column(s) used for a property mapping can be defined using
           the <literal>@Column</literal> annotation. Use it to override
           default values (see the JPA specification for more information on
           the defaults). You can use this annotation at the property level for
           properties that are:</para>
 
           <itemizedlist>
             <listitem>
               <para>not annotated at all</para>
             </listitem>
 
             <listitem>
               <para>annotated with <literal>@Basic</literal></para>
             </listitem>
 
             <listitem>
               <para>annotated with <literal>@Version</literal></para>
             </listitem>
 
             <listitem>
               <para>annotated with <literal>@Lob</literal></para>
             </listitem>
 
             <listitem>
               <para>annotated with <literal>@Temporal</literal></para>
             </listitem>
           </itemizedlist>
 
           <programlisting language="JAVA" role="JAVA">
 @Entity
 public class Flight implements Serializable {
 ...
 @Column(updatable = false, name = "flight_name", nullable = false, length=50)
 public String getName() { ... }
             </programlisting>
 
           <para>The <literal>name</literal> property is mapped to the
           <literal>flight_name</literal> column, which is not nullable, has a
           length of 50 and is not updatable (making the property
           immutable).</para>
 
           <para>This annotation can be applied to regular properties as well
           as <literal>@Id</literal> or <literal>@Version</literal>
           properties.</para>
 
           <programlistingco>
             <areaspec>
               <area coords="2" xml:id="hm1" />
 
               <area coords="3" xml:id="hm2" />
 
               <area coords="4" xml:id="hm3" />
 
               <area coords="5" xml:id="hm4" />
 
               <area coords="6" xml:id="hm5" />
 
               <area coords="7" xml:id="hm6" />
 
               <area coords="8" xml:id="hm7" />
 
               <area coords="9" xml:id="hm8" />
 
               <area coords="10" xml:id="hm9" />
 
               <area coords="11" xml:id="hm10" />
             </areaspec>
 
             <programlisting>@Column(
     name="columnName";
     boolean unique() default false;
     boolean nullable() default true;
     boolean insertable() default true;
     boolean updatable() default true;
     String columnDefinition() default "";
     String table() default "";
     int length() default 255;
     int precision() default 0; // decimal precision
     int scale() default 0; // decimal scale</programlisting>
 
             <calloutlist>
               <callout arearefs="hm1">
                 <para><literal>name</literal> (optional): the column name
                 (default to the property name)</para>
               </callout>
 
               <callout arearefs="hm2">
                 <para><literal>unique</literal> (optional): set a unique
                 constraint on this column or not (default false)</para>
               </callout>
 
               <callout arearefs="hm3">
                 <para><literal>nullable</literal> (optional): set the column
                 as nullable (default true).</para>
               </callout>
 
               <callout arearefs="hm4">
                 <para><literal>insertable</literal> (optional): whether or not
                 the column will be part of the insert statement (default
                 true)</para>
               </callout>
 
               <callout arearefs="hm5">
                 <para><literal>updatable</literal> (optional): whether or not
                 the column will be part of the update statement (default
                 true)</para>
               </callout>
 
               <callout arearefs="hm6">
                 <para><literal>columnDefinition</literal> (optional): override
                 the sql DDL fragment for this particular column (non
                 portable)</para>
               </callout>
 
               <callout arearefs="hm7">
                 <para><literal>table</literal> (optional): define the targeted
                 table (default primary table)</para>
               </callout>
 
               <callout arearefs="hm8">
                 <para><literal>length</literal> (optional):
                 column length (default 255)</para>
               </callout>
 
               <callout arearefs="hm8">
                 <para><literal>precision</literal>
                 (optional): column decimal precision (default 0)</para>
               </callout>
 
               <callout arearefs="hm10">
                 <para><literal>scale</literal> (optional):
                 column decimal scale if useful (default 0)</para>
               </callout>
             </calloutlist>
           </programlistingco>
         </section>
 
         <section>
           <title>Formula</title>
 
           <para>Sometimes, you want the Database to do some computation for
           you rather than in the JVM, you might also create some kind of
           virtual column. You can use a SQL fragment (aka formula) instead of
           mapping a property into a column. This kind of property is read only
           (its value is calculated by your formula fragment).</para>
 
           <programlisting language="JAVA" role="JAVA">@Formula("obj_length * obj_height * obj_width")
 public long getObjectVolume()</programlisting>
 
           <para>The SQL fragment can be as complex as you want and even
           include subselects.</para>
         </section>
 
         <section>
           <title>Non-annotated property defaults</title>
 
           <para>If a property is not annotated, the following rules
           apply:<itemizedlist>
               <listitem>
                 <para>If the property is of a single type, it is mapped as
                 @Basic</para>
               </listitem>
 
               <listitem>
                 <para>Otherwise, if the type of the property is annotated as
                 @Embeddable, it is mapped as @Embedded</para>
               </listitem>
 
               <listitem>
                 <para>Otherwise, if the type of the property is
                 <classname>Serializable</classname>, it is mapped as
                 <classname>@Basic</classname> in a column holding the object
                 in its serialized version</para>
               </listitem>
 
               <listitem>
                 <para>Otherwise, if the type of the property is
                 <classname>java.sql.Clob</classname> or
                 <classname>java.sql.Blob</classname>, it is mapped as
                 <classname>@Lob</classname> with the appropriate
                 <classname>LobType</classname></para>
               </listitem>
             </itemizedlist></para>
         </section>
       </section>
 
       <section>
         <title>Property mapping with hbm.xml</title>
 
         <para>The <literal>&lt;property&gt;</literal> element declares a
         persistent JavaBean style property of the class.</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="property1" />
 
             <area coords="3" xml:id="property2" />
 
             <area coords="4" xml:id="property3" />
 
             <areaset coords="" xml:id="property4-5">
               <area coords="5" xml:id="property4" />
 
               <area coords="6" xml:id="property5" />
             </areaset>
 
             <area coords="7" xml:id="property6" />
 
             <area coords="8" xml:id="property7" />
 
             <area coords="9" xml:id="property8" />
 
             <area coords="10" xml:id="property9" />
 
             <area coords="11" xml:id="property10" />
 
             <area coords="12" xml:id="property11" />
 
             <area coords="13" xml:id="property12" />
           </areaspec>
 
           <programlisting>&lt;property
         name="propertyName"
         column="column_name"
         type="typename"
         update="true|false"
         insert="true|false"
         formula="arbitrary SQL expression"
         access="field|property|ClassName"
         lazy="true|false"
         unique="true|false"
         not-null="true|false"
         optimistic-lock="true|false"
         generated="never|insert|always"
         node="element-name|@attribute-name|element/@attribute|."
         index="index_name"
         unique_key="unique_key_id"
         length="L"
         precision="P"
         scale="S"
 /&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="property1">
               <para><literal>name</literal>: the name of the property, with an
               initial lowercase letter.</para>
             </callout>
 
             <callout arearefs="property2">
               <para><literal>column</literal> (optional - defaults to the
               property name): the name of the mapped database table column.
               This can also be specified by nested
               <literal>&lt;column&gt;</literal> element(s).</para>
             </callout>
 
             <callout arearefs="property3">
               <para><literal>type</literal> (optional): a name that indicates
               the Hibernate type.</para>
             </callout>
 
             <callout arearefs="property4-5">
               <para><literal>update, insert</literal> (optional - defaults to
               <literal>true</literal>): specifies that the mapped columns
               should be included in SQL <literal>UPDATE</literal> and/or
               <literal>INSERT</literal> statements. Setting both to
               <literal>false</literal> allows a pure "derived" property whose
               value is initialized from some other property that maps to the
               same column(s), or by a trigger or other application.</para>
             </callout>
 
             <callout arearefs="property6">
               <para><literal>formula</literal> (optional): an SQL expression
               that defines the value for a <emphasis>computed</emphasis>
               property. Computed properties do not have a column mapping of
               their own.</para>
             </callout>
 
             <callout arearefs="property7">
               <para><literal>access</literal> (optional - defaults to
               <literal>property</literal>): the strategy Hibernate uses for
               accessing the property value.</para>
             </callout>
 
             <callout arearefs="property8">
               <para><literal>lazy</literal> (optional - defaults to
               <literal>false</literal>): specifies that this property should
               be fetched lazily when the instance variable is first accessed.
               It requires build-time bytecode instrumentation.</para>
             </callout>
 
             <callout arearefs="property9">
               <para><literal>unique</literal> (optional): enables the DDL
               generation of a unique constraint for the columns. Also, allow
               this to be the target of a
               <literal>property-ref</literal>.</para>
             </callout>
 
             <callout arearefs="property10">
               <para><literal>not-null</literal> (optional): enables the DDL
               generation of a nullability constraint for the columns.</para>
             </callout>
 
             <callout arearefs="property11">
               <para><literal>optimistic-lock</literal> (optional - defaults to
               <literal>true</literal>): specifies that updates to this
               property do or do not require acquisition of the optimistic
               lock. In other words, it determines if a version increment
               should occur when this property is dirty.</para>
             </callout>
 
             <callout arearefs="property12">
               <para><literal>generated</literal> (optional - defaults to
               <literal>never</literal>): specifies that this property value is
               actually generated by the database. See the discussion of <link
               linkend="mapping-generated">generated properties</link> for more
               information.</para>
             </callout>
           </calloutlist>
         </programlistingco>
 
         <para><emphasis>typename</emphasis> could be:</para>
 
         <orderedlist spacing="compact">
           <listitem>
             <para>The name of a Hibernate basic type: <literal>integer,
             string, character, date, timestamp, float, binary, serializable,
             object, blob</literal> etc.</para>
           </listitem>
 
           <listitem>
             <para>The name of a Java class with a default basic type:
             <literal>int, float, char, java.lang.String, java.util.Date,
             java.lang.Integer, java.sql.Clob</literal> etc.</para>
           </listitem>
 
           <listitem>
             <para>The name of a serializable Java class.</para>
           </listitem>
 
           <listitem>
             <para>The class name of a custom type:
             <literal>com.illflow.type.MyCustomType</literal> etc.</para>
           </listitem>
         </orderedlist>
 
         <para>If you do not specify a type, Hibernate will use reflection upon
         the named property and guess the correct Hibernate type. Hibernate
         will attempt to interpret the name of the return class of the property
         getter using, in order, rules 2, 3, and 4. In certain cases you will
         need the <literal>type</literal> attribute. For example, to
         distinguish between <literal>Hibernate.DATE</literal> and
         <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom
         type.</para>
 
         <para>The <literal>access</literal> attribute allows you to control
         how Hibernate accesses the property at runtime. By default, Hibernate
         will call the property get/set pair. If you specify
         <literal>access="field"</literal>, Hibernate will bypass the get/set
         pair and access the field directly using reflection. You can specify
         your own strategy for property access by naming a class that
         implements the interface
-        <literal>org.hibernate.property.PropertyAccessor</literal>.</para>
+        <literal>org.hibernate.property.access.spi.PropertyAccessStrategy</literal>.</para>
 
         <para>A powerful feature is derived properties. These properties are
         by definition read-only. The property value is computed at load time.
         You declare the computation as an SQL expression. This then translates
         to a <literal>SELECT</literal> clause subquery in the SQL query that
         loads an instance:</para>
 
         <programlisting role="XML">
 &lt;property name="totalPrice"
     formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                 WHERE li.productId = p.productId
                 AND li.customerId = customerId
                 AND li.orderNumber = orderNumber )"/&gt;</programlisting>
 
         <para>You can reference the entity table by not declaring an alias on
         a particular column. This would be <literal>customerId</literal> in
         the given example. You can also use the nested
         <literal>&lt;formula&gt;</literal> mapping element if you do not want
         to use the attribute.</para>
       </section>
     </section>
 
     <section xml:id="mapping-declaration-component">
       <title>Embedded objects (aka components)</title>
 
       <para>Embeddable objects (or components) are objects whose properties
       are mapped to the same table as the owning entity's table. Components
       can, in turn, declare their own properties, components or
       collections</para>
 
       <para>It is possible to declare an embedded component inside an entity
       and even override its column mapping. Component classes have to be
       annotated at the class level with the <literal>@Embeddable</literal>
       annotation. It is possible to override the column mapping of an embedded
       object for a particular entity using the <literal>@Embedded</literal>
       and <literal>@AttributeOverride</literal> annotation in the associated
       property:</para>
 
       <programlisting language="JAVA" role="JAVA">@Entity
 public class Person implements Serializable {
 
     // Persistent component using defaults
     Address homeAddress;
 
     @Embedded
     @AttributeOverrides( {
             @AttributeOverride(name="iso2", column = @Column(name="bornIso2") ),
             @AttributeOverride(name="name", column = @Column(name="bornCountryName") )
     } )
     Country bornIn;
     ...
 }          </programlisting>
 
       <programlisting language="JAVA" role="JAVA">@Embeddable
 public class Address implements Serializable {
     String city;
     Country nationality; //no overriding here
 }            </programlisting>
 
       <programlisting language="JAVA" role="JAVA">@Embeddable
 public class Country implements Serializable {
     private String iso2;
     @Column(name="countryName") private String name;
 
     public String getIso2() { return iso2; }
     public void setIso2(String iso2) { this.iso2 = iso2; }
 
     
     public String getName() { return name; }
     public void setName(String name) { this.name = name; }
     ...
 }            </programlisting>
 
       <para>An embeddable object inherits the access type of its owning entity
       (note that you can override that using the <literal>@Access</literal>
       annotation).</para>
 
       <para>The <literal>Person</literal> entity has two component properties,
       <literal>homeAddress</literal> and <literal>bornIn</literal>.
       <literal>homeAddress</literal> property has not been annotated, but
       Hibernate will guess that it is a persistent component by looking for
       the <literal>@Embeddable</literal> annotation in the Address class. We
       also override the mapping of a column name (to
       <literal>bornCountryName</literal>) with the
       <literal>@Embedded</literal> and <literal>@AttributeOverride
       </literal>annotations for each mapped attribute of
       <literal>Country</literal>. As you can see, <literal>Country
       </literal>is also a nested component of <literal>Address</literal>,
       again using auto-detection by Hibernate and JPA defaults. Overriding
       columns of embedded objects of embedded objects is through dotted
       expressions.</para>
 
       <programlisting language="JAVA" role="JAVA">    @Embedded
     @AttributeOverrides( {
             @AttributeOverride(name="city", column = @Column(name="fld_city") ),
             @AttributeOverride(name="nationality.iso2", column = @Column(name="nat_Iso2") ),
             @AttributeOverride(name="nationality.name", column = @Column(name="nat_CountryName") )
             //nationality columns in homeAddress are overridden
     } )
     Address homeAddress;</programlisting>
 
       <para>Hibernate Annotations supports something that is not explicitly
       supported by the JPA specification. You can annotate a embedded object
       with the <literal>@MappedSuperclass</literal> annotation to make the
       superclass properties persistent (see
       <literal>@MappedSuperclass</literal> for more informations).</para>
 
       <para>You can also use association annotations in an embeddable object
       (ie <literal>@OneToOne</literal>, <classname>@ManyToOne</classname>,
       <classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To
       override the association columns you can use
       <literal>@AssociationOverride</literal>.</para>
 
       <para>If you want to have the same embeddable object type twice in the
       same entity, the column name defaulting will not work as several
       embedded objects would share the same set of columns. In plain JPA, you
       need to override at least one set of columns. Hibernate, however, allows
       you to enhance the default naming mechanism through the
       <classname>NamingStrategy</classname> interface. You can write a
       strategy that prevent name clashing in such a situation.
       <classname>DefaultComponentSafeNamingStrategy</classname> is an example
       of this.</para>
 
       <para>If a property of the embedded object points back to the owning
       entity, annotate it with the <classname>@Parent</classname> annotation.
       Hibernate will make sure this property is properly loaded with the
       entity reference.</para>
 
       <para>In XML, use the <literal>&lt;component&gt;</literal>
       element.</para>
 
       <programlistingco role="XML">
         <areaspec>
           <area coords="2" xml:id="component1" />
 
           <area coords="3" xml:id="component2" />
 
           <area coords="4" xml:id="component3" />
 
           <area coords="5" xml:id="component4" />
 
           <area coords="6" xml:id="component5" />
 
           <area coords="7" xml:id="component6" />
 
           <area coords="8" xml:id="component7" />
 
           <area coords="9" xml:id="component8" />
         </areaspec>
 
         <programlisting>&lt;component
         name="propertyName"
         class="className"
         insert="true|false"
         update="true|false"
         access="field|property|ClassName"
         lazy="true|false"
         optimistic-lock="true|false"
         unique="true|false"
         node="element-name|."
 &gt;
 
         &lt;property ...../&gt;
         &lt;many-to-one .... /&gt;
         ........
 &lt;/component&gt;</programlisting>
 
         <calloutlist>
           <callout arearefs="component1">
             <para><literal>name</literal>: the name of the property.</para>
           </callout>
 
           <callout arearefs="component2">
             <para><literal>class</literal> (optional - defaults to the
             property type determined by reflection): the name of the component
             (child) class.</para>
           </callout>
 
           <callout arearefs="component3">
             <para><literal>insert</literal>: do the mapped columns appear in
             SQL <literal>INSERTs</literal>?</para>
           </callout>
 
           <callout arearefs="component4">
             <para><literal>update</literal>: do the mapped columns appear in
             SQL <literal>UPDATEs</literal>?</para>
           </callout>
 
           <callout arearefs="component5">
             <para><literal>access</literal> (optional - defaults to
             <literal>property</literal>): the strategy Hibernate uses for
             accessing the property value.</para>
           </callout>
 
           <callout arearefs="component6">
             <para><literal>lazy</literal> (optional - defaults to
             <literal>false</literal>): specifies that this component should be
             fetched lazily when the instance variable is first accessed. It
             requires build-time bytecode instrumentation.</para>
           </callout>
 
           <callout arearefs="component7">
             <para><literal>optimistic-lock</literal> (optional - defaults to
             <literal>true</literal>): specifies that updates to this component
             either do or do not require acquisition of the optimistic lock. It
             determines if a version increment should occur when this property
             is dirty.</para>
           </callout>
 
           <callout arearefs="component8">
             <para><literal>unique</literal> (optional - defaults to
             <literal>false</literal>): specifies that a unique constraint
             exists upon all mapped columns of the component.</para>
           </callout>
         </calloutlist>
       </programlistingco>
 
       <para>The child <literal>&lt;property&gt;</literal> tags map properties
       of the child class to table columns.</para>
 
       <para>The <literal>&lt;component&gt;</literal> element allows a
       <literal>&lt;parent&gt;</literal> subelement that maps a property of the
       component class as a reference back to the containing entity.</para>
 
       <para>The <literal>&lt;dynamic-component&gt;</literal> element allows a
       <literal>Map</literal> to be mapped as a component, where the property
       names refer to keys of the map. See <xref
       linkend="components-dynamic" /> for more information. This feature is
       not supported in annotations.</para>
     </section>
 
     <section>
       <title>Inheritance strategy</title>
 
       <para>Java is a language supporting polymorphism: a class can inherit
       from another. Several strategies are possible to persist a class
       hierarchy:</para>
 
       <itemizedlist>
         <listitem>
           <para>Single table per class hierarchy strategy: a single table
           hosts all the instances of a class hierarchy</para>
         </listitem>
 
         <listitem>
           <para>Joined subclass strategy: one table per class and subclass is
           present and each table persist the properties specific to a given
           subclass. The state of the entity is then stored in its
           corresponding class table and all its superclasses</para>
         </listitem>
 
         <listitem>
           <para>Table per class strategy: one table per concrete class and
           subclass is present and each table persist the properties of the
           class and its superclasses. The state of the entity is then stored
           entirely in the dedicated table for its class.</para>
         </listitem>
       </itemizedlist>
 
       <section xml:id="mapping-declaration-subclass" revision="4">
         <title>Single table per class hierarchy strategy</title>
 
         <para>With this approach the properties of all the subclasses in a
         given mapped class hierarchy are stored in a single table.</para>
 
         <para>Each subclass declares its own persistent properties and
         subclasses. Version and id properties are assumed to be inherited from
         the root class. Each subclass in a hierarchy must define a unique
         discriminator value. If this is not specified, the fully qualified
         Java class name is used.</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 @Inheritance(strategy=InheritanceType.SINGLE_TABLE)
 @DiscriminatorColumn(
     name="planetype",
     discriminatorType=DiscriminatorType.STRING
 )
 @DiscriminatorValue("Plane")
 public class Plane { ... }
 
 @Entity
 @DiscriminatorValue("A320")
 public class A320 extends Plane { ... }          </programlisting>
 
         <para>In hbm.xml, for the table-per-class-hierarchy mapping strategy,
         the <literal>&lt;subclass&gt;</literal> declaration is used. For
         example:</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="subclass1" />
 
             <area coords="3" xml:id="subclass2" />
 
             <area coords="4" xml:id="subclass3" />
 
             <area coords="5" xml:id="subclass4" />
           </areaspec>
 
           <programlisting>&lt;subclass
         name="ClassName"
         discriminator-value="discriminator_value"
         proxy="ProxyInterface"
         lazy="true|false"
         dynamic-update="true|false"
         dynamic-insert="true|false"
         entity-name="EntityName"
         node="element-name"
         extends="SuperclassName"&gt;
 
         &lt;property .... /&gt;
         .....
 &lt;/subclass&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="subclass1">
               <para><literal>name</literal>: the fully qualified class name of
               the subclass.</para>
             </callout>
 
             <callout arearefs="subclass2">
               <para><literal>discriminator-value</literal> (optional -
               defaults to the class name): a value that distinguishes
               individual subclasses.</para>
             </callout>
 
             <callout arearefs="subclass3">
               <para><literal>proxy</literal> (optional): specifies a class or
               interface used for lazy initializing proxies.</para>
             </callout>
 
             <callout arearefs="subclass4">
               <para><literal>lazy</literal> (optional - defaults to
               <literal>true</literal>): setting
               <literal>lazy="false"</literal> disables the use of lazy
               fetching.</para>
             </callout>
           </calloutlist>
         </programlistingco>
 
         <para>For information about inheritance mappings see <xref
         linkend="inheritance" />.</para>
 
         <section xml:id="mapping-declaration-discriminator" revision="3">
           <title>Discriminator</title>
 
           <para>Discriminators are required for polymorphic persistence using
           the table-per-class-hierarchy mapping strategy. It declares a
           discriminator column of the table. The discriminator column contains
           marker values that tell the persistence layer what subclass to
           instantiate for a particular row. Hibernate Core supports the
           follwoing restricted set of types as discriminator column:
           <literal>string</literal>, <literal>character</literal>,
           <literal>integer</literal>, <literal>byte</literal>,
           <literal>short</literal>, <literal>boolean</literal>,
           <literal>yes_no</literal>, <literal>true_false</literal>.</para>
 
           <para>Use the <classname>@DiscriminatorColumn</classname> to define
           the discriminator column as well as the discriminator type. <note>
               <para><classname>The enum DiscriminatorType</classname> used in
               <classname>javax.persitence.DiscriminatorColumn</classname> only
               contains the values <constant>STRING</constant>,
               <constant>CHAR</constant> and <constant>INTEGER</constant> which
               means that not all Hibernate supported types are available via
               the <classname>@DiscriminatorColumn</classname>
               annotation.</para>
             </note>You can also use
           <classname>@DiscriminatorFormula</classname> to express in SQL a
           virtual discriminator column. This is particularly useful when the
           discriminator value can be extracted from one or more columns of the
           table. Both <classname>@DiscriminatorColumn</classname> and
           <classname>@DiscriminatorFormula</classname> are to be set on the
           root entity (once per persisted hierarchy).</para>
 
           <para><classname>@org.hibernate.annotations.DiscriminatorOptions</classname>
           allows to optionally specify Hibernate specific discriminator
           options which are not standardized in JPA. The available options are
           <literal>force</literal> and <literal>insert</literal>. The
           <literal>force</literal> attribute is useful if the table contains
           rows with "extra" discriminator values that are not mapped to a
           persistent class. This could for example occur when working with a
           legacy database. If <literal>force</literal> is set to
           <constant>true</constant> Hibernate will specify the allowed
           discriminator values in the <literal>SELECT</literal> query, even
           when retrieving all instances of the root class. The second option -
           <literal>insert</literal> - tells Hibernate whether or not to
           include the discriminator column in SQL <literal>INSERTs</literal>.
           Usually the column should be part of the <literal>INSERT</literal>
           statement, but if your discriminator column is also part of a mapped
           composite identifier you have to set this option to
           <constant>false</constant>.<tip>
               <para>There is also a
               <classname>@org.hibernate.annotations.ForceDiscriminator</classname>
               annotation which is deprecated since version 3.6. Use
               <classname>@DiscriminatorOptions</classname> instead.</para>
             </tip></para>
 
           <para>Finally, use <classname>@DiscriminatorValue</classname> on
           each class of the hierarchy to specify the value stored in the
           discriminator column for a given entity. If you do not set
           <classname>@DiscriminatorValue</classname> on a class, the fully
           qualified class name is used.</para>
 
           <programlisting language="JAVA" role="JAVA">@Entity
 @Inheritance(strategy=InheritanceType.SINGLE_TABLE)
 @DiscriminatorColumn(
     name="planetype",
     discriminatorType=DiscriminatorType.STRING
 )
 @DiscriminatorValue("Plane")
 public class Plane { ... }
 
 @Entity
 @DiscriminatorValue("A320")
 public class A320 extends Plane { ... }          </programlisting>
 
           <para>In hbm.xml, the <literal>&lt;discriminator&gt;</literal>
           element is used to define the discriminator column or
           formula:</para>
 
           <programlistingco role="XML">
             <areaspec>
               <area coords="2" xml:id="discriminator1" />
 
               <area coords="3" xml:id="discriminator2" />
 
               <area coords="4" xml:id="discriminator3" />
 
               <area coords="5" xml:id="discriminator4" />
 
               <area coords="6" xml:id="discriminator5" />
             </areaspec>
 
             <programlisting>&lt;discriminator
         column="discriminator_column"
         type="discriminator_type"
         force="true|false"
         insert="true|false"
         formula="arbitrary sql expression"
 /&gt;</programlisting>
 
             <calloutlist>
               <callout arearefs="discriminator1">
                 <para><literal>column</literal> (optional - defaults to
                 <literal>class</literal>): the name of the discriminator
                 column.</para>
               </callout>
 
               <callout arearefs="discriminator2">
                 <para><literal>type</literal> (optional - defaults to
                 <literal>string</literal>): a name that indicates the
                 Hibernate type</para>
               </callout>
 
               <callout arearefs="discriminator3">
                 <para><literal>force</literal> (optional - defaults to
                 <literal>false</literal>): "forces" Hibernate to specify the
                 allowed discriminator values, even when retrieving all
                 instances of the root class.</para>
               </callout>
 
               <callout arearefs="discriminator4">
                 <para><literal>insert</literal> (optional - defaults to
                 <literal>true</literal>): set this to <literal>false</literal>
                 if your discriminator column is also part of a mapped
                 composite identifier. It tells Hibernate not to include the
                 column in SQL <literal>INSERTs</literal>.</para>
               </callout>
 
               <callout arearefs="discriminator5">
                 <para><literal>formula</literal> (optional): an arbitrary SQL
                 expression that is executed when a type has to be evaluated.
                 It allows content-based discrimination.</para>
               </callout>
             </calloutlist>
           </programlistingco>
 
           <para>Actual values of the discriminator column are specified by the
           <literal>discriminator-value</literal> attribute of the
           <literal>&lt;class&gt;</literal> and
           <literal>&lt;subclass&gt;</literal> elements.</para>
 
           <para>The <literal>formula</literal> attribute allows you to declare
           an arbitrary SQL expression that will be used to evaluate the type
           of a row. For example:</para>
 
           <programlisting role="XML">&lt;discriminator
     formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
     type="integer"/&gt;</programlisting>
         </section>
       </section>
 
       <section xml:id="mapping-declaration-joinedsubclass" revision="3">
         <title>Joined subclass strategy</title>
 
         <para>Each subclass can also be mapped to its own table. This is
         called the table-per-subclass mapping strategy. An inherited state is
         retrieved by joining with the table of the superclass. A discriminator
         column is not required for this mapping strategy. Each subclass must,
         however, declare a table column holding the object identifier. The
         primary key of this table is also a foreign key to the superclass
         table and described by the
         <classname>@PrimaryKeyJoinColumn</classname>s or the
         <literal>&lt;key&gt;</literal> element.</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity @Table(name="CATS")
 @Inheritance(strategy=InheritanceType.JOINED)
 public class Cat implements Serializable { 
     @Id @GeneratedValue(generator="cat-uuid") 
     @GenericGenerator(name="cat-uuid", strategy="uuid")
     String getId() { return id; }
 
     ...
 }
 
 @Entity @Table(name="DOMESTIC_CATS")
 @PrimaryKeyJoinColumn(name="CAT")
 public class DomesticCat extends Cat { 
     public String getName() { return name; }
 }            </programlisting>
 
         <note>
           <para>The table name still defaults to the non qualified class name.
           Also if <classname>@PrimaryKeyJoinColumn</classname> is not set, the
           primary key / foreign key columns are assumed to have the same names
           as the primary key columns of the primary table of the
           superclass.</para>
         </note>
 
         <para>In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal>
         element. For example:</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="joinedsubclass1" />
 
             <area coords="3" xml:id="joinedsubclass2" />
 
             <area coords="4" xml:id="joinedsubclass3" />
 
             <area coords="5" xml:id="joinedsubclass4" />
           </areaspec>
 
           <programlisting>&lt;joined-subclass
         name="ClassName"
         table="tablename"
         proxy="ProxyInterface"
         lazy="true|false"
         dynamic-update="true|false"
         dynamic-insert="true|false"
         schema="schema"
         catalog="catalog"
         extends="SuperclassName"
         persister="ClassName"
         subselect="SQL expression"
         entity-name="EntityName"
         node="element-name"&gt;
 
         &lt;key .... &gt;
 
         &lt;property .... /&gt;
         .....
 &lt;/joined-subclass&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="joinedsubclass1">
               <para><literal>name</literal>: the fully qualified class name of
               the subclass.</para>
             </callout>
 
             <callout arearefs="joinedsubclass2">
               <para><literal>table</literal>: the name of the subclass
               table.</para>
             </callout>
 
             <callout arearefs="joinedsubclass3">
               <para><literal>proxy</literal> (optional): specifies a class or
               interface to use for lazy initializing proxies.</para>
             </callout>
 
             <callout arearefs="joinedsubclass4">
               <para><literal>lazy</literal> (optional, defaults to
               <literal>true</literal>): setting
               <literal>lazy="false"</literal> disables the use of lazy
               fetching.</para>
             </callout>
           </calloutlist>
         </programlistingco>
 
         <para>Use the <literal>&lt;key&gt;</literal> element to declare the
         primary key / foreign key column. The mapping at the start of the
         chapter would then be re-written as:</para>
 
         <programlisting role="XML">&lt;?xml version="1.0"?&gt;
 &lt;!DOCTYPE hibernate-mapping PUBLIC
         "-//Hibernate/Hibernate Mapping DTD//EN"
         "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
 
 &lt;hibernate-mapping package="eg"&gt;
 
         &lt;class name="Cat" table="CATS"&gt;
                 &lt;id name="id" column="uid" type="long"&gt;
                         &lt;generator class="hilo"/&gt;
                 &lt;/id&gt;
                 &lt;property name="birthdate" type="date"/&gt;
                 &lt;property name="color" not-null="true"/&gt;
                 &lt;property name="sex" not-null="true"/&gt;
                 &lt;property name="weight"/&gt;
                 &lt;many-to-one name="mate"/&gt;
                 &lt;set name="kittens"&gt;
                         &lt;key column="MOTHER"/&gt;
                         &lt;one-to-many class="Cat"/&gt;
                 &lt;/set&gt;
                 &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                     &lt;key column="CAT"/&gt;
                     &lt;property name="name" type="string"/&gt;
                 &lt;/joined-subclass&gt;
         &lt;/class&gt;
 
         &lt;class name="eg.Dog"&gt;
                 &lt;!-- mapping for Dog could go here --&gt;
         &lt;/class&gt;
 
 &lt;/hibernate-mapping&gt;</programlisting>
 
         <para>For information about inheritance mappings see <xref
         linkend="inheritance" />.</para>
       </section>
 
       <section xml:id="mapping-declaration-unionsubclass" revision="2">
         <title>Table per class strategy</title>
 
         <para>A third option is to map only the concrete classes of an
         inheritance hierarchy to tables. This is called the
         table-per-concrete-class strategy. Each table defines all persistent
         states of the class, including the inherited state. In Hibernate, it
         is not necessary to explicitly map such inheritance hierarchies. You
         can map each class as a separate entity root. However, if you wish use
         polymorphic associations (e.g. an association to the superclass of
         your hierarchy), you need to use the union subclass mapping.</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
 public class Flight implements Serializable { ... }            </programlisting>
 
         <para>Or in hbm.xml:</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="unionsubclass1" />
 
             <area coords="3" xml:id="unionsubclass2" />
 
             <area coords="4" xml:id="unionsubclass3" />
 
             <area coords="5" xml:id="unionsubclass4" />
           </areaspec>
 
           <programlisting>&lt;union-subclass
         name="ClassName"
         table="tablename"
         proxy="ProxyInterface"
         lazy="true|false"
         dynamic-update="true|false"
         dynamic-insert="true|false"
         schema="schema"
         catalog="catalog"
         extends="SuperclassName"
         abstract="true|false"
         persister="ClassName"
         subselect="SQL expression"
         entity-name="EntityName"
         node="element-name"&gt;
 
         &lt;property .... /&gt;
         .....
 &lt;/union-subclass&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="unionsubclass1">
               <para><literal>name</literal>: the fully qualified class name of
               the subclass.</para>
             </callout>
 
             <callout arearefs="unionsubclass2">
               <para><literal>table</literal>: the name of the subclass
               table.</para>
             </callout>
 
             <callout arearefs="unionsubclass3">
               <para><literal>proxy</literal> (optional): specifies a class or
               interface to use for lazy initializing proxies.</para>
             </callout>
 
             <callout arearefs="unionsubclass4">
               <para><literal>lazy</literal> (optional, defaults to
               <literal>true</literal>): setting
               <literal>lazy="false"</literal> disables the use of lazy
               fetching.</para>
             </callout>
           </calloutlist>
         </programlistingco>
 
         <para>No discriminator column or key column is required for this
         mapping strategy.</para>
 
         <para>For information about inheritance mappings see <xref
         linkend="inheritance" />.</para>
       </section>
 
       <section>
         <title>Inherit properties from superclasses</title>
 
         <para>This is sometimes useful to share common properties through a
         technical or a business superclass without including it as a regular
         mapped entity (ie no specific table for this entity). For that purpose
         you can map them as <literal>@MappedSuperclass</literal>.</para>
 
         <programlisting language="JAVA" role="JAVA">@MappedSuperclass
 public class BaseEntity {
     @Basic
     @Temporal(TemporalType.TIMESTAMP)
     public Date getLastUpdate() { ... }
     public String getLastUpdater() { ... }
     ...
 }
 
 @Entity class Order extends BaseEntity {
     @Id public Integer getId() { ... }
     ...
 }</programlisting>
 
         <para>In database, this hierarchy will be represented as an
         <literal>Order</literal> table having the <literal>id</literal>,
         <literal>lastUpdate</literal> and <literal>lastUpdater</literal>
         columns. The embedded superclass property mappings are copied into
         their entity subclasses. Remember that the embeddable superclass is
         not the root of the hierarchy though.</para>
 
         <note>
           <para>Properties from superclasses not mapped as
           <literal>@MappedSuperclass</literal> are ignored.</para>
         </note>
 
         <note>
           <para>The default access type (field or methods) is used, unless you
           use the <literal>@Access</literal> annotation.</para>
         </note>
 
         <note>
           <para>The same notion can be applied to
           <literal>@Embeddable</literal> objects to persist properties from
           their superclasses. You also need to use
           <literal>@MappedSuperclass</literal> to do that (this should not be
           considered as a standard EJB3 feature though)</para>
         </note>
 
         <note>
           <para>It is allowed to mark a class as
           <literal>@MappedSuperclass</literal> in the middle of the mapped
           inheritance hierarchy.</para>
         </note>
 
         <note>
           <para>Any class in the hierarchy non annotated with
           <literal>@MappedSuperclass</literal> nor <literal>@Entity</literal>
           will be ignored.</para>
         </note>
 
         <para>You can override columns defined in entity superclasses at the
         root entity level using the <literal>@AttributeOverride</literal>
         annotation.</para>
 
         <programlisting language="JAVA" role="JAVA">@MappedSuperclass
 public class FlyingObject implements Serializable {
 
     public int getAltitude() {
         return altitude;
     }
 
     @Transient
     public int getMetricAltitude() {
         return metricAltitude;
     }
 
     @ManyToOne
     public PropulsionType getPropulsion() {
         return metricAltitude;
     }
     ...
 }
 
 @Entity
 @AttributeOverride( name="altitude", column = @Column(name="fld_altitude") )
 @AssociationOverride( 
    name="propulsion", 
    joinColumns = @JoinColumn(name="fld_propulsion_fk") 
 )
 public class Plane extends FlyingObject {
     ...
 }</programlisting>
 
         <para>The <literal>altitude</literal> property will be persisted in an
         <literal>fld_altitude</literal> column of table
         <literal>Plane</literal> and the propulsion association will be
         materialized in a <literal>fld_propulsion_fk</literal> foreign key
         column.</para>
 
         <para>You can define <literal>@AttributeOverride</literal>(s) and
         <literal>@AssociationOverride</literal>(s) on
         <literal>@Entity</literal> classes,
         <literal>@MappedSuperclass</literal> classes and properties pointing
         to an <literal>@Embeddable</literal> object.</para>
 
         <para>In hbm.xml, simply map the properties of the superclass in the
         <literal>&lt;class&gt;</literal> element of the entity that needs to
         inherit them.</para>
       </section>
 
       <section xml:id="mapping-declaration-join" revision="3">
         <title>Mapping one entity to several tables</title>
 
         <para>While not recommended for a fresh schema, some legacy databases
         force your to map a single entity on several tables.</para>
 
         <para>Using the <literal>@SecondaryTable</literal> or
         <literal>@SecondaryTables</literal> class level annotations. To
         express that a column is in a particular table, use the
         <literal>table</literal> parameter of <literal>@Column</literal> or
         <literal>@JoinColumn</literal>.</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 @Table(name="MainCat")
 @SecondaryTables({
     @SecondaryTable(name="Cat1", pkJoinColumns={
         @PrimaryKeyJoinColumn(name="cat_id", referencedColumnName="id")
     ),
     @SecondaryTable(name="Cat2", uniqueConstraints={@UniqueConstraint(columnNames={"storyPart2"})})
 })
 public class Cat implements Serializable {
 
     private Integer id;
     private String name;
     private String storyPart1;
     private String storyPart2;
 
     @Id @GeneratedValue
     public Integer getId() {
         return id;
     }
 
     public String getName() {
         return name;
     }
     
     @Column(table="Cat1")
     public String getStoryPart1() {
         return storyPart1;
     }
 
     @Column(table="Cat2")
     public String getStoryPart2() {
         return storyPart2;
     }
 }</programlisting>
 
         <para>In this example, <literal>name</literal> will be in
         <literal>MainCat</literal>. <literal>storyPart1</literal> will be in
         <literal>Cat1</literal> and <literal>storyPart2</literal> will be in
         <literal>Cat2</literal>. <literal>Cat1</literal> will be joined to
         <literal>MainCat</literal> using the <literal>cat_id</literal> as a
         foreign key, and <literal>Cat2</literal> using <literal>id</literal>
         (ie the same column name, the <literal>MainCat</literal> id column
         has). Plus a unique constraint on <literal>storyPart2</literal> has
         been set.</para>
 
         <para>There is also additional tuning accessible via the
         <classname>@org.hibernate.annotations.Table</classname>
         annotation:</para>
 
         <itemizedlist>
           <listitem>
             <para><literal>fetch</literal>: If set to JOIN, the default,
             Hibernate will use an inner join to retrieve a secondary table
             defined by a class or its superclasses and an outer join for a
             secondary table defined by a subclass. If set to
             <classname>SELECT</classname> then Hibernate will use a sequential
             select for a secondary table defined on a subclass, which will be
             issued only if a row turns out to represent an instance of the
             subclass. Inner joins will still be used to retrieve a secondary
             defined by the class and its superclasses.</para>
           </listitem>
 
           <listitem>
             <para><literal>inverse</literal>: If true, Hibernate will not try
             to insert or update the properties defined by this join. Default
             to false.</para>
           </listitem>
 
           <listitem>
             <para><literal>optional</literal>: If enabled (the default),
             Hibernate will insert a row only if the properties defined by this
             join are non-null and will always use an outer join to retrieve
             the properties.</para>
           </listitem>
 
           <listitem>
             <para><literal>foreignKey</literal>: defines the Foreign Key name
             of a secondary table pointing back to the primary table.</para>
           </listitem>
         </itemizedlist>
 
         <para>Make sure to use the secondary table name in the
         <methodname>appliesto</methodname> property</para>
 
         <programlisting language="JAVA" role="JAVA">@Entity
 @Table(name="MainCat")
 @SecondaryTable(name="Cat1")
 @org.hibernate.annotations.Table(
    appliesTo="Cat1",
    fetch=FetchMode.SELECT,
    optional=true)
 public class Cat implements Serializable {
 
     private Integer id;
     private String name;
     private String storyPart1;
     private String storyPart2;
 
     @Id @GeneratedValue
     public Integer getId() {
         return id;
     }
 
     public String getName() {
         return name;
     }
     
     @Column(table="Cat1")
     public String getStoryPart1() {
         return storyPart1;
     }
 
     @Column(table="Cat2")
     public String getStoryPart2() {
         return storyPart2;
     }
 }</programlisting>
 
         <para>In hbm.xml, use the <literal>&lt;join&gt;</literal>
         element.</para>
 
         <programlistingco role="XML">
           <areaspec>
             <area coords="2" xml:id="join1" />
 
             <area coords="3" xml:id="join2" />
 
             <area coords="4" xml:id="join3" />
 
             <area coords="5" xml:id="join4" />
 
             <area coords="6" xml:id="join5" />
 
             <area coords="7" xml:id="join6" />
           </areaspec>
 
           <programlisting>&lt;join
         table="tablename"
         schema="owner"
         catalog="catalog"
         fetch="join|select"
         inverse="true|false"
         optional="true|false"&gt;
 
         &lt;key ... /&gt;
 
         &lt;property ... /&gt;
         ...
 &lt;/join&gt;</programlisting>
 
           <calloutlist>
             <callout arearefs="join1">
               <para><literal>table</literal>: the name of the joined
               table.</para>
             </callout>
 
             <callout arearefs="join2">
               <para><literal>schema</literal> (optional): overrides the schema
               name specified by the root
               <literal>&lt;hibernate-mapping&gt;</literal> element.</para>
             </callout>
 
             <callout arearefs="join3">
               <para><literal>catalog</literal> (optional): overrides the
               catalog name specified by the root
               <literal>&lt;hibernate-mapping&gt;</literal> element.</para>
             </callout>
 
             <callout arearefs="join4">
diff --git a/documentation/src/main/docbook/manual/es-ES/content/basic_mapping.po b/documentation/src/main/docbook/manual/es-ES/content/basic_mapping.po
index caff512f79..8df485b92e 100644
--- a/documentation/src/main/docbook/manual/es-ES/content/basic_mapping.po
+++ b/documentation/src/main/docbook/manual/es-ES/content/basic_mapping.po
@@ -3628,2001 +3628,2001 @@ msgid ""
 "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
 "type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
 "\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
 "\"&gt;</literal>"
 msgstr ""
 "<literal>&lt;Timestamp&gt;</literal> es equivalente a <literal>&lt;version "
 "type=\"timestamp\"&gt;</literal>. Y <literal>&lt;timestamp source=\"db\"&gt;"
 "</literal> es equivalente a <literal>&lt;version type=\"dbtimestamp\"&gt;</"
 "literal>."
 
 #. Tag: title
 #: basic_mapping.xml:1697
 #, no-c-format
 msgid "Property"
 msgstr "Propiedad"
 
 #. Tag: para
 #: basic_mapping.xml:1699
 #, no-c-format
 msgid ""
 "You need to decide which property needs to be made persistent in a given "
 "entity. This differs slightly between the annotation driven metadata and the "
 "hbm.xml files."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1704
 #, no-c-format
 msgid "Property mapping with annotations"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1706
 #, no-c-format
 msgid ""
 "In the annotations world, every non static non transient property (field or "
 "method depending on the access type) of an entity is considered persistent, "
 "unless you annotate it as <literal>@Transient</literal>. Not having an "
 "annotation for your property is equivalent to the appropriate "
 "<literal>@Basic</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1713
 #, no-c-format
 msgid ""
 "The <literal>@Basic</literal> annotation allows you to declare the fetching "
 "strategy for a property. If set to <literal>LAZY</literal>, specifies that "
 "this property should be fetched lazily when the instance variable is first "
 "accessed. It requires build-time bytecode instrumentation, if your classes "
 "are not instrumented, property level lazy loading is silently ignored. The "
 "default is <literal>EAGER</literal>. You can also mark a property as not "
 "optional thanks to the <classname>@Basic.optional</classname> attribute. "
 "This will ensure that the underlying column are not nullable (if possible). "
 "Note that a better approach is to use the <classname>@NotNull</classname> "
 "annotation of the Bean Validation specification."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1726
 #, no-c-format
 msgid "Let's look at a few examples:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1728
 #, no-c-format
 msgid ""
 "public transient int counter; //transient property\n"
 "\n"
 "private String firstname; //persistent property\n"
 "\n"
 "@Transient\n"
 "String getLengthInMeter() { ... } //transient property\n"
 "\n"
 "String getName() {... } // persistent property\n"
 "\n"
 "@Basic\n"
 "int getLength() { ... } // persistent property\n"
 "\n"
 "@Basic(fetch = FetchType.LAZY)\n"
 "String getDetailedComment() { ... } // persistent property\n"
 "\n"
 "@Temporal(TemporalType.TIME)\n"
 "java.util.Date getDepartureTime() { ... } // persistent property           \n"
 "\n"
 "@Enumerated(EnumType.STRING)\n"
 "Starred getNote() { ... } //enum persisted as String in database"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1730
 #, no-c-format
 msgid ""
 "<literal>counter</literal>, a transient field, and <literal>lengthInMeter</"
 "literal>, a method annotated as <literal>@Transient</literal>, and will be "
 "ignored by the Hibernate. <literal>name</literal>, <literal>length</"
 "literal>, and <literal>firstname</literal> properties are mapped persistent "
 "and eagerly fetched (the default for simple properties). The "
 "<literal>detailedComment</literal> property value will be lazily fetched "
 "from the database once a lazy property of the entity is accessed for the "
 "first time. Usually you don't need to lazy simple properties (not to be "
 "confused with lazy association fetching). The recommended alternative is to "
 "use the projection capability of JP-QL (Java Persistence Query Language) or "
 "Criteria queries."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1743
 #, no-c-format
 msgid ""
 "JPA support property mapping of all basic types supported by Hibernate (all "
 "basic Java types , their respective wrappers and serializable classes). "
 "Hibernate Annotations supports out of the box enum type mapping either into "
 "a ordinal column (saving the enum ordinal) or a string based column (saving "
 "the enum string representation): the persistence representation, defaulted "
 "to ordinal, can be overridden through the <literal>@Enumerated</literal> "
 "annotation as shown in the <literal>note</literal> property example."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1753
 #, no-c-format
 msgid ""
 "In plain Java APIs, the temporal precision of time is not defined. When "
 "dealing with temporal data you might want to describe the expected precision "
 "in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</"
 "literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, "
 "only the time, or both). Use the <literal>@Temporal</literal> annotation to "
 "fine tune that."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1761
 #, no-c-format
 msgid ""
 "<literal>@Lob</literal> indicates that the property should be persisted in a "
 "Blob or a Clob depending on the property type: <classname>java.sql.Clob</"
 "classname>, <classname>Character[]</classname>, <classname>char[]</"
 "classname> and java.lang.<classname>String</classname> will be persisted in "
 "a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, "
 "<classname>byte[] </classname>and <classname>Serializable</classname> type "
 "will be persisted in a Blob."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1770
 #, no-c-format
 msgid ""
 "@Lob\n"
 "public String getFullText() {\n"
 "    return fullText;\n"
 "}\n"
 "\n"
 "@Lob\n"
 "public byte[] getFullCode() {\n"
 "    return fullCode;\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1772
 #, no-c-format
 msgid ""
 "If the property type implements <classname>java.io.Serializable</classname> "
 "and is not a basic type, and if the property is not annotated with "
 "<literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> "
 "type is used."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1779
 #, no-c-format
 msgid "Type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1781
 #, no-c-format
 msgid ""
 "You can also manually specify a type using the <literal>@org.hibernate."
 "annotations.Type</literal> and some parameters if needed. <classname>@Type."
 "type</classname> could be:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1788 basic_mapping.xml:2220
 #, no-c-format
 msgid ""
 "The name of a Hibernate basic type: <literal>integer, string, character, "
 "date, timestamp, float, binary, serializable, object, blob</literal> etc."
 msgstr ""
 "El nombre de un tipo básico de Hibernate: <literal>integer, string, "
 "character, date, timestamp, float, binary, serializable, object, blob</"
 "literal>, etc."
 
 #. Tag: para
 #: basic_mapping.xml:1794 basic_mapping.xml:2226
 #, no-c-format
 msgid ""
 "The name of a Java class with a default basic type: <literal>int, float, "
 "char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
 "literal> etc."
 msgstr ""
 "El nombre de una clase Java con un tipo básico predeterminado: <literal>int, "
 "float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql."
 "Clob</literal>, etc."
 
 #. Tag: para
 #: basic_mapping.xml:1800 basic_mapping.xml:2232
 #, no-c-format
 msgid "The name of a serializable Java class."
 msgstr "El nombre de una clase Java serializable."
 
 #. Tag: para
 #: basic_mapping.xml:1804 basic_mapping.xml:2236
 #, no-c-format
 msgid ""
 "The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
 "literal> etc."
 msgstr ""
 "El nombre declase de un tipo personalizado: <literal>com.illflow.type."
 "MyCustomType</literal> etc."
 
 #. Tag: para
 #: basic_mapping.xml:1809
 #, fuzzy, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4."
 msgstr ""
 "Si no especifica un tipo, Hibernate utilizará reflección sobre la propiedad "
 "mencionada para deducir el tipo Hibernate correcto. Hibernate intentará "
 "interpretar el nombre de la clase de retorno del getter de la propiedad "
 "utilizando las reglas 2, 3 y 4 en ese mismo orden. En algunos casos "
 "necesitará el atributo <literal>type</literal>. Por ejemplo, para distinguir "
 "entre <literal>Hibernate.DATE</literal> y <literal>Hibernate.TIMESTAMP</"
 "literal>, o especificar un tipo personalizado."
 
 #. Tag: para
 #: basic_mapping.xml:1814
 #, no-c-format
 msgid ""
 "<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org."
 "hibernate.annotations.TypeDefs</literal> allows you to declare type "
 "definitions. These annotations can be placed at the class or package level. "
 "Note that these definitions are global for the session factory (even when "
 "defined at the class level). If the type is used on a single entity, you can "
 "place the definition on the entity itself. Otherwise, it is recommended to "
 "place the definition at the package level. In the example below, when "
 "Hibernate encounters a property of class <literal>PhoneNumer</literal>, it "
 "delegates the persistence strategy to the custom mapping type "
 "<literal>PhoneNumberType</literal>. However, properties belonging to other "
 "classes, too, can delegate their persistence strategy to "
 "<literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</"
 "literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1830
 #, no-c-format
 msgid ""
 "Package level annotations are placed in a file named <filename>package-info."
 "java</filename> in the appropriate package. Place your annotations before "
 "the package declaration."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1835
 #, no-c-format
 msgid ""
 "@TypeDef(\n"
 "   name = \"phoneNumber\",\n"
 "   defaultForType = PhoneNumber.class,\n"
 "   typeClass = PhoneNumberType.class\n"
 ")\n"
 "\n"
 "@Entity\n"
 "public class ContactDetails {\n"
 "   [...]\n"
 "   private PhoneNumber localPhoneNumber;\n"
 "   @Type(type=\"phoneNumber\")\n"
 "   private OverseasPhoneNumber overseasPhoneNumber;\n"
 "   [...]\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1837
 #, no-c-format
 msgid ""
 "The following example shows the usage of the <literal>parameters</literal> "
 "attribute to customize the TypeDef."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1841
 #, no-c-format
 msgid ""
 "//in org/hibernate/test/annotations/entity/package-info.java\n"
 "@TypeDefs(\n"
 "    {\n"
 "    @TypeDef(\n"
 "        name=\"caster\",\n"
 "        typeClass = CasterStringType.class,\n"
 "        parameters = {\n"
 "            @Parameter(name=\"cast\", value=\"lower\")\n"
 "        }\n"
 "    )\n"
 "    }\n"
 ")\n"
 "package org.hibernate.test.annotations.entity;\n"
 "\n"
 "//in org/hibernate/test/annotations/entity/Forest.java\n"
 "public class Forest {\n"
 "    @Type(type=\"caster\")\n"
 "    public String getSmallText() {\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1843
 #, no-c-format
 msgid ""
 "When using composite user type, you will have to express column definitions. "
 "The <literal>@Columns</literal> has been introduced for that purpose."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1847
 #, no-c-format
 msgid ""
 "@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType"
 "\")\n"
 "@Columns(columns = {\n"
 "    @Column(name=\"r_amount\"),\n"
 "    @Column(name=\"r_currency\")\n"
 "})\n"
 "public MonetaryAmount getAmount() {\n"
 "    return amount;\n"
 "}\n"
 "\n"
 "\n"
 "public class MonetaryAmount implements Serializable {\n"
 "    private BigDecimal amount;\n"
 "    private Currency currency;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1851
 #, no-c-format
 msgid "Access type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1853
 #, no-c-format
 msgid ""
 "By default the access type of a class hierarchy is defined by the position "
 "of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> "
 "annotations. If these annotations are on a field, then only fields are "
 "considered for persistence and the state is accessed via the field. If there "
 "annotations are on a getter, then only the getters are considered for "
 "persistence and the state is accessed via the getter/setter. That works well "
 "in practice and is the recommended approach."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1861
 #, no-c-format
 msgid ""
 "The placement of annotations within a class hierarchy has to be consistent "
 "(either field or on property) to be able to determine the default access "
 "type. It is recommended to stick to one single annotation placement strategy "
 "throughout your whole application."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1868
 #, no-c-format
 msgid "However in some situations, you need to:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1872
 #, no-c-format
 msgid "force the access type of the entity hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1876
 #, no-c-format
 msgid "override the access type of a specific entity in the class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1881
 #, no-c-format
 msgid "override the access type of an embeddable type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1885
 #, no-c-format
 msgid ""
 "The best use case is an embeddable class used by several entities that might "
 "not use the same access type. In this case it is better to force the access "
 "type at the embeddable class level."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1890
 #, no-c-format
 msgid ""
 "To force the access type on a given class, use the <classname>@Access</"
 "classname> annotation as showed below:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1893
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   @Embedded private Address address;\n"
 "   public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Entity\n"
 "public class User {\n"
 "   private Long id;\n"
 "   @Id public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   private Address address;\n"
 "   @Embedded public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Embeddable\n"
 "@Access(AcessType.PROPERTY)\n"
 "public class Address {\n"
 "   private String street1;\n"
 "   public String getStreet1() { return street1; }\n"
 "   public void setStreet1() { this.street1 = street1; }\n"
 "\n"
 "   private hashCode; //not persistent\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1895
 #, no-c-format
 msgid ""
 "You can also override the access type of a single property while keeping the "
 "other properties standard."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1898
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "   @Transient private String userId;\n"
 "   @Transient private String orderId;\n"
 "\n"
 "   @Access(AccessType.PROPERTY)\n"
 "   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
 "   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1900
 #, no-c-format
 msgid ""
 "In this example, the default access type is <classname>FIELD</classname> "
 "except for the <literal>orderNumber</literal> property. Note that the "
 "corresponding field, if any must be marked as <classname>@Transient</"
 "classname> or <code>transient</code>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1907
 #, no-c-format
 msgid "@org.hibernate.annotations.AccessType"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1909
 #, no-c-format
 msgid ""
 "The annotation <classname>@org.hibernate.annotations.AccessType</classname> "
 "should be considered deprecated for FIELD and PROPERTY access. It is still "
 "useful however if you need to use a custom access type."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1918
 #, no-c-format
 msgid "Optimistic lock"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1920
 #, no-c-format
 msgid ""
 "It is sometimes useful to avoid increasing the version number even if a "
 "given property is dirty (particularly collections). You can do that by "
 "annotating the property (or collection) with <literal>@OptimisticLock"
 "(excluded=true)</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1925
 #, no-c-format
 msgid ""
 "More formally, specifies that updates to this property do not require "
 "acquisition of the optimistic lock."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1930
 #, no-c-format
 msgid "Declaring column attributes"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1932
 #, no-c-format
 msgid ""
 "The column(s) used for a property mapping can be defined using the "
 "<literal>@Column</literal> annotation. Use it to override default values "
 "(see the JPA specification for more information on the defaults). You can "
 "use this annotation at the property level for properties that are:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1940
 #, no-c-format
 msgid "not annotated at all"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1944
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Basic</literal>"
 msgstr "<literal>assigned</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1948
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Version</literal>"
 msgstr "<literal>string</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1952
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Lob</literal>"
 msgstr "<literal>hilo</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1956
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Temporal</literal>"
 msgstr "<literal>serializable</literal>"
 
 #. Tag: programlisting
 #: basic_mapping.xml:1960
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Flight implements Serializable {\n"
 "...\n"
 "@Column(updatable = false, name = \"flight_name\", nullable = false, "
 "length=50)\n"
 "public String getName() { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1962
 #, no-c-format
 msgid ""
 "The <literal>name</literal> property is mapped to the <literal>flight_name</"
 "literal> column, which is not nullable, has a length of 50 and is not "
 "updatable (making the property immutable)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1967
 #, no-c-format
 msgid ""
 "This annotation can be applied to regular properties as well as "
 "<literal>@Id</literal> or <literal>@Version</literal> properties."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1994
 #, no-c-format
 msgid ""
 "@Column(\n"
 "    name=\"columnName\";\n"
 "    boolean unique() default false;\n"
 "    boolean nullable() default true;\n"
 "    boolean insertable() default true;\n"
 "    boolean updatable() default true;\n"
 "    String columnDefinition() default \"\";\n"
 "    String table() default \"\";\n"
 "    int length() default 255;\n"
 "    int precision() default 0; // decimal precision\n"
 "    int scale() default 0; // decimal scale"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1998
 #, fuzzy, no-c-format
 msgid ""
 "<literal>name</literal> (optional): the column name (default to the property "
 "name)"
 msgstr ""
 "<literal>name</literal> (opcional): El nombre de la propiedad del "
 "identificador. s"
 
 #. Tag: para
 #: basic_mapping.xml:2003
 #, fuzzy, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): set a unique constraint on this column "
 "or not (default false)"
 msgstr ""
 "<literal>unique</literal> (opcional): Activa la generación DDL de una "
 "restricción de unicidad para las columnas. Además, permite que ésta sea el "
 "objetivo de una <literal>property-ref</literal>. "
 
 #. Tag: para
 #: basic_mapping.xml:2008
 #, fuzzy, no-c-format
 msgid ""
 "<literal>nullable</literal> (optional): set the column as nullable (default "
 "true)."
 msgstr ""
 "<literal>name</literal> (opcional): El nombre de la propiedad del "
 "identificador. s"
 
 #. Tag: para
 #: basic_mapping.xml:2013
 #, fuzzy, no-c-format
 msgid ""
 "<literal>insertable</literal> (optional): whether or not the column will be "
 "part of the insert statement (default true)"
 msgstr ""
 "<literal>name</literal> (opcional): El nombre de la propiedad del "
 "identificador. s"
 
 #. Tag: para
 #: basic_mapping.xml:2019
 #, fuzzy, no-c-format
 msgid ""
 "<literal>updatable</literal> (optional): whether or not the column will be "
 "part of the update statement (default true)"
 msgstr ""
 "<literal>catalog</literal> (opcional): El nombre de un catálogo de la base "
 "de datos. "
 
 #. Tag: para
 #: basic_mapping.xml:2025
 #, no-c-format
 msgid ""
 "<literal>columnDefinition</literal> (optional): override the sql DDL "
 "fragment for this particular column (non portable)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2031
 #, fuzzy, no-c-format
 msgid ""
 "<literal>table</literal> (optional): define the targeted table (default "
 "primary table)"
 msgstr ""
 "<literal>catalog</literal> (opcional): El nombre de un catálogo de la base "
 "de datos. "
 
 #. Tag: para
 #: basic_mapping.xml:2036
 #, no-c-format
 msgid ""
 "<literal><literal>length</literal></literal> (optional): column length "
 "(default 255)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2041
 #, no-c-format
 msgid ""
 "<literal><literal>precision</literal></literal> (optional): column decimal "
 "precision (default 0)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2046
 #, no-c-format
 msgid ""
 "<literal><literal>scale</literal></literal> (optional): column decimal scale "
 "if useful (default 0)"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2054
 #, no-c-format
 msgid "Formula"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2056
 #, no-c-format
 msgid ""
 "Sometimes, you want the Database to do some computation for you rather than "
 "in the JVM, you might also create some kind of virtual column. You can use a "
 "SQL fragment (aka formula) instead of mapping a property into a column. This "
 "kind of property is read only (its value is calculated by your formula "
 "fragment)."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2062
 #, no-c-format
 msgid ""
 "@Formula(\"obj_length * obj_height * obj_width\")\n"
 "public long getObjectVolume()"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2064
 #, no-c-format
 msgid ""
 "The SQL fragment can be as complex as you want and even include subselects."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2069
 #, no-c-format
 msgid "Non-annotated property defaults"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2071
 #, no-c-format
 msgid "If a property is not annotated, the following rules apply:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2074
 #, no-c-format
 msgid "If the property is of a single type, it is mapped as @Basic"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2079
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is annotated as @Embeddable, it is "
 "mapped as @Embedded"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2084
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>Serializable</"
 "classname>, it is mapped as <classname>@Basic</classname> in a column "
 "holding the object in its serialized version"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2091
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>java.sql.Clob</"
 "classname> or <classname>java.sql.Blob</classname>, it is mapped as "
 "<classname>@Lob</classname> with the appropriate <classname>LobType</"
 "classname>"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2102
 #, no-c-format
 msgid "Property mapping with hbm.xml"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2104
 #, no-c-format
 msgid ""
 "The <literal>&lt;property&gt;</literal> element declares a persistent "
 "JavaBean style property of the class."
 msgstr ""
 "El elemento <literal>&lt;property&gt;</literal> declara una propiedad "
 "persistente estilo JavaBean de la clase. "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2136
 #, no-c-format
 msgid ""
 "&lt;property\n"
 "        name=\"propertyName\"\n"
 "        column=\"column_name\"\n"
 "        type=\"typename\"\n"
 "        update=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary SQL expression\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        not-null=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        generated=\"never|insert|always\"\n"
 "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
 "        index=\"index_name\"\n"
 "        unique_key=\"unique_key_id\"\n"
 "        length=\"L\"\n"
 "        precision=\"P\"\n"
 "        scale=\"S\"\n"
 "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2140
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the name of the property, with an initial lowercase "
 "letter."
 msgstr ""
 "<literal>name</literal>: el nombre de la propiedad, con la letra inicial en "
 "minúscula."
 
 #. Tag: para
 #: basic_mapping.xml:2145
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to the property name): the "
 "name of the mapped database table column. This can also be specified by "
 "nested <literal>&lt;column&gt;</literal> element(s)."
 msgstr ""
 "<literal>column</literal> (opcional - por defecto es el nombre de la "
 "propiedad): El nombre de la columna de la tabla de base de datos mapeada. "
 "Esto se puede especificar también con los elemento(s) anidado(s) "
 "<literal>&lt;column&gt;</literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2157
 #, no-c-format
 msgid ""
 "<literal>update, insert</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that the mapped columns should be included in SQL "
 "<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
 "Setting both to <literal>false</literal> allows a pure \"derived\" property "
 "whose value is initialized from some other property that maps to the same "
 "column(s), or by a trigger or other application."
 msgstr ""
 "<literal>update, insert</literal> (opcional - por defecto es <literal>true</"
 "literal>): Especifica que las columnas mapeadas deben ser incluídas en las "
 "declaraciones SQL <literal>UPDATE</literal> y/o <literal>INSERT</literal> . "
 "Especificando ambas como <literal>false</literal> permite una propiedad "
 "\"derivada\", cuyo valor se inicia desde alguna otra propiedad que mapee a "
 "la misma columna (o columnas) o por un disparador u otra aplicación."
 
 #. Tag: para
 #: basic_mapping.xml:2167
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an SQL expression that defines the "
 "value for a <emphasis>computed</emphasis> property. Computed properties do "
 "not have a column mapping of their own."
 msgstr ""
 "<literal>formula</literal> (opcional): una expresión SQL que define el valor "
 "para una propiedad <emphasis>computada</emphasis>. Las propiedades "
 "computadas no tienen una columna mapeada propia."
 
 #. Tag: para
 #: basic_mapping.xml:2180
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this property should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal> (opcional - por defecto es <literal>false</"
 "literal>): Especifica que se debe recuperar perezosamente esta propiedad "
 "cuando se acceda por primera vez la variable de instancia. Requiere "
 "instrumentación de código byte en tiempo de compilación."
 
 #. Tag: para
 #: basic_mapping.xml:2187
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): enables the DDL generation of a unique "
 "constraint for the columns. Also, allow this to be the target of a "
 "<literal>property-ref</literal>."
 msgstr ""
 "<literal>unique</literal> (opcional): Activa la generación DDL de una "
 "restricción de unicidad para las columnas. Además, permite que ésta sea el "
 "objetivo de una <literal>property-ref</literal>. "
 
 #. Tag: para
 #: basic_mapping.xml:2194
 #, no-c-format
 msgid ""
 "<literal>not-null</literal> (optional): enables the DDL generation of a "
 "nullability constraint for the columns."
 msgstr ""
 "<literal>not-null</literal> (opcional): Activa la generación DDL de una "
 "restricción de nulabilidad para las columnas. "
 
 #. Tag: para
 #: basic_mapping.xml:2199 basic_mapping.xml:3282
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this property do or do not require "
 "acquisition of the optimistic lock. In other words, it determines if a "
 "version increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal> (opcional - por defecto es <literal>true</"
 "literal>): Especifica que las actualizaciones a esta propiedad requieren o "
 "no de la obtención de un bloqueo optimista. En otras palabras, determina si "
 "debe ocurrir un incremento de versión cuando la propiedad se encuentre "
 "desactualizada."
 
 #. Tag: para
 #: basic_mapping.xml:2207
 #, no-c-format
 msgid ""
 "<literal>generated</literal> (optional - defaults to <literal>never</"
 "literal>): specifies that this property value is actually generated by the "
 "database. See the discussion of <link linkend=\"mapping-generated"
 "\">generated properties</link> for more information."
 msgstr ""
 "<literal>generated</literal> (opcional - por defecto es <literal>never</"
 "literal>): Especifica que este valor de la propiedad es de hecho generado "
 "por la base de datos. Consulte discusión sobre las <link linkend=\"mapping-"
 "generated\">propiedades generadas</link> para obtener mayor información. "
 
 #. Tag: para
 #: basic_mapping.xml:2216
 #, no-c-format
 msgid "<emphasis>typename</emphasis> could be:"
 msgstr "<emphasis>escribanombre</emphasis> puede ser:"
 
 #. Tag: para
 #: basic_mapping.xml:2241
 #, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
 "literal> attribute. For example, to distinguish between <literal>Hibernate."
 "DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
 "custom type."
 msgstr ""
 "Si no especifica un tipo, Hibernate utilizará reflección sobre la propiedad "
 "mencionada para deducir el tipo Hibernate correcto. Hibernate intentará "
 "interpretar el nombre de la clase de retorno del getter de la propiedad "
 "utilizando las reglas 2, 3 y 4 en ese mismo orden. En algunos casos "
 "necesitará el atributo <literal>type</literal>. Por ejemplo, para distinguir "
 "entre <literal>Hibernate.DATE</literal> y <literal>Hibernate.TIMESTAMP</"
 "literal>, o especificar un tipo personalizado."
 
 #. Tag: para
 #: basic_mapping.xml:2250
 #, no-c-format
 msgid ""
 "The <literal>access</literal> attribute allows you to control how Hibernate "
 "accesses the property at runtime. By default, Hibernate will call the "
 "property get/set pair. If you specify <literal>access=\"field\"</literal>, "
 "Hibernate will bypass the get/set pair and access the field directly using "
 "reflection. You can specify your own strategy for property access by naming "
 "a class that implements the interface <literal>org.hibernate.property."
 "PropertyAccessor</literal>."
 msgstr ""
 "El atributo <literal>access</literal> le permite controlar el cómo Hibernate "
 "accederá a la propiedad en tiempo de ejecución. Por defecto, Hibernate "
 "llamará al par de getter/setter de la propiedad. Si usted especifica "
 "<literal>access=\"field\"</literal>, Hibernate se saltará el par get/set y "
 "accederá al campo directamente utilizando reflección. Puede especificar su "
 "propia estrategia de acceso a la propiedad mencionando una clase que "
-"implemente la interfaz <literal>org.hibernate.property.PropertyAccessor</"
+"implemente la interfaz <literal>org.hibernate.property.access.spi.PropertyAccessStrategy</"
 "literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2259
 #, no-c-format
 msgid ""
 "A powerful feature is derived properties. These properties are by definition "
 "read-only. The property value is computed at load time. You declare the "
 "computation as an SQL expression. This then translates to a <literal>SELECT</"
 "literal> clause subquery in the SQL query that loads an instance:"
 msgstr ""
 "Una funcionalidad especialmente poderosa son las propiedades derivadas. "
 "Estas propiedades son, por definición, de sólo lectura. El valor de la "
 "propiedad se computa en tiempo de carga. Usted declara la computación como "
 "una expresión SQL y ésta se traduce como una cláusula de subconsulta "
 "<literal>SELECT</literal> en la consulta SQL que carga una instancia:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2265
 #, no-c-format
 msgid ""
 "&lt;property name=\"totalPrice\"\n"
 "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
 "p\n"
 "                WHERE li.productId = p.productId\n"
 "                AND li.customerId = customerId\n"
 "                AND li.orderNumber = orderNumber )\"/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2267
 #, no-c-format
 msgid ""
 "You can reference the entity table by not declaring an alias on a particular "
 "column. This would be <literal>customerId</literal> in the given example. "
 "You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
 "element if you do not want to use the attribute."
 msgstr ""
 "Puede referenciar la tabla de las entidades sin declarar un alias o una "
 "columna particular. En el ejemplo dado sería <literal>customerId</literal>. "
 "También puede utilizar el elemento anidado de mapeo <literal>&lt;formula&gt;"
 "</literal> si no quiere utilizar el atributo."
 
 #. Tag: title
 #: basic_mapping.xml:2276
 #, no-c-format
 msgid "Embedded objects (aka components)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2278
 #, fuzzy, no-c-format
 msgid ""
 "Embeddable objects (or components) are objects whose properties are mapped "
 "to the same table as the owning entity's table. Components can, in turn, "
 "declare their own properties, components or collections"
 msgstr ""
 "El elemento <literal>&lt;component&gt;</literal> mapea propiedades de un "
 "objeto hijo a columnas de la tabla de la clase padre. Los componentes "
 "pueden, a su vez, declarar sus propias propiedades, componentes o "
 "colecciones. Vea a continuación los \"componentes\":"
 
 #. Tag: para
 #: basic_mapping.xml:2283
 #, no-c-format
 msgid ""
 "It is possible to declare an embedded component inside an entity and even "
 "override its column mapping. Component classes have to be annotated at the "
 "class level with the <literal>@Embeddable</literal> annotation. It is "
 "possible to override the column mapping of an embedded object for a "
 "particular entity using the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride</literal> annotation in the associated property:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2291
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Person implements Serializable {\n"
 "\n"
 "    // Persistent component using defaults\n"
 "    Address homeAddress;\n"
 "\n"
 "    @Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"iso2\", column = @Column(name="
 "\"bornIso2\") ),\n"
 "            @AttributeOverride(name=\"name\", column = @Column(name="
 "\"bornCountryName\") )\n"
 "    } )\n"
 "    Country bornIn;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2293
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Address implements Serializable {\n"
 "    String city;\n"
 "    Country nationality; //no overriding here\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2295
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Country implements Serializable {\n"
 "    private String iso2;\n"
 "    @Column(name=\"countryName\") private String name;\n"
 "\n"
 "    public String getIso2() { return iso2; }\n"
 "    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
 "\n"
 "    \n"
 "    public String getName() { return name; }\n"
 "    public void setName(String name) { this.name = name; }\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2297
 #, no-c-format
 msgid ""
 "An embeddable object inherits the access type of its owning entity (note "
 "that you can override that using the <literal>@Access</literal> annotation)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2301
 #, no-c-format
 msgid ""
 "The <literal>Person</literal> entity has two component properties, "
 "<literal>homeAddress</literal> and <literal>bornIn</literal>. "
 "<literal>homeAddress</literal> property has not been annotated, but "
 "Hibernate will guess that it is a persistent component by looking for the "
 "<literal>@Embeddable</literal> annotation in the Address class. We also "
 "override the mapping of a column name (to <literal>bornCountryName</"
 "literal>) with the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride </literal>annotations for each mapped attribute "
 "of <literal>Country</literal>. As you can see, <literal>Country </literal>is "
 "also a nested component of <literal>Address</literal>, again using auto-"
 "detection by Hibernate and JPA defaults. Overriding columns of embedded "
 "objects of embedded objects is through dotted expressions."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2316
 #, no-c-format
 msgid ""
 "@Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"city\", column = @Column(name="
 "\"fld_city\") ),\n"
 "            @AttributeOverride(name=\"nationality.iso2\", column = @Column"
 "(name=\"nat_Iso2\") ),\n"
 "            @AttributeOverride(name=\"nationality.name\", column = @Column"
 "(name=\"nat_CountryName\") )\n"
 "            //nationality columns in homeAddress are overridden\n"
 "    } )\n"
 "    Address homeAddress;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2318
 #, no-c-format
 msgid ""
 "Hibernate Annotations supports something that is not explicitly supported by "
 "the JPA specification. You can annotate a embedded object with the "
 "<literal>@MappedSuperclass</literal> annotation to make the superclass "
 "properties persistent (see <literal>@MappedSuperclass</literal> for more "
 "informations)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2324
 #, no-c-format
 msgid ""
 "You can also use association annotations in an embeddable object (ie "
 "<literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, "
 "<classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To "
 "override the association columns you can use <literal>@AssociationOverride</"
 "literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2330
 #, no-c-format
 msgid ""
 "If you want to have the same embeddable object type twice in the same "
 "entity, the column name defaulting will not work as several embedded objects "
 "would share the same set of columns. In plain JPA, you need to override at "
 "least one set of columns. Hibernate, however, allows you to enhance the "
 "default naming mechanism through the <classname>NamingStrategy</classname> "
 "interface. You can write a strategy that prevent name clashing in such a "
 "situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an "
 "example of this."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2340
 #, no-c-format
 msgid ""
 "If a property of the embedded object points back to the owning entity, "
 "annotate it with the <classname>@Parent</classname> annotation. Hibernate "
 "will make sure this property is properly loaded with the entity reference."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2345
 #, no-c-format
 msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2367
 #, no-c-format
 msgid ""
 "&lt;component\n"
 "        name=\"propertyName\"\n"
 "        class=\"className\"\n"
 "        insert=\"true|false\"\n"
 "        update=\"true|false\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        node=\"element-name|.\"\n"
 "&gt;\n"
 "\n"
 "        &lt;property ...../&gt;\n"
 "        &lt;many-to-one .... /&gt;\n"
 "        ........\n"
 "&lt;/component&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
 #, no-c-format
 msgid "<literal>name</literal>: the name of the property."
 msgstr "<literal>name</literal>: El nombre de la propiedad. "
 
 #. Tag: para
 #: basic_mapping.xml:2375
 #, no-c-format
 msgid ""
 "<literal>class</literal> (optional - defaults to the property type "
 "determined by reflection): the name of the component (child) class."
 msgstr ""
 "<literal>class</literal> (opcional - por defecto es el tipo de la propiedad "
 "determinado por reflección): El nombre de la clase del componente (hijo). "
 
 #. Tag: para
 #: basic_mapping.xml:2381 basic_mapping.xml:3677
 #, no-c-format
 msgid ""
 "<literal>insert</literal>: do the mapped columns appear in SQL "
 "<literal>INSERTs</literal>?"
 msgstr ""
 "<literal>insert</literal>: ¿Las columnas mapeadas aparacen en "
 "<literal>INSERTs</literal> SQL? "
 
 #. Tag: para
 #: basic_mapping.xml:2386 basic_mapping.xml:3682
 #, no-c-format
 msgid ""
 "<literal>update</literal>: do the mapped columns appear in SQL "
 "<literal>UPDATEs</literal>?"
 msgstr ""
 "<literal>update</literal>: ¿Las columnas mapeadas aparacen en "
 "<literal>UPDATEs</literal> SQL?"
 
 #. Tag: para
 #: basic_mapping.xml:2397
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this component should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal> (opcional - por defecto es <literal>false</"
 "literal>): Especifica que este componente debe ser recuperado perezosamente "
 "cuando se acceda a la variable de instancia por primera vez. Requiere "
 "instrumentación de código byte en tiempo de compilación."
 
 #. Tag: para
 #: basic_mapping.xml:2404
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this component either do or do not "
 "require acquisition of the optimistic lock. It determines if a version "
 "increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal> (opcional - por defecto es <literal>true</"
 "literal>): Especifica que las actualizaciones de este componente requieren o "
 "no la adquisición de un bloqueo optimista. Determina si debe ocurrir un "
 "incremento de versión cuando esta propiedad se encuentra desactualizada."
 
 #. Tag: para
 #: basic_mapping.xml:2412 basic_mapping.xml:3695
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that a unique constraint exists upon all mapped columns of the "
 "component."
 msgstr ""
 "<literal>unique</literal> (opcional - por defecto es <literal>false</"
 "literal>): Especifica que existe una restricción de unicidad sobre todas las "
 "columnas mapeadas del componente."
 
 #. Tag: para
 #: basic_mapping.xml:2419
 #, no-c-format
 msgid ""
 "The child <literal>&lt;property&gt;</literal> tags map properties of the "
 "child class to table columns."
 msgstr ""
 "Las etiquetas hijas <literal>&lt;property&gt;</literal> mapean propiedades "
 "de la clase hija a las columnas de la tabla."
 
 #. Tag: para
 #: basic_mapping.xml:2422
 #, no-c-format
 msgid ""
 "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
 "parent&gt;</literal> subelement that maps a property of the component class "
 "as a reference back to the containing entity."
 msgstr ""
 "El elemento <literal>&lt;component&gt;</literal> permite un subelemento "
 "<literal>&lt;parent&gt;</literal> que mapea una propiedad de la clase del "
 "componente como una referencia a la entidad contenedora."
 
 #. Tag: para
 #: basic_mapping.xml:2426
 #, fuzzy, no-c-format
 msgid ""
 "The <literal>&lt;dynamic-component&gt;</literal> element allows a "
 "<literal>Map</literal> to be mapped as a component, where the property names "
 "refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for "
 "more information. This feature is not supported in annotations."
 msgstr ""
 "El elemento <literal>&lt;dynamic-component&gt;</literal> permite que un "
 "<literal>Map</literal> sea mapeado como un componente, en donde los nombres "
 "de las propiedades se refieran a las claves del mapeo. Consulte <xref "
 "linkend=\"components-dynamic\" /> para obtener mayor información. "
 
 #. Tag: title
 #: basic_mapping.xml:2434
 #, no-c-format
 msgid "Inheritance strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2436
 #, no-c-format
 msgid ""
 "Java is a language supporting polymorphism: a class can inherit from "
 "another. Several strategies are possible to persist a class hierarchy:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2442
 #, no-c-format
 msgid ""
 "Single table per class hierarchy strategy: a single table hosts all the "
 "instances of a class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2447
 #, no-c-format
 msgid ""
 "Joined subclass strategy: one table per class and subclass is present and "
 "each table persist the properties specific to a given subclass. The state of "
 "the entity is then stored in its corresponding class table and all its "
 "superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2454
 #, no-c-format
 msgid ""
 "Table per class strategy: one table per concrete class and subclass is "
 "present and each table persist the properties of the class and its "
 "superclasses. The state of the entity is then stored entirely in the "
 "dedicated table for its class."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2462
 #, no-c-format
 msgid "Single table per class hierarchy strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2464
 #, no-c-format
 msgid ""
 "With this approach the properties of all the subclasses in a given mapped "
 "class hierarchy are stored in a single table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2467
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass declares its own persistent properties and subclasses. Version "
 "and id properties are assumed to be inherited from the root class. Each "
 "subclass in a hierarchy must define a unique discriminator value. If this is "
 "not specified, the fully qualified Java class name is used."
 msgstr ""
 "Cada subclase debe declarar sus propias propiedades persistentes y "
 "subclases. Se asume que las propiedades <literal>&lt;version&gt;</literal> y "
 "<literal>&lt;id&gt;</literal> son heredadas de la clase raíz. Cada subclase "
 "en una jerarquía tiene que definir un <literal>discriminator-value</literal> "
 "único. Si no se especifica ninguno entonces se utiliza el nombre "
 "completamente calificado de clase Java."
 
 #. Tag: programlisting
 #: basic_mapping.xml:2473 basic_mapping.xml:2581
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
 "@DiscriminatorColumn(\n"
 "    name=\"planetype\",\n"
 "    discriminatorType=DiscriminatorType.STRING\n"
 ")\n"
 "@DiscriminatorValue(\"Plane\")\n"
 "public class Plane { ... }\n"
 "\n"
 "@Entity\n"
 "@DiscriminatorValue(\"A320\")\n"
 "public class A320 extends Plane { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2475
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, for the table-per-class-hierarchy mapping strategy, the "
 "<literal>&lt;subclass&gt;</literal> declaration is used. For example:"
 msgstr ""
 "La persistencia polimórfica requiere la declaración de cada subclase de la "
 "clase persistente raíz. Para la estrategia de mapeo tabla-por-jerarquía-de-"
 "clases, se utiliza la declaración <literal>&lt;subclass&gt;</literal>. Por "
 "ejemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2490
 #, no-c-format
 msgid ""
 "&lt;subclass\n"
 "        name=\"ClassName\"\n"
 "        discriminator-value=\"discriminator_value\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"\n"
 "        extends=\"SuperclassName\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the fully qualified class name of the subclass."
 msgstr ""
 "<literal>name</literal>: El nombre de clase completamente calificado de la "
 "subclase. "
 
 #. Tag: para
 #: basic_mapping.xml:2499
 #, no-c-format
 msgid ""
 "<literal>discriminator-value</literal> (optional - defaults to the class "
 "name): a value that distinguishes individual subclasses."
 msgstr ""
 "<literal>discriminator-value</literal> (opcional - por defecto es el nombre "
 "de la clase): Un valor que distingue subclases individuales. "
 
 #. Tag: para
 #: basic_mapping.xml:2505
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface used for "
 "lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal> (opcional): Especifica una clase o interfaz que se "
 "utiliza para proxies de inicialización perezosa."
 
 #. Tag: para
 #: basic_mapping.xml:2510
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal> (opcional, por defecto es <literal>true</literal>): "
 "El establecer <literal>lazy=\"false\"</literal> desactiva el uso de la "
 "recuperación perezosa. "
 
 #. Tag: para
 #: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
 #, fuzzy, no-c-format
 msgid ""
 "For information about inheritance mappings see <xref linkend=\"inheritance\"/"
 ">."
 msgstr ""
 "Para obtener información acerca de los mapeos de herencias consulte <xref "
 "linkend=\"inheritance\" />."
 
 #. Tag: title
 #: basic_mapping.xml:2522
 #, no-c-format
 msgid "Discriminator"
 msgstr "Discriminador"
 
 #. Tag: para
 #: basic_mapping.xml:2524
 #, fuzzy, no-c-format
 msgid ""
 "Discriminators are required for polymorphic persistence using the table-per-"
 "class-hierarchy mapping strategy. It declares a discriminator column of the "
 "table. The discriminator column contains marker values that tell the "
 "persistence layer what subclass to instantiate for a particular row. "
 "Hibernate Core supports the follwoing restricted set of types as "
 "discriminator column: <literal>string</literal>, <literal>character</"
 "literal>, <literal>integer</literal>, <literal>byte</literal>, "
 "<literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</"
 "literal>, <literal>true_false</literal>."
 msgstr ""
 "Se necesita el elemento <literal>&lt;discriminator&gt;</literal> para la "
 "persistencia polimórfica utilizando la estrategia de mapeo de tabla-por-"
 "jerarquía-de-clases. Declara una columna discriminadora de la tabla. La "
 "columna discriminidora contiene valores de marca que le dicen a la capa de "
 "persistencia qué subclase instanciar para una fila en particular. Se puede "
 "utilizar un conjunto restringido de tipos: <literal>string</literal>, "
 "<literal>character</literal>, <literal>integer</literal>, <literal>byte</"
 "literal>, <literal>short</literal>, <literal>boolean</literal>, "
 "<literal>yes_no</literal>, <literal>true_false</literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2535
 #, no-c-format
 msgid ""
 "Use the <classname>@DiscriminatorColumn</classname> to define the "
 "discriminator column as well as the discriminator type. <note> "
 "<para><classname>The enum DiscriminatorType</classname> used in "
 "<classname>javax.persitence.DiscriminatorColumn</classname> only contains "
 "the values <constant>STRING</constant>, <constant>CHAR</constant> and "
 "<constant>INTEGER</constant> which means that not all Hibernate supported "
 "types are available via the <classname>@DiscriminatorColumn</classname> "
 "annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</"
 "classname> to express in SQL a virtual discriminator column. This is "
 "particularly useful when the discriminator value can be extracted from one "
 "or more columns of the table. Both <classname>@DiscriminatorColumn</"
 "classname> and <classname>@DiscriminatorFormula</classname> are to be set on "
 "the root entity (once per persisted hierarchy)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2552
 #, no-c-format
 msgid ""
 "<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> "
 "allows to optionally specify Hibernate specific discriminator options which "
 "are not standardized in JPA. The available options are <literal>force</"
 "literal> and <literal>insert</literal>. The <literal>force</literal> "
 "attribute is useful if the table contains rows with \"extra\" discriminator "
 "values that are not mapped to a persistent class. This could for example "
 "occur when working with a legacy database. If <literal>force</literal> is "
 "set to <constant>true</constant> Hibernate will specify the allowed "
 "discriminator values in the <literal>SELECT</literal> query, even when "
 "retrieving all instances of the root class. The second option - "
 "<literal>insert</literal> - tells Hibernate whether or not to include the "
 "discriminator column in SQL <literal>INSERTs</literal>. Usually the column "
 "should be part of the <literal>INSERT</literal> statement, but if your "
 "discriminator column is also part of a mapped composite identifier you have "
 "to set this option to <constant>false</constant>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2569
 #, no-c-format
 msgid ""
 "There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</"
 "classname> annotation which is deprecated since version 3.6. Use "
 "<classname>@DiscriminatorOptions</classname> instead."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2575
 #, no-c-format
 msgid ""
 "Finally, use <classname>@DiscriminatorValue</classname> on each class of the "
 "hierarchy to specify the value stored in the discriminator column for a "
 "given entity. If you do not set <classname>@DiscriminatorValue</classname> "
 "on a class, the fully qualified class name is used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2583
 #, no-c-format
 msgid ""
 "In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to "
 "define the discriminator column or formula:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2600
 #, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "        column=\"discriminator_column\"\n"
 "        type=\"discriminator_type\"\n"
 "        force=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary sql expression\"\n"
 "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2604
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to <literal>class</literal>): "
 "the name of the discriminator column."
 msgstr ""
 "<literal>column</literal> (opcional - por defecto es <literal>class</"
 "literal>) el nombre de la columna discriminadora. "
 
 #. Tag: para
 #: basic_mapping.xml:2610
 #, no-c-format
 msgid ""
 "<literal>type</literal> (optional - defaults to <literal>string</literal>): "
 "a name that indicates the Hibernate type"
 msgstr ""
 "<literal>type</literal> (opcional - por defecto es <literal>string</"
 "literal>) un nombre que indica el tipo Hibernate. "
 
 #. Tag: para
 #: basic_mapping.xml:2616
 #, no-c-format
 msgid ""
 "<literal>force</literal> (optional - defaults to <literal>false</literal>): "
 "\"forces\" Hibernate to specify the allowed discriminator values, even when "
 "retrieving all instances of the root class."
 msgstr ""
 "<literal>force</literal> (opcional - por defecto es <literal>false</"
 "literal>) \"fuerza\" a Hibernate para especificar los valores "
 "discriminadores permitidos incluso cuando se recuperan todas las instancias "
 "de la clase raíz. "
 
 #. Tag: para
 #: basic_mapping.xml:2623
 #, no-c-format
 msgid ""
 "<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
 "set this to <literal>false</literal> if your discriminator column is also "
 "part of a mapped composite identifier. It tells Hibernate not to include the "
 "column in SQL <literal>INSERTs</literal>."
 msgstr ""
 "<literal>insert</literal> (opcional - por defecto es <literal>true</"
 "literal>): establecido como <literal>false</literal> si su columna "
 "discriminadora también es parte de un identificador mapeado compuesto. Lle "
 "dice a Hibernate que no incluya la columna en los SQLs <literal>INSERT</"
 "literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2631
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an arbitrary SQL expression that is "
 "executed when a type has to be evaluated. It allows content-based "
 "discrimination."
 msgstr ""
 "<literal>formula</literal> (opcional): una expresión SQL arbitraria que se "
 "ejecuta cuando se tenga que evaluar un tipo. Permite la discriminación con "
 "base en el contenido."
 
 #. Tag: para
 #: basic_mapping.xml:2638
 #, no-c-format
 msgid ""
 "Actual values of the discriminator column are specified by the "
 "<literal>discriminator-value</literal> attribute of the <literal>&lt;"
 "class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
 msgstr ""
 "Los valores reales de la columna discriminadora están especificados por el "
 "atributo <literal>discriminator-value</literal> de los elementos "
 "<literal>&lt;class&gt;</literal> y <literal>&lt;subclass&gt;</literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2643
 #, no-c-format
 msgid ""
 "The <literal>formula</literal> attribute allows you to declare an arbitrary "
 "SQL expression that will be used to evaluate the type of a row. For example:"
 msgstr ""
 "El atributo <literal>formula</literal> le permite declarar una expresión SQL "
 "arbitraria que será utilizada para evaluar el tipo de una fila. Por ejemplo: "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2647
 #, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
 "    type=\"integer\"/&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2652
 #, fuzzy, no-c-format
 msgid "Joined subclass strategy"
 msgstr "joined-subclass "
 
 #. Tag: para
 #: basic_mapping.xml:2654
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass can also be mapped to its own table. This is called the table-"
 "per-subclass mapping strategy. An inherited state is retrieved by joining "
 "with the table of the superclass. A discriminator column is not required for "
 "this mapping strategy. Each subclass must, however, declare a table column "
 "holding the object identifier. The primary key of this table is also a "
 "foreign key to the superclass table and described by the "
 "<classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</"
 "literal> element."
 msgstr ""
 "Se puede mapear cada subclase a su propia tabla. Esto se llama una "
 "estrategia de mapeo tabla-por-subclase. El estado heredado se recupera "
 "uniendo con la tabla de la superclase. Para hacer esto utilice elemento "
 "<literal>&lt;joined-subclass&gt;</literal>. Por ejemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2664
 #, no-c-format
 msgid ""
 "@Entity @Table(name=\"CATS\")\n"
 "@Inheritance(strategy=InheritanceType.JOINED)\n"
 "public class Cat implements Serializable { \n"
 "    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
 "    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
 "    String getId() { return id; }\n"
 "\n"
 "    ...\n"
 "}\n"
 "\n"
 "@Entity @Table(name=\"DOMESTIC_CATS\")\n"
 "@PrimaryKeyJoinColumn(name=\"CAT\")\n"
 "public class DomesticCat extends Cat { \n"
 "    public String getName() { return name; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2667
 #, no-c-format
 msgid ""
 "The table name still defaults to the non qualified class name. Also if "
 "<classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / "
 "foreign key columns are assumed to have the same names as the primary key "
 "columns of the primary table of the superclass."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2674
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For "
 "example:"
 msgstr ""
 "Puede declarar una clase persistente utilizando el elemento <literal>class</"
 "literal>. Por ejemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2688
 #, no-c-format
 msgid ""
 "&lt;joined-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;key .... &gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/joined-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2697 basic_mapping.xml:2761
 #, no-c-format
 msgid "<literal>table</literal>: the name of the subclass table."
 msgstr "<literal>table</literal>: El nombre de tabla de la subclase. "
 
 #. Tag: para
 #: basic_mapping.xml:2702 basic_mapping.xml:2766
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface to use "
 "for lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal> (opcional): Especifica una clase o interfaz que se "
 "debe utilizar para proxies de inicialización perezosa. "
 
 #. Tag: para
 #: basic_mapping.xml:2707 basic_mapping.xml:2771
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal> (opcional, por defecto es <literal>true</literal>): "
 "El establecer <literal>lazy=\"false\"</literal> desactiva el uso de la "
 "recuperación perezosa. "
 
 #. Tag: para
 #: basic_mapping.xml:2715
 #, no-c-format
 msgid ""
 "Use the <literal>&lt;key&gt;</literal> element to declare the primary key / "
 "foreign key column. The mapping at the start of the chapter would then be re-"
 "written as:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2719
 #, no-c-format
 msgid ""
 "&lt;?xml version=\"1.0\"?&gt;\n"
 "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
 "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
 "        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
 "\n"
 "&lt;hibernate-mapping package=\"eg\"&gt;\n"
 "\n"
 "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
 "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
 "                        &lt;generator class=\"hilo\"/&gt;\n"
 "                &lt;/id&gt;\n"
 "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
 "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"weight\"/&gt;\n"
 "                &lt;many-to-one name=\"mate\"/&gt;\n"
 "                &lt;set name=\"kittens\"&gt;\n"
 "                        &lt;key column=\"MOTHER\"/&gt;\n"
 "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
 "                &lt;/set&gt;\n"
 "                &lt;joined-subclass name=\"DomesticCat\" table="
 "\"DOMESTIC_CATS\"&gt;\n"
 "                    &lt;key column=\"CAT\"/&gt;\n"
 "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
 "                &lt;/joined-subclass&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "        &lt;class name=\"eg.Dog\"&gt;\n"
 "                &lt;!-- mapping for Dog could go here --&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "&lt;/hibernate-mapping&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2726
 #, no-c-format
 msgid "Table per class strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2728
 #, fuzzy, no-c-format
 msgid ""
 "A third option is to map only the concrete classes of an inheritance "
 "hierarchy to tables. This is called the table-per-concrete-class strategy. "
 "Each table defines all persistent states of the class, including the "
 "inherited state. In Hibernate, it is not necessary to explicitly map such "
 "inheritance hierarchies. You can map each class as a separate entity root. "
 "However, if you wish use polymorphic associations (e.g. an association to "
 "the superclass of your hierarchy), you need to use the union subclass "
 "mapping."
 msgstr ""
 "Una tercera opción es mapear sólo las clases concretas de una jerarquía de "
 "herencia a tablas. Esta se llama la estrategia clase concreta por tabla). "
 "Cada tabla define todos los estados persistentes de la clase, incluyendo el "
 "estado heredado. En Hibernate, no es necesario mapear dichas jerarquías de "
 "herencia. Puede mapear cada clase con una declaración <literal>&lt;class&gt;"
 "</literal> separada. Sin embargo, si desea utilizar asociaciones "
 "polimórficas (por ejemplo, una asociación a la superclase de su jerarquía), "
 "necesita utilizar el mapeo <literal>&lt;union-subclass&gt;</literal>. Por "
 "ejemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2737
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
 "public class Flight implements Serializable { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2739
 #, no-c-format
 msgid "Or in hbm.xml:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2752
 #, no-c-format
 msgid ""
 "&lt;union-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        abstract=\"true|false\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/union-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2779
 #, no-c-format
 msgid ""
 "No discriminator column or key column is required for this mapping strategy."
 msgstr ""
 "No se necesita una columna o una columna clave discriminadora para esta "
 "estrategia de mapeo."
 
 #. Tag: title
 #: basic_mapping.xml:2787
 #, no-c-format
 msgid "Inherit properties from superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2789
 #, no-c-format
 msgid ""
 "This is sometimes useful to share common properties through a technical or a "
 "business superclass without including it as a regular mapped entity (ie no "
 "specific table for this entity). For that purpose you can map them as "
 "<literal>@MappedSuperclass</literal>."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2794
 #, no-c-format
 msgid ""
 "@MappedSuperclass\n"
 "public class BaseEntity {\n"
 "    @Basic\n"
 "    @Temporal(TemporalType.TIMESTAMP)\n"
 "    public Date getLastUpdate() { ... }\n"
 "    public String getLastUpdater() { ... }\n"
 "    ...\n"
 "}\n"
 "\n"
 "@Entity class Order extends BaseEntity {\n"
 "    @Id public Integer getId() { ... }\n"
diff --git a/documentation/src/main/docbook/manual/pot/content/basic_mapping.pot b/documentation/src/main/docbook/manual/pot/content/basic_mapping.pot
index 2e572f3597..6f40594efd 100644
--- a/documentation/src/main/docbook/manual/pot/content/basic_mapping.pot
+++ b/documentation/src/main/docbook/manual/pot/content/basic_mapping.pot
@@ -2133,2001 +2133,2001 @@ msgstr ""
 #, no-c-format
 msgid "Partial identifier generation"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1443
 #, no-c-format
 msgid "Hibernate supports the automatic generation of some of the identifier properties. Simply use the <classname>@GeneratedValue</classname> annotation on one or several id properties."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1449
 #, no-c-format
 msgid "The Hibernate team has always felt such a construct as fundamentally wrong. Try hard to fix your data model before using this feature."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1454
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class CustomerInventory implements Serializable {\n"
       "  @Id\n"
       "  @TableGenerator(name = \"inventory\",\n"
       "    table = \"U_SEQUENCES\",\n"
       "    pkColumnName = \"S_ID\",\n"
       "    valueColumnName = \"S_NEXTNUM\",\n"
       "    pkColumnValue = \"inventory\",\n"
       "    allocationSize = 1000)\n"
       "  @GeneratedValue(strategy = GenerationType.TABLE, generator = \"inventory\")\n"
       "  Integer id;\n"
       "\n"
       "\n"
       "  @Id @ManyToOne(cascade = CascadeType.MERGE)\n"
       "  Customer customer;\n"
       "}\n"
       "\n"
       "@Entity\n"
       "public class Customer implements Serializable {\n"
       "   @Id\n"
       "   private int id;\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1456
 #, no-c-format
 msgid "You can also generate properties inside an <classname>@EmbeddedId</classname> class."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1462
 #, no-c-format
 msgid "Optimistic locking properties (optional)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1464
 #, no-c-format
 msgid "When using long transactions or conversations that span several database transactions, it is useful to store versioning data to ensure that if the same entity is updated by two conversations, the last to commit changes will be informed and not override the other conversation's work. It guarantees some isolation while still allowing for good scalability and works particularly well in read-often write-sometimes situations."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1472
 #, no-c-format
 msgid "You can use two approaches: a dedicated version number or a timestamp."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1475
 #, no-c-format
 msgid "A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <literal>unsaved-value</literal> strategies are specified. <emphasis>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</emphasis>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1485
 #, no-c-format
 msgid "Version number"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1487
 #, no-c-format
 msgid "You can add optimistic locking capability to an entity using the <literal>@Version</literal> annotation:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1490
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Flight implements Serializable {\n"
       "...\n"
       "    @Version\n"
       "    @Column(name=\"OPTLOCK\")\n"
       "    public Integer getVersion() { ... }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1492
 #, no-c-format
 msgid "The version property will be mapped to the <literal>OPTLOCK</literal> column, and the entity manager will use it to detect conflicting updates (preventing lost updates you might otherwise see with the last-commit-wins strategy)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1497
 #, no-c-format
 msgid "The version column may be a numeric. Hibernate supports any kind of type provided that you define and implement the appropriate <classname>UserVersionType</classname>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1501
 #, no-c-format
 msgid "The application must not alter the version number set up by Hibernate in any way. To artificially increase the version number, check in Hibernate Entity Manager's reference documentation <literal>LockModeType.OPTIMISTIC_FORCE_INCREMENT</literal> or <literal>LockModeType.PESSIMISTIC_FORCE_INCREMENT</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1507
 #, no-c-format
 msgid "If the version number is generated by the database (via a trigger for example), make sure to use <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code>"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1511
 #, no-c-format
 msgid "To declare a version property in hbm.xml, use:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1530
 #, no-c-format
 msgid ""
       "&lt;version\n"
       "        column=\"version_column\"\n"
       "        name=\"propertyName\"\n"
       "        type=\"typename\"\n"
       "        access=\"field|property|ClassName\"\n"
       "        unsaved-value=\"null|negative|undefined\"\n"
       "        generated=\"never|always\"\n"
       "        insert=\"true|false\"\n"
       "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
       "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1534
 #, no-c-format
 msgid "<literal>column</literal> (optional - defaults to the property name): the name of the column holding the version number."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1540
 #, no-c-format
 msgid "<literal>name</literal>: the name of a property of the persistent class."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1545
 #, no-c-format
 msgid "<literal>type</literal> (optional - defaults to <literal>integer</literal>): the type of the version number."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1551
 #, no-c-format
 msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses to access the property value."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1557
 #, no-c-format
 msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1567
 #, no-c-format
 msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this version property value is generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1575
 #, no-c-format
 msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): specifies whether the version column should be included in SQL insert statements. It can be set to <literal>false</literal> if the database column is defined with a default value of <literal>0</literal>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1586
 #, no-c-format
 msgid "Timestamp"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1588
 #, no-c-format
 msgid "Alternatively, you can use a timestamp. Timestamps are a less safe implementation of optimistic locking. However, sometimes an application might use the timestamps in other ways as well."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1592
 #, no-c-format
 msgid "Simply mark a property of type <classname>Date</classname> or <classname>Calendar</classname> as <classname>@Version</classname>."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1596
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Flight implements Serializable {\n"
       "...\n"
       "    @Version\n"
       "    public Date getLastUpdate() { ... }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1598
 #, no-c-format
 msgid "When using timestamp versioning you can tell Hibernate where to retrieve the timestamp value from - database or JVM - by optionally adding the <classname>@org.hibernate.annotations.Source</classname> annotation to the property. Possible values for the value attribute of the annotation are <classname>org.hibernate.annotations.SourceType.VM</classname> and <classname>org.hibernate.annotations.SourceType.DB</classname>. The default is <classname>SourceType.DB</classname> which is also used in case there is no <classname>@Source</classname> annotation at all."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1609
 #, no-c-format
 msgid "Like in the case of version numbers, the timestamp can also be generated by the database instead of Hibernate. To do that, use <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code>"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1613
 #, no-c-format
 msgid "In hbm.xml, use the <literal>&lt;timestamp&gt;</literal> element:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1631
 #, no-c-format
 msgid ""
       "&lt;timestamp\n"
       "        column=\"timestamp_column\"\n"
       "        name=\"propertyName\"\n"
       "        access=\"field|property|ClassName\"\n"
       "        unsaved-value=\"null|undefined\"\n"
       "        source=\"vm|db\"\n"
       "        generated=\"never|always\"\n"
       "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
       "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1635
 #, no-c-format
 msgid "<literal>column</literal> (optional - defaults to the property name): the name of a column holding the timestamp."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1641
 #, no-c-format
 msgid "<literal>name</literal>: the name of a JavaBeans style property of Java type <literal>Date</literal> or <literal>Timestamp</literal> of the persistent class."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1647 basic_mapping.xml:2174 basic_mapping.xml:2391 basic_mapping.xml:3262 basic_mapping.xml:3456 basic_mapping.xml:3629
 #, no-c-format
 msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses for accessing the property value."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1653
 #, no-c-format
 msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1663
 #, no-c-format
 msgid "<literal>source</literal> (optional - defaults to <literal>vm</literal>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the \"next value\". It is safer to use in clustered environments. Not all <literal>Dialects</literal> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1676
 #, no-c-format
 msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this timestamp property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1686
 #, no-c-format
 msgid "Note"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1688
 #, no-c-format
 msgid "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp\"&gt;</literal>"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1697
 #, no-c-format
 msgid "Property"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1699
 #, no-c-format
 msgid "You need to decide which property needs to be made persistent in a given entity. This differs slightly between the annotation driven metadata and the hbm.xml files."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1704
 #, no-c-format
 msgid "Property mapping with annotations"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1706
 #, no-c-format
 msgid "In the annotations world, every non static non transient property (field or method depending on the access type) of an entity is considered persistent, unless you annotate it as <literal>@Transient</literal>. Not having an annotation for your property is equivalent to the appropriate <literal>@Basic</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1713
 #, no-c-format
 msgid "The <literal>@Basic</literal> annotation allows you to declare the fetching strategy for a property. If set to <literal>LAZY</literal>, specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation, if your classes are not instrumented, property level lazy loading is silently ignored. The default is <literal>EAGER</literal>. You can also mark a property as not optional thanks to the <classname>@Basic.optional</classname> attribute. This will ensure that the underlying column are not nullable (if possible). Note that a better approach is to use the <classname>@NotNull</classname> annotation of the Bean Validation specification."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1726
 #, no-c-format
 msgid "Let's look at a few examples:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1728
 #, no-c-format
 msgid ""
       "public transient int counter; //transient property\n"
       "\n"
       "private String firstname; //persistent property\n"
       "\n"
       "@Transient\n"
       "String getLengthInMeter() { ... } //transient property\n"
       "\n"
       "String getName() {... } // persistent property\n"
       "\n"
       "@Basic\n"
       "int getLength() { ... } // persistent property\n"
       "\n"
       "@Basic(fetch = FetchType.LAZY)\n"
       "String getDetailedComment() { ... } // persistent property\n"
       "\n"
       "@Temporal(TemporalType.TIME)\n"
       "java.util.Date getDepartureTime() { ... } // persistent property           \n"
       "\n"
       "@Enumerated(EnumType.STRING)\n"
       "Starred getNote() { ... } //enum persisted as String in database"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1730
 #, no-c-format
 msgid "<literal>counter</literal>, a transient field, and <literal>lengthInMeter</literal>, a method annotated as <literal>@Transient</literal>, and will be ignored by the Hibernate. <literal>name</literal>, <literal>length</literal>, and <literal>firstname</literal> properties are mapped persistent and eagerly fetched (the default for simple properties). The <literal>detailedComment</literal> property value will be lazily fetched from the database once a lazy property of the entity is accessed for the first time. Usually you don't need to lazy simple properties (not to be confused with lazy association fetching). The recommended alternative is to use the projection capability of JP-QL (Java Persistence Query Language) or Criteria queries."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1743
 #, no-c-format
 msgid "JPA support property mapping of all basic types supported by Hibernate (all basic Java types , their respective wrappers and serializable classes). Hibernate Annotations supports out of the box enum type mapping either into a ordinal column (saving the enum ordinal) or a string based column (saving the enum string representation): the persistence representation, defaulted to ordinal, can be overridden through the <literal>@Enumerated</literal> annotation as shown in the <literal>note</literal> property example."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1753
 #, no-c-format
 msgid "In plain Java APIs, the temporal precision of time is not defined. When dealing with temporal data you might want to describe the expected precision in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, only the time, or both). Use the <literal>@Temporal</literal> annotation to fine tune that."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1761
 #, no-c-format
 msgid "<literal>@Lob</literal> indicates that the property should be persisted in a Blob or a Clob depending on the property type: <classname>java.sql.Clob</classname>, <classname>Character[]</classname>, <classname>char[]</classname> and java.lang.<classname>String</classname> will be persisted in a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, <classname>byte[] </classname>and <classname>Serializable</classname> type will be persisted in a Blob."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1770
 #, no-c-format
 msgid ""
       "@Lob\n"
       "public String getFullText() {\n"
       "    return fullText;\n"
       "}\n"
       "\n"
       "@Lob\n"
       "public byte[] getFullCode() {\n"
       "    return fullCode;\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1772
 #, no-c-format
 msgid "If the property type implements <classname>java.io.Serializable</classname> and is not a basic type, and if the property is not annotated with <literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> type is used."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1779
 #, no-c-format
 msgid "Type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1781
 #, no-c-format
 msgid "You can also manually specify a type using the <literal>@org.hibernate.annotations.Type</literal> and some parameters if needed. <classname>@Type.type</classname> could be:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1788 basic_mapping.xml:2220
 #, no-c-format
 msgid "The name of a Hibernate basic type: <literal>integer, string, character, date, timestamp, float, binary, serializable, object, blob</literal> etc."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1794 basic_mapping.xml:2226
 #, no-c-format
 msgid "The name of a Java class with a default basic type: <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal> etc."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1800 basic_mapping.xml:2232
 #, no-c-format
 msgid "The name of a serializable Java class."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1804 basic_mapping.xml:2236
 #, no-c-format
 msgid "The class name of a custom type: <literal>com.illflow.type.MyCustomType</literal> etc."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1809
 #, no-c-format
 msgid "If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1814
 #, no-c-format
 msgid "<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org.hibernate.annotations.TypeDefs</literal> allows you to declare type definitions. These annotations can be placed at the class or package level. Note that these definitions are global for the session factory (even when defined at the class level). If the type is used on a single entity, you can place the definition on the entity itself. Otherwise, it is recommended to place the definition at the package level. In the example below, when Hibernate encounters a property of class <literal>PhoneNumer</literal>, it delegates the persistence strategy to the custom mapping type <literal>PhoneNumberType</literal>. However, properties belonging to other classes, too, can delegate their persistence strategy to <literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1830
 #, no-c-format
 msgid "Package level annotations are placed in a file named <filename>package-info.java</filename> in the appropriate package. Place your annotations before the package declaration."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1835
 #, no-c-format
 msgid ""
       "@TypeDef(\n"
       "   name = \"phoneNumber\",\n"
       "   defaultForType = PhoneNumber.class,\n"
       "   typeClass = PhoneNumberType.class\n"
       ")\n"
       "\n"
       "@Entity\n"
       "public class ContactDetails {\n"
       "   [...]\n"
       "   private PhoneNumber localPhoneNumber;\n"
       "   @Type(type=\"phoneNumber\")\n"
       "   private OverseasPhoneNumber overseasPhoneNumber;\n"
       "   [...]\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1837
 #, no-c-format
 msgid "The following example shows the usage of the <literal>parameters</literal> attribute to customize the TypeDef."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1841
 #, no-c-format
 msgid ""
       "//in org/hibernate/test/annotations/entity/package-info.java\n"
       "@TypeDefs(\n"
       "    {\n"
       "    @TypeDef(\n"
       "        name=\"caster\",\n"
       "        typeClass = CasterStringType.class,\n"
       "        parameters = {\n"
       "            @Parameter(name=\"cast\", value=\"lower\")\n"
       "        }\n"
       "    )\n"
       "    }\n"
       ")\n"
       "package org.hibernate.test.annotations.entity;\n"
       "\n"
       "//in org/hibernate/test/annotations/entity/Forest.java\n"
       "public class Forest {\n"
       "    @Type(type=\"caster\")\n"
       "    public String getSmallText() {\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1843
 #, no-c-format
 msgid "When using composite user type, you will have to express column definitions. The <literal>@Columns</literal> has been introduced for that purpose."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1847
 #, no-c-format
 msgid ""
       "@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType\")\n"
       "@Columns(columns = {\n"
       "    @Column(name=\"r_amount\"),\n"
       "    @Column(name=\"r_currency\")\n"
       "})\n"
       "public MonetaryAmount getAmount() {\n"
       "    return amount;\n"
       "}\n"
       "\n"
       "\n"
       "public class MonetaryAmount implements Serializable {\n"
       "    private BigDecimal amount;\n"
       "    private Currency currency;\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1851
 #, no-c-format
 msgid "Access type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1853
 #, no-c-format
 msgid "By default the access type of a class hierarchy is defined by the position of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> annotations. If these annotations are on a field, then only fields are considered for persistence and the state is accessed via the field. If there annotations are on a getter, then only the getters are considered for persistence and the state is accessed via the getter/setter. That works well in practice and is the recommended approach."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1861
 #, no-c-format
 msgid "The placement of annotations within a class hierarchy has to be consistent (either field or on property) to be able to determine the default access type. It is recommended to stick to one single annotation placement strategy throughout your whole application."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1868
 #, no-c-format
 msgid "However in some situations, you need to:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1872
 #, no-c-format
 msgid "force the access type of the entity hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1876
 #, no-c-format
 msgid "override the access type of a specific entity in the class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1881
 #, no-c-format
 msgid "override the access type of an embeddable type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1885
 #, no-c-format
 msgid "The best use case is an embeddable class used by several entities that might not use the same access type. In this case it is better to force the access type at the embeddable class level."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1890
 #, no-c-format
 msgid "To force the access type on a given class, use the <classname>@Access</classname> annotation as showed below:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1893
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Order {\n"
       "   @Id private Long id;\n"
       "   public Long getId() { return id; }\n"
       "   public void setId(Long id) { this.id = id; }\n"
       "\n"
       "   @Embedded private Address address;\n"
       "   public Address getAddress() { return address; }\n"
       "   public void setAddress() { this.address = address; }\n"
       "}\n"
       "\n"
       "@Entity\n"
       "public class User {\n"
       "   private Long id;\n"
       "   @Id public Long getId() { return id; }\n"
       "   public void setId(Long id) { this.id = id; }\n"
       "\n"
       "   private Address address;\n"
       "   @Embedded public Address getAddress() { return address; }\n"
       "   public void setAddress() { this.address = address; }\n"
       "}\n"
       "\n"
       "@Embeddable\n"
       "@Access(AcessType.PROPERTY)\n"
       "public class Address {\n"
       "   private String street1;\n"
       "   public String getStreet1() { return street1; }\n"
       "   public void setStreet1() { this.street1 = street1; }\n"
       "\n"
       "   private hashCode; //not persistent\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1895
 #, no-c-format
 msgid "You can also override the access type of a single property while keeping the other properties standard."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1898
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Order {\n"
       "   @Id private Long id;\n"
       "   public Long getId() { return id; }\n"
       "   public void setId(Long id) { this.id = id; }\n"
       "   @Transient private String userId;\n"
       "   @Transient private String orderId;\n"
       "\n"
       "   @Access(AccessType.PROPERTY)\n"
       "   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
       "   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1900
 #, no-c-format
 msgid "In this example, the default access type is <classname>FIELD</classname> except for the <literal>orderNumber</literal> property. Note that the corresponding field, if any must be marked as <classname>@Transient</classname> or <code>transient</code>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1907
 #, no-c-format
 msgid "@org.hibernate.annotations.AccessType"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1909
 #, no-c-format
 msgid "The annotation <classname>@org.hibernate.annotations.AccessType</classname> should be considered deprecated for FIELD and PROPERTY access. It is still useful however if you need to use a custom access type."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1918
 #, no-c-format
 msgid "Optimistic lock"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1920
 #, no-c-format
 msgid "It is sometimes useful to avoid increasing the version number even if a given property is dirty (particularly collections). You can do that by annotating the property (or collection) with <literal>@OptimisticLock(excluded=true)</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1925
 #, no-c-format
 msgid "More formally, specifies that updates to this property do not require acquisition of the optimistic lock."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1930
 #, no-c-format
 msgid "Declaring column attributes"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1932
 #, no-c-format
 msgid "The column(s) used for a property mapping can be defined using the <literal>@Column</literal> annotation. Use it to override default values (see the JPA specification for more information on the defaults). You can use this annotation at the property level for properties that are:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1940
 #, no-c-format
 msgid "not annotated at all"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1944
 #, no-c-format
 msgid "annotated with <literal>@Basic</literal>"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1948
 #, no-c-format
 msgid "annotated with <literal>@Version</literal>"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1952
 #, no-c-format
 msgid "annotated with <literal>@Lob</literal>"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1956
 #, no-c-format
 msgid "annotated with <literal>@Temporal</literal>"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1960
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Flight implements Serializable {\n"
       "...\n"
       "@Column(updatable = false, name = \"flight_name\", nullable = false, length=50)\n"
       "public String getName() { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1962
 #, no-c-format
 msgid "The <literal>name</literal> property is mapped to the <literal>flight_name</literal> column, which is not nullable, has a length of 50 and is not updatable (making the property immutable)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1967
 #, no-c-format
 msgid "This annotation can be applied to regular properties as well as <literal>@Id</literal> or <literal>@Version</literal> properties."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1994
 #, no-c-format
 msgid ""
       "@Column(\n"
       "    name=\"columnName\";\n"
       "    boolean unique() default false;\n"
       "    boolean nullable() default true;\n"
       "    boolean insertable() default true;\n"
       "    boolean updatable() default true;\n"
       "    String columnDefinition() default \"\";\n"
       "    String table() default \"\";\n"
       "    int length() default 255;\n"
       "    int precision() default 0; // decimal precision\n"
       "    int scale() default 0; // decimal scale"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1998
 #, no-c-format
 msgid "<literal>name</literal> (optional): the column name (default to the property name)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2003
 #, no-c-format
 msgid "<literal>unique</literal> (optional): set a unique constraint on this column or not (default false)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2008
 #, no-c-format
 msgid "<literal>nullable</literal> (optional): set the column as nullable (default true)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2013
 #, no-c-format
 msgid "<literal>insertable</literal> (optional): whether or not the column will be part of the insert statement (default true)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2019
 #, no-c-format
 msgid "<literal>updatable</literal> (optional): whether or not the column will be part of the update statement (default true)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2025
 #, no-c-format
 msgid "<literal>columnDefinition</literal> (optional): override the sql DDL fragment for this particular column (non portable)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2031
 #, no-c-format
 msgid "<literal>table</literal> (optional): define the targeted table (default primary table)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2036
 #, no-c-format
 msgid "<literal><literal>length</literal></literal> (optional): column length (default 255)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2041
 #, no-c-format
 msgid "<literal><literal>precision</literal></literal> (optional): column decimal precision (default 0)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2046
 #, no-c-format
 msgid "<literal><literal>scale</literal></literal> (optional): column decimal scale if useful (default 0)"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2054
 #, no-c-format
 msgid "Formula"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2056
 #, no-c-format
 msgid "Sometimes, you want the Database to do some computation for you rather than in the JVM, you might also create some kind of virtual column. You can use a SQL fragment (aka formula) instead of mapping a property into a column. This kind of property is read only (its value is calculated by your formula fragment)."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2062
 #, no-c-format
 msgid ""
       "@Formula(\"obj_length * obj_height * obj_width\")\n"
       "public long getObjectVolume()"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2064
 #, no-c-format
 msgid "The SQL fragment can be as complex as you want and even include subselects."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2069
 #, no-c-format
 msgid "Non-annotated property defaults"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2071
 #, no-c-format
 msgid "If a property is not annotated, the following rules apply:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2074
 #, no-c-format
 msgid "If the property is of a single type, it is mapped as @Basic"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2079
 #, no-c-format
 msgid "Otherwise, if the type of the property is annotated as @Embeddable, it is mapped as @Embedded"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2084
 #, no-c-format
 msgid "Otherwise, if the type of the property is <classname>Serializable</classname>, it is mapped as <classname>@Basic</classname> in a column holding the object in its serialized version"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2091
 #, no-c-format
 msgid "Otherwise, if the type of the property is <classname>java.sql.Clob</classname> or <classname>java.sql.Blob</classname>, it is mapped as <classname>@Lob</classname> with the appropriate <classname>LobType</classname>"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2102
 #, no-c-format
 msgid "Property mapping with hbm.xml"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2104
 #, no-c-format
 msgid "The <literal>&lt;property&gt;</literal> element declares a persistent JavaBean style property of the class."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2136
 #, no-c-format
 msgid ""
       "&lt;property\n"
       "        name=\"propertyName\"\n"
       "        column=\"column_name\"\n"
       "        type=\"typename\"\n"
       "        update=\"true|false\"\n"
       "        insert=\"true|false\"\n"
       "        formula=\"arbitrary SQL expression\"\n"
       "        access=\"field|property|ClassName\"\n"
       "        lazy=\"true|false\"\n"
       "        unique=\"true|false\"\n"
       "        not-null=\"true|false\"\n"
       "        optimistic-lock=\"true|false\"\n"
       "        generated=\"never|insert|always\"\n"
       "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
       "        index=\"index_name\"\n"
       "        unique_key=\"unique_key_id\"\n"
       "        length=\"L\"\n"
       "        precision=\"P\"\n"
       "        scale=\"S\"\n"
       "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2140
 #, no-c-format
 msgid "<literal>name</literal>: the name of the property, with an initial lowercase letter."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2145
 #, no-c-format
 msgid "<literal>column</literal> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2157
 #, no-c-format
 msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>): specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2167
 #, no-c-format
 msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> property. Computed properties do not have a column mapping of their own."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2180
 #, no-c-format
 msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2187
 #, no-c-format
 msgid "<literal>unique</literal> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <literal>property-ref</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2194
 #, no-c-format
 msgid "<literal>not-null</literal> (optional): enables the DDL generation of a nullability constraint for the columns."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2199 basic_mapping.xml:3282
 #, no-c-format
 msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2207
 #, no-c-format
 msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2216
 #, no-c-format
 msgid "<emphasis>typename</emphasis> could be:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2241
 #, no-c-format
 msgid "If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <literal>type</literal> attribute. For example, to distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom type."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2250
 #, no-c-format
-msgid "The <literal>access</literal> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.PropertyAccessor</literal>."
+msgid "The <literal>access</literal> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.access.spi.PropertyAccessStrategy</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2259
 #, no-c-format
 msgid "A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <literal>SELECT</literal> clause subquery in the SQL query that loads an instance:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2265
 #, no-c-format
 msgid ""
       "&lt;property name=\"totalPrice\"\n"
       "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p\n"
       "                WHERE li.productId = p.productId\n"
       "                AND li.customerId = customerId\n"
       "                AND li.orderNumber = orderNumber )\"/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2267
 #, no-c-format
 msgid "You can reference the entity table by not declaring an alias on a particular column. This would be <literal>customerId</literal> in the given example. You can also use the nested <literal>&lt;formula&gt;</literal> mapping element if you do not want to use the attribute."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2276
 #, no-c-format
 msgid "Embedded objects (aka components)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2278
 #, no-c-format
 msgid "Embeddable objects (or components) are objects whose properties are mapped to the same table as the owning entity's table. Components can, in turn, declare their own properties, components or collections"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2283
 #, no-c-format
 msgid "It is possible to declare an embedded component inside an entity and even override its column mapping. Component classes have to be annotated at the class level with the <literal>@Embeddable</literal> annotation. It is possible to override the column mapping of an embedded object for a particular entity using the <literal>@Embedded</literal> and <literal>@AttributeOverride</literal> annotation in the associated property:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2291
 #, no-c-format
 msgid ""
       "@Entity\n"
       "public class Person implements Serializable {\n"
       "\n"
       "    // Persistent component using defaults\n"
       "    Address homeAddress;\n"
       "\n"
       "    @Embedded\n"
       "    @AttributeOverrides( {\n"
       "            @AttributeOverride(name=\"iso2\", column = @Column(name=\"bornIso2\") ),\n"
       "            @AttributeOverride(name=\"name\", column = @Column(name=\"bornCountryName\") )\n"
       "    } )\n"
       "    Country bornIn;\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2293
 #, no-c-format
 msgid ""
       "@Embeddable\n"
       "public class Address implements Serializable {\n"
       "    String city;\n"
       "    Country nationality; //no overriding here\n"
       "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2295
 #, no-c-format
 msgid ""
       "@Embeddable\n"
       "public class Country implements Serializable {\n"
       "    private String iso2;\n"
       "    @Column(name=\"countryName\") private String name;\n"
       "\n"
       "    public String getIso2() { return iso2; }\n"
       "    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
       "\n"
       "    \n"
       "    public String getName() { return name; }\n"
       "    public void setName(String name) { this.name = name; }\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2297
 #, no-c-format
 msgid "An embeddable object inherits the access type of its owning entity (note that you can override that using the <literal>@Access</literal> annotation)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2301
 #, no-c-format
 msgid "The <literal>Person</literal> entity has two component properties, <literal>homeAddress</literal> and <literal>bornIn</literal>. <literal>homeAddress</literal> property has not been annotated, but Hibernate will guess that it is a persistent component by looking for the <literal>@Embeddable</literal> annotation in the Address class. We also override the mapping of a column name (to <literal>bornCountryName</literal>) with the <literal>@Embedded</literal> and <literal>@AttributeOverride </literal>annotations for each mapped attribute of <literal>Country</literal>. As you can see, <literal>Country </literal>is also a nested component of <literal>Address</literal>, again using auto-detection by Hibernate and JPA defaults. Overriding columns of embedded objects of embedded objects is through dotted expressions."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2316
 #, no-c-format
 msgid ""
       "@Embedded\n"
       "    @AttributeOverrides( {\n"
       "            @AttributeOverride(name=\"city\", column = @Column(name=\"fld_city\") ),\n"
       "            @AttributeOverride(name=\"nationality.iso2\", column = @Column(name=\"nat_Iso2\") ),\n"
       "            @AttributeOverride(name=\"nationality.name\", column = @Column(name=\"nat_CountryName\") )\n"
       "            //nationality columns in homeAddress are overridden\n"
       "    } )\n"
       "    Address homeAddress;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2318
 #, no-c-format
 msgid "Hibernate Annotations supports something that is not explicitly supported by the JPA specification. You can annotate a embedded object with the <literal>@MappedSuperclass</literal> annotation to make the superclass properties persistent (see <literal>@MappedSuperclass</literal> for more informations)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2324
 #, no-c-format
 msgid "You can also use association annotations in an embeddable object (ie <literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, <classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To override the association columns you can use <literal>@AssociationOverride</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2330
 #, no-c-format
 msgid "If you want to have the same embeddable object type twice in the same entity, the column name defaulting will not work as several embedded objects would share the same set of columns. In plain JPA, you need to override at least one set of columns. Hibernate, however, allows you to enhance the default naming mechanism through the <classname>NamingStrategy</classname> interface. You can write a strategy that prevent name clashing in such a situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an example of this."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2340
 #, no-c-format
 msgid "If a property of the embedded object points back to the owning entity, annotate it with the <classname>@Parent</classname> annotation. Hibernate will make sure this property is properly loaded with the entity reference."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2345
 #, no-c-format
 msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2367
 #, no-c-format
 msgid ""
       "&lt;component\n"
       "        name=\"propertyName\"\n"
       "        class=\"className\"\n"
       "        insert=\"true|false\"\n"
       "        update=\"true|false\"\n"
       "        access=\"field|property|ClassName\"\n"
       "        lazy=\"true|false\"\n"
       "        optimistic-lock=\"true|false\"\n"
       "        unique=\"true|false\"\n"
       "        node=\"element-name|.\"\n"
       "&gt;\n"
       "\n"
       "        &lt;property ...../&gt;\n"
       "        &lt;many-to-one .... /&gt;\n"
       "        ........\n"
       "&lt;/component&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
 #, no-c-format
 msgid "<literal>name</literal>: the name of the property."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2375
 #, no-c-format
 msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the name of the component (child) class."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2381 basic_mapping.xml:3677
 #, no-c-format
 msgid "<literal>insert</literal>: do the mapped columns appear in SQL <literal>INSERTs</literal>?"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2386 basic_mapping.xml:3682
 #, no-c-format
 msgid "<literal>update</literal>: do the mapped columns appear in SQL <literal>UPDATEs</literal>?"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2397
 #, no-c-format
 msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2404
 #, no-c-format
 msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2412 basic_mapping.xml:3695
 #, no-c-format
 msgid "<literal>unique</literal> (optional - defaults to <literal>false</literal>): specifies that a unique constraint exists upon all mapped columns of the component."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2419
 #, no-c-format
 msgid "The child <literal>&lt;property&gt;</literal> tags map properties of the child class to table columns."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2422
 #, no-c-format
 msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2426
 #, no-c-format
 msgid "The <literal>&lt;dynamic-component&gt;</literal> element allows a <literal>Map</literal> to be mapped as a component, where the property names refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for more information. This feature is not supported in annotations."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2434
 #, no-c-format
 msgid "Inheritance strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2436
 #, no-c-format
 msgid "Java is a language supporting polymorphism: a class can inherit from another. Several strategies are possible to persist a class hierarchy:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2442
 #, no-c-format
 msgid "Single table per class hierarchy strategy: a single table hosts all the instances of a class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2447
 #, no-c-format
 msgid "Joined subclass strategy: one table per class and subclass is present and each table persist the properties specific to a given subclass. The state of the entity is then stored in its corresponding class table and all its superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2454
 #, no-c-format
 msgid "Table per class strategy: one table per concrete class and subclass is present and each table persist the properties of the class and its superclasses. The state of the entity is then stored entirely in the dedicated table for its class."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2462
 #, no-c-format
 msgid "Single table per class hierarchy strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2464
 #, no-c-format
 msgid "With this approach the properties of all the subclasses in a given mapped class hierarchy are stored in a single table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2467
 #, no-c-format
 msgid "Each subclass declares its own persistent properties and subclasses. Version and id properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique discriminator value. If this is not specified, the fully qualified Java class name is used."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2473 basic_mapping.xml:2581
 #, no-c-format
 msgid ""
       "@Entity\n"
       "@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
       "@DiscriminatorColumn(\n"
       "    name=\"planetype\",\n"
       "    discriminatorType=DiscriminatorType.STRING\n"
       ")\n"
       "@DiscriminatorValue(\"Plane\")\n"
       "public class Plane { ... }\n"
       "\n"
       "@Entity\n"
       "@DiscriminatorValue(\"A320\")\n"
       "public class A320 extends Plane { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2475
 #, no-c-format
 msgid "In hbm.xml, for the table-per-class-hierarchy mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used. For example:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2490
 #, no-c-format
 msgid ""
       "&lt;subclass\n"
       "        name=\"ClassName\"\n"
       "        discriminator-value=\"discriminator_value\"\n"
       "        proxy=\"ProxyInterface\"\n"
       "        lazy=\"true|false\"\n"
       "        dynamic-update=\"true|false\"\n"
       "        dynamic-insert=\"true|false\"\n"
       "        entity-name=\"EntityName\"\n"
       "        node=\"element-name\"\n"
       "        extends=\"SuperclassName\"&gt;\n"
       "\n"
       "        &lt;property .... /&gt;\n"
       "        .....\n"
       "&lt;/subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
 #, no-c-format
 msgid "<literal>name</literal>: the fully qualified class name of the subclass."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2499
 #, no-c-format
 msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): a value that distinguishes individual subclasses."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2505
 #, no-c-format
 msgid "<literal>proxy</literal> (optional): specifies a class or interface used for lazy initializing proxies."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2510
 #, no-c-format
 msgid "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
 #, no-c-format
 msgid "For information about inheritance mappings see <xref linkend=\"inheritance\"/>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2522
 #, no-c-format
 msgid "Discriminator"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2524
 #, no-c-format
 msgid "Discriminators are required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. Hibernate Core supports the follwoing restricted set of types as discriminator column: <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2535
 #, no-c-format
 msgid "Use the <classname>@DiscriminatorColumn</classname> to define the discriminator column as well as the discriminator type. <note> <para><classname>The enum DiscriminatorType</classname> used in <classname>javax.persitence.DiscriminatorColumn</classname> only contains the values <constant>STRING</constant>, <constant>CHAR</constant> and <constant>INTEGER</constant> which means that not all Hibernate supported types are available via the <classname>@DiscriminatorColumn</classname> annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</classname> to express in SQL a virtual discriminator column. This is particularly useful when the discriminator value can be extracted from one or more columns of the table. Both <classname>@DiscriminatorColumn</classname> and <classname>@DiscriminatorFormula</classname> are to be set on the root entity (once per persisted hierarchy)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2552
 #, no-c-format
 msgid "<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> allows to optionally specify Hibernate specific discriminator options which are not standardized in JPA. The available options are <literal>force</literal> and <literal>insert</literal>. The <literal>force</literal> attribute is useful if the table contains rows with \"extra\" discriminator values that are not mapped to a persistent class. This could for example occur when working with a legacy database. If <literal>force</literal> is set to <constant>true</constant> Hibernate will specify the allowed discriminator values in the <literal>SELECT</literal> query, even when retrieving all instances of the root class. The second option - <literal>insert</literal> - tells Hibernate whether or not to include the discriminator column in SQL <literal>INSERTs</literal>. Usually the column should be part of the <literal>INSERT</literal> statement, but if your discriminator column is also part of a mapped composite identifier you have to set this option to <constant>false</constant>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2569
 #, no-c-format
 msgid "There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</classname> annotation which is deprecated since version 3.6. Use <classname>@DiscriminatorOptions</classname> instead."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2575
 #, no-c-format
 msgid "Finally, use <classname>@DiscriminatorValue</classname> on each class of the hierarchy to specify the value stored in the discriminator column for a given entity. If you do not set <classname>@DiscriminatorValue</classname> on a class, the fully qualified class name is used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2583
 #, no-c-format
 msgid "In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to define the discriminator column or formula:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2600
 #, no-c-format
 msgid ""
       "&lt;discriminator\n"
       "        column=\"discriminator_column\"\n"
       "        type=\"discriminator_type\"\n"
       "        force=\"true|false\"\n"
       "        insert=\"true|false\"\n"
       "        formula=\"arbitrary sql expression\"\n"
       "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2604
 #, no-c-format
 msgid "<literal>column</literal> (optional - defaults to <literal>class</literal>): the name of the discriminator column."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2610
 #, no-c-format
 msgid "<literal>type</literal> (optional - defaults to <literal>string</literal>): a name that indicates the Hibernate type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2616
 #, no-c-format
 msgid "<literal>force</literal> (optional - defaults to <literal>false</literal>): \"forces\" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2623
 #, no-c-format
 msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): set this to <literal>false</literal> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <literal>INSERTs</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2631
 #, no-c-format
 msgid "<literal>formula</literal> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2638
 #, no-c-format
 msgid "Actual values of the discriminator column are specified by the <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2643
 #, no-c-format
 msgid "The <literal>formula</literal> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2647
 #, no-c-format
 msgid ""
       "&lt;discriminator\n"
       "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
       "    type=\"integer\"/&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2652
 #, no-c-format
 msgid "Joined subclass strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2654
 #, no-c-format
 msgid "Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the <classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2664
 #, no-c-format
 msgid ""
       "@Entity @Table(name=\"CATS\")\n"
       "@Inheritance(strategy=InheritanceType.JOINED)\n"
       "public class Cat implements Serializable { \n"
       "    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
       "    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
       "    String getId() { return id; }\n"
       "\n"
       "    ...\n"
       "}\n"
       "\n"
       "@Entity @Table(name=\"DOMESTIC_CATS\")\n"
       "@PrimaryKeyJoinColumn(name=\"CAT\")\n"
       "public class DomesticCat extends Cat { \n"
       "    public String getName() { return name; }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2667
 #, no-c-format
 msgid "The table name still defaults to the non qualified class name. Also if <classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2674
 #, no-c-format
 msgid "In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For example:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2688
 #, no-c-format
 msgid ""
       "&lt;joined-subclass\n"
       "        name=\"ClassName\"\n"
       "        table=\"tablename\"\n"
       "        proxy=\"ProxyInterface\"\n"
       "        lazy=\"true|false\"\n"
       "        dynamic-update=\"true|false\"\n"
       "        dynamic-insert=\"true|false\"\n"
       "        schema=\"schema\"\n"
       "        catalog=\"catalog\"\n"
       "        extends=\"SuperclassName\"\n"
       "        persister=\"ClassName\"\n"
       "        subselect=\"SQL expression\"\n"
       "        entity-name=\"EntityName\"\n"
       "        node=\"element-name\"&gt;\n"
       "\n"
       "        &lt;key .... &gt;\n"
       "\n"
       "        &lt;property .... /&gt;\n"
       "        .....\n"
       "&lt;/joined-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2697 basic_mapping.xml:2761
 #, no-c-format
 msgid "<literal>table</literal>: the name of the subclass table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2702 basic_mapping.xml:2766
 #, no-c-format
 msgid "<literal>proxy</literal> (optional): specifies a class or interface to use for lazy initializing proxies."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2707 basic_mapping.xml:2771
 #, no-c-format
 msgid "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2715
 #, no-c-format
 msgid "Use the <literal>&lt;key&gt;</literal> element to declare the primary key / foreign key column. The mapping at the start of the chapter would then be re-written as:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2719
 #, no-c-format
 msgid ""
       "&lt;?xml version=\"1.0\"?&gt;\n"
       "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
       "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
       "        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
       "\n"
       "&lt;hibernate-mapping package=\"eg\"&gt;\n"
       "\n"
       "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
       "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
       "                        &lt;generator class=\"hilo\"/&gt;\n"
       "                &lt;/id&gt;\n"
       "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
       "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
       "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
       "                &lt;property name=\"weight\"/&gt;\n"
       "                &lt;many-to-one name=\"mate\"/&gt;\n"
       "                &lt;set name=\"kittens\"&gt;\n"
       "                        &lt;key column=\"MOTHER\"/&gt;\n"
       "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
       "                &lt;/set&gt;\n"
       "                &lt;joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS\"&gt;\n"
       "                    &lt;key column=\"CAT\"/&gt;\n"
       "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
       "                &lt;/joined-subclass&gt;\n"
       "        &lt;/class&gt;\n"
       "\n"
       "        &lt;class name=\"eg.Dog\"&gt;\n"
       "                &lt;!-- mapping for Dog could go here --&gt;\n"
       "        &lt;/class&gt;\n"
       "\n"
       "&lt;/hibernate-mapping&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2726
 #, no-c-format
 msgid "Table per class strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2728
 #, no-c-format
 msgid "A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2737
 #, no-c-format
 msgid ""
       "@Entity\n"
       "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
       "public class Flight implements Serializable { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2739
 #, no-c-format
 msgid "Or in hbm.xml:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2752
 #, no-c-format
 msgid ""
       "&lt;union-subclass\n"
       "        name=\"ClassName\"\n"
       "        table=\"tablename\"\n"
       "        proxy=\"ProxyInterface\"\n"
       "        lazy=\"true|false\"\n"
       "        dynamic-update=\"true|false\"\n"
       "        dynamic-insert=\"true|false\"\n"
       "        schema=\"schema\"\n"
       "        catalog=\"catalog\"\n"
       "        extends=\"SuperclassName\"\n"
       "        abstract=\"true|false\"\n"
       "        persister=\"ClassName\"\n"
       "        subselect=\"SQL expression\"\n"
       "        entity-name=\"EntityName\"\n"
       "        node=\"element-name\"&gt;\n"
       "\n"
       "        &lt;property .... /&gt;\n"
       "        .....\n"
       "&lt;/union-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2779
 #, no-c-format
 msgid "No discriminator column or key column is required for this mapping strategy."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2787
 #, no-c-format
 msgid "Inherit properties from superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2789
 #, no-c-format
 msgid "This is sometimes useful to share common properties through a technical or a business superclass without including it as a regular mapped entity (ie no specific table for this entity). For that purpose you can map them as <literal>@MappedSuperclass</literal>."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2794
 #, no-c-format
 msgid ""
       "@MappedSuperclass\n"
       "public class BaseEntity {\n"
       "    @Basic\n"
       "    @Temporal(TemporalType.TIMESTAMP)\n"
       "    public Date getLastUpdate() { ... }\n"
       "    public String getLastUpdater() { ... }\n"
       "    ...\n"
       "}\n"
       "\n"
       "@Entity class Order extends BaseEntity {\n"
       "    @Id public Integer getId() { ... }\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2796
 #, no-c-format
 msgid "In database, this hierarchy will be represented as an <literal>Order</literal> table having the <literal>id</literal>, <literal>lastUpdate</literal> and <literal>lastUpdater</literal> columns. The embedded superclass property mappings are copied into their entity subclasses. Remember that the embeddable superclass is not the root of the hierarchy though."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2804
 #, no-c-format
 msgid "Properties from superclasses not mapped as <literal>@MappedSuperclass</literal> are ignored."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2809
 #, no-c-format
 msgid "The default access type (field or methods) is used, unless you use the <literal>@Access</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2814
 #, no-c-format
 msgid "The same notion can be applied to <literal>@Embeddable</literal> objects to persist properties from their superclasses. You also need to use <literal>@MappedSuperclass</literal> to do that (this should not be considered as a standard EJB3 feature though)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2822
 #, no-c-format
 msgid "It is allowed to mark a class as <literal>@MappedSuperclass</literal> in the middle of the mapped inheritance hierarchy."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2828
 #, no-c-format
 msgid "Any class in the hierarchy non annotated with <literal>@MappedSuperclass</literal> nor <literal>@Entity</literal> will be ignored."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2833
 #, no-c-format
 msgid "You can override columns defined in entity superclasses at the root entity level using the <literal>@AttributeOverride</literal> annotation."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2837
 #, no-c-format
 msgid ""
       "@MappedSuperclass\n"
       "public class FlyingObject implements Serializable {\n"
       "\n"
       "    public int getAltitude() {\n"
       "        return altitude;\n"
       "    }\n"
       "\n"
       "    @Transient\n"
       "    public int getMetricAltitude() {\n"
       "        return metricAltitude;\n"
       "    }\n"
       "\n"
       "    @ManyToOne\n"
       "    public PropulsionType getPropulsion() {\n"
       "        return metricAltitude;\n"
       "    }\n"
       "    ...\n"
       "}\n"
       "\n"
       "@Entity\n"
       "@AttributeOverride( name=\"altitude\", column = @Column(name=\"fld_altitude\") )\n"
       "@AssociationOverride( \n"
       "   name=\"propulsion\", \n"
       "   joinColumns = @JoinColumn(name=\"fld_propulsion_fk\") \n"
       ")\n"
       "public class Plane extends FlyingObject {\n"
       "    ...\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2839
 #, no-c-format
 msgid "The <literal>altitude</literal> property will be persisted in an <literal>fld_altitude</literal> column of table <literal>Plane</literal> and the propulsion association will be materialized in a <literal>fld_propulsion_fk</literal> foreign key column."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2845
 #, no-c-format
 msgid "You can define <literal>@AttributeOverride</literal>(s) and <literal>@AssociationOverride</literal>(s) on <literal>@Entity</literal> classes, <literal>@MappedSuperclass</literal> classes and properties pointing to an <literal>@Embeddable</literal> object."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2851
 #, no-c-format
 msgid "In hbm.xml, simply map the properties of the superclass in the <literal>&lt;class&gt;</literal> element of the entity that needs to inherit them."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2857
 #, no-c-format
 msgid "Mapping one entity to several tables"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2859
 #, no-c-format
 msgid "While not recommended for a fresh schema, some legacy databases force your to map a single entity on several tables."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2862
 #, no-c-format
 msgid "Using the <literal>@SecondaryTable</literal> or <literal>@SecondaryTables</literal> class level annotations. To express that a column is in a particular table, use the <literal>table</literal> parameter of <literal>@Column</literal> or <literal>@JoinColumn</literal>."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2868
 #, no-c-format
 msgid ""
       "@Entity\n"
       "@Table(name=\"MainCat\")\n"
       "@SecondaryTables({\n"
       "    @SecondaryTable(name=\"Cat1\", pkJoinColumns={\n"
       "        @PrimaryKeyJoinColumn(name=\"cat_id\", referencedColumnName=\"id\")\n"
       "    ),\n"
       "    @SecondaryTable(name=\"Cat2\", uniqueConstraints={@UniqueConstraint(columnNames={\"storyPart2\"})})\n"
       "})\n"
       "public class Cat implements Serializable {\n"
       "\n"
       "    private Integer id;\n"
       "    private String name;\n"
       "    private String storyPart1;\n"
       "    private String storyPart2;\n"
       "\n"
       "    @Id @GeneratedValue\n"
       "    public Integer getId() {\n"
       "        return id;\n"
       "    }\n"
       "\n"
       "    public String getName() {\n"
       "        return name;\n"
       "    }\n"
       "    \n"
       "    @Column(table=\"Cat1\")\n"
       "    public String getStoryPart1() {\n"
       "        return storyPart1;\n"
       "    }\n"
       "\n"
       "    @Column(table=\"Cat2\")\n"
       "    public String getStoryPart2() {\n"
       "        return storyPart2;\n"
       "    }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2870
 #, no-c-format
 msgid "In this example, <literal>name</literal> will be in <literal>MainCat</literal>. <literal>storyPart1</literal> will be in <literal>Cat1</literal> and <literal>storyPart2</literal> will be in <literal>Cat2</literal>. <literal>Cat1</literal> will be joined to <literal>MainCat</literal> using the <literal>cat_id</literal> as a foreign key, and <literal>Cat2</literal> using <literal>id</literal> (ie the same column name, the <literal>MainCat</literal> id column has). Plus a unique constraint on <literal>storyPart2</literal> has been set."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2880
 #, no-c-format
 msgid "There is also additional tuning accessible via the <classname>@org.hibernate.annotations.Table</classname> annotation:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2886
 #, no-c-format
 msgid "<literal>fetch</literal>: If set to JOIN, the default, Hibernate will use an inner join to retrieve a secondary table defined by a class or its superclasses and an outer join for a secondary table defined by a subclass. If set to <classname>SELECT</classname> then Hibernate will use a sequential select for a secondary table defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. Inner joins will still be used to retrieve a secondary defined by the class and its superclasses."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2898
 #, no-c-format
 msgid "<literal>inverse</literal>: If true, Hibernate will not try to insert or update the properties defined by this join. Default to false."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2904
 #, no-c-format
 msgid "<literal>optional</literal>: If enabled (the default), Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2911
 #, no-c-format
 msgid "<literal>foreignKey</literal>: defines the Foreign Key name of a secondary table pointing back to the primary table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2916
 #, no-c-format
 msgid "Make sure to use the secondary table name in the <methodname>appliesto</methodname> property"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2919
 #, no-c-format
 msgid ""
       "@Entity\n"
       "@Table(name=\"MainCat\")\n"
       "@SecondaryTable(name=\"Cat1\")\n"
       "@org.hibernate.annotations.Table(\n"
       "   appliesTo=\"Cat1\",\n"
       "   fetch=FetchMode.SELECT,\n"
       "   optional=true)\n"
       "public class Cat implements Serializable {\n"
       "\n"
       "    private Integer id;\n"
       "    private String name;\n"
       "    private String storyPart1;\n"
       "    private String storyPart2;\n"
       "\n"
       "    @Id @GeneratedValue\n"
       "    public Integer getId() {\n"
       "        return id;\n"
       "    }\n"
       "\n"
       "    public String getName() {\n"
       "        return name;\n"
       "    }\n"
       "    \n"
       "    @Column(table=\"Cat1\")\n"
       "    public String getStoryPart1() {\n"
       "        return storyPart1;\n"
       "    }\n"
       "\n"
       "    @Column(table=\"Cat2\")\n"
       "    public String getStoryPart2() {\n"
       "        return storyPart2;\n"
       "    }\n"
       "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2921
 #, no-c-format
 msgid "In hbm.xml, use the <literal>&lt;join&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2939
 #, no-c-format
 msgid ""
       "&lt;join\n"
       "        table=\"tablename\"\n"
       "        schema=\"owner\"\n"
       "        catalog=\"catalog\"\n"
       "        fetch=\"join|select\"\n"
       "        inverse=\"true|false\"\n"
       "        optional=\"true|false\"&gt;\n"
       "\n"
       "        &lt;key ... /&gt;\n"
       "\n"
       "        &lt;property ... /&gt;\n"
       "        ...\n"
       "&lt;/join&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2943
 #, no-c-format
 msgid "<literal>table</literal>: the name of the joined table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2960
 #, no-c-format
 msgid "<literal>fetch</literal> (optional - defaults to <literal>join</literal>): if set to <literal>join</literal>, the default, Hibernate will use an inner join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses. It will use an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass. If set to <literal>select</literal> then Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its superclasses."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2975
 #, no-c-format
 msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will not insert or update the properties defined by this join."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2981
 #, no-c-format
 msgid "<literal>optional</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2989
 #, no-c-format
 msgid "For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2993
 #, no-c-format
 msgid ""
       "&lt;class name=\"Person\"\n"
       "    table=\"PERSON\"&gt;\n"
       "\n"
       "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;...&lt;/id&gt;\n"
       "\n"
       "    &lt;join table=\"ADDRESS\"&gt;\n"
       "        &lt;key column=\"ADDRESS_ID\"/&gt;\n"
       "        &lt;property name=\"address\"/&gt;\n"
       "        &lt;property name=\"zip\"/&gt;\n"
       "        &lt;property name=\"country\"/&gt;\n"
       "    &lt;/join&gt;\n"
       "    ..."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2995
 #, no-c-format
 msgid "This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:3003
 #, no-c-format
 msgid "Mapping one to one and one to many associations"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:3005
diff --git a/documentation/src/main/docbook/manual/pt-BR/content/basic_mapping.po b/documentation/src/main/docbook/manual/pt-BR/content/basic_mapping.po
index a0f988ded7..cb84f18fd1 100644
--- a/documentation/src/main/docbook/manual/pt-BR/content/basic_mapping.po
+++ b/documentation/src/main/docbook/manual/pt-BR/content/basic_mapping.po
@@ -3698,2001 +3698,2001 @@ msgstr ""
 #, no-c-format
 msgid "Note"
 msgstr "Nota"
 
 #. Tag: para
 #: basic_mapping.xml:1688
 #, no-c-format
 msgid ""
 "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
 "type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
 "\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
 "\"&gt;</literal>"
 msgstr ""
 "Observe que o <literal>&lt;timestamp&gt;</literal> é equivalente a "
 "<literal>&lt;version type=\"timestamp\"&gt;</literal>. E <literal>&lt;"
 "timestamp source=\"db\"&gt;</literal> é equivalente a <literal>&lt;version "
 "type=\"dbtimestamp\"&gt;</literal>."
 
 #. Tag: title
 #: basic_mapping.xml:1697
 #, no-c-format
 msgid "Property"
 msgstr "Propriedade "
 
 #. Tag: para
 #: basic_mapping.xml:1699
 #, no-c-format
 msgid ""
 "You need to decide which property needs to be made persistent in a given "
 "entity. This differs slightly between the annotation driven metadata and the "
 "hbm.xml files."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1704
 #, no-c-format
 msgid "Property mapping with annotations"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1706
 #, no-c-format
 msgid ""
 "In the annotations world, every non static non transient property (field or "
 "method depending on the access type) of an entity is considered persistent, "
 "unless you annotate it as <literal>@Transient</literal>. Not having an "
 "annotation for your property is equivalent to the appropriate "
 "<literal>@Basic</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1713
 #, no-c-format
 msgid ""
 "The <literal>@Basic</literal> annotation allows you to declare the fetching "
 "strategy for a property. If set to <literal>LAZY</literal>, specifies that "
 "this property should be fetched lazily when the instance variable is first "
 "accessed. It requires build-time bytecode instrumentation, if your classes "
 "are not instrumented, property level lazy loading is silently ignored. The "
 "default is <literal>EAGER</literal>. You can also mark a property as not "
 "optional thanks to the <classname>@Basic.optional</classname> attribute. "
 "This will ensure that the underlying column are not nullable (if possible). "
 "Note that a better approach is to use the <classname>@NotNull</classname> "
 "annotation of the Bean Validation specification."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1726
 #, no-c-format
 msgid "Let's look at a few examples:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1728
 #, no-c-format
 msgid ""
 "public transient int counter; //transient property\n"
 "\n"
 "private String firstname; //persistent property\n"
 "\n"
 "@Transient\n"
 "String getLengthInMeter() { ... } //transient property\n"
 "\n"
 "String getName() {... } // persistent property\n"
 "\n"
 "@Basic\n"
 "int getLength() { ... } // persistent property\n"
 "\n"
 "@Basic(fetch = FetchType.LAZY)\n"
 "String getDetailedComment() { ... } // persistent property\n"
 "\n"
 "@Temporal(TemporalType.TIME)\n"
 "java.util.Date getDepartureTime() { ... } // persistent property           \n"
 "\n"
 "@Enumerated(EnumType.STRING)\n"
 "Starred getNote() { ... } //enum persisted as String in database"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1730
 #, no-c-format
 msgid ""
 "<literal>counter</literal>, a transient field, and <literal>lengthInMeter</"
 "literal>, a method annotated as <literal>@Transient</literal>, and will be "
 "ignored by the Hibernate. <literal>name</literal>, <literal>length</"
 "literal>, and <literal>firstname</literal> properties are mapped persistent "
 "and eagerly fetched (the default for simple properties). The "
 "<literal>detailedComment</literal> property value will be lazily fetched "
 "from the database once a lazy property of the entity is accessed for the "
 "first time. Usually you don't need to lazy simple properties (not to be "
 "confused with lazy association fetching). The recommended alternative is to "
 "use the projection capability of JP-QL (Java Persistence Query Language) or "
 "Criteria queries."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1743
 #, no-c-format
 msgid ""
 "JPA support property mapping of all basic types supported by Hibernate (all "
 "basic Java types , their respective wrappers and serializable classes). "
 "Hibernate Annotations supports out of the box enum type mapping either into "
 "a ordinal column (saving the enum ordinal) or a string based column (saving "
 "the enum string representation): the persistence representation, defaulted "
 "to ordinal, can be overridden through the <literal>@Enumerated</literal> "
 "annotation as shown in the <literal>note</literal> property example."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1753
 #, no-c-format
 msgid ""
 "In plain Java APIs, the temporal precision of time is not defined. When "
 "dealing with temporal data you might want to describe the expected precision "
 "in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</"
 "literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, "
 "only the time, or both). Use the <literal>@Temporal</literal> annotation to "
 "fine tune that."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1761
 #, no-c-format
 msgid ""
 "<literal>@Lob</literal> indicates that the property should be persisted in a "
 "Blob or a Clob depending on the property type: <classname>java.sql.Clob</"
 "classname>, <classname>Character[]</classname>, <classname>char[]</"
 "classname> and java.lang.<classname>String</classname> will be persisted in "
 "a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, "
 "<classname>byte[] </classname>and <classname>Serializable</classname> type "
 "will be persisted in a Blob."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1770
 #, no-c-format
 msgid ""
 "@Lob\n"
 "public String getFullText() {\n"
 "    return fullText;\n"
 "}\n"
 "\n"
 "@Lob\n"
 "public byte[] getFullCode() {\n"
 "    return fullCode;\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1772
 #, no-c-format
 msgid ""
 "If the property type implements <classname>java.io.Serializable</classname> "
 "and is not a basic type, and if the property is not annotated with "
 "<literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> "
 "type is used."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1779
 #, no-c-format
 msgid "Type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1781
 #, no-c-format
 msgid ""
 "You can also manually specify a type using the <literal>@org.hibernate."
 "annotations.Type</literal> and some parameters if needed. <classname>@Type."
 "type</classname> could be:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1788 basic_mapping.xml:2220
 #, no-c-format
 msgid ""
 "The name of a Hibernate basic type: <literal>integer, string, character, "
 "date, timestamp, float, binary, serializable, object, blob</literal> etc."
 msgstr ""
 "O nome de um tipo básico de Hibernate: <literal>integer, string, character, "
 "date, timestamp, float, binary, serializable, object, blob</literal>, etc. "
 
 #. Tag: para
 #: basic_mapping.xml:1794 basic_mapping.xml:2226
 #, no-c-format
 msgid ""
 "The name of a Java class with a default basic type: <literal>int, float, "
 "char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
 "literal> etc."
 msgstr ""
 "O nome da classe Java com um tipo básico padrão: <literal>int, float, char, "
 "java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
 "literal>, etc."
 
 #. Tag: para
 #: basic_mapping.xml:1800 basic_mapping.xml:2232
 #, no-c-format
 msgid "The name of a serializable Java class."
 msgstr "O nome da classe Java serializável"
 
 #. Tag: para
 #: basic_mapping.xml:1804 basic_mapping.xml:2236
 #, no-c-format
 msgid ""
 "The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
 "literal> etc."
 msgstr ""
 "O nome da classe de um tipo customizado: <literal>com.illflow.type."
 "MyCustomType</literal>, etc."
 
 #. Tag: para
 #: basic_mapping.xml:1809
 #, fuzzy, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4."
 msgstr ""
 "Se você não especificar um tipo, o Hibernate irá utilizar reflexão sobre a "
 "propriedade nomeada para ter uma idéia do tipo de Hibernate correto. O "
 "Hibernate tentará interpretar o nome da classe retornada, usando as regras "
 "2, 3 e 4 nesta ordem. Em certos casos, você ainda precisará do atributo "
 "<literal>type</literal>. Por exemplo, para distinguir entre "
 "<literal>Hibernate.DATE</literal> e <literal>Hibernate.TIMESTAMP</literal>, "
 "ou para especificar um tipo customizado."
 
 #. Tag: para
 #: basic_mapping.xml:1814
 #, no-c-format
 msgid ""
 "<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org."
 "hibernate.annotations.TypeDefs</literal> allows you to declare type "
 "definitions. These annotations can be placed at the class or package level. "
 "Note that these definitions are global for the session factory (even when "
 "defined at the class level). If the type is used on a single entity, you can "
 "place the definition on the entity itself. Otherwise, it is recommended to "
 "place the definition at the package level. In the example below, when "
 "Hibernate encounters a property of class <literal>PhoneNumer</literal>, it "
 "delegates the persistence strategy to the custom mapping type "
 "<literal>PhoneNumberType</literal>. However, properties belonging to other "
 "classes, too, can delegate their persistence strategy to "
 "<literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</"
 "literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1830
 #, no-c-format
 msgid ""
 "Package level annotations are placed in a file named <filename>package-info."
 "java</filename> in the appropriate package. Place your annotations before "
 "the package declaration."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1835
 #, no-c-format
 msgid ""
 "@TypeDef(\n"
 "   name = \"phoneNumber\",\n"
 "   defaultForType = PhoneNumber.class,\n"
 "   typeClass = PhoneNumberType.class\n"
 ")\n"
 "\n"
 "@Entity\n"
 "public class ContactDetails {\n"
 "   [...]\n"
 "   private PhoneNumber localPhoneNumber;\n"
 "   @Type(type=\"phoneNumber\")\n"
 "   private OverseasPhoneNumber overseasPhoneNumber;\n"
 "   [...]\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1837
 #, no-c-format
 msgid ""
 "The following example shows the usage of the <literal>parameters</literal> "
 "attribute to customize the TypeDef."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1841
 #, no-c-format
 msgid ""
 "//in org/hibernate/test/annotations/entity/package-info.java\n"
 "@TypeDefs(\n"
 "    {\n"
 "    @TypeDef(\n"
 "        name=\"caster\",\n"
 "        typeClass = CasterStringType.class,\n"
 "        parameters = {\n"
 "            @Parameter(name=\"cast\", value=\"lower\")\n"
 "        }\n"
 "    )\n"
 "    }\n"
 ")\n"
 "package org.hibernate.test.annotations.entity;\n"
 "\n"
 "//in org/hibernate/test/annotations/entity/Forest.java\n"
 "public class Forest {\n"
 "    @Type(type=\"caster\")\n"
 "    public String getSmallText() {\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1843
 #, no-c-format
 msgid ""
 "When using composite user type, you will have to express column definitions. "
 "The <literal>@Columns</literal> has been introduced for that purpose."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1847
 #, no-c-format
 msgid ""
 "@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType"
 "\")\n"
 "@Columns(columns = {\n"
 "    @Column(name=\"r_amount\"),\n"
 "    @Column(name=\"r_currency\")\n"
 "})\n"
 "public MonetaryAmount getAmount() {\n"
 "    return amount;\n"
 "}\n"
 "\n"
 "\n"
 "public class MonetaryAmount implements Serializable {\n"
 "    private BigDecimal amount;\n"
 "    private Currency currency;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1851
 #, no-c-format
 msgid "Access type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1853
 #, no-c-format
 msgid ""
 "By default the access type of a class hierarchy is defined by the position "
 "of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> "
 "annotations. If these annotations are on a field, then only fields are "
 "considered for persistence and the state is accessed via the field. If there "
 "annotations are on a getter, then only the getters are considered for "
 "persistence and the state is accessed via the getter/setter. That works well "
 "in practice and is the recommended approach."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1861
 #, no-c-format
 msgid ""
 "The placement of annotations within a class hierarchy has to be consistent "
 "(either field or on property) to be able to determine the default access "
 "type. It is recommended to stick to one single annotation placement strategy "
 "throughout your whole application."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1868
 #, no-c-format
 msgid "However in some situations, you need to:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1872
 #, no-c-format
 msgid "force the access type of the entity hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1876
 #, no-c-format
 msgid "override the access type of a specific entity in the class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1881
 #, no-c-format
 msgid "override the access type of an embeddable type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1885
 #, no-c-format
 msgid ""
 "The best use case is an embeddable class used by several entities that might "
 "not use the same access type. In this case it is better to force the access "
 "type at the embeddable class level."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1890
 #, no-c-format
 msgid ""
 "To force the access type on a given class, use the <classname>@Access</"
 "classname> annotation as showed below:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1893
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   @Embedded private Address address;\n"
 "   public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Entity\n"
 "public class User {\n"
 "   private Long id;\n"
 "   @Id public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   private Address address;\n"
 "   @Embedded public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Embeddable\n"
 "@Access(AcessType.PROPERTY)\n"
 "public class Address {\n"
 "   private String street1;\n"
 "   public String getStreet1() { return street1; }\n"
 "   public void setStreet1() { this.street1 = street1; }\n"
 "\n"
 "   private hashCode; //not persistent\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1895
 #, no-c-format
 msgid ""
 "You can also override the access type of a single property while keeping the "
 "other properties standard."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1898
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "   @Transient private String userId;\n"
 "   @Transient private String orderId;\n"
 "\n"
 "   @Access(AccessType.PROPERTY)\n"
 "   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
 "   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1900
 #, no-c-format
 msgid ""
 "In this example, the default access type is <classname>FIELD</classname> "
 "except for the <literal>orderNumber</literal> property. Note that the "
 "corresponding field, if any must be marked as <classname>@Transient</"
 "classname> or <code>transient</code>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1907
 #, no-c-format
 msgid "@org.hibernate.annotations.AccessType"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1909
 #, no-c-format
 msgid ""
 "The annotation <classname>@org.hibernate.annotations.AccessType</classname> "
 "should be considered deprecated for FIELD and PROPERTY access. It is still "
 "useful however if you need to use a custom access type."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1918
 #, no-c-format
 msgid "Optimistic lock"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1920
 #, no-c-format
 msgid ""
 "It is sometimes useful to avoid increasing the version number even if a "
 "given property is dirty (particularly collections). You can do that by "
 "annotating the property (or collection) with <literal>@OptimisticLock"
 "(excluded=true)</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1925
 #, no-c-format
 msgid ""
 "More formally, specifies that updates to this property do not require "
 "acquisition of the optimistic lock."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1930
 #, no-c-format
 msgid "Declaring column attributes"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1932
 #, no-c-format
 msgid ""
 "The column(s) used for a property mapping can be defined using the "
 "<literal>@Column</literal> annotation. Use it to override default values "
 "(see the JPA specification for more information on the defaults). You can "
 "use this annotation at the property level for properties that are:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1940
 #, no-c-format
 msgid "not annotated at all"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1944
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Basic</literal>"
 msgstr "<literal>assigned</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1948
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Version</literal>"
 msgstr "<literal>string</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1952
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Lob</literal>"
 msgstr "<literal>hilo</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1956
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Temporal</literal>"
 msgstr "<literal>serializable</literal>"
 
 #. Tag: programlisting
 #: basic_mapping.xml:1960
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Flight implements Serializable {\n"
 "...\n"
 "@Column(updatable = false, name = \"flight_name\", nullable = false, "
 "length=50)\n"
 "public String getName() { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1962
 #, no-c-format
 msgid ""
 "The <literal>name</literal> property is mapped to the <literal>flight_name</"
 "literal> column, which is not nullable, has a length of 50 and is not "
 "updatable (making the property immutable)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1967
 #, no-c-format
 msgid ""
 "This annotation can be applied to regular properties as well as "
 "<literal>@Id</literal> or <literal>@Version</literal> properties."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1994
 #, no-c-format
 msgid ""
 "@Column(\n"
 "    name=\"columnName\";\n"
 "    boolean unique() default false;\n"
 "    boolean nullable() default true;\n"
 "    boolean insertable() default true;\n"
 "    boolean updatable() default true;\n"
 "    String columnDefinition() default \"\";\n"
 "    String table() default \"\";\n"
 "    int length() default 255;\n"
 "    int precision() default 0; // decimal precision\n"
 "    int scale() default 0; // decimal scale"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1998
 #, fuzzy, no-c-format
 msgid ""
 "<literal>name</literal> (optional): the column name (default to the property "
 "name)"
 msgstr ""
 "<literal>name</literal> (opcional): O nome da propriedade do identificador."
 
 #. Tag: para
 #: basic_mapping.xml:2003
 #, fuzzy, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): set a unique constraint on this column "
 "or not (default false)"
 msgstr ""
 "<literal>unique</literal> (opcional): Habilita a geração de DDL de uma única "
 "restrição para as colunas. Da mesma forma, permita que isto seja o alvo de "
 "uma <literal>property-ref</literal>. "
 
 #. Tag: para
 #: basic_mapping.xml:2008
 #, fuzzy, no-c-format
 msgid ""
 "<literal>nullable</literal> (optional): set the column as nullable (default "
 "true)."
 msgstr ""
 "<literal>name</literal> (opcional): O nome da propriedade do identificador."
 
 #. Tag: para
 #: basic_mapping.xml:2013
 #, fuzzy, no-c-format
 msgid ""
 "<literal>insertable</literal> (optional): whether or not the column will be "
 "part of the insert statement (default true)"
 msgstr ""
 "<literal>name</literal> (opcional): O nome da propriedade do identificador."
 
 #. Tag: para
 #: basic_mapping.xml:2019
 #, fuzzy, no-c-format
 msgid ""
 "<literal>updatable</literal> (optional): whether or not the column will be "
 "part of the update statement (default true)"
 msgstr ""
 "<literal>catalog</literal> (opcional): O nome do catálogo do banco de dados. "
 
 #. Tag: para
 #: basic_mapping.xml:2025
 #, no-c-format
 msgid ""
 "<literal>columnDefinition</literal> (optional): override the sql DDL "
 "fragment for this particular column (non portable)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2031
 #, fuzzy, no-c-format
 msgid ""
 "<literal>table</literal> (optional): define the targeted table (default "
 "primary table)"
 msgstr ""
 "<literal>catalog</literal> (opcional): O nome do catálogo do banco de dados. "
 
 #. Tag: para
 #: basic_mapping.xml:2036
 #, no-c-format
 msgid ""
 "<literal><literal>length</literal></literal> (optional): column length "
 "(default 255)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2041
 #, no-c-format
 msgid ""
 "<literal><literal>precision</literal></literal> (optional): column decimal "
 "precision (default 0)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2046
 #, no-c-format
 msgid ""
 "<literal><literal>scale</literal></literal> (optional): column decimal scale "
 "if useful (default 0)"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2054
 #, no-c-format
 msgid "Formula"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2056
 #, no-c-format
 msgid ""
 "Sometimes, you want the Database to do some computation for you rather than "
 "in the JVM, you might also create some kind of virtual column. You can use a "
 "SQL fragment (aka formula) instead of mapping a property into a column. This "
 "kind of property is read only (its value is calculated by your formula "
 "fragment)."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2062
 #, no-c-format
 msgid ""
 "@Formula(\"obj_length * obj_height * obj_width\")\n"
 "public long getObjectVolume()"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2064
 #, no-c-format
 msgid ""
 "The SQL fragment can be as complex as you want and even include subselects."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2069
 #, no-c-format
 msgid "Non-annotated property defaults"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2071
 #, no-c-format
 msgid "If a property is not annotated, the following rules apply:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2074
 #, no-c-format
 msgid "If the property is of a single type, it is mapped as @Basic"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2079
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is annotated as @Embeddable, it is "
 "mapped as @Embedded"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2084
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>Serializable</"
 "classname>, it is mapped as <classname>@Basic</classname> in a column "
 "holding the object in its serialized version"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2091
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>java.sql.Clob</"
 "classname> or <classname>java.sql.Blob</classname>, it is mapped as "
 "<classname>@Lob</classname> with the appropriate <classname>LobType</"
 "classname>"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2102
 #, no-c-format
 msgid "Property mapping with hbm.xml"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2104
 #, no-c-format
 msgid ""
 "The <literal>&lt;property&gt;</literal> element declares a persistent "
 "JavaBean style property of the class."
 msgstr ""
 "O elemento <literal>&lt;property&gt;</literal> declara uma propriedade de "
 "estilo JavaBean de uma classe."
 
 #. Tag: programlisting
 #: basic_mapping.xml:2136
 #, no-c-format
 msgid ""
 "&lt;property\n"
 "        name=\"propertyName\"\n"
 "        column=\"column_name\"\n"
 "        type=\"typename\"\n"
 "        update=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary SQL expression\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        not-null=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        generated=\"never|insert|always\"\n"
 "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
 "        index=\"index_name\"\n"
 "        unique_key=\"unique_key_id\"\n"
 "        length=\"L\"\n"
 "        precision=\"P\"\n"
 "        scale=\"S\"\n"
 "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2140
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the name of the property, with an initial lowercase "
 "letter."
 msgstr ""
 "<literal>name</literal>: o nome da propriedade, iniciando com letra "
 "minúscula."
 
 #. Tag: para
 #: basic_mapping.xml:2145
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to the property name): the "
 "name of the mapped database table column. This can also be specified by "
 "nested <literal>&lt;column&gt;</literal> element(s)."
 msgstr ""
 "<literal>column</literal> (opcional - padrão para o nome da propriedade): O "
 "nome da coluna mapeada do banco de dados. Isto pode também ser especificado "
 "pelo(s) elemento(s) <literal>&lt;column&gt;</literal> aninhados."
 
 #. Tag: para
 #: basic_mapping.xml:2157
 #, no-c-format
 msgid ""
 "<literal>update, insert</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that the mapped columns should be included in SQL "
 "<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
 "Setting both to <literal>false</literal> allows a pure \"derived\" property "
 "whose value is initialized from some other property that maps to the same "
 "column(s), or by a trigger or other application."
 msgstr ""
 "<literal>update, insert</literal> (opcional - padrão para <literal>true</"
 "literal>): especifica que as colunas mapeadas devem ser incluídas nas "
 "instruções SQL de <literal>UPDATE</literal> e/ou <literal>INSERT</literal>. "
 "Ajustar ambas para <literal>false</literal> permite uma propridade \"derivada"
 "\" pura, cujo valor é inicializado de outra propriedade, que mapeie a mesma "
 "coluna(s) ou por uma disparo ou outra aplicação."
 
 #. Tag: para
 #: basic_mapping.xml:2167
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an SQL expression that defines the "
 "value for a <emphasis>computed</emphasis> property. Computed properties do "
 "not have a column mapping of their own."
 msgstr ""
 "<literal>formula</literal> (opcional): uma instrução SQL que definie o valor "
 "para uma propriedade <emphasis>calculada</emphasis>. Propriedades calculadas "
 "não possuem uma coluna de mapeamento para elas."
 
 #. Tag: para
 #: basic_mapping.xml:2180
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this property should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal> (opcional - padrão para <literal>false</literal>): "
 "Especifica que esta propriedade deve ser atingida de forma lenta quando a "
 "instância da variável é acessada pela primeira vez. Isto requer "
 "instrumentação bytecode em tempo de criação."
 
 #. Tag: para
 #: basic_mapping.xml:2187
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): enables the DDL generation of a unique "
 "constraint for the columns. Also, allow this to be the target of a "
 "<literal>property-ref</literal>."
 msgstr ""
 "<literal>unique</literal> (opcional): Habilita a geração de DDL de uma única "
 "restrição para as colunas. Da mesma forma, permita que isto seja o alvo de "
 "uma <literal>property-ref</literal>. "
 
 #. Tag: para
 #: basic_mapping.xml:2194
 #, no-c-format
 msgid ""
 "<literal>not-null</literal> (optional): enables the DDL generation of a "
 "nullability constraint for the columns."
 msgstr ""
 "<literal>not-null</literal> (opcional): Habilita a geração de DDL de uma "
 "restrição de nulidade para as colunas. "
 
 #. Tag: para
 #: basic_mapping.xml:2199 basic_mapping.xml:3282
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this property do or do not require "
 "acquisition of the optimistic lock. In other words, it determines if a "
 "version increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal> (opcional - padrão para <literal>true</"
 "literal>): Especifica se mudanças para esta propriedade requerem ou não "
 "bloqueio otimista. Em outras palavras, determina se um incremento de versão "
 "deve ocorrer quando esta propriedade está suja."
 
 #. Tag: para
 #: basic_mapping.xml:2207
 #, no-c-format
 msgid ""
 "<literal>generated</literal> (optional - defaults to <literal>never</"
 "literal>): specifies that this property value is actually generated by the "
 "database. See the discussion of <link linkend=\"mapping-generated"
 "\">generated properties</link> for more information."
 msgstr ""
 "<literal>generated</literal> (opcional - padrão para <literal>never</"
 "literal>): Especifica que o valor da propriedade é na verdade gerado pelo "
 "banco de dados. Veja a discussão do <link linkend=\"mapping-generated"
 "\">generated properties</link> para maiores informações. "
 
 #. Tag: para
 #: basic_mapping.xml:2216
 #, no-c-format
 msgid "<emphasis>typename</emphasis> could be:"
 msgstr "<emphasis>typename</emphasis> pode ser:"
 
 #. Tag: para
 #: basic_mapping.xml:2241
 #, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
 "literal> attribute. For example, to distinguish between <literal>Hibernate."
 "DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
 "custom type."
 msgstr ""
 "Se você não especificar um tipo, o Hibernate irá utilizar reflexão sobre a "
 "propriedade nomeada para ter uma idéia do tipo de Hibernate correto. O "
 "Hibernate tentará interpretar o nome da classe retornada, usando as regras "
 "2, 3 e 4 nesta ordem. Em certos casos, você ainda precisará do atributo "
 "<literal>type</literal>. Por exemplo, para distinguir entre "
 "<literal>Hibernate.DATE</literal> e <literal>Hibernate.TIMESTAMP</literal>, "
 "ou para especificar um tipo customizado."
 
 #. Tag: para
 #: basic_mapping.xml:2250
 #, no-c-format
 msgid ""
 "The <literal>access</literal> attribute allows you to control how Hibernate "
 "accesses the property at runtime. By default, Hibernate will call the "
 "property get/set pair. If you specify <literal>access=\"field\"</literal>, "
 "Hibernate will bypass the get/set pair and access the field directly using "
 "reflection. You can specify your own strategy for property access by naming "
 "a class that implements the interface <literal>org.hibernate.property."
 "PropertyAccessor</literal>."
 msgstr ""
 "A função <literal>access</literal> permite que você controle como o "
 "Hibernate irá acessar a propriedade em tempo de execução. Por padrão, o "
 "Hibernate irá chamar os métodos get/set da propriedades. Se você especificar "
 "<literal>access=\"field\"</literal>, o Hibernate irá bipassar os metodos get/"
 "set, acessando o campo diretamente, usando reflexão. Você pode especificar "
 "sua própria estratégia para acesso da propriedade criando uma classe que "
-"implemente a interface <literal>org.hibernate.property.PropertyAccessor</"
+"implemente a interface <literal>org.hibernate.property.access.spi.PropertyAccessStrategy</"
 "literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2259
 #, no-c-format
 msgid ""
 "A powerful feature is derived properties. These properties are by definition "
 "read-only. The property value is computed at load time. You declare the "
 "computation as an SQL expression. This then translates to a <literal>SELECT</"
 "literal> clause subquery in the SQL query that loads an instance:"
 msgstr ""
 "Um recurso especialmente poderoso é o de propriedades derivadas. Estas "
 "propriedades são por definição somente leitura, e o valor da propriedade é "
 "calculado em tempo de execução. Você declara este cálculo como uma expressão "
 "SQL, que traduz para cláusula <literal>SELECT</literal> de uma subconsulta "
 "da consulta SQL que carrega a instância: "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2265
 #, no-c-format
 msgid ""
 "&lt;property name=\"totalPrice\"\n"
 "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
 "p\n"
 "                WHERE li.productId = p.productId\n"
 "                AND li.customerId = customerId\n"
 "                AND li.orderNumber = orderNumber )\"/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2267
 #, no-c-format
 msgid ""
 "You can reference the entity table by not declaring an alias on a particular "
 "column. This would be <literal>customerId</literal> in the given example. "
 "You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
 "element if you do not want to use the attribute."
 msgstr ""
 "Observe que você pode referenciar as entidades da própria tabela, através da "
 "não declaração de um alias para uma coluna particular. Isto seria o "
 "<literal>customerId</literal> no exemplo dado. Observe também que você pode "
 "usar o mapeamento de elemento aninhado <literal>&lt;formula&gt;</literal>, "
 "se você não gostar de usar o atributo. "
 
 #. Tag: title
 #: basic_mapping.xml:2276
 #, no-c-format
 msgid "Embedded objects (aka components)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2278
 #, fuzzy, no-c-format
 msgid ""
 "Embeddable objects (or components) are objects whose properties are mapped "
 "to the same table as the owning entity's table. Components can, in turn, "
 "declare their own properties, components or collections"
 msgstr ""
 "O elemento <literal>&lt;component&gt;</literal> mapeia propriedades de um "
 "objeto filho para colunas da tabela de uma classe pai. Os componentes podem, "
 "um após o outro, declarar suas próprias propriedades, componentes ou "
 "coleções. Veja \"Components\" abaixo:"
 
 #. Tag: para
 #: basic_mapping.xml:2283
 #, no-c-format
 msgid ""
 "It is possible to declare an embedded component inside an entity and even "
 "override its column mapping. Component classes have to be annotated at the "
 "class level with the <literal>@Embeddable</literal> annotation. It is "
 "possible to override the column mapping of an embedded object for a "
 "particular entity using the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride</literal> annotation in the associated property:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2291
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Person implements Serializable {\n"
 "\n"
 "    // Persistent component using defaults\n"
 "    Address homeAddress;\n"
 "\n"
 "    @Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"iso2\", column = @Column(name="
 "\"bornIso2\") ),\n"
 "            @AttributeOverride(name=\"name\", column = @Column(name="
 "\"bornCountryName\") )\n"
 "    } )\n"
 "    Country bornIn;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2293
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Address implements Serializable {\n"
 "    String city;\n"
 "    Country nationality; //no overriding here\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2295
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Country implements Serializable {\n"
 "    private String iso2;\n"
 "    @Column(name=\"countryName\") private String name;\n"
 "\n"
 "    public String getIso2() { return iso2; }\n"
 "    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
 "\n"
 "    \n"
 "    public String getName() { return name; }\n"
 "    public void setName(String name) { this.name = name; }\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2297
 #, no-c-format
 msgid ""
 "An embeddable object inherits the access type of its owning entity (note "
 "that you can override that using the <literal>@Access</literal> annotation)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2301
 #, no-c-format
 msgid ""
 "The <literal>Person</literal> entity has two component properties, "
 "<literal>homeAddress</literal> and <literal>bornIn</literal>. "
 "<literal>homeAddress</literal> property has not been annotated, but "
 "Hibernate will guess that it is a persistent component by looking for the "
 "<literal>@Embeddable</literal> annotation in the Address class. We also "
 "override the mapping of a column name (to <literal>bornCountryName</"
 "literal>) with the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride </literal>annotations for each mapped attribute "
 "of <literal>Country</literal>. As you can see, <literal>Country </literal>is "
 "also a nested component of <literal>Address</literal>, again using auto-"
 "detection by Hibernate and JPA defaults. Overriding columns of embedded "
 "objects of embedded objects is through dotted expressions."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2316
 #, no-c-format
 msgid ""
 "@Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"city\", column = @Column(name="
 "\"fld_city\") ),\n"
 "            @AttributeOverride(name=\"nationality.iso2\", column = @Column"
 "(name=\"nat_Iso2\") ),\n"
 "            @AttributeOverride(name=\"nationality.name\", column = @Column"
 "(name=\"nat_CountryName\") )\n"
 "            //nationality columns in homeAddress are overridden\n"
 "    } )\n"
 "    Address homeAddress;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2318
 #, no-c-format
 msgid ""
 "Hibernate Annotations supports something that is not explicitly supported by "
 "the JPA specification. You can annotate a embedded object with the "
 "<literal>@MappedSuperclass</literal> annotation to make the superclass "
 "properties persistent (see <literal>@MappedSuperclass</literal> for more "
 "informations)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2324
 #, no-c-format
 msgid ""
 "You can also use association annotations in an embeddable object (ie "
 "<literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, "
 "<classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To "
 "override the association columns you can use <literal>@AssociationOverride</"
 "literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2330
 #, no-c-format
 msgid ""
 "If you want to have the same embeddable object type twice in the same "
 "entity, the column name defaulting will not work as several embedded objects "
 "would share the same set of columns. In plain JPA, you need to override at "
 "least one set of columns. Hibernate, however, allows you to enhance the "
 "default naming mechanism through the <classname>NamingStrategy</classname> "
 "interface. You can write a strategy that prevent name clashing in such a "
 "situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an "
 "example of this."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2340
 #, no-c-format
 msgid ""
 "If a property of the embedded object points back to the owning entity, "
 "annotate it with the <classname>@Parent</classname> annotation. Hibernate "
 "will make sure this property is properly loaded with the entity reference."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2345
 #, no-c-format
 msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2367
 #, no-c-format
 msgid ""
 "&lt;component\n"
 "        name=\"propertyName\"\n"
 "        class=\"className\"\n"
 "        insert=\"true|false\"\n"
 "        update=\"true|false\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        node=\"element-name|.\"\n"
 "&gt;\n"
 "\n"
 "        &lt;property ...../&gt;\n"
 "        &lt;many-to-one .... /&gt;\n"
 "        ........\n"
 "&lt;/component&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
 #, no-c-format
 msgid "<literal>name</literal>: the name of the property."
 msgstr "<literal>name</literal>: O nome da propriedade. "
 
 #. Tag: para
 #: basic_mapping.xml:2375
 #, no-c-format
 msgid ""
 "<literal>class</literal> (optional - defaults to the property type "
 "determined by reflection): the name of the component (child) class."
 msgstr ""
 "<literal>class</literal> (opcional – padrão para o tipo de propriedade "
 "determinada por reflection): O nome da classe (filha) do componente."
 
 #. Tag: para
 #: basic_mapping.xml:2381 basic_mapping.xml:3677
 #, no-c-format
 msgid ""
 "<literal>insert</literal>: do the mapped columns appear in SQL "
 "<literal>INSERTs</literal>?"
 msgstr ""
 "<literal>insert</literal>: As colunas mapeadas aparecem nos SQL de "
 "<literal>INSERTs</literal>? "
 
 #. Tag: para
 #: basic_mapping.xml:2386 basic_mapping.xml:3682
 #, no-c-format
 msgid ""
 "<literal>update</literal>: do the mapped columns appear in SQL "
 "<literal>UPDATEs</literal>?"
 msgstr ""
 "<literal>update</literal>: As colunas mapeadas aparecem nos SQL de "
 "<literal>UPDATEs</literal>? "
 
 #. Tag: para
 #: basic_mapping.xml:2397
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this component should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal> (opcional - padrão para <literal>false</literal>): "
 "Especifica que este componente deve ter uma busca lazy quando a função for "
 "acessada pela primeira vez. Isto requer instrumentação bytecode de tempo de "
 "construção."
 
 #. Tag: para
 #: basic_mapping.xml:2404
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this component either do or do not "
 "require acquisition of the optimistic lock. It determines if a version "
 "increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal> (opcional – padrão para <literal>true</"
 "literal>): Especifica que atualizações para este componente requerem ou não "
 "aquisição de um bloqueio otimista. Em outras palavras, determina se uma "
 "versão de incremento deve ocorrer quando esta propriedade estiver suja."
 
 #. Tag: para
 #: basic_mapping.xml:2412 basic_mapping.xml:3695
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that a unique constraint exists upon all mapped columns of the "
 "component."
 msgstr ""
 "<literal>unique</literal> (opcional – valor padrão <literal>false</"
 "literal>): Especifica que existe uma unique restrição em todas as colunas "
 "mapeadas do componente. "
 
 #. Tag: para
 #: basic_mapping.xml:2419
 #, no-c-format
 msgid ""
 "The child <literal>&lt;property&gt;</literal> tags map properties of the "
 "child class to table columns."
 msgstr ""
 "A tag filha <literal>&lt;property&gt;</literal> acrescenta a propriedade de "
 "mapeamento da classe filha para colunas de uma tabela."
 
 #. Tag: para
 #: basic_mapping.xml:2422
 #, no-c-format
 msgid ""
 "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
 "parent&gt;</literal> subelement that maps a property of the component class "
 "as a reference back to the containing entity."
 msgstr ""
 "O elemento <literal>&lt;component&gt;</literal> permite um sub-elemento "
 "<literal>&lt;parent&gt;</literal> mapeie uma propriedade da classe do "
 "componente como uma referencia de volta para a entidade que o contém."
 
 #. Tag: para
 #: basic_mapping.xml:2426
 #, fuzzy, no-c-format
 msgid ""
 "The <literal>&lt;dynamic-component&gt;</literal> element allows a "
 "<literal>Map</literal> to be mapped as a component, where the property names "
 "refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for "
 "more information. This feature is not supported in annotations."
 msgstr ""
 "O elemento <literal>&lt;dynamic-component&gt;</literal> permite que um "
 "<literal>Map</literal> possa ser mapeado como um componente onde os nomes "
 "das propriedades referem-se para as chaves no mapa. Consulte <xref linkend="
 "\"components-dynamic\"/> para maiores informações."
 
 #. Tag: title
 #: basic_mapping.xml:2434
 #, no-c-format
 msgid "Inheritance strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2436
 #, no-c-format
 msgid ""
 "Java is a language supporting polymorphism: a class can inherit from "
 "another. Several strategies are possible to persist a class hierarchy:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2442
 #, no-c-format
 msgid ""
 "Single table per class hierarchy strategy: a single table hosts all the "
 "instances of a class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2447
 #, no-c-format
 msgid ""
 "Joined subclass strategy: one table per class and subclass is present and "
 "each table persist the properties specific to a given subclass. The state of "
 "the entity is then stored in its corresponding class table and all its "
 "superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2454
 #, no-c-format
 msgid ""
 "Table per class strategy: one table per concrete class and subclass is "
 "present and each table persist the properties of the class and its "
 "superclasses. The state of the entity is then stored entirely in the "
 "dedicated table for its class."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2462
 #, no-c-format
 msgid "Single table per class hierarchy strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2464
 #, no-c-format
 msgid ""
 "With this approach the properties of all the subclasses in a given mapped "
 "class hierarchy are stored in a single table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2467
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass declares its own persistent properties and subclasses. Version "
 "and id properties are assumed to be inherited from the root class. Each "
 "subclass in a hierarchy must define a unique discriminator value. If this is "
 "not specified, the fully qualified Java class name is used."
 msgstr ""
 "Cada subclasse deve declarar suas próprias propriedades persistentes e "
 "subclasses. As propriedades <literal>&lt;version&gt;</literal> e "
 "<literal>&lt;id&gt;</literal> são configuradas para serem herdadas da classe "
 "raíz. Cada subclasse numa hierarquia deve definir um único "
 "<literal>discriminator-value</literal>. Se nenhum for especificado, será "
 "usado o nome da classe Java completamente qualificado."
 
 #. Tag: programlisting
 #: basic_mapping.xml:2473 basic_mapping.xml:2581
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
 "@DiscriminatorColumn(\n"
 "    name=\"planetype\",\n"
 "    discriminatorType=DiscriminatorType.STRING\n"
 ")\n"
 "@DiscriminatorValue(\"Plane\")\n"
 "public class Plane { ... }\n"
 "\n"
 "@Entity\n"
 "@DiscriminatorValue(\"A320\")\n"
 "public class A320 extends Plane { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2475
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, for the table-per-class-hierarchy mapping strategy, the "
 "<literal>&lt;subclass&gt;</literal> declaration is used. For example:"
 msgstr ""
 "Finalmente, a persistência polimórfica requer a declaração de cada subclasse "
 "da classe raíz de persistência. Para a estratégia de mapeamento tabela-por-"
 "hierarquia-de-classe, deve-se utilizar a declaração <literal>&lt;subclass&gt;"
 "</literal>. Por exemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2490
 #, no-c-format
 msgid ""
 "&lt;subclass\n"
 "        name=\"ClassName\"\n"
 "        discriminator-value=\"discriminator_value\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"\n"
 "        extends=\"SuperclassName\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the fully qualified class name of the subclass."
 msgstr ""
 "<literal>name</literal>: O nome de classe completamente qualificada da "
 "subclasse. "
 
 #. Tag: para
 #: basic_mapping.xml:2499
 #, no-c-format
 msgid ""
 "<literal>discriminator-value</literal> (optional - defaults to the class "
 "name): a value that distinguishes individual subclasses."
 msgstr ""
 "<literal>discriminator-value</literal> (opcional – padrão para o nome da "
 "classe): Um valor que distingue subclasses individuais."
 
 #. Tag: para
 #: basic_mapping.xml:2505
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface used for "
 "lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal> (opcional): Especifica a classe ou interface que "
 "usará os proxies de inicialização lazy."
 
 #. Tag: para
 #: basic_mapping.xml:2510
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal> (opcional, padrão para <literal>true</literal>): "
 "Configurar <literal>lazy=\"false\"</literal> desabilitará o uso de "
 "inicialização lazy."
 
 #. Tag: para
 #: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
 #, fuzzy, no-c-format
 msgid ""
 "For information about inheritance mappings see <xref linkend=\"inheritance\"/"
 ">."
 msgstr ""
 "Para informações sobre mapeamento de heranças. Consulte o <xref linkend="
 "\"inheritance\" />."
 
 #. Tag: title
 #: basic_mapping.xml:2522
 #, no-c-format
 msgid "Discriminator"
 msgstr "Discriminador "
 
 #. Tag: para
 #: basic_mapping.xml:2524
 #, fuzzy, no-c-format
 msgid ""
 "Discriminators are required for polymorphic persistence using the table-per-"
 "class-hierarchy mapping strategy. It declares a discriminator column of the "
 "table. The discriminator column contains marker values that tell the "
 "persistence layer what subclass to instantiate for a particular row. "
 "Hibernate Core supports the follwoing restricted set of types as "
 "discriminator column: <literal>string</literal>, <literal>character</"
 "literal>, <literal>integer</literal>, <literal>byte</literal>, "
 "<literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</"
 "literal>, <literal>true_false</literal>."
 msgstr ""
 "O elemento <literal>&lt;discriminator&gt;</literal> é necessário para "
 "persistência polimórfica utilizando a estratégia de mapeamento de tabela-por-"
 "classe-hierárquica e declara uma coluna discriminadora da tabela. A coluna "
 "discriminadora contém valores de marcação que informam à camada de "
 "persistência qual subclasse instanciar para uma linha em específico. Um "
 "restrito conjunto de tipos que podem ser utilizados: <literal>string</"
 "literal>, <literal>character</literal>, <literal>integer</literal>, "
 "<literal>byte</literal>, <literal>short</literal>, <literal>boolean</"
 "literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2535
 #, no-c-format
 msgid ""
 "Use the <classname>@DiscriminatorColumn</classname> to define the "
 "discriminator column as well as the discriminator type. <note> "
 "<para><classname>The enum DiscriminatorType</classname> used in "
 "<classname>javax.persitence.DiscriminatorColumn</classname> only contains "
 "the values <constant>STRING</constant>, <constant>CHAR</constant> and "
 "<constant>INTEGER</constant> which means that not all Hibernate supported "
 "types are available via the <classname>@DiscriminatorColumn</classname> "
 "annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</"
 "classname> to express in SQL a virtual discriminator column. This is "
 "particularly useful when the discriminator value can be extracted from one "
 "or more columns of the table. Both <classname>@DiscriminatorColumn</"
 "classname> and <classname>@DiscriminatorFormula</classname> are to be set on "
 "the root entity (once per persisted hierarchy)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2552
 #, no-c-format
 msgid ""
 "<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> "
 "allows to optionally specify Hibernate specific discriminator options which "
 "are not standardized in JPA. The available options are <literal>force</"
 "literal> and <literal>insert</literal>. The <literal>force</literal> "
 "attribute is useful if the table contains rows with \"extra\" discriminator "
 "values that are not mapped to a persistent class. This could for example "
 "occur when working with a legacy database. If <literal>force</literal> is "
 "set to <constant>true</constant> Hibernate will specify the allowed "
 "discriminator values in the <literal>SELECT</literal> query, even when "
 "retrieving all instances of the root class. The second option - "
 "<literal>insert</literal> - tells Hibernate whether or not to include the "
 "discriminator column in SQL <literal>INSERTs</literal>. Usually the column "
 "should be part of the <literal>INSERT</literal> statement, but if your "
 "discriminator column is also part of a mapped composite identifier you have "
 "to set this option to <constant>false</constant>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2569
 #, no-c-format
 msgid ""
 "There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</"
 "classname> annotation which is deprecated since version 3.6. Use "
 "<classname>@DiscriminatorOptions</classname> instead."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2575
 #, no-c-format
 msgid ""
 "Finally, use <classname>@DiscriminatorValue</classname> on each class of the "
 "hierarchy to specify the value stored in the discriminator column for a "
 "given entity. If you do not set <classname>@DiscriminatorValue</classname> "
 "on a class, the fully qualified class name is used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2583
 #, no-c-format
 msgid ""
 "In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to "
 "define the discriminator column or formula:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2600
 #, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "        column=\"discriminator_column\"\n"
 "        type=\"discriminator_type\"\n"
 "        force=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary sql expression\"\n"
 "/&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2604
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to <literal>class</literal>): "
 "the name of the discriminator column."
 msgstr ""
 "<literal>column</literal> (opcional - padrão para <literal>class</literal>): "
 "O nome da coluna discriminadora."
 
 #. Tag: para
 #: basic_mapping.xml:2610
 #, no-c-format
 msgid ""
 "<literal>type</literal> (optional - defaults to <literal>string</literal>): "
 "a name that indicates the Hibernate type"
 msgstr ""
 "<literal>type</literal> (opcional - padrão para <literal>string</literal>): "
 "O nome que indica o tipo Hibernate."
 
 #. Tag: para
 #: basic_mapping.xml:2616
 #, no-c-format
 msgid ""
 "<literal>force</literal> (optional - defaults to <literal>false</literal>): "
 "\"forces\" Hibernate to specify the allowed discriminator values, even when "
 "retrieving all instances of the root class."
 msgstr ""
 "<literal>force</literal> (opcional - valor padrão <literal>false</literal>): "
 "\"Força\" o Hibernate a especificar valores discriminadores permitidos mesmo "
 "quando recuperando todas as instâncias da classe raíz. "
 
 #. Tag: para
 #: basic_mapping.xml:2623
 #, no-c-format
 msgid ""
 "<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
 "set this to <literal>false</literal> if your discriminator column is also "
 "part of a mapped composite identifier. It tells Hibernate not to include the "
 "column in SQL <literal>INSERTs</literal>."
 msgstr ""
 "<literal>insert</literal> (opcional - valor padrão para <literal>true</"
 "literal>) Ajuste para <literal>false</literal> se sua coluna discriminadora "
 "também fizer parte do identificador composto mapeado. (Isto informa ao "
 "Hibernate para não incluir a coluna em comandos SQL <literal>INSERT</"
 "literal>s)."
 
 #. Tag: para
 #: basic_mapping.xml:2631
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an arbitrary SQL expression that is "
 "executed when a type has to be evaluated. It allows content-based "
 "discrimination."
 msgstr ""
 "<literal>formula</literal> (opcional): Uma expressão SQL arbitrária que é "
 "executada quando um tipo tem que ser avaliado. Permite discriminação baseada "
 "em conteúdo. "
 
 #. Tag: para
 #: basic_mapping.xml:2638
 #, no-c-format
 msgid ""
 "Actual values of the discriminator column are specified by the "
 "<literal>discriminator-value</literal> attribute of the <literal>&lt;"
 "class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
 msgstr ""
 "Valores atuais de uma coluna discriminada são especificados pela função "
 "<literal>discriminator-value</literal> da <literal>&lt;class&gt;</literal> e "
 "elementos da <literal>&lt;subclass&gt;</literal>."
 
 #. Tag: para
 #: basic_mapping.xml:2643
 #, no-c-format
 msgid ""
 "The <literal>formula</literal> attribute allows you to declare an arbitrary "
 "SQL expression that will be used to evaluate the type of a row. For example:"
 msgstr ""
 "Usando o atributo <literal>formula</literal> você pode declarar uma "
 "expressão SQL arbitrária que será utilizada para avaliar o tipo de uma "
 "linha. Por exemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2647
 #, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
 "    type=\"integer\"/&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2652
 #, fuzzy, no-c-format
 msgid "Joined subclass strategy"
 msgstr "Subclasses Unidas "
 
 #. Tag: para
 #: basic_mapping.xml:2654
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass can also be mapped to its own table. This is called the table-"
 "per-subclass mapping strategy. An inherited state is retrieved by joining "
 "with the table of the superclass. A discriminator column is not required for "
 "this mapping strategy. Each subclass must, however, declare a table column "
 "holding the object identifier. The primary key of this table is also a "
 "foreign key to the superclass table and described by the "
 "<classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</"
 "literal> element."
 msgstr ""
 "Alternativamente, cada subclasse pode ser mapeada para sua própria tabela. "
 "Isto é chamado estratégia de mapeamento de tabela-por-subclasse. O estado "
 "herdado é devolvido por associação com a tabela da superclasse. Nós usamos o "
 "elemento <literal>&lt;joined-subclass&gt;</literal>. Por exemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2664
 #, no-c-format
 msgid ""
 "@Entity @Table(name=\"CATS\")\n"
 "@Inheritance(strategy=InheritanceType.JOINED)\n"
 "public class Cat implements Serializable { \n"
 "    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
 "    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
 "    String getId() { return id; }\n"
 "\n"
 "    ...\n"
 "}\n"
 "\n"
 "@Entity @Table(name=\"DOMESTIC_CATS\")\n"
 "@PrimaryKeyJoinColumn(name=\"CAT\")\n"
 "public class DomesticCat extends Cat { \n"
 "    public String getName() { return name; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2667
 #, no-c-format
 msgid ""
 "The table name still defaults to the non qualified class name. Also if "
 "<classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / "
 "foreign key columns are assumed to have the same names as the primary key "
 "columns of the primary table of the superclass."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2674
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For "
 "example:"
 msgstr ""
 "Você pode declarar uma classe persistente utilizando o elemento "
 "<literal>class</literal>. Por exemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2688
 #, no-c-format
 msgid ""
 "&lt;joined-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;key .... &gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/joined-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2697 basic_mapping.xml:2761
 #, no-c-format
 msgid "<literal>table</literal>: the name of the subclass table."
 msgstr "<literal>table</literal>: O nome da tabela da subclasse. "
 
 #. Tag: para
 #: basic_mapping.xml:2702 basic_mapping.xml:2766
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface to use "
 "for lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal> (opcional): Especifica a classe ou interface que "
 "usará os proxies de inicialização lazy. "
 
 #. Tag: para
 #: basic_mapping.xml:2707 basic_mapping.xml:2771
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal> (opcional, padrão para <literal>true</literal>): "
 "Configurar <literal>lazy=\"false\"</literal> desabilitará o uso de "
 "inicialização lazy."
 
 #. Tag: para
 #: basic_mapping.xml:2715
 #, no-c-format
 msgid ""
 "Use the <literal>&lt;key&gt;</literal> element to declare the primary key / "
 "foreign key column. The mapping at the start of the chapter would then be re-"
 "written as:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2719
 #, no-c-format
 msgid ""
 "&lt;?xml version=\"1.0\"?&gt;\n"
 "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
 "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
 "        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
 "\n"
 "&lt;hibernate-mapping package=\"eg\"&gt;\n"
 "\n"
 "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
 "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
 "                        &lt;generator class=\"hilo\"/&gt;\n"
 "                &lt;/id&gt;\n"
 "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
 "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"weight\"/&gt;\n"
 "                &lt;many-to-one name=\"mate\"/&gt;\n"
 "                &lt;set name=\"kittens\"&gt;\n"
 "                        &lt;key column=\"MOTHER\"/&gt;\n"
 "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
 "                &lt;/set&gt;\n"
 "                &lt;joined-subclass name=\"DomesticCat\" table="
 "\"DOMESTIC_CATS\"&gt;\n"
 "                    &lt;key column=\"CAT\"/&gt;\n"
 "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
 "                &lt;/joined-subclass&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "        &lt;class name=\"eg.Dog\"&gt;\n"
 "                &lt;!-- mapping for Dog could go here --&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "&lt;/hibernate-mapping&gt;"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2726
 #, no-c-format
 msgid "Table per class strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2728
 #, fuzzy, no-c-format
 msgid ""
 "A third option is to map only the concrete classes of an inheritance "
 "hierarchy to tables. This is called the table-per-concrete-class strategy. "
 "Each table defines all persistent states of the class, including the "
 "inherited state. In Hibernate, it is not necessary to explicitly map such "
 "inheritance hierarchies. You can map each class as a separate entity root. "
 "However, if you wish use polymorphic associations (e.g. an association to "
 "the superclass of your hierarchy), you need to use the union subclass "
 "mapping."
 msgstr ""
 "Uma terceira opção é mapear apenas as classes concretas de uma hierarquia de "
 "heranças para tabelas. Isto é chamado estratégia table-per-concrete-class. "
 "Cada tabela define todos os estados persistentes da classe, incluindo "
 "estados herdados. No Hibernate, não é absolutamente necessário mapear "
 "explicitamente como hierarquia de heranças. Você pode simplesmente mapear "
 "cada classe com uma declaração <literal>&lt;class&gt;</literal> separada. "
 "Porém, se você deseja usar associações polimórficas (por exemplo: uma "
 "associação para a superclasse de sua hierarquia), você precisa usar o "
 "mapeamento <literal>&lt;union-subclass&gt;</literal>. Por exemplo:"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2737
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
 "public class Flight implements Serializable { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2739
 #, no-c-format
 msgid "Or in hbm.xml:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2752
 #, no-c-format
 msgid ""
 "&lt;union-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        abstract=\"true|false\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/union-subclass&gt;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2779
 #, no-c-format
 msgid ""
 "No discriminator column or key column is required for this mapping strategy."
 msgstr ""
 "A coluna discriminatória não é requerida para esta estratégia de mapeamento."
 
 #. Tag: title
 #: basic_mapping.xml:2787
 #, no-c-format
 msgid "Inherit properties from superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2789
 #, no-c-format
 msgid ""
 "This is sometimes useful to share common properties through a technical or a "
 "business superclass without including it as a regular mapped entity (ie no "
 "specific table for this entity). For that purpose you can map them as "
 "<literal>@MappedSuperclass</literal>."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2794
 #, no-c-format
 msgid ""
 "@MappedSuperclass\n"
 "public class BaseEntity {\n"
 "    @Basic\n"
 "    @Temporal(TemporalType.TIMESTAMP)\n"
 "    public Date getLastUpdate() { ... }\n"
 "    public String getLastUpdater() { ... }\n"
 "    ...\n"
 "}\n"
 "\n"
 "@Entity class Order extends BaseEntity {\n"
 "    @Id public Integer getId() { ... }\n"
diff --git a/documentation/src/main/docbook/manual/zh-CN/content/basic_mapping.po b/documentation/src/main/docbook/manual/zh-CN/content/basic_mapping.po
index ed527a45ed..9ed3f1bad8 100644
--- a/documentation/src/main/docbook/manual/zh-CN/content/basic_mapping.po
+++ b/documentation/src/main/docbook/manual/zh-CN/content/basic_mapping.po
@@ -3641,2001 +3641,2001 @@ msgstr ""
 #: basic_mapping.xml:1686
 #, no-c-format
 msgid "Note"
 msgstr "注意"
 
 #. Tag: para
 #: basic_mapping.xml:1688
 #, no-c-format
 msgid ""
 "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
 "type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
 "\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
 "\"&gt;</literal>"
 msgstr ""
 "注意，<literal>&lt;timestamp&gt;</literal> 和 <literal>&lt;version type="
 "\"timestamp\"&gt;</literal> 是等价的。并且 <literal>&lt;timestamp source=\"db"
 "\"&gt;</literal> 和 <literal>&lt;version type=\"dbtimestamp\"&gt;</literal> "
 "是等价的。 "
 
 #. Tag: title
 #: basic_mapping.xml:1697
 #, no-c-format
 msgid "Property"
 msgstr "Property"
 
 #. Tag: para
 #: basic_mapping.xml:1699
 #, no-c-format
 msgid ""
 "You need to decide which property needs to be made persistent in a given "
 "entity. This differs slightly between the annotation driven metadata and the "
 "hbm.xml files."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1704
 #, no-c-format
 msgid "Property mapping with annotations"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1706
 #, no-c-format
 msgid ""
 "In the annotations world, every non static non transient property (field or "
 "method depending on the access type) of an entity is considered persistent, "
 "unless you annotate it as <literal>@Transient</literal>. Not having an "
 "annotation for your property is equivalent to the appropriate "
 "<literal>@Basic</literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1713
 #, no-c-format
 msgid ""
 "The <literal>@Basic</literal> annotation allows you to declare the fetching "
 "strategy for a property. If set to <literal>LAZY</literal>, specifies that "
 "this property should be fetched lazily when the instance variable is first "
 "accessed. It requires build-time bytecode instrumentation, if your classes "
 "are not instrumented, property level lazy loading is silently ignored. The "
 "default is <literal>EAGER</literal>. You can also mark a property as not "
 "optional thanks to the <classname>@Basic.optional</classname> attribute. "
 "This will ensure that the underlying column are not nullable (if possible). "
 "Note that a better approach is to use the <classname>@NotNull</classname> "
 "annotation of the Bean Validation specification."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1726
 #, no-c-format
 msgid "Let's look at a few examples:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1728
 #, no-c-format
 msgid ""
 "public transient int counter; //transient property\n"
 "\n"
 "private String firstname; //persistent property\n"
 "\n"
 "@Transient\n"
 "String getLengthInMeter() { ... } //transient property\n"
 "\n"
 "String getName() {... } // persistent property\n"
 "\n"
 "@Basic\n"
 "int getLength() { ... } // persistent property\n"
 "\n"
 "@Basic(fetch = FetchType.LAZY)\n"
 "String getDetailedComment() { ... } // persistent property\n"
 "\n"
 "@Temporal(TemporalType.TIME)\n"
 "java.util.Date getDepartureTime() { ... } // persistent property           \n"
 "\n"
 "@Enumerated(EnumType.STRING)\n"
 "Starred getNote() { ... } //enum persisted as String in database"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1730
 #, no-c-format
 msgid ""
 "<literal>counter</literal>, a transient field, and <literal>lengthInMeter</"
 "literal>, a method annotated as <literal>@Transient</literal>, and will be "
 "ignored by the Hibernate. <literal>name</literal>, <literal>length</"
 "literal>, and <literal>firstname</literal> properties are mapped persistent "
 "and eagerly fetched (the default for simple properties). The "
 "<literal>detailedComment</literal> property value will be lazily fetched "
 "from the database once a lazy property of the entity is accessed for the "
 "first time. Usually you don't need to lazy simple properties (not to be "
 "confused with lazy association fetching). The recommended alternative is to "
 "use the projection capability of JP-QL (Java Persistence Query Language) or "
 "Criteria queries."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1743
 #, no-c-format
 msgid ""
 "JPA support property mapping of all basic types supported by Hibernate (all "
 "basic Java types , their respective wrappers and serializable classes). "
 "Hibernate Annotations supports out of the box enum type mapping either into "
 "a ordinal column (saving the enum ordinal) or a string based column (saving "
 "the enum string representation): the persistence representation, defaulted "
 "to ordinal, can be overridden through the <literal>@Enumerated</literal> "
 "annotation as shown in the <literal>note</literal> property example."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1753
 #, no-c-format
 msgid ""
 "In plain Java APIs, the temporal precision of time is not defined. When "
 "dealing with temporal data you might want to describe the expected precision "
 "in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</"
 "literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, "
 "only the time, or both). Use the <literal>@Temporal</literal> annotation to "
 "fine tune that."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1761
 #, no-c-format
 msgid ""
 "<literal>@Lob</literal> indicates that the property should be persisted in a "
 "Blob or a Clob depending on the property type: <classname>java.sql.Clob</"
 "classname>, <classname>Character[]</classname>, <classname>char[]</"
 "classname> and java.lang.<classname>String</classname> will be persisted in "
 "a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, "
 "<classname>byte[] </classname>and <classname>Serializable</classname> type "
 "will be persisted in a Blob."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1770
 #, no-c-format
 msgid ""
 "@Lob\n"
 "public String getFullText() {\n"
 "    return fullText;\n"
 "}\n"
 "\n"
 "@Lob\n"
 "public byte[] getFullCode() {\n"
 "    return fullCode;\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1772
 #, no-c-format
 msgid ""
 "If the property type implements <classname>java.io.Serializable</classname> "
 "and is not a basic type, and if the property is not annotated with "
 "<literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> "
 "type is used."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1779
 #, no-c-format
 msgid "Type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1781
 #, no-c-format
 msgid ""
 "You can also manually specify a type using the <literal>@org.hibernate."
 "annotations.Type</literal> and some parameters if needed. <classname>@Type."
 "type</classname> could be:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1788 basic_mapping.xml:2220
 #, no-c-format
 msgid ""
 "The name of a Hibernate basic type: <literal>integer, string, character, "
 "date, timestamp, float, binary, serializable, object, blob</literal> etc."
 msgstr ""
 "Hibernate 基本类型名（比如：<literal>integer, string, character,date, "
 "timestamp, float, binary, serializable, object, blob</literal>）。 "
 
 #. Tag: para
 #: basic_mapping.xml:1794 basic_mapping.xml:2226
 #, no-c-format
 msgid ""
 "The name of a Java class with a default basic type: <literal>int, float, "
 "char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
 "literal> etc."
 msgstr ""
 "一个 Java 类的名字，这个类属于一种默认基础类型（比如：<literal>int, float,"
 "char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
 "literal>)。 "
 
 #. Tag: para
 #: basic_mapping.xml:1800 basic_mapping.xml:2232
 #, no-c-format
 msgid "The name of a serializable Java class."
 msgstr "一个可以序列化的 Java 类的名字。"
 
 #. Tag: para
 #: basic_mapping.xml:1804 basic_mapping.xml:2236
 #, no-c-format
 msgid ""
 "The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
 "literal> etc."
 msgstr ""
 "一个自定义类型的类的名字。（比如：<literal>com.illflow.type.MyCustomType</"
 "literal>)。 "
 
 #. Tag: para
 #: basic_mapping.xml:1809
 #, fuzzy, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4."
 msgstr ""
 "如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确"
 "的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方"
 "法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <literal>type</"
 "literal> 属性。（比如，为了区别<literal>Hibernate.DATE</literal> 和"
 "<literal>Hibernate.TIMESTAMP</literal>,或者为了指定一个自定义类型。） "
 
 #. Tag: para
 #: basic_mapping.xml:1814
 #, no-c-format
 msgid ""
 "<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org."
 "hibernate.annotations.TypeDefs</literal> allows you to declare type "
 "definitions. These annotations can be placed at the class or package level. "
 "Note that these definitions are global for the session factory (even when "
 "defined at the class level). If the type is used on a single entity, you can "
 "place the definition on the entity itself. Otherwise, it is recommended to "
 "place the definition at the package level. In the example below, when "
 "Hibernate encounters a property of class <literal>PhoneNumer</literal>, it "
 "delegates the persistence strategy to the custom mapping type "
 "<literal>PhoneNumberType</literal>. However, properties belonging to other "
 "classes, too, can delegate their persistence strategy to "
 "<literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</"
 "literal> annotation."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1830
 #, no-c-format
 msgid ""
 "Package level annotations are placed in a file named <filename>package-info."
 "java</filename> in the appropriate package. Place your annotations before "
 "the package declaration."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1835
 #, no-c-format
 msgid ""
 "@TypeDef(\n"
 "   name = \"phoneNumber\",\n"
 "   defaultForType = PhoneNumber.class,\n"
 "   typeClass = PhoneNumberType.class\n"
 ")\n"
 "\n"
 "@Entity\n"
 "public class ContactDetails {\n"
 "   [...]\n"
 "   private PhoneNumber localPhoneNumber;\n"
 "   @Type(type=\"phoneNumber\")\n"
 "   private OverseasPhoneNumber overseasPhoneNumber;\n"
 "   [...]\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1837
 #, no-c-format
 msgid ""
 "The following example shows the usage of the <literal>parameters</literal> "
 "attribute to customize the TypeDef."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1841
 #, no-c-format
 msgid ""
 "//in org/hibernate/test/annotations/entity/package-info.java\n"
 "@TypeDefs(\n"
 "    {\n"
 "    @TypeDef(\n"
 "        name=\"caster\",\n"
 "        typeClass = CasterStringType.class,\n"
 "        parameters = {\n"
 "            @Parameter(name=\"cast\", value=\"lower\")\n"
 "        }\n"
 "    )\n"
 "    }\n"
 ")\n"
 "package org.hibernate.test.annotations.entity;\n"
 "\n"
 "//in org/hibernate/test/annotations/entity/Forest.java\n"
 "public class Forest {\n"
 "    @Type(type=\"caster\")\n"
 "    public String getSmallText() {\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1843
 #, no-c-format
 msgid ""
 "When using composite user type, you will have to express column definitions. "
 "The <literal>@Columns</literal> has been introduced for that purpose."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1847
 #, no-c-format
 msgid ""
 "@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType"
 "\")\n"
 "@Columns(columns = {\n"
 "    @Column(name=\"r_amount\"),\n"
 "    @Column(name=\"r_currency\")\n"
 "})\n"
 "public MonetaryAmount getAmount() {\n"
 "    return amount;\n"
 "}\n"
 "\n"
 "\n"
 "public class MonetaryAmount implements Serializable {\n"
 "    private BigDecimal amount;\n"
 "    private Currency currency;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1851
 #, no-c-format
 msgid "Access type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1853
 #, no-c-format
 msgid ""
 "By default the access type of a class hierarchy is defined by the position "
 "of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> "
 "annotations. If these annotations are on a field, then only fields are "
 "considered for persistence and the state is accessed via the field. If there "
 "annotations are on a getter, then only the getters are considered for "
 "persistence and the state is accessed via the getter/setter. That works well "
 "in practice and is the recommended approach."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1861
 #, no-c-format
 msgid ""
 "The placement of annotations within a class hierarchy has to be consistent "
 "(either field or on property) to be able to determine the default access "
 "type. It is recommended to stick to one single annotation placement strategy "
 "throughout your whole application."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1868
 #, no-c-format
 msgid "However in some situations, you need to:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1872
 #, no-c-format
 msgid "force the access type of the entity hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1876
 #, no-c-format
 msgid "override the access type of a specific entity in the class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1881
 #, no-c-format
 msgid "override the access type of an embeddable type"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1885
 #, no-c-format
 msgid ""
 "The best use case is an embeddable class used by several entities that might "
 "not use the same access type. In this case it is better to force the access "
 "type at the embeddable class level."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1890
 #, no-c-format
 msgid ""
 "To force the access type on a given class, use the <classname>@Access</"
 "classname> annotation as showed below:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1893
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   @Embedded private Address address;\n"
 "   public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Entity\n"
 "public class User {\n"
 "   private Long id;\n"
 "   @Id public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "\n"
 "   private Address address;\n"
 "   @Embedded public Address getAddress() { return address; }\n"
 "   public void setAddress() { this.address = address; }\n"
 "}\n"
 "\n"
 "@Embeddable\n"
 "@Access(AcessType.PROPERTY)\n"
 "public class Address {\n"
 "   private String street1;\n"
 "   public String getStreet1() { return street1; }\n"
 "   public void setStreet1() { this.street1 = street1; }\n"
 "\n"
 "   private hashCode; //not persistent\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1895
 #, no-c-format
 msgid ""
 "You can also override the access type of a single property while keeping the "
 "other properties standard."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1898
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Order {\n"
 "   @Id private Long id;\n"
 "   public Long getId() { return id; }\n"
 "   public void setId(Long id) { this.id = id; }\n"
 "   @Transient private String userId;\n"
 "   @Transient private String orderId;\n"
 "\n"
 "   @Access(AccessType.PROPERTY)\n"
 "   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
 "   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1900
 #, no-c-format
 msgid ""
 "In this example, the default access type is <classname>FIELD</classname> "
 "except for the <literal>orderNumber</literal> property. Note that the "
 "corresponding field, if any must be marked as <classname>@Transient</"
 "classname> or <code>transient</code>."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1907
 #, no-c-format
 msgid "@org.hibernate.annotations.AccessType"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1909
 #, no-c-format
 msgid ""
 "The annotation <classname>@org.hibernate.annotations.AccessType</classname> "
 "should be considered deprecated for FIELD and PROPERTY access. It is still "
 "useful however if you need to use a custom access type."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1918
 #, no-c-format
 msgid "Optimistic lock"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1920
 #, no-c-format
 msgid ""
 "It is sometimes useful to avoid increasing the version number even if a "
 "given property is dirty (particularly collections). You can do that by "
 "annotating the property (or collection) with <literal>@OptimisticLock"
 "(excluded=true)</literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1925
 #, no-c-format
 msgid ""
 "More formally, specifies that updates to this property do not require "
 "acquisition of the optimistic lock."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:1930
 #, no-c-format
 msgid "Declaring column attributes"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1932
 #, no-c-format
 msgid ""
 "The column(s) used for a property mapping can be defined using the "
 "<literal>@Column</literal> annotation. Use it to override default values "
 "(see the JPA specification for more information on the defaults). You can "
 "use this annotation at the property level for properties that are:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1940
 #, no-c-format
 msgid "not annotated at all"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1944
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Basic</literal>"
 msgstr "<literal>assigned</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1948
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Version</literal>"
 msgstr "<literal>string</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1952
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Lob</literal>"
 msgstr "<literal>hilo</literal>"
 
 #. Tag: para
 #: basic_mapping.xml:1956
 #, fuzzy, no-c-format
 msgid "annotated with <literal>@Temporal</literal>"
 msgstr "<literal>serializable</literal>"
 
 #. Tag: programlisting
 #: basic_mapping.xml:1960
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Flight implements Serializable {\n"
 "...\n"
 "@Column(updatable = false, name = \"flight_name\", nullable = false, "
 "length=50)\n"
 "public String getName() { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1962
 #, no-c-format
 msgid ""
 "The <literal>name</literal> property is mapped to the <literal>flight_name</"
 "literal> column, which is not nullable, has a length of 50 and is not "
 "updatable (making the property immutable)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1967
 #, no-c-format
 msgid ""
 "This annotation can be applied to regular properties as well as "
 "<literal>@Id</literal> or <literal>@Version</literal> properties."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:1994
 #, no-c-format
 msgid ""
 "@Column(\n"
 "    name=\"columnName\";\n"
 "    boolean unique() default false;\n"
 "    boolean nullable() default true;\n"
 "    boolean insertable() default true;\n"
 "    boolean updatable() default true;\n"
 "    String columnDefinition() default \"\";\n"
 "    String table() default \"\";\n"
 "    int length() default 255;\n"
 "    int precision() default 0; // decimal precision\n"
 "    int scale() default 0; // decimal scale"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:1998
 #, fuzzy, no-c-format
 msgid ""
 "<literal>name</literal> (optional): the column name (default to the property "
 "name)"
 msgstr "<literal>name</literal>（可选）：标识属性的名字。 "
 
 #. Tag: para
 #: basic_mapping.xml:2003
 #, fuzzy, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): set a unique constraint on this column "
 "or not (default false)"
 msgstr ""
 "<literal>unique</literal>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允"
 "许它作为 <literal>property-ref</literal> 引用的目标。 "
 
 #. Tag: para
 #: basic_mapping.xml:2008
 #, fuzzy, no-c-format
 msgid ""
 "<literal>nullable</literal> (optional): set the column as nullable (default "
 "true)."
 msgstr "<literal>name</literal>（可选）：标识属性的名字。 "
 
 #. Tag: para
 #: basic_mapping.xml:2013
 #, fuzzy, no-c-format
 msgid ""
 "<literal>insertable</literal> (optional): whether or not the column will be "
 "part of the insert statement (default true)"
 msgstr "<literal>name</literal>（可选）：标识属性的名字。 "
 
 #. Tag: para
 #: basic_mapping.xml:2019
 #, fuzzy, no-c-format
 msgid ""
 "<literal>updatable</literal> (optional): whether or not the column will be "
 "part of the update statement (default true)"
 msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "
 
 #. Tag: para
 #: basic_mapping.xml:2025
 #, no-c-format
 msgid ""
 "<literal>columnDefinition</literal> (optional): override the sql DDL "
 "fragment for this particular column (non portable)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2031
 #, fuzzy, no-c-format
 msgid ""
 "<literal>table</literal> (optional): define the targeted table (default "
 "primary table)"
 msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "
 
 #. Tag: para
 #: basic_mapping.xml:2036
 #, no-c-format
 msgid ""
 "<literal><literal>length</literal></literal> (optional): column length "
 "(default 255)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2041
 #, no-c-format
 msgid ""
 "<literal><literal>precision</literal></literal> (optional): column decimal "
 "precision (default 0)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2046
 #, no-c-format
 msgid ""
 "<literal><literal>scale</literal></literal> (optional): column decimal scale "
 "if useful (default 0)"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2054
 #, no-c-format
 msgid "Formula"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2056
 #, no-c-format
 msgid ""
 "Sometimes, you want the Database to do some computation for you rather than "
 "in the JVM, you might also create some kind of virtual column. You can use a "
 "SQL fragment (aka formula) instead of mapping a property into a column. This "
 "kind of property is read only (its value is calculated by your formula "
 "fragment)."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2062
 #, no-c-format
 msgid ""
 "@Formula(\"obj_length * obj_height * obj_width\")\n"
 "public long getObjectVolume()"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2064
 #, no-c-format
 msgid ""
 "The SQL fragment can be as complex as you want and even include subselects."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2069
 #, no-c-format
 msgid "Non-annotated property defaults"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2071
 #, no-c-format
 msgid "If a property is not annotated, the following rules apply:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2074
 #, no-c-format
 msgid "If the property is of a single type, it is mapped as @Basic"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2079
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is annotated as @Embeddable, it is "
 "mapped as @Embedded"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2084
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>Serializable</"
 "classname>, it is mapped as <classname>@Basic</classname> in a column "
 "holding the object in its serialized version"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2091
 #, no-c-format
 msgid ""
 "Otherwise, if the type of the property is <classname>java.sql.Clob</"
 "classname> or <classname>java.sql.Blob</classname>, it is mapped as "
 "<classname>@Lob</classname> with the appropriate <classname>LobType</"
 "classname>"
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2102
 #, no-c-format
 msgid "Property mapping with hbm.xml"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2104
 #, no-c-format
 msgid ""
 "The <literal>&lt;property&gt;</literal> element declares a persistent "
 "JavaBean style property of the class."
 msgstr ""
 "<literal>&lt;property&gt;</literal> 元素为类定义了一个持久化的、JavaBean 风格"
 "的属性。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2136
 #, fuzzy, no-c-format
 msgid ""
 "&lt;property\n"
 "        name=\"propertyName\"\n"
 "        column=\"column_name\"\n"
 "        type=\"typename\"\n"
 "        update=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary SQL expression\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        not-null=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        generated=\"never|insert|always\"\n"
 "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
 "        index=\"index_name\"\n"
 "        unique_key=\"unique_key_id\"\n"
 "        length=\"L\"\n"
 "        precision=\"P\"\n"
 "        scale=\"S\"\n"
 "/&gt;"
 msgstr ""
 "<![CDATA[<property\n"
 "        name=\"propertyName\"\n"
 "        column=\"column_name\"\n"
 "        type=\"typename\"\n"
 "        update=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary SQL expression\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        not-null=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        generated=\"never|insert|always\"\n"
 "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
 "        index=\"index_name\"\n"
 "        unique_key=\"unique_key_id\"\n"
 "        length=\"L\"\n"
 "        precision=\"P\"\n"
 "        scale=\"S\"\n"
 "/>]]>"
 
 #. Tag: para
 #: basic_mapping.xml:2140
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the name of the property, with an initial lowercase "
 "letter."
 msgstr "<literal>name</literal>：属性的名字，以小写字母开头。"
 
 #. Tag: para
 #: basic_mapping.xml:2145
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to the property name): the "
 "name of the mapped database table column. This can also be specified by "
 "nested <literal>&lt;column&gt;</literal> element(s)."
 msgstr ""
 "<literal>column</literal>（可选 — 默认为属性名字）：对应的数据库字段名。 也可"
 "以通过嵌套的 <literal>&lt;column&gt;</literal> 元素指定。 "
 
 #. Tag: para
 #: basic_mapping.xml:2157
 #, no-c-format
 msgid ""
 "<literal>update, insert</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that the mapped columns should be included in SQL "
 "<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
 "Setting both to <literal>false</literal> allows a pure \"derived\" property "
 "whose value is initialized from some other property that maps to the same "
 "column(s), or by a trigger or other application."
 msgstr ""
 "<literal>update, insert</literal>（可选 — 默认为 <literal>true</literal>）： "
 "表明用于　<literal>UPDATE</literal> 和/或 <literal>INSERT</literal> 的 SQL 语"
 "句中是否包含这个被映射了的字段。这二者如果都设置为 <literal>false</literal> "
 "则表明这是一个“外源性（derived）”的属性，它的值来源于映射到同一个（或多个） "
 "字段的某些其他属性，或者通过一个 trigger（触发器）或其他程序生成。 "
 
 #. Tag: para
 #: basic_mapping.xml:2167
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an SQL expression that defines the "
 "value for a <emphasis>computed</emphasis> property. Computed properties do "
 "not have a column mapping of their own."
 msgstr ""
 "<literal>formula</literal>（可选）：一个 SQL 表达式，定义了这个<emphasis>计"
 "算 （computed）</emphasis> 属性的值。计算属性没有和它对应的数据库字段。"
 
 #. Tag: para
 #: basic_mapping.xml:2180
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this property should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal>（可选 — 默认为 <literal>false</literal>）：指定 指定"
 "实例变量第一次被访问时，这个属性是否延迟抓取（fetched lazily）（ 需要运行时字"
 "节码增强）。 "
 
 #. Tag: para
 #: basic_mapping.xml:2187
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional): enables the DDL generation of a unique "
 "constraint for the columns. Also, allow this to be the target of a "
 "<literal>property-ref</literal>."
 msgstr ""
 "<literal>unique</literal>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允"
 "许它作为 <literal>property-ref</literal> 引用的目标。 "
 
 #. Tag: para
 #: basic_mapping.xml:2194
 #, no-c-format
 msgid ""
 "<literal>not-null</literal> (optional): enables the DDL generation of a "
 "nullability constraint for the columns."
 msgstr ""
 "<literal>not-null</literal>（可选）：使用 DDL 为该字段添加可否为空"
 "（nullability）的约束。 "
 
 #. Tag: para
 #: basic_mapping.xml:2199 basic_mapping.xml:3282
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this property do or do not require "
 "acquisition of the optimistic lock. In other words, it determines if a "
 "version increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal>（可选 — 默认为 <literal>true</literal>）："
 "指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决"
 "定这个属性发生脏数据时版本（version）的值是否增长。 "
 
 #. Tag: para
 #: basic_mapping.xml:2207
 #, no-c-format
 msgid ""
 "<literal>generated</literal> (optional - defaults to <literal>never</"
 "literal>): specifies that this property value is actually generated by the "
 "database. See the discussion of <link linkend=\"mapping-generated"
 "\">generated properties</link> for more information."
 msgstr ""
 "<literal>generated</literal>（可选 — 默认为 <literal>never</literal>）：表明"
 "此属性值是否实际上是由数据库生成的。请参阅 <link linkend=\"mapping-generated"
 "\">generated properties</link> 的讨论。 "
 
 #. Tag: para
 #: basic_mapping.xml:2216
 #, no-c-format
 msgid "<emphasis>typename</emphasis> could be:"
 msgstr "<emphasis>typename</emphasis> 可以是如下几种："
 
 #. Tag: para
 #: basic_mapping.xml:2241
 #, no-c-format
 msgid ""
 "If you do not specify a type, Hibernate will use reflection upon the named "
 "property and guess the correct Hibernate type. Hibernate will attempt to "
 "interpret the name of the return class of the property getter using, in "
 "order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
 "literal> attribute. For example, to distinguish between <literal>Hibernate."
 "DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
 "custom type."
 msgstr ""
 "如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确"
 "的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方"
 "法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <literal>type</"
 "literal> 属性。（比如，为了区别<literal>Hibernate.DATE</literal> 和"
 "<literal>Hibernate.TIMESTAMP</literal>,或者为了指定一个自定义类型。） "
 
 #. Tag: para
 #: basic_mapping.xml:2250
 #, no-c-format
 msgid ""
 "The <literal>access</literal> attribute allows you to control how Hibernate "
 "accesses the property at runtime. By default, Hibernate will call the "
 "property get/set pair. If you specify <literal>access=\"field\"</literal>, "
 "Hibernate will bypass the get/set pair and access the field directly using "
 "reflection. You can specify your own strategy for property access by naming "
 "a class that implements the interface <literal>org.hibernate.property."
 "PropertyAccessor</literal>."
 msgstr ""
 "<literal>access</literal> 属性用来让你控制 Hibernate 如何在运行时访问属性。在"
 "默认情况下，Hibernate 会使用属性的 get/set 方法对（pair）。如果你指明 "
 "<literal>access=\"field\"</literal>，Hibernate 会忽略 get/set 方法对，直接使"
 "用反射来访问成员变量。你也可以指定你自己的策略，这就需要你自己实现 "
-"<literal>org.hibernate.property.PropertyAccessor</literal> 接口，再在 access "
+"<literal>org.hibernate.property.access.spi.PropertyAccessStrategy</literal> 接口，再在 access "
 "中设置你自定义策略类的名字。 "
 
 #. Tag: para
 #: basic_mapping.xml:2259
 #, no-c-format
 msgid ""
 "A powerful feature is derived properties. These properties are by definition "
 "read-only. The property value is computed at load time. You declare the "
 "computation as an SQL expression. This then translates to a <literal>SELECT</"
 "literal> clause subquery in the SQL query that loads an instance:"
 msgstr ""
 "衍生属性（derive propertie）是一个特别强大的特征。这些属性应该定义为只读，属"
 "性值在装载时计算生成。 你用一个 SQL 表达式生成计算的结果，它会在这个实例转载"
 "时翻译成一个 SQL 查询的 <literal>SELECT</literal> 子查询语句。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2265
 #, fuzzy, no-c-format
 msgid ""
 "&lt;property name=\"totalPrice\"\n"
 "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
 "p\n"
 "                WHERE li.productId = p.productId\n"
 "                AND li.customerId = customerId\n"
 "                AND li.orderNumber = orderNumber )\"/&gt;"
 msgstr ""
 "&lt;property name=\"totalPrice\"\n"
 "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
 "p\n"
 "                WHERE li.productId = p.productId\n"
 "                AND li.customerId = customerId\n"
 "                AND li.orderNumber = orderNumber )\"/&gt;"
 
 #. Tag: para
 #: basic_mapping.xml:2267
 #, no-c-format
 msgid ""
 "You can reference the entity table by not declaring an alias on a particular "
 "column. This would be <literal>customerId</literal> in the given example. "
 "You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
 "element if you do not want to use the attribute."
 msgstr ""
 "注意，你可以使用实体自己的表，而不用为这个特别的列定义别名（上面例子中的 "
 "<literal>customerId</literal>）。同时注意，如果你不喜欢使用属性， 你可以使用"
 "嵌套的 <literal>&lt;formula&gt;</literal> 映射元素。 "
 
 #. Tag: title
 #: basic_mapping.xml:2276
 #, no-c-format
 msgid "Embedded objects (aka components)"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2278
 #, fuzzy, no-c-format
 msgid ""
 "Embeddable objects (or components) are objects whose properties are mapped "
 "to the same table as the owning entity's table. Components can, in turn, "
 "declare their own properties, components or collections"
 msgstr ""
 "<literal>&lt;component&gt;</literal> 元素把子对象的一些元素与父类对应的表的一"
 "些字段映射起来。然后组件可以定义它们自己的属性、组件或者集合。参见后面"
 "的“Components”一章。 "
 
 #. Tag: para
 #: basic_mapping.xml:2283
 #, no-c-format
 msgid ""
 "It is possible to declare an embedded component inside an entity and even "
 "override its column mapping. Component classes have to be annotated at the "
 "class level with the <literal>@Embeddable</literal> annotation. It is "
 "possible to override the column mapping of an embedded object for a "
 "particular entity using the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride</literal> annotation in the associated property:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2291
 #, no-c-format
 msgid ""
 "@Entity\n"
 "public class Person implements Serializable {\n"
 "\n"
 "    // Persistent component using defaults\n"
 "    Address homeAddress;\n"
 "\n"
 "    @Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"iso2\", column = @Column(name="
 "\"bornIso2\") ),\n"
 "            @AttributeOverride(name=\"name\", column = @Column(name="
 "\"bornCountryName\") )\n"
 "    } )\n"
 "    Country bornIn;\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2293
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Address implements Serializable {\n"
 "    String city;\n"
 "    Country nationality; //no overriding here\n"
 "}"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2295
 #, no-c-format
 msgid ""
 "@Embeddable\n"
 "public class Country implements Serializable {\n"
 "    private String iso2;\n"
 "    @Column(name=\"countryName\") private String name;\n"
 "\n"
 "    public String getIso2() { return iso2; }\n"
 "    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
 "\n"
 "    \n"
 "    public String getName() { return name; }\n"
 "    public void setName(String name) { this.name = name; }\n"
 "    ...\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2297
 #, no-c-format
 msgid ""
 "An embeddable object inherits the access type of its owning entity (note "
 "that you can override that using the <literal>@Access</literal> annotation)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2301
 #, no-c-format
 msgid ""
 "The <literal>Person</literal> entity has two component properties, "
 "<literal>homeAddress</literal> and <literal>bornIn</literal>. "
 "<literal>homeAddress</literal> property has not been annotated, but "
 "Hibernate will guess that it is a persistent component by looking for the "
 "<literal>@Embeddable</literal> annotation in the Address class. We also "
 "override the mapping of a column name (to <literal>bornCountryName</"
 "literal>) with the <literal>@Embedded</literal> and "
 "<literal>@AttributeOverride </literal>annotations for each mapped attribute "
 "of <literal>Country</literal>. As you can see, <literal>Country </literal>is "
 "also a nested component of <literal>Address</literal>, again using auto-"
 "detection by Hibernate and JPA defaults. Overriding columns of embedded "
 "objects of embedded objects is through dotted expressions."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2316
 #, no-c-format
 msgid ""
 "@Embedded\n"
 "    @AttributeOverrides( {\n"
 "            @AttributeOverride(name=\"city\", column = @Column(name="
 "\"fld_city\") ),\n"
 "            @AttributeOverride(name=\"nationality.iso2\", column = @Column"
 "(name=\"nat_Iso2\") ),\n"
 "            @AttributeOverride(name=\"nationality.name\", column = @Column"
 "(name=\"nat_CountryName\") )\n"
 "            //nationality columns in homeAddress are overridden\n"
 "    } )\n"
 "    Address homeAddress;"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2318
 #, no-c-format
 msgid ""
 "Hibernate Annotations supports something that is not explicitly supported by "
 "the JPA specification. You can annotate a embedded object with the "
 "<literal>@MappedSuperclass</literal> annotation to make the superclass "
 "properties persistent (see <literal>@MappedSuperclass</literal> for more "
 "informations)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2324
 #, no-c-format
 msgid ""
 "You can also use association annotations in an embeddable object (ie "
 "<literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, "
 "<classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To "
 "override the association columns you can use <literal>@AssociationOverride</"
 "literal>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2330
 #, no-c-format
 msgid ""
 "If you want to have the same embeddable object type twice in the same "
 "entity, the column name defaulting will not work as several embedded objects "
 "would share the same set of columns. In plain JPA, you need to override at "
 "least one set of columns. Hibernate, however, allows you to enhance the "
 "default naming mechanism through the <classname>NamingStrategy</classname> "
 "interface. You can write a strategy that prevent name clashing in such a "
 "situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an "
 "example of this."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2340
 #, no-c-format
 msgid ""
 "If a property of the embedded object points back to the owning entity, "
 "annotate it with the <classname>@Parent</classname> annotation. Hibernate "
 "will make sure this property is properly loaded with the entity reference."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2345
 #, no-c-format
 msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2367
 #, fuzzy, no-c-format
 msgid ""
 "&lt;component\n"
 "        name=\"propertyName\"\n"
 "        class=\"className\"\n"
 "        insert=\"true|false\"\n"
 "        update=\"true|false\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        node=\"element-name|.\"\n"
 "&gt;\n"
 "\n"
 "        &lt;property ...../&gt;\n"
 "        &lt;many-to-one .... /&gt;\n"
 "        ........\n"
 "&lt;/component&gt;"
 msgstr ""
 "&lt;component \n"
 "        name=\"propertyName\" \n"
 "        class=\"className\"\n"
 "        insert=\"true|false\"\n"
 "        update=\"true|false\"\n"
 "        access=\"field|property|ClassName\"\n"
 "        lazy=\"true|false\"\n"
 "        optimistic-lock=\"true|false\"\n"
 "        unique=\"true|false\"\n"
 "        node=\"element-name|.\"\n"
 "&gt;\n"
 "        \n"
 "        &lt;property ...../&gt;\n"
 "        &lt;many-to-one .... /&gt;\n"
 "        ........\n"
 "&lt;/component&gt;"
 
 #. Tag: para
 #: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
 #, no-c-format
 msgid "<literal>name</literal>: the name of the property."
 msgstr "<literal>name</literal>：属性名。"
 
 #. Tag: para
 #: basic_mapping.xml:2375
 #, no-c-format
 msgid ""
 "<literal>class</literal> (optional - defaults to the property type "
 "determined by reflection): the name of the component (child) class."
 msgstr ""
 "<literal>class</literal>（可选 — 默认为通过反射得到的属性类型）：组件（子）类"
 "的名字。 "
 
 #. Tag: para
 #: basic_mapping.xml:2381 basic_mapping.xml:3677
 #, no-c-format
 msgid ""
 "<literal>insert</literal>: do the mapped columns appear in SQL "
 "<literal>INSERTs</literal>?"
 msgstr ""
 "<literal>insert</literal>：被映射的字段是否出现在 SQL 的 <literal>INSERT</"
 "literal> 语句中？ "
 
 #. Tag: para
 #: basic_mapping.xml:2386 basic_mapping.xml:3682
 #, no-c-format
 msgid ""
 "<literal>update</literal>: do the mapped columns appear in SQL "
 "<literal>UPDATEs</literal>?"
 msgstr ""
 "<literal>update</literal>：被映射的字段是否出现在 SQL 的 <literal>UPDATE</"
 "literal> 语句中？ "
 
 #. Tag: para
 #: basic_mapping.xml:2397
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that this component should be fetched lazily when the instance "
 "variable is first accessed. It requires build-time bytecode instrumentation."
 msgstr ""
 "<literal>lazy</literal>（可选 — 默认是 <literal>false</literal>）：表明此组件"
 "应在实例变量第一次被访问的时候延迟加载（需要编译时字节码装置器）。"
 
 #. Tag: para
 #: basic_mapping.xml:2404
 #, no-c-format
 msgid ""
 "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
 "literal>): specifies that updates to this component either do or do not "
 "require acquisition of the optimistic lock. It determines if a version "
 "increment should occur when this property is dirty."
 msgstr ""
 "<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）："
 "表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号"
 "（Version）。"
 
 #. Tag: para
 #: basic_mapping.xml:2412 basic_mapping.xml:3695
 #, no-c-format
 msgid ""
 "<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
 "specifies that a unique constraint exists upon all mapped columns of the "
 "component."
 msgstr ""
 "<literal>unique</literal>（可选 — 默认是 <literal>false</literal>）：表明组件"
 "映射的所有字段上都有唯一性约束。"
 
 #. Tag: para
 #: basic_mapping.xml:2419
 #, no-c-format
 msgid ""
 "The child <literal>&lt;property&gt;</literal> tags map properties of the "
 "child class to table columns."
 msgstr ""
 "其 <literal>&lt;property&gt;</literal> 子标签为子类的一些属性与表字段之间建立"
 "映射。"
 
 #. Tag: para
 #: basic_mapping.xml:2422
 #, no-c-format
 msgid ""
 "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
 "parent&gt;</literal> subelement that maps a property of the component class "
 "as a reference back to the containing entity."
 msgstr ""
 "<literal>&lt;component&gt;</literal> 元素允许加入一个 <literal>&lt;parent&gt;"
 "</literal> 子元素，在组件类内部就可以有一个指向其容器的实体的反向引用。"
 
 #. Tag: para
 #: basic_mapping.xml:2426
 #, fuzzy, no-c-format
 msgid ""
 "The <literal>&lt;dynamic-component&gt;</literal> element allows a "
 "<literal>Map</literal> to be mapped as a component, where the property names "
 "refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for "
 "more information. This feature is not supported in annotations."
 msgstr ""
 "<literal>&lt;dynamic-component&gt;</literal> 元素允许把一个 <literal>Map</"
 "literal> 映射为组件，其属性名对应 map 的键值。参见 <xref linkend="
 "\"components-dynamic\"/>。 "
 
 #. Tag: title
 #: basic_mapping.xml:2434
 #, no-c-format
 msgid "Inheritance strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2436
 #, no-c-format
 msgid ""
 "Java is a language supporting polymorphism: a class can inherit from "
 "another. Several strategies are possible to persist a class hierarchy:"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2442
 #, no-c-format
 msgid ""
 "Single table per class hierarchy strategy: a single table hosts all the "
 "instances of a class hierarchy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2447
 #, no-c-format
 msgid ""
 "Joined subclass strategy: one table per class and subclass is present and "
 "each table persist the properties specific to a given subclass. The state of "
 "the entity is then stored in its corresponding class table and all its "
 "superclasses"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2454
 #, no-c-format
 msgid ""
 "Table per class strategy: one table per concrete class and subclass is "
 "present and each table persist the properties of the class and its "
 "superclasses. The state of the entity is then stored entirely in the "
 "dedicated table for its class."
 msgstr ""
 
 #. Tag: title
 #: basic_mapping.xml:2462
 #, no-c-format
 msgid "Single table per class hierarchy strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2464
 #, no-c-format
 msgid ""
 "With this approach the properties of all the subclasses in a given mapped "
 "class hierarchy are stored in a single table."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2467
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass declares its own persistent properties and subclasses. Version "
 "and id properties are assumed to be inherited from the root class. Each "
 "subclass in a hierarchy must define a unique discriminator value. If this is "
 "not specified, the fully qualified Java class name is used."
 msgstr ""
 "每个子类都应该定义它自己的持久化属性和子类。<literal>&lt;version&gt;</"
 "literal> 和 <literal>&lt;id&gt;</literal> 属性可以从根父类继承下来。在一棵继"
 "承树上的每个子类都必须定义一个唯一的 <literal>discriminator-value</literal>。"
 "如果没有指定，就会使用 Java 类的全限定名。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2473 basic_mapping.xml:2581
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
 "@DiscriminatorColumn(\n"
 "    name=\"planetype\",\n"
 "    discriminatorType=DiscriminatorType.STRING\n"
 ")\n"
 "@DiscriminatorValue(\"Plane\")\n"
 "public class Plane { ... }\n"
 "\n"
 "@Entity\n"
 "@DiscriminatorValue(\"A320\")\n"
 "public class A320 extends Plane { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2475
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, for the table-per-class-hierarchy mapping strategy, the "
 "<literal>&lt;subclass&gt;</literal> declaration is used. For example:"
 msgstr ""
 "最后，多态持久化需要为父类的每个子类都进行定义。对于“每一棵类继承树对应一个"
 "表”的策略来说，就需要使用 <literal>&lt;subclass&gt;</literal> 定义。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2490
 #, fuzzy, no-c-format
 msgid ""
 "&lt;subclass\n"
 "        name=\"ClassName\"\n"
 "        discriminator-value=\"discriminator_value\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"\n"
 "        extends=\"SuperclassName\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/subclass&gt;"
 msgstr ""
 "&lt;subclass\n"
 "        name=\"ClassName\"\n"
 "        discriminator-value=\"discriminator_value\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"\n"
 "        extends=\"SuperclassName\"&gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/subclass&gt;"
 
 #. Tag: para
 #: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
 #, no-c-format
 msgid ""
 "<literal>name</literal>: the fully qualified class name of the subclass."
 msgstr "<literal>name</literal>：子类的全限定名。 "
 
 #. Tag: para
 #: basic_mapping.xml:2499
 #, no-c-format
 msgid ""
 "<literal>discriminator-value</literal> (optional - defaults to the class "
 "name): a value that distinguishes individual subclasses."
 msgstr ""
 "<literal>discriminator-value（辨别标志）</literal>（可选 — 默认为类名）：一个"
 "用于区分每个独立的子类的值。 "
 
 #. Tag: para
 #: basic_mapping.xml:2505
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface used for "
 "lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使"
 "用。 "
 
 #. Tag: para
 #: basic_mapping.xml:2510
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 "
 "<literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "
 
 #. Tag: para
 #: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
 #, fuzzy, no-c-format
 msgid ""
 "For information about inheritance mappings see <xref linkend=\"inheritance\"/"
 ">."
 msgstr "更多关于继承映射的信息，参考 <xref linkend=\"inheritance\"/>。 "
 
 #. Tag: title
 #: basic_mapping.xml:2522
 #, no-c-format
 msgid "Discriminator"
 msgstr "鉴别器（discriminator） "
 
 #. Tag: para
 #: basic_mapping.xml:2524
 #, fuzzy, no-c-format
 msgid ""
 "Discriminators are required for polymorphic persistence using the table-per-"
 "class-hierarchy mapping strategy. It declares a discriminator column of the "
 "table. The discriminator column contains marker values that tell the "
 "persistence layer what subclass to instantiate for a particular row. "
 "Hibernate Core supports the follwoing restricted set of types as "
 "discriminator column: <literal>string</literal>, <literal>character</"
 "literal>, <literal>integer</literal>, <literal>byte</literal>, "
 "<literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</"
 "literal>, <literal>true_false</literal>."
 msgstr ""
 "在\"一棵对象继承树对应一个表\"的策略中，<literal>&lt;discriminator&gt;</"
 "literal> 元素是必需的，它定义了表的鉴别器字段。鉴别器字段包含标志值，用于告知"
 "持久化层应该为某个特定的行创建哪一个子类的实例。如下这些受到限制的类型可以使"
 "用：<literal>string</literal>、<literal>character</literal>、"
 "<literal>integer</literal>、<literal>byte</literal>、<literal>short</"
 "literal>、<literal>boolean</literal>、<literal>yes_no</literal>、"
 "<literal>true_false</literal>。"
 
 #. Tag: para
 #: basic_mapping.xml:2535
 #, no-c-format
 msgid ""
 "Use the <classname>@DiscriminatorColumn</classname> to define the "
 "discriminator column as well as the discriminator type. <note> "
 "<para><classname>The enum DiscriminatorType</classname> used in "
 "<classname>javax.persitence.DiscriminatorColumn</classname> only contains "
 "the values <constant>STRING</constant>, <constant>CHAR</constant> and "
 "<constant>INTEGER</constant> which means that not all Hibernate supported "
 "types are available via the <classname>@DiscriminatorColumn</classname> "
 "annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</"
 "classname> to express in SQL a virtual discriminator column. This is "
 "particularly useful when the discriminator value can be extracted from one "
 "or more columns of the table. Both <classname>@DiscriminatorColumn</"
 "classname> and <classname>@DiscriminatorFormula</classname> are to be set on "
 "the root entity (once per persisted hierarchy)."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2552
 #, no-c-format
 msgid ""
 "<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> "
 "allows to optionally specify Hibernate specific discriminator options which "
 "are not standardized in JPA. The available options are <literal>force</"
 "literal> and <literal>insert</literal>. The <literal>force</literal> "
 "attribute is useful if the table contains rows with \"extra\" discriminator "
 "values that are not mapped to a persistent class. This could for example "
 "occur when working with a legacy database. If <literal>force</literal> is "
 "set to <constant>true</constant> Hibernate will specify the allowed "
 "discriminator values in the <literal>SELECT</literal> query, even when "
 "retrieving all instances of the root class. The second option - "
 "<literal>insert</literal> - tells Hibernate whether or not to include the "
 "discriminator column in SQL <literal>INSERTs</literal>. Usually the column "
 "should be part of the <literal>INSERT</literal> statement, but if your "
 "discriminator column is also part of a mapped composite identifier you have "
 "to set this option to <constant>false</constant>."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2569
 #, no-c-format
 msgid ""
 "There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</"
 "classname> annotation which is deprecated since version 3.6. Use "
 "<classname>@DiscriminatorOptions</classname> instead."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2575
 #, no-c-format
 msgid ""
 "Finally, use <classname>@DiscriminatorValue</classname> on each class of the "
 "hierarchy to specify the value stored in the discriminator column for a "
 "given entity. If you do not set <classname>@DiscriminatorValue</classname> "
 "on a class, the fully qualified class name is used."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2583
 #, no-c-format
 msgid ""
 "In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to "
 "define the discriminator column or formula:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2600
 #, fuzzy, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "        column=\"discriminator_column\"\n"
 "        type=\"discriminator_type\"\n"
 "        force=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary sql expression\"\n"
 "/&gt;"
 msgstr ""
 "<![CDATA[<discriminator\n"
 "        column=\"discriminator_column\"\n"
 "        type=\"discriminator_type\"\n"
 "        force=\"true|false\"\n"
 "        insert=\"true|false\"\n"
 "        formula=\"arbitrary sql expression\"\n"
 "/>]]>"
 
 #. Tag: para
 #: basic_mapping.xml:2604
 #, no-c-format
 msgid ""
 "<literal>column</literal> (optional - defaults to <literal>class</literal>): "
 "the name of the discriminator column."
 msgstr ""
 "<literal>column</literal>（可选 — 默认为 <literal>class</literal>）"
 "discriminator 器字段的名字。"
 
 #. Tag: para
 #: basic_mapping.xml:2610
 #, no-c-format
 msgid ""
 "<literal>type</literal> (optional - defaults to <literal>string</literal>): "
 "a name that indicates the Hibernate type"
 msgstr ""
 "<literal>type</literal>（可选 — 默认为 <literal>string</literal>）一个 "
 "Hibernate 字段类型的名字 "
 
 #. Tag: para
 #: basic_mapping.xml:2616
 #, no-c-format
 msgid ""
 "<literal>force</literal> (optional - defaults to <literal>false</literal>): "
 "\"forces\" Hibernate to specify the allowed discriminator values, even when "
 "retrieving all instances of the root class."
 msgstr ""
 "<literal>force(强制)</literal>（可选 — 默认为 <literal>false</literal>）\"强"
 "制\" Hibernate 指定允许的鉴别器值,即使当取得的所有实例都是根类的。 "
 
 #. Tag: para
 #: basic_mapping.xml:2623
 #, no-c-format
 msgid ""
 "<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
 "set this to <literal>false</literal> if your discriminator column is also "
 "part of a mapped composite identifier. It tells Hibernate not to include the "
 "column in SQL <literal>INSERTs</literal>."
 msgstr ""
 "<literal>insert</literal>（可选 - 默认为<literal>true</literal>）如果你的鉴别"
 "器字段也是映射为复合标识（composite identifier）的一部分，则需将这个值设为 "
 "<literal>false</literal>。（告诉 Hibernate 在做 SQL <literal>INSERT</"
 "literal> 时不包含该列） "
 
 #. Tag: para
 #: basic_mapping.xml:2631
 #, no-c-format
 msgid ""
 "<literal>formula</literal> (optional): an arbitrary SQL expression that is "
 "executed when a type has to be evaluated. It allows content-based "
 "discrimination."
 msgstr ""
 "<literal>formula</literal>（可选）一个 SQL 表达式，在类型判断（判断是父类还是"
 "具体子类 — 译注）时执行。可用于基于内容的鉴别器。 "
 
 #. Tag: para
 #: basic_mapping.xml:2638
 #, no-c-format
 msgid ""
 "Actual values of the discriminator column are specified by the "
 "<literal>discriminator-value</literal> attribute of the <literal>&lt;"
 "class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
 msgstr ""
 "鉴别器字段的实际值是根据 <literal>&lt;class&gt;</literal> 和 <literal>&lt;"
 "subclass&gt;</literal> 元素中的 <literal>discriminator-value</literal> 属性得"
 "来的。"
 
 #. Tag: para
 #: basic_mapping.xml:2643
 #, no-c-format
 msgid ""
 "The <literal>formula</literal> attribute allows you to declare an arbitrary "
 "SQL expression that will be used to evaluate the type of a row. For example:"
 msgstr ""
 "使用 <literal>formula</literal> 属性你可以定义一个 SQL 表达式，用来判断一行数"
 "据的类型。"
 
 #. Tag: programlisting
 #: basic_mapping.xml:2647
 #, fuzzy, no-c-format
 msgid ""
 "&lt;discriminator\n"
 "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
 "    type=\"integer\"/&gt;"
 msgstr ""
 "<![CDATA[<discriminator\n"
 "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
 "    type=\"integer\"/>]]>"
 
 #. Tag: title
 #: basic_mapping.xml:2652
 #, fuzzy, no-c-format
 msgid "Joined subclass strategy"
 msgstr "连接的子类（joined-subclass） "
 
 #. Tag: para
 #: basic_mapping.xml:2654
 #, fuzzy, no-c-format
 msgid ""
 "Each subclass can also be mapped to its own table. This is called the table-"
 "per-subclass mapping strategy. An inherited state is retrieved by joining "
 "with the table of the superclass. A discriminator column is not required for "
 "this mapping strategy. Each subclass must, however, declare a table column "
 "holding the object identifier. The primary key of this table is also a "
 "foreign key to the superclass table and described by the "
 "<classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</"
 "literal> element."
 msgstr ""
 "此外，每个子类可能被映射到他自己的表中（每个子类一个表的策略）。被继承的状态"
 "通过和超类的表关联得到。我们使用 <literal>&lt;joined-subclass&gt;</literal> "
 "元素。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2664
 #, no-c-format
 msgid ""
 "@Entity @Table(name=\"CATS\")\n"
 "@Inheritance(strategy=InheritanceType.JOINED)\n"
 "public class Cat implements Serializable { \n"
 "    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
 "    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
 "    String getId() { return id; }\n"
 "\n"
 "    ...\n"
 "}\n"
 "\n"
 "@Entity @Table(name=\"DOMESTIC_CATS\")\n"
 "@PrimaryKeyJoinColumn(name=\"CAT\")\n"
 "public class DomesticCat extends Cat { \n"
 "    public String getName() { return name; }\n"
 "}"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2667
 #, no-c-format
 msgid ""
 "The table name still defaults to the non qualified class name. Also if "
 "<classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / "
 "foreign key columns are assumed to have the same names as the primary key "
 "columns of the primary table of the superclass."
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2674
 #, fuzzy, no-c-format
 msgid ""
 "In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For "
 "example:"
 msgstr "你可以使用 <literal>class</literal> 元素来定义一个持久化类。例如："
 
 #. Tag: programlisting
 #: basic_mapping.xml:2688
 #, fuzzy, no-c-format
 msgid ""
 "&lt;joined-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;key .... &gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/joined-subclass&gt;"
 msgstr ""
 "&lt;joined-subclass\n"
 "        name=\"ClassName\"\n"
 "        table=\"tablename\"\n"
 "        proxy=\"ProxyInterface\"\n"
 "        lazy=\"true|false\"\n"
 "        dynamic-update=\"true|false\"\n"
 "        dynamic-insert=\"true|false\"\n"
 "        schema=\"schema\"\n"
 "        catalog=\"catalog\"\n"
 "        extends=\"SuperclassName\"\n"
 "        persister=\"ClassName\"\n"
 "        subselect=\"SQL expression\"\n"
 "        entity-name=\"EntityName\"\n"
 "        node=\"element-name\"&gt;\n"
 "\n"
 "        &lt;key .... &gt;\n"
 "\n"
 "        &lt;property .... /&gt;\n"
 "        .....\n"
 "&lt;/joined-subclass&gt;"
 
 #. Tag: para
 #: basic_mapping.xml:2697 basic_mapping.xml:2761
 #, no-c-format
 msgid "<literal>table</literal>: the name of the subclass table."
 msgstr "<literal>table</literal>：子类的表名。"
 
 #. Tag: para
 #: basic_mapping.xml:2702 basic_mapping.xml:2766
 #, no-c-format
 msgid ""
 "<literal>proxy</literal> (optional): specifies a class or interface to use "
 "for lazy initializing proxies."
 msgstr ""
 "<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使"
 "用。 "
 
 #. Tag: para
 #: basic_mapping.xml:2707 basic_mapping.xml:2771
 #, no-c-format
 msgid ""
 "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
 "setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
 msgstr ""
 "<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 "
 "<literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "
 
 #. Tag: para
 #: basic_mapping.xml:2715
 #, no-c-format
 msgid ""
 "Use the <literal>&lt;key&gt;</literal> element to declare the primary key / "
 "foreign key column. The mapping at the start of the chapter would then be re-"
 "written as:"
 msgstr ""
 
 #. Tag: programlisting
 #: basic_mapping.xml:2719
 #, fuzzy, no-c-format
 msgid ""
 "&lt;?xml version=\"1.0\"?&gt;\n"
 "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
 "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
 "        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
 "\n"
 "&lt;hibernate-mapping package=\"eg\"&gt;\n"
 "\n"
 "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
 "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
 "                        &lt;generator class=\"hilo\"/&gt;\n"
 "                &lt;/id&gt;\n"
 "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
 "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"weight\"/&gt;\n"
 "                &lt;many-to-one name=\"mate\"/&gt;\n"
 "                &lt;set name=\"kittens\"&gt;\n"
 "                        &lt;key column=\"MOTHER\"/&gt;\n"
 "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
 "                &lt;/set&gt;\n"
 "                &lt;joined-subclass name=\"DomesticCat\" table="
 "\"DOMESTIC_CATS\"&gt;\n"
 "                    &lt;key column=\"CAT\"/&gt;\n"
 "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
 "                &lt;/joined-subclass&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "        &lt;class name=\"eg.Dog\"&gt;\n"
 "                &lt;!-- mapping for Dog could go here --&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "&lt;/hibernate-mapping&gt;"
 msgstr ""
 "&lt;?xml version=\"1.0\"?&gt;\n"
 "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
 "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
 "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n"
 "\n"
 "&lt;hibernate-mapping package=\"eg\"&gt;\n"
 "\n"
 "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
 "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
 "                        &lt;generator class=\"hilo\"/&gt;\n"
 "                &lt;/id&gt;\n"
 "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
 "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
 "                &lt;property name=\"weight\"/&gt;\n"
 "                &lt;many-to-one name=\"mate\"/&gt;\n"
 "                &lt;set name=\"kittens\"&gt;\n"
 "                        &lt;key column=\"MOTHER\"/&gt;\n"
 "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
 "                &lt;/set&gt;\n"
 "                &lt;joined-subclass name=\"DomesticCat\" table="
 "\"DOMESTIC_CATS\"&gt;\n"
 "                    &lt;key column=\"CAT\"/&gt;\n"
 "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
 "                &lt;/joined-subclass&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "        &lt;class name=\"eg.Dog\"&gt;\n"
 "                &lt;!-- mapping for Dog could go here --&gt;\n"
 "        &lt;/class&gt;\n"
 "\n"
 "&lt;/hibernate-mapping&gt;"
 
 #. Tag: title
 #: basic_mapping.xml:2726
 #, no-c-format
 msgid "Table per class strategy"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2728
 #, fuzzy, no-c-format
 msgid ""
 "A third option is to map only the concrete classes of an inheritance "
 "hierarchy to tables. This is called the table-per-concrete-class strategy. "
 "Each table defines all persistent states of the class, including the "
 "inherited state. In Hibernate, it is not necessary to explicitly map such "
 "inheritance hierarchies. You can map each class as a separate entity root. "
 "However, if you wish use polymorphic associations (e.g. an association to "
 "the superclass of your hierarchy), you need to use the union subclass "
 "mapping."
 msgstr ""
 "第三种选择是仅仅映射类继承树中具体类部分到表中（每个具体类一张表的策略）。其"
 "中，每张表定义了类的所有持久化状态，包括继承的状态。在 Hibernate 中，并不需要"
 "完全显式地映射这样的继承树。你可以简单地使用单独的 <literal>&lt;class&gt;</"
 "literal> 定义映射每个类。然而，如果你想使用多态关联（例如，一个对类继承树中超"
 "类的关联），你需要使用 <literal>&lt;union-subclass&gt;</literal> 映射。 "
 
 #. Tag: programlisting
 #: basic_mapping.xml:2737
 #, no-c-format
 msgid ""
 "@Entity\n"
 "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
 "public class Flight implements Serializable { ... }"
 msgstr ""
 
 #. Tag: para
 #: basic_mapping.xml:2739
 #, no-c-format
 msgid "Or in hbm.xml:"
 msgstr ""
 
diff --git a/hibernate-core/src/main/java/org/hibernate/annotations/AttributeAccessor.java b/hibernate-core/src/main/java/org/hibernate/annotations/AttributeAccessor.java
index 82c33d617b..672f17a9f3 100644
--- a/hibernate-core/src/main/java/org/hibernate/annotations/AttributeAccessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/annotations/AttributeAccessor.java
@@ -1,44 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.annotations;
 
 import java.lang.annotation.Retention;
 
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Names a {@link org.hibernate.property.PropertyAccessor} strategy to use.
+ * Names a persistent property access strategy ({@link org.hibernate.property.access.spi.PropertyAccessStrategy}) to use.
  *
  * Can be specified at either:<ul>
  *     <li>
  *         <strong>TYPE</strong> level, which will act as naming the default accessor strategy for
  *         all attributes on the class which do not explicitly name an accessor strategy
  *     </li>
  *     <li>
  *         <strong>METHOD/FIELD</strong> level, which will be in effect for just that attribute.
  *     </li>
  * </ul>
  *
- * Should only be used to name custom {@link org.hibernate.property.PropertyAccessor}.  For {@code property/field}
- * access, the JPA {@link javax.persistence.Access} annotation should be preferred using the appropriate
- * {@link javax.persistence.AccessType}.  However, if this annotation is used with either {@code value="property"}
- * or {@code value="field"}, it will act just as the corresponding usage of {@link javax.persistence.Access}.
+ * Should only be used to name custom {@link org.hibernate.property.access.spi.PropertyAccessStrategy}.  For
+ * {@code property/field} access, the JPA {@link javax.persistence.Access} annotation should be preferred
+ * using the appropriate {@link javax.persistence.AccessType}.  However, if this annotation is used with
+ * either {@code value="property"} or {@code value="field"}, it will act just as the corresponding usage
+ * of {@link javax.persistence.Access}.
+ *
+ * @see org.hibernate.property.access.spi.PropertyAccessStrategy
+ * @see org.hibernate.property.access.spi.PropertyAccessStrategyResolver
  *
  * @author Steve Ebersole
  * @author Emmanuel Bernard
  */
 @java.lang.annotation.Target({ TYPE, METHOD, FIELD })
 @Retention(RUNTIME)
 public @interface AttributeAccessor {
 	/**
-	 * Names the {@link org.hibernate.property.PropertyAccessor} strategy.
+	 * Names the {@link org.hibernate.property.access.spi.PropertyAccessStrategy} strategy.
 	 */
 	String value();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/MetadataSources.java b/hibernate-core/src/main/java/org/hibernate/boot/MetadataSources.java
index 8c72eeef6f..4b5a01bd93 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/MetadataSources.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/MetadataSources.java
@@ -1,490 +1,492 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Serializable;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 import javax.xml.transform.dom.DOMSource;
 
 import org.hibernate.boot.archive.spi.InputStreamAccess;
 import org.hibernate.boot.internal.MetadataBuilderImpl;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.SourceType;
 import org.hibernate.boot.jaxb.internal.CacheableFileXmlSource;
 import org.hibernate.boot.jaxb.internal.FileXmlSource;
 import org.hibernate.boot.jaxb.internal.InputStreamXmlSource;
 import org.hibernate.boot.jaxb.internal.JarFileEntryXmlSource;
 import org.hibernate.boot.jaxb.internal.JaxpSourceXmlSource;
 import org.hibernate.boot.jaxb.internal.MappingBinder;
 import org.hibernate.boot.jaxb.internal.UrlXmlSource;
 import org.hibernate.boot.jaxb.spi.Binder;
 import org.hibernate.boot.jaxb.spi.Binding;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.SerializationException;
 
 import org.w3c.dom.Document;
 
 /**
  * Entry point into working with sources of metadata information (mapping XML, annotations).   Tell Hibernate
  * about sources and then call {@link #buildMetadata()}, or use {@link #getMetadataBuilder()} to customize
  * how sources are processed (naming strategies, etc).
  *
  * @author Steve Ebersole
  *
  * @since 5.0
  */
 public class MetadataSources implements Serializable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( MetadataSources.class );
 
 	private final ServiceRegistry serviceRegistry;
 
-	// NOTE : The boolean here indicates whether or not to perform validation as we load XML documents.
-	// Should we expose this setting?  Disabling would speed up JAXP and JAXB at runtime, but potentially
-	// at the cost of less obvious errors when a document is not valid.
-	private Binder mappingsBinder = new MappingBinder( true );
+	private Binder mappingsBinder;
 
 	private List<Binding> xmlBindings = new ArrayList<Binding>();
 	private LinkedHashSet<Class<?>> annotatedClasses = new LinkedHashSet<Class<?>>();
 	private LinkedHashSet<String> annotatedClassNames = new LinkedHashSet<String>();
 	private LinkedHashSet<String> annotatedPackages = new LinkedHashSet<String>();
 
 	public MetadataSources() {
 		this( new BootstrapServiceRegistryBuilder().build() );
 	}
 
 	/**
 	 * Create a metadata sources using the specified service registry.
 	 *
 	 * @param serviceRegistry The service registry to use.
 	 */
 	public MetadataSources(ServiceRegistry serviceRegistry) {
 		// service registry really should be either BootstrapServiceRegistry or StandardServiceRegistry type...
 		if ( ! isExpectedServiceRegistryType( serviceRegistry ) ) {
 			LOG.debugf(
 					"Unexpected ServiceRegistry type [%s] encountered during building of MetadataSources; may cause " +
 							"problems later attempting to construct MetadataBuilder",
 					serviceRegistry.getClass().getName()
 			);
 		}
 		this.serviceRegistry = serviceRegistry;
+
+		// NOTE : The boolean here indicates whether or not to perform validation as we load XML documents.
+		// Should we expose this setting?  Disabling would speed up JAXP and JAXB at runtime, but potentially
+		// at the cost of less obvious errors when a document is not valid.
+		this.mappingsBinder = new MappingBinder( serviceRegistry.getService( ClassLoaderService.class ), true );
 	}
 
 	protected static boolean isExpectedServiceRegistryType(ServiceRegistry serviceRegistry) {
 		return BootstrapServiceRegistry.class.isInstance( serviceRegistry )
 				|| StandardServiceRegistry.class.isInstance( serviceRegistry );
 	}
 
 	public List<Binding> getXmlBindings() {
 		return xmlBindings;
 	}
 
 	public Collection<String> getAnnotatedPackages() {
 		return annotatedPackages;
 	}
 
 	public Collection<Class<?>> getAnnotatedClasses() {
 		return annotatedClasses;
 	}
 
 	public Collection<String> getAnnotatedClassNames() {
 		return annotatedClassNames;
 	}
 
 	public ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	/**
 	 * Get a builder for metadata where non-default options can be specified.
 	 *
 	 * @return The built metadata.
 	 */
 	public MetadataBuilder getMetadataBuilder() {
 		return new MetadataBuilderImpl( this );
 	}
 
 	/**
 	 * Get a builder for metadata where non-default options can be specified.
 	 *
 	 * @return The built metadata.
 	 */
 	public MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) {
 		return new MetadataBuilderImpl( this, serviceRegistry );
 	}
 
 	/**
 	 * Short-hand form of calling {@link #getMetadataBuilder()} and using its
 	 * {@link org.hibernate.boot.MetadataBuilder#build()} method in cases where the application wants
 	 * to accept the defaults.
 	 *
 	 * @return The built metadata.
 	 */
 	public Metadata buildMetadata() {
 		return getMetadataBuilder().build();
 	}
 
 	public Metadata buildMetadata(StandardServiceRegistry serviceRegistry) {
 		return getMetadataBuilder( serviceRegistry ).build();
 	}
 
 	/**
 	 * Read metadata from the annotations attached to the given class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addAnnotatedClass(Class annotatedClass) {
 		annotatedClasses.add( annotatedClass );
 		return this;
 	}
 
 	/**
 	 * Read metadata from the annotations attached to the given class.  The important
 	 * distinction here is that the {@link Class} will not be accessed until later
 	 * which is important for on-the-fly bytecode-enhancement
 	 *
 	 * @param annotatedClassName The name of a class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addAnnotatedClassName(String annotatedClassName) {
 		annotatedClassNames.add( annotatedClassName );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name without trailing '.', cannot be {@code null}
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addPackage(String packageName) {
 		if ( packageName == null ) {
 			throw new IllegalArgumentException( "The specified package name cannot be null" );
 		}
 
 		if ( packageName.endsWith( "." ) ) {
 			packageName = packageName.substring( 0, packageName.length() - 1 );
 		}
 
 		annotatedPackages.add( packageName );
 
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageRef Java Package reference
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addPackage(Package packageRef) {
 		annotatedPackages.add( packageRef.getName() );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup).
 	 *
 	 * @param name The resource name
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addResource(String name) {
 		LOG.tracef( "reading mappings from resource : %s", name );
 
 		final Origin origin = new Origin( SourceType.RESOURCE, name );
 		final URL url = classLoaderService().locateResource( name );
 		if ( url == null ) {
 			throw new MappingNotFoundException( origin );
 		}
 
 		xmlBindings.add( new UrlXmlSource( origin, url ).doBind( mappingsBinder ) );
 
 		return this;
 	}
 
 	private ClassLoaderService classLoaderService() {
 		return serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class named {@code foo.bar.Foo} is
 	 * mapped by a file named {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 	 *
 	 * @param entityClass The mapped class. Cannot be {@code null} null.
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 	 */
 	@Deprecated
 	public MetadataSources addClass(Class entityClass) {
 		if ( entityClass == null ) {
 			throw new IllegalArgumentException( "The specified class cannot be null" );
 		}
 		LOG.debugf( "adding resource mappings from class convention : %s", entityClass.getName() );
 		final String mappingResourceName = entityClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		addResource( mappingResourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link java.io.File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addFile(java.io.File)
 	 */
 	public MetadataSources addFile(String path) {
 		addFile(
 				new Origin( SourceType.FILE, path ),
 				new File( path )
 		);
 		return this;
 	}
 
 	private void addFile(Origin origin, File file) {
 		LOG.tracef( "reading mappings from file : %s", origin.getName() );
 
 		if ( !file.exists() ) {
 			throw new MappingNotFoundException( origin );
 		}
 
 		xmlBindings.add( new FileXmlSource( origin, file ).doBind( mappingsBinder ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param file The reference to the XML file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addFile(File file) {
 		addFile(
 				new Origin( SourceType.FILE, file.getPath() ),
 				file
 		);
 		return this;
 	}
 
 	/**
 	 * See {@link #addCacheableFile(java.io.File)} for description
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link java.io.File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public MetadataSources addCacheableFile(String path) {
 		final Origin origin = new Origin( SourceType.FILE, path );
 		addCacheableFile( origin, new File( path ) );
 		return this;
 	}
 
 	private void addCacheableFile(Origin origin, File file) {
 		xmlBindings.add( new CacheableFileXmlSource( origin, file, false ).doBind( mappingsBinder ) );
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation of the DOM structure of a
 	 * particular mapping.  It is saved from a previous call as a file with the name {@code {xmlFile}.bin}
 	 * where {@code {xmlFile}} is the name of the original mapping file.
 	 * </p>
 	 * If a cached {@code {xmlFile}.bin} exists and is newer than {@code {xmlFile}}, the {@code {xmlFile}.bin}
 	 * file will be read directly. Otherwise {@code {xmlFile}} is read and then serialized to {@code {xmlFile}.bin} for
 	 * use the next time.
 	 *
 	 * @param file The cacheable mapping file to be added, {@code {xmlFile}} in above discussion.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addCacheableFile(File file) {
 		final Origin origin = new Origin( SourceType.FILE, file.getName() );
 		addCacheableFile( origin, file );
 		return this;
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(java.io.File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param file The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws org.hibernate.type.SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws java.io.FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public MetadataSources addCacheableFileStrictly(File file) throws SerializationException, FileNotFoundException {
 		final Origin origin = new Origin( SourceType.FILE, file.getAbsolutePath() );
 		xmlBindings.add( new CacheableFileXmlSource( origin, file, true ).doBind( mappingsBinder ) );
 		return this;
 	}
 
 	/**
 	 * Read metadata from an {@link java.io.InputStream} access
 	 *
 	 * @param xmlInputStreamAccess Access to an input stream containing a DOM.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addInputStream(InputStreamAccess xmlInputStreamAccess) {
 		final Origin origin = new Origin( SourceType.INPUT_STREAM, xmlInputStreamAccess.getStreamName() );
 		InputStream xmlInputStream = xmlInputStreamAccess.accessInputStream();
 		try {
 			xmlBindings.add( new InputStreamXmlSource( origin, xmlInputStream, false ).doBind( mappingsBinder ) );
 		}
 		finally {
 			try {
 				xmlInputStream.close();
 			}
 			catch (IOException e) {
 				LOG.debugf( "Unable to close InputStream obtained from InputStreamAccess : " + xmlInputStreamAccess.getStreamName() );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Read metadata from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addInputStream(InputStream xmlInputStream) {
 		final Origin origin = new Origin( SourceType.INPUT_STREAM, null );
 		xmlBindings.add( new InputStreamXmlSource( origin, xmlInputStream, false ).doBind( mappingsBinder ) );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a {@link java.net.URL}
 	 *
 	 * @param url The url for the mapping document to be read.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addURL(URL url) {
 		final String urlExternalForm = url.toExternalForm();
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		final Origin origin = new Origin( SourceType.URL, urlExternalForm );
 		xmlBindings.add( new UrlXmlSource( origin, url ).doBind( mappingsBinder ) );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a DOM {@link org.w3c.dom.Document}
 	 *
 	 * @param document The DOM document
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @deprecated since 5.0.  Use one of the other methods for passing mapping source(s).
 	 */
 	@Deprecated
 	public MetadataSources addDocument(Document document) {
 		final Origin origin = new Origin( SourceType.DOM, Origin.UNKNOWN_FILE_PATH );
 		xmlBindings.add( new JaxpSourceXmlSource( origin, new DOMSource( document ) ).doBind( mappingsBinder ) );
 		return this;
 	}
 
 	/**
 	 * Read all mappings from a jar file.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addJar(File jar) {
 		LOG.debugf( "Seeking mapping documents in jar file : %s", jar.getName() );
 		final Origin origin = new Origin( SourceType.JAR, jar.getAbsolutePath() );
 		try {
 			JarFile jarFile = new JarFile( jar );
 			try {
 				Enumeration jarEntries = jarFile.entries();
 				while ( jarEntries.hasMoreElements() ) {
 					final ZipEntry zipEntry = (ZipEntry) jarEntries.nextElement();
 					if ( zipEntry.getName().endsWith( ".hbm.xml" ) ) {
 						LOG.tracef( "found mapping document : %s", zipEntry.getName() );
 						xmlBindings.add(
 								new JarFileEntryXmlSource( origin, jarFile, zipEntry ).doBind( mappingsBinder )
 						);
 					}
 				}
 			}
 			finally {
 				try {
 					jarFile.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new MappingNotFoundException( e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public MetadataSources addDirectory(File dir) {
 		File[] files = dir.listFiles();
 		if ( files != null && files.length > 0 ) {
 			for ( File file : files ) {
 				if ( file.isDirectory() ) {
 					addDirectory( file );
 				}
 				else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 					addFile( file );
 				}
 			}
 		}
 		return this;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/cfgxml/internal/JaxbCfgProcessor.java b/hibernate-core/src/main/java/org/hibernate/boot/cfgxml/internal/JaxbCfgProcessor.java
index 262e803c3e..d28bc254fd 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/cfgxml/internal/JaxbCfgProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/cfgxml/internal/JaxbCfgProcessor.java
@@ -1,263 +1,265 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.cfgxml.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.ValidationEventHandler;
 import javax.xml.bind.ValidationEventLocator;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Namespace;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.EventReaderDelegate;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.cfg.spi.JaxbCfgHibernateConfiguration;
 import org.hibernate.boot.jaxb.internal.stax.LocalXmlResourceResolver;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.internal.util.config.ConfigurationException;
 import org.hibernate.internal.util.xml.XsdException;
 
 import org.jboss.logging.Logger;
 
 import org.xml.sax.SAXException;
 
 /**
  * @author Steve Ebersole
  */
 public class JaxbCfgProcessor {
 	private static final Logger log = Logger.getLogger( JaxbCfgProcessor.class );
 
 	public static final String HIBERNATE_CONFIGURATION_URI = "http://www.hibernate.org/xsd/orm/cfg";
 
 	private final ClassLoaderService classLoaderService;
+	private final LocalXmlResourceResolver xmlResourceResolver;
 
 	public JaxbCfgProcessor(ClassLoaderService classLoaderService) {
 		this.classLoaderService = classLoaderService;
+		this.xmlResourceResolver = new LocalXmlResourceResolver( classLoaderService );
 	}
 
 	public JaxbCfgHibernateConfiguration unmarshal(InputStream stream, Origin origin) {
 		try {
 			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			try {
 				return unmarshal( staxReader, origin );
 			}
 			finally {
 				try {
 					staxReader.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( XMLStreamException e ) {
 			throw new HibernateException( "Unable to create stax reader", e );
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
-		staxFactory.setXMLResolver( LocalXmlResourceResolver.INSTANCE );
+		staxFactory.setXMLResolver( xmlResourceResolver );
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "unchecked" })
 	private JaxbCfgHibernateConfiguration unmarshal(XMLEventReader staxEventReader, final Origin origin) {
 		XMLEvent event;
 		try {
 			event = staxEventReader.peek();
 			while ( event != null && !event.isStartElement() ) {
 				staxEventReader.nextEvent();
 				event = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Error accessing stax stream", e );
 		}
 
 		if ( event == null ) {
 			throw new HibernateException( "Could not locate root element" );
 		}
 
 		if ( !isNamespaced( event.asStartElement() ) ) {
 			// if the elements are not namespaced, wrap the reader in a reader which will namespace them as pulled.
 			log.debug( "cfg.xml document did not define namespaces; wrapping in custom event reader to introduce namespace information" );
 			staxEventReader = new NamespaceAddingEventReader( staxEventReader, HIBERNATE_CONFIGURATION_URI );
 		}
 
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( JaxbCfgHibernateConfiguration.class );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( schema() );
 			unmarshaller.setEventHandler( handler );
 			return (JaxbCfgHibernateConfiguration) unmarshaller.unmarshal( staxEventReader );
 		}
 		catch ( JAXBException e ) {
 			throw new ConfigurationException(
 					"Unable to perform unmarshalling at line number " + handler.getLineNumber()
 							+ " and column " + handler.getColumnNumber()
 							+ " in " + origin.getType().name() + " " + origin.getName()
 							+ ". Message: " + handler.getMessage(), e
 			);
 		}
 	}
 
 	private boolean isNamespaced(StartElement startElement) {
 		return ! "".equals( startElement.getName().getNamespaceURI() );
 	}
 
 	private Schema schema;
 
 	private Schema schema() {
 		if ( schema == null ) {
 			schema = resolveLocalSchema( "org/hibernate/hibernate-configuration-4.0.xsd" );
 		}
 		return schema;
 	}
 
 	private Schema resolveLocalSchema(String schemaName) {
 		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
 	}
 
 	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
 		URL url = classLoaderService.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					log.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
 		private int lineNumber;
 		private int columnNumber;
 		private String message;
 
 		@Override
 		public boolean handleEvent(ValidationEvent validationEvent) {
 			ValidationEventLocator locator = validationEvent.getLocator();
 			lineNumber = locator.getLineNumber();
 			columnNumber = locator.getColumnNumber();
 			message = validationEvent.getMessage();
 			return false;
 		}
 
 		public int getLineNumber() {
 			return lineNumber;
 		}
 
 		public int getColumnNumber() {
 			return columnNumber;
 		}
 
 		public String getMessage() {
 			return message;
 		}
 	}
 
 	public class NamespaceAddingEventReader extends EventReaderDelegate {
 		private final XMLEventFactory xmlEventFactory;
 		private final String namespaceUri;
 
 		public NamespaceAddingEventReader(XMLEventReader reader, String namespaceUri) {
 			this( reader, XMLEventFactory.newInstance(), namespaceUri );
 		}
 
 		public NamespaceAddingEventReader(XMLEventReader reader, XMLEventFactory xmlEventFactory, String namespaceUri) {
 			super( reader );
 			this.xmlEventFactory = xmlEventFactory;
 			this.namespaceUri = namespaceUri;
 		}
 
 		private StartElement withNamespace(StartElement startElement) {
 			// otherwise, wrap the start element event to provide a default namespace mapping
 			final List<Namespace> namespaces = new ArrayList<Namespace>();
 			namespaces.add( xmlEventFactory.createNamespace( "", namespaceUri ) );
 			Iterator<?> originalNamespaces = startElement.getNamespaces();
 			while ( originalNamespaces.hasNext() ) {
 				namespaces.add( (Namespace) originalNamespaces.next() );
 			}
 			return xmlEventFactory.createStartElement(
 					new QName( namespaceUri, startElement.getName().getLocalPart() ),
 					startElement.getAttributes(),
 					namespaces.iterator()
 			);
 		}
 
 		@Override
 		public XMLEvent nextEvent() throws XMLStreamException {
 			XMLEvent event = super.nextEvent();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			return event;
 		}
 
 		@Override
 		public XMLEvent peek() throws XMLStreamException {
 			XMLEvent event = super.peek();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			else {
 				return event;
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/ClassLoaderAccessImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/ClassLoaderAccessImpl.java
index b321c4591b..031402a721 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/ClassLoaderAccessImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/ClassLoaderAccessImpl.java
@@ -1,87 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.internal;
 
 import java.net.URL;
 
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.service.ServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * Standard implementation of ClassLoaderAccess
  *
  * @author Steve Ebersole
  */
 public class ClassLoaderAccessImpl implements ClassLoaderAccess {
 	private static final Logger log = Logger.getLogger( ClassLoaderAccessImpl.class );
 
 	private final ClassLoader jpaTempClassLoader;
 	private final ClassLoaderService classLoaderService;
 
 	public ClassLoaderAccessImpl(
 			ClassLoader jpaTempClassLoader,
 			ClassLoaderService classLoaderService) {
 		this.jpaTempClassLoader = jpaTempClassLoader;
 		this.classLoaderService = classLoaderService;
 	}
 
 	public ClassLoaderAccessImpl(ClassLoader tempClassLoader, ServiceRegistry serviceRegistry) {
 		this( tempClassLoader, serviceRegistry.getService( ClassLoaderService.class ) );
 	}
 
+	public ClassLoaderAccessImpl(ClassLoaderService classLoaderService) {
+		this( null, classLoaderService );
+	}
+
 	@Override
 	@SuppressWarnings("unchecked")
 	public Class<?> classForName(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "Name of class to load cannot be null" );
 		}
 
 		if ( isSafeClass( name ) ) {
 			return classLoaderService.classForName( name );
 		}
 		else {
 			log.debugf( "Not known whether passed class name [%s] is safe", name );
 			if ( jpaTempClassLoader == null ) {
 				log.debugf(
 						"No temp ClassLoader provided; using live ClassLoader " +
 								"for loading potentially unsafe class : %s",
 						name
 				);
 				return classLoaderService.classForName( name );
 			}
 			else {
 				log.debugf(
 						"Temp ClassLoader was provided, so we will use that : %s",
 						name
 				);
 				try {
 					return jpaTempClassLoader.loadClass( name );
 				}
 				catch (ClassNotFoundException e) {
 					throw new ClassLoadingException( name );
 				}
 			}
 		}
 	}
 
 	private boolean isSafeClass(String name) {
 		// classes in any of these packages are safe to load through the "live" ClassLoader
 		return name.startsWith( "java." )
 				|| name.startsWith( "javax." )
 				|| name.startsWith( "org.hibernate." );
 
 	}
 
 	@Override
 	public URL locateResource(String resourceName) {
 		return classLoaderService.locateResource( resourceName );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
index baeb3b88cc..23210ea916 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
@@ -1,906 +1,906 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.internal;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.persistence.AttributeConverter;
 import javax.persistence.SharedCacheMode;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.common.reflection.ClassLoaderDelegate;
 import org.hibernate.annotations.common.reflection.ClassLoadingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
 import org.hibernate.annotations.common.util.StandardClassLoaderDelegateImpl;
 import org.hibernate.boot.CacheRegionDefinition;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.archive.scan.internal.StandardScanOptions;
 import org.hibernate.boot.archive.scan.spi.ScanEnvironment;
 import org.hibernate.boot.archive.scan.spi.ScanOptions;
 import org.hibernate.boot.archive.scan.spi.Scanner;
 import org.hibernate.boot.archive.spi.ArchiveDescriptorFactory;
 import org.hibernate.boot.cfgxml.spi.CfgXmlAccessService;
 import org.hibernate.boot.cfgxml.spi.LoadedConfig;
 import org.hibernate.boot.cfgxml.spi.MappingReference;
 import org.hibernate.boot.model.IdGeneratorStrategyInterpreter;
 import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl;
 import org.hibernate.boot.model.relational.AuxiliaryDatabaseObject;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.selector.spi.StrategySelector;
 import org.hibernate.boot.spi.MappingDefaults;
 import org.hibernate.boot.spi.MetadataBuilderInitializer;
 import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.boot.spi.MetadataSourcesContributor;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.AttributeConverterDefinition;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.MetadataSourceType;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.config.spi.StandardConverters;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.CompositeCustomType;
 import org.hibernate.type.CustomType;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 import org.jboss.jandex.IndexView;
 
 import static org.hibernate.internal.log.DeprecationLogger.DEPRECATION_LOGGER;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataBuilderImpl implements MetadataBuilder, TypeContributions {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( MetadataBuilderImpl.class );
 
 	private final MetadataSources sources;
 	private final MetadataBuildingOptionsImpl options;
 
 	public MetadataBuilderImpl(MetadataSources sources) {
 		this(
 				sources,
 				getStandardServiceRegistry( sources.getServiceRegistry() )
 		);
 	}
 
 	private static StandardServiceRegistry getStandardServiceRegistry(ServiceRegistry serviceRegistry) {
 		if ( serviceRegistry == null ) {
 			throw new HibernateException( "ServiceRegistry passed to MetadataBuilder cannot be null" );
 		}
 
 		if ( StandardServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			return ( StandardServiceRegistry ) serviceRegistry;
 		}
 		else if ( BootstrapServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			log.debugf(
 					"ServiceRegistry passed to MetadataBuilder was a BootstrapServiceRegistry; this likely wont end well" +
 							"if attempt is made to build SessionFactory"
 			);
 			return new StandardServiceRegistryBuilder( (BootstrapServiceRegistry) serviceRegistry ).build();
 		}
 		else {
 			throw new HibernateException(
 					String.format(
 							"Unexpected type of ServiceRegistry [%s] encountered in attempt to build MetadataBuilder",
 							serviceRegistry.getClass().getName()
 					)
 			);
 		}
 	}
 
 	public MetadataBuilderImpl(MetadataSources sources, StandardServiceRegistry serviceRegistry) {
 		this.sources = sources;
 		this.options = new MetadataBuildingOptionsImpl( serviceRegistry );
 
 		for ( MetadataSourcesContributor contributor :
 				sources.getServiceRegistry()
 						.getService( ClassLoaderService.class )
 						.loadJavaServices( MetadataSourcesContributor.class ) ) {
 			contributor.contribute( sources );
 		}
 
 		// todo : not so sure this is needed anymore.
 		//		these should be set during the StandardServiceRegistryBuilder.configure call
 		applyCfgXmlValues( serviceRegistry.getService( CfgXmlAccessService.class ) );
 
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 		for ( MetadataBuilderInitializer contributor : classLoaderService.loadJavaServices( MetadataBuilderInitializer.class ) ) {
 			contributor.contribute( this, serviceRegistry );
 		}
 	}
 
 	private void applyCfgXmlValues(CfgXmlAccessService service) {
 		final LoadedConfig aggregatedConfig = service.getAggregatedConfig();
 		if ( aggregatedConfig == null ) {
 			return;
 		}
 
 		for ( CacheRegionDefinition cacheRegionDefinition : aggregatedConfig.getCacheRegionDefinitions() ) {
 			applyCacheRegionDefinition( cacheRegionDefinition );
 		}
 	}
 
 	@Override
 	public MetadataBuilder applyImplicitSchemaName(String implicitSchemaName) {
 		options.mappingDefaults.implicitSchemaName = implicitSchemaName;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyImplicitCatalogName(String implicitCatalogName) {
 		options.mappingDefaults.implicitCatalogName = implicitCatalogName;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyImplicitNamingStrategy(ImplicitNamingStrategy namingStrategy) {
 		this.options.implicitNamingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyPhysicalNamingStrategy(PhysicalNamingStrategy namingStrategy) {
 		this.options.physicalNamingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyReflectionManager(ReflectionManager reflectionManager) {
 		this.options.reflectionManager = reflectionManager;
 		this.options.reflectionManager.injectClassLoaderDelegate( this.options.getHcannClassLoaderDelegate() );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applySharedCacheMode(SharedCacheMode sharedCacheMode) {
 		this.options.sharedCacheMode = sharedCacheMode;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAccessType(AccessType implicitCacheAccessType) {
 		this.options.mappingDefaults.implicitCacheAccessType = implicitCacheAccessType;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyIndexView(IndexView jandexView) {
 		this.options.jandexView = jandexView;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyScanOptions(ScanOptions scanOptions) {
 		this.options.scanOptions = scanOptions;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyScanEnvironment(ScanEnvironment scanEnvironment) {
 		this.options.scanEnvironment = scanEnvironment;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyScanner(Scanner scanner) {
 		this.options.scannerSetting = scanner;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyArchiveDescriptorFactory(ArchiveDescriptorFactory factory) {
 		this.options.archiveDescriptorFactory = factory;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder enableExplicitDiscriminatorsForJoinedSubclassSupport(boolean supported) {
 		options.explicitDiscriminatorsForJoinedInheritanceSupported = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder enableImplicitDiscriminatorsForJoinedSubclassSupport(boolean supported) {
 		options.implicitDiscriminatorsForJoinedInheritanceSupported = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder enableImplicitForcingOfDiscriminatorsInSelect(boolean supported) {
 		options.implicitlyForceDiscriminatorInSelect = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder enableGlobalNationalizedCharacterDataSupport(boolean enabled) {
 		options.useNationalizedCharacterData = enabled;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyBasicType(BasicType type) {
 		options.basicTypeRegistrations.add( type );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyBasicType(UserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CustomType( type, keys ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyBasicType(CompositeUserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CompositeCustomType( type, keys ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyTypes(TypeContributor typeContributor) {
 		typeContributor.contribute( this, options.serviceRegistry );
 		return this;
 	}
 
 	@Override
 	public void contributeType(BasicType type) {
 		options.basicTypeRegistrations.add( type );
 	}
 
 	@Override
 	public void contributeType(UserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CustomType( type, keys ) );
 	}
 
 	@Override
 	public void contributeType(CompositeUserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CompositeCustomType( type, keys ) );
 	}
 
 	@Override
 	public MetadataBuilder applyCacheRegionDefinition(CacheRegionDefinition cacheRegionDefinition) {
 		if ( options.cacheRegionDefinitions == null ) {
 			options.cacheRegionDefinitions = new ArrayList<CacheRegionDefinition>();
 		}
 		options.cacheRegionDefinitions.add( cacheRegionDefinition );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyTempClassLoader(ClassLoader tempClassLoader) {
 		options.tempClassLoader = tempClassLoader;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applySourceProcessOrdering(MetadataSourceType... sourceTypes) {
 		options.sourceProcessOrdering.addAll( Arrays.asList( sourceTypes ) );
 		return this;
 	}
 
 	public MetadataBuilder allowSpecjSyntax() {
 		this.options.specjProprietarySyntaxEnabled = true;
 		return this;
 	}
 
 
 	@Override
 	public MetadataBuilder applySqlFunction(String functionName, SQLFunction function) {
 		if ( this.options.sqlFunctionMap == null ) {
 			this.options.sqlFunctionMap = new HashMap<String, SQLFunction>();
 		}
 		this.options.sqlFunctionMap.put( functionName, function );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAuxiliaryDatabaseObject(AuxiliaryDatabaseObject auxiliaryDatabaseObject) {
 		if ( this.options.auxiliaryDatabaseObjectList == null ) {
 			this.options.auxiliaryDatabaseObjectList = new ArrayList<AuxiliaryDatabaseObject>();
 		}
 		this.options.auxiliaryDatabaseObjectList.add( auxiliaryDatabaseObject );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAttributeConverter(AttributeConverterDefinition definition) {
 		this.options.addAttributeConverterDefinition( definition );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass) {
 		applyAttributeConverter( AttributeConverterDefinition.from( attributeConverterClass ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass, boolean autoApply) {
 		applyAttributeConverter( AttributeConverterDefinition.from( attributeConverterClass, autoApply ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAttributeConverter(AttributeConverter attributeConverter) {
 		applyAttributeConverter( AttributeConverterDefinition.from( attributeConverter ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyAttributeConverter(AttributeConverter attributeConverter, boolean autoApply) {
 		applyAttributeConverter( AttributeConverterDefinition.from( attributeConverter, autoApply ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder enableNewIdentifierGeneratorSupport(boolean enabled) {
 		if ( enabled ) {
 			this.options.idGenerationTypeInterpreter.disableLegacyFallback();
 		}
 		else {
 			this.options.idGenerationTypeInterpreter.enableLegacyFallback();
 		}
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder applyIdGenerationTypeInterpreter(IdGeneratorStrategyInterpreter interpreter) {
 		this.options.idGenerationTypeInterpreter.addInterpreterDelegate( interpreter );
 		return this;
 	}
 
 //	public MetadataBuilder with(PersistentAttributeMemberResolver resolver) {
 //		options.persistentAttributeMemberResolver = resolver;
 //		return this;
 //	}
 
 	@Override
 	public MetadataImpl build() {
 		final CfgXmlAccessService cfgXmlAccessService = options.serviceRegistry.getService( CfgXmlAccessService.class );
 		if ( cfgXmlAccessService.getAggregatedConfig() != null ) {
 			if ( cfgXmlAccessService.getAggregatedConfig().getMappingReferences() != null ) {
 				for ( MappingReference mappingReference : cfgXmlAccessService.getAggregatedConfig().getMappingReferences() ) {
 					mappingReference.apply( sources );
 				}
 			}
 		}
 
 		return MetadataBuildingProcess.build( sources, options );
 	}
 
 	public static class MappingDefaultsImpl implements MappingDefaults {
 		private String implicitSchemaName;
 		private String implicitCatalogName;
 		private boolean implicitlyQuoteIdentifiers;
 
 		private AccessType implicitCacheAccessType;
 
 		public MappingDefaultsImpl(StandardServiceRegistry serviceRegistry) {
 			final ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			this.implicitSchemaName = configService.getSetting(
 					AvailableSettings.DEFAULT_SCHEMA,
 					StandardConverters.STRING,
 					null
 			);
 
 			this.implicitCatalogName = configService.getSetting(
 					AvailableSettings.DEFAULT_CATALOG,
 					StandardConverters.STRING,
 					null
 			);
 
 			this.implicitlyQuoteIdentifiers = configService.getSetting(
 					AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			this.implicitCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							return AccessType.fromExternalName( value.toString() );
 						}
 					}
 			);
 		}
 
 		@Override
 		public String getImplicitSchemaName() {
 			return implicitSchemaName;
 		}
 
 		@Override
 		public String getImplicitCatalogName() {
 			return implicitCatalogName;
 		}
 
 		@Override
 		public boolean shouldImplicitlyQuoteIdentifiers() {
 			return implicitlyQuoteIdentifiers;
 		}
 
 		@Override
 		public String getImplicitIdColumnName() {
 			return DEFAULT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitTenantIdColumnName() {
 			return DEFAULT_TENANT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitDiscriminatorColumnName() {
 			return DEFAULT_DISCRIMINATOR_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitPackageName() {
 			return null;
 		}
 
 		@Override
 		public boolean isAutoImportEnabled() {
 			return true;
 		}
 
 		@Override
 		public String getImplicitCascadeStyleName() {
 			return DEFAULT_CASCADE_NAME;
 		}
 
 		@Override
 		public String getImplicitPropertyAccessorName() {
 			return DEFAULT_PROPERTY_ACCESS_NAME;
 		}
 
 		@Override
 		public boolean areEntitiesImplicitlyLazy() {
 			// for now, just hard-code
 			return false;
 		}
 
 		@Override
 		public boolean areCollectionsImplicitlyLazy() {
 			// for now, just hard-code
 			return true;
 		}
 
 		@Override
 		public AccessType getImplicitCacheAccessType() {
 			return implicitCacheAccessType;
 		}
 	}
 
 	public static class MetadataBuildingOptionsImpl implements MetadataBuildingOptions {
 		private final StandardServiceRegistry serviceRegistry;
 		private final MappingDefaultsImpl mappingDefaults;
 
 		private ArrayList<BasicType> basicTypeRegistrations = new ArrayList<BasicType>();
 
 		private IndexView jandexView;
 		private ClassLoader tempClassLoader;
 
 		private ScanOptions scanOptions;
 		private ScanEnvironment scanEnvironment;
 		private Object scannerSetting;
 		private ArchiveDescriptorFactory archiveDescriptorFactory;
 
 		private ImplicitNamingStrategy implicitNamingStrategy;
 		private PhysicalNamingStrategy physicalNamingStrategy;
 
 		private ReflectionManager reflectionManager;
 		private ClassLoaderDelegate hcannClassLoaderDelegate;
 
 		private SharedCacheMode sharedCacheMode;
 		private AccessType defaultCacheAccessType;
 		private MultiTenancyStrategy multiTenancyStrategy;
 		private ArrayList<CacheRegionDefinition> cacheRegionDefinitions;
 		private boolean explicitDiscriminatorsForJoinedInheritanceSupported;
 		private boolean implicitDiscriminatorsForJoinedInheritanceSupported;
 		private boolean implicitlyForceDiscriminatorInSelect;
 		private boolean useNationalizedCharacterData;
 		private boolean specjProprietarySyntaxEnabled;
 		private ArrayList<MetadataSourceType> sourceProcessOrdering;
 
 		private HashMap<String,SQLFunction> sqlFunctionMap;
 		private ArrayList<AuxiliaryDatabaseObject> auxiliaryDatabaseObjectList;
 		private HashMap<Class,AttributeConverterDefinition> attributeConverterDefinitionsByClass;
 
 		private IdGeneratorInterpreterImpl idGenerationTypeInterpreter = new IdGeneratorInterpreterImpl();
 
 //		private PersistentAttributeMemberResolver persistentAttributeMemberResolver =
 //				StandardPersistentAttributeMemberResolver.INSTANCE;
 
 		public MetadataBuildingOptionsImpl(StandardServiceRegistry serviceRegistry) {
 			this.serviceRegistry = serviceRegistry;
 
 			final StrategySelector strategySelector = serviceRegistry.getService( StrategySelector.class );
 			final ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			this.mappingDefaults = new MappingDefaultsImpl( serviceRegistry );
 
 //			jandexView = (IndexView) configService.getSettings().get( AvailableSettings.JANDEX_INDEX );
 
 			scanOptions = new StandardScanOptions(
 					(String) configService.getSettings().get( AvailableSettings.SCANNER_DISCOVERY ),
 					false
 			);
 			// ScanEnvironment must be set explicitly
 			scannerSetting = configService.getSettings().get( AvailableSettings.SCANNER );
 			if ( scannerSetting == null ) {
 				scannerSetting = configService.getSettings().get( AvailableSettings.SCANNER_DEPRECATED );
 				if ( scannerSetting != null ) {
 					DEPRECATION_LOGGER.logDeprecatedScannerSetting();
 				}
 			}
 			archiveDescriptorFactory = strategySelector.resolveStrategy(
 					ArchiveDescriptorFactory.class,
 					configService.getSettings().get( AvailableSettings.SCANNER_ARCHIVE_INTERPRETER )
 			);
 
 			multiTenancyStrategy =  MultiTenancyStrategy.determineMultiTenancyStrategy( configService.getSettings() );
 
 			implicitDiscriminatorsForJoinedInheritanceSupported = configService.getSetting(
 					AvailableSettings.IMPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			explicitDiscriminatorsForJoinedInheritanceSupported = !configService.getSetting(
 					AvailableSettings.IGNORE_EXPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			implicitlyForceDiscriminatorInSelect = configService.getSetting(
 					AvailableSettings.FORCE_DISCRIMINATOR_IN_SELECTS_BY_DEFAULT,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			sharedCacheMode = configService.getSetting(
 					"javax.persistence.sharedCache.mode",
 					new ConfigurationService.Converter<SharedCacheMode>() {
 						@Override
 						public SharedCacheMode convert(Object value) {
 							if ( value == null ) {
 								return null;
 							}
 
 							if ( SharedCacheMode.class.isInstance( value ) ) {
 								return (SharedCacheMode) value;
 							}
 
 							return SharedCacheMode.valueOf( value.toString() );
 						}
 					},
 					SharedCacheMode.UNSPECIFIED
 			);
 
 			defaultCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							if ( value == null ) {
 								return null;
 							}
 
 							if ( CacheConcurrencyStrategy.class.isInstance( value ) ) {
 								return ( (CacheConcurrencyStrategy) value ).toAccessType();
 							}
 
 							if ( AccessType.class.isInstance( value ) ) {
 								return (AccessType) value;
 							}
 
 							return AccessType.fromExternalName( value.toString() );
 						}
 					},
 					// by default, see if the defined RegionFactory (if one) defines a default
 					serviceRegistry.getService( RegionFactory.class ) == null
 							? null
 							: serviceRegistry.getService( RegionFactory.class ).getDefaultAccessType()
 			);
 
 			specjProprietarySyntaxEnabled = configService.getSetting(
 					"hibernate.enable_specj_proprietary_syntax",
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			implicitNamingStrategy = strategySelector.resolveDefaultableStrategy(
 					ImplicitNamingStrategy.class,
 					configService.getSettings().get( AvailableSettings.IMPLICIT_NAMING_STRATEGY ),
 					ImplicitNamingStrategyLegacyJpaImpl.INSTANCE
 			);
 
 			physicalNamingStrategy = strategySelector.resolveDefaultableStrategy(
 					PhysicalNamingStrategy.class,
 					configService.getSettings().get( AvailableSettings.PHYSICAL_NAMING_STRATEGY ),
 					PhysicalNamingStrategyStandardImpl.INSTANCE
 			);
 
 			sourceProcessOrdering = resolveInitialSourceProcessOrdering( configService );
 
 			final boolean useNewIdentifierGenerators = configService.getSetting(
 					AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 			if ( useNewIdentifierGenerators ) {
 				idGenerationTypeInterpreter.disableLegacyFallback();
 			}
 			else {
 				idGenerationTypeInterpreter.enableLegacyFallback();
 			}
 
 			reflectionManager = generateDefaultReflectionManager();
 		}
 
 		private ArrayList<MetadataSourceType> resolveInitialSourceProcessOrdering(ConfigurationService configService) {
 			final ArrayList<MetadataSourceType> initialSelections = new ArrayList<MetadataSourceType>();
 
 			final String sourceProcessOrderingSetting = configService.getSetting(
 					AvailableSettings.ARTIFACT_PROCESSING_ORDER,
 					StandardConverters.STRING
 			);
 			if ( sourceProcessOrderingSetting != null ) {
 				final String[] orderChoices = StringHelper.split( ",; ", sourceProcessOrderingSetting, false );
 				initialSelections.addAll( CollectionHelper.<MetadataSourceType>arrayList( orderChoices.length ) );
 				for ( String orderChoice : orderChoices ) {
 					initialSelections.add( MetadataSourceType.parsePrecedence( orderChoice ) );
 				}
 			}
 			if ( initialSelections.isEmpty() ) {
 				initialSelections.add( MetadataSourceType.HBM );
 				initialSelections.add( MetadataSourceType.CLASS );
 			}
 
 			return initialSelections;
 		}
 
 		private ReflectionManager generateDefaultReflectionManager() {
 			final JavaReflectionManager reflectionManager = new JavaReflectionManager();
-			reflectionManager.setMetadataProvider( new JPAMetadataProvider() );
+			reflectionManager.setMetadataProvider( new JPAMetadataProvider( this ) );
 			reflectionManager.injectClassLoaderDelegate( getHcannClassLoaderDelegate() );
 			return reflectionManager;
 		}
 
 		public ClassLoaderDelegate getHcannClassLoaderDelegate() {
 			if ( hcannClassLoaderDelegate == null ) {
 				hcannClassLoaderDelegate = new ClassLoaderDelegate() {
 					private final  ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
 
 					@Override
 					public <T> Class<T> classForName(String className) throws ClassLoadingException {
 						try {
 							return classLoaderService.classForName( className );
 						}
 						catch (org.hibernate.boot.registry.classloading.spi.ClassLoadingException e) {
 							return StandardClassLoaderDelegateImpl.INSTANCE.classForName( className );
 						}
 					}
 				};
 			}
 			return hcannClassLoaderDelegate;
 		}
 
 		@Override
 		public StandardServiceRegistry getServiceRegistry() {
 			return serviceRegistry;
 		}
 
 		@Override
 		public MappingDefaults getMappingDefaults() {
 			return mappingDefaults;
 		}
 
 		@Override
 		public List<BasicType> getBasicTypeRegistrations() {
 			return basicTypeRegistrations;
 		}
 
 		@Override
 		public IndexView getJandexView() {
 			return jandexView;
 		}
 
 		@Override
 		public ScanOptions getScanOptions() {
 			return scanOptions;
 		}
 
 		@Override
 		public ScanEnvironment getScanEnvironment() {
 			return scanEnvironment;
 		}
 
 		@Override
 		public Object getScanner() {
 			return scannerSetting;
 		}
 
 		@Override
 		public ArchiveDescriptorFactory getArchiveDescriptorFactory() {
 			return archiveDescriptorFactory;
 		}
 
 		@Override
 		public ClassLoader getTempClassLoader() {
 			return tempClassLoader;
 		}
 
 		@Override
 		public ImplicitNamingStrategy getImplicitNamingStrategy() {
 			return implicitNamingStrategy;
 		}
 
 		@Override
 		public PhysicalNamingStrategy getPhysicalNamingStrategy() {
 			return physicalNamingStrategy;
 		}
 
 		@Override
 		public ReflectionManager getReflectionManager() {
 			return reflectionManager;
 		}
 
 		@Override
 		public SharedCacheMode getSharedCacheMode() {
 			return sharedCacheMode;
 		}
 
 		@Override
 		public AccessType getImplicitCacheAccessType() {
 			return defaultCacheAccessType;
 		}
 
 		@Override
 		public MultiTenancyStrategy getMultiTenancyStrategy() {
 			return multiTenancyStrategy;
 		}
 
 		@Override
 		public IdGeneratorStrategyInterpreter getIdGenerationTypeInterpreter() {
 			return idGenerationTypeInterpreter;
 		}
 
 		@Override
 		public List<CacheRegionDefinition> getCacheRegionDefinitions() {
 			return cacheRegionDefinitions;
 		}
 
 		@Override
 		public boolean ignoreExplicitDiscriminatorsForJoinedInheritance() {
 			return !explicitDiscriminatorsForJoinedInheritanceSupported;
 		}
 
 		@Override
 		public boolean createImplicitDiscriminatorsForJoinedInheritance() {
 			return implicitDiscriminatorsForJoinedInheritanceSupported;
 		}
 
 		@Override
 		public boolean shouldImplicitlyForceDiscriminatorInSelect() {
 			return implicitlyForceDiscriminatorInSelect;
 		}
 
 		@Override
 		public boolean useNationalizedCharacterData() {
 			return useNationalizedCharacterData;
 		}
 
 		@Override
 		public boolean isSpecjProprietarySyntaxEnabled() {
 			return specjProprietarySyntaxEnabled;
 		}
 
 		@Override
 		public List<MetadataSourceType> getSourceProcessOrdering() {
 			return sourceProcessOrdering;
 		}
 
 		@Override
 		public Map<String, SQLFunction> getSqlFunctions() {
 			return sqlFunctionMap == null ? Collections.<String, SQLFunction>emptyMap() : sqlFunctionMap;
 		}
 
 		@Override
 		public List<AuxiliaryDatabaseObject> getAuxiliaryDatabaseObjectList() {
 			return auxiliaryDatabaseObjectList == null
 					? Collections.<AuxiliaryDatabaseObject>emptyList()
 					: auxiliaryDatabaseObjectList;
 		}
 
 		@Override
 		public List<AttributeConverterDefinition> getAttributeConverters() {
 			return attributeConverterDefinitionsByClass == null
 					? Collections.<AttributeConverterDefinition>emptyList()
 					: new ArrayList<AttributeConverterDefinition>( attributeConverterDefinitionsByClass.values() );
 		}
 
 		public void addAttributeConverterDefinition(AttributeConverterDefinition definition) {
 			if ( this.attributeConverterDefinitionsByClass == null ) {
 				this.attributeConverterDefinitionsByClass = new HashMap<Class, AttributeConverterDefinition>();
 			}
 
 			final Object old = this.attributeConverterDefinitionsByClass.put( definition.getAttributeConverter().getClass(), definition );
 
 			if ( old != null ) {
 				throw new AssertionFailure(
 						String.format(
 								"AttributeConverter class [%s] registered multiple times",
 								definition.getAttributeConverter().getClass()
 						)
 				);
 			}
 		}
 
 		public static interface JpaOrmXmlPersistenceUnitDefaults {
 			public String getDefaultSchemaName();
 			public String getDefaultCatalogName();
 			public boolean shouldImplicitlyQuoteIdentifiers();
 		}
 
 		/**
 		 * Yuck.  This is needed because JPA lets users define "global building options"
 		 * in {@code orm.xml} mappings.  Forget that there are generally multiple
 		 * {@code orm.xml} mappings if using XML approach...  Ugh
 		 */
 		public void apply(JpaOrmXmlPersistenceUnitDefaults jpaOrmXmlPersistenceUnitDefaults) {
 			if ( !mappingDefaults.shouldImplicitlyQuoteIdentifiers() ) {
 				mappingDefaults.implicitlyQuoteIdentifiers = jpaOrmXmlPersistenceUnitDefaults.shouldImplicitlyQuoteIdentifiers();
 			}
 
 			if ( mappingDefaults.getImplicitCatalogName() == null ) {
 				mappingDefaults.implicitCatalogName = StringHelper.nullIfEmpty(
 						jpaOrmXmlPersistenceUnitDefaults.getDefaultCatalogName()
 				);
 			}
 
 			if ( mappingDefaults.getImplicitSchemaName() == null ) {
 				mappingDefaults.implicitSchemaName = StringHelper.nullIfEmpty(
 						jpaOrmXmlPersistenceUnitDefaults.getDefaultSchemaName()
 				);
 			}
 		}
 
 		//		@Override
 //		public PersistentAttributeMemberResolver getPersistentAttributeMemberResolver() {
 //			return persistentAttributeMemberResolver;
 //		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
index b89c4780b1..601c1dc0e4 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
@@ -1,512 +1,512 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.internal;
 
 import java.lang.reflect.Constructor;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 import javax.persistence.Converter;
 
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.archive.internal.StandardArchiveDescriptorFactory;
 import org.hibernate.boot.archive.scan.internal.StandardScanner;
 import org.hibernate.boot.archive.scan.spi.ClassDescriptor;
 import org.hibernate.boot.archive.scan.spi.JandexInitializer;
 import org.hibernate.boot.archive.scan.spi.MappingFileDescriptor;
 import org.hibernate.boot.archive.scan.spi.PackageDescriptor;
 import org.hibernate.boot.archive.scan.spi.ScanParameters;
 import org.hibernate.boot.archive.scan.spi.ScanResult;
 import org.hibernate.boot.archive.scan.spi.Scanner;
 import org.hibernate.boot.archive.spi.ArchiveDescriptorFactory;
 import org.hibernate.boot.internal.DeploymentResourcesInterpreter.DeploymentResources;
 import org.hibernate.boot.internal.MetadataBuilderImpl.MetadataBuildingOptionsImpl;
 import org.hibernate.boot.jaxb.internal.MappingBinder;
 import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.model.source.internal.annotations.AnnotationMetadataSourceProcessorImpl;
 import org.hibernate.boot.model.source.internal.hbm.EntityHierarchyBuilder;
 import org.hibernate.boot.model.source.internal.hbm.EntityHierarchySourceImpl;
 import org.hibernate.boot.model.source.internal.hbm.HbmMetadataSourceProcessorImpl;
 import org.hibernate.boot.model.source.internal.hbm.MappingDocument;
 import org.hibernate.boot.model.source.internal.hbm.ModelBinder;
 import org.hibernate.boot.model.source.spi.MetadataSourceProcessor;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.AdditionalJaxbMappingProducer;
 import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.boot.spi.MetadataContributor;
 import org.hibernate.cfg.AttributeConverterDefinition;
 import org.hibernate.cfg.MetadataSourceType;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.type.BasicTypeRegistry;
 import org.hibernate.type.TypeFactory;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 import org.jboss.jandex.IndexView;
 import org.jboss.logging.Logger;
 
 /**
  * Represents the process of building a Metadata object.  The main entry point is the
  * static {@link #build}
  *
  * @author Steve Ebersole
  */
 public class MetadataBuildingProcess {
 	private static final Logger log = Logger.getLogger( MetadataBuildingProcess.class );
 
 	public static MetadataImpl build(
 			final MetadataSources sources,
 			final MetadataBuildingOptionsImpl options) {
 		final ClassLoaderService classLoaderService = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		final ClassLoaderAccess classLoaderAccess = new ClassLoaderAccessImpl(
 				options.getTempClassLoader(),
 				classLoaderService
 		);
 
 //		final JandexInitManager jandexInitializer = buildJandexInitializer( options, classLoaderAccess );
 		
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// scanning - Jandex initialization and source discovery
 		if ( options.getScanEnvironment() != null ) {
 			final Scanner scanner = buildScanner( options, classLoaderAccess );
 			final ScanResult scanResult = scanner.scan(
 					options.getScanEnvironment(),
 					options.getScanOptions(),
 					new ScanParameters() {
 						@Override
 						public JandexInitializer getJandexInitializer() {
 //							return jandexInitializer;
 							return null;
 						}
 					}
 			);
 
 			// Add to the MetadataSources any classes/packages/mappings discovered during scanning
 			addScanResultsToSources( sources, options, scanResult );
 		}
 
 //		// todo : add options.getScanEnvironment().getExplicitlyListedClassNames() to jandex?
 //		//		^^ - another option is to make sure that they are added to sources
 //
 //		if ( !jandexInitializer.wasIndexSupplied() ) {
 //			// If the Jandex Index(View) was supplied, we consider that supplied
 //			// one "complete".
 //			// Here though we were NOT supplied an index; in this case we want to
 //			// additionally ensure that any-and-all "known" classes are added to
 //			// the index we are building
 //			sources.indexKnownClasses( jandexInitializer );
 //		}
 		
 		// It's necessary to delay the binding of XML resources until now.  ClassLoaderAccess is needed for
 		// reflection, etc.
 //		sources.buildBindResults( classLoaderAccess );
 
 //		final IndexView jandexView = augmentJandexFromMappings( jandexInitializer.buildIndex(), sources, options );
 		final IndexView jandexView = options.getJandexView();
 
 		final BasicTypeRegistry basicTypeRegistry = handleTypes( options );
 
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// prep to start handling binding in earnest
 
 //		final JandexAccessImpl jandexAccess = new JandexAccessImpl(
 //				jandexView,
 //				classLoaderAccess
 //
 //		);
 		final InFlightMetadataCollectorImpl metadataCollector = new InFlightMetadataCollectorImpl(
 				options,
 				sources,
 				new TypeResolver( basicTypeRegistry, new TypeFactory() )
 		);
 
 		final MetadataBuildingContextRootImpl rootMetadataBuildingContext = new MetadataBuildingContextRootImpl(
 				options,
 				classLoaderAccess,
 				metadataCollector
 		);
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Set up the processors and start binding
 		//		NOTE : this becomes even more simplified after we move purely
 		// 		to unified model
 
 		final MetadataSourceProcessor processor = new MetadataSourceProcessor() {
 			private final HbmMetadataSourceProcessorImpl hbmProcessor = new HbmMetadataSourceProcessorImpl(
 					sources,
 					rootMetadataBuildingContext
 			);
 
 			private final AnnotationMetadataSourceProcessorImpl annotationProcessor = new AnnotationMetadataSourceProcessorImpl(
 					sources,
 					rootMetadataBuildingContext,
 					jandexView
 			);
 
 			@Override
 			public void prepare() {
 				hbmProcessor.prepare();
 				annotationProcessor.prepare();
 			}
 
 			@Override
 			public void processTypeDefinitions() {
 				hbmProcessor.processTypeDefinitions();
 				annotationProcessor.processTypeDefinitions();
 			}
 
 			@Override
 			public void processQueryRenames() {
 				hbmProcessor.processQueryRenames();
 				annotationProcessor.processQueryRenames();
 			}
 
 			@Override
 			public void processNamedQueries() {
 				hbmProcessor.processNamedQueries();
 				annotationProcessor.processNamedQueries();
 			}
 
 			@Override
 			public void processAuxiliaryDatabaseObjectDefinitions() {
 				hbmProcessor.processAuxiliaryDatabaseObjectDefinitions();
 				annotationProcessor.processAuxiliaryDatabaseObjectDefinitions();
 			}
 
 			@Override
 			public void processIdentifierGenerators() {
 				hbmProcessor.processIdentifierGenerators();
 				annotationProcessor.processIdentifierGenerators();
 			}
 
 			@Override
 			public void processFilterDefinitions() {
 				hbmProcessor.processFilterDefinitions();
 				annotationProcessor.processFilterDefinitions();
 			}
 
 			@Override
 			public void processFetchProfiles() {
 				hbmProcessor.processFetchProfiles();
 				annotationProcessor.processFetchProfiles();
 			}
 
 			@Override
 			public void prepareForEntityHierarchyProcessing() {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.prepareForEntityHierarchyProcessing();
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.prepareForEntityHierarchyProcessing();
 					}
 				}
 			}
 
 			@Override
 			public void processEntityHierarchies(Set<String> processedEntityNames) {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.processEntityHierarchies( processedEntityNames );
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.processEntityHierarchies( processedEntityNames );
 					}
 				}
 			}
 
 			@Override
 			public void postProcessEntityHierarchies() {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.postProcessEntityHierarchies();
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.postProcessEntityHierarchies();
 					}
 				}
 			}
 
 			@Override
 			public void processResultSetMappings() {
 				hbmProcessor.processResultSetMappings();
 				annotationProcessor.processResultSetMappings();
 			}
 
 			@Override
 			public void finishUp() {
 				hbmProcessor.finishUp();
 				annotationProcessor.finishUp();
 			}
 		};
 
 		processor.prepare();
 
 		processor.processTypeDefinitions();
 		processor.processQueryRenames();
 		processor.processAuxiliaryDatabaseObjectDefinitions();
 
 		processor.processIdentifierGenerators();
 		processor.processFilterDefinitions();
 		processor.processFetchProfiles();
 
 		final Set<String> processedEntityNames = new HashSet<String>();
 		processor.prepareForEntityHierarchyProcessing();
 		processor.processEntityHierarchies( processedEntityNames );
 		processor.postProcessEntityHierarchies();
 
 		processor.processResultSetMappings();
 		processor.processNamedQueries();
 
 		processor.finishUp();
 
 		for ( MetadataContributor contributor : classLoaderService.loadJavaServices( MetadataContributor.class ) ) {
 			log.tracef( "Calling MetadataContributor : %s", contributor );
 			contributor.contribute( metadataCollector, jandexView );
 		}
 
 		metadataCollector.processSecondPasses( rootMetadataBuildingContext );
 
 		Iterable<AdditionalJaxbMappingProducer> producers = classLoaderService.loadJavaServices( AdditionalJaxbMappingProducer.class );
 		if ( producers != null ) {
 			final EntityHierarchyBuilder hierarchyBuilder = new EntityHierarchyBuilder();
 //			final MappingBinder mappingBinder = new MappingBinder( true );
 			// We need to disable validation here.  It seems Envers is not producing valid (according to schema) XML
-			final MappingBinder mappingBinder = new MappingBinder( false );
+			final MappingBinder mappingBinder = new MappingBinder( classLoaderService, false );
 			for ( AdditionalJaxbMappingProducer producer : producers ) {
 				log.tracef( "Calling AdditionalJaxbMappingProducer : %s", producer );
 				Collection<MappingDocument> additionalMappings = producer.produceAdditionalMappings(
 						metadataCollector,
 						jandexView,
 						mappingBinder,
 						rootMetadataBuildingContext
 				);
 				for ( MappingDocument mappingDocument : additionalMappings ) {
 					hierarchyBuilder.indexMappingDocument( mappingDocument );
 				}
 			}
 
 			ModelBinder binder = ModelBinder.prepare( rootMetadataBuildingContext );
 			for ( EntityHierarchySourceImpl entityHierarchySource : hierarchyBuilder.buildHierarchies() ) {
 				binder.bindEntityHierarchy( entityHierarchySource );
 			}
 		}
 
 		return metadataCollector.buildMetadataInstance( rootMetadataBuildingContext );
 	}
 
 //	private static JandexInitManager buildJandexInitializer(
 //			MetadataBuildingOptions options,
 //			ClassLoaderAccess classLoaderAccess) {
 //		final boolean autoIndexMembers = ConfigurationHelper.getBoolean(
 //				org.hibernate.cfg.AvailableSettings.ENABLE_AUTO_INDEX_MEMBER_TYPES,
 //				options.getServiceRegistry().getService( ConfigurationService.class ).getSettings(),
 //				false
 //		);
 //
 //		return new JandexInitManager( options.getJandexView(), classLoaderAccess, autoIndexMembers );
 //	}
 
 	private static final Class[] SINGLE_ARG = new Class[] { ArchiveDescriptorFactory.class };
 
 	private static Scanner buildScanner(MetadataBuildingOptions options, ClassLoaderAccess classLoaderAccess) {
 		final Object scannerSetting = options.getScanner();
 		final ArchiveDescriptorFactory archiveDescriptorFactory = options.getArchiveDescriptorFactory();
 
 		if ( scannerSetting == null ) {
 			// No custom Scanner specified, use the StandardScanner
 			if ( archiveDescriptorFactory == null ) {
 				return new StandardScanner();
 			}
 			else {
 				return new StandardScanner( archiveDescriptorFactory );
 			}
 		}
 		else {
 			if ( Scanner.class.isInstance( scannerSetting ) ) {
 				if ( archiveDescriptorFactory != null ) {
 					throw new IllegalStateException(
 							"A Scanner instance and an ArchiveDescriptorFactory were both specified; please " +
 									"specify one or the other, or if you need to supply both, Scanner class to use " +
 									"(assuming it has a constructor accepting a ArchiveDescriptorFactory).  " +
 									"Alternatively, just pass the ArchiveDescriptorFactory during your own " +
 									"Scanner constructor assuming it is statically known."
 					);
 				}
 				return (Scanner) scannerSetting;
 			}
 
 			final Class<? extends  Scanner> scannerImplClass;
 			if ( Class.class.isInstance( scannerSetting ) ) {
 				scannerImplClass = (Class<? extends Scanner>) scannerSetting;
 			}
 			else {
 				scannerImplClass = classLoaderAccess.classForName( scannerSetting.toString() );
 			}
 
 
 			if ( archiveDescriptorFactory != null ) {
 				// find the single-arg constructor - its an error if none exists
 				try {
 					final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor( SINGLE_ARG );
 					try {
 						return constructor.newInstance( archiveDescriptorFactory );
 					}
 					catch (Exception e) {
 						throw new IllegalStateException(
 								"Error trying to instantiate custom specified Scanner [" +
 										scannerImplClass.getName() + "]",
 								e
 						);
 					}
 				}
 				catch (NoSuchMethodException e) {
 					throw new IllegalArgumentException(
 							"Configuration named a custom Scanner and a custom ArchiveDescriptorFactory, but " +
 									"Scanner impl did not define a constructor accepting ArchiveDescriptorFactory"
 					);
 				}
 			}
 			else {
 				// could be either ctor form...
 				// find the single-arg constructor - its an error if none exists
 				try {
 					final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor( SINGLE_ARG );
 					try {
 						return constructor.newInstance( StandardArchiveDescriptorFactory.INSTANCE );
 					}
 					catch (Exception e) {
 						throw new IllegalStateException(
 								"Error trying to instantiate custom specified Scanner [" +
 										scannerImplClass.getName() + "]",
 								e
 						);
 					}
 				}
 				catch (NoSuchMethodException e) {
 					try {
 						final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor();
 						try {
 							return constructor.newInstance();
 						}
 						catch (Exception e2) {
 							throw new IllegalStateException(
 									"Error trying to instantiate custom specified Scanner [" +
 											scannerImplClass.getName() + "]",
 									e2
 							);
 						}
 					}
 					catch (NoSuchMethodException ignore) {
 						throw new IllegalArgumentException(
 								"Configuration named a custom Scanner, but we were unable to locate " +
 										"an appropriate constructor"
 						);
 					}
 				}
 			}
 		}
 	}
 
 	private static void addScanResultsToSources(
 			MetadataSources sources,
 			MetadataBuildingOptionsImpl options,
 			ScanResult scanResult) {
 		final ClassLoaderService cls = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		DeploymentResources deploymentResources = DeploymentResourcesInterpreter.INSTANCE.buildDeploymentResources(
 				options.getScanEnvironment(),
 				scanResult,
 				options.getServiceRegistry()
 		);
 
 		for ( ClassDescriptor classDescriptor : deploymentResources.getClassDescriptors() ) {
 			final String className = classDescriptor.getName();
 
 			// todo : leverage Jandex calls after we fully integrate Jandex...
 			try {
 				final Class classRef = cls.classForName( className );
 
 				// logic here assumes an entity is not also a converter...
 				final Converter converter = (Converter) classRef.getAnnotation( Converter.class );
 				if ( converter != null ) {
 					//noinspection unchecked
 					options.addAttributeConverterDefinition(
 							AttributeConverterDefinition.from( classRef, converter.autoApply() )
 					);
 				}
 				else {
 					sources.addAnnotatedClass( classRef );
 				}
 			}
 			catch (ClassLoadingException e) {
 				// Not really sure what this means...
 				sources.addAnnotatedClassName( className );
 			}
 		}
 
 		for ( PackageDescriptor packageDescriptor : deploymentResources.getPackageDescriptors() ) {
 			sources.addPackage( packageDescriptor.getName() );
 		}
 
 		for ( MappingFileDescriptor mappingFileDescriptor : deploymentResources.getMappingFileDescriptors() ) {
 			sources.addInputStream( mappingFileDescriptor.getStreamAccess() );
 		}
 	}
 
 
 	private static BasicTypeRegistry handleTypes(MetadataBuildingOptions options) {
 		final ClassLoaderService classLoaderService = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		// ultimately this needs to change a little bit to account for HHH-7792
 		final BasicTypeRegistry basicTypeRegistry = new BasicTypeRegistry();
 
 		final TypeContributions typeContributions = new TypeContributions() {
 			@Override
 			public void contributeType(org.hibernate.type.BasicType type) {
 				basicTypeRegistry.register( type );
 			}
 
 			@Override
 			public void contributeType(UserType type, String[] keys) {
 				basicTypeRegistry.register( type, keys );
 			}
 
 			@Override
 			public void contributeType(CompositeUserType type, String[] keys) {
 				basicTypeRegistry.register( type, keys );
 			}
 		};
 
 		// add Dialect contributed types
 		final Dialect dialect = options.getServiceRegistry().getService( JdbcServices.class ).getDialect();
 		dialect.contributeTypes( typeContributions, options.getServiceRegistry() );
 
 		// add TypeContributor contributed types.
 		for ( TypeContributor contributor : classLoaderService.loadJavaServices( TypeContributor.class ) ) {
 			contributor.contribute( typeContributions, options.getServiceRegistry() );
 		}
 
 		// add explicit application registered types
 		for ( org.hibernate.type.BasicType basicType : options.getBasicTypeRegistrations() ) {
 			basicTypeRegistry.register( basicType );
 		}
 
 		return basicTypeRegistry;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/AbstractBinder.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/AbstractBinder.java
index e5500ed351..f34621bdd5 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/AbstractBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/AbstractBinder.java
@@ -1,181 +1,184 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.jaxb.internal;
 
 import java.io.InputStream;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.transform.Source;
 import javax.xml.validation.Schema;
 
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.internal.stax.BufferedXMLEventReader;
 import org.hibernate.boot.jaxb.internal.stax.LocalXmlResourceResolver;
 import org.hibernate.boot.jaxb.spi.Binder;
 import org.hibernate.boot.jaxb.spi.Binding;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class AbstractBinder implements Binder {
 	private static final Logger log = Logger.getLogger( AbstractBinder.class );
 
+	private final LocalXmlResourceResolver xmlResourceResolver;
 	private final boolean validateXml;
 
-	protected AbstractBinder() {
-		this( true );
+	protected AbstractBinder(ClassLoaderService classLoaderService) {
+		this( classLoaderService, true );
 	}
 
-	protected AbstractBinder(boolean validateXml) {
+	protected AbstractBinder(ClassLoaderService classLoaderService, boolean validateXml) {
+		this.xmlResourceResolver = new LocalXmlResourceResolver( classLoaderService );
 		this.validateXml = validateXml;
 	}
 
 	public boolean isValidationEnabled() {
 		return validateXml;
 	}
 
 	@Override
 	public Binding bind(InputStream stream, Origin origin) {
 		final XMLEventReader eventReader = createReader( stream, origin );
 		try {
 			return doBind( eventReader, origin );
 		}
 		finally {
 			try {
 				eventReader.close();
 			}
 			catch (XMLStreamException e) {
 				log.debug( "Unable to close StAX reader", e );
 			}
 		}
 	}
 
 	protected XMLEventReader createReader(InputStream stream, Origin origin) {
 		try {
 			// create a standard StAX reader
 			final XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			// and wrap it in a buffered reader (keeping 100 element sized buffer)
 			return new BufferedXMLEventReader( staxReader, 100 );
 		}
 		catch ( XMLStreamException e ) {
 			throw new MappingException( "Unable to create stax reader", e, origin );
 		}
 	}
 
 	@Override
 	public Binding bind(Source source, Origin origin) {
 		final XMLEventReader eventReader = createReader( source, origin );
 		return doBind( eventReader, origin );
 	}
 
 	protected XMLEventReader createReader(Source source, Origin origin) {
 		try {
 			// create a standard StAX reader
 			final XMLEventReader staxReader = staxFactory().createXMLEventReader( source );
 			// and wrap it in a buffered reader (keeping 100 element sized buffer)
 			return new BufferedXMLEventReader( staxReader, 100 );
 		}
 		catch ( XMLStreamException e ) {
 			throw new MappingException( "Unable to create stax reader", e, origin );
 		}
 	}
 
 	private Binding doBind(XMLEventReader eventReader, Origin origin) {
 		try {
 			final StartElement rootElementStartEvent = seekRootElementStartEvent( eventReader, origin );
 			return doBind( eventReader, rootElementStartEvent, origin );
 		}
 		finally {
 			try {
 				eventReader.close();
 			}
 			catch ( Exception e ) {
 				log.debug( "Unable to close StAX reader", e );
 
 			}
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
-		staxFactory.setXMLResolver( LocalXmlResourceResolver.INSTANCE );
+		staxFactory.setXMLResolver( xmlResourceResolver );
 		return staxFactory;
 	}
 
 	protected StartElement seekRootElementStartEvent(XMLEventReader staxEventReader, Origin origin) {
 		XMLEvent rootElementStartEvent;
 		try {
 			rootElementStartEvent = staxEventReader.peek();
 			while ( rootElementStartEvent != null && !rootElementStartEvent.isStartElement() ) {
 				staxEventReader.nextEvent();
 				rootElementStartEvent = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Error accessing stax stream", e, origin );
 		}
 
 		if ( rootElementStartEvent == null ) {
 			throw new MappingException( "Could not locate root element", origin );
 		}
 
 		return rootElementStartEvent.asStartElement();
 	}
 
 	protected abstract Binding doBind(XMLEventReader staxEventReader, StartElement rootElementStartEvent, Origin origin);
 
 	protected static boolean hasNamespace(StartElement startElement) {
 		return ! "".equals( startElement.getName().getNamespaceURI() );
 	}
 
 	@SuppressWarnings("unchecked")
 	protected <T> T jaxb(XMLEventReader reader, Schema xsd, Class<T> modelClass, Origin origin) {
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 
 		try {
 			final JAXBContext jaxbContext = JAXBContext.newInstance( modelClass );
 			final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			if ( isValidationEnabled() ) {
 				unmarshaller.setSchema( xsd );
 			}
 			else {
 				unmarshaller.setSchema( null );
 			}
 			unmarshaller.setEventHandler( handler );
 
 			return (T) unmarshaller.unmarshal( reader );
 		}
 		catch ( JAXBException e ) {
 			throw new MappingException(
 					"Unable to perform unmarshalling at line number " + handler.getLineNumber()
 							+ " and column " + handler.getColumnNumber()
 							+ ". Message: " + handler.getMessage(),
 					e,
 					origin
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
index c197230ea5..890e0c5d18 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
@@ -1,100 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.jaxb.internal;
 
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.UnsupportedOrmXsdVersionException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmHibernateMapping;
 import org.hibernate.boot.jaxb.internal.stax.HbmEventReader;
 import org.hibernate.boot.jaxb.internal.stax.JpaOrmXmlEventReader;
 import org.hibernate.boot.jaxb.internal.stax.LocalSchema;
 import org.hibernate.boot.jaxb.spi.Binding;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Document;
 import org.dom4j.Node;
 import org.dom4j.io.STAXEventReader;
 
 /**
  * @author Steve Ebersole
  */
 public class MappingBinder extends AbstractBinder {
 	private static final Logger log = Logger.getLogger( MappingBinder.class );
 
 	private final XMLEventFactory xmlEventFactory = XMLEventFactory.newInstance();
 
-	public MappingBinder() {
-		super();
+	public MappingBinder(ClassLoaderService classLoaderService) {
+		super( classLoaderService );
 	}
 
-	public MappingBinder(boolean validateXml) {
-		super( validateXml );
+	public MappingBinder(ClassLoaderService classLoaderService, boolean validateXml) {
+		super( classLoaderService, validateXml );
 	}
 
 	@Override
 	protected Binding doBind(
 			XMLEventReader staxEventReader,
 			StartElement rootElementStartEvent,
 			Origin origin) {
 		final String rootElementLocalName = rootElementStartEvent.getName().getLocalPart();
 		if ( "hibernate-mapping".equals( rootElementLocalName ) ) {
 			log.debugf( "Performing JAXB binding of hbm.xml document : %s", origin.toString() );
 
 			XMLEventReader hbmReader = new HbmEventReader( staxEventReader, xmlEventFactory );
 			JaxbHbmHibernateMapping hbmBindings = jaxb( hbmReader, LocalSchema.HBM.getSchema(), JaxbHbmHibernateMapping.class, origin );
 			return new Binding<JaxbHbmHibernateMapping>( hbmBindings, origin );
 		}
 		else {
 //			final XMLEventReader reader = new JpaOrmXmlEventReader( staxEventReader );
 //			return jaxb( reader, LocalSchema.MAPPING.getSchema(), JaxbEntityMappings.class, origin );
 
 			try {
 				final XMLEventReader reader = new JpaOrmXmlEventReader( staxEventReader, xmlEventFactory );
 				return new Binding<Document>( toDom4jDocument( reader, origin), origin );
 			}
 			catch (JpaOrmXmlEventReader.BadVersionException e) {
 				throw new UnsupportedOrmXsdVersionException( e.getRequestedVersion(), origin );
 			}
 		}
 	}
 
 	private Document toDom4jDocument(XMLEventReader jpaOrmXmlEventReader, Origin origin) {
 		// todo : do we need to build a DocumentFactory instance for use here?
 		//		historically we did that to set TCCL since, iirc, dom4j uses TCCL
 		org.dom4j.io.STAXEventReader staxToDom4jReader = new STAXEventReader() {
 			@Override
 			public Node readNode(XMLEventReader reader) throws XMLStreamException {
 				// dom4j's reader misses handling of XML comments.  So if the document we
 				// are trying to read has comments this process will blow up.  So we
 				// override that to add that support as best we can
 				XMLEvent event = reader.peek();
 				if ( javax.xml.stream.events.Comment.class.isInstance( event ) ) {
 					return super.readComment( reader );
 				}
 				return super.readNode( reader );
 			}
 		};
 		try {
 			return staxToDom4jReader.readDocument( jpaOrmXmlEventReader );
 		}
 		catch (XMLStreamException e) {
 			throw new MappingException(
 					"An error occurred transforming orm.xml document from StAX to dom4j representation ",
 					e,
 					origin
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/LocalXmlResourceResolver.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/LocalXmlResourceResolver.java
index bccfc10f06..64dc0ea51b 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/LocalXmlResourceResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/LocalXmlResourceResolver.java
@@ -1,228 +1,232 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.jaxb.internal.stax;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import javax.xml.stream.XMLStreamException;
 
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ConfigHelper;
 
 /**
  * @author Steve Ebersole
  */
 public class LocalXmlResourceResolver implements javax.xml.stream.XMLResolver {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( LocalXmlResourceResolver.class );
 
-	public static final LocalXmlResourceResolver INSTANCE = new LocalXmlResourceResolver();
-
 	public static final String CLASSPATH_EXTENSION_URL_BASE = "classpath://";
 
+	private final ClassLoaderService classLoaderService;
+
+	public LocalXmlResourceResolver(ClassLoaderService classLoaderService) {
+		this.classLoaderService = classLoaderService;
+	}
+
 	@Override
 	public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws XMLStreamException {
 		log.tracef( "In resolveEntity(%s, %s, %s, %s)", publicID, systemID, baseURI, namespace );
 
 		if ( namespace != null ) {
 			log.debugf( "Interpreting namespace : %s", namespace );
 			if ( INITIAL_JPA_XSD_MAPPING.matches( namespace ) ) {
 				return openUrlStream( INITIAL_JPA_XSD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( JPA_XSD_MAPPING.matches( namespace ) ) {
 				return openUrlStream( JPA_XSD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( HBM_XSD_MAPPING.matches( namespace ) ) {
 				return openUrlStream( HBM_XSD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( HBM_XSD_MAPPING2.matches( namespace ) ) {
 				return openUrlStream( HBM_XSD_MAPPING2.getMappedLocalUrl() );
 			}
 			else if ( CFG_XSD_MAPPING.matches( namespace ) ) {
 				return openUrlStream( CFG_XSD_MAPPING.getMappedLocalUrl() );
 			}
 		}
 
 		if ( publicID != null || systemID != null ) {
 			log.debugf( "Interpreting public/system identifier : [%s] - [%s]", publicID, systemID );
 			if ( HBM_DTD_MAPPING.matches( publicID, systemID ) ) {
 				log.debug(
 						"Recognized hibernate-mapping identifier; attempting to resolve on classpath under org/hibernate/"
 				);
 				return openUrlStream( HBM_DTD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( LEGACY_HBM_DTD_MAPPING.matches( publicID, systemID ) ) {
 				log.recognizedObsoleteHibernateNamespace(
 						LEGACY_HBM_DTD_MAPPING.getIdentifierBase(),
 						HBM_DTD_MAPPING.getIdentifierBase()
 				);
 				log.debug(
 						"Recognized legacy hibernate-mapping identifier; attempting to resolve on classpath under org/hibernate/"
 				);
 				return openUrlStream( HBM_DTD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( LEGACY2_HBM_DTD_MAPPING.matches( publicID, systemID ) ) {
 				log.recognizedObsoleteHibernateNamespace(
 						LEGACY2_HBM_DTD_MAPPING.getIdentifierBase(),
 						HBM_DTD_MAPPING.getIdentifierBase()
 				);
 				log.debug(
 						"Recognized legacy hibernate-mapping identifier; attempting to resolve on classpath under org/hibernate/"
 				);
 				return openUrlStream( HBM_DTD_MAPPING.getMappedLocalUrl() );
 			}
 			else if ( CFG_DTD_MAPPING.matches( publicID, systemID ) ) {
 				log.debug(
 						"Recognized hibernate-configuration identifier; attempting to resolve on classpath under org/hibernate/"
 				);
 				return openUrlStream( CFG_DTD_MAPPING.getMappedLocalUrl() );
 			}
 		}
 
 		if ( systemID != null ) {
 			// technically, "classpath://..." identifiers should only be declared as SYSTEM identifiers
 			if ( systemID.startsWith( CLASSPATH_EXTENSION_URL_BASE ) ) {
 				log.debugf( "Recognized `classpath:` identifier; attempting to resolve on classpath [%s]", systemID );
 				final String path = systemID.substring( CLASSPATH_EXTENSION_URL_BASE.length() );
 				// todo : for this to truly work consistently, we need access to ClassLoaderService
 				final InputStream stream = resolveInLocalNamespace( path );
 				if ( stream == null ) {
 					log.debugf( "Unable to resolve [%s] on classpath", systemID );
 				}
 				else {
 					log.debugf( "Resolved [%s] on classpath", systemID );
 				}
 				return stream;
 			}
 		}
 
 		return null;
 	}
 
 	private InputStream openUrlStream(URL url) {
 		try {
 			return url.openStream();
 		}
 		catch (IOException e) {
 			throw new XmlInfrastructureException( "Could not open url stream : " + url.toExternalForm(), e );
 		}
 	}
 
 	private InputStream resolveInLocalNamespace(String path) {
 		try {
-			return ConfigHelper.getUserResourceAsStream( path );
+			return classLoaderService.locateResourceStream( path );
 		}
 		catch ( Throwable t ) {
 			return null;
 		}
 	}
 
 	/**
 	 * Maps the namespace for the orm.xml xsd for jpa 1.0 and 2.0
 	 */
 	public static final NamespaceSchemaMapping INITIAL_JPA_XSD_MAPPING = new NamespaceSchemaMapping(
 			"http://java.sun.com/xml/ns/persistence/orm",
 			"org/hibernate/jpa/orm_2_0.xsd"
 	);
 
 	/**
 	 * Maps the namespace for the orm.xml xsd for jpa 2.1+
 	 */
 	public static final NamespaceSchemaMapping JPA_XSD_MAPPING = new NamespaceSchemaMapping(
 			"http://xmlns.jcp.org/xml/ns/persistence/orm",
 			"org/hibernate/jpa/orm_2_1.xsd"
 	);
 
 	public static final NamespaceSchemaMapping HBM_XSD_MAPPING = new NamespaceSchemaMapping(
 			"http://www.hibernate.org/xsd/orm/hbm",
 			"org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd"
 	);
 
 	public static final NamespaceSchemaMapping HBM_XSD_MAPPING2 = new NamespaceSchemaMapping(
 			"http://www.hibernate.org/xsd/hibernate-mapping",
 			"org/hibernate/hibernate-mapping-4.0.xsd"
 	);
 
 	public static final NamespaceSchemaMapping CFG_XSD_MAPPING = new NamespaceSchemaMapping(
 			"http://www.hibernate.org/xsd/orm/cfg",
 			"org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd"
 	);
 
 	public static final DtdMapping HBM_DTD_MAPPING = new DtdMapping(
 			"http://www.hibernate.org/dtd/hibernate-mapping",
 			"org/hibernate/hibernate-mapping-3.0.dtd"
 	);
 
 	public static final DtdMapping LEGACY_HBM_DTD_MAPPING = new DtdMapping(
 			"http://www.hibernate.org/dtd/hibernate-mapping",
 			"org/hibernate/hibernate-mapping-3.0.dtd"
 	);
 
 	public static final DtdMapping LEGACY2_HBM_DTD_MAPPING = new DtdMapping(
 			"http://hibernate.sourceforge.net/hibernate-mapping",
 			"org/hibernate/hibernate-mapping-3.0.dtd"
 	);
 
 	public static final DtdMapping CFG_DTD_MAPPING = new DtdMapping(
 			"http://www.hibernate.org/dtd/hibernate-configuration",
 			"org/hibernate/hibernate-configuration-3.0.dtd"
 	);
 
 
 	public static class NamespaceSchemaMapping {
 		private final String namespace;
 		private final URL localSchemaUrl;
 
 		public NamespaceSchemaMapping(String namespace, String resourceName) {
 			this.namespace = namespace;
 			this.localSchemaUrl = LocalSchemaLocator.resolveLocalSchemaUrl( resourceName );
 		}
 
 		public boolean matches(String namespace) {
 			return this.namespace.equals( namespace );
 		}
 
 		public URL getMappedLocalUrl() {
 			return localSchemaUrl;
 		}
 	}
 
 	public static class DtdMapping {
 		private final String identifierBase;
 		private final URL localSchemaUrl;
 
 		public DtdMapping(String identifierBase, String resourceName) {
 			this.identifierBase = identifierBase;
 			this.localSchemaUrl = LocalSchemaLocator.resolveLocalSchemaUrl( resourceName );
 		}
 
 		public String getIdentifierBase() {
 			return identifierBase;
 		}
 
 		public boolean matches(String publicId, String systemId) {
 			if ( publicId != null ) {
 				if ( publicId.startsWith( identifierBase ) ) {
 					return true;
 				}
 			}
 
 			if ( systemId != null ) {
 				if ( systemId.startsWith( identifierBase ) ) {
 					return true;
 				}
 			}
 
 			return false;
 		}
 
 		public URL getMappedLocalUrl() {
 			return localSchemaUrl;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
index 8783846462..ab647b7f60 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
@@ -1,1640 +1,1644 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.model.source.internal.hbm;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmNamedNativeQueryType;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmNamedQueryType;
 import org.hibernate.boot.model.Caching;
 import org.hibernate.boot.model.IdentifierGeneratorDefinition;
 import org.hibernate.boot.model.TruthValue;
 import org.hibernate.boot.model.TypeDefinition;
 import org.hibernate.boot.model.naming.EntityNaming;
 import org.hibernate.boot.model.naming.Identifier;
 import org.hibernate.boot.model.naming.ImplicitBasicColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitCollectionTableNameSource;
 import org.hibernate.boot.model.naming.ImplicitEntityNameSource;
 import org.hibernate.boot.model.naming.ImplicitIdentifierColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitIndexColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitJoinColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitMapKeyColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.ImplicitUniqueKeyNameSource;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.Schema;
 import org.hibernate.boot.model.source.internal.ConstraintSecondPass;
 import org.hibernate.boot.model.source.internal.ImplicitColumnNamingSecondPass;
 import org.hibernate.boot.model.source.spi.AnyMappingSource;
 import org.hibernate.boot.model.source.spi.AttributePath;
 import org.hibernate.boot.model.source.spi.AttributeRole;
 import org.hibernate.boot.model.source.spi.AttributeSource;
 import org.hibernate.boot.model.source.spi.CascadeStyleSource;
 import org.hibernate.boot.model.source.spi.CollectionIdSource;
 import org.hibernate.boot.model.source.spi.ColumnSource;
 import org.hibernate.boot.model.source.spi.CompositeIdentifierSource;
 import org.hibernate.boot.model.source.spi.ConstraintSource;
 import org.hibernate.boot.model.source.spi.EmbeddableSource;
 import org.hibernate.boot.model.source.spi.EntitySource;
 import org.hibernate.boot.model.source.spi.FilterSource;
 import org.hibernate.boot.model.source.spi.HibernateTypeSource;
 import org.hibernate.boot.model.source.spi.IdentifiableTypeSource;
 import org.hibernate.boot.model.source.spi.IdentifierSourceAggregatedComposite;
 import org.hibernate.boot.model.source.spi.IdentifierSourceNonAggregatedComposite;
 import org.hibernate.boot.model.source.spi.IdentifierSourceSimple;
 import org.hibernate.boot.model.source.spi.InLineViewSource;
 import org.hibernate.boot.model.source.spi.LocalMetadataBuildingContext;
 import org.hibernate.boot.model.source.spi.NaturalIdMutability;
 import org.hibernate.boot.model.source.spi.Orderable;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceBasic;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceEmbedded;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceManyToAny;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceManyToMany;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceOneToMany;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeyManyToAnySource;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeyManyToManySource;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeySourceBasic;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeySourceEmbedded;
 import org.hibernate.boot.model.source.spi.PluralAttributeSequentialIndexSource;
 import org.hibernate.boot.model.source.spi.PluralAttributeSource;
 import org.hibernate.boot.model.source.spi.PluralAttributeSourceArray;
 import org.hibernate.boot.model.source.spi.RelationalValueSource;
 import org.hibernate.boot.model.source.spi.RelationalValueSourceContainer;
 import org.hibernate.boot.model.source.spi.SecondaryTableSource;
 import org.hibernate.boot.model.source.spi.SingularAttributeSource;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceAny;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceBasic;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceEmbedded;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceManyToOne;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceOneToOne;
 import org.hibernate.boot.model.source.spi.Sortable;
 import org.hibernate.boot.model.source.spi.TableSource;
 import org.hibernate.boot.model.source.spi.TableSpecificationSource;
 import org.hibernate.boot.model.source.spi.VersionAttributeSource;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.InFlightMetadataCollector;
 import org.hibernate.boot.spi.InFlightMetadataCollector.EntityTableXref;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.boot.spi.NaturalIdUniqueKeyBinder;
 import org.hibernate.cfg.FkSecondPass;
 import org.hibernate.cfg.SecondPass;
 import org.hibernate.engine.FetchStyle;
 import org.hibernate.engine.FetchTiming;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.log.DeprecationLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.compare.EqualsHelper;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.mapping.Any;
 import org.hibernate.mapping.Array;
 import org.hibernate.mapping.AttributeContainer;
 import org.hibernate.mapping.Backref;
 import org.hibernate.mapping.Bag;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.IdentifierBag;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.IndexBackref;
 import org.hibernate.mapping.IndexedCollection;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.ManyToOne;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.PrimitiveArray;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Set;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.SyntheticProperty;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.UnionSubclass;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.mapping.Value;
 import org.hibernate.tuple.GeneratedValueGeneration;
 import org.hibernate.tuple.GenerationTiming;
 import org.hibernate.type.DiscriminatorType;
 import org.hibernate.type.ForeignKeyDirection;
 
 /**
  * Responsible for coordinating the binding of all information inside entity tags ({@code <class/>}, etc).
  *
  * @author Steve Ebersole
  */
 public class ModelBinder {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( ModelBinder.class );
 	private static final boolean debugEnabled = log.isDebugEnabled();
 
+	private final MetadataBuildingContext metadataBuildingContext;
+
 	private final Database database;
 	private final ObjectNameNormalizer objectNameNormalizer;
 	private final ImplicitNamingStrategy implicitNamingStrategy;
 	private final RelationalObjectBinder relationalObjectBinder;
 
 	public static ModelBinder prepare(MetadataBuildingContext context) {
 		return new ModelBinder( context );
 	}
 
 	public ModelBinder(final MetadataBuildingContext context) {
+		this.metadataBuildingContext = context;
+
 		this.database = context.getMetadataCollector().getDatabase();
 		this.objectNameNormalizer = new ObjectNameNormalizer() {
 			@Override
 			protected MetadataBuildingContext getBuildingContext() {
 				return context;
 			}
 		};
 		this.implicitNamingStrategy = context.getBuildingOptions().getImplicitNamingStrategy();
 		this.relationalObjectBinder = new RelationalObjectBinder( context );
 	}
 
 	public void finishUp(MetadataBuildingContext context) {
 	}
 
 	public void bindEntityHierarchy(EntityHierarchySourceImpl hierarchySource) {
-		final RootClass rootEntityDescriptor = new RootClass();
+		final RootClass rootEntityDescriptor = new RootClass( metadataBuildingContext );
 		bindRootEntity( hierarchySource, rootEntityDescriptor );
 		hierarchySource.getRoot()
 				.getLocalMetadataBuildingContext()
 				.getMetadataCollector()
 				.addEntityBinding( rootEntityDescriptor );
 
 		switch ( hierarchySource.getHierarchyInheritanceType() ) {
 			case NO_INHERITANCE: {
 				// nothing to do
 				break;
 			}
 			case DISCRIMINATED: {
 				bindDiscriminatorSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 			case JOINED: {
 				bindJoinedSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 			case UNION: {
 				bindUnionSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 		}
 	}
 
 	private void bindRootEntity(EntityHierarchySourceImpl hierarchySource, RootClass rootEntityDescriptor) {
 		final MappingDocument mappingDocument = hierarchySource.getRoot().sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				hierarchySource.getRoot().getPrimaryTable(),
 				null,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		rootEntityDescriptor.setTable( primaryTable );
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping class: %s -> %s", rootEntityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		rootEntityDescriptor.setOptimisticLockStyle( hierarchySource.getOptimisticLockStyle() );
 		rootEntityDescriptor.setMutable( hierarchySource.isMutable() );
 		rootEntityDescriptor.setWhere( hierarchySource.getWhere() );
 		rootEntityDescriptor.setExplicitPolymorphism( hierarchySource.isExplicitPolymorphism() );
 
 		bindEntityIdentifier(
 				mappingDocument,
 				hierarchySource,
 				rootEntityDescriptor
 		);
 
 		if ( hierarchySource.getVersionAttributeSource() != null ) {
 			bindEntityVersion(
 					mappingDocument,
 					hierarchySource,
 					rootEntityDescriptor
 			);
 		}
 
 		if ( hierarchySource.getDiscriminatorSource() != null ) {
 			bindEntityDiscriminator(
 					mappingDocument,
 					hierarchySource,
 					rootEntityDescriptor
 			);
 		}
 
 		applyCaching( mappingDocument, hierarchySource.getCaching(), rootEntityDescriptor );
 
 		// Primary key constraint
 		rootEntityDescriptor.createPrimaryKey();
 
 		bindAllEntityAttributes(
 				mappingDocument,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		if ( hierarchySource.getNaturalIdCaching() != null ) {
 			if ( hierarchySource.getNaturalIdCaching().getRequested() == TruthValue.TRUE ) {
 				rootEntityDescriptor.setNaturalIdCacheRegionName( hierarchySource.getNaturalIdCaching().getRegion() );
 			}
 		}
 	}
 
 	private void applyCaching(MappingDocument mappingDocument, Caching caching, RootClass rootEntityDescriptor) {
 		if ( caching == null || caching.getRequested() == TruthValue.UNKNOWN ) {
 			// see if JPA's SharedCacheMode indicates we should implicitly apply caching
 			//
 			// here we only really look for ALL.  Ideally we could look at NONE too as a means
 			// to selectively disable all caching, but historically hbm.xml mappings were processed
 			// outside this concept and whether to cache or not was defined wholly by what
 			// is defined in the mapping document.  So for backwards compatibility we
 			// do not consider ENABLE_SELECTIVE nor DISABLE_SELECTIVE here.
 			//
 			// Granted, ALL was not historically considered either, but I have a practical
 			// reason for wanting to support this... our legacy tests built using
 			// Configuration applied a similar logic but that capability is no longer
 			// accessible from Configuration
 			switch ( mappingDocument.getBuildingOptions().getSharedCacheMode() ) {
 				case ALL: {
 					caching = new Caching(
 							null,
 							mappingDocument.getBuildingOptions().getImplicitCacheAccessType(),
 							false,
 							TruthValue.UNKNOWN
 					);
 					break;
 				}
 				case NONE: {
 					// Ideally we'd disable all caching...
 					break;
 				}
 				case ENABLE_SELECTIVE: {
 					// this is default behavior for hbm.xml
 					break;
 				}
 				case DISABLE_SELECTIVE: {
 					// really makes no sense for hbm.xml
 					break;
 				}
 				default: {
 					// null or UNSPECIFIED, nothing to do.  IMO for hbm.xml this is equivalent
 					// to ENABLE_SELECTIVE
 					break;
 				}
 			}
 		}
 
 		if ( caching == null || caching.getRequested() == TruthValue.FALSE ) {
 			return;
 		}
 
 		if ( caching.getAccessType() != null ) {
 			rootEntityDescriptor.setCacheConcurrencyStrategy( caching.getAccessType().getExternalName() );
 		}
 		else {
 			rootEntityDescriptor.setCacheConcurrencyStrategy( mappingDocument.getBuildingOptions().getImplicitCacheAccessType().getExternalName() );
 		}
 		rootEntityDescriptor.setCacheRegionName( caching.getRegion() );
 		rootEntityDescriptor.setLazyPropertiesCacheable( caching.isCacheLazyProperties() );
 		rootEntityDescriptor.setCachingExplicitlyRequested( caching.getRequested() != TruthValue.UNKNOWN );
 	}
 
 	private void bindEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		switch ( hierarchySource.getIdentifierSource().getNature() ) {
 			case SIMPLE: {
 				bindSimpleEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			case AGGREGATED_COMPOSITE: {
 				bindAggregatedCompositeEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			case NON_AGGREGATED_COMPOSITE: {
 				bindNonAggregatedCompositeEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			default: {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Unexpected entity identifier nature [%s] for entity %s",
 								hierarchySource.getIdentifierSource().getNature(),
 								hierarchySource.getRoot().getEntityNamingSource().getEntityName()
 						),
 						mappingDocument.getOrigin()
 				);
 			}
 		}
 	}
 
 	private void bindBasicEntityValues(
 			MappingDocument sourceDocument,
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass entityDescriptor) {
 		entityDescriptor.setEntityName( entitySource.getEntityNamingSource().getEntityName() );
 		entityDescriptor.setJpaEntityName( entitySource.getEntityNamingSource().getJpaEntityName() );
 		entityDescriptor.setClassName( entitySource.getEntityNamingSource().getClassName() );
 
 		entityDescriptor.setDiscriminatorValue(
 				entitySource.getDiscriminatorMatchValue() != null
 						? entitySource.getDiscriminatorMatchValue()
 						: entityDescriptor.getEntityName()
 		);
 
 		// NOTE : entitySource#isLazy already accounts for MappingDefaults#areEntitiesImplicitlyLazy
 		if ( StringHelper.isNotEmpty( entitySource.getProxy() ) ) {
 			final String qualifiedProxyName = sourceDocument.qualifyClassName( entitySource.getProxy() );
 			entityDescriptor.setProxyInterfaceName( qualifiedProxyName );
 			entityDescriptor.setLazy( true );
 		}
 		else if ( entitySource.isLazy() ) {
 			entityDescriptor.setProxyInterfaceName( entityDescriptor.getClassName() );
 			entityDescriptor.setLazy( true );
 		}
 		else {
 			entityDescriptor.setProxyInterfaceName( null );
 			entityDescriptor.setLazy( false );
 		}
 
 		entityDescriptor.setAbstract( entitySource.isAbstract() );
 
 		sourceDocument.getMetadataCollector().addImport(
 				entitySource.getEntityNamingSource().getEntityName(),
 				entitySource.getEntityNamingSource().getEntityName()
 		);
 
 		if ( sourceDocument.getMappingDefaults().isAutoImportEnabled() && entitySource.getEntityNamingSource().getEntityName().indexOf( '.' ) > 0 ) {
 			sourceDocument.getMetadataCollector().addImport(
 					StringHelper.unqualify( entitySource.getEntityNamingSource().getEntityName() ),
 					entitySource.getEntityNamingSource().getEntityName()
 			);
 		}
 
 		if ( entitySource.getTuplizerClassMap() != null ) {
 			if ( entitySource.getTuplizerClassMap().size() > 1 ) {
 				DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfMultipleEntityModeSupport();
 			}
 			for ( Map.Entry<EntityMode,String> tuplizerEntry : entitySource.getTuplizerClassMap().entrySet() ) {
 				entityDescriptor.addTuplizer(
 						tuplizerEntry.getKey(),
 						tuplizerEntry.getValue()
 				);
 			}
 		}
 
 		if ( StringHelper.isNotEmpty( entitySource.getXmlNodeName() ) ) {
 			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfDomEntityModeSupport();
 			entityDescriptor.setNodeName( entitySource.getXmlNodeName() );
 		}
 
 		entityDescriptor.setDynamicInsert( entitySource.isDynamicInsert() );
 		entityDescriptor.setDynamicUpdate( entitySource.isDynamicUpdate() );
 		entityDescriptor.setBatchSize( entitySource.getBatchSize() );
 		entityDescriptor.setSelectBeforeUpdate( entitySource.isSelectBeforeUpdate() );
 
 		if ( StringHelper.isNotEmpty( entitySource.getCustomPersisterClassName() ) ) {
 			try {
 				entityDescriptor.setEntityPersisterClass(
 						sourceDocument.getClassLoaderAccess().classForName( entitySource.getCustomPersisterClassName() )
 				);
 			}
 			catch (ClassLoadingException e) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Unable to load specified persister class : %s",
 								entitySource.getCustomPersisterClassName()
 						),
 						e,
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 
 		bindCustomSql( sourceDocument, entitySource, entityDescriptor );
 
 		for ( String tableName : entitySource.getSynchronizedTableNames() ) {
 			entityDescriptor.addSynchronizedTable( tableName );
 		}
 
 		for ( FilterSource filterSource : entitySource.getFilterSources() ) {
 			String condition = filterSource.getCondition();
 			if ( condition == null ) {
 				final FilterDefinition filterDefinition = sourceDocument.getMetadataCollector().getFilterDefinition( filterSource.getName() );
 				if ( filterDefinition != null ) {
 					condition = filterDefinition.getDefaultFilterCondition();
 				}
 			}
 
 			entityDescriptor.addFilter(
 					filterSource.getName(),
 					condition,
 					filterSource.shouldAutoInjectAliases(),
 					filterSource.getAliasToTableMap(),
 					filterSource.getAliasToEntityMap()
 			);
 		}
 
 		for ( JaxbHbmNamedQueryType namedQuery : entitySource.getNamedQueries() ) {
 			NamedQueryBinder.processNamedQuery(
 					sourceDocument,
 					namedQuery,
 					entitySource.getEntityNamingSource().getEntityName() + "."
 			);
 		}
 		for ( JaxbHbmNamedNativeQueryType namedQuery : entitySource.getNamedNativeQueries() ) {
 			NamedQueryBinder.processNamedNativeQuery(
 					sourceDocument,
 					namedQuery,
 					entitySource.getEntityNamingSource().getEntityName() + "."
 			);
 		}
 
 		entityDescriptor.setMetaAttributes( entitySource.getToolingHintContext().getMetaAttributeMap() );
 	}
 
 	private void bindDiscriminatorSubclassEntities(
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
-			final SingleTableSubclass subEntityDescriptor = new SingleTableSubclass( superEntityDescriptor );
+			final SingleTableSubclass subEntityDescriptor = new SingleTableSubclass( superEntityDescriptor, metadataBuildingContext );
 			bindDiscriminatorSubclassEntity( (SubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindDiscriminatorSubclassEntity(
 			SubclassEntitySourceImpl entitySource,
 			SingleTableSubclass entityDescriptor) {
 
 		bindBasicEntityValues(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		final String superEntityName = ( (EntitySource) entitySource.getSuperType() ).getEntityNamingSource()
 				.getEntityName();
 		final EntityTableXref superEntityTableXref = entitySource.getLocalMetadataBuildingContext()
 				.getMetadataCollector()
 				.getEntityTableXref( superEntityName );
 		if ( superEntityTableXref == null ) {
 			throw new MappingException(
 					String.format(
 							Locale.ENGLISH,
 							"Unable to locate entity table xref for entity [%s] super-type [%s]",
 							entityDescriptor.getEntityName(),
 							superEntityName
 					),
 					entitySource.origin()
 			);
 		}
 
 		entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityTableXref(
 				entitySource.getEntityNamingSource().getEntityName(),
 				database.toIdentifier(
 						entitySource.getLocalMetadataBuildingContext().getMetadataCollector().getLogicalTableName(
 								entityDescriptor.getTable()
 						)
 				),
 				entityDescriptor.getTable(),
 				superEntityTableXref
 		);
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindDiscriminatorSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindJoinedSubclassEntities(
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
-			final JoinedSubclass subEntityDescriptor = new JoinedSubclass( superEntityDescriptor );
+			final JoinedSubclass subEntityDescriptor = new JoinedSubclass( superEntityDescriptor, metadataBuildingContext );
 			bindJoinedSubclassEntity( (JoinedSubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindJoinedSubclassEntity(
 			JoinedSubclassEntitySourceImpl entitySource,
 			JoinedSubclass entityDescriptor) {
 		MappingDocument mappingDocument = entitySource.sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				entitySource,
 				entityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				entitySource.getPrimaryTable(),
 				null,
 				entitySource,
 				entityDescriptor
 		);
 
 		entityDescriptor.setTable( primaryTable );
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping joined-subclass: %s -> %s", entityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		// KEY
 		final SimpleValue keyBinding = new DependantValue(
 				mappingDocument.getMetadataCollector(),
 				primaryTable,
 				entityDescriptor.getIdentifier()
 		);
 		if ( mappingDocument.getBuildingOptions().useNationalizedCharacterData() ) {
 			keyBinding.makeNationalized();
 		}
 		entityDescriptor.setKey( keyBinding );
 		keyBinding.setCascadeDeleteEnabled( entitySource.isCascadeDeleteEnabled() );
 		relationalObjectBinder.bindColumns(
 				mappingDocument,
 				entitySource.getPrimaryKeyColumnSources(),
 				keyBinding,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					int count = 0;
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						final Column column = primaryTable.getPrimaryKey().getColumn( count++ );
 						return database.toIdentifier( column.getQuotedName() );
 					}
 				}
 		);
 
 		// model.getKey().setType( new Type( model.getIdentifier() ) );
 		entityDescriptor.createPrimaryKey();
 		entityDescriptor.createForeignKey();
 
 		// todo : tooling hints
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindJoinedSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindUnionSubclassEntities(
 			EntitySource entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
-			final UnionSubclass subEntityDescriptor = new UnionSubclass( superEntityDescriptor );
+			final UnionSubclass subEntityDescriptor = new UnionSubclass( superEntityDescriptor, metadataBuildingContext );
 			bindUnionSubclassEntity( (SubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindUnionSubclassEntity(
 			SubclassEntitySourceImpl entitySource,
 			UnionSubclass entityDescriptor) {
 		MappingDocument mappingDocument = entitySource.sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				entitySource,
 				entityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				entitySource.getPrimaryTable(),
 				entityDescriptor.getSuperclass().getTable(),
 				entitySource,
 				entityDescriptor
 		);
 		entityDescriptor.setTable( primaryTable );
 
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping union-subclass: %s -> %s", entityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		// todo : tooling hints
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindUnionSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindSimpleEntityIdentifier(
 			MappingDocument sourceDocument,
 			final EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final IdentifierSourceSimple idSource = (IdentifierSourceSimple) hierarchySource.getIdentifierSource();
 
 		final SimpleValue idValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 		rootEntityDescriptor.setIdentifier( idValue );
 
 		bindSimpleValueType(
 				sourceDocument,
 				idSource.getIdentifierAttributeSource().getTypeInformation(),
 				idValue
 		);
 
 		final String propertyName = idSource.getIdentifierAttributeSource().getName();
 		if ( propertyName == null || !rootEntityDescriptor.hasPojoRepresentation() ) {
 			if ( !idValue.isTypeSpecified() ) {
 				throw new MappingException(
 						"must specify an identifier type: " + rootEntityDescriptor.getEntityName(),
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 		else {
 			idValue.setTypeUsingReflection( rootEntityDescriptor.getClassName(), propertyName );
 		}
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				( (RelationalValueSourceContainer) idSource.getIdentifierAttributeSource() ).getRelationalValueSources(),
 				idValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 						context.getBuildingOptions().getImplicitNamingStrategy().determineIdentifierColumnName(
 								new ImplicitIdentifierColumnNameSource() {
 									@Override
 									public EntityNaming getEntityNaming() {
 										return hierarchySource.getRoot().getEntityNamingSource();
 									}
 
 									@Override
 									public AttributePath getIdentifierAttributePath() {
 										return idSource.getIdentifierAttributeSource().getAttributePath();
 									}
 
 									@Override
 									public MetadataBuildingContext getBuildingContext() {
 										return context;
 									}
 								}
 						);
 						return database.toIdentifier( propertyName );
 					}
 				}
 		);
 
 		if ( propertyName != null ) {
 			Property prop = new Property();
 			prop.setValue( idValue );
 			bindProperty(
 					sourceDocument,
 					idSource.getIdentifierAttributeSource(),
 					prop
 			);
 			rootEntityDescriptor.setIdentifierProperty( prop );
 			rootEntityDescriptor.setDeclaredIdentifierProperty( prop );
 		}
 
 		makeIdentifier(
 				sourceDocument,
 				idSource.getIdentifierGeneratorDescriptor(),
 				idSource.getUnsavedValue(),
 				idValue
 		);
 	}
 
 	private void makeIdentifier(
 			final MappingDocument sourceDocument,
 			IdentifierGeneratorDefinition generator,
 			String unsavedValue,
 			SimpleValue identifierValue) {
 		if ( generator != null ) {
 			String generatorName = generator.getStrategy();
 			Properties params = new Properties();
 
 			// see if the specified generator name matches a registered <identifier-generator/>
 			IdentifierGeneratorDefinition generatorDef = sourceDocument.getMetadataCollector().getIdentifierGenerator( generatorName );
 			if ( generatorDef != null ) {
 				generatorName = generatorDef.getStrategy();
 				params.putAll( generatorDef.getParameters() );
 			}
 
 			identifierValue.setIdentifierGeneratorStrategy( generatorName );
 
 			// YUCK!  but cannot think of a clean way to do this given the string-config based scheme
 			params.put( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER, objectNameNormalizer);
 
 			if ( database.getDefaultSchema().getPhysicalName().getSchema() != null ) {
 				params.setProperty(
 						PersistentIdentifierGenerator.SCHEMA,
 						database.getDefaultSchema().getPhysicalName().getSchema().render( database.getDialect() )
 				);
 			}
 			if ( database.getDefaultSchema().getPhysicalName().getCatalog() != null ) {
 				params.setProperty(
 						PersistentIdentifierGenerator.CATALOG,
 						database.getDefaultSchema().getPhysicalName().getCatalog().render( database.getDialect() )
 				);
 			}
 
 			params.putAll( generator.getParameters() );
 
 			identifierValue.setIdentifierGeneratorProperties( params );
 		}
 
 		identifierValue.getTable().setIdentifierValue( identifierValue );
 
 		if ( StringHelper.isNotEmpty( unsavedValue ) ) {
 			identifierValue.setNullValue( unsavedValue );
 		}
 		else {
 			if ( "assigned".equals( identifierValue.getIdentifierGeneratorStrategy() ) ) {
 				identifierValue.setNullValue( "undefined" );
 			}
 			else {
 				identifierValue.setNullValue( null );
 			}
 		}
 	}
 
 	private void bindAggregatedCompositeEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 
 		// an aggregated composite-id is a composite-id that defines a singular
 		// (composite) attribute as part of the entity to represent the id.
 
 		final IdentifierSourceAggregatedComposite identifierSource
 				= (IdentifierSourceAggregatedComposite) hierarchySource.getIdentifierSource();
 
 		final Component cid = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 		cid.setKey( true );
 		rootEntityDescriptor.setIdentifier( cid );
 
 		final String idClassName = extractIdClassName( identifierSource );
 
 		final String idPropertyName = identifierSource.getIdentifierAttributeSource().getName();
 		final String pathPart = idPropertyName == null ? "<id>" : idPropertyName;
 
 		bindComponent(
 				mappingDocument,
 				hierarchySource.getRoot().getAttributeRoleBase().append( pathPart ).getFullPath(),
 				identifierSource.getEmbeddableSource(),
 				cid,
 				idClassName,
 				rootEntityDescriptor.getClassName(),
 				idPropertyName,
 				idClassName == null && idPropertyName == null,
 				identifierSource.getEmbeddableSource().isDynamic(),
 				identifierSource.getIdentifierAttributeSource().getXmlNodeName()
 		);
 
 		finishBindingCompositeIdentifier(
 				mappingDocument,
 				rootEntityDescriptor,
 				identifierSource,
 				cid,
 				idPropertyName
 		);
 	}
 
 	private String extractIdClassName(IdentifierSourceAggregatedComposite identifierSource) {
 		if ( identifierSource.getEmbeddableSource().getTypeDescriptor() == null ) {
 			return null;
 		}
 
 		return identifierSource.getEmbeddableSource().getTypeDescriptor().getName();
 	}
 
 	private static final String ID_MAPPER_PATH_PART = '<' + PropertyPath.IDENTIFIER_MAPPER_PROPERTY + '>';
 
 	private void bindNonAggregatedCompositeEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final IdentifierSourceNonAggregatedComposite identifierSource
 				= (IdentifierSourceNonAggregatedComposite) hierarchySource.getIdentifierSource();
 
 		final Component cid = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 		cid.setKey( true );
 		rootEntityDescriptor.setIdentifier( cid );
 
 		final String idClassName = extractIdClassName( identifierSource );
 
 		bindComponent(
 				mappingDocument,
 				hierarchySource.getRoot().getAttributeRoleBase().append( "<id>" ).getFullPath(),
 				identifierSource.getEmbeddableSource(),
 				cid,
 				idClassName,
 				rootEntityDescriptor.getClassName(),
 				null,
 				idClassName == null,
 				false,
 				null
 		);
 
 		if ( idClassName != null ) {
 			// we also need to bind the "id mapper".  ugh, terrible name.  Basically we need to
 			// create a virtual (embedded) composite for the non-aggregated attributes on the entity
 			// itself.
 			final Component mapper = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 			bindComponent(
 					mappingDocument,
 					hierarchySource.getRoot().getAttributeRoleBase().append( ID_MAPPER_PATH_PART ).getFullPath(),
 					identifierSource.getEmbeddableSource(),
 					mapper,
 					rootEntityDescriptor.getClassName(),
 					null,
 					null,
 					true,
 					false,
 					null
 			);
 
 			rootEntityDescriptor.setIdentifierMapper(mapper);
 			Property property = new Property();
 			property.setName( PropertyPath.IDENTIFIER_MAPPER_PROPERTY );
 			property.setNodeName( "id" );
 			property.setUpdateable( false );
 			property.setInsertable( false );
 			property.setValue( mapper );
 			property.setPropertyAccessorName( "embedded" );
 			rootEntityDescriptor.addProperty( property );
 		}
 
 		finishBindingCompositeIdentifier( mappingDocument, rootEntityDescriptor, identifierSource, cid, null );
 	}
 
 	private String extractIdClassName(IdentifierSourceNonAggregatedComposite identifierSource) {
 		if ( identifierSource.getIdClassSource() == null ) {
 			return null;
 		}
 
 		if ( identifierSource.getIdClassSource().getTypeDescriptor() == null ) {
 			return null;
 		}
 
 		return identifierSource.getIdClassSource().getTypeDescriptor().getName();
 	}
 
 	private void finishBindingCompositeIdentifier(
 			MappingDocument sourceDocument,
 			RootClass rootEntityDescriptor,
 			CompositeIdentifierSource identifierSource,
 			Component cid,
 			String propertyName) {
 		if ( propertyName == null ) {
 			rootEntityDescriptor.setEmbeddedIdentifier( cid.isEmbedded() );
 			if ( cid.isEmbedded() ) {
 				// todo : what is the implication of this?
 				cid.setDynamic( !rootEntityDescriptor.hasPojoRepresentation() );
 				/*
 				 * Property prop = new Property(); prop.setName("id");
 				 * prop.setPropertyAccessorName("embedded"); prop.setValue(id);
 				 * entity.setIdentifierProperty(prop);
 				 */
 			}
 		}
 		else {
 			Property prop = new Property();
 			prop.setValue( cid );
 			bindProperty(
 					sourceDocument,
 					( (IdentifierSourceAggregatedComposite) identifierSource ).getIdentifierAttributeSource(),
 					prop
 			);
 			rootEntityDescriptor.setIdentifierProperty( prop );
 			rootEntityDescriptor.setDeclaredIdentifierProperty( prop );
 		}
 
 		makeIdentifier(
 				sourceDocument,
 				identifierSource.getIdentifierGeneratorDescriptor(),
 				null,
 				cid
 		);
 	}
 
 	private void bindEntityVersion(
 			MappingDocument sourceDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final VersionAttributeSource versionAttributeSource = hierarchySource.getVersionAttributeSource();
 
 		final SimpleValue versionValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 
 		bindSimpleValueType(
 				sourceDocument,
 				versionAttributeSource.getTypeInformation(),
 				versionValue
 		);
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				versionAttributeSource.getRelationalValueSources(),
 				versionValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineBasicColumnName( versionAttributeSource );
 					}
 				}
 		);
 
 		Property prop = new Property();
 		prop.setValue( versionValue );
 		bindProperty(
 				sourceDocument,
 				versionAttributeSource,
 				prop
 		);
 
 		// for version properties marked as being generated, make sure they are "always"
 		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
 		// but just to make sure...
 		if ( prop.getValueGenerationStrategy() != null ) {
 			if ( prop.getValueGenerationStrategy().getGenerationTiming() == GenerationTiming.INSERT ) {
 				throw new MappingException(
 						"'generated' attribute cannot be 'insert' for version/timestamp property",
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 
 		if ( versionAttributeSource.getUnsavedValue() != null ) {
 			versionValue.setNullValue( versionAttributeSource.getUnsavedValue() );
 		}
 		else {
 			versionValue.setNullValue( "undefined" );
 		}
 
 		rootEntityDescriptor.setVersion( prop );
 		rootEntityDescriptor.addProperty( prop );
 	}
 
 	private void bindEntityDiscriminator(
 			MappingDocument sourceDocument,
 			final EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final SimpleValue discriminatorValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 		rootEntityDescriptor.setDiscriminator( discriminatorValue );
 
 		String typeName = hierarchySource.getDiscriminatorSource().getExplicitHibernateTypeName();
 		if ( typeName == null ) {
 			typeName = "string";
 		}
 		bindSimpleValueType(
 				sourceDocument,
 				new HibernateTypeSourceImpl( typeName ),
 				discriminatorValue
 		);
 
 		relationalObjectBinder.bindColumnOrFormula(
 				sourceDocument,
 				hierarchySource.getDiscriminatorSource().getDiscriminatorRelationalValueSource(),
 				discriminatorValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineDiscriminatorColumnName(
 								hierarchySource.getDiscriminatorSource()
 						);
 					}
 				}
 		);
 
 		rootEntityDescriptor.setPolymorphic( true );
 		rootEntityDescriptor.setDiscriminatorInsertable( hierarchySource.getDiscriminatorSource().isInserted() );
 
 		// todo : currently isForced() is defined as boolean, not Boolean
 		//		although it has always been that way (DTD too)
 		final boolean force = hierarchySource.getDiscriminatorSource().isForced()
 				|| sourceDocument.getBuildingOptions().shouldImplicitlyForceDiscriminatorInSelect();
 		rootEntityDescriptor.setForceDiscriminator( force );
 	}
 
 	private void bindAllEntityAttributes(
 			MappingDocument mappingDocument,
 			EntitySource entitySource,
 			PersistentClass entityDescriptor) {
 		final EntityTableXref entityTableXref = mappingDocument.getMetadataCollector().getEntityTableXref(
 				entityDescriptor.getEntityName()
 		);
 		if ( entityTableXref == null ) {
 			throw new AssertionFailure(
 					String.format(
 							Locale.ENGLISH,
 							"Unable to locate EntityTableXref for entity [%s] : %s",
 							entityDescriptor.getEntityName(),
 							mappingDocument.getOrigin()
 					)
 			);
 		}
 
 		// make sure we bind secondary tables first!
 		for ( SecondaryTableSource secondaryTableSource : entitySource.getSecondaryTableMap().values() ) {
 			final Join secondaryTableJoin = new Join();
 			secondaryTableJoin.setPersistentClass( entityDescriptor );
 			bindSecondaryTable(
 					mappingDocument,
 					secondaryTableSource,
 					secondaryTableJoin,
 					entityTableXref
 			);
 			entityDescriptor.addJoin( secondaryTableJoin );
 		}
 
 		for ( AttributeSource attributeSource : entitySource.attributeSources() ) {
 			if ( PluralAttributeSource.class.isInstance( attributeSource ) ) {
 				// plural attribute
 				final Property attribute = createPluralAttribute(
 						mappingDocument,
 						(PluralAttributeSource) attributeSource,
 						entityDescriptor
 				);
 				entityDescriptor.addProperty( attribute );
 			}
 			else {
 				// singular attribute
 				if ( SingularAttributeSourceBasic.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceBasic basicAttributeSource = (SingularAttributeSourceBasic) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, basicAttributeSource.getName(), basicAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createBasicAttribute(
 							mappingDocument,
 							basicAttributeSource,
 							new SimpleValue( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							basicAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceEmbedded.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceEmbedded embeddedAttributeSource = (SingularAttributeSourceEmbedded) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, embeddedAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createEmbeddedAttribute(
 							mappingDocument,
 							(SingularAttributeSourceEmbedded) attributeSource,
 							new Component( mappingDocument.getMetadataCollector(), table, entityDescriptor ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							embeddedAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceManyToOne.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceManyToOne manyToOneAttributeSource = (SingularAttributeSourceManyToOne) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, manyToOneAttributeSource.getName(), manyToOneAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createManyToOneAttribute(
 							mappingDocument,
 							manyToOneAttributeSource,
 							new ManyToOne( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							manyToOneAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceOneToOne.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceOneToOne oneToOneAttributeSource = (SingularAttributeSourceOneToOne) attributeSource;
 					final Table table = entityDescriptor.getTable();
 					final Property attribute = createOneToOneAttribute(
 							mappingDocument,
 							oneToOneAttributeSource,
 							new OneToOne( mappingDocument.getMetadataCollector(), table, entityDescriptor ),
 							entityDescriptor.getClassName()
 					);
 					entityDescriptor.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							oneToOneAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceAny.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceAny anyAttributeSource = (SingularAttributeSourceAny) attributeSource;
 					final Identifier tableName = determineTable(
 							mappingDocument,
 							anyAttributeSource.getName(),
 							anyAttributeSource.getKeySource().getRelationalValueSources()
 					);
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createAnyAssociationAttribute(
 							mappingDocument,
 							anyAttributeSource,
 							new Any( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getEntityName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							anyAttributeSource.getNaturalIdMutability()
 					);
 				}
 			}
 		}
 
 		registerConstraintSecondPasses( mappingDocument, entitySource, entityTableXref );
 	}
 
 	private void handleNaturalIdBinding(
 			MappingDocument mappingDocument,
 			PersistentClass entityBinding,
 			Property attributeBinding,
 			NaturalIdMutability naturalIdMutability) {
 		if ( naturalIdMutability == NaturalIdMutability.NOT_NATURAL_ID ) {
 			return;
 		}
 
 		attributeBinding.setNaturalIdentifier( true );
 
 		if ( naturalIdMutability == NaturalIdMutability.IMMUTABLE ) {
 			attributeBinding.setUpdateable( false );
 		}
 
 		NaturalIdUniqueKeyBinder ukBinder = mappingDocument.getMetadataCollector().locateNaturalIdUniqueKeyBinder(
 				entityBinding.getEntityName()
 		);
 
 		if ( ukBinder == null ) {
 			ukBinder = new NaturalIdUniqueKeyBinderImpl( mappingDocument, entityBinding );
 			mappingDocument.getMetadataCollector().registerNaturalIdUniqueKeyBinder(
 					entityBinding.getEntityName(),
 					ukBinder
 			);
 		}
 
 		ukBinder.addAttributeBinding( attributeBinding );
 	}
 
 	private void registerConstraintSecondPasses(
 			MappingDocument mappingDocument,
 			EntitySource entitySource,
 			final EntityTableXref entityTableXref) {
 		if ( entitySource.getConstraints() == null ) {
 			return;
 		}
 
 		for ( ConstraintSource constraintSource : entitySource.getConstraints() ) {
 			final String logicalTableName = constraintSource.getTableName();
 			final Table table = entityTableXref.resolveTable( database.toIdentifier( logicalTableName ) );
 
 			mappingDocument.getMetadataCollector().addSecondPass(
 					new ConstraintSecondPass(
 							mappingDocument,
 							table,
 							constraintSource
 					)
 			);
 		}
 	}
 
 	private Property createPluralAttribute(
 			MappingDocument sourceDocument,
 			PluralAttributeSource attributeSource,
 			PersistentClass entityDescriptor) {
 		final Collection collectionBinding;
 
 		if ( attributeSource instanceof PluralAttributeSourceListImpl ) {
 			collectionBinding = new org.hibernate.mapping.List( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeListSecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(org.hibernate.mapping.List) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceSetImpl ) {
 			collectionBinding = new Set( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeSetSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceMapImpl ) {
 			collectionBinding = new org.hibernate.mapping.Map( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeMapSecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(org.hibernate.mapping.Map) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceBagImpl ) {
 			collectionBinding = new Bag( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeBagSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceIdBagImpl ) {
 			collectionBinding = new IdentifierBag( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeIdBagSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceArrayImpl ) {
 			final PluralAttributeSourceArray arraySource = (PluralAttributeSourceArray) attributeSource;
 			collectionBinding = new Array( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			( (Array) collectionBinding ).setElementClassName(
 					sourceDocument.qualifyClassName( arraySource.getElementClass() )
 			);
 
 			registerSecondPass(
 					new PluralAttributeArraySecondPass(
 							sourceDocument,
 							arraySource,
 							(Array) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourcePrimitiveArrayImpl ) {
 			collectionBinding = new PrimitiveArray( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributePrimitiveArraySecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(PrimitiveArray) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else {
 			throw new AssertionFailure(
 					"Unexpected PluralAttributeSource type : " + attributeSource.getClass().getName()
 			);
 		}
 
 		sourceDocument.getMetadataCollector().addCollectionBinding( collectionBinding );
 
 		final Property attribute = new Property();
 		attribute.setValue( collectionBinding );
 		bindProperty(
 				sourceDocument,
 				attributeSource,
 				attribute
 		);
 
 		return attribute;
 	}
 
 	private void bindCollectionMetadata(MappingDocument mappingDocument, PluralAttributeSource source, Collection binding) {
 		binding.setRole( source.getAttributeRole().getFullPath() );
 		binding.setInverse( source.isInverse() );
 		binding.setMutable( source.isMutable() );
 		binding.setOptimisticLocked( source.isIncludedInOptimisticLocking() );
 
 		if ( source.getCustomPersisterClassName() != null ) {
 			binding.setCollectionPersisterClass(
 					mappingDocument.getClassLoaderAccess().classForName(
 							mappingDocument.qualifyClassName( source.getCustomPersisterClassName() )
 					)
 			);
 		}
 
 		applyCaching( mappingDocument, source.getCaching(), binding );
 
 		// bind the collection type info
 		String typeName = source.getTypeInformation().getName();
 		Map typeParameters = new HashMap();
 		if ( typeName != null ) {
 			// see if there is a corresponding type-def
 			final TypeDefinition typeDef = mappingDocument.getMetadataCollector().getTypeDefinition( typeName );
 			if ( typeDef != null ) {
 				typeName = typeDef.getTypeImplementorClass().getName();
 				if ( typeDef.getParameters() != null ) {
 					typeParameters.putAll( typeDef.getParameters() );
 				}
 			}
 			else {
 				// it could be a unqualified class name, in which case we should qualify
 				// it with the implicit package name for this context, if one.
 				typeName = mappingDocument.qualifyClassName( typeName );
 			}
 		}
 		if ( source.getTypeInformation().getParameters() != null ) {
 			typeParameters.putAll( source.getTypeInformation().getParameters() );
 		}
 
 		binding.setTypeName( typeName );
 		binding.setTypeParameters( typeParameters );
 
 		if ( source.getFetchCharacteristics().getFetchTiming() == FetchTiming.DELAYED ) {
 			binding.setLazy( true );
 			binding.setExtraLazy( source.getFetchCharacteristics().isExtraLazy() );
 		}
 		else {
 			binding.setLazy( false );
 		}
 
 		switch ( source.getFetchCharacteristics().getFetchStyle() ) {
 			case SELECT: {
 				binding.setFetchMode( FetchMode.SELECT );
 				break;
 			}
 			case JOIN: {
 				binding.setFetchMode( FetchMode.JOIN );
 				break;
 			}
 			case BATCH: {
 				binding.setFetchMode( FetchMode.SELECT );
 				binding.setBatchSize( source.getFetchCharacteristics().getBatchSize() );
 				break;
 			}
 			case SUBSELECT: {
 				binding.setFetchMode( FetchMode.SELECT );
 				binding.setSubselectLoadable( true );
 				// todo : this could totally be done using a "symbol map" approach
 				binding.getOwner().setSubselectLoadableCollections( true );
 				break;
 			}
 			default: {
 				throw new AssertionFailure( "Unexpected FetchStyle : " + source.getFetchCharacteristics().getFetchStyle().name() );
 			}
 		}
 
 		for ( String name : source.getSynchronizedTableNames() ) {
 			binding.getSynchronizedTables().add( name );
 		}
 
 		binding.setWhere( source.getWhere() );
 		binding.setLoaderName( source.getCustomLoaderName() );
 		if ( source.getCustomSqlInsert() != null ) {
 			binding.setCustomSQLInsert(
 					source.getCustomSqlInsert().getSql(),
 					source.getCustomSqlInsert().isCallable(),
 					source.getCustomSqlInsert().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlUpdate() != null ) {
 			binding.setCustomSQLUpdate(
 					source.getCustomSqlUpdate().getSql(),
 					source.getCustomSqlUpdate().isCallable(),
 					source.getCustomSqlUpdate().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlDelete() != null ) {
 			binding.setCustomSQLDelete(
 					source.getCustomSqlDelete().getSql(),
 					source.getCustomSqlDelete().isCallable(),
 					source.getCustomSqlDelete().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlDeleteAll() != null ) {
 			binding.setCustomSQLDeleteAll(
 					source.getCustomSqlDeleteAll().getSql(),
 					source.getCustomSqlDeleteAll().isCallable(),
 					source.getCustomSqlDeleteAll().getCheckStyle()
 			);
 		}
 
 		if ( source instanceof Sortable ) {
 			final Sortable sortable = (Sortable) source;
 			if ( sortable.isSorted() ) {
 				binding.setSorted( true );
 				if ( ! sortable.getComparatorName().equals( "natural" ) ) {
 					binding.setComparatorClassName( sortable.getComparatorName() );
 				}
 			}
 			else {
 				binding.setSorted( false );
 			}
 		}
 
 		if ( source instanceof Orderable ) {
 			if ( ( (Orderable) source ).isOrdered() ) {
 				binding.setOrderBy( ( (Orderable) source ).getOrder() );
 			}
 		}
 
 		final String cascadeStyle = source.getCascadeStyleName();
 		if ( cascadeStyle != null && cascadeStyle.contains( "delete-orphan" ) ) {
 			binding.setOrphanDelete( true );
 		}
 
 		for ( FilterSource filterSource : source.getFilterSources() ) {
 			String condition = filterSource.getCondition();
 			if ( condition == null ) {
 				final FilterDefinition filterDefinition = mappingDocument.getMetadataCollector().getFilterDefinition( filterSource.getName() );
 				if ( filterDefinition != null ) {
 					condition = filterDefinition.getDefaultFilterCondition();
 				}
 			}
 
 			binding.addFilter(
 					filterSource.getName(),
 					condition,
 					filterSource.shouldAutoInjectAliases(),
 					filterSource.getAliasToTableMap(),
 					filterSource.getAliasToEntityMap()
 			);
 		}
 	}
 
 	private void applyCaching(MappingDocument mappingDocument, Caching caching, Collection collection) {
 		if ( caching == null || caching.getRequested() == TruthValue.UNKNOWN ) {
 			// see if JPA's SharedCacheMode indicates we should implicitly apply caching
 			switch ( mappingDocument.getBuildingOptions().getSharedCacheMode() ) {
 				case ALL: {
 					caching = new Caching(
 							null,
 							mappingDocument.getBuildingOptions().getImplicitCacheAccessType(),
 							false,
 							TruthValue.UNKNOWN
 					);
 					break;
 				}
 				case NONE: {
 					// Ideally we'd disable all caching...
 					break;
 				}
 				case ENABLE_SELECTIVE: {
 					// this is default behavior for hbm.xml
 					break;
 				}
 				case DISABLE_SELECTIVE: {
 					// really makes no sense for hbm.xml
 					break;
 				}
 				default: {
 					// null or UNSPECIFIED, nothing to do.  IMO for hbm.xml this is equivalent
 					// to ENABLE_SELECTIVE
 					break;
 				}
 			}
 		}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/model/source/spi/AttributeSource.java b/hibernate-core/src/main/java/org/hibernate/boot/model/source/spi/AttributeSource.java
index 26ebefa50b..31f2339283 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/model/source/spi/AttributeSource.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/source/spi/AttributeSource.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.model.source.spi;
 
 import org.hibernate.boot.model.source.internal.hbm.XmlElementMetadata;
 
 /**
  * Contract for sources of persistent attribute descriptions.
  * <p/>
  * These values are used to build {@link org.hibernate.mapping.Property} instances.
  *
  * @author Steve Ebersole
  */
 public interface AttributeSource extends ToolingHintContextContainer {
 	public XmlElementMetadata getSourceType();
 
 	/**
 	 * Obtain the attribute name.
 	 *
 	 * @return The attribute name. {@code null} is NOT allowed!
 	 */
 	public String getName();
 
 	/**
 	 * Attributes are (coarsely speaking) either singular or plural.
 	 *
 	 * @return {@code true} indicates the attribute is singular (and therefore castable
 	 * to {@link SingularAttributeSource}); {@code false} indicates it is plural (and
 	 * therefore castable to {@link PluralAttributeSource}).
 	 */
 	public boolean isSingular();
 
 	/**
 	 * Ugh.  This is the deprecated DOM4J entity-mode feature
 	 *
 	 * @return The xml node name
 	 */
 	public String getXmlNodeName();
 
 	public AttributePath getAttributePath();
 	public AttributeRole getAttributeRole();
 
 	/**
 	 * Obtain information about the Hibernate type ({@link org.hibernate.type.Type}) for this attribute.
 	 *
 	 * @return The Hibernate type information
 	 */
 	public HibernateTypeSource getTypeInformation();
 
 	/**
 	 * Obtain the name of the property accessor style used to access this attribute.
 	 *
 	 * @return The property accessor style for this attribute.
 	 *
-	 * @see org.hibernate.property.PropertyAccessor
+	 * @see org.hibernate.property.access.spi.PropertyAccessStrategy
 	 */
 	public String getPropertyAccessorName();
 
 	/**
 	 * If the containing entity is using optimistic locking, should this
 	 * attribute participate in that locking?  Meaning, should changes in the
 	 * value of this attribute at runtime indicate that the entity is now dirty
 	 * in terms of optimistic locking?
 	 *
 	 * @return {@code true} indicates it should be included; {@code false}, it should not.
 	 */
 	public boolean isIncludedInOptimisticLocking();
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java
index 3d84968e92..302b9f4763 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java
@@ -1,331 +1,335 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.registry;
 
 import java.io.File;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.boot.cfgxml.internal.ConfigLoader;
 import org.hibernate.boot.cfgxml.spi.LoadedConfig;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.cfg.Environment;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.Service;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.StandardServiceInitiators;
 import org.hibernate.service.internal.ProvidedService;
 import org.hibernate.service.spi.ServiceContributor;
 
 /**
  * Builder for standard {@link org.hibernate.service.ServiceRegistry} instances.
  *
  * @author Steve Ebersole
  * 
  * @see StandardServiceRegistryImpl
  * @see org.hibernate.boot.registry.BootstrapServiceRegistryBuilder
  */
 public class StandardServiceRegistryBuilder {
 	/**
 	 * The default resource name for a hibernate configuration xml file.
 	 */
 	public static final String DEFAULT_CFG_RESOURCE_NAME = "hibernate.cfg.xml";
 
 	private final Map settings;
 	private final List<StandardServiceInitiator> initiators = standardInitiatorList();
 	private final List<ProvidedService> providedServices = new ArrayList<ProvidedService>();
 
 	private boolean autoCloseRegistry = true;
 
 	private final BootstrapServiceRegistry bootstrapServiceRegistry;
 	private final ConfigLoader configLoader;
 	private final LoadedConfig aggregatedCfgXml;
 
 	/**
 	 * Create a default builder.
 	 */
 	public StandardServiceRegistryBuilder() {
 		this( new BootstrapServiceRegistryBuilder().enableAutoClose().build() );
 	}
 
 	/**
 	 * Create a builder with the specified bootstrap services.
 	 *
 	 * @param bootstrapServiceRegistry Provided bootstrap registry to use.
 	 */
 	public StandardServiceRegistryBuilder(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		this( bootstrapServiceRegistry,  LoadedConfig.baseline() );
 	}
 
 	/**
 	 * Create a builder with the specified bootstrap services.
 	 *
 	 * @param bootstrapServiceRegistry Provided bootstrap registry to use.
 	 */
 	public StandardServiceRegistryBuilder(BootstrapServiceRegistry bootstrapServiceRegistry, LoadedConfig loadedConfigBaseline) {
 		this.settings = Environment.getProperties();
 		this.bootstrapServiceRegistry = bootstrapServiceRegistry;
 		this.configLoader = new ConfigLoader( bootstrapServiceRegistry );
 		this.aggregatedCfgXml = loadedConfigBaseline;
 	}
 
 	/**
 	 * Intended for internal testing use only!!
 	 */
 	public LoadedConfig getAggregatedCfgXml() {
 		return aggregatedCfgXml;
 	}
 
 	/**
 	 * Used from the {@link #initiators} variable initializer
 	 *
 	 * @return List of standard initiators
 	 */
 	private static List<StandardServiceInitiator> standardInitiatorList() {
 		final List<StandardServiceInitiator> initiators = new ArrayList<StandardServiceInitiator>();
 		initiators.addAll( StandardServiceInitiators.LIST );
 		return initiators;
 	}
 
 	public BootstrapServiceRegistry getBootstrapServiceRegistry() {
 		return bootstrapServiceRegistry;
 	}
 
 	/**
 	 * Read settings from a {@link java.util.Properties} file by resource name.
 	 *
 	 * Differs from {@link #configure()} and {@link #configure(String)} in that here we expect to read a
 	 * {@link java.util.Properties} file while for {@link #configure} we read the XML variant.
 	 *
 	 * @param resourceName The name by which to perform a resource look up for the properties file.
 	 *
 	 * @return this, for method chaining
 	 *
 	 * @see #configure()
 	 * @see #configure(String)
 	 */
 	@SuppressWarnings( {"unchecked"})
 	public StandardServiceRegistryBuilder loadProperties(String resourceName) {
 		settings.putAll( configLoader.loadProperties( resourceName ) );
 		return this;
 	}
 
 	/**
 	 * Read settings from a {@link java.util.Properties} file by File reference
 	 *
 	 * Differs from {@link #configure()} and {@link #configure(String)} in that here we expect to read a
 	 * {@link java.util.Properties} file while for {@link #configure} we read the XML variant.
 	 *
 	 * @param file The properties File reference
 	 *
 	 * @return this, for method chaining
 	 *
 	 * @see #configure()
 	 * @see #configure(String)
 	 */
 	@SuppressWarnings( {"unchecked"})
 	public StandardServiceRegistryBuilder loadProperties(File file) {
 		settings.putAll( configLoader.loadProperties( file ) );
 		return this;
 	}
 
 	/**
 	 * Read setting information from an XML file using the standard resource location.
 	 *
 	 * @return this, for method chaining
 	 *
 	 * @see #DEFAULT_CFG_RESOURCE_NAME
 	 * @see #configure(String)
 	 * @see #loadProperties(String)
 	 */
 	public StandardServiceRegistryBuilder configure() {
 		return configure( DEFAULT_CFG_RESOURCE_NAME );
 	}
 
 	/**
 	 * Read setting information from an XML file using the named resource location.
 	 *
 	 * @param resourceName The named resource
 	 *
 	 * @return this, for method chaining
 	 */
 	public StandardServiceRegistryBuilder configure(String resourceName) {
 		return configure( configLoader.loadConfigXmlResource( resourceName ) );
 	}
 
 	public StandardServiceRegistryBuilder configure(File configurationFile) {
 		return configure( configLoader.loadConfigXmlFile( configurationFile ) );
 	}
 
 	public StandardServiceRegistryBuilder configure(URL url) {
 		return configure( configLoader.loadConfigXmlUrl( url ) );
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public StandardServiceRegistryBuilder configure(LoadedConfig loadedConfig) {
 		aggregatedCfgXml.merge( loadedConfig );
 		settings.putAll( loadedConfig.getConfigurationValues() );
 
 		return this;
 	}
 
 	/**
 	 * Apply a setting value.
 	 *
 	 * @param settingName The name of the setting
 	 * @param value The value to use.
 	 *
 	 * @return this, for method chaining
 	 */
 	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
 	public StandardServiceRegistryBuilder applySetting(String settingName, Object value) {
 		settings.put( settingName, value );
 		return this;
 	}
 
 	/**
 	 * Apply a groups of setting values.
 	 *
 	 * @param settings The incoming settings to apply
 	 *
 	 * @return this, for method chaining
 	 */
 	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
 	public StandardServiceRegistryBuilder applySettings(Map settings) {
 		this.settings.putAll( settings );
 		return this;
 	}
 
 	/**
 	 * Adds a service initiator.
 	 *
 	 * @param initiator The initiator to be added
 	 *
 	 * @return this, for method chaining
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public StandardServiceRegistryBuilder addInitiator(StandardServiceInitiator initiator) {
 		initiators.add( initiator );
 		return this;
 	}
 
 	/**
 	 * Adds a user-provided service.
 	 *
 	 * @param serviceRole The role of the service being added
 	 * @param service The service implementation
 	 *
 	 * @return this, for method chaining
 	 */
 	@SuppressWarnings( {"unchecked"})
 	public StandardServiceRegistryBuilder addService(final Class serviceRole, final Service service) {
 		providedServices.add( new ProvidedService( serviceRole, service ) );
 		return this;
 	}
 
 	/**
 	 * By default, when a ServiceRegistry is no longer referenced by any other
 	 * registries as a parent it will be closed.
 	 * <p/>
 	 * Some applications that explicitly build "shared registries" may want to
 	 * circumvent that behavior.
 	 * <p/>
 	 * This method indicates that the registry being built should not be
 	 * automatically closed.  The caller agrees to take responsibility to
 	 * close it themselves.
 	 *
 	 * @return this, for method chaining
 	 */
 	public StandardServiceRegistryBuilder disableAutoClose() {
 		this.autoCloseRegistry = false;
 		return this;
 	}
 
 	/**
 	 * See the discussion on {@link #disableAutoClose}.  This method enables
 	 * the auto-closing.
 	 *
 	 * @return this, for method chaining
 	 */
 	public StandardServiceRegistryBuilder enableAutoClose() {
 		this.autoCloseRegistry = true;
 		return this;
 	}
 
 	/**
 	 * Build the StandardServiceRegistry.
 	 *
 	 * @return The StandardServiceRegistry.
 	 */
 	@SuppressWarnings("unchecked")
 	public StandardServiceRegistry build() {
 		applyServiceContributingIntegrators();
 		applyServiceContributors();
 
 		final Map settingsCopy = new HashMap();
 		settingsCopy.putAll( settings );
 		settingsCopy.put( org.hibernate.boot.cfgxml.spi.CfgXmlAccessService.LOADED_CONFIG_KEY, aggregatedCfgXml );
 		Environment.verifyProperties( settingsCopy );
 		ConfigurationHelper.resolvePlaceHolders( settingsCopy );
 
 		return new StandardServiceRegistryImpl(
 				autoCloseRegistry,
 				bootstrapServiceRegistry,
 				initiators,
 				providedServices,
 				settingsCopy
 		);
 	}
 
 	@SuppressWarnings("deprecation")
 	private void applyServiceContributingIntegrators() {
 		for ( Integrator integrator : bootstrapServiceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			if ( org.hibernate.integrator.spi.ServiceContributingIntegrator.class.isInstance( integrator ) ) {
 				org.hibernate.integrator.spi.ServiceContributingIntegrator.class.cast( integrator ).prepareServices( this );
 			}
 		}
 	}
 
 	private void applyServiceContributors() {
 		final Iterable<ServiceContributor> serviceContributors =
 				bootstrapServiceRegistry.getService( ClassLoaderService.class )
 						.loadJavaServices( ServiceContributor.class );
 
 		for ( ServiceContributor serviceContributor : serviceContributors ) {
 			serviceContributor.contribute( this );
 		}
 	}
 
 	/**
 	 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows
 	 * code to configure the builder and access that to configure Configuration object (used from HEM atm).
 	 *
 	 * @return The settings map.
 	 *
 	 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.
 	 * This allows code to configure the builder and access that to configure Configuration object.
 	 */
 	@Deprecated
 	public Map getSettings() {
 		return settings;
 	}
 
 	/**
 	 * Destroy a service registry.  Applications should only destroy registries they have explicitly created.
 	 *
 	 * @param serviceRegistry The registry to be closed.
 	 */
 	public static void destroy(ServiceRegistry serviceRegistry) {
+		if ( serviceRegistry == null ) {
+			return;
+		}
+
 		( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
index 911a921a11..a46297f8b8 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
@@ -1,343 +1,358 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.registry.classloading.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Proxy;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ClassLoaderHelper;
 
 /**
  * Standard implementation of the service for interacting with class loaders
  *
  * @author Steve Ebersole
  * @author Sanne Grinovero
  */
 public class ClassLoaderServiceImpl implements ClassLoaderService {
 
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( ClassLoaderServiceImpl.class );
 
 	private final ConcurrentMap<Class, ServiceLoader> serviceLoaders = new ConcurrentHashMap<Class, ServiceLoader>();
 	private volatile AggregatedClassLoader aggregatedClassLoader;
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with standard set-up
 	 */
 	public ClassLoaderServiceImpl() {
 		this( ClassLoaderServiceImpl.class.getClassLoader() );
 	}
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with the given ClassLoader
 	 *
 	 * @param classLoader The ClassLoader to use
 	 */
 	public ClassLoaderServiceImpl(ClassLoader classLoader) {
 		this( Collections.singletonList( classLoader ) );
 	}
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with the given ClassLoader instances
 	 *
 	 * @param providedClassLoaders The ClassLoader instances to use
 	 */
 	public ClassLoaderServiceImpl(Collection<ClassLoader> providedClassLoaders) {
 		final LinkedHashSet<ClassLoader> orderedClassLoaderSet = new LinkedHashSet<ClassLoader>();
 
 		// first, add all provided class loaders, if any
 		if ( providedClassLoaders != null ) {
 			for ( ClassLoader classLoader : providedClassLoaders ) {
 				if ( classLoader != null ) {
 					orderedClassLoaderSet.add( classLoader );
 				}
 			}
 		}
 
 		// normalize adding known class-loaders...
 		// then the Hibernate class loader
 		orderedClassLoaderSet.add( ClassLoaderServiceImpl.class.getClassLoader() );
 
 		// then the TCCL, if one...
 		final ClassLoader tccl = locateTCCL();
 		if ( tccl != null ) {
 			orderedClassLoaderSet.add( tccl );
 		}
 		// finally the system classloader
 		final ClassLoader sysClassLoader = locateSystemClassLoader();
 		if ( sysClassLoader != null ) {
 			orderedClassLoaderSet.add( sysClassLoader );
 		}
 
 		// now build the aggregated class loader...
 		this.aggregatedClassLoader = new AggregatedClassLoader( orderedClassLoaderSet );
 	}
 
 	/**
 	 * No longer used/supported!
 	 *
 	 * @param configValues The config values
 	 *
 	 * @return The built service
 	 *
 	 * @deprecated No longer used/supported!
 	 */
 	@Deprecated
 	@SuppressWarnings({"UnusedDeclaration", "unchecked", "deprecation"})
 	public static ClassLoaderServiceImpl fromConfigSettings(Map configValues) {
 		final List<ClassLoader> providedClassLoaders = new ArrayList<ClassLoader>();
 
 		final Collection<ClassLoader> classLoaders = (Collection<ClassLoader>) configValues.get( AvailableSettings.CLASSLOADERS );
 		if ( classLoaders != null ) {
 			for ( ClassLoader classLoader : classLoaders ) {
 				providedClassLoaders.add( classLoader );
 			}
 		}
 
 		addIfSet( providedClassLoaders, AvailableSettings.APP_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.RESOURCES_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.HIBERNATE_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.ENVIRONMENT_CLASSLOADER, configValues );
 
 		if ( providedClassLoaders.isEmpty() ) {
 			log.debugf( "Incoming config yielded no classloaders; adding standard SE ones" );
 			final ClassLoader tccl = locateTCCL();
 			if ( tccl != null ) {
 				providedClassLoaders.add( tccl );
 			}
 			providedClassLoaders.add( ClassLoaderServiceImpl.class.getClassLoader() );
 		}
 
 		return new ClassLoaderServiceImpl( providedClassLoaders );
 	}
 
 	private static void addIfSet(List<ClassLoader> providedClassLoaders, String name, Map configVales) {
 		final ClassLoader providedClassLoader = (ClassLoader) configVales.get( name );
 		if ( providedClassLoader != null ) {
 			providedClassLoaders.add( providedClassLoader );
 		}
 	}
 
 	private static ClassLoader locateSystemClassLoader() {
 		try {
 			return ClassLoader.getSystemClassLoader();
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private static ClassLoader locateTCCL() {
 		try {
-			return ClassLoaderHelper.getContextClassLoader();
+			return Thread.currentThread().getContextClassLoader();
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private static class AggregatedClassLoader extends ClassLoader {
 		private final ClassLoader[] individualClassLoaders;
 
 		private AggregatedClassLoader(final LinkedHashSet<ClassLoader> orderedClassLoaderSet) {
 			super( null );
 			individualClassLoaders = orderedClassLoaderSet.toArray( new ClassLoader[orderedClassLoaderSet.size()] );
 		}
 
 		@Override
 		public Enumeration<URL> getResources(String name) throws IOException {
 			final LinkedHashSet<URL> resourceUrls = new LinkedHashSet<URL>();
 
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				final Enumeration<URL> urls = classLoader.getResources( name );
 				while ( urls.hasMoreElements() ) {
 					resourceUrls.add( urls.nextElement() );
 				}
 			}
 
 			return new Enumeration<URL>() {
 				final Iterator<URL> resourceUrlIterator = resourceUrls.iterator();
 
 				@Override
 				public boolean hasMoreElements() {
 					return resourceUrlIterator.hasNext();
 				}
 
 				@Override
 				public URL nextElement() {
 					return resourceUrlIterator.next();
 				}
 			};
 		}
 
 		@Override
 		protected URL findResource(String name) {
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				final URL resource = classLoader.getResource( name );
 				if ( resource != null ) {
 					return resource;
 				}
 			}
 			return super.findResource( name );
 		}
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				try {
 					return classLoader.loadClass( name );
 				}
 				catch (Exception ignore) {
 				}
 			}
 
 			throw new ClassNotFoundException( "Could not load requested class : " + name );
 		}
 
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> Class<T> classForName(String className) {
 		try {
 			return (Class<T>) Class.forName( className, true, getAggregatedClassLoader() );
 		}
 		catch (Exception e) {
 			throw new ClassLoadingException( "Unable to load class [" + className + "]", e );
 		}
 	}
 
 	@Override
 	public URL locateResource(String name) {
 		// first we try name as a URL
 		try {
 			return new URL( name );
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			return getAggregatedClassLoader().getResource( name );
 		}
 		catch (Exception ignore) {
 		}
 
 		return null;
 	}
 
 	@Override
 	public InputStream locateResourceStream(String name) {
 		// first we try name as a URL
 		try {
 			log.tracef( "trying via [new URL(\"%s\")]", name );
 			return new URL( name ).openStream();
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", name );
 			final InputStream stream = getAggregatedClassLoader().getResourceAsStream( name );
 			if ( stream != null ) {
 				return stream;
 			}
 		}
 		catch (Exception ignore) {
 		}
 
 		final String stripped = name.startsWith( "/" ) ? name.substring( 1 ) : null;
 
 		if ( stripped != null ) {
 			try {
 				log.tracef( "trying via [new URL(\"%s\")]", stripped );
 				return new URL( stripped ).openStream();
 			}
 			catch (Exception ignore) {
 			}
 
 			try {
 				log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", stripped );
 				final InputStream stream = getAggregatedClassLoader().getResourceAsStream( stripped );
 				if ( stream != null ) {
 					return stream;
 				}
 			}
 			catch (Exception ignore) {
 			}
 		}
 
 		return null;
 	}
 
 	@Override
 	public List<URL> locateResources(String name) {
 		final ArrayList<URL> urls = new ArrayList<URL>();
 		try {
 			final Enumeration<URL> urlEnumeration = getAggregatedClassLoader().getResources( name );
 			if ( urlEnumeration != null && urlEnumeration.hasMoreElements() ) {
 				while ( urlEnumeration.hasMoreElements() ) {
 					urls.add( urlEnumeration.nextElement() );
 				}
 			}
 		}
 		catch (Exception ignore) {
 		}
 
 		return urls;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public <S> Collection<S> loadJavaServices(Class<S> serviceContract) {
 		ServiceLoader<S> serviceLoader = serviceLoaders.get( serviceContract );
 		if ( serviceLoader == null ) {
 			serviceLoader = ServiceLoader.load( serviceContract, getAggregatedClassLoader() );
 			serviceLoaders.put( serviceContract, serviceLoader );
 		}
 		final LinkedHashSet<S> services = new LinkedHashSet<S>();
 		for ( S service : serviceLoader ) {
 			services.add( service );
 		}
 		return services;
 	}
 
+	@Override
+	@SuppressWarnings("unchecked")
+	public <T> T generateProxy(InvocationHandler handler, Class... interfaces) {
+		return (T) Proxy.newProxyInstance(
+				getAggregatedClassLoader(),
+				interfaces,
+				handler
+		);
+	}
+
+	@Override
+	public <T> T workWithClassLoader(Work<T> work) {
+		return work.doWork( getAggregatedClassLoader() );
+	}
 
 	private ClassLoader getAggregatedClassLoader() {
 		final ClassLoader aggregated = this.aggregatedClassLoader;
 		if ( aggregated == null ) {
 			throw log.usingStoppedClassLoaderService();
 		}
 		return aggregated;
 	}
 
 	@Override
 	public void stop() {
 		for ( ServiceLoader serviceLoader : serviceLoaders.values() ) {
 			serviceLoader.reload(); // clear service loader providers
 		}
 		serviceLoaders.clear();
 		//Avoid ClassLoader leaks
 		this.aggregatedClassLoader = null;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
index 0735423406..ba455e0108 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
@@ -1,74 +1,83 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.registry.classloading.spi;
 
 import java.io.InputStream;
+import java.lang.reflect.InvocationHandler;
 import java.net.URL;
 import java.util.Collection;
 import java.util.List;
 
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A service for interacting with class loaders.
  *
  * @author Steve Ebersole
  */
 public interface ClassLoaderService extends Service, Stoppable {
 	/**
 	 * Locate a class by name.
 	 *
 	 * @param className The name of the class to locate
 	 * @param <T> The returned class type.
 	 *
 	 * @return The class reference
 	 *
 	 * @throws ClassLoadingException Indicates the class could not be found
 	 */
 	public <T> Class<T> classForName(String className);
 
 	/**
 	 * Locate a resource by name (classpath lookup).
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The located URL; may return {@code null} to indicate the resource was not found
 	 */
 	public URL locateResource(String name);
 
 	/**
 	 * Locate a resource by name (classpath lookup) and gets its stream.
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The stream of the located resource; may return {@code null} to indicate the resource was not found
 	 */
 	public InputStream locateResourceStream(String name);
 
 	/**
 	 * Locate a series of resource by name (classpath lookup).
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The list of URL matching; may return {@code null} to indicate the resource was not found
 	 */
 	public List<URL> locateResources(String name);
 
 	/**
 	 * Discovers and instantiates implementations of the named service contract.
 	 * <p/>
 	 * NOTE : the terms service here is used differently than {@link Service}.  Instead here we are talking about
 	 * services as defined by {@link java.util.ServiceLoader}.
 	 *
 	 * @param serviceContract The java type defining the service contract
 	 * @param <S> The type of the service contract
 	 *     
 	 * @return The ordered set of discovered services.
 	 */
 	public <S> Collection<S> loadJavaServices(Class<S> serviceContract);
+
+	<T> T generateProxy(InvocationHandler handler, Class... interfaces);
+
+	interface Work<T> {
+		T doWork(ClassLoader classLoader);
+	}
+
+	<T> T workWithClassLoader(Work<T> work);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/ClassLoaderAccessDelegateImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/ClassLoaderAccessDelegateImpl.java
new file mode 100644
index 0000000000..0285749239
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/ClassLoaderAccessDelegateImpl.java
@@ -0,0 +1,28 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.boot.spi;
+
+import java.net.URL;
+
+/**
+ * A ClassLoaderAccess implementation based on delegation
+ *
+ * @author Steve Ebersole
+ */
+public abstract class ClassLoaderAccessDelegateImpl implements ClassLoaderAccess {
+	protected abstract ClassLoaderAccess getDelegate();
+
+	@Override
+	public <T> Class<T> classForName(String name) {
+		return getDelegate().classForName( name );
+	}
+
+	@Override
+	public URL locateResource(String resourceName) {
+		return getDelegate().locateResource( resourceName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/MappingDefaults.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/MappingDefaults.java
index fb60011307..f3cb163c09 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/spi/MappingDefaults.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/MappingDefaults.java
@@ -1,128 +1,128 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.boot.spi;
 
 import org.hibernate.cache.spi.access.AccessType;
 
 /**
  * Defines a (contextual) set of values to use as defaults in the absence of related mapping information.  The
  * context here is conceptually a stack.  The "global" level is configuration settings.
  *
  * @author Steve Ebersole
  * @author Gail Badner
  *
  * @since 5.0
  */
 public interface MappingDefaults {
 	public static final String DEFAULT_IDENTIFIER_COLUMN_NAME = "id";
 	public static final String DEFAULT_TENANT_IDENTIFIER_COLUMN_NAME = "tenant_id";
 	public static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "class";
 	public static final String DEFAULT_CASCADE_NAME = "none";
 	public static final String DEFAULT_PROPERTY_ACCESS_NAME = "property";
 	/**
 	 * Identifies the database schema name to use if none specified in the mapping.
 	 *
 	 * @return The implicit schema name; may be {@code null}
 	 */
 	public String getImplicitSchemaName();
 
 	/**
 	 * Identifies the database catalog name to use if none specified in the mapping.
 	 *
 	 * @return The implicit catalog name; may be {@code null}
 	 */
 	public String getImplicitCatalogName();
 
 	/**
 	 * Should all database identifiers encountered in this context be implicitly quoted?
 	 *
 	 * {@code true} indicates that all identifier encountered within this context should be
 	 * quoted.  {@code false} indicates indicates that identifiers within this context are
 	 * onl;y quoted if explicitly quoted.
 	 *
 	 * @return {@code true}/{@code false}
 	 */
 	public boolean shouldImplicitlyQuoteIdentifiers();
 
 	/**
 	 * Identifies the column name to use for the identifier column if none specified in
 	 * the mapping.
 	 *
 	 * @return The implicit identifier column name
 	 */
 	public String getImplicitIdColumnName();
 
 	/**
 	 * Identifies the column name to use for the tenant identifier column if none is
 	 * specified in the mapping.
 	 *
 	 * @return The implicit tenant identifier column name
 	 */
 	public String getImplicitTenantIdColumnName();
 
 	/**
 	 * Identifies the column name to use for the discriminator column if none specified
 	 * in the mapping.
 	 *
 	 * @return The implicit discriminator column name
 	 */
 	public String getImplicitDiscriminatorColumnName();
 
 	/**
 	 * Identifies the package name to use if none specified in the mapping.  Really only
 	 * pertinent for {@code hbm.xml} mappings.
 	 *
 	 * @return The implicit package name.
 	 */
 	public String getImplicitPackageName();
 
 	/**
 	 * Is auto-importing of entity (short) names enabled?
 	 *
 	 * @return {@code true} if auto-importing is enabled; {@code false} otherwise.
 	 */
 	public boolean isAutoImportEnabled();
 
 	/**
 	 * Identifies the cascade style to apply to associations if none specified in the mapping.
 	 *
 	 * @return The implicit cascade style
 	 */
 	public String getImplicitCascadeStyleName();
 
 	/**
-	 * Identifies the default {@link org.hibernate.property.PropertyAccessor} name to use if none specified in the
+	 * Identifies the default {@link org.hibernate.property.access.spi.PropertyAccessStrategy} name to use if none specified in the
 	 * mapping.
 	 *
 	 * @return The implicit property accessor name
 	 *
-	 * @see org.hibernate.property.PropertyAccessorFactory
+	 * @see org.hibernate.property.access.spi.PropertyAccessStrategy
 	 */
 	public String getImplicitPropertyAccessorName();
 
 	/**
 	 * Identifies whether singular associations (many-to-one, one-to-one) are lazy
 	 * by default if not specified in the mapping.
 	 *
 	 * @return The implicit association laziness
 	 */
 	public boolean areEntitiesImplicitlyLazy();
 
 	/**
 	 * Identifies whether plural attributes are lazy by default if not specified in the mapping.
 	 *
 	 * @return The implicit association laziness
 	 */
 	public boolean areCollectionsImplicitlyLazy();
 
 	/**
 	 * The cache access type to use if none is specified
 	 *
 	 * @return The implicit cache access type.
 	 */
 	public AccessType getImplicitCacheAccessType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java b/hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java
index 2d38e4bd8f..b07f89ea60 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java
@@ -1,2198 +1,2196 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg;
 
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import javax.persistence.Basic;
 import javax.persistence.Cacheable;
 import javax.persistence.CollectionTable;
 import javax.persistence.Column;
 import javax.persistence.ConstraintMode;
 import javax.persistence.DiscriminatorColumn;
 import javax.persistence.DiscriminatorType;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.ElementCollection;
 import javax.persistence.Embeddable;
 import javax.persistence.Embedded;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.InheritanceType;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.JoinTable;
 import javax.persistence.ManyToMany;
 import javax.persistence.ManyToOne;
 import javax.persistence.MapKey;
 import javax.persistence.MapKeyColumn;
 import javax.persistence.MapKeyJoinColumn;
 import javax.persistence.MapKeyJoinColumns;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.MapsId;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
 import javax.persistence.NamedStoredProcedureQueries;
 import javax.persistence.NamedStoredProcedureQuery;
 import javax.persistence.OneToMany;
 import javax.persistence.OneToOne;
 import javax.persistence.OrderColumn;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.PrimaryKeyJoinColumns;
 import javax.persistence.SequenceGenerator;
 import javax.persistence.SharedCacheMode;
 import javax.persistence.SqlResultSetMapping;
 import javax.persistence.SqlResultSetMappings;
 import javax.persistence.Table;
 import javax.persistence.TableGenerator;
 import javax.persistence.UniqueConstraint;
 import javax.persistence.Version;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.BatchSize;
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.Cascade;
 import org.hibernate.annotations.CascadeType;
 import org.hibernate.annotations.Check;
 import org.hibernate.annotations.CollectionId;
 import org.hibernate.annotations.Columns;
 import org.hibernate.annotations.DiscriminatorFormula;
 import org.hibernate.annotations.DiscriminatorOptions;
 import org.hibernate.annotations.Fetch;
 import org.hibernate.annotations.FetchProfile;
 import org.hibernate.annotations.FetchProfiles;
 import org.hibernate.annotations.Filter;
 import org.hibernate.annotations.FilterDef;
 import org.hibernate.annotations.FilterDefs;
 import org.hibernate.annotations.Filters;
 import org.hibernate.annotations.ForeignKey;
 import org.hibernate.annotations.Formula;
 import org.hibernate.annotations.GenericGenerator;
 import org.hibernate.annotations.GenericGenerators;
 import org.hibernate.annotations.Index;
 import org.hibernate.annotations.LazyToOne;
 import org.hibernate.annotations.LazyToOneOption;
 import org.hibernate.annotations.ListIndexBase;
 import org.hibernate.annotations.ManyToAny;
 import org.hibernate.annotations.MapKeyType;
 import org.hibernate.annotations.NaturalId;
 import org.hibernate.annotations.NaturalIdCache;
 import org.hibernate.annotations.NotFound;
 import org.hibernate.annotations.NotFoundAction;
 import org.hibernate.annotations.OnDelete;
 import org.hibernate.annotations.OnDeleteAction;
 import org.hibernate.annotations.OrderBy;
 import org.hibernate.annotations.ParamDef;
 import org.hibernate.annotations.Parameter;
 import org.hibernate.annotations.Parent;
 import org.hibernate.annotations.Proxy;
 import org.hibernate.annotations.Sort;
 import org.hibernate.annotations.SortComparator;
 import org.hibernate.annotations.SortNatural;
 import org.hibernate.annotations.Source;
 import org.hibernate.annotations.Tuplizer;
 import org.hibernate.annotations.Tuplizers;
 import org.hibernate.annotations.TypeDef;
 import org.hibernate.annotations.TypeDefs;
 import org.hibernate.annotations.Where;
 import org.hibernate.annotations.common.reflection.ClassLoadingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XAnnotatedElement;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XMethod;
 import org.hibernate.annotations.common.reflection.XPackage;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.boot.model.IdGeneratorStrategyInterpreter;
 import org.hibernate.boot.model.IdentifierGeneratorDefinition;
 import org.hibernate.boot.model.TypeDefinition;
 import org.hibernate.boot.spi.InFlightMetadataCollector.EntityTableXref;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.cfg.annotations.CollectionBinder;
 import org.hibernate.cfg.annotations.EntityBinder;
 import org.hibernate.cfg.annotations.MapKeyColumnDelegator;
 import org.hibernate.cfg.annotations.MapKeyJoinColumnDelegator;
 import org.hibernate.cfg.annotations.Nullability;
 import org.hibernate.cfg.annotations.PropertyBinder;
 import org.hibernate.cfg.annotations.QueryBinder;
 import org.hibernate.cfg.annotations.SimpleValueBinder;
 import org.hibernate.cfg.annotations.TableBinder;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.id.PersistentIdentifierGenerator;
+import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.mapping.Any;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Constraint;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.IdGenerator;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.mapping.ToOne;
 import org.hibernate.mapping.UnionSubclass;
 
-import org.jboss.logging.Logger;
+import static org.hibernate.internal.CoreLogging.messageLogger;
 
 /**
  * JSR 175 annotation binder which reads the annotations from classes, applies the
  * principles of the EJB3 spec and produces the Hibernate configuration-time metamodel
  * (the classes in the {@code org.hibernate.mapping} package)
+ * <p/>
+ * Some design description
+ * I tried to remove any link to annotation except from the 2 first level of
+ * method call.
+ * It'll enable to:
+ *   - facilitate annotation overriding
+ *   - mutualize one day xml and annotation binder (probably a dream though)
+ *   - split this huge class in smaller mapping oriented classes
+ *
+ * bindSomething usually create the mapping container and is accessed by one of the 2 first level method
+ * makeSomething usually create the mapping container and is accessed by bindSomething[else]
+ * fillSomething take the container into parameter and fill it.
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 @SuppressWarnings("unchecked")
 public final class AnnotationBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, AnnotationBinder.class.getName() );
-
-    /*
-     * Some design description
-     * I tried to remove any link to annotation except from the 2 first level of
-     * method call.
-     * It'll enable to:
-     *   - facilitate annotation overriding
-     *   - mutualize one day xml and annotation binder (probably a dream though)
-     *   - split this huge class in smaller mapping oriented classes
-     *
-     * bindSomething usually create the mapping container and is accessed by one of the 2 first level method
-     * makeSomething usually create the mapping container and is accessed by bindSomething[else]
-     * fillSomething take the container into parameter and fill it.
-     */
+	private static final CoreMessageLogger LOG = messageLogger( AnnotationBinder.class );
 
 	private AnnotationBinder() {
 	}
 
 	public static void bindDefaults(MetadataBuildingContext context) {
 		Map defaults = context.getBuildingOptions().getReflectionManager().getDefaults();
 
 		// id generators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		{
 			List<SequenceGenerator> anns = ( List<SequenceGenerator> ) defaults.get( SequenceGenerator.class );
 			if ( anns != null ) {
 				for ( SequenceGenerator ann : anns ) {
 					IdentifierGeneratorDefinition idGen = buildIdGenerator( ann, context );
 					if ( idGen != null ) {
 						context.getMetadataCollector().addDefaultIdentifierGenerator( idGen );
 					}
 				}
 			}
 		}
 		{
 			List<TableGenerator> anns = ( List<TableGenerator> ) defaults.get( TableGenerator.class );
 			if ( anns != null ) {
 				for ( TableGenerator ann : anns ) {
 					IdentifierGeneratorDefinition idGen = buildIdGenerator( ann, context );
 					if ( idGen != null ) {
 						context.getMetadataCollector().addDefaultIdentifierGenerator( idGen );
 					}
 				}
 			}
 		}
 
 		// queries ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		{
 			List<NamedQuery> anns = ( List<NamedQuery> ) defaults.get( NamedQuery.class );
 			if ( anns != null ) {
 				for ( NamedQuery ann : anns ) {
 					QueryBinder.bindQuery( ann, context, true );
 				}
 			}
 		}
 		{
 			List<NamedNativeQuery> anns = ( List<NamedNativeQuery> ) defaults.get( NamedNativeQuery.class );
 			if ( anns != null ) {
 				for ( NamedNativeQuery ann : anns ) {
 					QueryBinder.bindNativeQuery( ann, context, true );
 				}
 			}
 		}
 
 		// result-set-mappings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		{
 			List<SqlResultSetMapping> anns = ( List<SqlResultSetMapping> ) defaults.get( SqlResultSetMapping.class );
 			if ( anns != null ) {
 				for ( SqlResultSetMapping ann : anns ) {
 					QueryBinder.bindSqlResultSetMapping( ann, context, true );
 				}
 			}
 		}
 
 		// stored procs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		{
 			final List<NamedStoredProcedureQuery> annotations =
 					(List<NamedStoredProcedureQuery>) defaults.get( NamedStoredProcedureQuery.class );
 			if ( annotations != null ) {
 				for ( NamedStoredProcedureQuery annotation : annotations ) {
 					bindNamedStoredProcedureQuery( annotation, context, true );
 				}
 			}
 		}
 		{
 			final List<NamedStoredProcedureQueries> annotations =
 					(List<NamedStoredProcedureQueries>) defaults.get( NamedStoredProcedureQueries.class );
 			if ( annotations != null ) {
 				for ( NamedStoredProcedureQueries annotation : annotations ) {
 					bindNamedStoredProcedureQueries( annotation, context, true );
 				}
 			}
 		}
 	}
 
 	public static void bindPackage(String packageName, MetadataBuildingContext context) {
 		XPackage pckg;
 		try {
 			pckg = context.getBuildingOptions().getReflectionManager().packageForName( packageName );
 		}
 		catch (ClassLoadingException e) {
 			LOG.packageNotFound( packageName );
 			return;
 		}
 		catch ( ClassNotFoundException cnf ) {
 			LOG.packageNotFound( packageName );
 			return;
 		}
 
 		if ( pckg.isAnnotationPresent( SequenceGenerator.class ) ) {
 			SequenceGenerator ann = pckg.getAnnotation( SequenceGenerator.class );
 			IdentifierGeneratorDefinition idGen = buildIdGenerator( ann, context );
 			context.getMetadataCollector().addIdentifierGenerator( idGen );
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev( "Add sequence generator with name: {0}", idGen.getName() );
 			}
 		}
 
 		if ( pckg.isAnnotationPresent( TableGenerator.class ) ) {
 			TableGenerator ann = pckg.getAnnotation( TableGenerator.class );
 			IdentifierGeneratorDefinition idGen = buildIdGenerator( ann, context );
 			context.getMetadataCollector().addIdentifierGenerator( idGen );
 		}
 
 		bindGenericGenerators( pckg, context );
 		bindQueries( pckg, context );
 		bindFilterDefs( pckg, context );
 		bindTypeDefs( pckg, context );
 		bindFetchProfiles( pckg, context );
 		BinderHelper.bindAnyMetaDefs( pckg, context );
 
 	}
 
 	private static void bindGenericGenerators(XAnnotatedElement annotatedElement, MetadataBuildingContext context) {
 		GenericGenerator defAnn = annotatedElement.getAnnotation( GenericGenerator.class );
 		GenericGenerators defsAnn = annotatedElement.getAnnotation( GenericGenerators.class );
 		if ( defAnn != null ) {
 			bindGenericGenerator( defAnn, context );
 		}
 		if ( defsAnn != null ) {
 			for ( GenericGenerator def : defsAnn.value() ) {
 				bindGenericGenerator( def, context );
 			}
 		}
 	}
 
 	private static void bindGenericGenerator(GenericGenerator def, MetadataBuildingContext context) {
 		context.getMetadataCollector().addIdentifierGenerator( buildIdGenerator( def, context ) );
 	}
 
 	private static void bindQueries(XAnnotatedElement annotatedElement, MetadataBuildingContext context) {
 		{
 			SqlResultSetMapping ann = annotatedElement.getAnnotation( SqlResultSetMapping.class );
 			QueryBinder.bindSqlResultSetMapping( ann, context, false );
 		}
 		{
 			SqlResultSetMappings ann = annotatedElement.getAnnotation( SqlResultSetMappings.class );
 			if ( ann != null ) {
 				for ( SqlResultSetMapping current : ann.value() ) {
 					QueryBinder.bindSqlResultSetMapping( current, context, false );
 				}
 			}
 		}
 		{
 			NamedQuery ann = annotatedElement.getAnnotation( NamedQuery.class );
 			QueryBinder.bindQuery( ann, context, false );
 		}
 		{
 			org.hibernate.annotations.NamedQuery ann = annotatedElement.getAnnotation(
 					org.hibernate.annotations.NamedQuery.class
 			);
 			QueryBinder.bindQuery( ann, context );
 		}
 		{
 			NamedQueries ann = annotatedElement.getAnnotation( NamedQueries.class );
 			QueryBinder.bindQueries( ann, context, false );
 		}
 		{
 			org.hibernate.annotations.NamedQueries ann = annotatedElement.getAnnotation(
 					org.hibernate.annotations.NamedQueries.class
 			);
 			QueryBinder.bindQueries( ann, context );
 		}
 		{
 			NamedNativeQuery ann = annotatedElement.getAnnotation( NamedNativeQuery.class );
 			QueryBinder.bindNativeQuery( ann, context, false );
 		}
 		{
 			org.hibernate.annotations.NamedNativeQuery ann = annotatedElement.getAnnotation(
 					org.hibernate.annotations.NamedNativeQuery.class
 			);
 			QueryBinder.bindNativeQuery( ann, context );
 		}
 		{
 			NamedNativeQueries ann = annotatedElement.getAnnotation( NamedNativeQueries.class );
 			QueryBinder.bindNativeQueries( ann, context, false );
 		}
 		{
 			org.hibernate.annotations.NamedNativeQueries ann = annotatedElement.getAnnotation(
 					org.hibernate.annotations.NamedNativeQueries.class
 			);
 			QueryBinder.bindNativeQueries( ann, context );
 		}
 
 		// NamedStoredProcedureQuery handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		bindNamedStoredProcedureQuery(
 				annotatedElement.getAnnotation( NamedStoredProcedureQuery.class ),
 				context,
 				false
 		);
 
 		// NamedStoredProcedureQueries handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		bindNamedStoredProcedureQueries(
 				annotatedElement.getAnnotation( NamedStoredProcedureQueries.class ),
 				context,
 				false
 		);
 	}
 
 	private static void bindNamedStoredProcedureQueries(NamedStoredProcedureQueries annotation, MetadataBuildingContext context, boolean isDefault) {
 		if ( annotation != null ) {
 			for ( NamedStoredProcedureQuery queryAnnotation : annotation.value() ) {
 				bindNamedStoredProcedureQuery( queryAnnotation, context, isDefault );
 			}
 		}
 	}
 
 	private static void bindNamedStoredProcedureQuery(NamedStoredProcedureQuery annotation, MetadataBuildingContext context, boolean isDefault) {
 		if ( annotation != null ) {
 			QueryBinder.bindNamedStoredProcedureQuery( annotation, context, isDefault );
 		}
 	}
 
 	private static IdentifierGeneratorDefinition buildIdGenerator(java.lang.annotation.Annotation ann, MetadataBuildingContext context) {
 		if ( ann == null ) {
 			return null;
 		}
 
 		IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();
 
 		if ( context.getMappingDefaults().getImplicitSchemaName() != null ) {
 			definitionBuilder.addParam(
 					PersistentIdentifierGenerator.SCHEMA,
 					context.getMappingDefaults().getImplicitSchemaName()
 			);
 		}
 
 		if ( context.getMappingDefaults().getImplicitCatalogName() != null ) {
 			definitionBuilder.addParam(
 					PersistentIdentifierGenerator.CATALOG,
 					context.getMappingDefaults().getImplicitCatalogName()
 			);
 		}
 
 		if ( ann instanceof TableGenerator ) {
 			context.getBuildingOptions().getIdGenerationTypeInterpreter().interpretTableGenerator(
 					(TableGenerator) ann,
 					definitionBuilder
 			);
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev( "Add table generator with name: {0}", definitionBuilder.getName() );
 			}
 		}
 		else if ( ann instanceof SequenceGenerator ) {
 			context.getBuildingOptions().getIdGenerationTypeInterpreter().interpretSequenceGenerator(
 					(SequenceGenerator) ann,
 					definitionBuilder
 			);
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev( "Add sequence generator with name: {0}", definitionBuilder.getName() );
 			}
 		}
 		else if ( ann instanceof GenericGenerator ) {
 			GenericGenerator genGen = ( GenericGenerator ) ann;
 			definitionBuilder.setName( genGen.name() );
 			definitionBuilder.setStrategy( genGen.strategy() );
 			Parameter[] params = genGen.parameters();
 			for ( Parameter parameter : params ) {
 				definitionBuilder.addParam( parameter.name(), parameter.value() );
 			}
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev( "Add generic generator with name: {0}", definitionBuilder.getName() );
 			}
 		}
 		else {
 			throw new AssertionFailure( "Unknown Generator annotation: " + ann );
 		}
 
 		return definitionBuilder.build();
 	}
 
 	/**
 	 * Bind a class having JSR175 annotations. Subclasses <b>have to</b> be bound after its parent class.
 	 *
 	 * @param clazzToProcess entity to bind as {@code XClass} instance
 	 * @param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes
 	 *
 	 * @throws MappingException in case there is an configuration error
 	 */
 	public static void bindClass(
 			XClass clazzToProcess,
 			Map<XClass, InheritanceState> inheritanceStatePerClass,
 			MetadataBuildingContext context) throws MappingException {
 		//@Entity and @MappedSuperclass on the same class leads to a NPE down the road
 		if ( clazzToProcess.isAnnotationPresent( Entity.class )
 				&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {
 			throw new AnnotationException( "An entity cannot be annotated with both @Entity and @MappedSuperclass: "
 					+ clazzToProcess.getName() );
 		}
 
 		//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)
 		InheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );
 		AnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );
 
 		//Queries declared in MappedSuperclass should be usable in Subclasses
 		if ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {
 			bindQueries( clazzToProcess, context );
 			bindTypeDefs( clazzToProcess, context );
 			bindFilterDefs( clazzToProcess, context );
 		}
 
 		if ( !isEntityClassType( clazzToProcess, classType ) ) {
 			return;
 		}
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Binding entity from annotated class: %s", clazzToProcess.getName() );
 		}
 
 		PersistentClass superEntity = getSuperEntity(
 				clazzToProcess,
 				inheritanceStatePerClass,
 				context,
 				inheritanceState
 		);
 
-		PersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );
+		PersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );
 		Entity entityAnn = clazzToProcess.getAnnotation( Entity.class );
 		org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(
 				org.hibernate.annotations.Entity.class
 		);
 		EntityBinder entityBinder = new EntityBinder(
 				entityAnn,
 				hibEntityAnn,
 				clazzToProcess,
 				persistentClass,
 				context
 		);
 		entityBinder.setInheritanceState( inheritanceState );
 
 		bindQueries( clazzToProcess, context );
 		bindFilterDefs( clazzToProcess, context );
 		bindTypeDefs( clazzToProcess, context );
 		bindFetchProfiles( clazzToProcess, context );
 		BinderHelper.bindAnyMetaDefs( clazzToProcess, context );
 
 		String schema = "";
 		String table = ""; //might be no @Table annotation on the annotated class
 		String catalog = "";
 		List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();
 		javax.persistence.Table tabAnn = null;
 		if ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {
 			tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );
 			table = tabAnn.name();
 			schema = tabAnn.schema();
 			catalog = tabAnn.catalog();
 			uniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );
 		}
 
 		Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(
 				clazzToProcess,
 				context,
 				inheritanceState,
 				superEntity
 		);
 
 		final Ejb3DiscriminatorColumn discriminatorColumn;
 		if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {
 			discriminatorColumn = processSingleTableDiscriminatorProperties(
 					clazzToProcess,
 					context,
 					inheritanceState,
 					entityBinder
 			);
 		}
 		else if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {
 			discriminatorColumn = processJoinedDiscriminatorProperties(
 					clazzToProcess,
 					context,
 					inheritanceState,
 					entityBinder
 			);
 		}
 		else {
 			discriminatorColumn = null;
 		}
 
 		entityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );
 		entityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );
 		entityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );
 	    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );
 	    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );
 
 		bindFilters( clazzToProcess, entityBinder, context );
 
 		entityBinder.bindEntity();
 
 		if ( inheritanceState.hasTable() ) {
 			Check checkAnn = clazzToProcess.getAnnotation( Check.class );
 			String constraints = checkAnn == null
 					? null
 					: checkAnn.constraints();
 
 			EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()
 					? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )
 					: null;
 
 			entityBinder.bindTable(
 					schema,
 					catalog,
 					table,
 					uniqueConstraints,
 					constraints,
 					denormalizedTableXref
 			);
 		}
 		else {
 			if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {
 				LOG.invalidTableAnnotation( clazzToProcess.getName() );
 			}
 
 			if ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {
 				// we at least need to properly set up the EntityTableXref
 				entityBinder.bindTableForDiscriminatedSubclass(
 						context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )
 				);
 			}
 		}
 
 
 		PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(
 				clazzToProcess,
 				persistentClass,
 				entityBinder,
 				context,
 				inheritanceStatePerClass
 		);
 
 		javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(
 				javax.persistence.SecondaryTable.class
 		);
 		javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(
 				javax.persistence.SecondaryTables.class
 		);
 		entityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );
 
 		OnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );
 		boolean onDeleteAppropriate = false;
 
 		// todo : sucks that this is separate from RootClass distinction
 		final boolean isInheritanceRoot = !inheritanceState.hasParents();
 		final boolean hasSubclasses = inheritanceState.hasSiblings();
 
 		if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {
 			if ( inheritanceState.hasParents() ) {
 				onDeleteAppropriate = true;
 				final JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;
 				SimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );
 				jsc.setKey( key );
 				ForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );
 				if ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {
 					key.setForeignKeyName( fk.name() );
 				}
 				if ( onDeleteAnn != null ) {
 					key.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );
 				}
 				else {
 					key.setCascadeDeleteEnabled( false );
 				}
 				//we are never in a second pass at that stage, so queue it
 				context.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );
 				context.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );
 			}
 
 			if ( isInheritanceRoot ) {
 				// the class we are processing is the root of the hierarchy, see if we had a discriminator column
 				// (it is perfectly valid for joined subclasses to not have discriminators).
 				if ( discriminatorColumn != null ) {
 					// we have a discriminator column
 					if ( hasSubclasses || !discriminatorColumn.isImplicit() ) {
 						bindDiscriminatorColumnToRootPersistentClass(
 								(RootClass) persistentClass,
 								discriminatorColumn,
 								entityBinder.getSecondaryTables(),
 								propertyHolder,
 								context
 						);
 						//bind it again since the type might have changed
 						entityBinder.bindDiscriminatorValue();
 					}
 				}
 			}
 		}
 		else if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {
 			if ( isInheritanceRoot ) {
 				if ( hasSubclasses || !discriminatorColumn.isImplicit() ) {
 					bindDiscriminatorColumnToRootPersistentClass(
 							(RootClass) persistentClass,
 							discriminatorColumn,
 							entityBinder.getSecondaryTables(),
 							propertyHolder,
 							context
 					);
 					//bind it again since the type might have changed
 					entityBinder.bindDiscriminatorValue();
 				}
 			}
 		}
 
         if ( onDeleteAnn != null && !onDeleteAppropriate ) {
 			LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());
 		}
 
 		// try to find class level generators
 		HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );
 
 		// check properties
 		final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();
 		inheritanceState.postProcess( persistentClass, entityBinder );
 
 		final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE
 				&& inheritanceState.hasParents();
 		Set<String> idPropertiesIfIdClass = new HashSet<String>();
 		boolean isIdClass = mapAsIdClass(
 				inheritanceStatePerClass,
 				inheritanceState,
 				persistentClass,
 				entityBinder,
 				propertyHolder,
 				elementsToProcess,
 				idPropertiesIfIdClass,
 				context
 		);
 
 		if ( !isIdClass ) {
 			entityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );
 		}
 
 		processIdPropertiesIfNotAlready(
 				inheritanceStatePerClass,
 				context,
 				persistentClass,
 				entityBinder,
 				propertyHolder,
 				classGenerators,
 				elementsToProcess,
 				subclassAndSingleTableStrategy,
 				idPropertiesIfIdClass
 		);
 
 		if ( !inheritanceState.hasParents() ) {
 			final RootClass rootClass = ( RootClass ) persistentClass;
 			context.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );
 		}
 		else {
 			superEntity.addSubclass( ( Subclass ) persistentClass );
 		}
 
 		context.getMetadataCollector().addEntityBinding( persistentClass );
 
 		//Process secondary tables and complementary definitions (ie o.h.a.Table)
 		context.getMetadataCollector().addSecondPass(
 				new SecondaryTableSecondPass(
 						entityBinder,
 						propertyHolder,
 						clazzToProcess
 				)
 		);
 
 		//add process complementary Table definition (index & all)
 		entityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );
 		entityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );
 		entityBinder.processComplementaryTableDefinitions( tabAnn );
 	}
 
 	/**
 	 * Process all discriminator-related metadata per rules for "single table" inheritance
 	 */
 	private static Ejb3DiscriminatorColumn processSingleTableDiscriminatorProperties(
 			XClass clazzToProcess,
 			MetadataBuildingContext context,
 			InheritanceState inheritanceState,
 			EntityBinder entityBinder) {
 		final boolean isRoot = !inheritanceState.hasParents();
 
 		Ejb3DiscriminatorColumn discriminatorColumn = null;
 		javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(
 				javax.persistence.DiscriminatorColumn.class
 		);
 		DiscriminatorType discriminatorType = discAnn != null
 				? discAnn.discriminatorType()
 				: DiscriminatorType.STRING;
 
 		org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(
 				org.hibernate.annotations.DiscriminatorFormula.class
 		);
 		if ( isRoot ) {
 			discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(
 					discriminatorType,
 					discAnn,
 					discFormulaAnn,
 					context
 			);
 		}
 		if ( discAnn != null && !isRoot ) {
 			LOG.invalidDiscriminatorAnnotation( clazzToProcess.getName() );
 		}
 
 		final String discriminatorValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class )
 				? clazzToProcess.getAnnotation( DiscriminatorValue.class ).value()
 				: null;
 		entityBinder.setDiscriminatorValue( discriminatorValue );
 
 		DiscriminatorOptions discriminatorOptions = clazzToProcess.getAnnotation( DiscriminatorOptions.class );
 		if ( discriminatorOptions != null) {
 			entityBinder.setForceDiscriminator( discriminatorOptions.force() );
 			entityBinder.setInsertableDiscriminator( discriminatorOptions.insert() );
 		}
 
 		return discriminatorColumn;
 	}
 
 	/**
 	 * Process all discriminator-related metadata per rules for "joined" inheritance
 	 */
 	private static Ejb3DiscriminatorColumn processJoinedDiscriminatorProperties(
 			XClass clazzToProcess,
 			MetadataBuildingContext context,
 			InheritanceState inheritanceState,
 			EntityBinder entityBinder) {
 		if ( clazzToProcess.isAnnotationPresent( DiscriminatorFormula.class ) ) {
 			throw new MappingException( "@DiscriminatorFormula on joined inheritance not supported at this time" );
 		}
 
 
 		// DiscriminatorValue handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		final DiscriminatorValue discriminatorValueAnnotation = clazzToProcess.getAnnotation( DiscriminatorValue.class );
 		final String discriminatorValue = discriminatorValueAnnotation != null
 				? clazzToProcess.getAnnotation( DiscriminatorValue.class ).value()
 				: null;
 		entityBinder.setDiscriminatorValue( discriminatorValue );
 
 
 		// DiscriminatorColumn handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		final DiscriminatorColumn discriminatorColumnAnnotation = clazzToProcess.getAnnotation( DiscriminatorColumn.class );
 		if ( !inheritanceState.hasParents() ) {
 			// we want to process the discriminator column if either:
 			//		1) There is an explicit DiscriminatorColumn annotation && we are not told to ignore them
 			//		2) There is not an explicit DiscriminatorColumn annotation && we are told to create them implicitly
 			final boolean generateDiscriminatorColumn;
 			if ( discriminatorColumnAnnotation != null ) {
 				if ( context.getBuildingOptions().ignoreExplicitDiscriminatorsForJoinedInheritance() ) {
 					LOG.debugf( "Ignoring explicit DiscriminatorColumn annotation on ", clazzToProcess.getName() );
 					generateDiscriminatorColumn = false;
 				}
 				else {
 					LOG.applyingExplicitDiscriminatorColumnForJoined(
 							clazzToProcess.getName(),
 							AvailableSettings.IGNORE_EXPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS
 					);
 					generateDiscriminatorColumn = true;
 				}
 			}
 			else {
 				if ( context.getBuildingOptions().createImplicitDiscriminatorsForJoinedInheritance() ) {
 					LOG.debug( "Applying implicit DiscriminatorColumn using DiscriminatorColumn defaults" );
 					generateDiscriminatorColumn = true;
 				}
 				else {
 					LOG.debug( "Ignoring implicit (absent) DiscriminatorColumn" );
 					generateDiscriminatorColumn = false;
 				}
 			}
 
 			if ( generateDiscriminatorColumn ) {
 				final DiscriminatorType discriminatorType = discriminatorColumnAnnotation != null
 						? discriminatorColumnAnnotation.discriminatorType()
 						: DiscriminatorType.STRING;
 				return Ejb3DiscriminatorColumn.buildDiscriminatorColumn(
 						discriminatorType,
 						discriminatorColumnAnnotation,
 						null,
 						context
 				);
 			}
 		}
 		else {
 			if ( discriminatorColumnAnnotation != null ) {
 				LOG.invalidDiscriminatorAnnotation( clazzToProcess.getName() );
 			}
 		}
 
 		return null;
 	}
 
 	private static void processIdPropertiesIfNotAlready(
 			Map<XClass, InheritanceState> inheritanceStatePerClass,
 			MetadataBuildingContext context,
 			PersistentClass persistentClass,
 			EntityBinder entityBinder,
 			PropertyHolder propertyHolder,
 			HashMap<String, IdentifierGeneratorDefinition> classGenerators,
 			InheritanceState.ElementsToProcess elementsToProcess,
 			boolean subclassAndSingleTableStrategy,
 			Set<String> idPropertiesIfIdClass) {
 		Set<String> missingIdProperties = new HashSet<String>( idPropertiesIfIdClass );
 		for ( PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {
 			String propertyName = propertyAnnotatedElement.getPropertyName();
 			if ( !idPropertiesIfIdClass.contains( propertyName ) ) {
 				processElementAnnotations(
 						propertyHolder,
 						subclassAndSingleTableStrategy
 								? Nullability.FORCED_NULL
 								: Nullability.NO_CONSTRAINT,
 						propertyAnnotatedElement,
 						classGenerators,
 						entityBinder,
 						false,
 						false,
 						false,
 						context,
 						inheritanceStatePerClass
 				);
 			}
 			else {
 				missingIdProperties.remove( propertyName );
 			}
 		}
 
 		if ( missingIdProperties.size() != 0 ) {
 			StringBuilder missings = new StringBuilder();
 			for ( String property : missingIdProperties ) {
 				missings.append( property ).append( ", " );
 			}
 			throw new AnnotationException(
 					"Unable to find properties ("
 							+ missings.substring( 0, missings.length() - 2 )
 							+ ") in entity annotated with @IdClass:" + persistentClass.getEntityName()
 			);
 		}
 	}
 
 	private static boolean mapAsIdClass(
 			Map<XClass, InheritanceState> inheritanceStatePerClass,
 			InheritanceState inheritanceState,
 			PersistentClass persistentClass,
 			EntityBinder entityBinder,
 			PropertyHolder propertyHolder,
 			InheritanceState.ElementsToProcess elementsToProcess,
 			Set<String> idPropertiesIfIdClass,
 			MetadataBuildingContext context) {
 		/*
 		 * We are looking for @IdClass
 		 * In general we map the id class as identifier using the mapping metadata of the main entity's properties
 		 * and we create an identifier mapper containing the id properties of the main entity
 		 *
 		 * In JPA 2, there is a shortcut if the id class is the Pk of the associated class pointed to by the id
 		 * it ought to be treated as an embedded and not a real IdClass (at least in the Hibernate's internal way
 		 */
 		XClass classWithIdClass = inheritanceState.getClassWithIdClass( false );
 		if ( classWithIdClass != null ) {
 			IdClass idClass = classWithIdClass.getAnnotation( IdClass.class );
 			XClass compositeClass = context.getBuildingOptions().getReflectionManager().toXClass( idClass.value() );
 			PropertyData inferredData = new PropertyPreloadedData(
 					entityBinder.getPropertyAccessType(), "id", compositeClass
 			);
 			PropertyData baseInferredData = new PropertyPreloadedData(
 					entityBinder.getPropertyAccessType(), "id", classWithIdClass
 			);
 			AccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );
 			//In JPA 2, there is a shortcut if the IdClass is the Pk of the associated class pointed to by the id
 			//it ought to be treated as an embedded and not a real IdClass (at least in the Hibernate's internal way
 			final boolean isFakeIdClass = isIdClassPkOfTheAssociatedEntity(
 					elementsToProcess,
 					compositeClass,
 					inferredData,
 					baseInferredData,
 					propertyAccessor,
 					inheritanceStatePerClass,
 					context
 			);
 
 			if ( isFakeIdClass ) {
 				return false;
 			}
 
 			boolean isComponent = true;
 			String generatorType = "assigned";
 			String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;
 
 			boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();
 			entityBinder.setIgnoreIdAnnotations( true );
 			propertyHolder.setInIdClass( true );
 			bindIdClass(
 					generatorType,
 					generator,
 					inferredData,
 					baseInferredData,
 					null,
 					propertyHolder,
 					isComponent,
 					propertyAccessor,
 					entityBinder,
 					true,
 					false,
 					context,
 					inheritanceStatePerClass
 			);
 			propertyHolder.setInIdClass( null );
 			inferredData = new PropertyPreloadedData(
 					propertyAccessor, PropertyPath.IDENTIFIER_MAPPER_PROPERTY, compositeClass
 			);
 			Component mapper = fillComponent(
 					propertyHolder,
 					inferredData,
 					baseInferredData,
 					propertyAccessor,
 					false,
 					entityBinder,
 					true,
 					true,
 					false,
 					context,
 					inheritanceStatePerClass
 			);
 			entityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );
 			persistentClass.setIdentifierMapper( mapper );
 
 			//If id definition is on a mapped superclass, update the mapping
 			final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(
 					classWithIdClass,
 					inheritanceStatePerClass,
 					context
 			);
 			if ( superclass != null ) {
 				superclass.setDeclaredIdentifierMapper( mapper );
 			}
 			else {
 				//we are for sure on the entity
 				persistentClass.setDeclaredIdentifierMapper( mapper );
 			}
 
 			Property property = new Property();
 			property.setName( PropertyPath.IDENTIFIER_MAPPER_PROPERTY );
 			property.setNodeName( "id" );
 			property.setUpdateable( false );
 			property.setInsertable( false );
 			property.setValue( mapper );
 			property.setPropertyAccessorName( "embedded" );
 			persistentClass.addProperty( property );
 			entityBinder.setIgnoreIdAnnotations( true );
 
 			Iterator properties = mapper.getPropertyIterator();
 			while ( properties.hasNext() ) {
 				idPropertiesIfIdClass.add( ( ( Property ) properties.next() ).getName() );
 			}
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	private static boolean isIdClassPkOfTheAssociatedEntity(
 			InheritanceState.ElementsToProcess elementsToProcess,
 			XClass compositeClass,
 			PropertyData inferredData,
 			PropertyData baseInferredData,
 			AccessType propertyAccessor,
 			Map<XClass, InheritanceState> inheritanceStatePerClass,
 			MetadataBuildingContext context) {
 		if ( elementsToProcess.getIdPropertyCount() == 1 ) {
 			final PropertyData idPropertyOnBaseClass = getUniqueIdPropertyFromBaseClass(
 					inferredData,
 					baseInferredData,
 					propertyAccessor,
 					context
 			);
 			final InheritanceState state = inheritanceStatePerClass.get( idPropertyOnBaseClass.getClassOrElement() );
 			if ( state == null ) {
 				return false; //while it is likely a user error, let's consider it is something that might happen
 			}
 			final XClass associatedClassWithIdClass = state.getClassWithIdClass( true );
 			if ( associatedClassWithIdClass == null ) {
 				//we cannot know for sure here unless we try and find the @EmbeddedId
 				//Let's not do this thorough checking but do some extra validation
 				final XProperty property = idPropertyOnBaseClass.getProperty();
 				return property.isAnnotationPresent( ManyToOne.class )
 						|| property.isAnnotationPresent( OneToOne.class );
 
 			}
 			else {
 				final XClass idClass = context.getBuildingOptions().getReflectionManager().toXClass(
 						associatedClassWithIdClass.getAnnotation( IdClass.class ).value()
 				);
 				return idClass.equals( compositeClass );
 			}
 		}
 		else {
 			return false;
 		}
 	}
 
 	private static Cache determineCacheSettings(XClass clazzToProcess, MetadataBuildingContext context) {
 		Cache cacheAnn = clazzToProcess.getAnnotation( Cache.class );
 		if ( cacheAnn != null ) {
 			return cacheAnn;
 		}
 
 		Cacheable cacheableAnn = clazzToProcess.getAnnotation( Cacheable.class );
 		SharedCacheMode mode = determineSharedCacheMode( context );
 		switch ( mode ) {
 			case ALL: {
 				cacheAnn = buildCacheMock( clazzToProcess.getName(), context );
 				break;
 			}
 			case ENABLE_SELECTIVE: {
 				if ( cacheableAnn != null && cacheableAnn.value() ) {
 					cacheAnn = buildCacheMock( clazzToProcess.getName(), context );
 				}
 				break;
 			}
 			case DISABLE_SELECTIVE: {
 				if ( cacheableAnn == null || cacheableAnn.value() ) {
 					cacheAnn = buildCacheMock( clazzToProcess.getName(), context );
 				}
 				break;
 			}
 			default: {
 				// treat both NONE and UNSPECIFIED the same
 				break;
 			}
 		}
 		return cacheAnn;
 	}
 
 	private static SharedCacheMode determineSharedCacheMode(MetadataBuildingContext context) {
 		return context.getBuildingOptions().getSharedCacheMode();
 	}
 
 	private static Cache buildCacheMock(String region, MetadataBuildingContext context) {
 		return new LocalCacheAnnotationImpl( region, determineCacheConcurrencyStrategy( context ) );
 	}
 
 	private static CacheConcurrencyStrategy DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 
 	private static CacheConcurrencyStrategy determineCacheConcurrencyStrategy(MetadataBuildingContext context) {
 		if ( DEFAULT_CACHE_CONCURRENCY_STRATEGY == null ) {
 			DEFAULT_CACHE_CONCURRENCY_STRATEGY = CacheConcurrencyStrategy.fromAccessType(
 					context.getBuildingOptions().getImplicitCacheAccessType()
 			);
 		}
 		return DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 	}
 
 	@SuppressWarnings({ "ClassExplicitlyAnnotation" })
 	private static class LocalCacheAnnotationImpl implements Cache {
 		private final String region;
 		private final CacheConcurrencyStrategy usage;
 
 		private LocalCacheAnnotationImpl(String region, CacheConcurrencyStrategy usage) {
 			this.region = region;
 			this.usage = usage;
 		}
 
 		public CacheConcurrencyStrategy usage() {
 			return usage;
 		}
 
 		public String region() {
 			return region;
 		}
 
 		public String include() {
 			return "all";
 		}
 
 		public Class<? extends Annotation> annotationType() {
 			return Cache.class;
 		}
 	}
 
-	private static PersistentClass makePersistentClass(InheritanceState inheritanceState, PersistentClass superEntity) {
+	private static PersistentClass makePersistentClass(
+			InheritanceState inheritanceState,
+			PersistentClass superEntity,
+			MetadataBuildingContext metadataBuildingContext) {
 		//we now know what kind of persistent entity it is
-		PersistentClass persistentClass;
-		//create persistent class
 		if ( !inheritanceState.hasParents() ) {
-			persistentClass = new RootClass();
+			return new RootClass( metadataBuildingContext );
 		}
 		else if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {
-			persistentClass = new SingleTableSubclass( superEntity );
+			return new SingleTableSubclass( superEntity, metadataBuildingContext );
 		}
 		else if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {
-			persistentClass = new JoinedSubclass( superEntity );
+			return new JoinedSubclass( superEntity, metadataBuildingContext );
 		}
 		else if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {
-			persistentClass = new UnionSubclass( superEntity );
+			return new UnionSubclass( superEntity, metadataBuildingContext );
 		}
 		else {
 			throw new AssertionFailure( "Unknown inheritance type: " + inheritanceState.getType() );
 		}
-		return persistentClass;
 	}
 
 	private static Ejb3JoinColumn[] makeInheritanceJoinColumns(
 			XClass clazzToProcess,
 			MetadataBuildingContext context,
 			InheritanceState inheritanceState,
 			PersistentClass superEntity) {
 		Ejb3JoinColumn[] inheritanceJoinedColumns = null;
 		final boolean hasJoinedColumns = inheritanceState.hasParents()
 				&& InheritanceType.JOINED.equals( inheritanceState.getType() );
 		if ( hasJoinedColumns ) {
 			//@Inheritance(JOINED) subclass need to link back to the super entity
 			PrimaryKeyJoinColumns jcsAnn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );
 			boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;
 			if ( explicitInheritanceJoinedColumns ) {
 				int nbrOfInhJoinedColumns = jcsAnn.value().length;
 				PrimaryKeyJoinColumn jcAnn;
 				inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];
 				for ( int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++ ) {
 					jcAnn = jcsAnn.value()[colIndex];
 					inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(
 							jcAnn,
 							null,
 							superEntity.getIdentifier(),
 							null,
 							null,
 							context
 					);
 				}
 			}
 			else {
 				PrimaryKeyJoinColumn jcAnn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );
 				inheritanceJoinedColumns = new Ejb3JoinColumn[1];
 				inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(
 						jcAnn,
 						null,
 						superEntity.getIdentifier(),
 						null,
 						null,
 						context
 				);
 			}
 			LOG.trace( "Subclass joined column(s) created" );
 		}
 		else {
 			if ( clazzToProcess.isAnnotationPresent( PrimaryKeyJoinColumns.class )
 					|| clazzToProcess.isAnnotationPresent( PrimaryKeyJoinColumn.class ) ) {
 				LOG.invalidPrimaryKeyJoinColumnAnnotation();
 			}
 		}
 		return inheritanceJoinedColumns;
 	}
 
 	private static PersistentClass getSuperEntity(
 			XClass clazzToProcess,
 			Map<XClass, InheritanceState> inheritanceStatePerClass,
 			MetadataBuildingContext context,
 			InheritanceState inheritanceState) {
 		InheritanceState superEntityState = InheritanceState.getInheritanceStateOfSuperEntity(
 				clazzToProcess, inheritanceStatePerClass
 		);
 		PersistentClass superEntity = superEntityState != null
 				? context.getMetadataCollector().getEntityBinding( superEntityState.getClazz().getName() )
 				: null;
 		if ( superEntity == null ) {
 			//check if superclass is not a potential persistent class
 			if ( inheritanceState.hasParents() ) {
 				throw new AssertionFailure(
 						"Subclass has to be binded after it's mother class: "
 								+ superEntityState.getClazz().getName()
 				);
 			}
 		}
 		return superEntity;
 	}
 
 	private static boolean isEntityClassType(XClass clazzToProcess, AnnotatedClassType classType) {
 		if ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities
 				|| AnnotatedClassType.NONE.equals( classType ) //to be ignored
 				|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration
 				) {
 			if ( AnnotatedClassType.NONE.equals( classType )
 					&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {
 				LOG.missingEntityAnnotation( clazzToProcess.getName() );
 			}
 			return false;
 		}
 
 		if ( !classType.equals( AnnotatedClassType.ENTITY ) ) {
 			throw new AnnotationException(
 					"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: " + clazzToProcess
 							.getName()
 			);
 		}
 
 		return true;
 	}
 
 	/*
 	 * Process the filters defined on the given class, as well as all filters defined
 	 * on the MappedSuperclass(s) in the inheritance hierarchy
 	 */
 
 	private static void bindFilters(
 			XClass annotatedClass,
 			EntityBinder entityBinder,
 			MetadataBuildingContext context) {
 
 		bindFilters( annotatedClass, entityBinder );
 
 		XClass classToProcess = annotatedClass.getSuperclass();
 		while ( classToProcess != null ) {
 			AnnotatedClassType classType = context.getMetadataCollector().getClassType( classToProcess );
 			if ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {
 				bindFilters( classToProcess, entityBinder );
 			}
 			else {
 				break;
 			}
 			classToProcess = classToProcess.getSuperclass();
 		}
 
 	}
 
 	private static void bindFilters(XAnnotatedElement annotatedElement, EntityBinder entityBinder) {
 
 		Filters filtersAnn = annotatedElement.getAnnotation( Filters.class );
 		if ( filtersAnn != null ) {
 			for ( Filter filter : filtersAnn.value() ) {
 				entityBinder.addFilter(filter);
 			}
 		}
 
 		Filter filterAnn = annotatedElement.getAnnotation( Filter.class );
 		if ( filterAnn != null ) {
 			entityBinder.addFilter(filterAnn);
 		}
 	}
 
 	private static void bindFilterDefs(XAnnotatedElement annotatedElement, MetadataBuildingContext context) {
 		FilterDef defAnn = annotatedElement.getAnnotation( FilterDef.class );
 		FilterDefs defsAnn = annotatedElement.getAnnotation( FilterDefs.class );
 		if ( defAnn != null ) {
 			bindFilterDef( defAnn, context );
 		}
 		if ( defsAnn != null ) {
 			for ( FilterDef def : defsAnn.value() ) {
 				bindFilterDef( def, context );
 			}
 		}
 	}
 
 	private static void bindFilterDef(FilterDef defAnn, MetadataBuildingContext context) {
 		Map<String, org.hibernate.type.Type> params = new HashMap<String, org.hibernate.type.Type>();
 		for ( ParamDef param : defAnn.parameters() ) {
 			params.put( param.name(), context.getMetadataCollector().getTypeResolver().heuristicType( param.type() ) );
 		}
 		FilterDefinition def = new FilterDefinition( defAnn.name(), defAnn.defaultCondition(), params );
 		LOG.debugf( "Binding filter definition: %s", def.getFilterName() );
 		context.getMetadataCollector().addFilterDefinition( def );
 	}
 
 	private static void bindTypeDefs(XAnnotatedElement annotatedElement, MetadataBuildingContext context) {
 		TypeDef defAnn = annotatedElement.getAnnotation( TypeDef.class );
 		TypeDefs defsAnn = annotatedElement.getAnnotation( TypeDefs.class );
 		if ( defAnn != null ) {
 			bindTypeDef( defAnn, context );
 		}
 		if ( defsAnn != null ) {
 			for ( TypeDef def : defsAnn.value() ) {
 				bindTypeDef( def, context );
 			}
 		}
 	}
 
 	private static void bindTypeDef(TypeDef defAnn, MetadataBuildingContext context) {
 		Properties params = new Properties();
 		for ( Parameter param : defAnn.parameters() ) {
 			params.setProperty( param.name(), param.value() );
 		}
 
 		if ( BinderHelper.isEmptyAnnotationValue( defAnn.name() ) && defAnn.defaultForType().equals( void.class ) ) {
 			throw new AnnotationException(
 					"Either name or defaultForType (or both) attribute should be set in TypeDef having typeClass " +
 							defAnn.typeClass().getName()
 			);
 		}
 
 		final String typeBindMessageF = "Binding type definition: %s";
 		if ( !BinderHelper.isEmptyAnnotationValue( defAnn.name() ) ) {
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf( typeBindMessageF, defAnn.name() );
 			}
 			context.getMetadataCollector().addTypeDefinition(
 					new TypeDefinition(
 							defAnn.name(),
 							defAnn.typeClass(),
 							null,
 							params
 					)
 			);
 		}
 
 		if ( !defAnn.defaultForType().equals( void.class ) ) {
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf( typeBindMessageF, defAnn.defaultForType().getName() );
 			}
 			context.getMetadataCollector().addTypeDefinition(
 					new TypeDefinition(
 							defAnn.defaultForType().getName(),
 							defAnn.typeClass(),
 							new String[]{ defAnn.defaultForType().getName() },
 							params
 					)
 			);
 		}
 
 	}
 
 	private static void bindFetchProfiles(XAnnotatedElement annotatedElement, MetadataBuildingContext context) {
 		FetchProfile fetchProfileAnnotation = annotatedElement.getAnnotation( FetchProfile.class );
 		FetchProfiles fetchProfileAnnotations = annotatedElement.getAnnotation( FetchProfiles.class );
 		if ( fetchProfileAnnotation != null ) {
 			bindFetchProfile( fetchProfileAnnotation, context );
 		}
 		if ( fetchProfileAnnotations != null ) {
 			for ( FetchProfile profile : fetchProfileAnnotations.value() ) {
 				bindFetchProfile( profile, context );
 			}
 		}
 	}
 
 	private static void bindFetchProfile(FetchProfile fetchProfileAnnotation, MetadataBuildingContext context) {
 		for ( FetchProfile.FetchOverride fetch : fetchProfileAnnotation.fetchOverrides() ) {
 			org.hibernate.annotations.FetchMode mode = fetch.mode();
 			if ( !mode.equals( org.hibernate.annotations.FetchMode.JOIN ) ) {
 				throw new MappingException( "Only FetchMode.JOIN is currently supported" );
 			}
 
 			context.getMetadataCollector().addSecondPass(
 					new VerifyFetchProfileReferenceSecondPass(
 							fetchProfileAnnotation.name(),
 							fetch,
 							context
 					)
 			);
 		}
 	}
 
 
 	private static void bindDiscriminatorColumnToRootPersistentClass(
 			RootClass rootClass,
 			Ejb3DiscriminatorColumn discriminatorColumn,
 			Map<String, Join> secondaryTables,
 			PropertyHolder propertyHolder,
 			MetadataBuildingContext context) {
 		if ( rootClass.getDiscriminator() == null ) {
 			if ( discriminatorColumn == null ) {
 				throw new AssertionFailure( "discriminator column should have been built" );
 			}
 			discriminatorColumn.setJoins( secondaryTables );
 			discriminatorColumn.setPropertyHolder( propertyHolder );
 			SimpleValue discriminatorColumnBinding = new SimpleValue( context.getMetadataCollector(), rootClass.getTable() );
 			rootClass.setDiscriminator( discriminatorColumnBinding );
 			discriminatorColumn.linkWithValue( discriminatorColumnBinding );
 			discriminatorColumnBinding.setTypeName( discriminatorColumn.getDiscriminatorTypeName() );
 			rootClass.setPolymorphic( true );
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev( "Setting discriminator for entity {0}", rootClass.getEntityName() );
 			}
 		}
 	}
 
 	/**
 	 * @param elements List of {@code ProperyData} instances
 	 * @param defaultAccessType The default value access strategy which has to be used in case no explicit local access
 	 * strategy is used
 	 * @param propertyContainer Metadata about a class and its properties
 	 *
 	 * @return the number of id properties found while iterating the elements of {@code annotatedClass} using
 	 *         the determined access strategy, {@code false} otherwise.
 	 */
 	static int addElementsOfClass(
 			List<PropertyData> elements,
 			AccessType defaultAccessType,
 			PropertyContainer propertyContainer,
 			MetadataBuildingContext context) {
 		int idPropertyCounter = 0;
 		AccessType accessType = defaultAccessType;
 
 		if ( propertyContainer.hasExplicitAccessStrategy() ) {
 			accessType = propertyContainer.getExplicitAccessStrategy();
 		}
 
 		Collection<XProperty> properties = propertyContainer.getProperties( accessType );
 		for ( XProperty p : properties ) {
 			final int currentIdPropertyCounter = addProperty(
 					propertyContainer,
 					p,
 					elements,
 					accessType.getType(),
 					context
 			);
 			idPropertyCounter += currentIdPropertyCounter;
 		}
 		return idPropertyCounter;
 	}
 
 	private static int addProperty(
 			PropertyContainer propertyContainer,
 			XProperty property,
 			List<PropertyData> annElts,
 			String propertyAccessor,
 			MetadataBuildingContext context) {
 		final XClass declaringClass = propertyContainer.getDeclaringClass();
 		final XClass entity = propertyContainer.getEntityAtStake();
 		int idPropertyCounter = 0;
 		PropertyData propertyAnnotatedElement = new PropertyInferredData(
 				declaringClass,
 				property,
 				propertyAccessor,
 				context.getBuildingOptions().getReflectionManager()
 		);
 
 		/*
 		 * put element annotated by @Id in front
 		 * since it has to be parsed before any association by Hibernate
 		 */
 		final XAnnotatedElement element = propertyAnnotatedElement.getProperty();
 		if ( element.isAnnotationPresent( Id.class ) || element.isAnnotationPresent( EmbeddedId.class ) ) {
 			annElts.add( 0, propertyAnnotatedElement );
 			/**
 			 * The property must be put in hibernate.properties as it's a system wide property. Fixable?
 			 * TODO support true/false/default on the property instead of present / not present
 			 * TODO is @Column mandatory?
 			 * TODO add method support
 			 */
 			if ( context.getBuildingOptions().isSpecjProprietarySyntaxEnabled() ) {
 				if ( element.isAnnotationPresent( Id.class ) && element.isAnnotationPresent( Column.class ) ) {
 					String columnName = element.getAnnotation( Column.class ).name();
 					for ( XProperty prop : declaringClass.getDeclaredProperties( AccessType.FIELD.getType() ) ) {
 						if ( !prop.isAnnotationPresent( MapsId.class ) ) {
 							/**
 							 * The detection of a configured individual JoinColumn differs between Annotation
 							 * and XML configuration processing.
 							 */
 							boolean isRequiredAnnotationPresent = false;
 							JoinColumns groupAnnotation = prop.getAnnotation( JoinColumns.class );
 							if ( (prop.isAnnotationPresent( JoinColumn.class )
 									&& prop.getAnnotation( JoinColumn.class ).name().equals( columnName )) ) {
 								isRequiredAnnotationPresent = true;
 							}
 							else if ( prop.isAnnotationPresent( JoinColumns.class ) ) {
 								for ( JoinColumn columnAnnotation : groupAnnotation.value() ) {
 									if ( columnName.equals( columnAnnotation.name() ) ) {
 										isRequiredAnnotationPresent = true;
 										break;
 									}
 								}
 							}
 							if ( isRequiredAnnotationPresent ) {
 								//create a PropertyData fpr the specJ property holding the mapping
 								PropertyData specJPropertyData = new PropertyInferredData(
 										declaringClass,
 										//same dec
 										prop,
 										// the actual @XToOne property
 										propertyAccessor,
 										//TODO we should get the right accessor but the same as id would do
 										context.getBuildingOptions().getReflectionManager()
 								);
 								context.getMetadataCollector().addPropertyAnnotatedWithMapsIdSpecj(
 										entity,
 										specJPropertyData,
 										element.toString()
 								);
 							}
 						}
 					}
 				}
 			}
 
 			if ( element.isAnnotationPresent( ManyToOne.class ) || element.isAnnotationPresent( OneToOne.class ) ) {
 				context.getMetadataCollector().addToOneAndIdProperty( entity, propertyAnnotatedElement );
 			}
 			idPropertyCounter++;
 		}
 		else {
 			annElts.add( propertyAnnotatedElement );
 		}
 		if ( element.isAnnotationPresent( MapsId.class ) ) {
 			context.getMetadataCollector().addPropertyAnnotatedWithMapsId( entity, propertyAnnotatedElement );
 		}
 
 		return idPropertyCounter;
 	}
 
 	/*
 	 * Process annotation of a particular property
 	 */
 
 	private static void processElementAnnotations(
 			PropertyHolder propertyHolder,
 			Nullability nullability,
 			PropertyData inferredData,
 			HashMap<String, IdentifierGeneratorDefinition> classGenerators,
 			EntityBinder entityBinder,
 			boolean isIdentifierMapper,
 			boolean isComponentEmbedded,
 			boolean inSecondPass,
 			MetadataBuildingContext context,
 			Map<XClass, InheritanceState> inheritanceStatePerClass) throws MappingException {
 		/**
 		 * inSecondPass can only be used to apply right away the second pass of a composite-element
 		 * Because it's a value type, there is no bidirectional association, hence second pass
 		 * ordering does not matter
 		 */
 
 		final boolean traceEnabled = LOG.isTraceEnabled();
 		if ( traceEnabled ) {
 			LOG.tracev( "Processing annotations of {0}.{1}" , propertyHolder.getEntityName(), inferredData.getPropertyName() );
 		}
 
 		final XProperty property = inferredData.getProperty();
 		if ( property.isAnnotationPresent( Parent.class ) ) {
 			if ( propertyHolder.isComponent() ) {
 				propertyHolder.setParentProperty( property.getName() );
 			}
 			else {
 				throw new AnnotationException(
 						"@Parent cannot be applied outside an embeddable object: "
 								+ BinderHelper.getPath( propertyHolder, inferredData )
 				);
 			}
 			return;
 		}
 
 		ColumnsBuilder columnsBuilder = new ColumnsBuilder(
 				propertyHolder,
 				nullability,
 				property,
 				inferredData,
 				entityBinder,
 				context
 		).extractMetadata();
 		Ejb3Column[] columns = columnsBuilder.getColumns();
 		Ejb3JoinColumn[] joinColumns = columnsBuilder.getJoinColumns();
 
 		final XClass returnedClass = inferredData.getClassOrElement();
 
 		//prepare PropertyBinder
 		PropertyBinder propertyBinder = new PropertyBinder();
 		propertyBinder.setName( inferredData.getPropertyName() );
 		propertyBinder.setReturnedClassName( inferredData.getTypeName() );
 		propertyBinder.setAccessType( inferredData.getDefaultAccess() );
 		propertyBinder.setHolder( propertyHolder );
 		propertyBinder.setProperty( property );
 		propertyBinder.setReturnedClass( inferredData.getPropertyClass() );
 		propertyBinder.setBuildingContext( context );
 		if ( isIdentifierMapper ) {
 			propertyBinder.setInsertable( false );
 			propertyBinder.setUpdatable( false );
 		}
 		propertyBinder.setDeclaringClass( inferredData.getDeclaringClass() );
 		propertyBinder.setEntityBinder( entityBinder );
 		propertyBinder.setInheritanceStatePerClass( inheritanceStatePerClass );
 
 		boolean isId = !entityBinder.isIgnoreIdAnnotations() &&
 				( property.isAnnotationPresent( Id.class )
 						|| property.isAnnotationPresent( EmbeddedId.class ) );
 		propertyBinder.setId( isId );
 
 		if ( property.isAnnotationPresent( Version.class ) ) {
 			if ( isIdentifierMapper ) {
 				throw new AnnotationException(
 						"@IdClass class should not have @Version property"
 				);
 			}
 			if ( !( propertyHolder.getPersistentClass() instanceof RootClass ) ) {
 				throw new AnnotationException(
 						"Unable to define/override @Version on a subclass: "
 								+ propertyHolder.getEntityName()
 				);
 			}
 			if ( !propertyHolder.isEntity() ) {
 				throw new AnnotationException(
 						"Unable to define @Version on an embedded class: "
 								+ propertyHolder.getEntityName()
 				);
 			}
 			if ( traceEnabled ) {
 				LOG.tracev( "{0} is a version property", inferredData.getPropertyName() );
 			}
 			RootClass rootClass = ( RootClass ) propertyHolder.getPersistentClass();
 			propertyBinder.setColumns( columns );
 			Property prop = propertyBinder.makePropertyValueAndBind();
 			setVersionInformation( property, propertyBinder );
 			rootClass.setVersion( prop );
 
 			//If version is on a mapped superclass, update the mapping
 			final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(
 					inferredData.getDeclaringClass(),
 					inheritanceStatePerClass,
 					context
 			);
 			if ( superclass != null ) {
 				superclass.setDeclaredVersion( prop );
 			}
 			else {
 				//we know the property is on the actual entity
 				rootClass.setDeclaredVersion( prop );
 			}
 
 			SimpleValue simpleValue = ( SimpleValue ) prop.getValue();
 			simpleValue.setNullValue( "undefined" );
 			rootClass.setOptimisticLockStyle( OptimisticLockStyle.VERSION );
 			if ( traceEnabled ) {
 				LOG.tracev( "Version name: {0}, unsavedValue: {1}", rootClass.getVersion().getName(),
 						( (SimpleValue) rootClass.getVersion().getValue() ).getNullValue() );
 			}
 		}
 		else {
 			final boolean forcePersist = property.isAnnotationPresent( MapsId.class )
 					|| property.isAnnotationPresent( Id.class );
 			if ( property.isAnnotationPresent( ManyToOne.class ) ) {
 				ManyToOne ann = property.getAnnotation( ManyToOne.class );
 
 				//check validity
 				if ( property.isAnnotationPresent( Column.class )
 						|| property.isAnnotationPresent( Columns.class ) ) {
 					throw new AnnotationException(
 							"@Column(s) not allowed on a @ManyToOne property: "
 									+ BinderHelper.getPath( propertyHolder, inferredData )
 					);
 				}
 
 				Cascade hibernateCascade = property.getAnnotation( Cascade.class );
 				NotFound notFound = property.getAnnotation( NotFound.class );
 				boolean ignoreNotFound = notFound != null && notFound.action().equals( NotFoundAction.IGNORE );
 				OnDelete onDeleteAnn = property.getAnnotation( OnDelete.class );
 				boolean onDeleteCascade = onDeleteAnn != null && OnDeleteAction.CASCADE.equals( onDeleteAnn.action() );
 				JoinTable assocTable = propertyHolder.getJoinTable( property );
 				if ( assocTable != null ) {
 					Join join = propertyHolder.addJoin( assocTable, false );
 					for ( Ejb3JoinColumn joinColumn : joinColumns ) {
 						joinColumn.setExplicitTableName( join.getTable().getName() );
 					}
 				}
 				final boolean mandatory = !ann.optional() || forcePersist;
 				bindManyToOne(
 						getCascadeStrategy( ann.cascade(), hibernateCascade, false, forcePersist ),
 						joinColumns,
 						!mandatory,
 						ignoreNotFound,
 						onDeleteCascade,
 						ToOneBinder.getTargetEntity( inferredData, context ),
 						propertyHolder,
 						inferredData,
 						false,
 						isIdentifierMapper,
 						inSecondPass,
 						propertyBinder,
 						context
 				);
 			}
 			else if ( property.isAnnotationPresent( OneToOne.class ) ) {
 				OneToOne ann = property.getAnnotation( OneToOne.class );
 
 				//check validity
 				if ( property.isAnnotationPresent( Column.class )
 						|| property.isAnnotationPresent( Columns.class ) ) {
 					throw new AnnotationException(
 							"@Column(s) not allowed on a @OneToOne property: "
 									+ BinderHelper.getPath( propertyHolder, inferredData )
 					);
 				}
 
 				//FIXME support a proper PKJCs
 				boolean trueOneToOne = property.isAnnotationPresent( PrimaryKeyJoinColumn.class )
 						|| property.isAnnotationPresent( PrimaryKeyJoinColumns.class );
 				Cascade hibernateCascade = property.getAnnotation( Cascade.class );
 				NotFound notFound = property.getAnnotation( NotFound.class );
 				boolean ignoreNotFound = notFound != null && notFound.action().equals( NotFoundAction.IGNORE );
 				OnDelete onDeleteAnn = property.getAnnotation( OnDelete.class );
 				boolean onDeleteCascade = onDeleteAnn != null && OnDeleteAction.CASCADE.equals( onDeleteAnn.action() );
 				JoinTable assocTable = propertyHolder.getJoinTable( property );
 				if ( assocTable != null ) {
 					Join join = propertyHolder.addJoin( assocTable, false );
 					for ( Ejb3JoinColumn joinColumn : joinColumns ) {
 						joinColumn.setExplicitTableName( join.getTable().getName() );
 					}
 				}
 				//MapsId means the columns belong to the pk => not null
 				//@OneToOne with @PKJC can still be optional
 				final boolean mandatory = !ann.optional() || forcePersist;
 				bindOneToOne(
 						getCascadeStrategy( ann.cascade(), hibernateCascade, ann.orphanRemoval(), forcePersist ),
 						joinColumns,
 						!mandatory,
 						getFetchMode( ann.fetch() ),
 						ignoreNotFound, onDeleteCascade,
 						ToOneBinder.getTargetEntity( inferredData, context ),
 						propertyHolder,
 						inferredData,
 						ann.mappedBy(),
 						trueOneToOne,
 						isIdentifierMapper,
 						inSecondPass,
 						propertyBinder,
 						context
 				);
 			}
 			else if ( property.isAnnotationPresent( org.hibernate.annotations.Any.class ) ) {
 
 				//check validity
 				if ( property.isAnnotationPresent( Column.class )
 						|| property.isAnnotationPresent( Columns.class ) ) {
 					throw new AnnotationException(
 							"@Column(s) not allowed on a @Any property: "
 									+ BinderHelper.getPath( propertyHolder, inferredData )
 					);
 				}
 
 				Cascade hibernateCascade = property.getAnnotation( Cascade.class );
 				OnDelete onDeleteAnn = property.getAnnotation( OnDelete.class );
 				boolean onDeleteCascade = onDeleteAnn != null && OnDeleteAction.CASCADE.equals( onDeleteAnn.action() );
 				JoinTable assocTable = propertyHolder.getJoinTable( property );
 				if ( assocTable != null ) {
 					Join join = propertyHolder.addJoin( assocTable, false );
 					for ( Ejb3JoinColumn joinColumn : joinColumns ) {
 						joinColumn.setExplicitTableName( join.getTable().getName() );
 					}
 				}
 				bindAny(
 						getCascadeStrategy( null, hibernateCascade, false, forcePersist ),
 						//@Any has not cascade attribute
 						joinColumns,
 						onDeleteCascade,
 						nullability,
 						propertyHolder,
 						inferredData,
 						entityBinder,
 						isIdentifierMapper,
 						context
 				);
 			}
 			else if ( property.isAnnotationPresent( OneToMany.class )
 					|| property.isAnnotationPresent( ManyToMany.class )
 					|| property.isAnnotationPresent( ElementCollection.class )
 					|| property.isAnnotationPresent( ManyToAny.class ) ) {
 				OneToMany oneToManyAnn = property.getAnnotation( OneToMany.class );
 				ManyToMany manyToManyAnn = property.getAnnotation( ManyToMany.class );
 				ElementCollection elementCollectionAnn = property.getAnnotation( ElementCollection.class );
 
 				final IndexColumn indexColumn;
 
 				if ( property.isAnnotationPresent( OrderColumn.class ) ) {
 					indexColumn = IndexColumn.buildColumnFromAnnotation(
 							property.getAnnotation( OrderColumn.class ),
 							propertyHolder,
 							inferredData,
 							entityBinder.getSecondaryTables(),
 							context
 					);
 					if ( property.isAnnotationPresent( ListIndexBase.class ) ) {
 						indexColumn.setBase( ( property.getAnnotation( ListIndexBase.class ) ).value() );
 					}
 				}
 				else {
 					//if @IndexColumn is not there, the generated IndexColumn is an implicit column and not used.
 					//so we can leave the legacy processing as the default
 					indexColumn = IndexColumn.buildColumnFromAnnotation(
 							property.getAnnotation( org.hibernate.annotations.IndexColumn.class ),
 							propertyHolder,
 							inferredData,
 							context
 					);
 				}
 				CollectionBinder collectionBinder = CollectionBinder.getCollectionBinder(
 						propertyHolder.getEntityName(),
 						property,
 						!indexColumn.isImplicit(),
 						property.isAnnotationPresent( MapKeyType.class ),
 						context
 				);
 				collectionBinder.setIndexColumn( indexColumn );
 				collectionBinder.setMapKey( property.getAnnotation( MapKey.class ) );
 				collectionBinder.setPropertyName( inferredData.getPropertyName() );
 
 				collectionBinder.setBatchSize( property.getAnnotation( BatchSize.class ) );
 
 				collectionBinder.setJpaOrderBy( property.getAnnotation( javax.persistence.OrderBy.class ) );
 				collectionBinder.setSqlOrderBy( property.getAnnotation( OrderBy.class ) );
 
 				collectionBinder.setSort( property.getAnnotation( Sort.class ) );
 				collectionBinder.setNaturalSort( property.getAnnotation( SortNatural.class ) );
 				collectionBinder.setComparatorSort( property.getAnnotation( SortComparator.class ) );
 
 				Cache cachAnn = property.getAnnotation( Cache.class );
 				collectionBinder.setCache( cachAnn );
 				collectionBinder.setPropertyHolder( propertyHolder );
 				Cascade hibernateCascade = property.getAnnotation( Cascade.class );
 				NotFound notFound = property.getAnnotation( NotFound.class );
 				boolean ignoreNotFound = notFound != null && notFound.action().equals( NotFoundAction.IGNORE );
 				collectionBinder.setIgnoreNotFound( ignoreNotFound );
 				collectionBinder.setCollectionType( inferredData.getProperty().getElementClass() );
 				collectionBinder.setBuildingContext( context );
 				collectionBinder.setAccessType( inferredData.getDefaultAccess() );
 
 				Ejb3Column[] elementColumns;
 				//do not use "element" if you are a JPA 2 @ElementCollection only for legacy Hibernate mappings
 				boolean isJPA2ForValueMapping = property.isAnnotationPresent( ElementCollection.class );
 				PropertyData virtualProperty = isJPA2ForValueMapping ? inferredData : new WrappedInferredData(
 						inferredData, "element"
 				);
 				if ( property.isAnnotationPresent( Column.class ) || property.isAnnotationPresent(
 						Formula.class
 				) ) {
 					Column ann = property.getAnnotation( Column.class );
 					Formula formulaAnn = property.getAnnotation( Formula.class );
 					elementColumns = Ejb3Column.buildColumnFromAnnotation(
 							new Column[] { ann },
 							formulaAnn,
 							nullability,
 							propertyHolder,
 							virtualProperty,
 							entityBinder.getSecondaryTables(),
 							context
 					);
 				}
 				else if ( property.isAnnotationPresent( Columns.class ) ) {
 					Columns anns = property.getAnnotation( Columns.class );
 					elementColumns = Ejb3Column.buildColumnFromAnnotation(
 							anns.columns(),
 							null,
 							nullability,
 							propertyHolder,
 							virtualProperty,
 							entityBinder.getSecondaryTables(),
 							context
 					);
 				}
 				else {
 					elementColumns = Ejb3Column.buildColumnFromAnnotation(
 							null,
 							null,
 							nullability,
 							propertyHolder,
 							virtualProperty,
 							entityBinder.getSecondaryTables(),
 							context
 					);
 				}
 				{
 					Column[] keyColumns = null;
 					//JPA 2 has priority and has different default column values, differenciate legacy from JPA 2
 					Boolean isJPA2 = null;
 					if ( property.isAnnotationPresent( MapKeyColumn.class ) ) {
 						isJPA2 = Boolean.TRUE;
 						keyColumns = new Column[] { new MapKeyColumnDelegator( property.getAnnotation( MapKeyColumn.class ) ) };
 					}
 
 					//not explicitly legacy
 					if ( isJPA2 == null ) {
 						isJPA2 = Boolean.TRUE;
 					}
 
 					//nullify empty array
 					keyColumns = keyColumns != null && keyColumns.length > 0 ? keyColumns : null;
 
 					//"mapkey" is the legacy column name of the key column pre JPA 2
 					PropertyData mapKeyVirtualProperty = new WrappedInferredData( inferredData, "mapkey" );
 					Ejb3Column[] mapColumns = Ejb3Column.buildColumnFromAnnotation(
 							keyColumns,
 							null,
 							Nullability.FORCED_NOT_NULL,
 							propertyHolder,
 							isJPA2 ? inferredData : mapKeyVirtualProperty,
 							isJPA2 ? "_KEY" : null,
 							entityBinder.getSecondaryTables(),
 							context
 					);
 					collectionBinder.setMapKeyColumns( mapColumns );
 				}
 				{
 					JoinColumn[] joinKeyColumns = null;
 					//JPA 2 has priority and has different default column values, differenciate legacy from JPA 2
 					Boolean isJPA2 = null;
 					if ( property.isAnnotationPresent( MapKeyJoinColumns.class ) ) {
 						isJPA2 = Boolean.TRUE;
 						final MapKeyJoinColumn[] mapKeyJoinColumns = property.getAnnotation( MapKeyJoinColumns.class )
 								.value();
 						joinKeyColumns = new JoinColumn[mapKeyJoinColumns.length];
 						int index = 0;
 						for ( MapKeyJoinColumn joinColumn : mapKeyJoinColumns ) {
 							joinKeyColumns[index] = new MapKeyJoinColumnDelegator( joinColumn );
 							index++;
 						}
 						if ( property.isAnnotationPresent( MapKeyJoinColumn.class ) ) {
 							throw new AnnotationException(
 									"@MapKeyJoinColumn and @MapKeyJoinColumns used on the same property: "
 											+ BinderHelper.getPath( propertyHolder, inferredData )
 							);
 						}
 					}
 					else if ( property.isAnnotationPresent( MapKeyJoinColumn.class ) ) {
 						isJPA2 = Boolean.TRUE;
 						joinKeyColumns = new JoinColumn[] {
 								new MapKeyJoinColumnDelegator(
 										property.getAnnotation(
 												MapKeyJoinColumn.class
 										)
 								)
 						};
 					}
 					//not explicitly legacy
 					if ( isJPA2 == null ) {
 						isJPA2 = Boolean.TRUE;
 					}
 
 					PropertyData mapKeyVirtualProperty = new WrappedInferredData( inferredData, "mapkey" );
 					Ejb3JoinColumn[] mapJoinColumns = Ejb3JoinColumn.buildJoinColumnsWithDefaultColumnSuffix(
 							joinKeyColumns,
 							null,
 							entityBinder.getSecondaryTables(),
 							propertyHolder,
 							isJPA2 ? inferredData.getPropertyName() : mapKeyVirtualProperty.getPropertyName(),
 							isJPA2 ? "_KEY" : null,
 							context
 					);
 					collectionBinder.setMapKeyManyToManyColumns( mapJoinColumns );
 				}
 
 				//potential element
 				collectionBinder.setEmbedded( property.isAnnotationPresent( Embedded.class ) );
 				collectionBinder.setElementColumns( elementColumns );
 				collectionBinder.setProperty( property );
 
 				//TODO enhance exception with @ManyToAny and @CollectionOfElements
 				if ( oneToManyAnn != null && manyToManyAnn != null ) {
 					throw new AnnotationException(
 							"@OneToMany and @ManyToMany on the same property is not allowed: "
 									+ propertyHolder.getEntityName() + "." + inferredData.getPropertyName()
 					);
 				}
 				String mappedBy = null;
 				if ( oneToManyAnn != null ) {
 					for ( Ejb3JoinColumn column : joinColumns ) {
 						if ( column.isSecondary() ) {
 							throw new NotYetImplementedException( "Collections having FK in secondary table" );
 						}
 					}
 					collectionBinder.setFkJoinColumns( joinColumns );
 					mappedBy = oneToManyAnn.mappedBy();
 					collectionBinder.setTargetEntity(
 							context.getBuildingOptions().getReflectionManager().toXClass( oneToManyAnn.targetEntity() )
 					);
 					collectionBinder.setCascadeStrategy(
 							getCascadeStrategy(
 									oneToManyAnn.cascade(), hibernateCascade, oneToManyAnn.orphanRemoval(), false
 							)
 					);
 					collectionBinder.setOneToMany( true );
 				}
 				else if ( elementCollectionAnn != null ) {
 					for ( Ejb3JoinColumn column : joinColumns ) {
 						if ( column.isSecondary() ) {
 							throw new NotYetImplementedException( "Collections having FK in secondary table" );
 						}
 					}
 					collectionBinder.setFkJoinColumns( joinColumns );
 					mappedBy = "";
 					final Class<?> targetElement = elementCollectionAnn.targetClass();
 					collectionBinder.setTargetEntity(
 							context.getBuildingOptions().getReflectionManager().toXClass( targetElement )
 					);
 					//collectionBinder.setCascadeStrategy( getCascadeStrategy( embeddedCollectionAnn.cascade(), hibernateCascade ) );
 					collectionBinder.setOneToMany( true );
 				}
 				else if ( manyToManyAnn != null ) {
 					mappedBy = manyToManyAnn.mappedBy();
 					collectionBinder.setTargetEntity(
 							context.getBuildingOptions().getReflectionManager().toXClass( manyToManyAnn.targetEntity() )
 					);
 					collectionBinder.setCascadeStrategy(
 							getCascadeStrategy(
 									manyToManyAnn.cascade(), hibernateCascade, false, false
 							)
 					);
 					collectionBinder.setOneToMany( false );
 				}
 				else if ( property.isAnnotationPresent( ManyToAny.class ) ) {
 					mappedBy = "";
 					collectionBinder.setTargetEntity(
 							context.getBuildingOptions().getReflectionManager().toXClass( void.class )
 					);
 					collectionBinder.setCascadeStrategy( getCascadeStrategy( null, hibernateCascade, false, false ) );
 					collectionBinder.setOneToMany( false );
 				}
 				collectionBinder.setMappedBy( mappedBy );
 
 				bindJoinedTableAssociation(
 						property,
 						context,
 						entityBinder,
 						collectionBinder,
 						propertyHolder,
 						inferredData,
 						mappedBy
 				);
 
 				OnDelete onDeleteAnn = property.getAnnotation( OnDelete.class );
 				boolean onDeleteCascade = onDeleteAnn != null && OnDeleteAction.CASCADE.equals( onDeleteAnn.action() );
 				collectionBinder.setCascadeDeleteEnabled( onDeleteCascade );
 				if ( isIdentifierMapper ) {
 					collectionBinder.setInsertable( false );
 					collectionBinder.setUpdatable( false );
 				}
 				if ( property.isAnnotationPresent( CollectionId.class ) ) { //do not compute the generators unless necessary
 					HashMap<String, IdentifierGeneratorDefinition> localGenerators = ( HashMap<String, IdentifierGeneratorDefinition> ) classGenerators.clone();
 					localGenerators.putAll( buildLocalGenerators( property, context ) );
 					collectionBinder.setLocalGenerators( localGenerators );
 
 				}
 				collectionBinder.setInheritanceStatePerClass( inheritanceStatePerClass );
 				collectionBinder.setDeclaringClass( inferredData.getDeclaringClass() );
 				collectionBinder.bind();
 
 			}
 			//Either a regular property or a basic @Id or @EmbeddedId while not ignoring id annotations
 			else if ( !isId || !entityBinder.isIgnoreIdAnnotations() ) {
 				//define whether the type is a component or not
 
 				boolean isComponent = false;
 
 				//Overrides from @MapsId if needed
 				boolean isOverridden = false;
 				if ( isId || propertyHolder.isOrWithinEmbeddedId() || propertyHolder.isInIdClass() ) {
 					//the associated entity could be using an @IdClass making the overridden property a component
 					final PropertyData overridingProperty = BinderHelper.getPropertyOverriddenByMapperOrMapsId(
 							isId,
 							propertyHolder,
 							property.getName(),
 							context
 					);
 					if ( overridingProperty != null ) {
 						isOverridden = true;
 						final InheritanceState state = inheritanceStatePerClass.get( overridingProperty.getClassOrElement() );
 						if ( state != null ) {
 							isComponent = isComponent || state.hasIdClassOrEmbeddedId();
 						}
 						//Get the new column
 						columns = columnsBuilder.overrideColumnFromMapperOrMapsIdProperty( isId );
 					}
 				}
 
 				isComponent = isComponent
 						|| property.isAnnotationPresent( Embedded.class )
 						|| property.isAnnotationPresent( EmbeddedId.class )
 						|| returnedClass.isAnnotationPresent( Embeddable.class );
 
 
 				if ( isComponent ) {
 					String referencedEntityName = null;
 					if ( isOverridden ) {
 						final PropertyData mapsIdProperty = BinderHelper.getPropertyOverriddenByMapperOrMapsId(
 								isId, propertyHolder, property.getName(), context
 						);
 						referencedEntityName = mapsIdProperty.getClassOrElementName();
 					}
 					AccessType propertyAccessor = entityBinder.getPropertyAccessor( property );
 					propertyBinder = bindComponent(
 							inferredData,
 							propertyHolder,
 							propertyAccessor,
 							entityBinder,
 							isIdentifierMapper,
 							context,
 							isComponentEmbedded,
 							isId,
 							inheritanceStatePerClass,
 							referencedEntityName,
 							isOverridden ? ( Ejb3JoinColumn[] ) columns : null
 					);
 				}
 				else {
 					//provide the basic property mapping
 					boolean optional = true;
 					boolean lazy = false;
 					if ( property.isAnnotationPresent( Basic.class ) ) {
 						Basic ann = property.getAnnotation( Basic.class );
 						optional = ann.optional();
 						lazy = ann.fetch() == FetchType.LAZY;
 					}
 					//implicit type will check basic types and Serializable classes
 					if ( isId || ( !optional && nullability != Nullability.FORCED_NULL ) ) {
 						//force columns to not null
 						for ( Ejb3Column col : columns ) {
 							col.forceNotNull();
 						}
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/EntityBinder.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/EntityBinder.java
index aa55b0b219..ac239312db 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/EntityBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/EntityBinder.java
@@ -1,1173 +1,1174 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.annotations;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import javax.persistence.Access;
+import javax.persistence.ConstraintMode;
+import javax.persistence.Entity;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.NamedEntityGraph;
+import javax.persistence.NamedEntityGraphs;
+import javax.persistence.PrimaryKeyJoinColumn;
+import javax.persistence.SecondaryTable;
+import javax.persistence.SecondaryTables;
+
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.BatchSize;
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.DynamicInsert;
 import org.hibernate.annotations.DynamicUpdate;
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.Filter;
 import org.hibernate.annotations.Immutable;
 import org.hibernate.annotations.Loader;
 import org.hibernate.annotations.NaturalIdCache;
 import org.hibernate.annotations.OptimisticLockType;
 import org.hibernate.annotations.OptimisticLocking;
 import org.hibernate.annotations.Persister;
 import org.hibernate.annotations.Polymorphism;
 import org.hibernate.annotations.PolymorphismType;
 import org.hibernate.annotations.Proxy;
 import org.hibernate.annotations.RowId;
 import org.hibernate.annotations.SQLDelete;
 import org.hibernate.annotations.SQLDeleteAll;
 import org.hibernate.annotations.SQLInsert;
 import org.hibernate.annotations.SQLUpdate;
 import org.hibernate.annotations.SelectBeforeUpdate;
 import org.hibernate.annotations.Subselect;
 import org.hibernate.annotations.Synchronize;
 import org.hibernate.annotations.Tables;
 import org.hibernate.annotations.Tuplizer;
 import org.hibernate.annotations.Tuplizers;
 import org.hibernate.annotations.Where;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XAnnotatedElement;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.boot.model.naming.EntityNaming;
 import org.hibernate.boot.model.naming.Identifier;
 import org.hibernate.boot.model.naming.ImplicitEntityNameSource;
 import org.hibernate.boot.model.naming.NamingStrategyHelper;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.InFlightMetadataCollector;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.cfg.AccessType;
 import org.hibernate.cfg.AnnotationBinder;
 import org.hibernate.cfg.BinderHelper;
 import org.hibernate.cfg.Ejb3JoinColumn;
 import org.hibernate.cfg.InheritanceState;
 import org.hibernate.cfg.ObjectNameSource;
 import org.hibernate.cfg.PropertyHolder;
 import org.hibernate.cfg.UniqueConstraintHolder;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.TableOwner;
 import org.hibernate.mapping.Value;
-import org.jboss.logging.Logger;
 
-import javax.persistence.Access;
-import javax.persistence.ConstraintMode;
-import javax.persistence.Entity;
-import javax.persistence.JoinColumn;
-import javax.persistence.JoinTable;
-import javax.persistence.NamedEntityGraph;
-import javax.persistence.NamedEntityGraphs;
-import javax.persistence.PrimaryKeyJoinColumn;
-import javax.persistence.SecondaryTable;
-import javax.persistence.SecondaryTables;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
+import org.jboss.logging.Logger;
 
 import static org.hibernate.cfg.BinderHelper.toAliasEntityMap;
 import static org.hibernate.cfg.BinderHelper.toAliasTableMap;
 
 
 /**
  * Stateful holder and processor for binding Entity information
  *
  * @author Emmanuel Bernard
  */
 public class EntityBinder {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, EntityBinder.class.getName());
     private static final String NATURAL_ID_CACHE_SUFFIX = "##NaturalId";
 
 	private MetadataBuildingContext context;
 
 	private String name;
 	private XClass annotatedClass;
 	private PersistentClass persistentClass;
 	private String discriminatorValue = "";
 	private Boolean forceDiscriminator;
 	private Boolean insertableDiscriminator;
 	private boolean dynamicInsert;
 	private boolean dynamicUpdate;
 	private boolean explicitHibernateEntityAnnotation;
 	private OptimisticLockType optimisticLockType;
 	private PolymorphismType polymorphismType;
 	private boolean selectBeforeUpdate;
 	private int batchSize;
 	private boolean lazy;
 	private XClass proxyClass;
 	private String where;
 	// todo : we should defer to InFlightMetadataCollector.EntityTableXref for secondary table tracking;
 	//		atm we use both from here; HBM binding solely uses InFlightMetadataCollector.EntityTableXref
 	private java.util.Map<String, Join> secondaryTables = new HashMap<String, Join>();
 	private java.util.Map<String, Object> secondaryTableJoins = new HashMap<String, Object>();
 	private String cacheConcurrentStrategy;
 	private String cacheRegion;
 	private String naturalIdCacheRegion;
 	private List<Filter> filters = new ArrayList<Filter>();
 	private InheritanceState inheritanceState;
 	private boolean ignoreIdAnnotations;
 	private boolean cacheLazyProperty;
 	private AccessType propertyAccessType = AccessType.DEFAULT;
 	private boolean wrapIdsInEmbeddedComponents;
 	private String subselect;
 
 	public boolean wrapIdsInEmbeddedComponents() {
 		return wrapIdsInEmbeddedComponents;
 	}
 
 	/**
 	 * Use as a fake one for Collection of elements
 	 */
 	public EntityBinder() {
 	}
 
 	public EntityBinder(
 			Entity ejb3Ann,
 			org.hibernate.annotations.Entity hibAnn,
 			XClass annotatedClass,
 			PersistentClass persistentClass,
 			MetadataBuildingContext context) {
 		this.context = context;
 		this.persistentClass = persistentClass;
 		this.annotatedClass = annotatedClass;
 		bindEjb3Annotation( ejb3Ann );
 		bindHibernateAnnotation( hibAnn );
 	}
 
 
 	@SuppressWarnings("SimplifiableConditionalExpression")
 	private void bindHibernateAnnotation(org.hibernate.annotations.Entity hibAnn) {
 		{
 			final DynamicInsert dynamicInsertAnn = annotatedClass.getAnnotation( DynamicInsert.class );
 			this.dynamicInsert = dynamicInsertAnn == null
 					? ( hibAnn == null ? false : hibAnn.dynamicInsert() )
 					: dynamicInsertAnn.value();
 		}
 
 		{
 			final DynamicUpdate dynamicUpdateAnn = annotatedClass.getAnnotation( DynamicUpdate.class );
 			this.dynamicUpdate = dynamicUpdateAnn == null
 					? ( hibAnn == null ? false : hibAnn.dynamicUpdate() )
 					: dynamicUpdateAnn.value();
 		}
 
 		{
 			final SelectBeforeUpdate selectBeforeUpdateAnn = annotatedClass.getAnnotation( SelectBeforeUpdate.class );
 			this.selectBeforeUpdate = selectBeforeUpdateAnn == null
 					? ( hibAnn == null ? false : hibAnn.selectBeforeUpdate() )
 					: selectBeforeUpdateAnn.value();
 		}
 
 		{
 			final OptimisticLocking optimisticLockingAnn = annotatedClass.getAnnotation( OptimisticLocking.class );
 			this.optimisticLockType = optimisticLockingAnn == null
 					? ( hibAnn == null ? OptimisticLockType.VERSION : hibAnn.optimisticLock() )
 					: optimisticLockingAnn.type();
 		}
 
 		{
 			final Polymorphism polymorphismAnn = annotatedClass.getAnnotation( Polymorphism.class );
 			this.polymorphismType = polymorphismAnn == null
 					? ( hibAnn == null ? PolymorphismType.IMPLICIT : hibAnn.polymorphism() )
 					: polymorphismAnn.type();
 		}
 
 		if ( hibAnn != null ) {
 			// used later in bind for logging
 			explicitHibernateEntityAnnotation = true;
 			//persister handled in bind
 		}
 	}
 
 	private void bindEjb3Annotation(Entity ejb3Ann) {
 		if ( ejb3Ann == null ) throw new AssertionFailure( "@Entity should always be not null" );
 		if ( BinderHelper.isEmptyAnnotationValue( ejb3Ann.name() ) ) {
 			name = StringHelper.unqualify( annotatedClass.getName() );
 		}
 		else {
 			name = ejb3Ann.name();
 		}
 	}
 
 	public boolean isRootEntity() {
 		// This is the best option I can think of here since PersistentClass is most likely not yet fully populated
 		return persistentClass instanceof RootClass;
 	}
 
 	public void setDiscriminatorValue(String discriminatorValue) {
 		this.discriminatorValue = discriminatorValue;
 	}
 
 	public void setForceDiscriminator(boolean forceDiscriminator) {
 		this.forceDiscriminator = forceDiscriminator;
 	}
 
 	public void setInsertableDiscriminator(boolean insertableDiscriminator) {
 		this.insertableDiscriminator = insertableDiscriminator;
 	}
 
 	public void bindEntity() {
 		persistentClass.setAbstract( annotatedClass.isAbstract() );
 		persistentClass.setClassName( annotatedClass.getName() );
 		persistentClass.setNodeName( name );
 		persistentClass.setJpaEntityName(name);
 		//persistentClass.setDynamic(false); //no longer needed with the Entity name refactoring?
 		persistentClass.setEntityName( annotatedClass.getName() );
 		bindDiscriminatorValue();
 
 		persistentClass.setLazy( lazy );
 		if ( proxyClass != null ) {
 			persistentClass.setProxyInterfaceName( proxyClass.getName() );
 		}
 		persistentClass.setDynamicInsert( dynamicInsert );
 		persistentClass.setDynamicUpdate( dynamicUpdate );
 
 		if ( persistentClass instanceof RootClass ) {
 			RootClass rootClass = (RootClass) persistentClass;
 			boolean mutable = true;
 			//priority on @Immutable, then @Entity.mutable()
 			if ( annotatedClass.isAnnotationPresent( Immutable.class ) ) {
 				mutable = false;
 			}
 			else {
 				org.hibernate.annotations.Entity entityAnn =
 						annotatedClass.getAnnotation( org.hibernate.annotations.Entity.class );
 				if ( entityAnn != null ) {
 					mutable = entityAnn.mutable();
 				}
 			}
 			rootClass.setMutable( mutable );
 			rootClass.setExplicitPolymorphism( isExplicitPolymorphism( polymorphismType ) );
 			if ( StringHelper.isNotEmpty( where ) ) rootClass.setWhere( where );
 			if ( cacheConcurrentStrategy != null ) {
 				rootClass.setCacheConcurrencyStrategy( cacheConcurrentStrategy );
 				rootClass.setCacheRegionName( cacheRegion );
 				rootClass.setLazyPropertiesCacheable( cacheLazyProperty );
 			}
 			rootClass.setNaturalIdCacheRegionName( naturalIdCacheRegion );
 			boolean forceDiscriminatorInSelects = forceDiscriminator == null
 					? context.getBuildingOptions().shouldImplicitlyForceDiscriminatorInSelect()
 					: forceDiscriminator;
 			rootClass.setForceDiscriminator( forceDiscriminatorInSelects );
 			if( insertableDiscriminator != null) {
 				rootClass.setDiscriminatorInsertable( insertableDiscriminator );
 			}
 		}
 		else {
             if (explicitHibernateEntityAnnotation) {
 				LOG.entityAnnotationOnNonRoot(annotatedClass.getName());
 			}
             if (annotatedClass.isAnnotationPresent(Immutable.class)) {
 				LOG.immutableAnnotationOnNonRoot(annotatedClass.getName());
 			}
 		}
 		persistentClass.setOptimisticLockStyle( getVersioning( optimisticLockType ) );
 		persistentClass.setSelectBeforeUpdate( selectBeforeUpdate );
 
 		//set persister if needed
 		Persister persisterAnn = annotatedClass.getAnnotation( Persister.class );
 		Class persister = null;
 		if ( persisterAnn != null ) {
 			persister = persisterAnn.impl();
 		}
 		else {
 			org.hibernate.annotations.Entity entityAnn = annotatedClass.getAnnotation( org.hibernate.annotations.Entity.class );
 			if ( entityAnn != null && !BinderHelper.isEmptyAnnotationValue( entityAnn.persister() ) ) {
 				try {
-					persister = ReflectHelper.classForName( entityAnn.persister() );
+					persister = context.getClassLoaderAccess().classForName( entityAnn.persister() );
 				}
-				catch (ClassNotFoundException cnfe) {
-					throw new AnnotationException( "Could not find persister class: " + persister );
+				catch (ClassLoadingException e) {
+					throw new AnnotationException( "Could not find persister class: " + entityAnn.persister(), e );
 				}
 			}
 		}
 		if ( persister != null ) {
 			persistentClass.setEntityPersisterClass( persister );
 		}
 
 		persistentClass.setBatchSize( batchSize );
 
 		//SQL overriding
 		SQLInsert sqlInsert = annotatedClass.getAnnotation( SQLInsert.class );
 		SQLUpdate sqlUpdate = annotatedClass.getAnnotation( SQLUpdate.class );
 		SQLDelete sqlDelete = annotatedClass.getAnnotation( SQLDelete.class );
 		SQLDeleteAll sqlDeleteAll = annotatedClass.getAnnotation( SQLDeleteAll.class );
 		Loader loader = annotatedClass.getAnnotation( Loader.class );
 
 		if ( sqlInsert != null ) {
 			persistentClass.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),
 					ExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )
 			);
 
 		}
 		if ( sqlUpdate != null ) {
 			persistentClass.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),
 					ExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )
 			);
 		}
 		if ( sqlDelete != null ) {
 			persistentClass.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),
 					ExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )
 			);
 		}
 		if ( sqlDeleteAll != null ) {
 			persistentClass.setCustomSQLDelete( sqlDeleteAll.sql(), sqlDeleteAll.callable(),
 					ExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )
 			);
 		}
 		if ( loader != null ) {
 			persistentClass.setLoaderName( loader.namedQuery() );
 		}
 
 		if ( annotatedClass.isAnnotationPresent( Synchronize.class )) {
 			Synchronize synchronizedWith = annotatedClass.getAnnotation(Synchronize.class);
 
 			String [] tables = synchronizedWith.value();
 			for (String table : tables) {
 				persistentClass.addSynchronizedTable(table);
 			}
 		}
 
 		if ( annotatedClass.isAnnotationPresent(Subselect.class )) {
 			Subselect subselect = annotatedClass.getAnnotation(Subselect.class);
 			this.subselect = subselect.value();
 		}
 
 		//tuplizers
 		if ( annotatedClass.isAnnotationPresent( Tuplizers.class ) ) {
 			for (Tuplizer tuplizer : annotatedClass.getAnnotation( Tuplizers.class ).value()) {
 				EntityMode mode = EntityMode.parse( tuplizer.entityMode() );
 				//todo tuplizer.entityModeType
 				persistentClass.addTuplizer( mode, tuplizer.impl().getName() );
 			}
 		}
 		if ( annotatedClass.isAnnotationPresent( Tuplizer.class ) ) {
 			Tuplizer tuplizer = annotatedClass.getAnnotation( Tuplizer.class );
 			EntityMode mode = EntityMode.parse( tuplizer.entityMode() );
 			//todo tuplizer.entityModeType
 			persistentClass.addTuplizer( mode, tuplizer.impl().getName() );
 		}
 
 		for ( Filter filter : filters ) {
 			String filterName = filter.name();
 			String cond = filter.condition();
 			if ( BinderHelper.isEmptyAnnotationValue( cond ) ) {
 				FilterDefinition definition = context.getMetadataCollector().getFilterDefinition( filterName );
 				cond = definition == null ? null : definition.getDefaultFilterCondition();
 				if ( StringHelper.isEmpty( cond ) ) {
 					throw new AnnotationException(
 							"no filter condition found for filter " + filterName + " in " + this.name
 					);
 				}
 			}
 			persistentClass.addFilter(filterName, cond, filter.deduceAliasInjectionPoints(), 
 					toAliasTableMap(filter.aliases()), toAliasEntityMap(filter.aliases()));
 		}
 		LOG.debugf( "Import with entity name %s", name );
 		try {
 			context.getMetadataCollector().addImport( name, persistentClass.getEntityName() );
 			String entityName = persistentClass.getEntityName();
 			if ( !entityName.equals( name ) ) {
 				context.getMetadataCollector().addImport( entityName, entityName );
 			}
 		}
 		catch (MappingException me) {
 			throw new AnnotationException( "Use of the same entity name twice: " + name, me );
 		}
 
 		processNamedEntityGraphs();
 	}
 
 	private void processNamedEntityGraphs() {
 		processNamedEntityGraph( annotatedClass.getAnnotation( NamedEntityGraph.class ) );
 		final NamedEntityGraphs graphs = annotatedClass.getAnnotation( NamedEntityGraphs.class );
 		if ( graphs != null ) {
 			for ( NamedEntityGraph graph : graphs.value() ) {
 				processNamedEntityGraph( graph );
 			}
 		}
 	}
 
 	private void processNamedEntityGraph(NamedEntityGraph annotation) {
 		if ( annotation == null ) {
 			return;
 		}
 		context.getMetadataCollector().addNamedEntityGraph(
 				new NamedEntityGraphDefinition( annotation, name, persistentClass.getEntityName() )
 		);
 	}
 	
 	public void bindDiscriminatorValue() {
 		if ( StringHelper.isEmpty( discriminatorValue ) ) {
 			Value discriminator = persistentClass.getDiscriminator();
 			if ( discriminator == null ) {
 				persistentClass.setDiscriminatorValue( name );
 			}
 			else if ( "character".equals( discriminator.getType().getName() ) ) {
 				throw new AnnotationException(
 						"Using default @DiscriminatorValue for a discriminator of type CHAR is not safe"
 				);
 			}
 			else if ( "integer".equals( discriminator.getType().getName() ) ) {
 				persistentClass.setDiscriminatorValue( String.valueOf( name.hashCode() ) );
 			}
 			else {
 				persistentClass.setDiscriminatorValue( name ); //Spec compliant
 			}
 		}
 		else {
 			//persistentClass.getDiscriminator()
 			persistentClass.setDiscriminatorValue( discriminatorValue );
 		}
 	}
 
 	OptimisticLockStyle getVersioning(OptimisticLockType type) {
 		switch ( type ) {
 			case VERSION:
 				return OptimisticLockStyle.VERSION;
 			case NONE:
 				return OptimisticLockStyle.NONE;
 			case DIRTY:
 				return OptimisticLockStyle.DIRTY;
 			case ALL:
 				return OptimisticLockStyle.ALL;
 			default:
 				throw new AssertionFailure( "optimistic locking not supported: " + type );
 		}
 	}
 
 	private boolean isExplicitPolymorphism(PolymorphismType type) {
 		switch ( type ) {
 			case IMPLICIT:
 				return false;
 			case EXPLICIT:
 				return true;
 			default:
 				throw new AssertionFailure( "Unknown polymorphism type: " + type );
 		}
 	}
 
 	public void setBatchSize(BatchSize sizeAnn) {
 		if ( sizeAnn != null ) {
 			batchSize = sizeAnn.size();
 		}
 		else {
 			batchSize = -1;
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void setProxy(Proxy proxy) {
 		if ( proxy != null ) {
 			lazy = proxy.lazy();
 			if ( !lazy ) {
 				proxyClass = null;
 			}
 			else {
 				final ReflectionManager reflectionManager = context.getBuildingOptions().getReflectionManager();
 				if ( AnnotationBinder.isDefault( reflectionManager.toXClass( proxy.proxyClass() ), context ) ) {
 					proxyClass = annotatedClass;
 				}
 				else {
 					proxyClass = reflectionManager.toXClass( proxy.proxyClass() );
 				}
 			}
 		}
 		else {
 			lazy = true; //needed to allow association lazy loading.
 			proxyClass = annotatedClass;
 		}
 	}
 
 	public void setWhere(Where whereAnn) {
 		if ( whereAnn != null ) {
 			where = whereAnn.clause();
 		}
 	}
 
 	public void setWrapIdsInEmbeddedComponents(boolean wrapIdsInEmbeddedComponents) {
 		this.wrapIdsInEmbeddedComponents = wrapIdsInEmbeddedComponents;
 	}
 
 
 	private static class EntityTableObjectNameSource implements ObjectNameSource {
 		private final String explicitName;
 		private final String logicalName;
 
 		private EntityTableObjectNameSource(String explicitName, String entityName) {
 			this.explicitName = explicitName;
 			this.logicalName = StringHelper.isNotEmpty( explicitName )
 					? explicitName
 					: StringHelper.unqualify( entityName );
 		}
 
 		public String getExplicitName() {
 			return explicitName;
 		}
 
 		public String getLogicalName() {
 			return logicalName;
 		}
 	}
 
 	private static class EntityTableNamingStrategyHelper implements NamingStrategyHelper {
 		private final String className;
 		private final String entityName;
 		private final String jpaEntityName;
 
 		private EntityTableNamingStrategyHelper(String className, String entityName, String jpaEntityName) {
 			this.className = className;
 			this.entityName = entityName;
 			this.jpaEntityName = jpaEntityName;
 		}
 
 		public Identifier determineImplicitName(final MetadataBuildingContext buildingContext) {
 			return buildingContext.getBuildingOptions().getImplicitNamingStrategy().determinePrimaryTableName(
 					new ImplicitEntityNameSource() {
 						private final EntityNaming entityNaming = new EntityNaming() {
 							@Override
 							public String getClassName() {
 								return className;
 							}
 
 							@Override
 							public String getEntityName() {
 								return entityName;
 							}
 
 							@Override
 							public String getJpaEntityName() {
 								return jpaEntityName;
 							}
 						};
 
 						@Override
 						public EntityNaming getEntityNaming() {
 							return entityNaming;
 						}
 
 						@Override
 						public MetadataBuildingContext getBuildingContext() {
 							return buildingContext;
 						}
 					}
 			);
 		}
 
 		@Override
 		public Identifier handleExplicitName(String explicitName, MetadataBuildingContext buildingContext) {
 			return buildingContext.getMetadataCollector()
 					.getDatabase()
 					.getJdbcEnvironment()
 					.getIdentifierHelper()
 					.toIdentifier( explicitName );
 		}
 
 		@Override
 		public Identifier toPhysicalName(Identifier logicalName, MetadataBuildingContext buildingContext) {
 			return buildingContext.getBuildingOptions().getPhysicalNamingStrategy().toPhysicalTableName(
 					logicalName,
 					buildingContext.getMetadataCollector().getDatabase().getJdbcEnvironment()
 			);
 		}
 	}
 
 	public void bindTableForDiscriminatedSubclass(InFlightMetadataCollector.EntityTableXref superTableXref) {
 		if ( !SingleTableSubclass.class.isInstance( persistentClass ) ) {
 			throw new AssertionFailure(
 					"Was expecting a discriminated subclass [" + SingleTableSubclass.class.getName() +
 							"] but found [" + persistentClass.getClass().getName() + "] for entity [" +
 							persistentClass.getEntityName() + "]"
 			);
 		}
 
 		context.getMetadataCollector().addEntityTableXref(
 				persistentClass.getEntityName(),
 				context.getMetadataCollector().getDatabase().toIdentifier(
 						context.getMetadataCollector().getLogicalTableName(
 								superTableXref.getPrimaryTable()
 						)
 				),
 				superTableXref.getPrimaryTable(),
 				superTableXref
 		);
 	}
 
 	public void bindTable(
 			String schema,
 			String catalog,
 			String tableName,
 			List<UniqueConstraintHolder> uniqueConstraints,
 			String constraints,
 			InFlightMetadataCollector.EntityTableXref denormalizedSuperTableXref) {
 		EntityTableNamingStrategyHelper namingStrategyHelper = new EntityTableNamingStrategyHelper(
 				persistentClass.getClassName(),
 				persistentClass.getEntityName(),
 				name
 		);
 
 		final Identifier logicalName;
 		if ( StringHelper.isNotEmpty( tableName ) ) {
 			logicalName = namingStrategyHelper.handleExplicitName( tableName, context );
 		}
 		else {
 			logicalName = namingStrategyHelper.determineImplicitName( context );
 		}
 
 		final Table table = TableBinder.buildAndFillTable(
 				schema,
 				catalog,
 				logicalName,
 				persistentClass.isAbstract(),
 				uniqueConstraints,
 				null,
 				constraints,
 				context,
 				this.subselect,
 				denormalizedSuperTableXref
 		);
 		final RowId rowId = annotatedClass.getAnnotation( RowId.class );
 		if ( rowId != null ) {
 			table.setRowId( rowId.value() );
 		}
 
 		context.getMetadataCollector().addEntityTableXref(
 				persistentClass.getEntityName(),
 				logicalName,
 				table,
 				denormalizedSuperTableXref
 		);
 
 		if ( persistentClass instanceof TableOwner ) {
 			LOG.debugf( "Bind entity %s on table %s", persistentClass.getEntityName(), table.getName() );
 			( (TableOwner) persistentClass ).setTable( table );
 		}
 		else {
 			throw new AssertionFailure( "binding a table for a subclass" );
 		}
 	}
 
 	public void finalSecondaryTableBinding(PropertyHolder propertyHolder) {
 		/*
 		 * Those operations has to be done after the id definition of the persistence class.
 		 * ie after the properties parsing
 		 */
 		Iterator joins = secondaryTables.values().iterator();
 		Iterator joinColumns = secondaryTableJoins.values().iterator();
 
 		while ( joins.hasNext() ) {
 			Object uncastedColumn = joinColumns.next();
 			Join join = (Join) joins.next();
 			createPrimaryColumnsToSecondaryTable( uncastedColumn, propertyHolder, join );
 		}
 	}
 
 	private void createPrimaryColumnsToSecondaryTable(Object uncastedColumn, PropertyHolder propertyHolder, Join join) {
 		Ejb3JoinColumn[] ejb3JoinColumns;
 		PrimaryKeyJoinColumn[] pkColumnsAnn = null;
 		JoinColumn[] joinColumnsAnn = null;
 		if ( uncastedColumn instanceof PrimaryKeyJoinColumn[] ) {
 			pkColumnsAnn = (PrimaryKeyJoinColumn[]) uncastedColumn;
 		}
 		if ( uncastedColumn instanceof JoinColumn[] ) {
 			joinColumnsAnn = (JoinColumn[]) uncastedColumn;
 		}
 		if ( pkColumnsAnn == null && joinColumnsAnn == null ) {
 			ejb3JoinColumns = new Ejb3JoinColumn[1];
 			ejb3JoinColumns[0] = Ejb3JoinColumn.buildJoinColumn(
 					null,
 					null,
 					persistentClass.getIdentifier(),
 					secondaryTables,
 					propertyHolder,
 					context
 			);
 		}
 		else {
 			int nbrOfJoinColumns = pkColumnsAnn != null ?
 					pkColumnsAnn.length :
 					joinColumnsAnn.length;
 			if ( nbrOfJoinColumns == 0 ) {
 				ejb3JoinColumns = new Ejb3JoinColumn[1];
 				ejb3JoinColumns[0] = Ejb3JoinColumn.buildJoinColumn(
 						null,
 						null,
 						persistentClass.getIdentifier(),
 						secondaryTables,
 						propertyHolder,
 						context
 				);
 			}
 			else {
 				ejb3JoinColumns = new Ejb3JoinColumn[nbrOfJoinColumns];
 				if ( pkColumnsAnn != null ) {
 					for (int colIndex = 0; colIndex < nbrOfJoinColumns; colIndex++) {
 						ejb3JoinColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(
 								pkColumnsAnn[colIndex],
 								null,
 								persistentClass.getIdentifier(),
 								secondaryTables,
 								propertyHolder,
 								context
 						);
 					}
 				}
 				else {
 					for (int colIndex = 0; colIndex < nbrOfJoinColumns; colIndex++) {
 						ejb3JoinColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(
 								null,
 								joinColumnsAnn[colIndex],
 								persistentClass.getIdentifier(),
 								secondaryTables,
 								propertyHolder,
 								context
 						);
 					}
 				}
 			}
 		}
 
 		for (Ejb3JoinColumn joinColumn : ejb3JoinColumns) {
 			joinColumn.forceNotNull();
 		}
 		bindJoinToPersistentClass( join, ejb3JoinColumns, context );
 	}
 
 	private void bindJoinToPersistentClass(Join join, Ejb3JoinColumn[] ejb3JoinColumns, MetadataBuildingContext buildingContext) {
 		SimpleValue key = new DependantValue( buildingContext.getMetadataCollector(), join.getTable(), persistentClass.getIdentifier() );
 		join.setKey( key );
 		setFKNameIfDefined( join );
 		key.setCascadeDeleteEnabled( false );
 		TableBinder.bindFk( persistentClass, null, ejb3JoinColumns, key, false, buildingContext );
 		join.createPrimaryKey();
 		join.createForeignKey();
 		persistentClass.addJoin( join );
 	}
 
 	private void setFKNameIfDefined(Join join) {
 		// just awful..
 
 		org.hibernate.annotations.Table matchingTable = findMatchingComplimentTableAnnotation( join );
 		if ( matchingTable != null && !BinderHelper.isEmptyAnnotationValue( matchingTable.foreignKey().name() ) ) {
 			( (SimpleValue) join.getKey() ).setForeignKeyName( matchingTable.foreignKey().name() );
 		}
 		else {
 			javax.persistence.SecondaryTable jpaSecondaryTable = findMatchingSecondaryTable( join );
 			if ( jpaSecondaryTable != null ) {
 				if ( jpaSecondaryTable.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {
 					( (SimpleValue) join.getKey() ).setForeignKeyName( "none" );
 				}
 				else {
 					( (SimpleValue) join.getKey() ).setForeignKeyName( StringHelper.nullIfEmpty( jpaSecondaryTable.foreignKey().name() ) );
 				}
 			}
 		}
 	}
 
 	private SecondaryTable findMatchingSecondaryTable(Join join) {
 		final String nameToMatch = join.getTable().getQuotedName();
 
 		SecondaryTable secondaryTable = annotatedClass.getAnnotation( SecondaryTable.class );
 		if ( secondaryTable != null && nameToMatch.equals( secondaryTable.name() ) ) {
 			return secondaryTable;
 		}
 
 		SecondaryTables secondaryTables = annotatedClass.getAnnotation( SecondaryTables.class );
 		if ( secondaryTables != null ) {
 			for ( SecondaryTable secondaryTable2 : secondaryTables.value() ) {
 				if ( secondaryTable != null && nameToMatch.equals( secondaryTable.name() ) ) {
 					return secondaryTable;
 				}
 			}
 
 		}
 
 		return null;
 	}
 
 	private org.hibernate.annotations.Table findMatchingComplimentTableAnnotation(Join join) {
 		String tableName = join.getTable().getQuotedName();
 		org.hibernate.annotations.Table table = annotatedClass.getAnnotation( org.hibernate.annotations.Table.class );
 		org.hibernate.annotations.Table matchingTable = null;
 		if ( table != null && tableName.equals( table.appliesTo() ) ) {
 			matchingTable = table;
 		}
 		else {
 			Tables tables = annotatedClass.getAnnotation( Tables.class );
 			if ( tables != null ) {
 				for (org.hibernate.annotations.Table current : tables.value()) {
 					if ( tableName.equals( current.appliesTo() ) ) {
 						matchingTable = current;
 						break;
 					}
 				}
 			}
 		}
 		return matchingTable;
 	}
 
 	public void firstLevelSecondaryTablesBinding(
 			SecondaryTable secTable, SecondaryTables secTables
 	) {
 		if ( secTables != null ) {
 			//loop through it
 			for (SecondaryTable tab : secTables.value()) {
 				addJoin( tab, null, null, false );
 			}
 		}
 		else {
 			if ( secTable != null ) addJoin( secTable, null, null, false );
 		}
 	}
 
 	//Used for @*ToMany @JoinTable
 	public Join addJoin(JoinTable joinTable, PropertyHolder holder, boolean noDelayInPkColumnCreation) {
 		return addJoin( null, joinTable, holder, noDelayInPkColumnCreation );
 	}
 
 	private static class SecondaryTableNameSource implements ObjectNameSource {
 		// always has an explicit name
 		private final String explicitName;
 
 		private SecondaryTableNameSource(String explicitName) {
 			this.explicitName = explicitName;
 		}
 
 		public String getExplicitName() {
 			return explicitName;
 		}
 
 		public String getLogicalName() {
 			return explicitName;
 		}
 	}
 
 	private static class SecondaryTableNamingStrategyHelper implements NamingStrategyHelper {
 		@Override
 		public Identifier determineImplicitName(MetadataBuildingContext buildingContext) {
 			// should maybe throw an exception here
 			return null;
 		}
 
 		@Override
 		public Identifier handleExplicitName(String explicitName, MetadataBuildingContext buildingContext) {
 			return buildingContext.getMetadataCollector()
 					.getDatabase()
 					.getJdbcEnvironment()
 					.getIdentifierHelper()
 					.toIdentifier( explicitName );
 		}
 
 		@Override
 		public Identifier toPhysicalName(Identifier logicalName, MetadataBuildingContext buildingContext) {
 			return buildingContext.getBuildingOptions().getPhysicalNamingStrategy().toPhysicalTableName(
 					logicalName,
 					buildingContext.getMetadataCollector().getDatabase().getJdbcEnvironment()
 			);
 		}
 	}
 
 	private static SecondaryTableNamingStrategyHelper SEC_TBL_NS_HELPER = new SecondaryTableNamingStrategyHelper();
 
 	private Join addJoin(
 			SecondaryTable secondaryTable,
 			JoinTable joinTable,
 			PropertyHolder propertyHolder,
 			boolean noDelayInPkColumnCreation) {
 		// A non null propertyHolder means than we process the Pk creation without delay
 		Join join = new Join();
 		join.setPersistentClass( persistentClass );
 
 		final String schema;
 		final String catalog;
 		final SecondaryTableNameSource secondaryTableNameContext;
 		final Object joinColumns;
 		final List<UniqueConstraintHolder> uniqueConstraintHolders;
 
 		final Identifier logicalName;
 		if ( secondaryTable != null ) {
 			schema = secondaryTable.schema();
 			catalog = secondaryTable.catalog();
 			logicalName = context.getMetadataCollector()
 					.getDatabase()
 					.getJdbcEnvironment()
 					.getIdentifierHelper()
 					.toIdentifier( secondaryTable.name() );
 			joinColumns = secondaryTable.pkJoinColumns();
 			uniqueConstraintHolders = TableBinder.buildUniqueConstraintHolders( secondaryTable.uniqueConstraints() );
 		}
 		else if ( joinTable != null ) {
 			schema = joinTable.schema();
 			catalog = joinTable.catalog();
 			logicalName = context.getMetadataCollector()
 					.getDatabase()
 					.getJdbcEnvironment()
 					.getIdentifierHelper()
 					.toIdentifier( joinTable.name() );
 			joinColumns = joinTable.joinColumns();
 			uniqueConstraintHolders = TableBinder.buildUniqueConstraintHolders( joinTable.uniqueConstraints() );
 		}
 		else {
 			throw new AssertionFailure( "Both JoinTable and SecondaryTable are null" );
 		}
 
 		final Table table = TableBinder.buildAndFillTable(
 				schema,
 				catalog,
 				logicalName,
 				false,
 				uniqueConstraintHolders,
 				null,
 				null,
 				context,
 				null,
 				null
 		);
 
 		final InFlightMetadataCollector.EntityTableXref tableXref = context.getMetadataCollector().getEntityTableXref( persistentClass.getEntityName() );
 		assert tableXref != null : "Could not locate EntityTableXref for entity [" + persistentClass.getEntityName() + "]";
 		tableXref.addSecondaryTable( logicalName, join );
 
 		if ( secondaryTable != null ) {
 			TableBinder.addIndexes( table, secondaryTable.indexes(), context );
 		}
 
 			//no check constraints available on joins
 		join.setTable( table );
 
 		//somehow keep joins() for later.
 		//Has to do the work later because it needs persistentClass id!
 		LOG.debugf( "Adding secondary table to entity %s -> %s", persistentClass.getEntityName(), join.getTable().getName() );
 		org.hibernate.annotations.Table matchingTable = findMatchingComplimentTableAnnotation( join );
 		if ( matchingTable != null ) {
 			join.setSequentialSelect( FetchMode.JOIN != matchingTable.fetch() );
 			join.setInverse( matchingTable.inverse() );
 			join.setOptional( matchingTable.optional() );
 			if ( !BinderHelper.isEmptyAnnotationValue( matchingTable.sqlInsert().sql() ) ) {
 				join.setCustomSQLInsert( matchingTable.sqlInsert().sql().trim(),
 						matchingTable.sqlInsert().callable(),
 						ExecuteUpdateResultCheckStyle.fromExternalName(
 								matchingTable.sqlInsert().check().toString().toLowerCase(Locale.ROOT)
 						)
 				);
 			}
 			if ( !BinderHelper.isEmptyAnnotationValue( matchingTable.sqlUpdate().sql() ) ) {
 				join.setCustomSQLUpdate( matchingTable.sqlUpdate().sql().trim(),
 						matchingTable.sqlUpdate().callable(),
 						ExecuteUpdateResultCheckStyle.fromExternalName(
 								matchingTable.sqlUpdate().check().toString().toLowerCase(Locale.ROOT)
 						)
 				);
 			}
 			if ( !BinderHelper.isEmptyAnnotationValue( matchingTable.sqlDelete().sql() ) ) {
 				join.setCustomSQLDelete( matchingTable.sqlDelete().sql().trim(),
 						matchingTable.sqlDelete().callable(),
 						ExecuteUpdateResultCheckStyle.fromExternalName(
 								matchingTable.sqlDelete().check().toString().toLowerCase(Locale.ROOT)
 						)
 				);
 			}
 		}
 		else {
 			//default
 			join.setSequentialSelect( false );
 			join.setInverse( false );
 			join.setOptional( true ); //perhaps not quite per-spec, but a Good Thing anyway
 		}
 
 		if ( noDelayInPkColumnCreation ) {
 			createPrimaryColumnsToSecondaryTable( joinColumns, propertyHolder, join );
 		}
 		else {
 			secondaryTables.put( table.getQuotedName(), join );
 			secondaryTableJoins.put( table.getQuotedName(), joinColumns );
 		}
 
 		return join;
 	}
 
 	public java.util.Map<String, Join> getSecondaryTables() {
 		return secondaryTables;
 	}
 
 	public void setCache(Cache cacheAnn) {
 		if ( cacheAnn != null ) {
 			cacheRegion = BinderHelper.isEmptyAnnotationValue( cacheAnn.region() ) ?
 					null :
 					cacheAnn.region();
 			cacheConcurrentStrategy = getCacheConcurrencyStrategy( cacheAnn.usage() );
 			if ( "all".equalsIgnoreCase( cacheAnn.include() ) ) {
 				cacheLazyProperty = true;
 			}
 			else if ( "non-lazy".equalsIgnoreCase( cacheAnn.include() ) ) {
 				cacheLazyProperty = false;
 			}
 			else {
 				throw new AnnotationException( "Unknown lazy property annotations: " + cacheAnn.include() );
 			}
 		}
 		else {
 			cacheConcurrentStrategy = null;
 			cacheRegion = null;
 			cacheLazyProperty = true;
 		}
 	}
 	
 	public void setNaturalIdCache(XClass clazzToProcess, NaturalIdCache naturalIdCacheAnn) {
 		if ( naturalIdCacheAnn != null ) {
 			if ( BinderHelper.isEmptyAnnotationValue( naturalIdCacheAnn.region() ) ) {
 				if (cacheRegion != null) {
 					naturalIdCacheRegion = cacheRegion + NATURAL_ID_CACHE_SUFFIX;
 				}
 				else {
 					naturalIdCacheRegion = clazzToProcess.getName() + NATURAL_ID_CACHE_SUFFIX;
 				}
 			}
 			else {
 				naturalIdCacheRegion = naturalIdCacheAnn.region();
 			}
 		}
 		else {
 			naturalIdCacheRegion = null;
 		}
 	}
 
 	public static String getCacheConcurrencyStrategy(CacheConcurrencyStrategy strategy) {
 		org.hibernate.cache.spi.access.AccessType accessType = strategy.toAccessType();
 		return accessType == null ? null : accessType.getExternalName();
 	}
 
 	public void addFilter(Filter filter) {
 		filters.add(filter);
 	}
 
 	public void setInheritanceState(InheritanceState inheritanceState) {
 		this.inheritanceState = inheritanceState;
 	}
 
 	public boolean isIgnoreIdAnnotations() {
 		return ignoreIdAnnotations;
 	}
 
 	public void setIgnoreIdAnnotations(boolean ignoreIdAnnotations) {
 		this.ignoreIdAnnotations = ignoreIdAnnotations;
 	}
 	public void processComplementaryTableDefinitions(javax.persistence.Table table) {
 		if ( table == null ) return;
 		TableBinder.addIndexes( persistentClass.getTable(), table.indexes(), context );
 	}
 	public void processComplementaryTableDefinitions(org.hibernate.annotations.Table table) {
 		//comment and index are processed here
 		if ( table == null ) return;
 		String appliedTable = table.appliesTo();
 		Iterator tables = persistentClass.getTableClosureIterator();
 		Table hibTable = null;
 		while ( tables.hasNext() ) {
 			Table pcTable = (Table) tables.next();
 			if ( pcTable.getQuotedName().equals( appliedTable ) ) {
 				//we are in the correct table to find columns
 				hibTable = pcTable;
 				break;
 			}
 			hibTable = null;
 		}
 		if ( hibTable == null ) {
 			//maybe a join/secondary table
 			for ( Join join : secondaryTables.values() ) {
 				if ( join.getTable().getQuotedName().equals( appliedTable ) ) {
 					hibTable = join.getTable();
 					break;
 				}
 			}
 		}
 		if ( hibTable == null ) {
 			throw new AnnotationException(
 					"@org.hibernate.annotations.Table references an unknown table: " + appliedTable
 			);
 		}
 		if ( !BinderHelper.isEmptyAnnotationValue( table.comment() ) ) hibTable.setComment( table.comment() );
 		TableBinder.addIndexes( hibTable, table.indexes(), context );
 	}
 
 	public void processComplementaryTableDefinitions(Tables tables) {
 		if ( tables == null ) return;
 		for (org.hibernate.annotations.Table table : tables.value()) {
 			processComplementaryTableDefinitions( table );
 		}
 	}
 
 	public AccessType getPropertyAccessType() {
 		return propertyAccessType;
 	}
 
 	public void setPropertyAccessType(AccessType propertyAccessor) {
 		this.propertyAccessType = getExplicitAccessType( annotatedClass );
 		// only set the access type if there is no explicit access type for this class
 		if( this.propertyAccessType == null ) {
 			this.propertyAccessType = propertyAccessor;
 		}
 	}
 
 	public AccessType getPropertyAccessor(XAnnotatedElement element) {
 		AccessType accessType = getExplicitAccessType( element );
 		if ( accessType == null ) {
 		   accessType = propertyAccessType;
 		}
 		return accessType;
 	}
 
 	public AccessType getExplicitAccessType(XAnnotatedElement element) {
 		AccessType accessType = null;
 
 		AccessType hibernateAccessType = null;
 		AccessType jpaAccessType = null;
 
 		org.hibernate.annotations.AccessType accessTypeAnnotation = element.getAnnotation( org.hibernate.annotations.AccessType.class );
 		if ( accessTypeAnnotation != null ) {
 			hibernateAccessType = AccessType.getAccessStrategy( accessTypeAnnotation.value() );
 		}
 
 		Access access = element.getAnnotation( Access.class );
 		if ( access != null ) {
 			jpaAccessType = AccessType.getAccessStrategy( access.value() );
 		}
 
 		if ( hibernateAccessType != null && jpaAccessType != null && hibernateAccessType != jpaAccessType ) {
 			throw new MappingException(
 					"Found @Access and @AccessType with conflicting values on a property in class " + annotatedClass.toString()
 			);
 		}
 
 		if ( hibernateAccessType != null ) {
 			accessType = hibernateAccessType;
 		}
 		else if ( jpaAccessType != null ) {
 			accessType = jpaAccessType;
 		}
 
 		return accessType;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/ClassLoaderAccessLazyImpl.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/ClassLoaderAccessLazyImpl.java
new file mode 100644
index 0000000000..b78aa94b6f
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/ClassLoaderAccessLazyImpl.java
@@ -0,0 +1,35 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.cfg.annotations.reflection;
+
+import java.net.URL;
+
+import org.hibernate.boot.spi.ClassLoaderAccess;
+import org.hibernate.boot.spi.MetadataBuildingOptions;
+
+/**
+ * A ClassLoaderAccess implementation based on lazy access to {@link MetadataBuildingOptions}
+ *
+ * @author Steve Ebersole
+ */
+public class ClassLoaderAccessLazyImpl implements ClassLoaderAccess {
+	private final MetadataBuildingOptions metadataBuildingOptions;
+
+	public ClassLoaderAccessLazyImpl(MetadataBuildingOptions metadataBuildingOptions) {
+		this.metadataBuildingOptions = metadataBuildingOptions;
+	}
+
+	@Override
+	public <T> Class<T> classForName(String name) {
+		return null;
+	}
+
+	@Override
+	public URL locateResource(String resourceName) {
+		return null;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAMetadataProvider.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAMetadataProvider.java
index 637da92c7e..58f6fa9329 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAMetadataProvider.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAMetadataProvider.java
@@ -1,159 +1,189 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.annotations.reflection;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.Serializable;
 import java.lang.reflect.AnnotatedElement;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.persistence.EntityListeners;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.NamedQuery;
 import javax.persistence.NamedStoredProcedureQuery;
 import javax.persistence.SequenceGenerator;
 import javax.persistence.SqlResultSetMapping;
 import javax.persistence.TableGenerator;
 
 import org.hibernate.annotations.common.reflection.AnnotationReader;
 import org.hibernate.annotations.common.reflection.MetadataProvider;
 import org.hibernate.annotations.common.reflection.java.JavaMetadataProvider;
-import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.boot.internal.ClassLoaderAccessImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
+import org.hibernate.boot.spi.ClassLoaderAccessDelegateImpl;
+import org.hibernate.boot.spi.MetadataBuildingOptions;
 
 import org.dom4j.Element;
 
 /**
  * MetadataProvider aware of the JPA Deployment descriptor
  *
  * @author Emmanuel Bernard
  */
 @SuppressWarnings("unchecked")
-public class JPAMetadataProvider implements MetadataProvider, Serializable {
-	private transient MetadataProvider delegate = new JavaMetadataProvider();
-	private transient Map<Object, Object> defaults;
-	private transient Map<AnnotatedElement, AnnotationReader> cache = new HashMap<AnnotatedElement, AnnotationReader>(100);
+public class JPAMetadataProvider implements MetadataProvider {
 
-	//all of the above can be safely rebuilt from XMLContext: only XMLContext this object is serialized
-	private XMLContext xmlContext = new XMLContext();
+	private final MetadataProvider delegate = new JavaMetadataProvider();
+
+	private final ClassLoaderAccess classLoaderAccess;
+	private final XMLContext xmlContext;
+
+	private Map<Object, Object> defaults;
+	private Map<AnnotatedElement, AnnotationReader> cache = new HashMap<AnnotatedElement, AnnotationReader>(100);
+
+	public JPAMetadataProvider(final MetadataBuildingOptions metadataBuildingOptions) {
+		classLoaderAccess = new ClassLoaderAccessDelegateImpl() {
+			ClassLoaderAccess delegate;
+
+			@Override
+			protected ClassLoaderAccess getDelegate() {
+				if ( delegate == null ) {
+					delegate = new ClassLoaderAccessImpl(
+							metadataBuildingOptions.getTempClassLoader(),
+							metadataBuildingOptions.getServiceRegistry().getService( ClassLoaderService.class )
+					);
+				}
+				return delegate;
+			}
+		};
+
+		xmlContext = new XMLContext( classLoaderAccess );
 
-	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
-		ois.defaultReadObject();
-		delegate = new JavaMetadataProvider();
-		cache = new HashMap<AnnotatedElement, AnnotationReader>(100);
 	}
+
+	//all of the above can be safely rebuilt from XMLContext: only XMLContext this object is serialized
 	@Override
 	public AnnotationReader getAnnotationReader(AnnotatedElement annotatedElement) {
 		AnnotationReader reader = cache.get( annotatedElement );
 		if (reader == null) {
 			if ( xmlContext.hasContext() ) {
-				reader = new JPAOverriddenAnnotationReader( annotatedElement, xmlContext );
+				reader = new JPAOverriddenAnnotationReader( annotatedElement, xmlContext, classLoaderAccess );
 			}
 			else {
 				reader = delegate.getAnnotationReader( annotatedElement );
 			}
 			cache.put(annotatedElement, reader);
 		}
 		return reader;
 	}
 	@Override
 	public Map<Object, Object> getDefaults() {
 		if ( defaults == null ) {
 			defaults = new HashMap<Object, Object>();
 			XMLContext.Default xmlDefaults = xmlContext.getDefault( null );
 
 			defaults.put( "schema", xmlDefaults.getSchema() );
 			defaults.put( "catalog", xmlDefaults.getCatalog() );
 			defaults.put( "delimited-identifier", xmlDefaults.getDelimitedIdentifier() );
 			List<Class> entityListeners = new ArrayList<Class>();
 			for ( String className : xmlContext.getDefaultEntityListeners() ) {
 				try {
-					entityListeners.add( ReflectHelper.classForName( className, this.getClass() ) );
+					entityListeners.add( classLoaderAccess.classForName( className ) );
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new IllegalStateException( "Default entity listener class not found: " + className );
 				}
 			}
 			defaults.put( EntityListeners.class, entityListeners );
 			for ( Element element : xmlContext.getAllDocuments() ) {
 				@SuppressWarnings( "unchecked" )
 				List<Element> elements = element.elements( "sequence-generator" );
 				List<SequenceGenerator> sequenceGenerators = ( List<SequenceGenerator> ) defaults.get( SequenceGenerator.class );
 				if ( sequenceGenerators == null ) {
 					sequenceGenerators = new ArrayList<SequenceGenerator>();
 					defaults.put( SequenceGenerator.class, sequenceGenerators );
 				}
 				for ( Element subelement : elements ) {
 					sequenceGenerators.add( JPAOverriddenAnnotationReader.buildSequenceGeneratorAnnotation( subelement ) );
 				}
 
 				elements = element.elements( "table-generator" );
 				List<TableGenerator> tableGenerators = ( List<TableGenerator> ) defaults.get( TableGenerator.class );
 				if ( tableGenerators == null ) {
 					tableGenerators = new ArrayList<TableGenerator>();
 					defaults.put( TableGenerator.class, tableGenerators );
 				}
 				for ( Element subelement : elements ) {
 					tableGenerators.add(
 							JPAOverriddenAnnotationReader.buildTableGeneratorAnnotation(
 									subelement, xmlDefaults
 							)
 					);
 				}
 
 				List<NamedQuery> namedQueries = ( List<NamedQuery> ) defaults.get( NamedQuery.class );
 				if ( namedQueries == null ) {
 					namedQueries = new ArrayList<NamedQuery>();
 					defaults.put( NamedQuery.class, namedQueries );
 				}
 				List<NamedQuery> currentNamedQueries = JPAOverriddenAnnotationReader.buildNamedQueries(
-						element, false, xmlDefaults
+						element,
+						false,
+						xmlDefaults,
+						classLoaderAccess
 				);
 				namedQueries.addAll( currentNamedQueries );
 
 				List<NamedNativeQuery> namedNativeQueries = ( List<NamedNativeQuery> ) defaults.get( NamedNativeQuery.class );
 				if ( namedNativeQueries == null ) {
 					namedNativeQueries = new ArrayList<NamedNativeQuery>();
 					defaults.put( NamedNativeQuery.class, namedNativeQueries );
 				}
 				List<NamedNativeQuery> currentNamedNativeQueries = JPAOverriddenAnnotationReader.buildNamedQueries(
-						element, true, xmlDefaults
+						element,
+						true,
+						xmlDefaults,
+						classLoaderAccess
 				);
 				namedNativeQueries.addAll( currentNamedNativeQueries );
 
 				List<SqlResultSetMapping> sqlResultSetMappings = ( List<SqlResultSetMapping> ) defaults.get(
 						SqlResultSetMapping.class
 				);
 				if ( sqlResultSetMappings == null ) {
 					sqlResultSetMappings = new ArrayList<SqlResultSetMapping>();
 					defaults.put( SqlResultSetMapping.class, sqlResultSetMappings );
 				}
 				List<SqlResultSetMapping> currentSqlResultSetMappings = JPAOverriddenAnnotationReader.buildSqlResultsetMappings(
-						element, xmlDefaults
+						element,
+						xmlDefaults,
+						classLoaderAccess
 				);
 				sqlResultSetMappings.addAll( currentSqlResultSetMappings );
 
 				List<NamedStoredProcedureQuery> namedStoredProcedureQueries = (List<NamedStoredProcedureQuery>)defaults.get( NamedStoredProcedureQuery.class );
 				if(namedStoredProcedureQueries==null){
 					namedStoredProcedureQueries = new ArrayList<NamedStoredProcedureQuery>(  );
 					defaults.put( NamedStoredProcedureQuery.class, namedStoredProcedureQueries );
 				}
 				List<NamedStoredProcedureQuery> currentNamedStoredProcedureQueries = JPAOverriddenAnnotationReader.buildNamedStoreProcedureQueries(
-						element, xmlDefaults
+						element,
+						xmlDefaults,
+						classLoaderAccess
 				);
 				namedStoredProcedureQueries.addAll( currentNamedStoredProcedureQueries );
 			}
 		}
 		return defaults;
 	}
 
 	public XMLContext getXMLContext() {
 		return xmlContext;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAOverriddenAnnotationReader.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAOverriddenAnnotationReader.java
index fe93bdb066..2446cc6d34 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAOverriddenAnnotationReader.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/JPAOverriddenAnnotationReader.java
@@ -1,2991 +1,3015 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.annotations.reflection;
 
 import java.beans.Introspector;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.AssociationOverride;
 import javax.persistence.AssociationOverrides;
 import javax.persistence.AttributeOverride;
 import javax.persistence.AttributeOverrides;
 import javax.persistence.Basic;
 import javax.persistence.Cacheable;
 import javax.persistence.CascadeType;
 import javax.persistence.CollectionTable;
 import javax.persistence.Column;
 import javax.persistence.ColumnResult;
 import javax.persistence.ConstructorResult;
 import javax.persistence.Convert;
 import javax.persistence.Converts;
 import javax.persistence.DiscriminatorColumn;
 import javax.persistence.DiscriminatorType;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.ElementCollection;
 import javax.persistence.Embeddable;
 import javax.persistence.Embedded;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.EntityListeners;
 import javax.persistence.EntityResult;
 import javax.persistence.EnumType;
 import javax.persistence.Enumerated;
 import javax.persistence.ExcludeDefaultListeners;
 import javax.persistence.ExcludeSuperclassListeners;
 import javax.persistence.FetchType;
 import javax.persistence.FieldResult;
 import javax.persistence.ForeignKey;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.Index;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.JoinTable;
 import javax.persistence.Lob;
 import javax.persistence.ManyToMany;
 import javax.persistence.ManyToOne;
 import javax.persistence.MapKey;
 import javax.persistence.MapKeyClass;
 import javax.persistence.MapKeyColumn;
 import javax.persistence.MapKeyEnumerated;
 import javax.persistence.MapKeyJoinColumn;
 import javax.persistence.MapKeyJoinColumns;
 import javax.persistence.MapKeyTemporal;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.MapsId;
 import javax.persistence.NamedAttributeNode;
 import javax.persistence.NamedEntityGraph;
 import javax.persistence.NamedEntityGraphs;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
 import javax.persistence.NamedStoredProcedureQueries;
 import javax.persistence.NamedStoredProcedureQuery;
 import javax.persistence.NamedSubgraph;
 import javax.persistence.OneToMany;
 import javax.persistence.OneToOne;
 import javax.persistence.OrderBy;
 import javax.persistence.OrderColumn;
 import javax.persistence.ParameterMode;
 import javax.persistence.PostLoad;
 import javax.persistence.PostPersist;
 import javax.persistence.PostRemove;
 import javax.persistence.PostUpdate;
 import javax.persistence.PrePersist;
 import javax.persistence.PreRemove;
 import javax.persistence.PreUpdate;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.PrimaryKeyJoinColumns;
 import javax.persistence.QueryHint;
 import javax.persistence.SecondaryTable;
 import javax.persistence.SecondaryTables;
 import javax.persistence.SequenceGenerator;
 import javax.persistence.SqlResultSetMapping;
 import javax.persistence.SqlResultSetMappings;
 import javax.persistence.StoredProcedureParameter;
 import javax.persistence.Table;
 import javax.persistence.TableGenerator;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 import javax.persistence.Transient;
 import javax.persistence.UniqueConstraint;
 import javax.persistence.Version;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.annotations.Any;
 import org.hibernate.annotations.Cascade;
 import org.hibernate.annotations.Columns;
 import org.hibernate.annotations.ManyToAny;
 import org.hibernate.annotations.common.annotationfactory.AnnotationDescriptor;
 import org.hibernate.annotations.common.annotationfactory.AnnotationFactory;
 import org.hibernate.annotations.common.reflection.AnnotationReader;
 import org.hibernate.annotations.common.reflection.ReflectionUtil;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 
 import org.dom4j.Attribute;
 import org.dom4j.Element;
 
 /**
  * Encapsulates the overriding of Java annotations from an EJB 3.0 descriptor.
  *
  * @author Paolo Perrotta
  * @author Davide Marchignoli
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 @SuppressWarnings("unchecked")
 public class JPAOverriddenAnnotationReader implements AnnotationReader {
     private static final CoreMessageLogger LOG = CoreLogging.messageLogger( JPAOverriddenAnnotationReader.class );
 
 	private static final String SCHEMA_VALIDATION = "Activate schema validation for more information";
 	private static final String WORD_SEPARATOR = "-";
 
 	private static enum PropertyType {
 		PROPERTY,
 		FIELD,
 		METHOD
 	}
 
 	private static final Map<Class, String> annotationToXml;
 
 	static {
 		annotationToXml = new HashMap<Class, String>();
 		annotationToXml.put( Entity.class, "entity" );
 		annotationToXml.put( MappedSuperclass.class, "mapped-superclass" );
 		annotationToXml.put( Embeddable.class, "embeddable" );
 		annotationToXml.put( Table.class, "table" );
 		annotationToXml.put( SecondaryTable.class, "secondary-table" );
 		annotationToXml.put( SecondaryTables.class, "secondary-table" );
 		annotationToXml.put( PrimaryKeyJoinColumn.class, "primary-key-join-column" );
 		annotationToXml.put( PrimaryKeyJoinColumns.class, "primary-key-join-column" );
 		annotationToXml.put( IdClass.class, "id-class" );
 		annotationToXml.put( Inheritance.class, "inheritance" );
 		annotationToXml.put( DiscriminatorValue.class, "discriminator-value" );
 		annotationToXml.put( DiscriminatorColumn.class, "discriminator-column" );
 		annotationToXml.put( SequenceGenerator.class, "sequence-generator" );
 		annotationToXml.put( TableGenerator.class, "table-generator" );
 		annotationToXml.put( NamedEntityGraph.class, "named-entity-graph" );
 		annotationToXml.put( NamedEntityGraphs.class, "named-entity-graph" );
 		annotationToXml.put( NamedQuery.class, "named-query" );
 		annotationToXml.put( NamedQueries.class, "named-query" );
 		annotationToXml.put( NamedNativeQuery.class, "named-native-query" );
 		annotationToXml.put( NamedNativeQueries.class, "named-native-query" );
 		annotationToXml.put( NamedStoredProcedureQuery.class, "named-stored-procedure-query" );
 		annotationToXml.put( NamedStoredProcedureQueries.class, "named-stored-procedure-query" );
 		annotationToXml.put( SqlResultSetMapping.class, "sql-result-set-mapping" );
 		annotationToXml.put( SqlResultSetMappings.class, "sql-result-set-mapping" );
 		annotationToXml.put( ExcludeDefaultListeners.class, "exclude-default-listeners" );
 		annotationToXml.put( ExcludeSuperclassListeners.class, "exclude-superclass-listeners" );
 		annotationToXml.put( AccessType.class, "access" );
 		annotationToXml.put( AttributeOverride.class, "attribute-override" );
 		annotationToXml.put( AttributeOverrides.class, "attribute-override" );
 		annotationToXml.put( AttributeOverride.class, "association-override" );
 		annotationToXml.put( AttributeOverrides.class, "association-override" );
 		annotationToXml.put( AttributeOverride.class, "map-key-attribute-override" );
 		annotationToXml.put( AttributeOverrides.class, "map-key-attribute-override" );
 		annotationToXml.put( Id.class, "id" );
 		annotationToXml.put( EmbeddedId.class, "embedded-id" );
 		annotationToXml.put( GeneratedValue.class, "generated-value" );
 		annotationToXml.put( Column.class, "column" );
 		annotationToXml.put( Columns.class, "column" );
 		annotationToXml.put( Temporal.class, "temporal" );
 		annotationToXml.put( Lob.class, "lob" );
 		annotationToXml.put( Enumerated.class, "enumerated" );
 		annotationToXml.put( Version.class, "version" );
 		annotationToXml.put( Transient.class, "transient" );
 		annotationToXml.put( Basic.class, "basic" );
 		annotationToXml.put( Embedded.class, "embedded" );
 		annotationToXml.put( ManyToOne.class, "many-to-one" );
 		annotationToXml.put( OneToOne.class, "one-to-one" );
 		annotationToXml.put( OneToMany.class, "one-to-many" );
 		annotationToXml.put( ManyToMany.class, "many-to-many" );
 		annotationToXml.put( Any.class, "any" );
 		annotationToXml.put( ManyToAny.class, "many-to-any" );
 		annotationToXml.put( JoinTable.class, "join-table" );
 		annotationToXml.put( JoinColumn.class, "join-column" );
 		annotationToXml.put( JoinColumns.class, "join-column" );
 		annotationToXml.put( MapKey.class, "map-key" );
 		annotationToXml.put( OrderBy.class, "order-by" );
 		annotationToXml.put( EntityListeners.class, "entity-listeners" );
 		annotationToXml.put( PrePersist.class, "pre-persist" );
 		annotationToXml.put( PreRemove.class, "pre-remove" );
 		annotationToXml.put( PreUpdate.class, "pre-update" );
 		annotationToXml.put( PostPersist.class, "post-persist" );
 		annotationToXml.put( PostRemove.class, "post-remove" );
 		annotationToXml.put( PostUpdate.class, "post-update" );
 		annotationToXml.put( PostLoad.class, "post-load" );
 		annotationToXml.put( CollectionTable.class, "collection-table" );
 		annotationToXml.put( MapKeyClass.class, "map-key-class" );
 		annotationToXml.put( MapKeyTemporal.class, "map-key-temporal" );
 		annotationToXml.put( MapKeyEnumerated.class, "map-key-enumerated" );
 		annotationToXml.put( MapKeyColumn.class, "map-key-column" );
 		annotationToXml.put( MapKeyJoinColumn.class, "map-key-join-column" );
 		annotationToXml.put( MapKeyJoinColumns.class, "map-key-join-column" );
 		annotationToXml.put( OrderColumn.class, "order-column" );
 		annotationToXml.put( Cacheable.class, "cacheable" );
 		annotationToXml.put( Index.class, "index" );
 		annotationToXml.put( ForeignKey.class, "foreign-key" );
 		annotationToXml.put( Convert.class, "convert" );
 		annotationToXml.put( Converts.class, "convert" );
 		annotationToXml.put( ConstructorResult.class, "constructor-result" );
 	}
 
 	private XMLContext xmlContext;
+	private final ClassLoaderAccess classLoaderAccess;
 	private final AnnotatedElement element;
 	private String className;
 	private String propertyName;
 	private PropertyType propertyType;
 	private transient Annotation[] annotations;
 	private transient Map<Class, Annotation> annotationsMap;
 	private transient List<Element> elementsForProperty;
 	private AccessibleObject mirroredAttribute;
 
-	public JPAOverriddenAnnotationReader(AnnotatedElement el, XMLContext xmlContext) {
+	public JPAOverriddenAnnotationReader(AnnotatedElement el, XMLContext xmlContext, ClassLoaderAccess classLoaderAccess) {
 		this.element = el;
 		this.xmlContext = xmlContext;
+		this.classLoaderAccess = classLoaderAccess;
+
 		if ( el instanceof Class ) {
 			Class clazz = (Class) el;
 			className = clazz.getName();
 		}
 		else if ( el instanceof Field ) {
 			Field field = (Field) el;
 			className = field.getDeclaringClass().getName();
 			propertyName = field.getName();
 			propertyType = PropertyType.FIELD;
 			String expectedGetter = "get" + Character.toUpperCase( propertyName.charAt( 0 ) ) + propertyName.substring(
 					1
 			);
 			try {
 				mirroredAttribute = field.getDeclaringClass().getDeclaredMethod( expectedGetter );
 			}
 			catch ( NoSuchMethodException e ) {
 				//no method
 			}
 		}
 		else if ( el instanceof Method ) {
 			Method method = (Method) el;
 			className = method.getDeclaringClass().getName();
 			propertyName = method.getName();
 
 			// YUCK!  The null here is the 'boundType', we'd rather get the TypeEnvironment()
 			if ( ReflectionUtil.isProperty( method, null, PersistentAttributeFilter.INSTANCE ) ) {
 				if ( propertyName.startsWith( "get" ) ) {
 					propertyName = Introspector.decapitalize( propertyName.substring( "get".length() ) );
 				}
 				else if ( propertyName.startsWith( "is" ) ) {
 					propertyName = Introspector.decapitalize( propertyName.substring( "is".length() ) );
 				}
 				else {
 					throw new RuntimeException( "Method " + propertyName + " is not a property getter" );
 				}
 				propertyType = PropertyType.PROPERTY;
 				try {
 					mirroredAttribute = method.getDeclaringClass().getDeclaredField( propertyName );
 				}
 				catch ( NoSuchFieldException e ) {
 					//no method
 				}
 			}
 			else {
 				propertyType = PropertyType.METHOD;
 			}
 		}
 		else {
 			className = null;
 			propertyName = null;
 		}
 	}
 
 	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {
 		initAnnotations();
 		return (T) annotationsMap.get( annotationType );
 	}
 
 	public <T extends Annotation> boolean isAnnotationPresent(Class<T> annotationType) {
 		initAnnotations();
 		return annotationsMap.containsKey( annotationType );
 	}
 
 	public Annotation[] getAnnotations() {
 		initAnnotations();
 		return annotations;
 	}
 
 	/*
 	 * The idea is to create annotation proxies for the xml configuration elements. Using this proxy annotations together
 	 * with the {@link JPAMetadataProvider} allows to handle xml configuration the same way as annotation configuration.
 	 */
 	private void initAnnotations() {
 		if ( annotations == null ) {
 			XMLContext.Default defaults = xmlContext.getDefault( className );
 			if ( className != null && propertyName == null ) {
 				//is a class
 				Element tree = xmlContext.getXMLTree( className );
 				Annotation[] annotations = getPhysicalAnnotations();
 				List<Annotation> annotationList = new ArrayList<Annotation>( annotations.length + 5 );
 				annotationsMap = new HashMap<Class, Annotation>( annotations.length + 5 );
 				for ( Annotation annotation : annotations ) {
 					if ( !annotationToXml.containsKey( annotation.annotationType() ) ) {
 						//unknown annotations are left over
 						annotationList.add( annotation );
 					}
 				}
 				addIfNotNull( annotationList, getEntity( tree, defaults ) );
 				addIfNotNull( annotationList, getMappedSuperclass( tree, defaults ) );
 				addIfNotNull( annotationList, getEmbeddable( tree, defaults ) );
 				addIfNotNull( annotationList, getTable( tree, defaults ) );
 				addIfNotNull( annotationList, getSecondaryTables( tree, defaults ) );
 				addIfNotNull( annotationList, getPrimaryKeyJoinColumns( tree, defaults, true ) );
 				addIfNotNull( annotationList, getIdClass( tree, defaults ) );
 				addIfNotNull( annotationList, getCacheable( tree, defaults ) );
 				addIfNotNull( annotationList, getInheritance( tree, defaults ) );
 				addIfNotNull( annotationList, getDiscriminatorValue( tree, defaults ) );
 				addIfNotNull( annotationList, getDiscriminatorColumn( tree, defaults ) );
 				addIfNotNull( annotationList, getSequenceGenerator( tree, defaults ) );
 				addIfNotNull( annotationList, getTableGenerator( tree, defaults ) );
 				addIfNotNull( annotationList, getNamedQueries( tree, defaults ) );
 				addIfNotNull( annotationList, getNamedNativeQueries( tree, defaults ) );
 				addIfNotNull( annotationList, getNamedStoredProcedureQueries( tree, defaults ) );
 				addIfNotNull( annotationList, getNamedEntityGraphs( tree, defaults ) );
 				addIfNotNull( annotationList, getSqlResultSetMappings( tree, defaults ) );
 				addIfNotNull( annotationList, getExcludeDefaultListeners( tree, defaults ) );
 				addIfNotNull( annotationList, getExcludeSuperclassListeners( tree, defaults ) );
 				addIfNotNull( annotationList, getAccessType( tree, defaults ) );
 				addIfNotNull( annotationList, getAttributeOverrides( tree, defaults, true ) );
 				addIfNotNull( annotationList, getAssociationOverrides( tree, defaults, true ) );
 				addIfNotNull( annotationList, getEntityListeners( tree, defaults ) );
 				addIfNotNull( annotationList, getConverts( tree, defaults ) );
 
 				this.annotations = annotationList.toArray( new Annotation[annotationList.size()] );
 				for ( Annotation ann : this.annotations ) {
 					annotationsMap.put( ann.annotationType(), ann );
 				}
 				checkForOrphanProperties( tree );
 			}
 			else if ( className != null ) { //&& propertyName != null ) { //always true but less confusing
 				Element tree = xmlContext.getXMLTree( className );
 				Annotation[] annotations = getPhysicalAnnotations();
 				List<Annotation> annotationList = new ArrayList<Annotation>( annotations.length + 5 );
 				annotationsMap = new HashMap<Class, Annotation>( annotations.length + 5 );
 				for ( Annotation annotation : annotations ) {
 					if ( !annotationToXml.containsKey( annotation.annotationType() ) ) {
 						//unknown annotations are left over
 						annotationList.add( annotation );
 					}
 				}
 				preCalculateElementsForProperty( tree );
 				Transient transientAnn = getTransient( defaults );
 				if ( transientAnn != null ) {
 					annotationList.add( transientAnn );
 				}
 				else {
 					if ( defaults.canUseJavaAnnotations() ) {
 						Annotation annotation = getPhysicalAnnotation( Access.class );
 						addIfNotNull( annotationList, annotation );
 					}
 					getId( annotationList, defaults );
 					getEmbeddedId( annotationList, defaults );
 					getEmbedded( annotationList, defaults );
 					getBasic( annotationList, defaults );
 					getVersion( annotationList, defaults );
 					getAssociation( ManyToOne.class, annotationList, defaults );
 					getAssociation( OneToOne.class, annotationList, defaults );
 					getAssociation( OneToMany.class, annotationList, defaults );
 					getAssociation( ManyToMany.class, annotationList, defaults );
 					getAssociation( Any.class, annotationList, defaults );
 					getAssociation( ManyToAny.class, annotationList, defaults );
 					getElementCollection( annotationList, defaults );
 					addIfNotNull( annotationList, getSequenceGenerator( elementsForProperty, defaults ) );
 					addIfNotNull( annotationList, getTableGenerator( elementsForProperty, defaults ) );
 					addIfNotNull( annotationList, getConvertsForAttribute( elementsForProperty, defaults ) );
 				}
 				processEventAnnotations( annotationList, defaults );
 				//FIXME use annotationsMap rather than annotationList this will be faster since the annotation type is usually known at put() time
 				this.annotations = annotationList.toArray( new Annotation[annotationList.size()] );
 				for ( Annotation ann : this.annotations ) {
 					annotationsMap.put( ann.annotationType(), ann );
 				}
 			}
 			else {
 				this.annotations = getPhysicalAnnotations();
 				annotationsMap = new HashMap<Class, Annotation>( annotations.length + 5 );
 				for ( Annotation ann : this.annotations ) {
 					annotationsMap.put( ann.annotationType(), ann );
 				}
 			}
 		}
 	}
 
 	private Annotation getConvertsForAttribute(List<Element> elementsForProperty, XMLContext.Default defaults) {
 		// NOTE : we use a map here to make sure that an xml and annotation referring to the same attribute
 		// properly overrides.  Very sparse map, yes, but easy setup.
 		// todo : revisit this
 		// although bear in mind that this code is no longer used in 5.0...
 
 		final Map<String,Convert> convertAnnotationsMap = new HashMap<String, Convert>();
 
 		for ( Element element : elementsForProperty ) {
 			final boolean isBasic = "basic".equals( element.getName() );
 			final boolean isEmbedded = "embedded".equals( element.getName() );
 
 			// todo : can be collections too
 
 			final boolean canHaveConverts = isBasic || isEmbedded;
 
 			if ( !canHaveConverts ) {
 				continue;
 			}
 
 			final String attributeNamePrefix = isBasic ? null : propertyName;
 			applyXmlDefinedConverts( element, defaults, attributeNamePrefix, convertAnnotationsMap );
 		}
 
 		// NOTE : per section 12.2.3.16 of the spec <convert/> is additive, although only if "metadata-complete" is not
 		// specified in the XML
 
 		if ( defaults.canUseJavaAnnotations() ) {
 			// todo : note sure how to best handle attributeNamePrefix here
 			applyPhysicalConvertAnnotations( propertyName, convertAnnotationsMap );
 		}
 
 		if ( !convertAnnotationsMap.isEmpty() ) {
 			final AnnotationDescriptor groupingDescriptor = new AnnotationDescriptor( Converts.class );
 			groupingDescriptor.setValue( "value", convertAnnotationsMap.values().toArray( new Convert[convertAnnotationsMap.size()]) );
 			return AnnotationFactory.create( groupingDescriptor );
 		}
 
 		return null;
 	}
 
 	private Converts getConverts(Element tree, XMLContext.Default defaults) {
 		// NOTE : we use a map here to make sure that an xml and annotation referring to the same attribute
 		// properly overrides.  Bit sparse, but easy...
 		final Map<String,Convert> convertAnnotationsMap = new HashMap<String, Convert>();
 
 		if ( tree != null ) {
 			applyXmlDefinedConverts( tree, defaults, null, convertAnnotationsMap );
 		}
 
 		// NOTE : per section 12.2.3.16 of the spec <convert/> is additive, although only if "metadata-complete" is not
 		// specified in the XML
 
 		if ( defaults.canUseJavaAnnotations() ) {
 			applyPhysicalConvertAnnotations( null, convertAnnotationsMap );
 		}
 
 		if ( !convertAnnotationsMap.isEmpty() ) {
 			final AnnotationDescriptor groupingDescriptor = new AnnotationDescriptor( Converts.class );
 			groupingDescriptor.setValue( "value", convertAnnotationsMap.values().toArray( new Convert[convertAnnotationsMap.size()]) );
 			return AnnotationFactory.create( groupingDescriptor );
 		}
 
 		return null;
 	}
 
 	private void applyXmlDefinedConverts(
 			Element containingElement,
 			XMLContext.Default defaults,
 			String attributeNamePrefix,
 			Map<String,Convert> convertAnnotationsMap) {
 		final List<Element> convertElements = containingElement.elements( "convert" );
 		for ( Element convertElement : convertElements ) {
 			final AnnotationDescriptor convertAnnotationDescriptor = new AnnotationDescriptor( Convert.class );
 			copyStringAttribute( convertAnnotationDescriptor, convertElement, "attribute-name", false );
 			copyBooleanAttribute( convertAnnotationDescriptor, convertElement, "disable-conversion" );
 
 			final Attribute converterClassAttr = convertElement.attribute( "converter" );
 			if ( converterClassAttr != null ) {
 				final String converterClassName = XMLContext.buildSafeClassName(
 						converterClassAttr.getValue(),
 						defaults
 				);
 				try {
-					final Class converterClass = ReflectHelper.classForName( converterClassName, this.getClass() );
+					final Class converterClass = classLoaderAccess.classForName( converterClassName );
 					convertAnnotationDescriptor.setValue( "converter", converterClass );
 				}
-				catch (ClassNotFoundException e) {
+				catch (ClassLoadingException e) {
 					throw new AnnotationException( "Unable to find specified converter class id-class: " + converterClassName, e );
 				}
 			}
 			final Convert convertAnnotation = AnnotationFactory.create( convertAnnotationDescriptor );
 			final String qualifiedAttributeName = qualifyConverterAttributeName(
 					attributeNamePrefix,
 					convertAnnotation.attributeName()
 			);
 			convertAnnotationsMap.put( qualifiedAttributeName, convertAnnotation );
 		}
 
 	}
 
 	private String qualifyConverterAttributeName(String attributeNamePrefix, String specifiedAttributeName) {
 		String qualifiedAttributeName;
 		if ( StringHelper.isNotEmpty( specifiedAttributeName ) ) {
 			if ( StringHelper.isNotEmpty( attributeNamePrefix ) ) {
 				qualifiedAttributeName = attributeNamePrefix + '.' + specifiedAttributeName;
 			}
 			else {
 				qualifiedAttributeName = specifiedAttributeName;
 			}
 		}
 		else {
 			qualifiedAttributeName = "";
 		}
 		return qualifiedAttributeName;
 	}
 
 	private void applyPhysicalConvertAnnotations(
 			String attributeNamePrefix,
 			Map<String, Convert> convertAnnotationsMap) {
 		final Convert physicalAnnotation = getPhysicalAnnotation( Convert.class );
 		if ( physicalAnnotation != null ) {
 			// only add if no XML element named a converter for this attribute
 			final String qualifiedAttributeName = qualifyConverterAttributeName( attributeNamePrefix, physicalAnnotation.attributeName() );
 			if ( ! convertAnnotationsMap.containsKey( qualifiedAttributeName ) ) {
 				convertAnnotationsMap.put( qualifiedAttributeName, physicalAnnotation );
 			}
 		}
 		final Converts physicalGroupingAnnotation = getPhysicalAnnotation( Converts.class );
 		if ( physicalGroupingAnnotation != null ) {
 			for ( Convert convertAnnotation : physicalGroupingAnnotation.value() ) {
 				// again, only add if no XML element named a converter for this attribute
 				final String qualifiedAttributeName = qualifyConverterAttributeName( attributeNamePrefix, convertAnnotation.attributeName() );
 				if ( ! convertAnnotationsMap.containsKey( qualifiedAttributeName ) ) {
 					convertAnnotationsMap.put( qualifiedAttributeName, convertAnnotation );
 				}
 			}
 		}
 	}
 
 	private void checkForOrphanProperties(Element tree) {
 		Class clazz;
 		try {
-			clazz = ReflectHelper.classForName( className, this.getClass() );
+			clazz = classLoaderAccess.classForName( className );
 		}
-		catch ( ClassNotFoundException e ) {
+		catch ( ClassLoadingException e ) {
 			return; //a primitive type most likely
 		}
 		Element element = tree != null ? tree.element( "attributes" ) : null;
 		//put entity.attributes elements
 		if ( element != null ) {
 			//precompute the list of properties
 			//TODO is it really useful...
 			Set<String> properties = new HashSet<String>();
 			for ( Field field : clazz.getFields() ) {
 				properties.add( field.getName() );
 			}
 			for ( Method method : clazz.getMethods() ) {
 				String name = method.getName();
 				if ( name.startsWith( "get" ) ) {
 					properties.add( Introspector.decapitalize( name.substring( "get".length() ) ) );
 				}
 				else if ( name.startsWith( "is" ) ) {
 					properties.add( Introspector.decapitalize( name.substring( "is".length() ) ) );
 				}
 			}
 			for ( Element subelement : (List<Element>) element.elements() ) {
 				String propertyName = subelement.attributeValue( "name" );
 				if ( !properties.contains( propertyName ) ) {
 					LOG.propertyNotFound( StringHelper.qualify( className, propertyName ) );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Adds {@code annotation} to the list (only if it's not null) and then returns it.
 	 *
 	 * @param annotationList The list of annotations.
 	 * @param annotation The annotation to add to the list.
 	 *
 	 * @return The annotation which was added to the list or {@code null}.
 	 */
 	private Annotation addIfNotNull(List<Annotation> annotationList, Annotation annotation) {
 		if ( annotation != null ) {
 			annotationList.add( annotation );
 		}
 		return annotation;
 	}
 
 	//TODO mutualize the next 2 methods
 	private Annotation getTableGenerator(List<Element> elementsForProperty, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			Element subelement = element != null ? element.element( annotationToXml.get( TableGenerator.class ) ) : null;
 			if ( subelement != null ) {
 				return buildTableGeneratorAnnotation( subelement, defaults );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( TableGenerator.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private Annotation getSequenceGenerator(List<Element> elementsForProperty, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			Element subelement = element != null ? element.element( annotationToXml.get( SequenceGenerator.class ) ) : null;
 			if ( subelement != null ) {
 				return buildSequenceGeneratorAnnotation( subelement );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( SequenceGenerator.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void processEventAnnotations(List<Annotation> annotationList, XMLContext.Default defaults) {
 		boolean eventElement = false;
 		for ( Element element : elementsForProperty ) {
 			String elementName = element.getName();
 			if ( "pre-persist".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PrePersist.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "pre-remove".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PreRemove.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "pre-update".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PreUpdate.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "post-persist".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PostPersist.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "post-remove".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PostRemove.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "post-update".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PostUpdate.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 			else if ( "post-load".equals( elementName ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( PostLoad.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				eventElement = true;
 			}
 		}
 		if ( !eventElement && defaults.canUseJavaAnnotations() ) {
 			Annotation ann = getPhysicalAnnotation( PrePersist.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PreRemove.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PreUpdate.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PostPersist.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PostRemove.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PostUpdate.class );
 			addIfNotNull( annotationList, ann );
 			ann = getPhysicalAnnotation( PostLoad.class );
 			addIfNotNull( annotationList, ann );
 		}
 	}
 
 	private EntityListeners getEntityListeners(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( "entity-listeners" ) : null;
 		if ( element != null ) {
 			List<Class> entityListenerClasses = new ArrayList<Class>();
 			for ( Element subelement : (List<Element>) element.elements( "entity-listener" ) ) {
 				String className = subelement.attributeValue( "class" );
 				try {
 					entityListenerClasses.add(
-							ReflectHelper.classForName(
-									XMLContext.buildSafeClassName( className, defaults ),
-									this.getClass()
+							classLoaderAccess.classForName(
+									XMLContext.buildSafeClassName( className, defaults )
 							)
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new AnnotationException(
 							"Unable to find " + element.getPath() + ".class: " + className, e
 					);
 				}
 			}
 			AnnotationDescriptor ad = new AnnotationDescriptor( EntityListeners.class );
 			ad.setValue( "value", entityListenerClasses.toArray( new Class[entityListenerClasses.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( EntityListeners.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private JoinTable overridesDefaultsInJoinTable(Annotation annotation, XMLContext.Default defaults) {
 		//no element but might have some default or some annotation
 		boolean defaultToJoinTable = !( isPhysicalAnnotationPresent( JoinColumn.class )
 				|| isPhysicalAnnotationPresent( JoinColumns.class ) );
 		final Class<? extends Annotation> annotationClass = annotation.annotationType();
 		defaultToJoinTable = defaultToJoinTable &&
 				( ( annotationClass == ManyToMany.class && StringHelper.isEmpty( ( (ManyToMany) annotation ).mappedBy() ) )
 						|| ( annotationClass == OneToMany.class && StringHelper.isEmpty( ( (OneToMany) annotation ).mappedBy() ) )
 						|| ( annotationClass == ElementCollection.class )
 				);
 		final Class<JoinTable> annotationType = JoinTable.class;
 		if ( defaultToJoinTable
 				&& ( StringHelper.isNotEmpty( defaults.getCatalog() )
 				|| StringHelper.isNotEmpty( defaults.getSchema() ) ) ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( annotationType );
 			if ( defaults.canUseJavaAnnotations() ) {
 				JoinTable table = getPhysicalAnnotation( annotationType );
 				if ( table != null ) {
 					ad.setValue( "name", table.name() );
 					ad.setValue( "schema", table.schema() );
 					ad.setValue( "catalog", table.catalog() );
 					ad.setValue( "uniqueConstraints", table.uniqueConstraints() );
 					ad.setValue( "joinColumns", table.joinColumns() );
 					ad.setValue( "inverseJoinColumns", table.inverseJoinColumns() );
 				}
 			}
 			if ( StringHelper.isEmpty( (String) ad.valueOf( "schema" ) )
 					&& StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 				ad.setValue( "schema", defaults.getSchema() );
 			}
 			if ( StringHelper.isEmpty( (String) ad.valueOf( "catalog" ) )
 					&& StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 				ad.setValue( "catalog", defaults.getCatalog() );
 			}
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( annotationType );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void getJoinTable(List<Annotation> annotationList, Element tree, XMLContext.Default defaults) {
 		addIfNotNull( annotationList, buildJoinTable( tree, defaults ) );
 	}
 
 	/*
 	 * no partial overriding possible
 	 */
 	private JoinTable buildJoinTable(Element tree, XMLContext.Default defaults) {
 		Element subelement = tree == null ? null : tree.element( "join-table" );
 		final Class<JoinTable> annotationType = JoinTable.class;
 		if ( subelement == null ) {
 			return null;
 		}
 		//ignore java annotation, an element is defined
 		AnnotationDescriptor annotation = new AnnotationDescriptor( annotationType );
 		copyStringAttribute( annotation, subelement, "name", false );
 		copyStringAttribute( annotation, subelement, "catalog", false );
 		if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 				&& StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) ) ) {
 			annotation.setValue( "catalog", defaults.getCatalog() );
 		}
 		copyStringAttribute( annotation, subelement, "schema", false );
 		if ( StringHelper.isNotEmpty( defaults.getSchema() )
 				&& StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) ) ) {
 			annotation.setValue( "schema", defaults.getSchema() );
 		}
 		buildUniqueConstraints( annotation, subelement );
 		buildIndex( annotation, subelement );
 		annotation.setValue( "joinColumns", getJoinColumns( subelement, false ) );
 		annotation.setValue( "inverseJoinColumns", getJoinColumns( subelement, true ) );
 		return AnnotationFactory.create( annotation );
 	}
 
 	/**
 	 * As per section 12.2 of the JPA 2.0 specification, the association
 	 * subelements (many-to-one, one-to-many, one-to-one, many-to-many,
 	 * element-collection) completely override the mapping for the specified
 	 * field or property.  Thus, any methods which might in some contexts merge
 	 * with annotations must not do so in this context.
 	 *
 	 * @see #getElementCollection(List, org.hibernate.cfg.annotations.reflection.XMLContext.Default)
 	 */
 	private void getAssociation(
 			Class<? extends Annotation> annotationType, List<Annotation> annotationList, XMLContext.Default defaults
 	) {
 		String xmlName = annotationToXml.get( annotationType );
 		for ( Element element : elementsForProperty ) {
 			if ( xmlName.equals( element.getName() ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( annotationType );
 				addTargetClass( element, ad, "target-entity", defaults );
 				getFetchType( ad, element );
 				getCascades( ad, element, defaults );
 				getJoinTable( annotationList, element, defaults );
 				buildJoinColumns( annotationList, element );
 				Annotation annotation = getPrimaryKeyJoinColumns( element, defaults, false );
 				addIfNotNull( annotationList, annotation );
 				copyBooleanAttribute( ad, element, "optional" );
 				copyBooleanAttribute( ad, element, "orphan-removal" );
 				copyStringAttribute( ad, element, "mapped-by", false );
 				getOrderBy( annotationList, element );
 				getMapKey( annotationList, element );
 				getMapKeyClass( annotationList, element, defaults );
 				getMapKeyColumn( annotationList, element );
 				getOrderColumn( annotationList, element );
 				getMapKeyTemporal( annotationList, element );
 				getMapKeyEnumerated( annotationList, element );
 				annotation = getMapKeyAttributeOverrides( element, defaults );
 				addIfNotNull( annotationList, annotation );
 				buildMapKeyJoinColumns( annotationList, element );
 				getAssociationId( annotationList, element );
 				getMapsId( annotationList, element );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				getAccessType( annotationList, element );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			Annotation annotation = getPhysicalAnnotation( annotationType );
 			if ( annotation != null ) {
 				annotationList.add( annotation );
 				annotation = overridesDefaultsInJoinTable( annotation, defaults );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( JoinColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( JoinColumns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( PrimaryKeyJoinColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( PrimaryKeyJoinColumns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKey.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( OrderBy.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Lob.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Enumerated.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Temporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Column.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Columns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyClass.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyTemporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyEnumerated.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyJoinColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyJoinColumns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( OrderColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Cascade.class );
 				addIfNotNull( annotationList, annotation );
 			}
 			else if ( isPhysicalAnnotationPresent( ElementCollection.class ) ) { //JPA2
 				annotation = overridesDefaultsInJoinTable( getPhysicalAnnotation( ElementCollection.class ), defaults );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKey.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( OrderBy.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Lob.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Enumerated.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Temporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Column.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( OrderColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyClass.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyTemporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyEnumerated.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyJoinColumn.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( MapKeyJoinColumns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( CollectionTable.class );
 				addIfNotNull( annotationList, annotation );
 			}
 		}
 	}
 
 	private void buildMapKeyJoinColumns(List<Annotation> annotationList, Element element) {
 		MapKeyJoinColumn[] joinColumns = getMapKeyJoinColumns( element );
 		if ( joinColumns.length > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKeyJoinColumns.class );
 			ad.setValue( "value", joinColumns );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private MapKeyJoinColumn[] getMapKeyJoinColumns(Element element) {
 		List<Element> subelements = element != null ? element.elements( "map-key-join-column" ) : null;
 		List<MapKeyJoinColumn> joinColumns = new ArrayList<MapKeyJoinColumn>();
 		if ( subelements != null ) {
 			for ( Element subelement : subelements ) {
 				AnnotationDescriptor column = new AnnotationDescriptor( MapKeyJoinColumn.class );
 				copyStringAttribute( column, subelement, "name", false );
 				copyStringAttribute( column, subelement, "referenced-column-name", false );
 				copyBooleanAttribute( column, subelement, "unique" );
 				copyBooleanAttribute( column, subelement, "nullable" );
 				copyBooleanAttribute( column, subelement, "insertable" );
 				copyBooleanAttribute( column, subelement, "updatable" );
 				copyStringAttribute( column, subelement, "column-definition", false );
 				copyStringAttribute( column, subelement, "table", false );
 				joinColumns.add( (MapKeyJoinColumn) AnnotationFactory.create( column ) );
 			}
 		}
 		return joinColumns.toArray( new MapKeyJoinColumn[joinColumns.size()] );
 	}
 
 	private AttributeOverrides getMapKeyAttributeOverrides(Element tree, XMLContext.Default defaults) {
 		List<AttributeOverride> attributes = buildAttributeOverrides( tree, "map-key-attribute-override" );
 		return mergeAttributeOverrides( defaults, attributes, false );
 	}
 
 	private Cacheable getCacheable(Element element, XMLContext.Default defaults){
 		if ( element != null ) {
 			String attValue = element.attributeValue( "cacheable" );
 			if ( attValue != null ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( Cacheable.class );
 				ad.setValue( "value", Boolean.valueOf( attValue ) );
 				return AnnotationFactory.create( ad );
 			}
 		}
 		if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( Cacheable.class );
 		}
 		else {
 			return null;
 		}
 	}
 	/**
 	 * Adds a @MapKeyEnumerated annotation to the specified annotationList if the specified element
 	 * contains a map-key-enumerated sub-element. This should only be the case for
 	 * element-collection, many-to-many, or one-to-many associations.
 	 */
 	private void getMapKeyEnumerated(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "map-key-enumerated" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKeyEnumerated.class );
 			EnumType value = EnumType.valueOf( subelement.getTextTrim() );
 			ad.setValue( "value", value );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	/**
 	 * Adds a @MapKeyTemporal annotation to the specified annotationList if the specified element
 	 * contains a map-key-temporal sub-element. This should only be the case for element-collection,
 	 * many-to-many, or one-to-many associations.
 	 */
 	private void getMapKeyTemporal(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "map-key-temporal" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKeyTemporal.class );
 			TemporalType value = TemporalType.valueOf( subelement.getTextTrim() );
 			ad.setValue( "value", value );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	/**
 	 * Adds an @OrderColumn annotation to the specified annotationList if the specified element
 	 * contains an order-column sub-element. This should only be the case for element-collection,
 	 * many-to-many, or one-to-many associations.
 	 */
 	private void getOrderColumn(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "order-column" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( OrderColumn.class );
 			copyStringAttribute( ad, subelement, "name", false );
 			copyBooleanAttribute( ad, subelement, "nullable" );
 			copyBooleanAttribute( ad, subelement, "insertable" );
 			copyBooleanAttribute( ad, subelement, "updatable" );
 			copyStringAttribute( ad, subelement, "column-definition", false );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	/**
 	 * Adds a @MapsId annotation to the specified annotationList if the specified element has the
 	 * maps-id attribute set. This should only be the case for many-to-one or one-to-one
 	 * associations.
 	 */
 	private void getMapsId(List<Annotation> annotationList, Element element) {
 		String attrVal = element.attributeValue( "maps-id" );
 		if ( attrVal != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapsId.class );
 			ad.setValue( "value", attrVal );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	/**
 	 * Adds an @Id annotation to the specified annotationList if the specified element has the id
 	 * attribute set to true. This should only be the case for many-to-one or one-to-one
 	 * associations.
 	 */
 	private void getAssociationId(List<Annotation> annotationList, Element element) {
 		String attrVal = element.attributeValue( "id" );
 		if ( "true".equals( attrVal ) ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Id.class );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void addTargetClass(Element element, AnnotationDescriptor ad, String nodeName, XMLContext.Default defaults) {
 		String className = element.attributeValue( nodeName );
 		if ( className != null ) {
 			Class clazz;
 			try {
-				clazz = ReflectHelper.classForName(
-						XMLContext.buildSafeClassName( className, defaults ), this.getClass()
-				);
+				clazz = classLoaderAccess.classForName( XMLContext.buildSafeClassName( className, defaults ) );
 			}
-			catch ( ClassNotFoundException e ) {
+			catch ( ClassLoadingException e ) {
 				throw new AnnotationException(
 						"Unable to find " + element.getPath() + " " + nodeName + ": " + className, e
 				);
 			}
 			ad.setValue( getJavaAttributeNameFromXMLOne( nodeName ), clazz );
 		}
 	}
 
 	/**
 	 * As per sections 12.2.3.23.9, 12.2.4.8.9 and 12.2.5.3.6 of the JPA 2.0
 	 * specification, the element-collection subelement completely overrides the
 	 * mapping for the specified field or property.  Thus, any methods which
 	 * might in some contexts merge with annotations must not do so in this
 	 * context.
 	 */
 	private void getElementCollection(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "element-collection".equals( element.getName() ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( ElementCollection.class );
 				addTargetClass( element, ad, "target-class", defaults );
 				getFetchType( ad, element );
 				getOrderBy( annotationList, element );
 				getOrderColumn( annotationList, element );
 				getMapKey( annotationList, element );
 				getMapKeyClass( annotationList, element, defaults );
 				getMapKeyTemporal( annotationList, element );
 				getMapKeyEnumerated( annotationList, element );
 				getMapKeyColumn( annotationList, element );
 				buildMapKeyJoinColumns( annotationList, element );
 				Annotation annotation = getColumn( element.element( "column" ), false, element );
 				addIfNotNull( annotationList, annotation );
 				getTemporal( annotationList, element );
 				getEnumerated( annotationList, element );
 				getLob( annotationList, element );
 				//Both map-key-attribute-overrides and attribute-overrides
 				//translate into AttributeOverride annotations, which need
 				//need to be wrapped in the same AttributeOverrides annotation.
 				List<AttributeOverride> attributes = new ArrayList<AttributeOverride>();
 				attributes.addAll( buildAttributeOverrides( element, "map-key-attribute-override" ) );
 				attributes.addAll( buildAttributeOverrides( element, "attribute-override" ) );
 				annotation = mergeAttributeOverrides( defaults, attributes, false );
 				addIfNotNull( annotationList, annotation );
 				annotation = getAssociationOverrides( element, defaults, false );
 				addIfNotNull( annotationList, annotation );
 				getCollectionTable( annotationList, element, defaults );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				getAccessType( annotationList, element );
 			}
 		}
 	}
 
 	private void getOrderBy(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "order-by" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( OrderBy.class );
 			copyStringElement( subelement, ad, "value" );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getMapKey(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "map-key" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKey.class );
 			copyStringAttribute( ad, subelement, "name", false );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getMapKeyColumn(List<Annotation> annotationList, Element element) {
 		Element subelement = element != null ? element.element( "map-key-column" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKeyColumn.class );
 			copyStringAttribute( ad, subelement, "name", false );
 			copyBooleanAttribute( ad, subelement, "unique" );
 			copyBooleanAttribute( ad, subelement, "nullable" );
 			copyBooleanAttribute( ad, subelement, "insertable" );
 			copyBooleanAttribute( ad, subelement, "updatable" );
 			copyStringAttribute( ad, subelement, "column-definition", false );
 			copyStringAttribute( ad, subelement, "table", false );
 			copyIntegerAttribute( ad, subelement, "length" );
 			copyIntegerAttribute( ad, subelement, "precision" );
 			copyIntegerAttribute( ad, subelement, "scale" );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getMapKeyClass(List<Annotation> annotationList, Element element, XMLContext.Default defaults) {
 		String nodeName = "map-key-class";
 		Element subelement = element != null ? element.element( nodeName ) : null;
 		if ( subelement != null ) {
 			String mapKeyClassName = subelement.attributeValue( "class" );
 			AnnotationDescriptor ad = new AnnotationDescriptor( MapKeyClass.class );
 			if ( StringHelper.isNotEmpty( mapKeyClassName ) ) {
 				Class clazz;
 				try {
-					clazz = ReflectHelper.classForName(
-							XMLContext.buildSafeClassName( mapKeyClassName, defaults ),
-							this.getClass()
+					clazz = classLoaderAccess.classForName(
+							XMLContext.buildSafeClassName( mapKeyClassName, defaults )
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new AnnotationException(
 							"Unable to find " + element.getPath() + " " + nodeName + ": " + mapKeyClassName, e
 					);
 				}
 				ad.setValue( "value", clazz );
 			}
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getCollectionTable(List<Annotation> annotationList, Element element, XMLContext.Default defaults) {
 		Element subelement = element != null ? element.element( "collection-table" ) : null;
 		if ( subelement != null ) {
 			AnnotationDescriptor annotation = new AnnotationDescriptor( CollectionTable.class );
 			copyStringAttribute( annotation, subelement, "name", false );
 			copyStringAttribute( annotation, subelement, "catalog", false );
 			if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) ) ) {
 				annotation.setValue( "catalog", defaults.getCatalog() );
 			}
 			copyStringAttribute( annotation, subelement, "schema", false );
 			if ( StringHelper.isNotEmpty( defaults.getSchema() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) ) ) {
 				annotation.setValue( "schema", defaults.getSchema() );
 			}
 			JoinColumn[] joinColumns = getJoinColumns( subelement, false );
 			if ( joinColumns.length > 0 ) {
 				annotation.setValue( "joinColumns", joinColumns );
 			}
 			buildUniqueConstraints( annotation, subelement );
 			buildIndex( annotation, subelement );
 			annotationList.add( AnnotationFactory.create( annotation ) );
 		}
 	}
 
 	private void buildJoinColumns(List<Annotation> annotationList, Element element) {
 		JoinColumn[] joinColumns = getJoinColumns( element, false );
 		if ( joinColumns.length > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( JoinColumns.class );
 			ad.setValue( "value", joinColumns );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getCascades(AnnotationDescriptor ad, Element element, XMLContext.Default defaults) {
 		List<Element> elements = element != null ? element.elements( "cascade" ) : new ArrayList<Element>( 0 );
 		List<CascadeType> cascades = new ArrayList<CascadeType>();
 		for ( Element subelement : elements ) {
 			if ( subelement.element( "cascade-all" ) != null ) {
 				cascades.add( CascadeType.ALL );
 			}
 			if ( subelement.element( "cascade-persist" ) != null ) {
 				cascades.add( CascadeType.PERSIST );
 			}
 			if ( subelement.element( "cascade-merge" ) != null ) {
 				cascades.add( CascadeType.MERGE );
 			}
 			if ( subelement.element( "cascade-remove" ) != null ) {
 				cascades.add( CascadeType.REMOVE );
 			}
 			if ( subelement.element( "cascade-refresh" ) != null ) {
 				cascades.add( CascadeType.REFRESH );
 			}
 			if ( subelement.element( "cascade-detach" ) != null ) {
 				cascades.add( CascadeType.DETACH );
 			}
 		}
 		if ( Boolean.TRUE.equals( defaults.getCascadePersist() )
 				&& !cascades.contains( CascadeType.ALL ) && !cascades.contains( CascadeType.PERSIST ) ) {
 			cascades.add( CascadeType.PERSIST );
 		}
 		if ( cascades.size() > 0 ) {
 			ad.setValue( "cascade", cascades.toArray( new CascadeType[cascades.size()] ) );
 		}
 	}
 
 	private void getEmbedded(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "embedded".equals( element.getName() ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( Embedded.class );
 				annotationList.add( AnnotationFactory.create( ad ) );
 				Annotation annotation = getAttributeOverrides( element, defaults, false );
 				addIfNotNull( annotationList, annotation );
 				annotation = getAssociationOverrides( element, defaults, false );
 				addIfNotNull( annotationList, annotation );
 				getAccessType( annotationList, element );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			Annotation annotation = getPhysicalAnnotation( Embedded.class );
 			if ( annotation != null ) {
 				annotationList.add( annotation );
 				annotation = getPhysicalAnnotation( AttributeOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverrides.class );
 				addIfNotNull( annotationList, annotation );
 			}
 		}
 	}
 
 	private Transient getTransient(XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "transient".equals( element.getName() ) ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( Transient.class );
 				return AnnotationFactory.create( ad );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( Transient.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void getVersion(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "version".equals( element.getName() ) ) {
 				Annotation annotation = buildColumns( element );
 				addIfNotNull( annotationList, annotation );
 				getTemporal( annotationList, element );
 				AnnotationDescriptor basic = new AnnotationDescriptor( Version.class );
 				annotationList.add( AnnotationFactory.create( basic ) );
 				getAccessType( annotationList, element );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			//we have nothing, so Java annotations might occurs
 			Annotation annotation = getPhysicalAnnotation( Version.class );
 			if ( annotation != null ) {
 				annotationList.add( annotation );
 				annotation = getPhysicalAnnotation( Column.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Columns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Temporal.class );
 				addIfNotNull( annotationList, annotation );
 			}
 		}
 	}
 
 	private void getBasic(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "basic".equals( element.getName() ) ) {
 				Annotation annotation = buildColumns( element );
 				addIfNotNull( annotationList, annotation );
 				getAccessType( annotationList, element );
 				getTemporal( annotationList, element );
 				getLob( annotationList, element );
 				getEnumerated( annotationList, element );
 				AnnotationDescriptor basic = new AnnotationDescriptor( Basic.class );
 				getFetchType( basic, element );
 				copyBooleanAttribute( basic, element, "optional" );
 				annotationList.add( AnnotationFactory.create( basic ) );
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			//no annotation presence constraint, basic is the default
 			Annotation annotation = getPhysicalAnnotation( Basic.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( Lob.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( Enumerated.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( Temporal.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( Column.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( Columns.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( AttributeOverride.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( AttributeOverrides.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( AssociationOverride.class );
 			addIfNotNull( annotationList, annotation );
 			annotation = getPhysicalAnnotation( AssociationOverrides.class );
 			addIfNotNull( annotationList, annotation );
 		}
 	}
 
 	private void getEnumerated(List<Annotation> annotationList, Element element) {
 		Element subElement = element != null ? element.element( "enumerated" ) : null;
 		if ( subElement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Enumerated.class );
 			String enumerated = subElement.getTextTrim();
 			if ( "ORDINAL".equalsIgnoreCase( enumerated ) ) {
 				ad.setValue( "value", EnumType.ORDINAL );
 			}
 			else if ( "STRING".equalsIgnoreCase( enumerated ) ) {
 				ad.setValue( "value", EnumType.STRING );
 			}
 			else if ( StringHelper.isNotEmpty( enumerated ) ) {
 				throw new AnnotationException( "Unknown EnumType: " + enumerated + ". " + SCHEMA_VALIDATION );
 			}
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getLob(List<Annotation> annotationList, Element element) {
 		Element subElement = element != null ? element.element( "lob" ) : null;
 		if ( subElement != null ) {
 			annotationList.add( AnnotationFactory.create( new AnnotationDescriptor( Lob.class ) ) );
 		}
 	}
 
 	private void getFetchType(AnnotationDescriptor descriptor, Element element) {
 		String fetchString = element != null ? element.attributeValue( "fetch" ) : null;
 		if ( fetchString != null ) {
 			if ( "eager".equalsIgnoreCase( fetchString ) ) {
 				descriptor.setValue( "fetch", FetchType.EAGER );
 			}
 			else if ( "lazy".equalsIgnoreCase( fetchString ) ) {
 				descriptor.setValue( "fetch", FetchType.LAZY );
 			}
 		}
 	}
 
 	private void getEmbeddedId(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "embedded-id".equals( element.getName() ) ) {
 				if ( isProcessingId( defaults ) ) {
 					Annotation annotation = getAttributeOverrides( element, defaults, false );
 					addIfNotNull( annotationList, annotation );
 					annotation = getAssociationOverrides( element, defaults, false );
 					addIfNotNull( annotationList, annotation );
 					AnnotationDescriptor ad = new AnnotationDescriptor( EmbeddedId.class );
 					annotationList.add( AnnotationFactory.create( ad ) );
 					getAccessType( annotationList, element );
 				}
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			Annotation annotation = getPhysicalAnnotation( EmbeddedId.class );
 			if ( annotation != null ) {
 				annotationList.add( annotation );
 				annotation = getPhysicalAnnotation( Column.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Columns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( GeneratedValue.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Temporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( TableGenerator.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( SequenceGenerator.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverrides.class );
 				addIfNotNull( annotationList, annotation );
 			}
 		}
 	}
 
 	private void preCalculateElementsForProperty(Element tree) {
 		elementsForProperty = new ArrayList<Element>();
 		Element element = tree != null ? tree.element( "attributes" ) : null;
 		//put entity.attributes elements
 		if ( element != null ) {
 			for ( Element subelement : (List<Element>) element.elements() ) {
 				if ( propertyName.equals( subelement.attributeValue( "name" ) ) ) {
 					elementsForProperty.add( subelement );
 				}
 			}
 		}
 		//add pre-* etc from entity and pure entity listener classes
 		if ( tree != null ) {
 			for ( Element subelement : (List<Element>) tree.elements() ) {
 				if ( propertyName.equals( subelement.attributeValue( "method-name" ) ) ) {
 					elementsForProperty.add( subelement );
 				}
 			}
 		}
 	}
 
 	private void getId(List<Annotation> annotationList, XMLContext.Default defaults) {
 		for ( Element element : elementsForProperty ) {
 			if ( "id".equals( element.getName() ) ) {
 				boolean processId = isProcessingId( defaults );
 				if ( processId ) {
 					Annotation annotation = buildColumns( element );
 					addIfNotNull( annotationList, annotation );
 					annotation = buildGeneratedValue( element );
 					addIfNotNull( annotationList, annotation );
 					getTemporal( annotationList, element );
 					//FIXME: fix the priority of xml over java for generator names
 					annotation = getTableGenerator( element, defaults );
 					addIfNotNull( annotationList, annotation );
 					annotation = getSequenceGenerator( element, defaults );
 					addIfNotNull( annotationList, annotation );
 					AnnotationDescriptor id = new AnnotationDescriptor( Id.class );
 					annotationList.add( AnnotationFactory.create( id ) );
 					getAccessType( annotationList, element );
 				}
 			}
 		}
 		if ( elementsForProperty.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			Annotation annotation = getPhysicalAnnotation( Id.class );
 			if ( annotation != null ) {
 				annotationList.add( annotation );
 				annotation = getPhysicalAnnotation( Column.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Columns.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( GeneratedValue.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( Temporal.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( TableGenerator.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( SequenceGenerator.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AttributeOverrides.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverride.class );
 				addIfNotNull( annotationList, annotation );
 				annotation = getPhysicalAnnotation( AssociationOverrides.class );
 				addIfNotNull( annotationList, annotation );
 			}
 		}
 	}
 
 	private boolean isProcessingId(XMLContext.Default defaults) {
 		boolean isExplicit = defaults.getAccess() != null;
 		boolean correctAccess =
 				( PropertyType.PROPERTY.equals( propertyType ) && AccessType.PROPERTY.equals( defaults.getAccess() ) )
 						|| ( PropertyType.FIELD.equals( propertyType ) && AccessType.FIELD
 						.equals( defaults.getAccess() ) );
 		boolean hasId = defaults.canUseJavaAnnotations()
 				&& ( isPhysicalAnnotationPresent( Id.class ) || isPhysicalAnnotationPresent( EmbeddedId.class ) );
 		//if ( properAccessOnMetadataComplete || properOverridingOnMetadataNonComplete ) {
 		boolean mirrorAttributeIsId = defaults.canUseJavaAnnotations() &&
 				( mirroredAttribute != null &&
 						( mirroredAttribute.isAnnotationPresent( Id.class )
 								|| mirroredAttribute.isAnnotationPresent( EmbeddedId.class ) ) );
 		boolean propertyIsDefault = PropertyType.PROPERTY.equals( propertyType )
 				&& !mirrorAttributeIsId;
 		return correctAccess || ( !isExplicit && hasId ) || ( !isExplicit && propertyIsDefault );
 	}
 
 	private Columns buildColumns(Element element) {
 		List<Element> subelements = element.elements( "column" );
 		List<Column> columns = new ArrayList<Column>( subelements.size() );
 		for ( Element subelement : subelements ) {
 			columns.add( getColumn( subelement, false, element ) );
 		}
 		if ( columns.size() > 0 ) {
 			AnnotationDescriptor columnsDescr = new AnnotationDescriptor( Columns.class );
 			columnsDescr.setValue( "columns", columns.toArray( new Column[columns.size()] ) );
 			return AnnotationFactory.create( columnsDescr );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private GeneratedValue buildGeneratedValue(Element element) {
 		Element subElement = element != null ? element.element( "generated-value" ) : null;
 		if ( subElement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( GeneratedValue.class );
 			String strategy = subElement.attributeValue( "strategy" );
 			if ( "TABLE".equalsIgnoreCase( strategy ) ) {
 				ad.setValue( "strategy", GenerationType.TABLE );
 			}
 			else if ( "SEQUENCE".equalsIgnoreCase( strategy ) ) {
 				ad.setValue( "strategy", GenerationType.SEQUENCE );
 			}
 			else if ( "IDENTITY".equalsIgnoreCase( strategy ) ) {
 				ad.setValue( "strategy", GenerationType.IDENTITY );
 			}
 			else if ( "AUTO".equalsIgnoreCase( strategy ) ) {
 				ad.setValue( "strategy", GenerationType.AUTO );
 			}
 			else if ( StringHelper.isNotEmpty( strategy ) ) {
 				throw new AnnotationException( "Unknown GenerationType: " + strategy + ". " + SCHEMA_VALIDATION );
 			}
 			copyStringAttribute( ad, subElement, "generator", false );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void getTemporal(List<Annotation> annotationList, Element element) {
 		Element subElement = element != null ? element.element( "temporal" ) : null;
 		if ( subElement != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Temporal.class );
 			String temporal = subElement.getTextTrim();
 			if ( "DATE".equalsIgnoreCase( temporal ) ) {
 				ad.setValue( "value", TemporalType.DATE );
 			}
 			else if ( "TIME".equalsIgnoreCase( temporal ) ) {
 				ad.setValue( "value", TemporalType.TIME );
 			}
 			else if ( "TIMESTAMP".equalsIgnoreCase( temporal ) ) {
 				ad.setValue( "value", TemporalType.TIMESTAMP );
 			}
 			else if ( StringHelper.isNotEmpty( temporal ) ) {
 				throw new AnnotationException( "Unknown TemporalType: " + temporal + ". " + SCHEMA_VALIDATION );
 			}
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	private void getAccessType(List<Annotation> annotationList, Element element) {
 		if ( element == null ) {
 			return;
 		}
 		String access = element.attributeValue( "access" );
 		if ( access != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Access.class );
 			AccessType type;
 			try {
 				type = AccessType.valueOf( access );
 			}
 			catch ( IllegalArgumentException e ) {
 				throw new AnnotationException( access + " is not a valid access type. Check you xml confguration." );
 			}
 
 			if ( ( AccessType.PROPERTY.equals( type ) && this.element instanceof Method ) ||
 					( AccessType.FIELD.equals( type ) && this.element instanceof Field ) ) {
 				return;
 			}
 
 			ad.setValue( "value", type );
 			annotationList.add( AnnotationFactory.create( ad ) );
 		}
 	}
 
 	/**
 	 * @param mergeWithAnnotations Whether to use Java annotations for this
 	 * element, if present and not disabled by the XMLContext defaults.
 	 * In some contexts (such as an element-collection mapping) merging
 	 * with annotations is never allowed.
 	 */
 	private AssociationOverrides getAssociationOverrides(Element tree, XMLContext.Default defaults, boolean mergeWithAnnotations) {
 		List<AssociationOverride> attributes = buildAssociationOverrides( tree, defaults );
 		if ( mergeWithAnnotations && defaults.canUseJavaAnnotations() ) {
 			AssociationOverride annotation = getPhysicalAnnotation( AssociationOverride.class );
 			addAssociationOverrideIfNeeded( annotation, attributes );
 			AssociationOverrides annotations = getPhysicalAnnotation( AssociationOverrides.class );
 			if ( annotations != null ) {
 				for ( AssociationOverride current : annotations.value() ) {
 					addAssociationOverrideIfNeeded( current, attributes );
 				}
 			}
 		}
 		if ( attributes.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( AssociationOverrides.class );
 			ad.setValue( "value", attributes.toArray( new AssociationOverride[attributes.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private List<AssociationOverride> buildAssociationOverrides(Element element, XMLContext.Default defaults) {
 		List<Element> subelements = element == null ? null : element.elements( "association-override" );
 		List<AssociationOverride> overrides = new ArrayList<AssociationOverride>();
 		if ( subelements != null && subelements.size() > 0 ) {
 			for ( Element current : subelements ) {
 				AnnotationDescriptor override = new AnnotationDescriptor( AssociationOverride.class );
 				copyStringAttribute( override, current, "name", true );
 				override.setValue( "joinColumns", getJoinColumns( current, false ) );
 				JoinTable joinTable = buildJoinTable( current, defaults );
 				if ( joinTable != null ) {
 					override.setValue( "joinTable", joinTable );
 				}
 				overrides.add( (AssociationOverride) AnnotationFactory.create( override ) );
 			}
 		}
 		return overrides;
 	}
 
 	private JoinColumn[] getJoinColumns(Element element, boolean isInverse) {
 		List<Element> subelements = element != null ?
 				element.elements( isInverse ? "inverse-join-column" : "join-column" ) :
 				null;
 		List<JoinColumn> joinColumns = new ArrayList<JoinColumn>();
 		if ( subelements != null ) {
 			for ( Element subelement : subelements ) {
 				AnnotationDescriptor column = new AnnotationDescriptor( JoinColumn.class );
 				copyStringAttribute( column, subelement, "name", false );
 				copyStringAttribute( column, subelement, "referenced-column-name", false );
 				copyBooleanAttribute( column, subelement, "unique" );
 				copyBooleanAttribute( column, subelement, "nullable" );
 				copyBooleanAttribute( column, subelement, "insertable" );
 				copyBooleanAttribute( column, subelement, "updatable" );
 				copyStringAttribute( column, subelement, "column-definition", false );
 				copyStringAttribute( column, subelement, "table", false );
 				joinColumns.add( (JoinColumn) AnnotationFactory.create( column ) );
 			}
 		}
 		return joinColumns.toArray( new JoinColumn[joinColumns.size()] );
 	}
 
 	private void addAssociationOverrideIfNeeded(AssociationOverride annotation, List<AssociationOverride> overrides) {
 		if ( annotation != null ) {
 			String overrideName = annotation.name();
 			boolean present = false;
 			for ( AssociationOverride current : overrides ) {
 				if ( current.name().equals( overrideName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				overrides.add( annotation );
 			}
 		}
 	}
 
 	/**
 	 * @param mergeWithAnnotations Whether to use Java annotations for this
 	 * element, if present and not disabled by the XMLContext defaults.
 	 * In some contexts (such as an association mapping) merging with
 	 * annotations is never allowed.
 	 */
 	private AttributeOverrides getAttributeOverrides(Element tree, XMLContext.Default defaults, boolean mergeWithAnnotations) {
 		List<AttributeOverride> attributes = buildAttributeOverrides( tree, "attribute-override" );
 		return mergeAttributeOverrides( defaults, attributes, mergeWithAnnotations );
 	}
 
 	/**
 	 * @param mergeWithAnnotations Whether to use Java annotations for this
 	 * element, if present and not disabled by the XMLContext defaults.
 	 * In some contexts (such as an association mapping) merging with
 	 * annotations is never allowed.
 	 */
 	private AttributeOverrides mergeAttributeOverrides(XMLContext.Default defaults, List<AttributeOverride> attributes, boolean mergeWithAnnotations) {
 		if ( mergeWithAnnotations && defaults.canUseJavaAnnotations() ) {
 			AttributeOverride annotation = getPhysicalAnnotation( AttributeOverride.class );
 			addAttributeOverrideIfNeeded( annotation, attributes );
 			AttributeOverrides annotations = getPhysicalAnnotation( AttributeOverrides.class );
 			if ( annotations != null ) {
 				for ( AttributeOverride current : annotations.value() ) {
 					addAttributeOverrideIfNeeded( current, attributes );
 				}
 			}
 		}
 		if ( attributes.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( AttributeOverrides.class );
 			ad.setValue( "value", attributes.toArray( new AttributeOverride[attributes.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private List<AttributeOverride> buildAttributeOverrides(Element element, String nodeName) {
 		List<Element> subelements = element == null ? null : element.elements( nodeName );
 		return buildAttributeOverrides( subelements, nodeName );
 	}
 
 	private List<AttributeOverride> buildAttributeOverrides(List<Element> subelements, String nodeName) {
 		List<AttributeOverride> overrides = new ArrayList<AttributeOverride>();
 		if ( subelements != null && subelements.size() > 0 ) {
 			for ( Element current : subelements ) {
 				if ( !current.getName().equals( nodeName ) ) {
 					continue;
 				}
 				AnnotationDescriptor override = new AnnotationDescriptor( AttributeOverride.class );
 				copyStringAttribute( override, current, "name", true );
 				Element column = current.element( "column" );
 				override.setValue( "column", getColumn( column, true, current ) );
 				overrides.add( (AttributeOverride) AnnotationFactory.create( override ) );
 			}
 		}
 		return overrides;
 	}
 
 	private Column getColumn(Element element, boolean isMandatory, Element current) {
 		//Element subelement = element != null ? element.element( "column" ) : null;
 		if ( element != null ) {
 			AnnotationDescriptor column = new AnnotationDescriptor( Column.class );
 			copyStringAttribute( column, element, "name", false );
 			copyBooleanAttribute( column, element, "unique" );
 			copyBooleanAttribute( column, element, "nullable" );
 			copyBooleanAttribute( column, element, "insertable" );
 			copyBooleanAttribute( column, element, "updatable" );
 			copyStringAttribute( column, element, "column-definition", false );
 			copyStringAttribute( column, element, "table", false );
 			copyIntegerAttribute( column, element, "length" );
 			copyIntegerAttribute( column, element, "precision" );
 			copyIntegerAttribute( column, element, "scale" );
 			return (Column) AnnotationFactory.create( column );
 		}
 		else {
 			if ( isMandatory ) {
 				throw new AnnotationException( current.getPath() + ".column is mandatory. " + SCHEMA_VALIDATION );
 			}
 			return null;
 		}
 	}
 
 	private void addAttributeOverrideIfNeeded(AttributeOverride annotation, List<AttributeOverride> overrides) {
 		if ( annotation != null ) {
 			String overrideName = annotation.name();
 			boolean present = false;
 			for ( AttributeOverride current : overrides ) {
 				if ( current.name().equals( overrideName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				overrides.add( annotation );
 			}
 		}
 	}
 
 	private Access getAccessType(Element tree, XMLContext.Default defaults) {
 		String access = tree == null ? null : tree.attributeValue( "access" );
 		if ( access != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Access.class );
 			AccessType type;
 			try {
 				type = AccessType.valueOf( access );
 			}
 			catch ( IllegalArgumentException e ) {
 				throw new AnnotationException( access + " is not a valid access type. Check you xml confguration." );
 			}
 			ad.setValue( "value", type );
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() && isPhysicalAnnotationPresent( Access.class ) ) {
 			return getPhysicalAnnotation( Access.class );
 		}
 		else if ( defaults.getAccess() != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Access.class );
 			ad.setValue( "value", defaults.getAccess() );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private ExcludeSuperclassListeners getExcludeSuperclassListeners(Element tree, XMLContext.Default defaults) {
 		return (ExcludeSuperclassListeners) getMarkerAnnotation( ExcludeSuperclassListeners.class, tree, defaults );
 	}
 
 	private ExcludeDefaultListeners getExcludeDefaultListeners(Element tree, XMLContext.Default defaults) {
 		return (ExcludeDefaultListeners) getMarkerAnnotation( ExcludeDefaultListeners.class, tree, defaults );
 	}
 
 	private Annotation getMarkerAnnotation(
 			Class<? extends Annotation> clazz, Element element, XMLContext.Default defaults
 	) {
 		Element subelement = element == null ? null : element.element( annotationToXml.get( clazz ) );
 		if ( subelement != null ) {
 			return AnnotationFactory.create( new AnnotationDescriptor( clazz ) );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			//TODO wonder whether it should be excluded so that user can undone it
 			return getPhysicalAnnotation( clazz );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private SqlResultSetMappings getSqlResultSetMappings(Element tree, XMLContext.Default defaults) {
-		List<SqlResultSetMapping> results = buildSqlResultsetMappings( tree, defaults );
+		List<SqlResultSetMapping> results = buildSqlResultsetMappings( tree, defaults, classLoaderAccess );
 		if ( defaults.canUseJavaAnnotations() ) {
 			SqlResultSetMapping annotation = getPhysicalAnnotation( SqlResultSetMapping.class );
 			addSqlResultsetMappingIfNeeded( annotation, results );
 			SqlResultSetMappings annotations = getPhysicalAnnotation( SqlResultSetMappings.class );
 			if ( annotations != null ) {
 				for ( SqlResultSetMapping current : annotations.value() ) {
 					addSqlResultsetMappingIfNeeded( current, results );
 				}
 			}
 		}
 		if ( results.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( SqlResultSetMappings.class );
 			ad.setValue( "value", results.toArray( new SqlResultSetMapping[results.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
-	public static List<NamedEntityGraph> buildNamedEntityGraph(Element element, XMLContext.Default defaults) {
+	public static List<NamedEntityGraph> buildNamedEntityGraph(
+			Element element,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		if ( element == null ) {
 			return new ArrayList<NamedEntityGraph>();
 		}
 		List<NamedEntityGraph> namedEntityGraphList = new ArrayList<NamedEntityGraph>();
 		List<Element> namedEntityGraphElements = element.elements( "named-entity-graph" );
 		for ( Element subElement : namedEntityGraphElements ) {
 			AnnotationDescriptor ann = new AnnotationDescriptor( NamedEntityGraph.class );
 			copyStringAttribute( ann, subElement, "name", false );
 			copyBooleanAttribute( ann, subElement, "include-all-attributes" );
 			bindNamedAttributeNodes( subElement, ann );
 
 			List<Element> subgraphNodes = subElement.elements( "subgraph" );
-			bindNamedSubgraph( defaults, ann, subgraphNodes );
+			bindNamedSubgraph( defaults, ann, subgraphNodes, classLoaderAccess );
 			List<Element> subclassSubgraphNodes = subElement.elements( "subclass-subgraph" );
-			bindNamedSubgraph( defaults, ann, subclassSubgraphNodes );
+			bindNamedSubgraph( defaults, ann, subclassSubgraphNodes, classLoaderAccess );
 			namedEntityGraphList.add( (NamedEntityGraph) AnnotationFactory.create( ann ) );
 		}
 		//TODO
 		return namedEntityGraphList;
 	}
 
-	private static void bindNamedSubgraph(XMLContext.Default defaults, AnnotationDescriptor ann, List<Element> subgraphNodes) {
+	private static void bindNamedSubgraph(
+			XMLContext.Default defaults,
+			AnnotationDescriptor ann,
+			List<Element> subgraphNodes,
+			ClassLoaderAccess classLoaderAccess) {
 		List<NamedSubgraph> annSubgraphNodes = new ArrayList<NamedSubgraph>(  );
 		for(Element subgraphNode : subgraphNodes){
 			AnnotationDescriptor annSubgraphNode = new AnnotationDescriptor( NamedSubgraph.class );
 			copyStringAttribute( annSubgraphNode, subgraphNode, "name", true );
 			String clazzName = subgraphNode.attributeValue( "class" );
 			Class clazz;
 			try {
-				clazz = ReflectHelper.classForName(
-						XMLContext.buildSafeClassName( clazzName, defaults ),
-						JPAOverriddenAnnotationReader.class
+				clazz = classLoaderAccess.classForName(
+						XMLContext.buildSafeClassName( clazzName, defaults )
 				);
 			}
-			catch ( ClassNotFoundException e ) {
+			catch ( ClassLoadingException e ) {
 				throw new AnnotationException( "Unable to find entity-class: " + clazzName, e );
 			}
 			annSubgraphNode.setValue( "type", clazz );
 			bindNamedAttributeNodes(subgraphNode, annSubgraphNode);
 			annSubgraphNodes.add( (NamedSubgraph) AnnotationFactory.create( annSubgraphNode ) );
 		}
 		ann.setValue( "subgraphs", annSubgraphNodes.toArray( new NamedSubgraph[annSubgraphNodes.size()] ) );
 	}
 
 	private static void bindNamedAttributeNodes(Element subElement, AnnotationDescriptor ann) {
 		List<Element> namedAttributeNodes = subElement.elements("named-attribute-node");
 		List<NamedAttributeNode> annNamedAttributeNodes = new ArrayList<NamedAttributeNode>(  );
 		for(Element namedAttributeNode : namedAttributeNodes){
 			AnnotationDescriptor annNamedAttributeNode = new AnnotationDescriptor( NamedAttributeNode.class );
 			copyStringAttribute( annNamedAttributeNode, namedAttributeNode, "value", "name", true );
 			copyStringAttribute( annNamedAttributeNode, namedAttributeNode, "subgraph", false );
 			copyStringAttribute( annNamedAttributeNode, namedAttributeNode, "key-subgraph", false );
 			annNamedAttributeNodes.add( (NamedAttributeNode) AnnotationFactory.create( annNamedAttributeNode ) );
 		}
 		ann.setValue( "attributeNodes", annNamedAttributeNodes.toArray( new NamedAttributeNode[annNamedAttributeNodes.size()] ) );
 	}
 
-	public static List<NamedStoredProcedureQuery> buildNamedStoreProcedureQueries(Element element, XMLContext.Default defaults) {
+	public static List<NamedStoredProcedureQuery> buildNamedStoreProcedureQueries(
+			Element element,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		if ( element == null ) {
 			return new ArrayList<NamedStoredProcedureQuery>();
 		}
 		List namedStoredProcedureElements = element.elements( "named-stored-procedure-query" );
 		List<NamedStoredProcedureQuery> namedStoredProcedureQueries = new ArrayList<NamedStoredProcedureQuery>();
 		for ( Object obj : namedStoredProcedureElements ) {
 			Element subElement = (Element) obj;
 			AnnotationDescriptor ann = new AnnotationDescriptor( NamedStoredProcedureQuery.class );
 			copyStringAttribute( ann, subElement, "name", true );
 			copyStringAttribute( ann, subElement, "procedure-name", true );
 
 			List<Element> elements = subElement.elements( "parameter" );
 			List<StoredProcedureParameter> storedProcedureParameters = new ArrayList<StoredProcedureParameter>();
 
 			for ( Element parameterElement : elements ) {
 				AnnotationDescriptor parameterDescriptor = new AnnotationDescriptor( StoredProcedureParameter.class );
 				copyStringAttribute( parameterDescriptor, parameterElement, "name", false );
 				String modeValue = parameterElement.attributeValue( "mode" );
 				if ( modeValue == null ) {
 					parameterDescriptor.setValue( "mode", ParameterMode.IN );
 				}
 				else {
 					parameterDescriptor.setValue( "mode", ParameterMode.valueOf( modeValue.toUpperCase(Locale.ROOT) ) );
 				}
 				String clazzName = parameterElement.attributeValue( "class" );
 				Class clazz;
 				try {
-					clazz = ReflectHelper.classForName(
-							XMLContext.buildSafeClassName( clazzName, defaults ),
-							JPAOverriddenAnnotationReader.class
+					clazz = classLoaderAccess.classForName(
+							XMLContext.buildSafeClassName( clazzName, defaults )
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new AnnotationException( "Unable to find entity-class: " + clazzName, e );
 				}
 				parameterDescriptor.setValue( "type", clazz );
 				storedProcedureParameters.add( (StoredProcedureParameter) AnnotationFactory.create( parameterDescriptor ) );
 			}
 
 			ann.setValue(
 					"parameters",
 					storedProcedureParameters.toArray( new StoredProcedureParameter[storedProcedureParameters.size()] )
 			);
 
 			elements = subElement.elements( "result-class" );
 			List<Class> returnClasses = new ArrayList<Class>();
 			for ( Element classElement : elements ) {
 				String clazzName = classElement.getTextTrim();
 				Class clazz;
 				try {
-					clazz = ReflectHelper.classForName(
-							XMLContext.buildSafeClassName( clazzName, defaults ),
-							JPAOverriddenAnnotationReader.class
+					clazz = classLoaderAccess.classForName(
+							XMLContext.buildSafeClassName( clazzName, defaults )
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new AnnotationException( "Unable to find entity-class: " + clazzName, e );
 				}
 				returnClasses.add( clazz );
 			}
 			ann.setValue( "resultClasses", returnClasses.toArray( new Class[returnClasses.size()] ) );
 
 
 			elements = subElement.elements( "result-set-mapping" );
 			List<String> resultSetMappings = new ArrayList<String>();
 			for ( Element resultSetMappingElement : elements ) {
 				resultSetMappings.add( resultSetMappingElement.getTextTrim() );
 			}
 			ann.setValue( "resultSetMappings", resultSetMappings.toArray( new String[resultSetMappings.size()] ) );
 			elements = subElement.elements( "hint" );
 			buildQueryHints( elements, ann );
 			namedStoredProcedureQueries.add( (NamedStoredProcedureQuery) AnnotationFactory.create( ann ) );
 		}
 		return namedStoredProcedureQueries;
 
 	}
 
-	public static List<SqlResultSetMapping> buildSqlResultsetMappings(Element element, XMLContext.Default defaults) {
+	public static List<SqlResultSetMapping> buildSqlResultsetMappings(
+			Element element,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		final List<SqlResultSetMapping> builtResultSetMappings = new ArrayList<SqlResultSetMapping>();
 		if ( element == null ) {
 			return builtResultSetMappings;
 		}
 
 		// iterate over each <sql-result-set-mapping/> element
 		for ( Object resultSetMappingElementObject : element.elements( "sql-result-set-mapping" ) ) {
 			final Element resultSetMappingElement = (Element) resultSetMappingElementObject;
 
 			final AnnotationDescriptor resultSetMappingAnnotation = new AnnotationDescriptor( SqlResultSetMapping.class );
 			copyStringAttribute( resultSetMappingAnnotation, resultSetMappingElement, "name", true );
 
 			// iterate over the <sql-result-set-mapping/> sub-elements, which should include:
 			//		* <entity-result/>
 			//		* <column-result/>
 			//		* <constructor-result/>
 
 			List<EntityResult> entityResultAnnotations = null;
 			List<ColumnResult> columnResultAnnotations = null;
 			List<ConstructorResult> constructorResultAnnotations = null;
 
 			for ( Object resultElementObject : resultSetMappingElement.elements() ) {
 				final Element resultElement = (Element) resultElementObject;
 
 				if ( "entity-result".equals( resultElement.getName() ) ) {
 					if ( entityResultAnnotations == null ) {
 						entityResultAnnotations = new ArrayList<EntityResult>();
 					}
 					// process the <entity-result/>
-					entityResultAnnotations.add( buildEntityResult( resultElement, defaults ) );
+					entityResultAnnotations.add( buildEntityResult( resultElement, defaults, classLoaderAccess ) );
 				}
 				else if ( "column-result".equals( resultElement.getName() ) ) {
 					if ( columnResultAnnotations == null ) {
 						columnResultAnnotations = new ArrayList<ColumnResult>();
 					}
-					columnResultAnnotations.add( buildColumnResult( resultElement, defaults ) );
+					columnResultAnnotations.add( buildColumnResult( resultElement, defaults, classLoaderAccess ) );
 				}
 				else if ( "constructor-result".equals( resultElement.getName() ) ) {
 					if ( constructorResultAnnotations == null ) {
 						constructorResultAnnotations = new ArrayList<ConstructorResult>();
 					}
-					constructorResultAnnotations.add( buildConstructorResult( resultElement, defaults ) );
+					constructorResultAnnotations.add( buildConstructorResult( resultElement, defaults, classLoaderAccess ) );
 				}
 				else {
 					// most likely the <result-class/> this code used to handle.  I have left the code here,
 					// but commented it out for now.  I'll just log a warning for now.
 					LOG.debug( "Encountered unrecognized sql-result-set-mapping sub-element : " + resultElement.getName() );
 
 //					String clazzName = subelement.attributeValue( "result-class" );
 //					if ( StringHelper.isNotEmpty( clazzName ) ) {
 //						Class clazz;
 //						try {
 //							clazz = ReflectHelper.classForName(
 //									XMLContext.buildSafeClassName( clazzName, defaults ),
 //									JPAOverriddenAnnotationReader.class
 //							);
 //						}
 //						catch ( ClassNotFoundException e ) {
 //							throw new AnnotationException( "Unable to find entity-class: " + clazzName, e );
 //						}
 //						ann.setValue( "resultClass", clazz );
 //					}
 				}
 			}
 
 			if ( entityResultAnnotations != null && !entityResultAnnotations.isEmpty() ) {
 				resultSetMappingAnnotation.setValue(
 						"entities",
 						entityResultAnnotations.toArray( new EntityResult[entityResultAnnotations.size()] )
 				);
 			}
 			if ( columnResultAnnotations != null && !columnResultAnnotations.isEmpty() ) {
 				resultSetMappingAnnotation.setValue(
 						"columns",
 						columnResultAnnotations.toArray( new ColumnResult[columnResultAnnotations.size()] )
 				);
 			}
 			if ( constructorResultAnnotations != null && !constructorResultAnnotations.isEmpty() ) {
 				resultSetMappingAnnotation.setValue(
 						"classes",
 						constructorResultAnnotations.toArray( new ConstructorResult[constructorResultAnnotations.size()] )
 				);
 			}
 
 
 			// this was part of the old code too, but could never figure out what it is supposed to do...
 			// copyStringAttribute( ann, subelement, "result-set-mapping", false );
 
 			builtResultSetMappings.add( (SqlResultSetMapping) AnnotationFactory.create( resultSetMappingAnnotation ) );
 		}
 
 		return builtResultSetMappings;
 	}
 
-	private static EntityResult buildEntityResult(Element entityResultElement, XMLContext.Default defaults) {
+	private static EntityResult buildEntityResult(
+			Element entityResultElement,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		final AnnotationDescriptor entityResultDescriptor = new AnnotationDescriptor( EntityResult.class );
 
-		final Class entityClass = resolveClassReference( entityResultElement.attributeValue( "entity-class" ), defaults );
+		final Class entityClass = resolveClassReference( entityResultElement.attributeValue( "entity-class" ), defaults, classLoaderAccess );
 		entityResultDescriptor.setValue( "entityClass", entityClass );
 
 		copyStringAttribute( entityResultDescriptor, entityResultElement, "discriminator-column", false );
 
 		// process the <field-result/> sub-elements
 		List<FieldResult> fieldResultAnnotations = new ArrayList<FieldResult>();
 		for ( Element fieldResult : (List<Element>) entityResultElement.elements( "field-result" ) ) {
 			AnnotationDescriptor fieldResultDescriptor = new AnnotationDescriptor( FieldResult.class );
 			copyStringAttribute( fieldResultDescriptor, fieldResult, "name", true );
 			copyStringAttribute( fieldResultDescriptor, fieldResult, "column", true );
 			fieldResultAnnotations.add( (FieldResult) AnnotationFactory.create( fieldResultDescriptor ) );
 		}
 		entityResultDescriptor.setValue(
 				"fields", fieldResultAnnotations.toArray( new FieldResult[fieldResultAnnotations.size()] )
 		);
 		return AnnotationFactory.create( entityResultDescriptor );
 	}
 
-	private static Class resolveClassReference(String className, XMLContext.Default defaults) {
+	private static Class resolveClassReference(
+			String className,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		if ( className == null ) {
 			throw new AnnotationException( "<entity-result> without entity-class. " + SCHEMA_VALIDATION );
 		}
 		try {
-			return ReflectHelper.classForName(
-					XMLContext.buildSafeClassName( className, defaults ),
-					JPAOverriddenAnnotationReader.class
+			return classLoaderAccess.classForName(
+					XMLContext.buildSafeClassName( className, defaults )
 			);
 		}
-		catch ( ClassNotFoundException e ) {
+		catch ( ClassLoadingException e ) {
 			throw new AnnotationException( "Unable to find specified class: " + className, e );
 		}
 	}
 
-	private static ColumnResult buildColumnResult(Element columnResultElement, XMLContext.Default defaults) {
+	private static ColumnResult buildColumnResult(
+			Element columnResultElement,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 //		AnnotationDescriptor columnResultDescriptor = new AnnotationDescriptor( ColumnResult.class );
 //		copyStringAttribute( columnResultDescriptor, columnResultElement, "name", true );
 //		return AnnotationFactory.create( columnResultDescriptor );
 
 		AnnotationDescriptor columnResultDescriptor = new AnnotationDescriptor( ColumnResult.class );
 		copyStringAttribute( columnResultDescriptor, columnResultElement, "name", true );
 		final String columnTypeName = columnResultElement.attributeValue( "class" );
 		if ( StringHelper.isNotEmpty( columnTypeName ) ) {
-			columnResultDescriptor.setValue( "type", resolveClassReference( columnTypeName, defaults ) );
+			columnResultDescriptor.setValue( "type", resolveClassReference( columnTypeName, defaults, classLoaderAccess ) );
 		}
 		return AnnotationFactory.create( columnResultDescriptor );
 	}
 
-	private static ConstructorResult buildConstructorResult(Element constructorResultElement, XMLContext.Default defaults) {
+	private static ConstructorResult buildConstructorResult(
+			Element constructorResultElement,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		AnnotationDescriptor constructorResultDescriptor = new AnnotationDescriptor( ConstructorResult.class );
 
-		final Class entityClass = resolveClassReference( constructorResultElement.attributeValue( "target-class" ), defaults );
+		final Class entityClass = resolveClassReference( constructorResultElement.attributeValue( "target-class" ), defaults, classLoaderAccess );
 		constructorResultDescriptor.setValue( "targetClass", entityClass );
 
 		List<ColumnResult> columnResultAnnotations = new ArrayList<ColumnResult>();
 		for ( Element columnResultElement : (List<Element>) constructorResultElement.elements( "column" ) ) {
-			columnResultAnnotations.add( buildColumnResult( columnResultElement, defaults ) );
+			columnResultAnnotations.add( buildColumnResult( columnResultElement, defaults, classLoaderAccess ) );
 		}
 		constructorResultDescriptor.setValue(
 				"columns",
 				columnResultAnnotations.toArray( new ColumnResult[ columnResultAnnotations.size() ] )
 		);
 
 		return AnnotationFactory.create( constructorResultDescriptor );
 	}
 
 	private void addSqlResultsetMappingIfNeeded(SqlResultSetMapping annotation, List<SqlResultSetMapping> resultsets) {
 		if ( annotation != null ) {
 			String resultsetName = annotation.name();
 			boolean present = false;
 			for ( SqlResultSetMapping current : resultsets ) {
 				if ( current.name().equals( resultsetName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				resultsets.add( annotation );
 			}
 		}
 	}
 
 	private NamedQueries getNamedQueries(Element tree, XMLContext.Default defaults) {
 		//TODO avoid the Proxy Creation (@NamedQueries) when possible
-		List<NamedQuery> queries = (List<NamedQuery>) buildNamedQueries( tree, false, defaults );
+		List<NamedQuery> queries = (List<NamedQuery>) buildNamedQueries( tree, false, defaults, classLoaderAccess );
 		if ( defaults.canUseJavaAnnotations() ) {
 			NamedQuery annotation = getPhysicalAnnotation( NamedQuery.class );
 			addNamedQueryIfNeeded( annotation, queries );
 			NamedQueries annotations = getPhysicalAnnotation( NamedQueries.class );
 			if ( annotations != null ) {
 				for ( NamedQuery current : annotations.value() ) {
 					addNamedQueryIfNeeded( current, queries );
 				}
 			}
 		}
 		if ( queries.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( NamedQueries.class );
 			ad.setValue( "value", queries.toArray( new NamedQuery[queries.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void addNamedQueryIfNeeded(NamedQuery annotation, List<NamedQuery> queries) {
 		if ( annotation != null ) {
 			String queryName = annotation.name();
 			boolean present = false;
 			for ( NamedQuery current : queries ) {
 				if ( current.name().equals( queryName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				queries.add( annotation );
 			}
 		}
 	}
 
 	private NamedEntityGraphs getNamedEntityGraphs(Element tree, XMLContext.Default defaults) {
-		List<NamedEntityGraph> queries = buildNamedEntityGraph( tree, defaults );
+		List<NamedEntityGraph> queries = buildNamedEntityGraph( tree, defaults, classLoaderAccess );
 		if ( defaults.canUseJavaAnnotations() ) {
 			NamedEntityGraph annotation = getPhysicalAnnotation( NamedEntityGraph.class );
 			addNamedEntityGraphIfNeeded( annotation, queries );
 			NamedEntityGraphs annotations = getPhysicalAnnotation( NamedEntityGraphs.class );
 			if ( annotations != null ) {
 				for ( NamedEntityGraph current : annotations.value() ) {
 					addNamedEntityGraphIfNeeded( current, queries );
 				}
 			}
 		}
 		if ( queries.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( NamedEntityGraphs.class );
 			ad.setValue( "value", queries.toArray( new NamedEntityGraph[queries.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void addNamedEntityGraphIfNeeded(NamedEntityGraph annotation, List<NamedEntityGraph> queries) {
 		if ( annotation != null ) {
 			String queryName = annotation.name();
 			boolean present = false;
 			for ( NamedEntityGraph current : queries ) {
 				if ( current.name().equals( queryName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				queries.add( annotation );
 			}
 		}
 
 	}
 
 	private NamedStoredProcedureQueries getNamedStoredProcedureQueries(Element tree, XMLContext.Default defaults) {
-		List<NamedStoredProcedureQuery> queries = buildNamedStoreProcedureQueries( tree, defaults );
+		List<NamedStoredProcedureQuery> queries = buildNamedStoreProcedureQueries( tree, defaults, classLoaderAccess );
 		if ( defaults.canUseJavaAnnotations() ) {
 			NamedStoredProcedureQuery annotation = getPhysicalAnnotation( NamedStoredProcedureQuery.class );
 			addNamedStoredProcedureQueryIfNeeded( annotation, queries );
 			NamedStoredProcedureQueries annotations = getPhysicalAnnotation( NamedStoredProcedureQueries.class );
 			if ( annotations != null ) {
 				for ( NamedStoredProcedureQuery current : annotations.value() ) {
 					addNamedStoredProcedureQueryIfNeeded( current, queries );
 				}
 			}
 		}
 		if ( queries.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( NamedStoredProcedureQueries.class );
 			ad.setValue( "value", queries.toArray( new NamedStoredProcedureQuery[queries.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void addNamedStoredProcedureQueryIfNeeded(NamedStoredProcedureQuery annotation, List<NamedStoredProcedureQuery> queries) {
 		if ( annotation != null ) {
 			String queryName = annotation.name();
 			boolean present = false;
 			for ( NamedStoredProcedureQuery current : queries ) {
 				if ( current.name().equals( queryName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				queries.add( annotation );
 			}
 		}
 	}
 
 
-	private NamedNativeQueries getNamedNativeQueries(Element tree, XMLContext.Default defaults) {
-		List<NamedNativeQuery> queries = (List<NamedNativeQuery>) buildNamedQueries( tree, true, defaults );
+	private NamedNativeQueries getNamedNativeQueries(
+			Element tree,
+			XMLContext.Default defaults) {
+		List<NamedNativeQuery> queries = (List<NamedNativeQuery>) buildNamedQueries( tree, true, defaults, classLoaderAccess );
 		if ( defaults.canUseJavaAnnotations() ) {
 			NamedNativeQuery annotation = getPhysicalAnnotation( NamedNativeQuery.class );
 			addNamedNativeQueryIfNeeded( annotation, queries );
 			NamedNativeQueries annotations = getPhysicalAnnotation( NamedNativeQueries.class );
 			if ( annotations != null ) {
 				for ( NamedNativeQuery current : annotations.value() ) {
 					addNamedNativeQueryIfNeeded( current, queries );
 				}
 			}
 		}
 		if ( queries.size() > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( NamedNativeQueries.class );
 			ad.setValue( "value", queries.toArray( new NamedNativeQuery[queries.size()] ) );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void addNamedNativeQueryIfNeeded(NamedNativeQuery annotation, List<NamedNativeQuery> queries) {
 		if ( annotation != null ) {
 			String queryName = annotation.name();
 			boolean present = false;
 			for ( NamedNativeQuery current : queries ) {
 				if ( current.name().equals( queryName ) ) {
 					present = true;
 					break;
 				}
 			}
 			if ( !present ) {
 				queries.add( annotation );
 			}
 		}
 	}
 
 	private static void buildQueryHints(List<Element> elements, AnnotationDescriptor ann){
 		List<QueryHint> queryHints = new ArrayList<QueryHint>( elements.size() );
 		for ( Element hint : elements ) {
 			AnnotationDescriptor hintDescriptor = new AnnotationDescriptor( QueryHint.class );
 			String value = hint.attributeValue( "name" );
 			if ( value == null ) {
 				throw new AnnotationException( "<hint> without name. " + SCHEMA_VALIDATION );
 			}
 			hintDescriptor.setValue( "name", value );
 			value = hint.attributeValue( "value" );
 			if ( value == null ) {
 				throw new AnnotationException( "<hint> without value. " + SCHEMA_VALIDATION );
 			}
 			hintDescriptor.setValue( "value", value );
 			queryHints.add( (QueryHint) AnnotationFactory.create( hintDescriptor ) );
 		}
 		ann.setValue( "hints", queryHints.toArray( new QueryHint[queryHints.size()] ) );
 	}
 
-	public static List buildNamedQueries(Element element, boolean isNative, XMLContext.Default defaults) {
+	public static List buildNamedQueries(
+			Element element,
+			boolean isNative,
+			XMLContext.Default defaults,
+			ClassLoaderAccess classLoaderAccess) {
 		if ( element == null ) {
 			return new ArrayList();
 		}
 		List namedQueryElementList = isNative ?
 				element.elements( "named-native-query" ) :
 				element.elements( "named-query" );
 		List namedQueries = new ArrayList();
-		Iterator it = namedQueryElementList.listIterator();
-		while ( it.hasNext() ) {
-			Element subelement = (Element) it.next();
+		for ( Object aNamedQueryElementList : namedQueryElementList ) {
+			Element subelement = (Element) aNamedQueryElementList;
 			AnnotationDescriptor ann = new AnnotationDescriptor(
 					isNative ? NamedNativeQuery.class : NamedQuery.class
 			);
 			copyStringAttribute( ann, subelement, "name", false );
 			Element queryElt = subelement.element( "query" );
 			if ( queryElt == null ) {
 				throw new AnnotationException( "No <query> element found." + SCHEMA_VALIDATION );
 			}
 			copyStringElement( queryElt, ann, "query" );
 			List<Element> elements = subelement.elements( "hint" );
 			buildQueryHints( elements, ann );
 			String clazzName = subelement.attributeValue( "result-class" );
 			if ( StringHelper.isNotEmpty( clazzName ) ) {
 				Class clazz;
 				try {
-					clazz = ReflectHelper.classForName(
-							XMLContext.buildSafeClassName( clazzName, defaults ),
-							JPAOverriddenAnnotationReader.class
+					clazz = classLoaderAccess.classForName(
+							XMLContext.buildSafeClassName( clazzName, defaults )
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch (ClassLoadingException e) {
 					throw new AnnotationException( "Unable to find entity-class: " + clazzName, e );
 				}
 				ann.setValue( "resultClass", clazz );
 			}
 			copyStringAttribute( ann, subelement, "result-set-mapping", false );
 			namedQueries.add( AnnotationFactory.create( ann ) );
 		}
 		return namedQueries;
 	}
 
 	private TableGenerator getTableGenerator(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( annotationToXml.get( TableGenerator.class ) ) : null;
 		if ( element != null ) {
 			return buildTableGeneratorAnnotation( element, defaults );
 		}
 		else if ( defaults.canUseJavaAnnotations() && isPhysicalAnnotationPresent( TableGenerator.class ) ) {
 			TableGenerator tableAnn = getPhysicalAnnotation( TableGenerator.class );
 			if ( StringHelper.isNotEmpty( defaults.getSchema() )
 					|| StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 				AnnotationDescriptor annotation = new AnnotationDescriptor( TableGenerator.class );
 				annotation.setValue( "name", tableAnn.name() );
 				annotation.setValue( "table", tableAnn.table() );
 				annotation.setValue( "catalog", tableAnn.table() );
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) )
 						&& StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 					annotation.setValue( "catalog", defaults.getCatalog() );
 				}
 				annotation.setValue( "schema", tableAnn.table() );
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) )
 						&& StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 					annotation.setValue( "catalog", defaults.getSchema() );
 				}
 				annotation.setValue( "pkColumnName", tableAnn.pkColumnName() );
 				annotation.setValue( "valueColumnName", tableAnn.valueColumnName() );
 				annotation.setValue( "pkColumnValue", tableAnn.pkColumnValue() );
 				annotation.setValue( "initialValue", tableAnn.initialValue() );
 				annotation.setValue( "allocationSize", tableAnn.allocationSize() );
 				annotation.setValue( "uniqueConstraints", tableAnn.uniqueConstraints() );
 				return AnnotationFactory.create( annotation );
 			}
 			else {
 				return tableAnn;
 			}
 		}
 		else {
 			return null;
 		}
 	}
 
 	public static TableGenerator buildTableGeneratorAnnotation(Element element, XMLContext.Default defaults) {
 		AnnotationDescriptor ad = new AnnotationDescriptor( TableGenerator.class );
 		copyStringAttribute( ad, element, "name", false );
 		copyStringAttribute( ad, element, "table", false );
 		copyStringAttribute( ad, element, "catalog", false );
 		copyStringAttribute( ad, element, "schema", false );
 		copyStringAttribute( ad, element, "pk-column-name", false );
 		copyStringAttribute( ad, element, "value-column-name", false );
 		copyStringAttribute( ad, element, "pk-column-value", false );
 		copyIntegerAttribute( ad, element, "initial-value" );
 		copyIntegerAttribute( ad, element, "allocation-size" );
 		buildUniqueConstraints( ad, element );
 		if ( StringHelper.isEmpty( (String) ad.valueOf( "schema" ) )
 				&& StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 			ad.setValue( "schema", defaults.getSchema() );
 		}
 		if ( StringHelper.isEmpty( (String) ad.valueOf( "catalog" ) )
 				&& StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 			ad.setValue( "catalog", defaults.getCatalog() );
 		}
 		return AnnotationFactory.create( ad );
 	}
 
 	private SequenceGenerator getSequenceGenerator(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( annotationToXml.get( SequenceGenerator.class ) ) : null;
 		if ( element != null ) {
 			return buildSequenceGeneratorAnnotation( element );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( SequenceGenerator.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	public static SequenceGenerator buildSequenceGeneratorAnnotation(Element element) {
 		if ( element != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( SequenceGenerator.class );
 			copyStringAttribute( ad, element, "name", false );
 			copyStringAttribute( ad, element, "sequence-name", false );
 			copyIntegerAttribute( ad, element, "initial-value" );
 			copyIntegerAttribute( ad, element, "allocation-size" );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private DiscriminatorColumn getDiscriminatorColumn(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( "discriminator-column" ) : null;
 		if ( element != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( DiscriminatorColumn.class );
 			copyStringAttribute( ad, element, "name", false );
 			copyStringAttribute( ad, element, "column-definition", false );
 			String value = element.attributeValue( "discriminator-type" );
 			DiscriminatorType type = DiscriminatorType.STRING;
 			if ( value != null ) {
 				if ( "STRING".equals( value ) ) {
 					type = DiscriminatorType.STRING;
 				}
 				else if ( "CHAR".equals( value ) ) {
 					type = DiscriminatorType.CHAR;
 				}
 				else if ( "INTEGER".equals( value ) ) {
 					type = DiscriminatorType.INTEGER;
 				}
 				else {
 					throw new AnnotationException(
 							"Unknown DiscrimiatorType in XML: " + value + " (" + SCHEMA_VALIDATION + ")"
 					);
 				}
 			}
 			ad.setValue( "discriminatorType", type );
 			copyIntegerAttribute( ad, element, "length" );
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( DiscriminatorColumn.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private DiscriminatorValue getDiscriminatorValue(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( "discriminator-value" ) : null;
 		if ( element != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( DiscriminatorValue.class );
 			copyStringElement( element, ad, "value" );
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( DiscriminatorValue.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private Inheritance getInheritance(Element tree, XMLContext.Default defaults) {
 		Element element = tree != null ? tree.element( "inheritance" ) : null;
 		if ( element != null ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( Inheritance.class );
 			Attribute attr = element.attribute( "strategy" );
 			InheritanceType strategy = InheritanceType.SINGLE_TABLE;
 			if ( attr != null ) {
 				String value = attr.getValue();
 				if ( "SINGLE_TABLE".equals( value ) ) {
 					strategy = InheritanceType.SINGLE_TABLE;
 				}
 				else if ( "JOINED".equals( value ) ) {
 					strategy = InheritanceType.JOINED;
 				}
 				else if ( "TABLE_PER_CLASS".equals( value ) ) {
 					strategy = InheritanceType.TABLE_PER_CLASS;
 				}
 				else {
 					throw new AnnotationException(
 							"Unknown InheritanceType in XML: " + value + " (" + SCHEMA_VALIDATION + ")"
 					);
 				}
 			}
 			ad.setValue( "strategy", strategy );
 			return AnnotationFactory.create( ad );
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( Inheritance.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private IdClass getIdClass(Element tree, XMLContext.Default defaults) {
 		Element element = tree == null ? null : tree.element( "id-class" );
 		if ( element != null ) {
 			Attribute attr = element.attribute( "class" );
 			if ( attr != null ) {
 				AnnotationDescriptor ad = new AnnotationDescriptor( IdClass.class );
 				Class clazz;
 				try {
-					clazz = ReflectHelper.classForName(
-							XMLContext.buildSafeClassName( attr.getValue(), defaults ),
-							this.getClass()
+					clazz = classLoaderAccess.classForName(
+							XMLContext.buildSafeClassName( attr.getValue(), defaults )
 					);
 				}
-				catch ( ClassNotFoundException e ) {
+				catch ( ClassLoadingException e ) {
 					throw new AnnotationException( "Unable to find id-class: " + attr.getValue(), e );
 				}
 				ad.setValue( "value", clazz );
 				return AnnotationFactory.create( ad );
 			}
 			else {
 				throw new AnnotationException( "id-class without class. " + SCHEMA_VALIDATION );
 			}
 		}
 		else if ( defaults.canUseJavaAnnotations() ) {
 			return getPhysicalAnnotation( IdClass.class );
 		}
 		else {
 			return null;
 		}
 	}
 
 	/**
 	 * @param mergeWithAnnotations Whether to use Java annotations for this
 	 * element, if present and not disabled by the XMLContext defaults.
 	 * In some contexts (such as an association mapping) merging with
 	 * annotations is never allowed.
 	 */
 	private PrimaryKeyJoinColumns getPrimaryKeyJoinColumns(Element element, XMLContext.Default defaults, boolean mergeWithAnnotations) {
 		PrimaryKeyJoinColumn[] columns = buildPrimaryKeyJoinColumns( element );
 		if ( mergeWithAnnotations ) {
 			if ( columns.length == 0 && defaults.canUseJavaAnnotations() ) {
 				PrimaryKeyJoinColumn annotation = getPhysicalAnnotation( PrimaryKeyJoinColumn.class );
 				if ( annotation != null ) {
 					columns = new PrimaryKeyJoinColumn[] { annotation };
 				}
 				else {
 					PrimaryKeyJoinColumns annotations = getPhysicalAnnotation( PrimaryKeyJoinColumns.class );
 					columns = annotations != null ? annotations.value() : columns;
 				}
 			}
 		}
 		if ( columns.length > 0 ) {
 			AnnotationDescriptor ad = new AnnotationDescriptor( PrimaryKeyJoinColumns.class );
 			ad.setValue( "value", columns );
 			return AnnotationFactory.create( ad );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private Entity getEntity(Element tree, XMLContext.Default defaults) {
 		if ( tree == null ) {
 			return defaults.canUseJavaAnnotations() ? getPhysicalAnnotation( Entity.class ) : null;
 		}
 		else {
 			if ( "entity".equals( tree.getName() ) ) {
 				AnnotationDescriptor entity = new AnnotationDescriptor( Entity.class );
 				copyStringAttribute( entity, tree, "name", false );
 				if ( defaults.canUseJavaAnnotations()
 						&& StringHelper.isEmpty( (String) entity.valueOf( "name" ) ) ) {
 					Entity javaAnn = getPhysicalAnnotation( Entity.class );
 					if ( javaAnn != null ) {
 						entity.setValue( "name", javaAnn.name() );
 					}
 				}
 				return AnnotationFactory.create( entity );
 			}
 			else {
 				return null; //this is not an entity
 			}
 		}
 	}
 
 	private MappedSuperclass getMappedSuperclass(Element tree, XMLContext.Default defaults) {
 		if ( tree == null ) {
 			return defaults.canUseJavaAnnotations() ? getPhysicalAnnotation( MappedSuperclass.class ) : null;
 		}
 		else {
 			if ( "mapped-superclass".equals( tree.getName() ) ) {
 				AnnotationDescriptor entity = new AnnotationDescriptor( MappedSuperclass.class );
 				return AnnotationFactory.create( entity );
 			}
 			else {
 				return null; //this is not an entity
 			}
 		}
 	}
 
 	private Embeddable getEmbeddable(Element tree, XMLContext.Default defaults) {
 		if ( tree == null ) {
 			return defaults.canUseJavaAnnotations() ? getPhysicalAnnotation( Embeddable.class ) : null;
 		}
 		else {
 			if ( "embeddable".equals( tree.getName() ) ) {
 				AnnotationDescriptor entity = new AnnotationDescriptor( Embeddable.class );
 				return AnnotationFactory.create( entity );
 			}
 			else {
 				return null; //this is not an entity
 			}
 		}
 	}
 
 	private Table getTable(Element tree, XMLContext.Default defaults) {
 		Element subelement = tree == null ? null : tree.element( "table" );
 		if ( subelement == null ) {
 			//no element but might have some default or some annotation
 			if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 					|| StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 				AnnotationDescriptor annotation = new AnnotationDescriptor( Table.class );
 				if ( defaults.canUseJavaAnnotations() ) {
 					Table table = getPhysicalAnnotation( Table.class );
 					if ( table != null ) {
 						annotation.setValue( "name", table.name() );
 						annotation.setValue( "schema", table.schema() );
 						annotation.setValue( "catalog", table.catalog() );
 						annotation.setValue( "uniqueConstraints", table.uniqueConstraints() );
 						annotation.setValue( "indexes", table.indexes() );
 					}
 				}
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) )
 						&& StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 					annotation.setValue( "schema", defaults.getSchema() );
 				}
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) )
 						&& StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 					annotation.setValue( "catalog", defaults.getCatalog() );
 				}
 				return AnnotationFactory.create( annotation );
 			}
 			else if ( defaults.canUseJavaAnnotations() ) {
 				return getPhysicalAnnotation( Table.class );
 			}
 			else {
 				return null;
 			}
 		}
 		else {
 			//ignore java annotation, an element is defined
 			AnnotationDescriptor annotation = new AnnotationDescriptor( Table.class );
 			copyStringAttribute( annotation, subelement, "name", false );
 			copyStringAttribute( annotation, subelement, "catalog", false );
 			if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) ) ) {
 				annotation.setValue( "catalog", defaults.getCatalog() );
 			}
 			copyStringAttribute( annotation, subelement, "schema", false );
 			if ( StringHelper.isNotEmpty( defaults.getSchema() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) ) ) {
 				annotation.setValue( "schema", defaults.getSchema() );
 			}
 			buildUniqueConstraints( annotation, subelement );
 			buildIndex( annotation, subelement );
 			return AnnotationFactory.create( annotation );
 		}
 	}
 
 	private SecondaryTables getSecondaryTables(Element tree, XMLContext.Default defaults) {
 		List<Element> elements = tree == null ?
 				new ArrayList<Element>() :
 				(List<Element>) tree.elements( "secondary-table" );
 		List<SecondaryTable> secondaryTables = new ArrayList<SecondaryTable>( 3 );
 		for ( Element element : elements ) {
 			AnnotationDescriptor annotation = new AnnotationDescriptor( SecondaryTable.class );
 			copyStringAttribute( annotation, element, "name", false );
 			copyStringAttribute( annotation, element, "catalog", false );
 			if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) ) ) {
 				annotation.setValue( "catalog", defaults.getCatalog() );
 			}
 			copyStringAttribute( annotation, element, "schema", false );
 			if ( StringHelper.isNotEmpty( defaults.getSchema() )
 					&& StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) ) ) {
 				annotation.setValue( "schema", defaults.getSchema() );
 			}
 			buildUniqueConstraints( annotation, element );
 			buildIndex( annotation, element );
 			annotation.setValue( "pkJoinColumns", buildPrimaryKeyJoinColumns( element ) );
 			secondaryTables.add( (SecondaryTable) AnnotationFactory.create( annotation ) );
 		}
 		/*
 		 * You can't have both secondary table in XML and Java,
 		 * since there would be no way to "remove" a secondary table
 		 */
 		if ( secondaryTables.size() == 0 && defaults.canUseJavaAnnotations() ) {
 			SecondaryTable secTableAnn = getPhysicalAnnotation( SecondaryTable.class );
 			overridesDefaultInSecondaryTable( secTableAnn, defaults, secondaryTables );
 			SecondaryTables secTablesAnn = getPhysicalAnnotation( SecondaryTables.class );
 			if ( secTablesAnn != null ) {
 				for ( SecondaryTable table : secTablesAnn.value() ) {
 					overridesDefaultInSecondaryTable( table, defaults, secondaryTables );
 				}
 			}
 		}
 		if ( secondaryTables.size() > 0 ) {
 			AnnotationDescriptor descriptor = new AnnotationDescriptor( SecondaryTables.class );
 			descriptor.setValue( "value", secondaryTables.toArray( new SecondaryTable[secondaryTables.size()] ) );
 			return AnnotationFactory.create( descriptor );
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void overridesDefaultInSecondaryTable(
 			SecondaryTable secTableAnn, XMLContext.Default defaults, List<SecondaryTable> secondaryTables
 	) {
 		if ( secTableAnn != null ) {
 			//handle default values
 			if ( StringHelper.isNotEmpty( defaults.getCatalog() )
 					|| StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 				AnnotationDescriptor annotation = new AnnotationDescriptor( SecondaryTable.class );
 				annotation.setValue( "name", secTableAnn.name() );
 				annotation.setValue( "schema", secTableAnn.schema() );
 				annotation.setValue( "catalog", secTableAnn.catalog() );
 				annotation.setValue( "uniqueConstraints", secTableAnn.uniqueConstraints() );
 				annotation.setValue( "pkJoinColumns", secTableAnn.pkJoinColumns() );
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "schema" ) )
 						&& StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 					annotation.setValue( "schema", defaults.getSchema() );
 				}
 				if ( StringHelper.isEmpty( (String) annotation.valueOf( "catalog" ) )
 						&& StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 					annotation.setValue( "catalog", defaults.getCatalog() );
 				}
 				secondaryTables.add( (SecondaryTable) AnnotationFactory.create( annotation ) );
 			}
 			else {
 				secondaryTables.add( secTableAnn );
 			}
 		}
 	}
 	private static void buildIndex(AnnotationDescriptor annotation, Element element){
 		List indexElementList = element.elements( "index" );
 		Index[] indexes = new Index[indexElementList.size()];
 		for(int i=0;i<indexElementList.size();i++){
 			Element subelement = (Element)indexElementList.get( i );
 			AnnotationDescriptor indexAnn = new AnnotationDescriptor( Index.class );
 			copyStringAttribute( indexAnn, subelement, "name", false );
 			copyStringAttribute( indexAnn, subelement, "column-list", true );
 			copyBooleanAttribute( indexAnn, subelement, "unique" );
 			indexes[i] = AnnotationFactory.create( indexAnn );
 		}
 		annotation.setValue( "indexes", indexes );
 	}
 	private static void buildUniqueConstraints(AnnotationDescriptor annotation, Element element) {
 		List uniqueConstraintElementList = element.elements( "unique-constraint" );
 		UniqueConstraint[] uniqueConstraints = new UniqueConstraint[uniqueConstraintElementList.size()];
 		int ucIndex = 0;
 		Iterator ucIt = uniqueConstraintElementList.listIterator();
 		while ( ucIt.hasNext() ) {
 			Element subelement = (Element) ucIt.next();
 			List<Element> columnNamesElements = subelement.elements( "column-name" );
 			String[] columnNames = new String[columnNamesElements.size()];
 			int columnNameIndex = 0;
 			Iterator it = columnNamesElements.listIterator();
 			while ( it.hasNext() ) {
 				Element columnNameElt = (Element) it.next();
 				columnNames[columnNameIndex++] = columnNameElt.getTextTrim();
 			}
 			AnnotationDescriptor ucAnn = new AnnotationDescriptor( UniqueConstraint.class );
 			copyStringAttribute( ucAnn, subelement, "name", false );
 			ucAnn.setValue( "columnNames", columnNames );
 			uniqueConstraints[ucIndex++] = AnnotationFactory.create( ucAnn );
 		}
 		annotation.setValue( "uniqueConstraints", uniqueConstraints );
 	}
 
 	private PrimaryKeyJoinColumn[] buildPrimaryKeyJoinColumns(Element element) {
 		if ( element == null ) {
 			return new PrimaryKeyJoinColumn[] { };
 		}
 		List pkJoinColumnElementList = element.elements( "primary-key-join-column" );
 		PrimaryKeyJoinColumn[] pkJoinColumns = new PrimaryKeyJoinColumn[pkJoinColumnElementList.size()];
 		int index = 0;
 		Iterator pkIt = pkJoinColumnElementList.listIterator();
 		while ( pkIt.hasNext() ) {
 			Element subelement = (Element) pkIt.next();
 			AnnotationDescriptor pkAnn = new AnnotationDescriptor( PrimaryKeyJoinColumn.class );
 			copyStringAttribute( pkAnn, subelement, "name", false );
 			copyStringAttribute( pkAnn, subelement, "referenced-column-name", false );
 			copyStringAttribute( pkAnn, subelement, "column-definition", false );
 			pkJoinColumns[index++] = AnnotationFactory.create( pkAnn );
 		}
 		return pkJoinColumns;
 	}
 
 	/**
 	 * Copy a string attribute from an XML element to an annotation descriptor. The name of the annotation attribute is
 	 * computed from the name of the XML attribute by {@link #getJavaAttributeNameFromXMLOne(String)}.
 	 *
 	 * @param annotation annotation descriptor where to copy to the attribute.
 	 * @param element XML element from where to copy the attribute.
 	 * @param attributeName name of the XML attribute to copy.
 	 * @param mandatory whether the attribute is mandatory.
 	 */
 	private static void copyStringAttribute(
 			final AnnotationDescriptor annotation, final Element element,
 			final String attributeName, final boolean mandatory) {
 		copyStringAttribute(
 				annotation,
 				element,
 				getJavaAttributeNameFromXMLOne( attributeName ),
 				attributeName,
 				mandatory
 		);
 	}
 
 	/**
 	 * Copy a string attribute from an XML element to an annotation descriptor. The name of the annotation attribute is
 	 * explicitely given.
 	 *
 	 * @param annotation annotation where to copy to the attribute.
 	 * @param element XML element from where to copy the attribute.
 	 * @param annotationAttributeName name of the annotation attribute where to copy.
 	 * @param attributeName name of the XML attribute to copy.
 	 * @param mandatory whether the attribute is mandatory.
 	 */
 	private static void copyStringAttribute(
 			final AnnotationDescriptor annotation, final Element element,
 			final String annotationAttributeName, final String attributeName, boolean mandatory) {
 		String attribute = element.attributeValue( attributeName );
 		if ( attribute != null ) {
 			annotation.setValue( annotationAttributeName, attribute );
 		}
 		else {
 			if ( mandatory ) {
 				throw new AnnotationException(
 						element.getName() + "." + attributeName + " is mandatory in XML overriding. " + SCHEMA_VALIDATION
 				);
 			}
 		}
 	}
 
 	private static void copyIntegerAttribute(AnnotationDescriptor annotation, Element element, String attributeName) {
 		String attribute = element.attributeValue( attributeName );
 		if ( attribute != null ) {
 			String annotationAttributeName = getJavaAttributeNameFromXMLOne( attributeName );
 			annotation.setValue( annotationAttributeName, attribute );
 			try {
 				int length = Integer.parseInt( attribute );
 				annotation.setValue( annotationAttributeName, length );
 			}
 			catch ( NumberFormatException e ) {
 				throw new AnnotationException(
 						element.getPath() + attributeName + " not parseable: " + attribute + " (" + SCHEMA_VALIDATION + ")"
 				);
 			}
 		}
 	}
 
 	private static String getJavaAttributeNameFromXMLOne(String attributeName) {
 		StringBuilder annotationAttributeName = new StringBuilder( attributeName );
 		int index = annotationAttributeName.indexOf( WORD_SEPARATOR );
 		while ( index != -1 ) {
 			annotationAttributeName.deleteCharAt( index );
 			annotationAttributeName.setCharAt(
 					index, Character.toUpperCase( annotationAttributeName.charAt( index ) )
 			);
 			index = annotationAttributeName.indexOf( WORD_SEPARATOR );
 		}
 		return annotationAttributeName.toString();
 	}
 
 	private static void copyStringElement(Element element, AnnotationDescriptor ad, String annotationAttribute) {
 		String discr = element.getTextTrim();
 		ad.setValue( annotationAttribute, discr );
 	}
 
 	private static void copyBooleanAttribute(AnnotationDescriptor descriptor, Element element, String attribute) {
 		String attributeValue = element.attributeValue( attribute );
 		if ( StringHelper.isNotEmpty( attributeValue ) ) {
 			String javaAttribute = getJavaAttributeNameFromXMLOne( attribute );
 			descriptor.setValue( javaAttribute, Boolean.parseBoolean( attributeValue ) );
 		}
 	}
 
 	private <T extends Annotation> T getPhysicalAnnotation(Class<T> annotationType) {
 		return element.getAnnotation( annotationType );
 	}
 
 	private <T extends Annotation> boolean isPhysicalAnnotationPresent(Class<T> annotationType) {
 		return element.isAnnotationPresent( annotationType );
 	}
 
 	private Annotation[] getPhysicalAnnotations() {
 		return element.getAnnotations();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/XMLContext.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/XMLContext.java
index b6839dd8f8..6417ab3388 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/XMLContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/reflection/XMLContext.java
@@ -1,331 +1,338 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.annotations.reflection;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.persistence.AccessType;
 import javax.persistence.AttributeConverter;
 
 import org.hibernate.AnnotationException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.cfg.AttributeConverterDefinition;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 
 import org.dom4j.Document;
 import org.dom4j.Element;
 
 /**
  * A helper for consuming orm.xml mappings.
  *
  * @author Emmanuel Bernard
  * @author Brett Meyer
  */
 public class XMLContext implements Serializable {
     private static final CoreMessageLogger LOG = CoreLogging.messageLogger( XMLContext.class );
 
+	private final ClassLoaderAccess classLoaderAccess;
+
 	private Default globalDefaults;
 	private Map<String, Element> classOverriding = new HashMap<String, Element>();
 	private Map<String, Default> defaultsOverriding = new HashMap<String, Default>();
 	private List<Element> defaultElements = new ArrayList<Element>();
 	private List<String> defaultEntityListeners = new ArrayList<String>();
 	private boolean hasContext = false;
 
+	public XMLContext(ClassLoaderAccess classLoaderAccess) {
+		this.classLoaderAccess = classLoaderAccess;
+	}
+
 	/**
 	 * @param doc The xml document to add
 	 * @return Add a xml document to this context and return the list of added class names.
 	 */
 	@SuppressWarnings( "unchecked" )
 	public List<String> addDocument(Document doc) {
 		hasContext = true;
 		List<String> addedClasses = new ArrayList<String>();
 		Element root = doc.getRootElement();
 		//global defaults
 		Element metadata = root.element( "persistence-unit-metadata" );
 		if ( metadata != null ) {
 			if ( globalDefaults == null ) {
 				globalDefaults = new Default();
 				globalDefaults.setMetadataComplete(
 						metadata.element( "xml-mapping-metadata-complete" ) != null ?
 								Boolean.TRUE :
 								null
 				);
 				Element defaultElement = metadata.element( "persistence-unit-defaults" );
 				if ( defaultElement != null ) {
 					Element unitElement = defaultElement.element( "schema" );
 					globalDefaults.setSchema( unitElement != null ? unitElement.getTextTrim() : null );
 					unitElement = defaultElement.element( "catalog" );
 					globalDefaults.setCatalog( unitElement != null ? unitElement.getTextTrim() : null );
 					unitElement = defaultElement.element( "access" );
 					setAccess( unitElement, globalDefaults );
 					unitElement = defaultElement.element( "cascade-persist" );
 					globalDefaults.setCascadePersist( unitElement != null ? Boolean.TRUE : null );
 					unitElement = defaultElement.element( "delimited-identifiers" );
 					globalDefaults.setDelimitedIdentifiers( unitElement != null ? Boolean.TRUE : null );
 					defaultEntityListeners.addAll( addEntityListenerClasses( defaultElement, null, addedClasses ) );
 				}
 			}
 			else {
 				LOG.duplicateMetadata();
 			}
 		}
 
 		//entity mapping default
 		Default entityMappingDefault = new Default();
 		Element unitElement = root.element( "package" );
 		String packageName = unitElement != null ? unitElement.getTextTrim() : null;
 		entityMappingDefault.setPackageName( packageName );
 		unitElement = root.element( "schema" );
 		entityMappingDefault.setSchema( unitElement != null ? unitElement.getTextTrim() : null );
 		unitElement = root.element( "catalog" );
 		entityMappingDefault.setCatalog( unitElement != null ? unitElement.getTextTrim() : null );
 		unitElement = root.element( "access" );
 		setAccess( unitElement, entityMappingDefault );
 		defaultElements.add( root );
 		
 		setLocalAttributeConverterDefinitions( root.elements( "converter" ) );
 
 		List<Element> entities = root.elements( "entity" );
 		addClass( entities, packageName, entityMappingDefault, addedClasses );
 
 		entities = root.elements( "mapped-superclass" );
 		addClass( entities, packageName, entityMappingDefault, addedClasses );
 
 		entities = root.elements( "embeddable" );
 		addClass( entities, packageName, entityMappingDefault, addedClasses );
 		return addedClasses;
 	}
 
 	private void setAccess(Element unitElement, Default defaultType) {
 		if ( unitElement != null ) {
 			String access = unitElement.getTextTrim();
 			setAccess( access, defaultType );
 		}
 	}
 
 	private void setAccess( String access, Default defaultType) {
 		AccessType type;
 		if ( access != null ) {
 			try {
 				type = AccessType.valueOf( access );
 			}
 			catch ( IllegalArgumentException e ) {
 				throw new AnnotationException( "Invalid access type " + access + " (check your xml configuration)" );
 			}
 			defaultType.setAccess( type );
 		}
 	}
 
 	private void addClass(List<Element> entities, String packageName, Default defaults, List<String> addedClasses) {
 		for (Element element : entities) {
 			String className = buildSafeClassName( element.attributeValue( "class" ), packageName );
 			if ( classOverriding.containsKey( className ) ) {
 				//maybe switch it to warn?
 				throw new IllegalStateException( "Duplicate XML entry for " + className );
 			}
 			addedClasses.add( className );
 			classOverriding.put( className, element );
 			Default localDefault = new Default();
 			localDefault.override( defaults );
 			String metadataCompleteString = element.attributeValue( "metadata-complete" );
 			if ( metadataCompleteString != null ) {
 				localDefault.setMetadataComplete( Boolean.parseBoolean( metadataCompleteString ) );
 			}
 			String access = element.attributeValue( "access" );
 			setAccess( access, localDefault );
 			defaultsOverriding.put( className, localDefault );
 
 			LOG.debugf( "Adding XML overriding information for %s", className );
 			addEntityListenerClasses( element, packageName, addedClasses );
 		}
 	}
 
 	private List<String> addEntityListenerClasses(Element element, String packageName, List<String> addedClasses) {
 		List<String> localAddedClasses = new ArrayList<String>();
 		Element listeners = element.element( "entity-listeners" );
 		if ( listeners != null ) {
 			@SuppressWarnings( "unchecked" )
 			List<Element> elements = listeners.elements( "entity-listener" );
 			for (Element listener : elements) {
 				String listenerClassName = buildSafeClassName( listener.attributeValue( "class" ), packageName );
 				if ( classOverriding.containsKey( listenerClassName ) ) {
 					//maybe switch it to warn?
 					if ( "entity-listener".equals( classOverriding.get( listenerClassName ).getName() ) ) {
 						LOG.duplicateListener( listenerClassName );
 						continue;
 					}
 					throw new IllegalStateException("Duplicate XML entry for " + listenerClassName);
 				}
 				localAddedClasses.add( listenerClassName );
 				classOverriding.put( listenerClassName, listener );
 			}
 		}
 		LOG.debugf( "Adding XML overriding information for listeners: %s", localAddedClasses );
 		addedClasses.addAll( localAddedClasses );
 		return localAddedClasses;
 	}
 	
 	@SuppressWarnings("unchecked")
 	private void setLocalAttributeConverterDefinitions(List<Element> converterElements) {
 		for ( Element converterElement : converterElements ) {
 			final String className = converterElement.attributeValue( "class" );
 			final String autoApplyAttribute = converterElement.attributeValue( "auto-apply" );
 			final boolean autoApply = autoApplyAttribute != null && Boolean.parseBoolean( autoApplyAttribute );
 
 			try {
-				final Class<? extends AttributeConverter> attributeConverterClass = ReflectHelper.classForName(
+				final Class<? extends AttributeConverter> attributeConverterClass = classLoaderAccess.classForName(
 						className
 				);
 				attributeConverterDefinitions.add(
 						new AttributeConverterDefinition( attributeConverterClass.newInstance(), autoApply )
 				);
 			}
-			catch (ClassNotFoundException e) {
+			catch (ClassLoadingException e) {
 				throw new AnnotationException( "Unable to locate specified AttributeConverter implementation class : " + className, e );
 			}
 			catch (Exception e) {
 				throw new AnnotationException( "Unable to instantiate specified AttributeConverter implementation class : " + className, e );
 			}
 		}
 	}
 
 	public static String buildSafeClassName(String className, String defaultPackageName) {
 		if ( className.indexOf( '.' ) < 0 && StringHelper.isNotEmpty( defaultPackageName ) ) {
 			className = StringHelper.qualify( defaultPackageName, className );
 		}
 		return className;
 	}
 
 	public static String buildSafeClassName(String className, XMLContext.Default defaults) {
 		return buildSafeClassName( className, defaults.getPackageName() );
 	}
 
 	public Default getDefault(String className) {
 		Default xmlDefault = new Default();
 		xmlDefault.override( globalDefaults );
 		if ( className != null ) {
 			Default entityMappingOverriding = defaultsOverriding.get( className );
 			xmlDefault.override( entityMappingOverriding );
 		}
 		return xmlDefault;
 	}
 
 	public Element getXMLTree(String className ) {
 		return classOverriding.get( className );
 	}
 
 	public List<Element> getAllDocuments() {
 		return defaultElements;
 	}
 
 	public boolean hasContext() {
 		return hasContext;
 	}
 
 	private List<AttributeConverterDefinition> attributeConverterDefinitions = new ArrayList<AttributeConverterDefinition>();
 
 	public void applyDiscoveredAttributeConverters(AttributeConverterDefinitionCollector collector) {
 		for ( AttributeConverterDefinition definition : attributeConverterDefinitions ) {
 			collector.addAttributeConverter( definition );
 		}
 		attributeConverterDefinitions.clear();
 	}
 
 	public static class Default implements Serializable {
 		private AccessType access;
 		private String packageName;
 		private String schema;
 		private String catalog;
 		private Boolean metadataComplete;
 		private Boolean cascadePersist;
 		private Boolean delimitedIdentifier;
 
 		public AccessType getAccess() {
 			return access;
 		}
 
 		protected void setAccess(AccessType access) {
 			this.access = access;
 		}
 
 		public String getCatalog() {
 			return catalog;
 		}
 
 		protected void setCatalog(String catalog) {
 			this.catalog = catalog;
 		}
 
 		public String getPackageName() {
 			return packageName;
 		}
 
 		protected void setPackageName(String packageName) {
 			this.packageName = packageName;
 		}
 
 		public String getSchema() {
 			return schema;
 		}
 
 		protected void setSchema(String schema) {
 			this.schema = schema;
 		}
 
 		public Boolean getMetadataComplete() {
 			return metadataComplete;
 		}
 
 		public boolean canUseJavaAnnotations() {
 			return metadataComplete == null || !metadataComplete;
 		}
 
 		protected void setMetadataComplete(Boolean metadataComplete) {
 			this.metadataComplete = metadataComplete;
 		}
 
 		public Boolean getCascadePersist() {
 			return cascadePersist;
 		}
 
 		void setCascadePersist(Boolean cascadePersist) {
 			this.cascadePersist = cascadePersist;
 		}
 
 		public void override(Default globalDefault) {
 			if ( globalDefault != null ) {
 				if ( globalDefault.getAccess() != null ) access = globalDefault.getAccess();
 				if ( globalDefault.getPackageName() != null ) packageName = globalDefault.getPackageName();
 				if ( globalDefault.getSchema() != null ) schema = globalDefault.getSchema();
 				if ( globalDefault.getCatalog() != null ) catalog = globalDefault.getCatalog();
 				if ( globalDefault.getDelimitedIdentifier() != null ) delimitedIdentifier = globalDefault.getDelimitedIdentifier();
 				if ( globalDefault.getMetadataComplete() != null ) {
 					metadataComplete = globalDefault.getMetadataComplete();
 				}
 				//TODO fix that in stone if cascade-persist is set already?
 				if ( globalDefault.getCascadePersist() != null ) cascadePersist = globalDefault.getCascadePersist();
 			}
 		}
 
 		public void setDelimitedIdentifiers(Boolean delimitedIdentifier) {
 			this.delimitedIdentifier = delimitedIdentifier;
 		}
 
 		public Boolean getDelimitedIdentifier() {
 			return delimitedIdentifier;
 		}
 	}
 
 	public List<String> getDefaultEntityListeners() {
 		return defaultEntityListeners;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
index 2370cada61..d2ff0f7ba7 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java
@@ -1,156 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.validation.ConstraintViolation;
 import javax.validation.ConstraintViolationException;
 import javax.validation.TraversableResolver;
 import javax.validation.Validation;
 import javax.validation.Validator;
 import javax.validation.ValidatorFactory;
 
 import org.hibernate.EntityMode;
+import org.hibernate.boot.internal.ClassLoaderAccessImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.spi.PreDeleteEvent;
 import org.hibernate.event.spi.PreDeleteEventListener;
 import org.hibernate.event.spi.PreInsertEvent;
 import org.hibernate.event.spi.PreInsertEventListener;
 import org.hibernate.event.spi.PreUpdateEvent;
 import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.entity.EntityPersister;
 
 import org.jboss.logging.Logger;
 
 /**
  * Event listener used to enable Bean Validation for insert/update/delete events.
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 //FIXME review exception model
 public class BeanValidationEventListener
 		implements PreInsertEventListener, PreUpdateEventListener, PreDeleteEventListener {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        BeanValidationEventListener.class.getName());
 
 	private ValidatorFactory factory;
 	private ConcurrentHashMap<EntityPersister, Set<String>> associationsPerEntityPersister =
 			new ConcurrentHashMap<EntityPersister, Set<String>>();
 	private GroupsPerOperation groupsPerOperation;
 	boolean initialized;
 
 	/**
-	 * No-arg constructor used when listener is configured via configuration file
-	 */
-	public BeanValidationEventListener() {
-	}
-
-	/**
 	 * Constructor used in an environment where validator factory is injected (JPA2).
 	 *
 	 * @param factory The {@code ValidatorFactory} to use to create {@code Validator} instance(s)
 	 * @param settings Configued properties
 	 */
-	public BeanValidationEventListener(ValidatorFactory factory, Map settings) {
-		init( factory, settings );
+	public BeanValidationEventListener(ValidatorFactory factory, Map settings, ClassLoaderService classLoaderService) {
+		init( factory, settings, classLoaderService );
 	}
 
-	public void initialize(Map settings) {
+	public void initialize(Map settings, ClassLoaderService classLoaderService) {
 		if ( !initialized ) {
 			ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
-			init( factory, settings );
+			init( factory, settings, classLoaderService );
 		}
 	}
 
+	private void init(ValidatorFactory factory, Map settings, ClassLoaderService classLoaderService) {
+		this.factory = factory;
+		groupsPerOperation = GroupsPerOperation.from( settings, new ClassLoaderAccessImpl( classLoaderService ) );
+		initialized = true;
+	}
+
 	public boolean onPreInsert(PreInsertEvent event) {
 		validate(
 				event.getEntity(), event.getPersister().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.INSERT
 		);
 		return false;
 	}
 
 	public boolean onPreUpdate(PreUpdateEvent event) {
 		validate(
 				event.getEntity(), event.getPersister().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.UPDATE
 		);
 		return false;
 	}
 
 	public boolean onPreDelete(PreDeleteEvent event) {
 		validate(
 				event.getEntity(), event.getPersister().getEntityMode(), event.getPersister(),
 				event.getSession().getFactory(), GroupsPerOperation.Operation.DELETE
 		);
 		return false;
 	}
 
-	private void init(ValidatorFactory factory, Map settings) {
-		this.factory = factory;
-		groupsPerOperation = new GroupsPerOperation( settings );
-		initialized = true;
-	}
-
 	private <T> void validate(T object, EntityMode mode, EntityPersister persister,
 							  SessionFactoryImplementor sessionFactory, GroupsPerOperation.Operation operation) {
 		if ( object == null || mode != EntityMode.POJO ) {
 			return;
 		}
 		TraversableResolver tr = new HibernateTraversableResolver(
 				persister, associationsPerEntityPersister, sessionFactory
 		);
 		Validator validator = factory.usingContext()
 				.traversableResolver( tr )
 				.getValidator();
 		final Class<?>[] groups = groupsPerOperation.get( operation );
 		if ( groups.length > 0 ) {
 			final Set<ConstraintViolation<T>> constraintViolations = validator.validate( object, groups );
 			if ( constraintViolations.size() > 0 ) {
 				Set<ConstraintViolation<?>> propagatedViolations =
 						new HashSet<ConstraintViolation<?>>( constraintViolations.size() );
 				Set<String> classNames = new HashSet<String>();
 				for ( ConstraintViolation<?> violation : constraintViolations ) {
 					LOG.trace( violation );
 					propagatedViolations.add( violation );
 					classNames.add( violation.getLeafBean().getClass().getName() );
 				}
 				StringBuilder builder = new StringBuilder();
 				builder.append( "Validation failed for classes " );
 				builder.append( classNames );
 				builder.append( " during " );
 				builder.append( operation.getName() );
 				builder.append( " time for groups " );
 				builder.append( toString( groups ) );
 				builder.append( "\nList of constraint violations:[\n" );
 				for (ConstraintViolation<?> violation : constraintViolations) {
 					builder.append( "\t" ).append( violation.toString() ).append("\n");
 				}
 				builder.append( "]" );
 
 				throw new ConstraintViolationException(
 						builder.toString(), propagatedViolations
 				);
 			}
 		}
 	}
 
 	private String toString(Class<?>[] groups) {
 		StringBuilder toString = new StringBuilder( "[" );
 		for ( Class<?> group : groups ) {
 			toString.append( group.getName() ).append( ", " );
 		}
 		toString.append( "]" );
 		return toString.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/GroupsPerOperation.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/GroupsPerOperation.java
index 59a247753f..53fca795d9 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/GroupsPerOperation.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/GroupsPerOperation.java
@@ -1,106 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.validation.groups.Default;
 
 import org.hibernate.HibernateException;
-import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
 
 /**
  * @author Emmanuel Bernard
  */
 public class GroupsPerOperation {
-
 	private static final String JPA_GROUP_PREFIX = "javax.persistence.validation.group.";
 	private static final String HIBERNATE_GROUP_PREFIX = "org.hibernate.validator.group.";
+
 	private static final Class<?>[] DEFAULT_GROUPS = new Class<?>[] { Default.class };
 	private static final Class<?>[] EMPTY_GROUPS = new Class<?>[] { };
 
 	private Map<Operation, Class<?>[]> groupsPerOperation = new HashMap<Operation, Class<?>[]>(4);
 
-	public GroupsPerOperation(Map settings) {
-		setGroupsForOperation( Operation.INSERT, settings );
-		setGroupsForOperation( Operation.UPDATE, settings );
-		setGroupsForOperation( Operation.DELETE, settings );
-		setGroupsForOperation( Operation.DDL, settings );
+	private GroupsPerOperation() {
 	}
 
-	private void setGroupsForOperation(Operation operation, Map settings) {
-		Object property = settings.get( operation.getGroupPropertyName() );
+	public static GroupsPerOperation from(Map settings, ClassLoaderAccess classLoaderAccess) {
+		GroupsPerOperation groupsPerOperation = new GroupsPerOperation();
+
+		applyOperationGrouping( groupsPerOperation, Operation.INSERT, settings, classLoaderAccess );
+		applyOperationGrouping( groupsPerOperation, Operation.UPDATE, settings, classLoaderAccess );
+		applyOperationGrouping( groupsPerOperation, Operation.DELETE, settings, classLoaderAccess );
+		applyOperationGrouping( groupsPerOperation, Operation.DDL, settings, classLoaderAccess );
+
+		return groupsPerOperation;
+	}
+
+	private static void applyOperationGrouping(
+			GroupsPerOperation groupsPerOperation,
+			Operation operation,
+			Map settings,
+			ClassLoaderAccess classLoaderAccess) {
+		groupsPerOperation.groupsPerOperation.put(
+				operation,
+				buildGroupsForOperation( operation, settings, classLoaderAccess )
+		);
+	}
+
+	public static Class<?>[] buildGroupsForOperation(Operation operation, Map settings, ClassLoaderAccess classLoaderAccess) {
+		final Object property = settings.get( operation.getGroupPropertyName() );
 
-		Class<?>[] groups;
 		if ( property == null ) {
-			groups = operation == Operation.DELETE ? EMPTY_GROUPS : DEFAULT_GROUPS;
+			return operation == Operation.DELETE ? EMPTY_GROUPS : DEFAULT_GROUPS;
 		}
-		else {
-			if ( property instanceof String ) {
-				String stringProperty = (String) property;
-				String[] groupNames = stringProperty.split( "," );
-				if ( groupNames.length == 1 && groupNames[0].equals( "" ) ) {
-					groups = EMPTY_GROUPS;
-				}
-				else {
-					List<Class<?>> groupsList = new ArrayList<Class<?>>(groupNames.length);
-					for (String groupName : groupNames) {
-						String cleanedGroupName = groupName.trim();
-						if ( cleanedGroupName.length() > 0) {
-							try {
-								groupsList.add( ReflectHelper.classForName( cleanedGroupName ) );
-							}
-							catch ( ClassNotFoundException e ) {
-								throw new HibernateException( "Unable to load class " + cleanedGroupName, e );
-							}
-						}
+
+		if ( property instanceof Class<?>[] ) {
+			return (Class<?>[]) property;
+		}
+
+		if ( property instanceof String ) {
+			String stringProperty = (String) property;
+			String[] groupNames = stringProperty.split( "," );
+			if ( groupNames.length == 1 && groupNames[0].equals( "" ) ) {
+				return EMPTY_GROUPS;
+			}
+
+			List<Class<?>> groupsList = new ArrayList<Class<?>>(groupNames.length);
+			for (String groupName : groupNames) {
+				String cleanedGroupName = groupName.trim();
+				if ( cleanedGroupName.length() > 0) {
+					try {
+						groupsList.add( classLoaderAccess.classForName( cleanedGroupName ) );
+					}
+					catch ( ClassLoadingException e ) {
+						throw new HibernateException( "Unable to load class " + cleanedGroupName, e );
 					}
-					groups = groupsList.toArray( new Class<?>[groupsList.size()] );
 				}
 			}
-			else if ( property instanceof Class<?>[] ) {
-				groups = (Class<?>[]) property;
-			}
-			else {
-				//null is bad and excluded by instanceof => exception is raised
-				throw new HibernateException( JPA_GROUP_PREFIX + operation.getGroupPropertyName() + " is of unknown type: String or Class<?>[] only");
-			}
+			return groupsList.toArray( new Class<?>[groupsList.size()] );
 		}
-		groupsPerOperation.put( operation, groups );
+
+		//null is bad and excluded by instanceof => exception is raised
+		throw new HibernateException( JPA_GROUP_PREFIX + operation.getGroupPropertyName() + " is of unknown type: String or Class<?>[] only");
 	}
 
 	public Class<?>[] get(Operation operation) {
 		return groupsPerOperation.get( operation );
 	}
 
 	public static enum Operation {
 		INSERT("persist", JPA_GROUP_PREFIX + "pre-persist"),
 		UPDATE("update", JPA_GROUP_PREFIX + "pre-update"),
 		DELETE("remove", JPA_GROUP_PREFIX + "pre-remove"),
 		DDL("ddl", HIBERNATE_GROUP_PREFIX + "ddl");
 
 
 		private String exposedName;
 		private String groupPropertyName;
 
 		Operation(String exposedName, String groupProperty) {
 			this.exposedName = exposedName;
 			this.groupPropertyName = groupProperty;
 		}
 
 		public String getName() {
 			return exposedName;
 		}
 
 		public String getGroupPropertyName() {
 			return groupPropertyName;
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
index e3fdb5aa58..b7402dee99 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/TypeSafeActivator.java
@@ -1,452 +1,463 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import javax.validation.Validation;
 import javax.validation.ValidatorFactory;
 import javax.validation.constraints.Digits;
 import javax.validation.constraints.Max;
 import javax.validation.constraints.Min;
 import javax.validation.constraints.NotNull;
 import javax.validation.constraints.Size;
 import javax.validation.metadata.BeanDescriptor;
 import javax.validation.metadata.ConstraintDescriptor;
 import javax.validation.metadata.PropertyDescriptor;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.MappingException;
+import org.hibernate.boot.internal.ClassLoaderAccessImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.config.spi.StandardConverters;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.SingleTableSubclass;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  * @author Steve Ebersole
  */
 class TypeSafeActivator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, TypeSafeActivator.class.getName());
 
 	private static final String FACTORY_PROPERTY = "javax.persistence.validation.factory";
 
 	/**
 	 * Used to validate a supplied ValidatorFactory instance as being castable to ValidatorFactory.
 	 *
 	 * @param object The supplied ValidatorFactory instance.
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static void validateSuppliedFactory(Object object) {
 		if ( ! ValidatorFactory.class.isInstance( object ) ) {
 			throw new IntegrationException(
 					"Given object was not an instance of " + ValidatorFactory.class.getName()
 							+ "[" + object.getClass().getName() + "]"
 			);
 		}
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public static void activate(ActivationContext activationContext) {
 		final ConfigurationService cfgService = activationContext.getServiceRegistry().getService( ConfigurationService.class );
 		final ValidatorFactory factory;
 		try {
 			factory = getValidatorFactory( cfgService.getSettings() );
 		}
 		catch (IntegrationException e) {
 			if ( activationContext.getValidationModes().contains( ValidationMode.CALLBACK ) ) {
 				throw new IntegrationException( "Bean Validation provider was not available, but 'callback' validation was requested", e );
 			}
 			if ( activationContext.getValidationModes().contains( ValidationMode.DDL ) ) {
 				throw new IntegrationException( "Bean Validation provider was not available, but 'ddl' validation was requested", e );
 			}
 
 			LOG.debug( "Unable to acquire Bean Validation ValidatorFactory, skipping activation" );
 			return;
 		}
 
 		applyRelationalConstraints( factory, activationContext );
 
 		applyCallbackListeners( factory, activationContext );
 	}
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static void applyCallbackListeners(ValidatorFactory validatorFactory, ActivationContext activationContext) {
 		final Set<ValidationMode> modes = activationContext.getValidationModes();
 		if ( ! ( modes.contains( ValidationMode.CALLBACK ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		final ConfigurationService cfgService = activationContext.getServiceRegistry().getService( ConfigurationService.class );
+		final ClassLoaderService classLoaderService = activationContext.getServiceRegistry().getService( ClassLoaderService.class );
 
 		// de-activate not-null tracking at the core level when Bean Validation is present unless the user explicitly
 		// asks for it
 		if ( cfgService.getSettings().get( Environment.CHECK_NULLABILITY ) == null ) {
 			activationContext.getSessionFactory().getSettings().setCheckNullability( false );
 		}
 
 		final BeanValidationEventListener listener = new BeanValidationEventListener(
 				validatorFactory,
-				cfgService.getSettings()
+				cfgService.getSettings(),
+				classLoaderService
 		);
 
 		final EventListenerRegistry listenerRegistry = activationContext.getServiceRegistry()
 				.getService( EventListenerRegistry.class );
 
 		listenerRegistry.addDuplicationStrategy( DuplicationStrategyImpl.INSTANCE );
 
 		listenerRegistry.appendListeners( EventType.PRE_INSERT, listener );
 		listenerRegistry.appendListeners( EventType.PRE_UPDATE, listener );
 		listenerRegistry.appendListeners( EventType.PRE_DELETE, listener );
 
-		listener.initialize( cfgService.getSettings() );
+		listener.initialize( cfgService.getSettings(), classLoaderService );
 	}
 
 	@SuppressWarnings({"unchecked", "UnusedParameters"})
 	private static void applyRelationalConstraints(ValidatorFactory factory, ActivationContext activationContext) {
 		final ConfigurationService cfgService = activationContext.getServiceRegistry().getService( ConfigurationService.class );
 		if ( !cfgService.getSetting( BeanValidationIntegrator.APPLY_CONSTRAINTS, StandardConverters.BOOLEAN, true  ) ) {
 			LOG.debug( "Skipping application of relational constraints from legacy Hibernate Validator" );
 			return;
 		}
 
 		final Set<ValidationMode> modes = activationContext.getValidationModes();
 		if ( ! ( modes.contains( ValidationMode.DDL ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		applyRelationalConstraints(
 				factory,
 				activationContext.getMetadata().getEntityBindings(),
 				cfgService.getSettings(),
-				activationContext.getServiceRegistry().getService( JdbcServices.class ).getDialect()
+				activationContext.getServiceRegistry().getService( JdbcServices.class ).getDialect(),
+				new ClassLoaderAccessImpl( null, activationContext.getServiceRegistry().getService( ClassLoaderService.class ) )
 		);
 	}
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static void applyRelationalConstraints(
 			ValidatorFactory factory,
 			Collection<PersistentClass> persistentClasses,
 			Map settings,
-			Dialect dialect) {
-		Class<?>[] groupsArray = new GroupsPerOperation( settings ).get( GroupsPerOperation.Operation.DDL );
+			Dialect dialect,
+			ClassLoaderAccess classLoaderAccess) {
+		Class<?>[] groupsArray = GroupsPerOperation.buildGroupsForOperation(
+				GroupsPerOperation.Operation.DDL,
+				settings,
+				classLoaderAccess
+		);
 		Set<Class<?>> groups = new HashSet<Class<?>>( Arrays.asList( groupsArray ) );
 
 		for ( PersistentClass persistentClass : persistentClasses ) {
 			final String className = persistentClass.getClassName();
 
 			if ( className == null || className.length() == 0 ) {
 				continue;
 			}
 			Class<?> clazz;
 			try {
-				clazz = ReflectHelper.classForName( className, TypeSafeActivator.class );
+				clazz = classLoaderAccess.classForName( className );
 			}
-			catch ( ClassNotFoundException e ) {
+			catch ( ClassLoadingException e ) {
 				throw new AssertionFailure( "Entity class not found", e );
 			}
 
 			try {
 				applyDDL( "", persistentClass, clazz, factory, groups, true, dialect );
 			}
 			catch (Exception e) {
 				LOG.unableToApplyConstraints( className, e );
 			}
 		}
 	}
 
 	private static void applyDDL(
 			String prefix,
 			PersistentClass persistentClass,
 			Class<?> clazz,
 			ValidatorFactory factory,
 			Set<Class<?>> groups,
 			boolean activateNotNull,
 			Dialect dialect) {
 		final BeanDescriptor descriptor = factory.getValidator().getConstraintsForClass( clazz );
 		//no bean level constraints can be applied, go to the properties
 
 		for ( PropertyDescriptor propertyDesc : descriptor.getConstrainedProperties() ) {
 			Property property = findPropertyByName( persistentClass, prefix + propertyDesc.getPropertyName() );
 			boolean hasNotNull;
 			if ( property != null ) {
 				hasNotNull = applyConstraints(
 						propertyDesc.getConstraintDescriptors(), property, propertyDesc, groups, activateNotNull, dialect
 				);
 				if ( property.isComposite() && propertyDesc.isCascaded() ) {
 					Class<?> componentClass = ( (Component) property.getValue() ).getComponentClass();
 
 					/*
 					 * we can apply not null if the upper component let's us activate not null
 					 * and if the property is not null.
 					 * Otherwise, all sub columns should be left nullable
 					 */
 					final boolean canSetNotNullOnColumns = activateNotNull && hasNotNull;
 					applyDDL(
 							prefix + propertyDesc.getPropertyName() + ".",
 							persistentClass, componentClass, factory, groups,
 							canSetNotNullOnColumns,
                             dialect
 					);
 				}
 				//FIXME add collection of components
 			}
 		}
 	}
 
 	private static boolean applyConstraints(
 			Set<ConstraintDescriptor<?>> constraintDescriptors,
 			Property property,
 			PropertyDescriptor propertyDesc,
 			Set<Class<?>> groups,
 			boolean canApplyNotNull,
 			Dialect dialect) {
 		boolean hasNotNull = false;
 		for ( ConstraintDescriptor<?> descriptor : constraintDescriptors ) {
 			if ( groups != null && Collections.disjoint( descriptor.getGroups(), groups ) ) {
 				continue;
 			}
 
 			if ( canApplyNotNull ) {
 				hasNotNull = hasNotNull || applyNotNull( property, descriptor );
 			}
 
 			// apply bean validation specific constraints
 			applyDigits( property, descriptor );
 			applySize( property, descriptor, propertyDesc );
 			applyMin( property, descriptor, dialect );
 			applyMax( property, descriptor, dialect );
 
 			// apply hibernate validator specific constraints - we cannot import any HV specific classes though!
 			// no need to check explicitly for @Range. @Range is a composed constraint using @Min and @Max which
 			// will be taken care later
 			applyLength( property, descriptor, propertyDesc );
 
 			// pass an empty set as composing constraints inherit the main constraint and thus are matching already
 			hasNotNull = hasNotNull || applyConstraints(
 					descriptor.getComposingConstraints(),
 					property, propertyDesc, null,
 					canApplyNotNull,
                     dialect
 			);
 		}
 		return hasNotNull;
 	}
 
 	private static void applyMin(Property property, ConstraintDescriptor<?> descriptor, Dialect dialect) {
 		if ( Min.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Min> minConstraint = (ConstraintDescriptor<Min>) descriptor;
 			long min = minConstraint.getAnnotation().value();
 
 			Column col = (Column) property.getColumnIterator().next();
 			String checkConstraint = col.getQuotedName(dialect) + ">=" + min;
 			applySQLCheck( col, checkConstraint );
 		}
 	}
 
 	private static void applyMax(Property property, ConstraintDescriptor<?> descriptor, Dialect dialect) {
 		if ( Max.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Max> maxConstraint = (ConstraintDescriptor<Max>) descriptor;
 			long max = maxConstraint.getAnnotation().value();
 			Column col = (Column) property.getColumnIterator().next();
 			String checkConstraint = col.getQuotedName(dialect) + "<=" + max;
 			applySQLCheck( col, checkConstraint );
 		}
 	}
 
 	private static void applySQLCheck(Column col, String checkConstraint) {
 		String existingCheck = col.getCheckConstraint();
 		// need to check whether the new check is already part of the existing check, because applyDDL can be called
 		// multiple times
 		if ( StringHelper.isNotEmpty( existingCheck ) && !existingCheck.contains( checkConstraint ) ) {
 			checkConstraint = col.getCheckConstraint() + " AND " + checkConstraint;
 		}
 		col.setCheckConstraint( checkConstraint );
 	}
 
 	private static boolean applyNotNull(Property property, ConstraintDescriptor<?> descriptor) {
 		boolean hasNotNull = false;
 		if ( NotNull.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			// single table inheritance should not be forced to null due to shared state
 			if ( !( property.getPersistentClass() instanceof SingleTableSubclass ) ) {
 				//composite should not add not-null on all columns
 				if ( !property.isComposite() ) {
 					final Iterator<Selectable> iter = property.getColumnIterator();
 					while ( iter.hasNext() ) {
 						final Selectable selectable = iter.next();
 						if ( Column.class.isInstance( selectable ) ) {
 							Column.class.cast( selectable ).setNullable( false );
 						}
 						else {
 							LOG.debugf(
 									"@NotNull was applied to attribute [%s] which is defined (at least partially) " +
 											"by formula(s); formula portions will be skipped",
 									property.getName()
 							);
 						}
 					}
 				}
 			}
 			hasNotNull = true;
 		}
 		return hasNotNull;
 	}
 
 	private static void applyDigits(Property property, ConstraintDescriptor<?> descriptor) {
 		if ( Digits.class.equals( descriptor.getAnnotation().annotationType() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Digits> digitsConstraint = (ConstraintDescriptor<Digits>) descriptor;
 			int integerDigits = digitsConstraint.getAnnotation().integer();
 			int fractionalDigits = digitsConstraint.getAnnotation().fraction();
 			Column col = (Column) property.getColumnIterator().next();
 			col.setPrecision( integerDigits + fractionalDigits );
 			col.setScale( fractionalDigits );
 		}
 	}
 
 	private static void applySize(Property property, ConstraintDescriptor<?> descriptor, PropertyDescriptor propertyDescriptor) {
 		if ( Size.class.equals( descriptor.getAnnotation().annotationType() )
 				&& String.class.equals( propertyDescriptor.getElementClass() ) ) {
 			@SuppressWarnings("unchecked")
 			ConstraintDescriptor<Size> sizeConstraint = (ConstraintDescriptor<Size>) descriptor;
 			int max = sizeConstraint.getAnnotation().max();
 			Column col = (Column) property.getColumnIterator().next();
 			if ( max < Integer.MAX_VALUE ) {
 				col.setLength( max );
 			}
 		}
 	}
 
 	private static void applyLength(Property property, ConstraintDescriptor<?> descriptor, PropertyDescriptor propertyDescriptor) {
 		if ( "org.hibernate.validator.constraints.Length".equals(
 				descriptor.getAnnotation().annotationType().getName()
 		)
 				&& String.class.equals( propertyDescriptor.getElementClass() ) ) {
 			@SuppressWarnings("unchecked")
 			int max = (Integer) descriptor.getAttributes().get( "max" );
 			Column col = (Column) property.getColumnIterator().next();
 			if ( max < Integer.MAX_VALUE ) {
 				col.setLength( max );
 			}
 		}
 	}
 
 	/**
 	 * @param associatedClass
 	 * @param propertyName
      * @return the property by path in a recursive way, including IdentifierProperty in the loop if propertyName is
      * <code>null</code>.  If propertyName is <code>null</code> or empty, the IdentifierProperty is returned
 	 */
 	private static Property findPropertyByName(PersistentClass associatedClass, String propertyName) {
 		Property property = null;
 		Property idProperty = associatedClass.getIdentifierProperty();
 		String idName = idProperty != null ? idProperty.getName() : null;
 		try {
 			if ( propertyName == null
 					|| propertyName.length() == 0
 					|| propertyName.equals( idName ) ) {
 				//default to id
 				property = idProperty;
 			}
 			else {
 				if ( propertyName.indexOf( idName + "." ) == 0 ) {
 					property = idProperty;
 					propertyName = propertyName.substring( idName.length() + 1 );
 				}
 				StringTokenizer st = new StringTokenizer( propertyName, ".", false );
 				while ( st.hasMoreElements() ) {
 					String element = (String) st.nextElement();
 					if ( property == null ) {
 						property = associatedClass.getProperty( element );
 					}
 					else {
 						if ( !property.isComposite() ) {
 							return null;
 						}
 						property = ( (Component) property.getValue() ).getProperty( element );
 					}
 				}
 			}
 		}
 		catch ( MappingException e ) {
 			try {
 				//if we do not find it try to check the identifier mapper
 				if ( associatedClass.getIdentifierMapper() == null ) {
 					return null;
 				}
 				StringTokenizer st = new StringTokenizer( propertyName, ".", false );
 				while ( st.hasMoreElements() ) {
 					String element = (String) st.nextElement();
 					if ( property == null ) {
 						property = associatedClass.getIdentifierMapper().getProperty( element );
 					}
 					else {
 						if ( !property.isComposite() ) {
 							return null;
 						}
 						property = ( (Component) property.getValue() ).getProperty( element );
 					}
 				}
 			}
 			catch ( MappingException ee ) {
 				return null;
 			}
 		}
 		return property;
 	}
 
 	private static ValidatorFactory getValidatorFactory(Map<Object, Object> properties) {
 		ValidatorFactory factory = null;
 		if ( properties != null ) {
 			Object unsafeProperty = properties.get( FACTORY_PROPERTY );
 			if ( unsafeProperty != null ) {
 				try {
 					factory = ValidatorFactory.class.cast( unsafeProperty );
 				}
 				catch ( ClassCastException e ) {
 					throw new IntegrationException(
 							"Property " + FACTORY_PROPERTY
 									+ " should contain an object of type " + ValidatorFactory.class.getName()
 					);
 				}
 			}
 		}
 		if ( factory == null ) {
 			try {
 				factory = Validation.buildDefaultValidatorFactory();
 			}
 			catch ( Exception e ) {
 				throw new IntegrationException( "Unable to build the default ValidatorFactory", e );
 			}
 		}
 		return factory;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java b/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
index 4781c68381..546e55ed42 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java
@@ -1,389 +1,389 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.CacheMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.Status;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PostLoadEvent;
 import org.hibernate.event.spi.PostLoadEventListener;
 import org.hibernate.event.spi.PreLoadEvent;
 import org.hibernate.event.spi.PreLoadEventListener;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
-import org.hibernate.property.BackrefPropertyAccessor;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 import org.jboss.logging.Logger;
 
 /**
  * Functionality relating to the Hibernate two-phase loading process, that may be reused by persisters
  * that do not use the Loader framework
  *
  * @author Gavin King
  */
 public final class TwoPhaseLoad {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TwoPhaseLoad.class.getName()
 	);
 
 	private TwoPhaseLoad() {
 	}
 
 	/**
 	 * Register the "hydrated" state of an entity instance, after the first step of 2-phase loading.
 	 *
 	 * Add the "hydrated state" (an array) of an uninitialized entity to the session. We don't try
 	 * to resolve any associations yet, because there might be other entities waiting to be
 	 * read from the JDBC result set we are currently processing
 	 *
 	 * @param persister The persister for the hydrated entity
 	 * @param id The entity identifier
 	 * @param values The entity values
 	 * @param rowId The rowId for the entity
 	 * @param object An optional instance for the entity being loaded
 	 * @param lockMode The lock mode
 	 * @param lazyPropertiesAreUnFetched Whether properties defined as lazy are yet un-fetched
 	 * @param session The Session
 	 */
 	public static void postHydrate(
 			final EntityPersister persister,
 			final Serializable id,
 			final Object[] values,
 			final Object rowId,
 			final Object object,
 			final LockMode lockMode,
 			final boolean lazyPropertiesAreUnFetched,
 			final SessionImplementor session) {
 		final Object version = Versioning.getVersion( values, persister );
 		session.getPersistenceContext().addEntry(
 				object,
 				Status.LOADING,
 				values,
 				rowId,
 				id,
 				version,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnFetched
 			);
 
 		if ( version != null && LOG.isTraceEnabled() ) {
 			final String versionStr = persister.isVersioned()
 					? persister.getVersionType().toLoggableString( version, session.getFactory() )
 					: "null";
 			LOG.tracef( "Version: %s", versionStr );
 		}
 	}
 
 	/**
 	 * Perform the second step of 2-phase load. Fully initialize the entity
 	 * instance.
 	 * <p/>
 	 * After processing a JDBC result set, we "resolve" all the associations
 	 * between the entities which were instantiated and had their state
 	 * "hydrated" into an array
 	 *
 	 * @param entity The entity being loaded
 	 * @param readOnly Is the entity being loaded as read-only
 	 * @param session The Session
 	 * @param preLoadEvent The (re-used) pre-load event
 	 */
 	public static void initializeEntity(
 			final Object entity,
 			final boolean readOnly,
 			final SessionImplementor session,
 			final PreLoadEvent preLoadEvent) {
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		final EntityEntry entityEntry = persistenceContext.getEntry( entity );
 		if ( entityEntry == null ) {
 			throw new AssertionFailure( "possible non-threadsafe access to the session" );
 		}
 		doInitializeEntity( entity, entityEntry, readOnly, session, preLoadEvent );
 	}
 
 	private static void doInitializeEntity(
 			final Object entity,
 			final EntityEntry entityEntry,
 			final boolean readOnly,
 			final SessionImplementor session,
 			final PreLoadEvent preLoadEvent) throws HibernateException {
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		final EntityPersister persister = entityEntry.getPersister();
 		final Serializable id = entityEntry.getId();
 		final Object[] hydratedState = entityEntry.getLoadedState();
 
 		final boolean debugEnabled = LOG.isDebugEnabled();
 		if ( debugEnabled ) {
 			LOG.debugf(
 					"Resolving associations for %s",
 					MessageHelper.infoString( persister, id, session.getFactory() )
 			);
 		}
 
 		final Type[] types = persister.getPropertyTypes();
 		for ( int i = 0; i < hydratedState.length; i++ ) {
 			final Object value = hydratedState[i];
-			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
+			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!= PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				hydratedState[i] = types[i].resolve( value, session, entity );
 			}
 		}
 
 		//Must occur after resolving identifiers!
 		if ( session.isEventSource() ) {
 			preLoadEvent.setEntity( entity ).setState( hydratedState ).setId( id ).setPersister( persister );
 
 			final EventListenerGroup<PreLoadEventListener> listenerGroup = session
 					.getFactory()
 					.getServiceRegistry()
 					.getService( EventListenerRegistry.class )
 					.getEventListenerGroup( EventType.PRE_LOAD );
 			for ( PreLoadEventListener listener : listenerGroup.listeners() ) {
 				listener.onPreLoad( preLoadEvent );
 			}
 		}
 
 		persister.setPropertyValues( entity, hydratedState );
 
 		final SessionFactoryImplementor factory = session.getFactory();
 		if ( persister.hasCache() && session.getCacheMode().isPutEnabled() ) {
 
 			if ( debugEnabled ) {
 				LOG.debugf(
 						"Adding entity to second-level cache: %s",
 						MessageHelper.infoString( persister, id, session.getFactory() )
 				);
 			}
 
 			final Object version = Versioning.getVersion( hydratedState, persister );
 			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
 			final CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
 
 			// explicit handling of caching for rows just inserted and then somehow forced to be read
 			// from the database *within the same transaction*.  usually this is done by
 			// 		1) Session#refresh, or
 			// 		2) Session#clear + some form of load
 			//
 			// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be
 			if ( session.getPersistenceContext().wasInsertedDuringTransaction( persister, id ) ) {
 				persister.getCacheAccessStrategy().update(
 						cacheKey,
 						persister.getCacheEntryStructure().structure( entry ),
 						version,
 						version
 				);
 			}
 			else {
 				try {
 					session.getEventListenerManager().cachePutStart();
 					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
 							cacheKey,
 							persister.getCacheEntryStructure().structure( entry ),
 							session.getTimestamp(),
 							version,
 							useMinimalPuts( session, entityEntry )
 					);
 
 					if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 						factory.getStatisticsImplementor().secondLevelCachePut( persister.getCacheAccessStrategy().getRegion().getName() );
 					}
 				}
 				finally {
 					session.getEventListenerManager().cachePutEnd();
 				}
 			}
 		}
 
 		if ( persister.hasNaturalIdentifier() ) {
 			persistenceContext.getNaturalIdHelper().cacheNaturalIdCrossReferenceFromLoad(
 					persister,
 					id,
 					persistenceContext.getNaturalIdHelper().extractNaturalIdValues( hydratedState, persister )
 			);
 		}
 
 		boolean isReallyReadOnly = readOnly;
 		if ( !persister.isMutable() ) {
 			isReallyReadOnly = true;
 		}
 		else {
 			final Object proxy = persistenceContext.getProxy( entityEntry.getEntityKey() );
 			if ( proxy != null ) {
 				// there is already a proxy for this impl
 				// only set the status to read-only if the proxy is read-only
 				isReallyReadOnly = ( (HibernateProxy) proxy ).getHibernateLazyInitializer().isReadOnly();
 			}
 		}
 		if ( isReallyReadOnly ) {
 			//no need to take a snapshot - this is a
 			//performance optimization, but not really
 			//important, except for entities with huge
 			//mutable property values
 			persistenceContext.setEntryStatus( entityEntry, Status.READ_ONLY );
 		}
 		else {
 			//take a snapshot
 			TypeHelper.deepCopy(
 					hydratedState,
 					persister.getPropertyTypes(),
 					persister.getPropertyUpdateability(),
 					//after setting values to object
 					hydratedState,
 					session
 			);
 			persistenceContext.setEntryStatus( entityEntry, Status.MANAGED );
 		}
 
 		persister.afterInitialize(
 				entity,
 				entityEntry.isLoadedWithLazyPropertiesUnfetched(),
 				session
 		);
 
 		if ( debugEnabled ) {
 			LOG.debugf(
 					"Done materializing entity %s",
 					MessageHelper.infoString( persister, id, session.getFactory() )
 			);
 		}
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().loadEntity( persister.getEntityName() );
 		}
 	}
 	
 	/**
 	 * PostLoad cannot occur during initializeEntity, as that call occurs *before*
 	 * the Set collections are added to the persistence context by Loader.
 	 * Without the split, LazyInitializationExceptions can occur in the Entity's
 	 * postLoad if it acts upon the collection.
 	 *
 	 * HHH-6043
 	 * 
 	 * @param entity The entity
 	 * @param session The Session
 	 * @param postLoadEvent The (re-used) post-load event
 	 */
 	public static void postLoad(
 			final Object entity,
 			final SessionImplementor session,
 			final PostLoadEvent postLoadEvent) {
 		
 		if ( session.isEventSource() ) {
 			final PersistenceContext persistenceContext
 					= session.getPersistenceContext();
 			final EntityEntry entityEntry = persistenceContext.getEntry( entity );
 
 			postLoadEvent.setEntity( entity ).setId( entityEntry.getId() ).setPersister( entityEntry.getPersister() );
 
 			final EventListenerGroup<PostLoadEventListener> listenerGroup = session.getFactory()
 							.getServiceRegistry()
 							.getService( EventListenerRegistry.class )
 							.getEventListenerGroup( EventType.POST_LOAD );
 			for ( PostLoadEventListener listener : listenerGroup.listeners() ) {
 				listener.onPostLoad( postLoadEvent );
 			}
 		}
 	}
 
 	private static boolean useMinimalPuts(SessionImplementor session, EntityEntry entityEntry) {
 		return ( session.getFactory().getSettings().isMinimalPutsEnabled()
 				&& session.getCacheMode()!=CacheMode.REFRESH )
 				|| ( entityEntry.getPersister().hasLazyProperties()
 				&& entityEntry.isLoadedWithLazyPropertiesUnfetched()
 				&& entityEntry.getPersister().isLazyPropertiesCacheable() );
 	}
 
 	/**
 	 * Add an uninitialized instance of an entity class, as a placeholder to ensure object
 	 * identity. Must be called before <tt>postHydrate()</tt>.
 	 *
 	 * Create a "temporary" entry for a newly instantiated entity. The entity is uninitialized,
 	 * but we need the mapping from id to instance in order to guarantee uniqueness.
 	 *
 	 * @param key The entity key
 	 * @param object The entity instance
 	 * @param persister The entity persister
 	 * @param lockMode The lock mode
 	 * @param lazyPropertiesAreUnFetched Are lazy properties still un-fetched?
 	 * @param session The Session
 	 */
 	public static void addUninitializedEntity(
 			final EntityKey key,
 			final Object object,
 			final EntityPersister persister,
 			final LockMode lockMode,
 			final boolean lazyPropertiesAreUnFetched,
 			final SessionImplementor session) {
 		session.getPersistenceContext().addEntity(
 				object,
 				Status.LOADING,
 				null,
 				key,
 				null,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnFetched
 		);
 	}
 
 	/**
 	 * Same as {@link #addUninitializedEntity}, but here for an entity from the second level cache
 	 *
 	 * @param key The entity key
 	 * @param object The entity instance
 	 * @param persister The entity persister
 	 * @param lockMode The lock mode
 	 * @param lazyPropertiesAreUnFetched Are lazy properties still un-fetched?
 	 * @param version The version
 	 * @param session The Session
 	 */
 	public static void addUninitializedCachedEntity(
 			final EntityKey key,
 			final Object object,
 			final EntityPersister persister,
 			final LockMode lockMode,
 			final boolean lazyPropertiesAreUnFetched,
 			final Object version,
 			final SessionImplementor session) {
 		session.getPersistenceContext().addEntity(
 				object,
 				Status.LOADING,
 				null,
 				key,
 				version,
 				lockMode,
 				true,
 				persister,
 				false,
 				lazyPropertiesAreUnFetched
 			);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/internal/UnsavedValueFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/internal/UnsavedValueFactory.java
index 1c76206b51..5eb1b8af8e 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/internal/UnsavedValueFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/internal/UnsavedValueFactory.java
@@ -1,153 +1,153 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.internal;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
 import org.hibernate.InstantiationException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.IdentifierValue;
 import org.hibernate.engine.spi.VersionValue;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.type.IdentifierType;
 import org.hibernate.type.PrimitiveType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Helper for dealing with unsaved value handling
  *
  * @author Gavin King
  */
 public class UnsavedValueFactory {
 
 	/**
 	 * Instantiate a class using the provided Constructor
 	 *
 	 * @param constructor The constructor
 	 *
 	 * @return The instantiated object
 	 *
 	 * @throws InstantiationException if something went wrong
 	 */
 	private static Object instantiate(Constructor constructor) {
 		try {
 			return constructor.newInstance();
 		}
 		catch (Exception e) {
 			throw new InstantiationException( "could not instantiate test object", constructor.getDeclaringClass(), e );
 		}
 	}
 	
 	/**
 	 * Return an IdentifierValue for the specified unsaved-value. If none is specified, 
 	 * guess the unsaved value by instantiating a test instance of the class and
 	 * reading it's id property, or if that is not possible, using the java default
 	 * value for the type
 	 *
 	 * @param unsavedValue The mapping defined unsaved value
 	 * @param identifierGetter The getter for the entity identifier attribute
 	 * @param identifierType The mapping type for the identifier
 	 * @param constructor The constructor for the entity
 	 *
 	 * @return The appropriate IdentifierValue
 	 */
 	public static IdentifierValue getUnsavedIdentifierValue(
 			String unsavedValue,
 			Getter identifierGetter,
 			Type identifierType,
 			Constructor constructor) {
 		if ( unsavedValue == null ) {
 			if ( identifierGetter != null && constructor != null ) {
 				// use the id value of a newly instantiated instance as the unsaved-value
 				final Serializable defaultValue = (Serializable) identifierGetter.get( instantiate( constructor ) );
 				return new IdentifierValue( defaultValue );
 			}
 			else if ( identifierGetter != null && (identifierType instanceof PrimitiveType) ) {
 				final Serializable defaultValue = ( (PrimitiveType) identifierType ).getDefaultValue();
 				return new IdentifierValue( defaultValue );
 			}
 			else {
 				return IdentifierValue.NULL;
 			}
 		}
 		else if ( "null".equals( unsavedValue ) ) {
 			return IdentifierValue.NULL;
 		}
 		else if ( "undefined".equals( unsavedValue ) ) {
 			return IdentifierValue.UNDEFINED;
 		}
 		else if ( "none".equals( unsavedValue ) ) {
 			return IdentifierValue.NONE;
 		}
 		else if ( "any".equals( unsavedValue ) ) {
 			return IdentifierValue.ANY;
 		}
 		else {
 			try {
 				return new IdentifierValue( (Serializable) ( (IdentifierType) identifierType ).stringToObject( unsavedValue ) );
 			}
 			catch ( ClassCastException cce ) {
 				throw new MappingException( "Bad identifier type: " + identifierType.getName() );
 			}
 			catch ( Exception e ) {
 				throw new MappingException( "Could not parse identifier unsaved-value: " + unsavedValue );
 			}
 		}
 	}
 
 	/**
 	 * Return an IdentifierValue for the specified unsaved-value. If none is specified,
 	 * guess the unsaved value by instantiating a test instance of the class and
 	 * reading it's version property value, or if that is not possible, using the java default
 	 * value for the type
 	 *
 	 * @param versionUnsavedValue The mapping defined unsaved value
 	 * @param versionGetter The version attribute getter
 	 * @param versionType The mapping type for the version
 	 * @param constructor The constructor for the entity
 	 *
 	 * @return The appropriate VersionValue
 	 */
 	public static VersionValue getUnsavedVersionValue(
 			String versionUnsavedValue, 
 			Getter versionGetter,
 			VersionType versionType,
 			Constructor constructor) {
 		
 		if ( versionUnsavedValue == null ) {
 			if ( constructor!=null ) {
 				final Object defaultValue = versionGetter.get( instantiate( constructor ) );
 				// if the version of a newly instantiated object is not the same
 				// as the version seed value, use that as the unsaved-value
 				return versionType.isEqual( versionType.seed( null ), defaultValue )
 						? VersionValue.UNDEFINED
 						: new VersionValue( defaultValue );
 			}
 			else {
 				return VersionValue.UNDEFINED;
 			}
 		}
 		else if ( "undefined".equals( versionUnsavedValue ) ) {
 			return VersionValue.UNDEFINED;
 		}
 		else if ( "null".equals( versionUnsavedValue ) ) {
 			return VersionValue.NULL;
 		}
 		else if ( "negative".equals( versionUnsavedValue ) ) {
 			return VersionValue.NEGATIVE;
 		}
 		else {
 			// this should not happen since the DTD prevents it
 			throw new MappingException( "Could not parse version unsaved-value: " + versionUnsavedValue );
 		}
 	}
 
 	private UnsavedValueFactory() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
index 66689cbcfe..fc7e3dfed4 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
@@ -1,168 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.jdbc;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ClassLoaderHelper;
+import org.hibernate.service.ServiceRegistry;
 
-import org.jboss.logging.Logger;
+import static org.hibernate.internal.CoreLogging.messageLogger;
 
 /**
  * A proxy for a ResultSet delegate, responsible for locally caching the columnName-to-columnIndex resolution that
  * has been found to be inefficient in a few vendor's drivers (i.e., Oracle and Postgres).
  *
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class ResultSetWrapperProxy implements InvocationHandler {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			ResultSetWrapperProxy.class.getName()
-	);
-	private static final Class[] PROXY_INTERFACES = new Class[] { ResultSet.class };
+	private static final CoreMessageLogger LOG = messageLogger( ResultSetWrapperProxy.class );
+
 	private static final SqlExceptionHelper SQL_EXCEPTION_HELPER = new SqlExceptionHelper();
 
 	private final ResultSet rs;
 	private final ColumnNameCache columnNameCache;
 
 	private ResultSetWrapperProxy(ResultSet rs, ColumnNameCache columnNameCache) {
 		this.rs = rs;
 		this.columnNameCache = columnNameCache;
 	}
 
 	/**
 	 * Generates a proxy wrapping the ResultSet.
 	 *
 	 * @param resultSet The resultSet to wrap.
 	 * @param columnNameCache The cache storing data for converting column names to column indexes.
+	 * @param serviceRegistry Access to any needed services
+	 *
 	 * @return The generated proxy.
 	 */
-	public static ResultSet generateProxy(ResultSet resultSet, ColumnNameCache columnNameCache) {
-		return (ResultSet) Proxy.newProxyInstance(
-				getProxyClassLoader(),
-				PROXY_INTERFACES,
-				new ResultSetWrapperProxy( resultSet, columnNameCache )
+	public static ResultSet generateProxy(
+			ResultSet resultSet,
+			ColumnNameCache columnNameCache,
+			ServiceRegistry serviceRegistry) {
+		return serviceRegistry.getService( ClassLoaderService.class ).generateProxy(
+				new ResultSetWrapperProxy( resultSet, columnNameCache ),
+				ResultSet.class
 		);
 	}
 
-	/**
-	 * Determines the appropriate class loader to which the generated proxy
-	 * should be scoped.
-	 *
-	 * @return The class loader appropriate for proxy construction.
-	 */
-	public static ClassLoader getProxyClassLoader() {
-		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
-		if ( cl == null ) {
-			cl = ResultSet.class.getClassLoader();
-		}
-		return cl;
-	}
-
 	@Override
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 		if ( "findColumn".equals( method.getName() ) ) {
 			return findColumn( (String) args[0] );
 		}
 
 		if ( isFirstArgColumnLabel( method, args ) ) {
 			try {
 				final Integer columnIndex = findColumn( (String) args[0] );
 				return invokeMethod(
 						locateCorrespondingColumnIndexMethod( method ),
 						buildColumnIndexMethodArgs( args, columnIndex )
 				);
 			}
 			catch ( SQLException ex ) {
 				final String msg = "Exception getting column index for column: [" + args[0] +
 						"].\nReverting to using: [" + args[0] +
 						"] as first argument for method: [" + method + "]";
 				SQL_EXCEPTION_HELPER.logExceptions( ex, msg );
 			}
 			catch ( NoSuchMethodException ex ) {
 				LOG.unableToSwitchToMethodUsingColumnIndex( method );
 			}
 		}
 		return invokeMethod( method, args );
 	}
 
 	/**
 	 * Locate the column index corresponding to the given column name via the cache.
 	 *
 	 * @param columnName The column name to resolve into an index.
 	 * @return The column index corresponding to the given column name.
 	 * @throws SQLException if the ResultSet object does not contain columnName or a database access error occurs
 	 */
 	private Integer findColumn(String columnName) throws SQLException {
 		return columnNameCache.getIndexForColumnName( columnName, rs );
 	}
 
 	private boolean isFirstArgColumnLabel(Method method, Object[] args) {
 		// method name should start with either get or update
 		if ( ! ( method.getName().startsWith( "get" ) || method.getName().startsWith( "update" ) ) ) {
 			return false;
 		}
 
 		// method should have arguments, and have same number as incoming arguments
 		if ( ! ( method.getParameterTypes().length > 0 && args.length == method.getParameterTypes().length ) ) {
 			return false;
 		}
 
 		// The first argument should be a String (the column name)
 		//noinspection RedundantIfStatement
 		if ( ! ( String.class.isInstance( args[0] ) && method.getParameterTypes()[0].equals( String.class ) ) ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	/**
 	 * For a given {@link ResultSet} method passed a column name, locate the corresponding method passed the same
 	 * parameters but the column index.
 	 *
 	 * @param columnNameMethod The method passed the column name
 	 * @return The corresponding method passed the column index.
 	 * @throws NoSuchMethodException Should never happen, but...
 	 */
 	private Method locateCorrespondingColumnIndexMethod(Method columnNameMethod) throws NoSuchMethodException {
 		final Class[] actualParameterTypes = new Class[columnNameMethod.getParameterTypes().length];
 		actualParameterTypes[0] = int.class;
 		System.arraycopy(
 				columnNameMethod.getParameterTypes(),
 				1,
 				actualParameterTypes,
 				1,
 				columnNameMethod.getParameterTypes().length - 1
 		);
 		return columnNameMethod.getDeclaringClass().getMethod( columnNameMethod.getName(), actualParameterTypes );
 	}
 
 	private Object[] buildColumnIndexMethodArgs(Object[] incomingArgs, Integer columnIndex) {
 		final Object[] actualArgs = new Object[incomingArgs.length];
 		actualArgs[0] = columnIndex;
 		System.arraycopy( incomingArgs, 1, actualArgs, 1, incomingArgs.length - 1 );
 		return actualArgs;
 	}
 
 	private Object invokeMethod(Method method, Object[] args) throws Throwable {
 		try {
 			return method.invoke( rs, args );
 		}
 		catch ( InvocationTargetException e ) {
 			throw e.getTargetException();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
index 0d7c61375d..91a7742954 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
@@ -1,294 +1,289 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.Driver;
 import java.sql.SQLException;
 import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A connection provider that uses the {@link java.sql.DriverManager} directly to open connections and provides
  * a very rudimentary connection pool.
  * <p/>
  * IMPL NOTE : not intended for production use!
  * <p/>
  * Thanks to Oleg Varaksin and his article on object pooling using the {@link java.util.concurrent} package, from
  * which much of the pooling code here is derived.  See http://ovaraksin.blogspot.com/2013/08/simple-and-lightweight-pool.html
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class DriverManagerConnectionProviderImpl
 		implements ConnectionProvider, Configurable, Stoppable, ServiceRegistryAwareService {
 
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( DriverManagerConnectionProviderImpl.class );
 
 	public static final String MIN_SIZE = "hibernate.connection.min_pool_size";
 	public static final String INITIAL_SIZE = "hibernate.connection.initial_pool_size";
 	// in TimeUnit.SECONDS
 	public static final String VALIDATION_INTERVAL = "hibernate.connection.pool_validation_interval";
 
 	private boolean active = true;
 
 	private ConcurrentLinkedQueue<Connection> connections = new ConcurrentLinkedQueue<Connection>();
 	private ConnectionCreator connectionCreator;
 	private ScheduledExecutorService executorService;
 
 
 
 	// create the pool ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public void configure(Map configurationValues) {
 		log.usingHibernateBuiltInConnectionPool();
 
 		connectionCreator = buildCreator( configurationValues );
 
 		final int minSize = ConfigurationHelper.getInt( MIN_SIZE, configurationValues, 1 );
 		final int maxSize = ConfigurationHelper.getInt( AvailableSettings.POOL_SIZE, configurationValues, 20 );
 		final int initialSize = ConfigurationHelper.getInt( INITIAL_SIZE, configurationValues, minSize );
 		final long validationInterval = ConfigurationHelper.getLong( VALIDATION_INTERVAL, configurationValues, 30 );
 
 		log.hibernateConnectionPoolSize( maxSize, minSize );
 
 		log.debugf( "Initializing Connection pool with %s Connections", initialSize );
 		for ( int i = 0; i < initialSize; i++ ) {
 			connections.add( connectionCreator.createConnection() );
 		}
 
 		executorService = Executors.newSingleThreadScheduledExecutor();
 		executorService.scheduleWithFixedDelay(
 				new Runnable() {
 					private boolean primed;
 					@Override
 					public void run() {
 						int size = connections.size();
 
 						if ( !primed && size >= minSize ) {
 							// IMPL NOTE : the purpose of primed is to allow the pool to lazily reach its
 							// defined min-size.
 							log.debug( "Connection pool now considered primed; min-size will be maintained" );
 							primed = true;
 						}
 
 						if ( size < minSize && primed ) {
 							int numberToBeAdded = minSize - size;
 							log.debugf( "Adding %s Connections to the pool", numberToBeAdded );
 							for (int i = 0; i < numberToBeAdded; i++) {
 								connections.add( connectionCreator.createConnection() );
 							}
 						}
 						else if ( size > maxSize ) {
 							int numberToBeRemoved = size - maxSize;
 							log.debugf( "Removing %s Connections from the pool", numberToBeRemoved );
 							for ( int i = 0; i < numberToBeRemoved; i++ ) {
 								Connection connection = connections.poll();
 								try {
 									connection.close();
 								}
 								catch (SQLException e) {
 									log.unableToCloseConnection( e );
 								}
 							}
 						}
 					}
 				},
 				validationInterval,
 				validationInterval,
 				TimeUnit.SECONDS
 		);
 	}
 
 	private ConnectionCreator buildCreator(Map configurationValues) {
 		final ConnectionCreatorBuilder connectionCreatorBuilder = new ConnectionCreatorBuilder( serviceRegistry );
 
 		final String driverClassName = (String) configurationValues.get( AvailableSettings.DRIVER );
 		connectionCreatorBuilder.setDriver( loadDriverIfPossible( driverClassName ) );
 
 		final String url = (String) configurationValues.get( AvailableSettings.URL );
 		if ( url == null ) {
 			final String msg = log.jdbcUrlNotSpecified( AvailableSettings.URL );
 			log.error( msg );
 			throw new HibernateException( msg );
 		}
 		connectionCreatorBuilder.setUrl( url );
 
 		log.usingDriver( driverClassName, url );
 
 		final Properties connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
 
 		// if debug level is enabled, then log the password, otherwise mask it
 		if ( log.isDebugEnabled() ) {
 			log.connectionProperties( connectionProps );
 		}
 		else {
 			log.connectionProperties( ConfigurationHelper.maskOut( connectionProps, "password" ) );
 		}
 		connectionCreatorBuilder.setConnectionProps( connectionProps );
 
 		final boolean autoCommit = ConfigurationHelper.getBoolean( AvailableSettings.AUTOCOMMIT, configurationValues, false );
 		log.autoCommitMode( autoCommit );
 		connectionCreatorBuilder.setAutoCommit( autoCommit );
 
 		final Integer isolation = ConfigurationHelper.getInteger( AvailableSettings.ISOLATION, configurationValues );
 		if ( isolation != null ) {
 			log.jdbcIsolationLevel( Environment.isolationLevelToString( isolation ) );
 		}
 		connectionCreatorBuilder.setIsolation( isolation );
 
 		return connectionCreatorBuilder.build();
 	}
 
 	private Driver loadDriverIfPossible(String driverClassName) {
 		if ( driverClassName == null ) {
 			log.debug( "No driver class specified" );
 			return null;
 		}
 
 		if ( serviceRegistry != null ) {
 			final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 			final Class<Driver> driverClass = classLoaderService.classForName( driverClassName );
 			try {
 				return driverClass.newInstance();
 			}
 			catch ( Exception e ) {
 				throw new ServiceException( "Specified JDBC Driver " + driverClassName + " could not be loaded", e );
 			}
 		}
 
 		try {
 			return (Driver) Class.forName( driverClassName ).newInstance();
 		}
 		catch ( Exception e1 ) {
-			try{
-				return (Driver) ReflectHelper.classForName( driverClassName ).newInstance();
-			}
-			catch ( Exception e2 ) {
-				throw new ServiceException( "Specified JDBC Driver " + driverClassName + " could not be loaded", e2 );
-			}
+			throw new ServiceException( "Specified JDBC Driver " + driverClassName + " could not be loaded", e1 );
 		}
 	}
 
 
 	// use the pool ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public Connection getConnection() throws SQLException {
 		if ( !active ) {
 			throw new HibernateException( "Connection pool is no longer active" );
 		}
 
 		Connection connection;
 		if ( (connection = connections.poll()) == null ) {
 			connection = connectionCreator.createConnection();
 		}
 
 		return connection;
 	}
 
 	@Override
 	public void closeConnection(Connection conn) throws SQLException {
 		if (conn == null) {
 			return;
 		}
 
 		this.connections.offer( conn );
 	}
 
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 
 	// destroy the pool ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public void stop() {
 		if ( !active ) {
 			return;
 		}
 
 		log.cleaningUpConnectionPool( connectionCreator.getUrl() );
 
 		active = false;
 
 		if ( executorService != null ) {
 			executorService.shutdown();
 		}
 		executorService = null;
 
 		for ( Connection connection : connections ) {
 			try {
 				connection.close();
 			}
 			catch (SQLException e) {
 				log.unableToClosePooledConnection( e );
 			}
 		}
 	}
 
 
 	//CHECKSTYLE:START_ALLOW_FINALIZER
 	@Override
 	protected void finalize() throws Throwable {
 		if ( active ) {
 			stop();
 		}
 		super.finalize();
 	}
 	//CHECKSTYLE:END_ALLOW_FINALIZER
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
index fd5aa7a0ba..f283fe2220 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
@@ -1,111 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.jdbc.internal;
 
 import java.util.Map;
 
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;
 import org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator;
 import org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.ResultSetWrapper;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard implementation of the {@link JdbcServices} contract
  *
  * @author Steve Ebersole
  */
 public class JdbcServicesImpl implements JdbcServices, ServiceRegistryAwareService, Configurable {
 	private ServiceRegistryImplementor serviceRegistry;
 	private JdbcEnvironment jdbcEnvironment;
 
 	private MultiTenancyStrategy multiTenancyStrategy;
 
 	private SqlStatementLogger sqlStatementLogger;
 
+	private ResultSetWrapperImpl resultSetWrapper;
+
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public void configure(Map configValues) {
 		this.jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
 		assert jdbcEnvironment != null : "JdbcEnvironment was not found!";
 
 		this.multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( configValues );
 
 		final boolean showSQL = ConfigurationHelper.getBoolean( Environment.SHOW_SQL, configValues, false );
 		final boolean formatSQL = ConfigurationHelper.getBoolean( Environment.FORMAT_SQL, configValues, false );
 
 		this.sqlStatementLogger =  new SqlStatementLogger( showSQL, formatSQL );
+
+		resultSetWrapper = new ResultSetWrapperImpl( serviceRegistry );
 	}
 
 	@Override
 	public JdbcEnvironment getJdbcEnvironment() {
 		return jdbcEnvironment;
 	}
 
 	@Override
 	public JdbcConnectionAccess getBootstrapJdbcConnectionAccess() {
 		return JdbcEnvironmentInitiator.buildBootstrapJdbcConnectionAccess( multiTenancyStrategy, serviceRegistry );
 	}
 
 	@Override
 	public Dialect getDialect() {
 		if ( jdbcEnvironment != null ) {
 			return jdbcEnvironment.getDialect();
 		}
 		return null;
 	}
 
 	@Override
 	public SqlStatementLogger getSqlStatementLogger() {
 		return sqlStatementLogger;
 	}
 
 	@Override
 	public SqlExceptionHelper getSqlExceptionHelper() {
 		if ( jdbcEnvironment != null ) {
 			return jdbcEnvironment.getSqlExceptionHelper();
 		}
 		return null;
 	}
 
 	@Override
 	public ExtractedDatabaseMetaData getExtractedMetaDataSupport() {
 		if ( jdbcEnvironment != null ) {
 			return jdbcEnvironment.getExtractedDatabaseMetaData();
 		}
 		return null;
 	}
 
 	@Override
 	public LobCreator getLobCreator(LobCreationContext lobCreationContext) {
 		if ( jdbcEnvironment != null ) {
 			return jdbcEnvironment.getLobCreatorBuilder().buildLobCreator( lobCreationContext );
 		}
 		return null;
 	}
 
 	@Override
 	public ResultSetWrapper getResultSetWrapper() {
-		return ResultSetWrapperImpl.INSTANCE;
+		return resultSetWrapper;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetWrapperImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetWrapperImpl.java
index 160b0afcd7..46eacc8810 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetWrapperImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetWrapperImpl.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.engine.jdbc.internal;
 
 import java.sql.ResultSet;
 
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.engine.jdbc.ColumnNameCache;
 import org.hibernate.engine.jdbc.ResultSetWrapperProxy;
 import org.hibernate.engine.jdbc.spi.ResultSetWrapper;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Standard Hibernate implementation for wrapping a {@link ResultSet} in a
  " column name cache" wrapper.
  *
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class ResultSetWrapperImpl implements ResultSetWrapper {
-	/**
-	 * Singleton access
-	 */
-	public static final ResultSetWrapper INSTANCE = new ResultSetWrapperImpl();
+	private final ServiceRegistry serviceRegistry;
 
-	private ResultSetWrapperImpl() {
+	public ResultSetWrapperImpl(ServiceRegistry serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public ResultSet wrap(ResultSet resultSet, ColumnNameCache columnNameCache) {
-		return ResultSetWrapperProxy.generateProxy( resultSet, columnNameCache );
+		return ResultSetWrapperProxy.generateProxy( resultSet, columnNameCache, serviceRegistry );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
index d87a542b78..6479b4ac2c 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
@@ -1,623 +1,631 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.ast;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.engine.query.spi.EntityGraphQueryHint;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.internal.QueryExecutionRequestException;
 import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.internal.antlr.HqlTokenTypes;
 import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 import org.hibernate.hql.internal.ast.exec.BasicExecutor;
 import org.hibernate.hql.internal.ast.exec.DeleteExecutor;
 import org.hibernate.hql.internal.ast.exec.MultiTableDeleteExecutor;
 import org.hibernate.hql.internal.ast.exec.MultiTableUpdateExecutor;
 import org.hibernate.hql.internal.ast.exec.StatementExecutor;
 import org.hibernate.hql.internal.ast.tree.AggregatedSelectExpression;
 import org.hibernate.hql.internal.ast.tree.FromElement;
 import org.hibernate.hql.internal.ast.tree.InsertStatement;
 import org.hibernate.hql.internal.ast.tree.QueryNode;
 import org.hibernate.hql.internal.ast.tree.Statement;
 import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.hql.internal.ast.util.NodeTraverser;
 import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.loader.hql.QueryLoader;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 import antlr.ANTLRException;
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 
 /**
  * A QueryTranslator that uses an Antlr-based parser.
  *
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 public class QueryTranslatorImpl implements FilterTranslator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			QueryTranslatorImpl.class.getName()
 	);
 
 	private SessionFactoryImplementor factory;
 
 	private final String queryIdentifier;
 	private String hql;
 	private boolean shallowQuery;
 	private Map tokenReplacements;
 
 	//TODO:this is only needed during compilation .. can we eliminate the instvar?
 	private Map enabledFilters;
 
 	private boolean compiled;
 	private QueryLoader queryLoader;
 	private StatementExecutor statementExecutor;
 
 	private Statement sqlAst;
 	private String sql;
 
 	private ParameterTranslations paramTranslations;
 	private List<ParameterSpecification> collectedParameterSpecifications;
 	
 	private EntityGraphQueryHint entityGraphQueryHint;
 
 
 	/**
 	 * Creates a new AST-based query translator.
 	 *
 	 * @param queryIdentifier The query-identifier (used in stats collection)
 	 * @param query The hql query to translate
 	 * @param enabledFilters Currently enabled filters
 	 * @param factory The session factory constructing this translator instance.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 			String query,
 			Map enabledFilters,
 			SessionFactoryImplementor factory) {
 		this.queryIdentifier = queryIdentifier;
 		this.hql = query;
 		this.compiled = false;
 		this.shallowQuery = false;
 		this.enabledFilters = enabledFilters;
 		this.factory = factory;
 	}
 	
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 			String query,
 			Map enabledFilters,
 			SessionFactoryImplementor factory,
 			EntityGraphQueryHint entityGraphQueryHint) {
 		this( queryIdentifier, query, enabledFilters, factory );
 		this.entityGraphQueryHint = entityGraphQueryHint;
 	}
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	@Override
 	public void compile(
 			Map replacements,
 			boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, null );
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param collectionRole the role name of the collection used as the basis for the filter.
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	@Override
 	public void compile(
 			String collectionRole,
 			Map replacements,
 			boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, collectionRole );
 	}
 
 	/**
 	 * Performs both filter and non-filter compiling.
 	 *
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @param collectionRole the role name of the collection used as the basis for the filter, NULL if this
 	 *                       is not a filter.
 	 */
 	private synchronized void doCompile(Map replacements, boolean shallow, String collectionRole) {
 		// If the query is already compiled, skip the compilation.
 		if ( compiled ) {
 			LOG.debug( "compile() : The query is already compiled, skipping..." );
 			return;
 		}
 
 		// Remember the parameters for the compilation.
 		this.tokenReplacements = replacements;
 		if ( tokenReplacements == null ) {
 			tokenReplacements = new HashMap();
 		}
 		this.shallowQuery = shallow;
 
 		try {
 			// PHASE 1 : Parse the HQL into an AST.
 			final HqlParser parser = parse( true );
 
 			// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.
 			final HqlSqlWalker w = analyze( parser, collectionRole );
 
 			sqlAst = (Statement) w.getAST();
 
 			// at some point the generate phase needs to be moved out of here,
 			// because a single object-level DML might spawn multiple SQL DML
 			// command executions.
 			//
 			// Possible to just move the sql generation for dml stuff, but for
 			// consistency-sake probably best to just move responsiblity for
 			// the generation phase completely into the delegates
 			// (QueryLoader/StatementExecutor) themselves.  Also, not sure why
 			// QueryLoader currently even has a dependency on this at all; does
 			// it need it?  Ideally like to see the walker itself given to the delegates directly...
 
 			if ( sqlAst.needsExecutor() ) {
 				statementExecutor = buildAppropriateStatementExecutor( w );
 			}
 			else {
 				// PHASE 3 : Generate the SQL.
 				generate( (QueryNode) sqlAst );
 				queryLoader = new QueryLoader( this, factory, w.getSelectClause() );
 			}
 
 			compiled = true;
 		}
 		catch ( QueryException qe ) {
 			if ( qe.getQueryString() == null ) {
 				throw qe.wrapWithQueryString( hql );
 			}
 			else {
 				throw qe;
 			}
 		}
 		catch ( RecognitionException e ) {
 			// we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
 			LOG.trace( "Converted antlr.RecognitionException", e );
 			throw QuerySyntaxException.convert( e, hql );
 		}
 		catch ( ANTLRException e ) {
 			// we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
 			LOG.trace( "Converted antlr.ANTLRException", e );
 			throw new QueryException( e.getMessage(), hql );
 		}
 
 		//only needed during compilation phase...
 		this.enabledFilters = null;
 	}
 
 	private void generate(AST sqlAst) throws QueryException, RecognitionException {
 		if ( sql == null ) {
 			final SqlGenerator gen = new SqlGenerator( factory );
 			gen.statement( sqlAst );
 			sql = gen.getSQL();
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf( "HQL: %s", hql );
 				LOG.debugf( "SQL: %s", sql );
 			}
 			gen.getParseErrorHandler().throwQueryException();
 			collectedParameterSpecifications = gen.getCollectedParameters();
 		}
 	}
 
 	private static final ASTPrinter SQL_TOKEN_PRINTER = new ASTPrinter( SqlTokenTypes.class );
 
 	private HqlSqlWalker analyze(HqlParser parser, String collectionRole) throws QueryException, RecognitionException {
 		final HqlSqlWalker w = new HqlSqlWalker( this, factory, parser, tokenReplacements, collectionRole );
 		final AST hqlAst = parser.getAST();
 
 		// Transform the tree.
 		w.statement( hqlAst );
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debug( SQL_TOKEN_PRINTER.showAsString( w.getAST(), "--- SQL AST ---" ) );
 		}
 
 		w.getParseErrorHandler().throwQueryException();
 
 		return w;
 	}
 
 	private HqlParser parse(boolean filter) throws TokenStreamException, RecognitionException {
 		// Parse the query string into an HQL AST.
 		final HqlParser parser = HqlParser.getInstance( hql );
 		parser.setFilter( filter );
 
 		LOG.debugf( "parse() - HQL: %s", hql );
 		parser.statement();
 
 		final AST hqlAst = parser.getAST();
 
-		final NodeTraverser walker = new NodeTraverser( new JavaConstantConverter() );
+		final NodeTraverser walker = new NodeTraverser( new JavaConstantConverter( factory ) );
 		walker.traverseDepthFirst( hqlAst );
 
 		showHqlAst( hqlAst );
 
 		parser.getParseErrorHandler().throwQueryException();
 		return parser;
 	}
 
 	private static final ASTPrinter HQL_TOKEN_PRINTER = new ASTPrinter( HqlTokenTypes.class );
 
 	void showHqlAst(AST hqlAst) {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debug( HQL_TOKEN_PRINTER.showAsString( hqlAst, "--- HQL AST ---" ) );
 		}
 	}
 
 	private void errorIfDML() throws HibernateException {
 		if ( sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for DML operations", hql );
 		}
 	}
 
 	private void errorIfSelect() throws HibernateException {
 		if ( !sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for select queries", hql );
 		}
 	}
 	@Override
 	public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	public Statement getSqlAST() {
 		return sqlAst;
 	}
 
 	private HqlSqlWalker getWalker() {
 		return sqlAst.getWalker();
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	@Override
 	public Type[] getReturnTypes() {
 		errorIfDML();
 		return getWalker().getReturnTypes();
 	}
 	@Override
 	public String[] getReturnAliases() {
 		errorIfDML();
 		return getWalker().getReturnAliases();
 	}
 	@Override
 	public String[][] getColumnNames() {
 		errorIfDML();
 		return getWalker().getSelectClause().getColumnNames();
 	}
 	@Override
 	public Set<Serializable> getQuerySpaces() {
 		return getWalker().getQuerySpaces();
 	}
 
 	@Override
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 
 		final QueryNode query = (QueryNode) sqlAst;
 		final boolean hasLimit = queryParameters.getRowSelection() != null && queryParameters.getRowSelection().definesLimits();
 		final boolean needsDistincting = ( query.getSelectClause().isDistinct() || hasLimit ) && containsCollectionFetches();
 
 		QueryParameters queryParametersToUse;
 		if ( hasLimit && containsCollectionFetches() ) {
 			LOG.firstOrMaxResultsSpecifiedWithCollectionFetch();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List results = queryLoader.list( session, queryParametersToUse );
 
 		if ( needsDistincting ) {
 			int includedCount = -1;
 			// NOTE : firstRow is zero-based
 			int first = !hasLimit || queryParameters.getRowSelection().getFirstRow() == null
 						? 0
 						: queryParameters.getRowSelection().getFirstRow();
 			int max = !hasLimit || queryParameters.getRowSelection().getMaxRows() == null
 						? -1
 						: queryParameters.getRowSelection().getMaxRows();
 			List tmp = new ArrayList();
 			IdentitySet distinction = new IdentitySet();
 			for ( final Object result : results ) {
 				if ( !distinction.add( result ) ) {
 					continue;
 				}
 				includedCount++;
 				if ( includedCount < first ) {
 					continue;
 				}
 				tmp.add( result );
 				// NOTE : ( max - 1 ) because first is zero-based while max is not...
 				if ( max >= 0 && ( includedCount - first ) >= ( max - 1 ) ) {
 					break;
 				}
 			}
 			results = tmp;
 		}
 
 		return results;
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	@Override
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.iterate( queryParameters, session );
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 */
 	@Override
 	public ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.scroll( queryParameters, session );
 	}
 	@Override
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		errorIfSelect();
 		return statementExecutor.execute( queryParameters, session );
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 */
 	@Override
 	public String getSQLString() {
 		return sql;
 	}
 	@Override
 	public List<String> collectSqlStrings() {
 		ArrayList<String> list = new ArrayList<String>();
 		if ( isManipulationStatement() ) {
 			String[] sqlStatements = statementExecutor.getSqlStatements();
 			Collections.addAll( list, sqlStatements );
 		}
 		else {
 			list.add( sql );
 		}
 		return list;
 	}
 
 	// -- Package local methods for the QueryLoader delegate --
 
 	public boolean isShallowQuery() {
 		return shallowQuery;
 	}
 	@Override
 	public String getQueryString() {
 		return hql;
 	}
 	@Override
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		return getWalker().getNamedParameterLocations( name );
 	}
 	@Override
 	public boolean containsCollectionFetches() {
 		errorIfDML();
 		List collectionFetches = ( (QueryNode) sqlAst ).getFromClause().getCollectionFetches();
 		return collectionFetches != null && collectionFetches.size() > 0;
 	}
 	@Override
 	public boolean isManipulationStatement() {
 		return sqlAst.needsExecutor();
 	}
 	@Override
 	public void validateScrollability() throws HibernateException {
 		// Impl Note: allows multiple collection fetches as long as the
 		// entire fecthed graph still "points back" to a single
 		// root entity for return
 
 		errorIfDML();
 
 		final QueryNode query = (QueryNode) sqlAst;
 
 		// If there are no collection fetches, then no further checks are needed
 		List collectionFetches = query.getFromClause().getCollectionFetches();
 		if ( collectionFetches.isEmpty() ) {
 			return;
 		}
 
 		// A shallow query is ok (although technically there should be no fetching here...)
 		if ( isShallowQuery() ) {
 			return;
 		}
 
 		// Otherwise, we have a non-scalar select with defined collection fetch(es).
 		// Make sure that there is only a single root entity in the return (no tuples)
 		if ( getReturnTypes().length > 1 ) {
 			throw new HibernateException( "cannot scroll with collection fetches and returned tuples" );
 		}
 
 		FromElement owner = null;
 		for ( Object o : query.getSelectClause().getFromElementsForLoad() ) {
 			// should be the first, but just to be safe...
 			final FromElement fromElement = (FromElement) o;
 			if ( fromElement.getOrigin() == null ) {
 				owner = fromElement;
 				break;
 			}
 		}
 
 		if ( owner == null ) {
 			throw new HibernateException( "unable to locate collection fetch(es) owner for scrollability checks" );
 		}
 
 		// This is not strictly true.  We actually just need to make sure that
 		// it is ordered by root-entity PK and that that order-by comes before
 		// any non-root-entity ordering...
 
 		AST primaryOrdering = query.getOrderByClause().getFirstChild();
 		if ( primaryOrdering != null ) {
 			// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)
 			String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
 			String expectedPrimaryOrderSeq = StringHelper.join(
 					", ",
 					StringHelper.qualify( owner.getTableAlias(), idColNames )
 			);
 			if (  !primaryOrdering.getText().startsWith( expectedPrimaryOrderSeq ) ) {
 				throw new HibernateException( "cannot scroll results with collection fetches which are not ordered primarily by the root entity's PK" );
 			}
 		}
 	}
 
 	private StatementExecutor buildAppropriateStatementExecutor(HqlSqlWalker walker) {
 		final Statement statement = (Statement) walker.getAST();
 		if ( walker.getStatementType() == HqlSqlTokenTypes.DELETE ) {
 			final FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			final Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				return new MultiTableDeleteExecutor( walker );
 			}
 			else {
 				return new DeleteExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.UPDATE ) {
 			final FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			final Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				// even here, if only properties mapped to the "base table" are referenced
 				// in the set and where clauses, this could be handled by the BasicDelegate.
 				// TODO : decide if it is better performance-wise to doAfterTransactionCompletion that check, or to simply use the MultiTableUpdateDelegate
 				return new MultiTableUpdateExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.INSERT ) {
 			return new BasicExecutor( walker, ( (InsertStatement) statement ).getIntoClause().getQueryable() );
 		}
 		else {
 			throw new QueryException( "Unexpected statement type" );
 		}
 	}
 	@Override
 	public ParameterTranslations getParameterTranslations() {
 		if ( paramTranslations == null ) {
 			paramTranslations = new ParameterTranslationsImpl( getWalker().getParameters() );
 		}
 		return paramTranslations;
 	}
 
 	public List<ParameterSpecification> getCollectedParameterSpecifications() {
 		return collectedParameterSpecifications;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		AggregatedSelectExpression aggregation = queryLoader.getAggregatedSelectExpression();
 		return aggregation == null ? null : aggregation.getAggregationResultType();
 	}
 
 	public static class JavaConstantConverter implements NodeTraverser.VisitationStrategy {
+		private final SessionFactoryImplementor factory;
 		private AST dotRoot;
+
+		public JavaConstantConverter(SessionFactoryImplementor factory) {
+
+			this.factory = factory;
+		}
+
 		@Override
 		public void visit(AST node) {
 			if ( dotRoot != null ) {
 				// we are already processing a dot-structure
 				if ( ASTUtil.isSubtreeChild( dotRoot, node ) ) {
 					return;
 				}
 				// we are now at a new tree level
 				dotRoot = null;
 			}
 
 			if ( node.getType() == HqlTokenTypes.DOT ) {
 				dotRoot = node;
 				handleDotStructure( dotRoot );
 			}
 		}
 		private void handleDotStructure(AST dotStructureRoot) {
 			final String expression = ASTUtil.getPathText( dotStructureRoot );
-			final Object constant = ReflectHelper.getConstantValue( expression );
+			final Object constant = ReflectHelper.getConstantValue( expression, factory.getServiceRegistry().getService( ClassLoaderService.class ) );
 			if ( constant != null ) {
 				dotStructureRoot.setFirstChild( null );
 				dotStructureRoot.setType( HqlTokenTypes.JAVA_CONSTANT );
 				dotStructureRoot.setText( expression );
 			}
 		}
 	}
 
 	public EntityGraphQueryHint getEntityGraphQueryHint() {
 		return entityGraphQueryHint;
 	}
 
 	public void setEntityGraphQueryHint(EntityGraphQueryHint entityGraphQueryHint) {
 		this.entityGraphQueryHint = entityGraphQueryHint;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
index c9b9075f98..f80921f65a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
@@ -1,239 +1,244 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.ast.tree;
 
 import java.lang.reflect.Constructor;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.QueryException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.hql.internal.ast.DetailedSemanticException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.transform.AliasToBeanConstructorResultTransformer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.transform.Transformers;
 import org.hibernate.type.PrimitiveType;
 import org.hibernate.type.Type;
 
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents a constructor (new) in a SELECT.
  *
  * @author josh
  */
 public class ConstructorNode extends SelectExpressionList implements AggregatedSelectExpression {
 	private Class resultType;
 	private Constructor constructor;
 	private Type[] constructorArgumentTypes;
 	private boolean isMap;
 	private boolean isList;
 
 	@Override
 	public ResultTransformer getResultTransformer() {
 		if ( constructor != null ) {
 			return new AliasToBeanConstructorResultTransformer( constructor );
 		}
 		else if ( isMap ) {
 			return Transformers.ALIAS_TO_ENTITY_MAP;
 		}
 		else if ( isList ) {
 			return Transformers.TO_LIST;
 		}
 		throw new QueryException( "Unable to determine proper dynamic-instantiation tranformer to use." );
 	}
 
 	private String[] aggregatedAliases;
 
 	@Override
 	public String[] getAggregatedAliases() {
 		if ( aggregatedAliases == null ) {
 			aggregatedAliases = buildAggregatedAliases();
 		}
 		return aggregatedAliases;
 	}
 
 	private String[] buildAggregatedAliases() {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		String[] aliases = new String[selectExpressions.length];
 		for ( int i = 0; i < selectExpressions.length; i++ ) {
 			String alias = selectExpressions[i].getAlias();
 			aliases[i] = alias == null ? Integer.toString( i ) : alias;
 		}
 		return aliases;
 	}
 
 	@Override
 	public void setScalarColumn(int i) throws SemanticException {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		// Invoke setScalarColumnText on each constructor argument.
 		for ( int j = 0; j < selectExpressions.length; j++ ) {
 			SelectExpression selectExpression = selectExpressions[j];
 			selectExpression.setScalarColumn( j );
 		}
 	}
 
 	@Override
 	public int getScalarColumnIndex() {
 		return -1;
 	}
 
 	@Override
 	public void setScalarColumnText(int i) throws SemanticException {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		// Invoke setScalarColumnText on each constructor argument.
 		for ( int j = 0; j < selectExpressions.length; j++ ) {
 			SelectExpression selectExpression = selectExpressions[j];
 			selectExpression.setScalarColumnText( j );
 		}
 	}
 
 	@Override
 	protected AST getFirstSelectExpression() {
 		// Collect the select expressions, skip the first child because it is the class name.
 		return getFirstChild().getNextSibling();
 	}
 
 	@Override
 	public Class getAggregationResultType() {
 		return resultType;
 	}
 
 	/**
 	 * @deprecated (tell clover to ignore this method)
 	 */
 	@Deprecated
 	@Override
 	public Type getDataType() {
 /*
 		// Return the type of the object created by the constructor.
 		AST firstChild = getFirstChild();
 		String text = firstChild.getText();
 		if ( firstChild.getType() == SqlTokenTypes.DOT ) {
 			DotNode dot = ( DotNode ) firstChild;
 			text = dot.getPath();
 		}
 		return getSessionFactoryHelper().requireEntityType( text );
 */
 		throw new UnsupportedOperationException( "getDataType() is not supported by ConstructorNode!" );
 	}
 
 	public void prepare() throws SemanticException {
 		constructorArgumentTypes = resolveConstructorArgumentTypes();
 		String path = ( (PathNode) getFirstChild() ).getPath();
 		if ( "map".equals( path.toLowerCase(Locale.ROOT) ) ) {
 			isMap = true;
 			resultType = Map.class;
 		}
 		else if ( "list".equals( path.toLowerCase(Locale.ROOT) ) ) {
 			isList = true;
 			resultType = List.class;
 		}
 		else {
 			constructor = resolveConstructor( path );
 			resultType = constructor.getDeclaringClass();
 		}
 	}
 
 	private Type[] resolveConstructorArgumentTypes() throws SemanticException {
 		SelectExpression[] argumentExpressions = collectSelectExpressions();
 		if ( argumentExpressions == null ) {
 			// return an empty Type array
 			return new Type[] {};
 		}
 
 		Type[] types = new Type[argumentExpressions.length];
 		for ( int x = 0; x < argumentExpressions.length; x++ ) {
 			types[x] = argumentExpressions[x].getDataType();
 		}
 		return types;
 	}
 
 	private Constructor resolveConstructor(String path) throws SemanticException {
 		String importedClassName = getSessionFactoryHelper().getImportedClassName( path );
 		String className = StringHelper.isEmpty( importedClassName ) ? path : importedClassName;
 		if ( className == null ) {
 			throw new SemanticException( "Unable to locate class [" + path + "]" );
 		}
 		try {
-			Class holderClass = ReflectHelper.classForName( className );
+			final Class holderClass = getSessionFactoryHelper().getFactory()
+					.getServiceRegistry()
+					.getService( ClassLoaderService.class )
+					.classForName( className );
 			return ReflectHelper.getConstructor( holderClass, constructorArgumentTypes );
 		}
-		catch (ClassNotFoundException e) {
+		catch (ClassLoadingException e) {
 			throw new DetailedSemanticException( "Unable to locate class [" + className + "]", e );
 		}
 		catch (PropertyNotFoundException e) {
 			// this is the exception returned by ReflectHelper.getConstructor() if it cannot
 			// locate an appropriate constructor
 			throw new DetailedSemanticException( formatMissingContructorExceptionMessage( className ), e );
 		}
 	}
 
 	// HHH-8068 -- provide a more helpful message
 	private String formatMissingContructorExceptionMessage(String className) {
 		String[] params = new String[constructorArgumentTypes.length];
 		for ( int j = 0; j < constructorArgumentTypes.length; j++ ) {
 			params[j] = constructorArgumentTypes[j] instanceof PrimitiveType
 					? ( (PrimitiveType) constructorArgumentTypes[j] ).getPrimitiveClass().getName()
 					: constructorArgumentTypes[j].getReturnedClass().getName();
 		}
 		String formattedList = params.length == 0 ? "no arguments constructor" : StringHelper.join( ", ", params );
 		return String.format(
 				"Unable to locate appropriate constructor on class [%s]. Expected arguments are: %s",
 				className, formattedList
 		);
 	}
 
 	public Constructor getConstructor() {
 		return constructor;
 	}
 
 	public List getConstructorArgumentTypeList() {
 		return Arrays.asList( constructorArgumentTypes );
 	}
 
 	@Override
 	public List getAggregatedSelectionTypeList() {
 		return getConstructorArgumentTypeList();
 	}
 
 	@Override
 	public FromElement getFromElement() {
 		return null;
 	}
 
 	@Override
 	public boolean isConstructor() {
 		return true;
 	}
 
 	@Override
 	public boolean isReturnableEntity() throws SemanticException {
 		return false;
 	}
 
 	@Override
 	public boolean isScalar() {
 		// Constructors are always considered scalar results.
 		return true;
 	}
 
 	@Override
 	public void setAlias(String alias) {
 		throw new UnsupportedOperationException( "constructor may not be aliased" );
 	}
 
 	@Override
 	public String getAlias() {
 		throw new UnsupportedOperationException( "constructor may not be aliased" );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
index c9f632cc6e..a9613b235b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
@@ -1,114 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.ast.tree;
 
 import java.util.Locale;
 
 import org.hibernate.QueryException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 import org.hibernate.type.descriptor.converter.AttributeConverterTypeAdapter;
 
 /**
  * A node representing a static Java constant.
  *
  * @author Steve Ebersole
  */
 public class JavaConstantNode extends Node implements ExpectedTypeAwareNode, SessionFactoryAwareNode {
 	private SessionFactoryImplementor factory;
 
 	private String constantExpression;
 	private Object constantValue;
 	private Type heuristicType;
 
 	private Type expectedType;
 
 	@Override
 	public void setText(String s) {
 		// for some reason the antlr.CommonAST initialization routines force
 		// this method to get called twice.  The first time with an empty string
 		if ( StringHelper.isNotEmpty( s ) ) {
 			constantExpression = s;
-			constantValue = ReflectHelper.getConstantValue( s );
+			constantValue = ReflectHelper.getConstantValue( s, factory.getServiceRegistry().getService( ClassLoaderService.class ) );
 			heuristicType = factory.getTypeResolver().heuristicType( constantValue.getClass().getName() );
 			super.setText( s );
 		}
 	}
 
 	@Override
 	public void setExpectedType(Type expectedType) {
 		this.expectedType = expectedType;
 	}
 
 	@Override
 	public Type getExpectedType() {
 		return expectedType;
 	}
 
 	@Override
 	public void setSessionFactory(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		final Type type = expectedType == null
 				? heuristicType
 				: Number.class.isAssignableFrom( heuristicType.getReturnedClass() )
 				? heuristicType
 				: expectedType;
 		try {
 			if ( LiteralType.class.isInstance( type ) ) {
 				final LiteralType literalType = (LiteralType) type;
 				final Dialect dialect = factory.getDialect();
 				return literalType.objectToSQLString( constantValue, dialect );
 			}
 			else if ( AttributeConverterTypeAdapter.class.isInstance( type ) ) {
 				final AttributeConverterTypeAdapter converterType = (AttributeConverterTypeAdapter) type;
 				if ( !converterType.getModelType().isInstance( constantValue ) ) {
 					throw new QueryException(
 							String.format(
 									Locale.ENGLISH,
 									"Recognized query constant expression [%s] was not resolved to type [%s] expected by defined AttributeConverter [%s]",
 									constantExpression,
 									constantValue.getClass().getName(),
 									converterType.getModelType().getName()
 							)
 					);
 				}
 				final Object value = converterType.getAttributeConverter().convertToDatabaseColumn( constantValue );
 				if ( String.class.equals( converterType.getJdbcType() ) ) {
 					return "'" + value + "'";
 				}
 				else {
 					return value.toString();
 				}
 			}
 			else {
 				throw new QueryException(
 						String.format(
 								Locale.ENGLISH,
 								"Unrecognized Hibernate Type for handling query constant (%s); expecting LiteralType implementation or AttributeConverter",
 								constantExpression
 						)
 				);
 			}
 		}
 		catch (QueryException e) {
 			throw e;
 		}
 		catch (Exception t) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + constantExpression, t );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
index 8fadc68b60..4418415f38 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
@@ -1,348 +1,349 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.ast.util;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.text.DecimalFormat;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 import org.hibernate.hql.internal.ast.HqlSqlWalker;
 import org.hibernate.hql.internal.ast.InvalidPathException;
 import org.hibernate.hql.internal.ast.tree.DotNode;
 import org.hibernate.hql.internal.ast.tree.FromClause;
 import org.hibernate.hql.internal.ast.tree.IdentNode;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InFragment;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 import antlr.SemanticException;
 import antlr.collections.AST;
 import java.util.Locale;
 
 /**
  * A delegate that handles literals and constants for HqlSqlWalker, performing the token replacement functions and
  * classifying literals.
  *
  * @author josh
  */
 public class LiteralProcessor implements HqlSqlTokenTypes {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			LiteralProcessor.class.getName()
 	);
 
 	/**
 	 * In what format should Float and Double literal values be sent to the database?
 	 */
 	public static DecimalLiteralFormat DECIMAL_LITERAL_FORMAT = DecimalLiteralFormat.EXACT;
 
 	private HqlSqlWalker walker;
 
 	public LiteralProcessor(HqlSqlWalker hqlSqlWalker) {
 		this.walker = hqlSqlWalker;
 	}
 
 	public boolean isAlias(String alias) {
 		FromClause from = walker.getCurrentFromClause();
 		while ( from.isSubQuery() ) {
 			if ( from.containsClassAlias( alias ) ) {
 				return true;
 			}
 			from = from.getParentFromClause();
 		}
 		return from.containsClassAlias( alias );
 	}
 
 	public void processConstant(AST constant, boolean resolveIdent) throws SemanticException {
 		// If the constant is an IDENT, figure out what it means...
 		boolean isIdent = ( constant.getType() == IDENT || constant.getType() == WEIRD_IDENT );
 		if ( resolveIdent && isIdent && isAlias( constant.getText() ) ) {
 			// IDENT is a class alias in the FROM.
 			IdentNode ident = (IdentNode) constant;
 			// Resolve to an identity column.
 			ident.resolve( false, true );
 		}
 		else {
 			// IDENT might be the name of a class.
 			Queryable queryable = walker.getSessionFactoryHelper().findQueryableUsingImports( constant.getText() );
 			if ( isIdent && queryable != null ) {
 				constant.setText( queryable.getDiscriminatorSQLValue() );
 			}
 			// Otherwise, it's a literal.
 			else {
 				processLiteral( constant );
 			}
 		}
 	}
 
 	public void lookupConstant(DotNode node) throws SemanticException {
 		String text = ASTUtil.getPathText( node );
 		Queryable persister = walker.getSessionFactoryHelper().findQueryableUsingImports( text );
 		if ( persister != null ) {
 			// the name of an entity class
 			final String discrim = persister.getDiscriminatorSQLValue();
 			node.setDataType( persister.getDiscriminatorType() );
 			if ( InFragment.NULL.equals( discrim ) || InFragment.NOT_NULL.equals( discrim ) ) {
 				throw new InvalidPathException(
 						"subclass test not allowed for null or not null discriminator: '" + text + "'"
 				);
 			}
 			// the class discriminator value
 			setSQLValue( node, text, discrim );
 		}
 		else {
-			Object value = ReflectHelper.getConstantValue( text );
+			Object value = ReflectHelper.getConstantValue( text, walker.getSessionFactoryHelper().getFactory().getServiceRegistry().getService( ClassLoaderService.class ) );
 			if ( value == null ) {
 				throw new InvalidPathException( "Invalid path: '" + text + "'" );
 			}
 			setConstantValue( node, text, value );
 		}
 	}
 
 	private void setSQLValue(DotNode node, String text, String value) {
 		LOG.debugf( "setSQLValue() %s -> %s", text, value );
 		// Chop off the rest of the tree.
 		node.setFirstChild( null );
 		node.setType( SqlTokenTypes.SQL_TOKEN );
 		node.setText( value );
 		node.setResolvedConstant( text );
 	}
 
 	private void setConstantValue(DotNode node, String text, Object value) {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "setConstantValue() %s -> %s %s", text, value, value.getClass().getName() );
 		}
 		// Chop off the rest of the tree.
 		node.setFirstChild( null );
 		if ( value instanceof String ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Character ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Byte ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Short ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Integer ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Long ) {
 			node.setType( SqlTokenTypes.NUM_LONG );
 		}
 		else if ( value instanceof Double ) {
 			node.setType( SqlTokenTypes.NUM_DOUBLE );
 		}
 		else if ( value instanceof Float ) {
 			node.setType( SqlTokenTypes.NUM_FLOAT );
 		}
 		else {
 			node.setType( SqlTokenTypes.CONSTANT );
 		}
 		Type type;
 		try {
 			type = walker.getSessionFactoryHelper().getFactory().getTypeResolver().heuristicType(
 					value.getClass().getName()
 			);
 		}
 		catch (MappingException me) {
 			throw new QueryException( me );
 		}
 		if ( type == null ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_DETERMINE_TYPE + node.getText() );
 		}
 		try {
 			LiteralType literalType = (LiteralType) type;
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			//noinspection unchecked
 			node.setText( literalType.objectToSQLString( value, dialect ) );
 		}
 		catch (Exception e) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + node.getText(), e );
 		}
 		node.setDataType( type );
 		node.setResolvedConstant( text );
 	}
 
 	public void processBoolean(AST constant) {
 		// TODO: something much better - look at the type of the other expression!
 		// TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.
 		String replacement = (String) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
 			constant.setText( replacement );
 		}
 		else {
 			boolean bool = "true".equals( constant.getText().toLowerCase(Locale.ROOT) );
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			constant.setText( dialect.toBooleanValueString( bool ) );
 		}
 	}
 
 	private void processLiteral(AST constant) {
 		String replacement = (String) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf( "processConstant() : Replacing '%s' with '%s'", constant.getText(), replacement );
 			}
 			constant.setText( replacement );
 		}
 	}
 
 	public void processNumeric(AST literal) {
 		if ( literal.getType() == NUM_INT
 				|| literal.getType() == NUM_LONG
 				|| literal.getType() == NUM_BIG_INTEGER ) {
 			literal.setText( determineIntegerRepresentation( literal.getText(), literal.getType() ) );
 		}
 		else if ( literal.getType() == NUM_FLOAT
 				|| literal.getType() == NUM_DOUBLE
 				|| literal.getType() == NUM_BIG_DECIMAL ) {
 			literal.setText( determineDecimalRepresentation( literal.getText(), literal.getType() ) );
 		}
 		else {
 			LOG.unexpectedLiteralTokenType( literal.getType() );
 		}
 	}
 
 	private String determineIntegerRepresentation(String text, int type) {
 		try {
 			if ( type == NUM_BIG_INTEGER ) {
 				String literalValue = text;
 				if ( literalValue.endsWith( "bi" ) || literalValue.endsWith( "BI" ) ) {
 					literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 				}
 				return new BigInteger( literalValue ).toString();
 			}
 			if ( type == NUM_INT ) {
 				try {
 					return Integer.valueOf( text ).toString();
 				}
 				catch (NumberFormatException e) {
 					LOG.tracev(
 							"Could not format incoming text [{0}] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG",
 							text
 					);
 				}
 			}
 			String literalValue = text;
 			if ( literalValue.endsWith( "l" ) || literalValue.endsWith( "L" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 			return Long.valueOf( literalValue ).toString();
 		}
 		catch (Throwable t) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as integer", t );
 		}
 	}
 
 	public String determineDecimalRepresentation(String text, int type) {
 		String literalValue = text;
 		if ( type == NUM_FLOAT ) {
 			if ( literalValue.endsWith( "f" ) || literalValue.endsWith( "F" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_DOUBLE ) {
 			if ( literalValue.endsWith( "d" ) || literalValue.endsWith( "D" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_BIG_DECIMAL ) {
 			if ( literalValue.endsWith( "bd" ) || literalValue.endsWith( "BD" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 			}
 		}
 
 		final BigDecimal number;
 		try {
 			number = new BigDecimal( literalValue );
 		}
 		catch (Throwable t) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as big-decimal", t );
 		}
 
 		return DECIMAL_LITERAL_FORMAT.getFormatter().format( number );
 	}
 
 
 	private static interface DecimalFormatter {
 		String format(BigDecimal number);
 	}
 
 	private static class ExactDecimalFormatter implements DecimalFormatter {
 		public static final ExactDecimalFormatter INSTANCE = new ExactDecimalFormatter();
 
 		public String format(BigDecimal number) {
 			return number.toString();
 		}
 	}
 
 	private static class ApproximateDecimalFormatter implements DecimalFormatter {
 		public static final ApproximateDecimalFormatter INSTANCE = new ApproximateDecimalFormatter();
 
 		private static final String FORMAT_STRING = "#0.0E0";
 
 		public String format(BigDecimal number) {
 			try {
 				// TODO : what amount of significant digits need to be supported here?
 				//      - from the DecimalFormat docs:
 				//          [significant digits] = [minimum integer digits] + [maximum fraction digits]
 				DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );
 				jdkFormatter.setMinimumIntegerDigits( 1 );
 				jdkFormatter.setMaximumFractionDigits( Integer.MAX_VALUE );
 				return jdkFormatter.format( number );
 			}
 			catch (Throwable t) {
 				throw new HibernateException(
 						"Unable to format decimal literal in approximate format [" + number.toString() + "]",
 						t
 				);
 			}
 		}
 	}
 
 	public static enum DecimalLiteralFormat {
 		/**
 		 * Indicates that Float and Double literal values should
 		 * be treated using the SQL "exact" format (i.e., '.001')
 		 */
 		EXACT {
 			@Override
 			public DecimalFormatter getFormatter() {
 				return ExactDecimalFormatter.INSTANCE;
 			}
 		},
 		/**
 		 * Indicates that Float and Double literal values should
 		 * be treated using the SQL "approximate" format (i.e., '1E-3')
 		 */
 		@SuppressWarnings({"UnusedDeclaration"})
 		APPROXIMATE {
 			@Override
 			public DecimalFormatter getFormatter() {
 				return ApproximateDecimalFormatter.INSTANCE;
 			}
 		};
 
 		public abstract DecimalFormatter getFormatter();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
index ad97e2ed1b..87dc1d6bee 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
@@ -1,248 +1,251 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.classic;
 
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 
 import org.hibernate.QueryException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.hql.internal.QuerySplitter;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Parsers the select clause of a Hibernate query.
  *
  * @author Gavin King, David Channon
  */
 public class SelectParser implements Parser {
 
 	//TODO: arithmetic expressions, multiple new Foo(...)
 
 	private static final Set<String> COUNT_MODIFIERS = new HashSet<String>();
 
 	static {
 		COUNT_MODIFIERS.add( "distinct" );
 		COUNT_MODIFIERS.add( "all" );
 		COUNT_MODIFIERS.add( "*" );
 	}
 
 	private LinkedList<String> aggregateFuncTokenList = new LinkedList<String>();
 
 	private boolean ready;
 	private boolean aggregate;
 	private boolean first;
 	private boolean afterNew;
 	private boolean insideNew;
 	private boolean aggregateAddSelectScalar;
 	private Class holderClass;
 
 	private final SelectPathExpressionParser pathExpressionParser;
 	private final PathExpressionParser aggregatePathExpressionParser;
 
 	{
 		pathExpressionParser = new SelectPathExpressionParser();
 		aggregatePathExpressionParser = new PathExpressionParser();
 		//TODO: would be nice to use false, but issues with MS SQL
 		pathExpressionParser.setUseThetaStyleJoin( true );
 		aggregatePathExpressionParser.setUseThetaStyleJoin( true );
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 		String lctoken = token.toLowerCase(Locale.ROOT);
 
 		if ( first ) {
 			first = false;
 			if ( "distinct".equals( lctoken ) ) {
 				q.setDistinct( true );
 				return;
 			}
 			else if ( "all".equals( lctoken ) ) {
 				q.setDistinct( false );
 				return;
 			}
 		}
 
 		if ( afterNew ) {
 			afterNew = false;
 			try {
-				holderClass = ReflectHelper.classForName( QuerySplitter.getImportedClass( token, q.getFactory() ) );
+				holderClass = q.getFactory().getServiceRegistry()
+						.getService( ClassLoaderService.class )
+						.classForName( QuerySplitter.getImportedClass( token, q.getFactory() ) );
 			}
-			catch ( ClassNotFoundException cnfe ) {
-				throw new QueryException( cnfe );
+			catch ( ClassLoadingException e ) {
+				throw new QueryException( e );
 			}
 			if ( holderClass == null ) {
 				throw new QueryException( "class not found: " + token );
 			}
 			q.setHolderClass( holderClass );
 			insideNew = true;
 		}
 		else if ( token.equals( "," ) ) {
 			if ( !aggregate && ready ) {
 				throw new QueryException( "alias or expression expected in SELECT" );
 			}
 			q.appendScalarSelectToken( ", " );
 			ready = true;
 		}
 		else if ( "new".equals( lctoken ) ) {
 			afterNew = true;
 			ready = false;
 		}
 		else if ( "(".equals( token ) ) {
 			if ( insideNew && !aggregate && !ready ) {
 				//opening paren in new Foo ( ... )
 				ready = true;
 			}
 			else if ( aggregate ) {
 				q.appendScalarSelectToken( token );
 			}
 			else {
 				throw new QueryException( "aggregate function expected before ( in SELECT" );
 			}
 			ready = true;
 		}
 		else if ( ")".equals( token ) ) {
 			if ( insideNew && !aggregate && !ready ) {
 				//if we are inside a new Result(), but not inside a nested function
 				insideNew = false;
 			}
 			else if ( aggregate && ready ) {
 				q.appendScalarSelectToken( token );
 				aggregateFuncTokenList.removeLast();
 				if ( aggregateFuncTokenList.size() < 1 ) {
 					aggregate = false;
 					ready = false;
 				}
 			}
 			else {
 				throw new QueryException( "( expected before ) in select" );
 			}
 		}
 		else if ( COUNT_MODIFIERS.contains( lctoken ) ) {
 			if ( !ready || !aggregate ) {
 				throw new QueryException( token + " only allowed inside aggregate function in SELECT" );
 			}
 			q.appendScalarSelectToken( token );
 			if ( "*".equals( token ) ) {
 				// special case
 				q.addSelectScalar( getFunction( "count", q ).getReturnType( StandardBasicTypes.LONG, q.getFactory() ) );
 			}
 		}
 		else if ( getFunction( lctoken, q ) != null && token.equals( q.unalias( token ) ) ) {
 			// the name of an SQL function
 			if ( !ready ) {
 				throw new QueryException( ", expected before aggregate function in SELECT: " + token );
 			}
 			aggregate = true;
 			aggregateAddSelectScalar = true;
 			aggregateFuncTokenList.add( lctoken );
 			ready = false;
 			q.appendScalarSelectToken( token );
 			if ( !aggregateHasArgs( lctoken, q ) ) {
 				q.addSelectScalar( aggregateType( aggregateFuncTokenList, null, q ) );
 				if ( !aggregateFuncNoArgsHasParenthesis( lctoken, q ) ) {
 					aggregateFuncTokenList.removeLast();
 					if ( aggregateFuncTokenList.size() < 1 ) {
 						aggregate = false;
 						ready = false;
 					}
 					else {
 						ready = true;
 					}
 				}
 			}
 		}
 		else if ( aggregate ) {
 			boolean constantToken = false;
 			if ( !ready ) {
 				throw new QueryException( "( expected after aggregate function in SELECT" );
 			}
 			try {
 				ParserHelper.parse( aggregatePathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			}
 			catch ( QueryException qex ) {
 				constantToken = true;
 			}
 
 			if ( constantToken ) {
 				q.appendScalarSelectToken( token );
 			}
 			else {
 				if ( aggregatePathExpressionParser.isCollectionValued() ) {
 					q.addCollection( aggregatePathExpressionParser.getCollectionName(),
 							aggregatePathExpressionParser.getCollectionRole() );
 				}
 				q.appendScalarSelectToken( aggregatePathExpressionParser.getWhereColumn() );
 				if ( aggregateAddSelectScalar ) {
 					q.addSelectScalar( aggregateType( aggregateFuncTokenList, aggregatePathExpressionParser.getWhereColumnType(), q ) );
 					aggregateAddSelectScalar = false;
 				}
 				aggregatePathExpressionParser.addAssociation( q );
 			}
 		}
 		else {
 			if ( !ready ) {
 				throw new QueryException( ", expected in SELECT" );
 			}
 			ParserHelper.parse( pathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			if ( pathExpressionParser.isCollectionValued() ) {
 				q.addCollection( pathExpressionParser.getCollectionName(),
 						pathExpressionParser.getCollectionRole() );
 			}
 			else if ( pathExpressionParser.getWhereColumnType().isEntityType() ) {
 				q.addSelectClass( pathExpressionParser.getSelectName() );
 			}
 			q.appendScalarSelectTokens( pathExpressionParser.getWhereColumns() );
 			q.addSelectScalar( pathExpressionParser.getWhereColumnType() );
 			pathExpressionParser.addAssociation( q );
 
 			ready = false;
 		}
 	}
 
 	public boolean aggregateHasArgs(String funcToken, QueryTranslatorImpl q) {
 		return getFunction( funcToken, q ).hasArguments();
 	}
 
 	public boolean aggregateFuncNoArgsHasParenthesis(String funcToken, QueryTranslatorImpl q) {
 		return getFunction( funcToken, q ).hasParenthesesIfNoArguments();
 	}
 
 	public Type aggregateType(List funcTokenList, Type type, QueryTranslatorImpl q) throws QueryException {
 		Type retType = type;
 		Type argType;
 		for ( int i = funcTokenList.size() - 1; i >= 0; i-- ) {
 			argType = retType;
 			String funcToken = ( String ) funcTokenList.get( i );
 			retType = getFunction( funcToken, q ).getReturnType( argType, q.getFactory() );
 		}
 		return retType;
 	}
 
 	private SQLFunction getFunction(String name, QueryTranslatorImpl q) {
 		return q.getFactory().getSqlFunctionRegistry().findSQLFunction( name );
 	}
 
 	public void start(QueryTranslatorImpl q) {
 		ready = true;
 		first = true;
 		aggregate = false;
 		afterNew = false;
 		insideNew = false;
 		holderClass = null;
 		aggregateFuncTokenList.clear();
 	}
 
 	public void end(QueryTranslatorImpl q) {
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
index bee8518a36..1b09019838 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
@@ -1,514 +1,515 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.hql.internal.classic;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InFragment;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 
 /**
  * Parses the where clause of a hibernate query and translates it to an
  * SQL where clause.
  */
 
 // We should reengineer this class so that, rather than the current ad -
 // hoc linear approach to processing a stream of tokens, we instead
 // build up a tree of expressions.
 
 // We would probably refactor to have LogicParser (builds a tree of simple
 // expressions connected by and, or, not), ExpressionParser (translates
 // from OO terms like foo, foo.Bar, foo.Bar.Baz to SQL terms like
 // FOOS.ID, FOOS.BAR_ID, etc) and PathExpressionParser (which does much
 // the same thing it does now)
 
 public class WhereParser implements Parser {
 
 	private final PathExpressionParser pathExpressionParser;
 
 	{
 		pathExpressionParser = new PathExpressionParser();
 		pathExpressionParser.setUseThetaStyleJoin( true ); //Need this, since join condition can appear inside parens!
 	}
 
 	private static final Set<String> EXPRESSION_TERMINATORS = new HashSet<String>();   //tokens that close a sub expression
 	private static final Set<String> EXPRESSION_OPENERS = new HashSet<String>();       //tokens that open a sub expression
 	private static final Set<String> BOOLEAN_OPERATORS = new HashSet<String>();        //tokens that would indicate a sub expression is a boolean expression
 	private static final Map<String,String> NEGATIONS = new HashMap<String,String>();
 
 	static {
 		EXPRESSION_TERMINATORS.add( "and" );
 		EXPRESSION_TERMINATORS.add( "or" );
 		EXPRESSION_TERMINATORS.add( ")" );
 		//expressionTerminators.add(","); // deliberately excluded
 
 		EXPRESSION_OPENERS.add( "and" );
 		EXPRESSION_OPENERS.add( "or" );
 		EXPRESSION_OPENERS.add( "(" );
 		//expressionOpeners.add(","); // deliberately excluded
 
 		BOOLEAN_OPERATORS.add( "<" );
 		BOOLEAN_OPERATORS.add( "=" );
 		BOOLEAN_OPERATORS.add( ">" );
 		BOOLEAN_OPERATORS.add( "#" );
 		BOOLEAN_OPERATORS.add( "~" );
 		BOOLEAN_OPERATORS.add( "like" );
 		BOOLEAN_OPERATORS.add( "ilike" );
 		BOOLEAN_OPERATORS.add( "regexp" );
 		BOOLEAN_OPERATORS.add( "rlike" );
 		BOOLEAN_OPERATORS.add( "is" );
 		BOOLEAN_OPERATORS.add( "in" );
 		BOOLEAN_OPERATORS.add( "any" );
 		BOOLEAN_OPERATORS.add( "some" );
 		BOOLEAN_OPERATORS.add( "all" );
 		BOOLEAN_OPERATORS.add( "exists" );
 		BOOLEAN_OPERATORS.add( "between" );
 		BOOLEAN_OPERATORS.add( "<=" );
 		BOOLEAN_OPERATORS.add( ">=" );
 		BOOLEAN_OPERATORS.add( "=>" );
 		BOOLEAN_OPERATORS.add( "=<" );
 		BOOLEAN_OPERATORS.add( "!=" );
 		BOOLEAN_OPERATORS.add( "<>" );
 		BOOLEAN_OPERATORS.add( "!#" );
 		BOOLEAN_OPERATORS.add( "!~" );
 		BOOLEAN_OPERATORS.add( "!<" );
 		BOOLEAN_OPERATORS.add( "!>" );
 		BOOLEAN_OPERATORS.add( "is not" );
 		BOOLEAN_OPERATORS.add( "not like" );
 		BOOLEAN_OPERATORS.add( "not ilike" );
 		BOOLEAN_OPERATORS.add( "not regexp" );
 		BOOLEAN_OPERATORS.add( "not rlike" );
 		BOOLEAN_OPERATORS.add( "not in" );
 		BOOLEAN_OPERATORS.add( "not between" );
 		BOOLEAN_OPERATORS.add( "not exists" );
 
 		NEGATIONS.put( "and", "or" );
 		NEGATIONS.put( "or", "and" );
 		NEGATIONS.put( "<", ">=" );
 		NEGATIONS.put( "=", "<>" );
 		NEGATIONS.put( ">", "<=" );
 		NEGATIONS.put( "#", "!#" );
 		NEGATIONS.put( "~", "!~" );
 		NEGATIONS.put( "like", "not like" );
 		NEGATIONS.put( "ilike", "not ilike" );
 		NEGATIONS.put( "regexp", "not regexp" );
 		NEGATIONS.put( "rlike", "not rlike" );
 		NEGATIONS.put( "is", "is not" );
 		NEGATIONS.put( "in", "not in" );
 		NEGATIONS.put( "exists", "not exists" );
 		NEGATIONS.put( "between", "not between" );
 		NEGATIONS.put( "<=", ">" );
 		NEGATIONS.put( ">=", "<" );
 		NEGATIONS.put( "=>", "<" );
 		NEGATIONS.put( "=<", ">" );
 		NEGATIONS.put( "!=", "=" );
 		NEGATIONS.put( "<>", "=" );
 		NEGATIONS.put( "!#", "#" );
 		NEGATIONS.put( "!~", "~" );
 		NEGATIONS.put( "!<", "<" );
 		NEGATIONS.put( "!>", ">" );
 		NEGATIONS.put( "is not", "is" );
 		NEGATIONS.put( "not like", "like" );
 		NEGATIONS.put( "not ilike", "ilike" );
 		NEGATIONS.put( "not regexp", "regexp" );
 		NEGATIONS.put( "not rlike", "rlike" );
 		NEGATIONS.put( "not in", "in" );
 		NEGATIONS.put( "not between", "between" );
 		NEGATIONS.put( "not exists", "exists" );
 
 	}
 	// Handles things like:
 	// a and b or c
 	// a and ( b or c )
 	// not a and not b
 	// not ( a and b )
 	// x between y and z            (overloaded "and")
 	// x in ( a, b, c )             (overloaded brackets)
 	// not not a
 	// a is not null                (overloaded "not")
 	// etc......
 	// and expressions like
 	// foo = bar                    (maps to: foo.id = bar.id)
 	// foo.Bar = 'foo'              (maps to: foo.bar = 'foo')
 	// foo.Bar.Baz = 1.0            (maps to: foo.bar = bar.id and bar.baz = 1.0)
 	// 1.0 = foo.Bar.Baz            (maps to: bar.baz = 1.0 and foo.Bar = bar.id)
 	// foo.Bar.Baz = a.B.C          (maps to: bar.Baz = b.C and foo.Bar = bar.id and a.B = b.id)
 	// foo.Bar.Baz + a.B.C          (maps to: bar.Baz + b.C and foo.Bar = bar.id and a.B = b.id)
 	// ( foo.Bar.Baz + 1.0 ) < 2.0  (maps to: ( bar.Baz + 1.0 ) < 2.0 and foo.Bar = bar.id)
 
 	private boolean betweenSpecialCase;       //Inside a BETWEEN ... AND ... expression
 	private boolean negated;
 
 	private boolean inSubselect;
 	private int bracketsSinceSelect;
 	private StringBuilder subselect;
 
 	private boolean expectingPathContinuation;
 	private int expectingIndex;
 
 	// The following variables are stacks that keep information about each subexpression
 	// in the list of nested subexpressions we are currently processing.
 
 	private LinkedList<Boolean> nots = new LinkedList<Boolean>();           //were an odd or even number of NOTs encountered
 	private LinkedList<StringBuilder> joins = new LinkedList<StringBuilder>();          //the join string built up by compound paths inside this expression
 	private LinkedList<Boolean> booleanTests = new LinkedList<Boolean>();   //a flag indicating if the subexpression is known to be boolean
 
 	private String getElementName(PathExpressionParser.CollectionElement element, QueryTranslatorImpl q) throws QueryException {
 		String name;
 		if ( element.isOneToMany ) {
 			name = element.alias;
 		}
 		else {
 			Type type = element.elementType;
 			if ( type.isEntityType() ) { //ie. a many-to-many
 				String entityName = ( ( EntityType ) type ).getAssociatedEntityName();
 				name = pathExpressionParser.continueFromManyToMany( entityName, element.elementColumns, q );
 			}
 			else {
 				throw new QueryException( "illegally dereferenced collection element" );
 			}
 		}
 		return name;
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 		String lcToken = token.toLowerCase(Locale.ROOT);
 
 		//Cope with [,]
 		if ( token.equals( "[" ) && !expectingPathContinuation ) {
 			expectingPathContinuation = false;
 			if ( expectingIndex == 0 ) {
 				throw new QueryException( "unexpected [" );
 			}
 			return;
 		}
 		else if ( token.equals( "]" ) ) {
 			expectingIndex--;
 			expectingPathContinuation = true;
 			return;
 		}
 
 		//Cope with a continued path expression (ie. ].baz)
 		if ( expectingPathContinuation ) {
 			boolean pathExpressionContinuesFurther = continuePathExpression( token, q );
 			if ( pathExpressionContinuesFurther ) {
 				return; //NOTE: early return
 			}
 		}
 
 		//Cope with a subselect
 		if ( !inSubselect && ( lcToken.equals( "select" ) || lcToken.equals( "from" ) ) ) {
 			inSubselect = true;
 			subselect = new StringBuilder( 20 );
 		}
 		if ( inSubselect && token.equals( ")" ) ) {
 			bracketsSinceSelect--;
 
 			if ( bracketsSinceSelect == -1 ) {
 				QueryTranslatorImpl subq = new QueryTranslatorImpl(
 						subselect.toString(),
 						q.getEnabledFilters(),
 						q.getFactory()
 				);
 				try {
 					subq.compile( q );
 				}
 				catch ( MappingException me ) {
 					throw new QueryException( "MappingException occurred compiling subquery", me );
 				}
 				appendToken( q, subq.getSQLString() );
 				inSubselect = false;
 				bracketsSinceSelect = 0;
 			}
 		}
 		if ( inSubselect ) {
 			if ( token.equals( "(" ) ) {
 				bracketsSinceSelect++;
 			}
 			subselect.append( token ).append( ' ' );
 			return;
 		}
 
 		//Cope with special cases of AND, NOT, ()
 		specialCasesBefore( lcToken );
 
 		//Close extra brackets we opened
 		if ( !betweenSpecialCase && EXPRESSION_TERMINATORS.contains( lcToken ) ) {
 			closeExpression( q, lcToken );
 		}
 
 		//take note when this is a boolean expression
 		if ( BOOLEAN_OPERATORS.contains( lcToken ) ) {
 			booleanTests.removeLast();
 			booleanTests.addLast( Boolean.TRUE );
 		}
 
 		if ( lcToken.equals( "not" ) ) {
 			nots.addLast(  !(  nots.removeLast() ) );
 			negated = !negated;
 			return; //NOTE: early return
 		}
 
 		//process a token, mapping OO path expressions to SQL expressions
 		doToken( token, q );
 
 		//Open any extra brackets we might need.
 		if ( !betweenSpecialCase && EXPRESSION_OPENERS.contains( lcToken ) ) {
 			openExpression( q, lcToken );
 		}
 
 		//Cope with special cases of AND, NOT, )
 		specialCasesAfter( lcToken );
 
 	}
 
 	public void start(QueryTranslatorImpl q) throws QueryException {
 		token( "(", q );
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		if ( expectingPathContinuation ) {
 			expectingPathContinuation = false;
 			PathExpressionParser.CollectionElement element = pathExpressionParser.lastCollectionElement();
 			if ( element.elementColumns.length != 1 ) {
 				throw new QueryException( "path expression ended in composite collection element" );
 			}
 			appendToken( q, element.elementColumns[0] );
 			addToCurrentJoin( element );
 		}
 		token( ")", q );
 	}
 
 	private void closeExpression(QueryTranslatorImpl q, String lcToken) {
 		if ( booleanTests.removeLast() ) { //it was a boolean expression
 
 			if ( booleanTests.size() > 0 ) {
 				// the next one up must also be
 				booleanTests.removeLast();
 				booleanTests.addLast( Boolean.TRUE );
 			}
 
 			// Add any joins
 			appendToken( q, ( joins.removeLast() ).toString() );
 
 		}
 		else {
 			StringBuilder join = joins.removeLast();
 			joins.getLast().append( join.toString() );
 		}
 
 		if ( nots.removeLast() ) {
 			negated = !negated;
 		}
 
 		if ( !")".equals( lcToken ) ) {
 			appendToken( q, ")" );
 		}
 	}
 
 	private void openExpression(QueryTranslatorImpl q, String lcToken) {
 		nots.addLast( Boolean.FALSE );
 		booleanTests.addLast( Boolean.FALSE );
 		joins.addLast( new StringBuilder() );
 		if ( !"(".equals( lcToken ) ) {
 			appendToken( q, "(" );
 		}
 	}
 
 	private void preprocess(String token, QueryTranslatorImpl q) throws QueryException {
 		// ugly hack for cases like "elements(foo.bar.collection)"
 		// (multi-part path expression ending in elements or indices)
 		String[] tokens = StringHelper.split( ".", token, true );
 		if (
 				tokens.length > 5 &&
 				( CollectionPropertyNames.COLLECTION_ELEMENTS.equals( tokens[tokens.length - 1] )
 				|| CollectionPropertyNames.COLLECTION_INDICES.equals( tokens[tokens.length - 1] ) )
 		) {
 			pathExpressionParser.start( q );
 			for ( int i = 0; i < tokens.length - 3; i++ ) {
 				pathExpressionParser.token( tokens[i], q );
 			}
 			pathExpressionParser.token( null, q );
 			pathExpressionParser.end( q );
 			addJoin( pathExpressionParser.getWhereJoin(), q );
 			pathExpressionParser.ignoreInitialJoin();
 		}
 	}
 
 	private void doPathExpression(String token, QueryTranslatorImpl q) throws QueryException {
 
 		preprocess( token, q );
 
 		StringTokenizer tokens = new StringTokenizer( token, ".", true );
 		pathExpressionParser.start( q );
 		while ( tokens.hasMoreTokens() ) {
 			pathExpressionParser.token( tokens.nextToken(), q );
 		}
 		pathExpressionParser.end( q );
 		if ( pathExpressionParser.isCollectionValued() ) {
 			openExpression( q, "" );
 			appendToken( q, pathExpressionParser.getCollectionSubquery( q.getEnabledFilters() ) );
 			closeExpression( q, "" );
 			// this is ugly here, but needed because its a subquery
 			q.addQuerySpaces( q.getCollectionPersister( pathExpressionParser.getCollectionRole() ).getCollectionSpaces() );
 		}
 		else {
 			if ( pathExpressionParser.isExpectingCollectionIndex() ) {
 				expectingIndex++;
 			}
 			else {
 				addJoin( pathExpressionParser.getWhereJoin(), q );
 				appendToken( q, pathExpressionParser.getWhereColumn() );
 			}
 		}
 	}
 
 	private void addJoin(JoinSequence joinSequence, QueryTranslatorImpl q) throws QueryException {
 		//JoinFragment fromClause = q.createJoinFragment(true);
 		//fromClause.addJoins( join.toJoinFragment().toFromFragmentString(), StringHelper.EMPTY_STRING );
 		q.addFromJoinOnly( pathExpressionParser.getName(), joinSequence );
 		try {
 			addToCurrentJoin( joinSequence.toJoinFragment( q.getEnabledFilters(), true ).toWhereFragmentString() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	private void doToken(String token, QueryTranslatorImpl q) throws QueryException {
 		if ( q.isName( StringHelper.root( token ) ) ) { //path expression
 			doPathExpression( q.unalias( token ), q );
 		}
 		else if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) { //named query parameter
 			q.addNamedParameter( token.substring( 1 ) );
 			appendToken( q, "?" );
 		}
 		else {
 			Queryable persister = q.getEntityPersisterUsingImports( token );
 			if ( persister != null ) { // the name of a class
 				final String discrim = persister.getDiscriminatorSQLValue();
 				if ( InFragment.NULL.equals(discrim) || InFragment.NOT_NULL.equals(discrim) ) {
 					throw new QueryException( "subclass test not allowed for null or not null discriminator" );
 				}
 				else {
 					appendToken( q, discrim );
 				}
 			}
 			else {
 				Object constant;
 				if (
 						token.indexOf( '.' ) > -1 &&
-						( constant = ReflectHelper.getConstantValue( token ) ) != null
+						( constant = ReflectHelper.getConstantValue( token, q.getFactory().getServiceRegistry().getService( ClassLoaderService.class ) ) ) != null
 				) {
 					Type type;
 					try {
 						type = q.getFactory().getTypeResolver().heuristicType( constant.getClass().getName() );
 					}
 					catch ( MappingException me ) {
 						throw new QueryException( me );
 					}
 					if ( type == null ) {
 						throw new QueryException( QueryTranslator.ERROR_CANNOT_DETERMINE_TYPE + token );
 					}
 					try {
 						//noinspection unchecked
 						appendToken( q, ( ( LiteralType ) type ).objectToSQLString( constant, q.getFactory().getDialect() ) );
 					}
 					catch ( Exception e ) {
 						throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + token, e );
 					}
 				}
 				else { //anything else
 
 					String negatedToken = negated ? NEGATIONS.get( token.toLowerCase(Locale.ROOT) ) : null;
 					if ( negatedToken != null && ( !betweenSpecialCase || !"or".equals( negatedToken ) ) ) {
 						appendToken( q, negatedToken );
 					}
 					else {
 						appendToken( q, token );
 					}
 				}
 			}
 		}
 	}
 
 	private void addToCurrentJoin(String sql) {
 		joins.getLast().append( sql );
 	}
 
 	private void addToCurrentJoin(PathExpressionParser.CollectionElement ce)
 			throws QueryException {
 		try {
 			addToCurrentJoin( ce.joinSequence.toJoinFragment().toWhereFragmentString() + ce.indexValue.toString() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	private void specialCasesBefore(String lcToken) {
 		if ( lcToken.equals( "between" ) || lcToken.equals( "not between" ) ) {
 			betweenSpecialCase = true;
 		}
 	}
 
 	private void specialCasesAfter(String lcToken) {
 		if ( betweenSpecialCase && lcToken.equals( "and" ) ) {
 			betweenSpecialCase = false;
 		}
 	}
 
 	void appendToken(QueryTranslatorImpl q, String token) {
 		if ( expectingIndex > 0 ) {
 			pathExpressionParser.setLastCollectionElementIndexValue( token );
 		}
 		else {
 			q.appendWhereToken( token );
 		}
 	}
 
 	private boolean continuePathExpression(String token, QueryTranslatorImpl q) throws QueryException {
 
 		expectingPathContinuation = false;
 
 		PathExpressionParser.CollectionElement element = pathExpressionParser.lastCollectionElement();
 
 		if ( token.startsWith( "." ) ) { // the path expression continues after a ]
 
 			doPathExpression( getElementName( element, q ) + token, q ); // careful with this!
 
 			addToCurrentJoin( element );
 			return true; //NOTE: EARLY EXIT!
 
 		}
 
 		else { // the path expression ends at the ]
 			if ( element.elementColumns.length != 1 ) {
 				throw new QueryException( "path expression ended in composite collection element" );
 			}
 			appendToken( q, element.elementColumns[0] );
 			addToCurrentJoin( element );
 			return false;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/Assigned.java b/hibernate-core/src/main/java/org/hibernate/id/Assigned.java
index b16b189f1a..b81f42e1a0 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/Assigned.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/Assigned.java
@@ -1,56 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * <b>assigned</b><br>
  * <br>
  * An <tt>IdentifierGenerator</tt> that returns the current identifier assigned
  * to an instance.
  *
  * @author Gavin King
  */
-
 public class Assigned implements IdentifierGenerator, Configurable {
 	
 	private String entityName;
 
 	public Serializable generate(SessionImplementor session, Object obj) throws HibernateException {
 		//TODO: cache the persister, this shows up in yourkit
 		final Serializable id = session.getEntityPersister( entityName, obj ).getIdentifier( obj, session );
 		if ( id == null ) {
 			throw new IdentifierGenerationException(
 					"ids for this class must be manually assigned before calling save(): " + entityName
 			);
 		}
 		
 		return id;
 	}
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		entityName = params.getProperty( ENTITY_NAME );
 		if ( entityName == null ) {
 			throw new MappingException("no entity name");
 		}
 	}
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/id/Configurable.java b/hibernate-core/src/main/java/org/hibernate/id/Configurable.java
index 061ddf6f70..7ffdcc9700 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/Configurable.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/Configurable.java
@@ -1,31 +1,34 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.util.Properties;
 
 import org.hibernate.MappingException;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
- * An <tt>IdentifierGenerator</tt> that supports "configuration".
+ * An {@link IdentifierGenerator} that supports "configuration".
  *
  * @see IdentifierGenerator
+ *
  * @author Gavin King
+ * @author Steve Ebersole
  */
 public interface Configurable {
 	/**
 	 * Configure this instance, given the value of parameters
 	 * specified by the user as <tt>&lt;param&gt;</tt> elements.
 	 * This method is called just once, following instantiation.
 	 *
+	 * @param type The id property type descriptor
 	 * @param params param values, keyed by parameter name
+	 * @param serviceRegistry Access to service that may be needed.
 	 */
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnvironment) throws MappingException;
-
+	void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/ExportableColumn.java b/hibernate-core/src/main/java/org/hibernate/id/ExportableColumn.java
index 78e7ebbe94..6719c91af4 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/ExportableColumn.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/ExportableColumn.java
@@ -1,162 +1,170 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.Value;
 import org.hibernate.mapping.ValueVisitor;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.Type;
 
 /**
  * @author Steve Ebersole
  */
 public class ExportableColumn extends Column {
 
 	public ExportableColumn(Database database, Table table, String name, BasicType type) {
 		this(
 				database,
 				table,
 				name,
 				type,
 				database.getDialect().getTypeName( type.sqlTypes( null )[0] )
 		);
 	}
 
 	public ExportableColumn(
 			Database database,
 			Table table,
 			String name,
 			BasicType type,
 			String dbTypeDeclaration) {
 		super( name );
-		setValue( new ValueImpl( this, table, type ) );
+		setValue( new ValueImpl( this, table, type, database ) );
 		setSqlType( dbTypeDeclaration );
 	}
 
 	public static class ValueImpl implements Value {
 		private final ExportableColumn column;
 		private final Table table;
 		private final BasicType type;
+		private final Database database;
 
-		public ValueImpl(ExportableColumn column, Table table, BasicType type) {
+		public ValueImpl(ExportableColumn column, Table table, BasicType type, Database database) {
 			this.column = column;
 			this.table = table;
 			this.type = type;
+			this.database = database;
 		}
 
 		@Override
 		public int getColumnSpan() {
 			return 1;
 		}
 
 		@Override
 		public Iterator<Selectable> getColumnIterator() {
 			return new ColumnIterator( column );
 		}
 
 		@Override
 		public Type getType() throws MappingException {
 			return type;
 		}
 
 		@Override
 		public FetchMode getFetchMode() {
 			return null;
 		}
 
 		@Override
 		public Table getTable() {
 			return table;
 		}
 
 		@Override
 		public boolean hasFormula() {
 			return false;
 		}
 
 		@Override
 		public boolean isAlternateUniqueKey() {
 			return false;
 		}
 
 		@Override
 		public boolean isNullable() {
 			return false;
 		}
 
 		@Override
 		public boolean[] getColumnUpdateability() {
 			return new boolean[] { true };
 		}
 
 		@Override
 		public boolean[] getColumnInsertability() {
 			return new boolean[] { true };
 		}
 
 		@Override
 		public void createForeignKey() throws MappingException {
 		}
 
 		@Override
 		public boolean isSimpleValue() {
 			return true;
 		}
 
 		@Override
 		public boolean isValid(Mapping mapping) throws MappingException {
 			return false;
 		}
 
 		@Override
 		public void setTypeUsingReflection(String className, String propertyName) throws MappingException {
 		}
 
 		@Override
 		public Object accept(ValueVisitor visitor) {
 			return null;
 		}
+
+		@Override
+		public ServiceRegistry getServiceRegistry() {
+			return database.getBuildingOptions().getServiceRegistry();
+		}
 	}
 
 	public static class ColumnIterator implements Iterator<Selectable> {
 		private final ExportableColumn column;
 		private int count = 0;
 
 		public ColumnIterator(ExportableColumn column) {
 			this.column = column;
 		}
 
 		@Override
 		public boolean hasNext() {
 			return count == 0;
 		}
 
 		@Override
 		public ExportableColumn next() {
 			if ( count > 0 ) {
 				throw new NoSuchElementException( "The single element has already been read" );
 			}
 			count++;
 			return column;
 		}
 
 		@Override
 		public void remove() {
 			throw new UnsupportedOperationException( "Cannot remove" );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/ForeignGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/ForeignGenerator.java
index 08d0ca3421..384e0ff6bc 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/ForeignGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/ForeignGenerator.java
@@ -1,117 +1,117 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.MappingException;
 import org.hibernate.Session;
 import org.hibernate.TransientObjectException;
 import org.hibernate.engine.internal.ForeignKeys;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * <b>foreign</b><br>
  * <br>
  * An <tt>Identifier</tt> generator that uses the value of the id property of an
  * associated object<br>
  * <br>
  * One mapping parameter is required: property.
  *
  * @author Gavin King
  */
 public class ForeignGenerator implements IdentifierGenerator, Configurable {
 	private String entityName;
 	private String propertyName;
 
 	/**
 	 * Getter for property 'entityName'.
 	 *
 	 * @return Value for property 'entityName'.
 	 */
 	public String getEntityName() {
 		return entityName;
 	}
 
 	/**
 	 * Getter for property 'propertyName'.
 	 *
 	 * @return Value for property 'propertyName'.
 	 */
 	public String getPropertyName() {
 		return propertyName;
 	}
 
 	/**
 	 * Getter for property 'role'.  Role is the {@link #getPropertyName property name} qualified by the
 	 * {@link #getEntityName entity name}.
 	 *
 	 * @return Value for property 'role'.
 	 */
 	public String getRole() {
 		return getEntityName() + '.' + getPropertyName();
 	}
 
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		propertyName = params.getProperty( "property" );
 		entityName = params.getProperty( ENTITY_NAME );
 		if ( propertyName==null ) {
 			throw new MappingException( "param named \"property\" is required for foreign id generation strategy" );
 		}
 	}
 
 	@Override
 	public Serializable generate(SessionImplementor sessionImplementor, Object object) {
 		Session session = ( Session ) sessionImplementor;
 
 		final EntityPersister persister = sessionImplementor.getFactory().getEntityPersister( entityName );
 		Object associatedObject = persister.getPropertyValue( object, propertyName );
 		if ( associatedObject == null ) {
 			throw new IdentifierGenerationException(
 					"attempted to assign id from null one-to-one property [" + getRole() + "]"
 			);
 		}
 
 		final EntityType foreignValueSourceType;
 		final Type propertyType = persister.getPropertyType( propertyName );
 		if ( propertyType.isEntityType() ) {
 			// the normal case
 			foreignValueSourceType = (EntityType) propertyType;
 		}
 		else {
 			// try identifier mapper
 			foreignValueSourceType = (EntityType) persister.getPropertyType( PropertyPath.IDENTIFIER_MAPPER_PROPERTY + "." + propertyName );
 		}
 
 		Serializable id;
 		try {
 			id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
 					foreignValueSourceType.getAssociatedEntityName(),
 					associatedObject,
 					sessionImplementor
 			);
 		}
 		catch (TransientObjectException toe) {
 			id = session.save( foreignValueSourceType.getAssociatedEntityName(), associatedObject );
 		}
 
 		if ( session.contains(object) ) {
 			//abort the save (the object is already saved by a circular cascade)
 			return IdentifierGeneratorHelper.SHORT_CIRCUIT_INDICATOR;
 			//throw new IdentifierGenerationException("save associated object first, or disable cascade for inverse association");
 		}
 		return id;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
index a2b3b10961..f327f84e62 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/IncrementGenerator.java
@@ -1,141 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.mapping.Table;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * <b>increment</b><br>
  * <br>
  * An <tt>IdentifierGenerator</tt> that returns a <tt>long</tt>, constructed by
  * counting from the maximum primary key value at startup. Not safe for use in a
  * cluster!<br>
  * <br>
  * Mapping parameters supported, but not usually needed: tables, column.
  * (The tables parameter specified a comma-separated list of table names.)
  *
  * @author Gavin King
  * @author Steve Ebersole
  * @author Brett Meyer
  */
 public class IncrementGenerator implements IdentifierGenerator, Configurable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( IncrementGenerator.class );
 
 	private Class returnClass;
 	private String sql;
 
 	private IntegralDataTypeHolder previousValueHolder;
 
 	@Override
 	public synchronized Serializable generate(SessionImplementor session, Object object) throws HibernateException {
 		if ( sql != null ) {
 			initializePreviousValueHolder( session );
 		}
 		return previousValueHolder.makeValueThenIncrement();
 	}
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		returnClass = type.getReturnedClass();
 
-		ObjectNameNormalizer normalizer =
+		final JdbcEnvironment jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		final ObjectNameNormalizer normalizer =
 				(ObjectNameNormalizer) params.get( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER );
 
 		String column = params.getProperty( "column" );
 		if ( column == null ) {
 			column = params.getProperty( PersistentIdentifierGenerator.PK );
 		}
-		column = normalizer.normalizeIdentifierQuoting( column ).render( jdbcEnv.getDialect() );
+		column = normalizer.normalizeIdentifierQuoting( column ).render( jdbcEnvironment.getDialect() );
 
 		String tableList = params.getProperty( "tables" );
 		if ( tableList == null ) {
 			tableList = params.getProperty( PersistentIdentifierGenerator.TABLES );
 		}
 		String[] tables = StringHelper.split( ", ", tableList );
 
 		final String schema = normalizer.toDatabaseIdentifierText(
 				params.getProperty( PersistentIdentifierGenerator.SCHEMA )
 		);
 		final String catalog = normalizer.toDatabaseIdentifierText(
 				params.getProperty( PersistentIdentifierGenerator.CATALOG )
 		);
 
 		StringBuilder buf = new StringBuilder();
 		for ( int i = 0; i < tables.length; i++ ) {
 			final String tableName = normalizer.toDatabaseIdentifierText( tables[i] );
 			if ( tables.length > 1 ) {
 				buf.append( "select max(" ).append( column ).append( ") as mx from " );
 			}
 			buf.append( Table.qualify( catalog, schema, tableName ) );
 			if ( i < tables.length - 1 ) {
 				buf.append( " union " );
 			}
 		}
 		if ( tables.length > 1 ) {
 			buf.insert( 0, "( " ).append( " ) ids_" );
 			column = "ids_.mx";
 		}
 
 		sql = "select max(" + column + ") from " + buf.toString();
 	}
 
 	private void initializePreviousValueHolder(SessionImplementor session) {
 		previousValueHolder = IdentifierGeneratorHelper.getIntegralDataTypeHolder( returnClass );
 
 		final boolean debugEnabled = LOG.isDebugEnabled();
 		if ( debugEnabled ) {
 			LOG.debugf( "Fetching initial value: %s", sql );
 		}
 		try {
 			PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
 				try {
 					if ( rs.next() ) {
 						previousValueHolder.initialize( rs, 0L ).increment();
 					}
 					else {
 						previousValueHolder.initialize( 1L );
 					}
 					sql = null;
 					if ( debugEnabled ) {
 						LOG.debugf( "First free id: %s", previousValueHolder.makeValue() );
 					}
 				}
 				finally {
 					session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
 				}
 			}
 			finally {
 				session.getJdbcCoordinator().getResourceRegistry().release( st );
 				session.getJdbcCoordinator().afterStatementExecution();
 			}
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not fetch initial value for increment generator",
 					sql
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java
index 64221814c4..c56287d799 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java
@@ -1,351 +1,353 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.QualifiedName;
 import org.hibernate.boot.model.relational.QualifiedNameParser;
 import org.hibernate.boot.model.relational.Schema;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.engine.spi.SessionEventListenerManager;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.enhanced.AccessCallback;
 import org.hibernate.id.enhanced.LegacyHiLoAlgorithmOptimizer;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.AbstractReturningWork;
 import org.hibernate.jdbc.WorkExecutorVisitable;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.PrimaryKey;
 import org.hibernate.mapping.Table;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.LongType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.Type;
 
 /**
  * A hilo <tt>IdentifierGenerator</tt> that returns a <tt>Long</tt>, constructed using
  * a hi/lo algorithm. The hi value MUST be fetched in a seperate transaction
  * to the <tt>Session</tt> transaction so the generator must be able to obtain
  * a new connection and commit it. Hence this implementation may not
  * be used  when the user is supplying connections. In this
  * case a <tt>SequenceHiLoGenerator</tt> would be a better choice (where
  * supported).<br>
  * <br>
  * <p/>
  * A hilo <tt>IdentifierGenerator</tt> that uses a database
  * table to store the last generated values. A table can contains
  * several hi values. They are distinct from each other through a key
  * <p/>
  * <p>This implementation is not compliant with a user connection</p>
  * <p/>
  * <p/>
  * <p>Allowed parameters (all of them are optional):</p>
  * <ul>
  * <li>table: table name (default <tt>hibernate_sequences</tt>)</li>
  * <li>primary_key_column: key column name (default <tt>sequence_name</tt>)</li>
  * <li>value_column: hi value column name(default <tt>sequence_next_hi_value</tt>)</li>
  * <li>primary_key_value: key value for the current entity (default to the entity's primary table name)</li>
  * <li>primary_key_length: length of the key column in DB represented as a varchar (default to 255)</li>
  * <li>max_lo: max low value before increasing hi (default to Short.MAX_VALUE)</li>
  * </ul>
  *
  * @author Emmanuel Bernard
  * @author <a href="mailto:kr@hbt.de">Klaus Richarz</a>.
  */
 public class MultipleHiLoPerTableGenerator implements PersistentIdentifierGenerator, Configurable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( MultipleHiLoPerTableGenerator.class );
 
 	public static final String ID_TABLE = "table";
 	public static final String PK_COLUMN_NAME = "primary_key_column";
 	public static final String PK_VALUE_NAME = "primary_key_value";
 	public static final String VALUE_COLUMN_NAME = "value_column";
 	public static final String PK_LENGTH_NAME = "primary_key_length";
 
 	private static final int DEFAULT_PK_LENGTH = 255;
 	public static final String DEFAULT_TABLE = "hibernate_sequences";
 	private static final String DEFAULT_PK_COLUMN = "sequence_name";
 	private static final String DEFAULT_VALUE_COLUMN = "sequence_next_hi_value";
 
 	private QualifiedName qualifiedTableName;
 	private String tableName;
 	private String pkColumnName;
 	private String valueColumnName;
 	private String query;
 	private String insert;
 	private String update;
 
 	//hilo params
 	public static final String MAX_LO = "max_lo";
 
 	private int maxLo;
 	private LegacyHiLoAlgorithmOptimizer hiloOptimizer;
 
 	private Class returnClass;
 	private int keySize;
 
 	public synchronized Serializable generate(final SessionImplementor session, Object obj) {
 		final SqlStatementLogger statementLogger = session.getFactory().getServiceRegistry()
 				.getService( JdbcServices.class )
 				.getSqlStatementLogger();
 		final SessionEventListenerManager statsCollector = session.getEventListenerManager();
 
 		final WorkExecutorVisitable<IntegralDataTypeHolder> work = new AbstractReturningWork<IntegralDataTypeHolder>() {
 			@Override
 			public IntegralDataTypeHolder execute(Connection connection) throws SQLException {
 				IntegralDataTypeHolder value = IdentifierGeneratorHelper.getIntegralDataTypeHolder( returnClass );
 
 				int rows;
 				do {
 					final PreparedStatement queryPreparedStatement = prepareStatement(
 							connection,
 							query,
 							statementLogger,
 							statsCollector
 					);
 					try {
 						final ResultSet rs = executeQuery( queryPreparedStatement, statsCollector );
 						boolean isInitialized = rs.next();
 						if ( !isInitialized ) {
 							value.initialize( 0 );
 							final PreparedStatement insertPreparedStatement = prepareStatement(
 									connection,
 									insert,
 									statementLogger,
 									statsCollector
 							);
 							try {
 								value.bind( insertPreparedStatement, 1 );
 								executeUpdate( insertPreparedStatement, statsCollector );
 							}
 							finally {
 								insertPreparedStatement.close();
 							}
 						}
 						else {
 							value.initialize( rs, 0 );
 						}
 						rs.close();
 					}
 					catch (SQLException sqle) {
 						LOG.unableToReadOrInitHiValue( sqle );
 						throw sqle;
 					}
 					finally {
 						queryPreparedStatement.close();
 					}
 
 
 					final PreparedStatement updatePreparedStatement = prepareStatement(
 							connection,
 							update,
 							statementLogger,
 							statsCollector
 					);
 					try {
 						value.copy().increment().bind( updatePreparedStatement, 1 );
 						value.bind( updatePreparedStatement, 2 );
 
 						rows = executeUpdate( updatePreparedStatement, statsCollector );
 					}
 					catch (SQLException sqle) {
 						LOG.error( LOG.unableToUpdateHiValue( tableName ), sqle );
 						throw sqle;
 					}
 					finally {
 						updatePreparedStatement.close();
 					}
 				} while ( rows == 0 );
 
 				return value;
 			}
 		};
 
 		// maxLo < 1 indicates a hilo generator with no hilo :?
 		if ( maxLo < 1 ) {
 			//keep the behavior consistent even for boundary usages
 			IntegralDataTypeHolder value = null;
 			while ( value == null || value.lt( 1 ) ) {
 				value = session.getTransactionCoordinator().createIsolationDelegate().delegateWork( work, true );
 			}
 			return value.makeValue();
 		}
 
 		return hiloOptimizer.generate(
 				new AccessCallback() {
 					public IntegralDataTypeHolder getNextValue() {
 						return session.getTransactionCoordinator().createIsolationDelegate().delegateWork(
 								work,
 								true
 						);
 					}
 
 					@Override
 					public String getTenantIdentifier() {
 						return session.getTenantIdentifier();
 					}
 				}
 		);
 	}
 
 	private PreparedStatement prepareStatement(
 			Connection connection,
 			String sql,
 			SqlStatementLogger statementLogger,
 			SessionEventListenerManager statsCollector) throws SQLException {
 		statementLogger.logStatement( sql, FormatStyle.BASIC.getFormatter() );
 		try {
 			statsCollector.jdbcPrepareStatementStart();
 			return connection.prepareStatement( sql );
 		}
 		finally {
 			statsCollector.jdbcPrepareStatementEnd();
 		}
 	}
 
 	private int executeUpdate(PreparedStatement ps, SessionEventListenerManager statsCollector) throws SQLException {
 		try {
 			statsCollector.jdbcExecuteStatementStart();
 			return ps.executeUpdate();
 		}
 		finally {
 			statsCollector.jdbcExecuteStatementEnd();
 		}
 
 	}
 
 	private ResultSet executeQuery(PreparedStatement ps, SessionEventListenerManager statsCollector)
 			throws SQLException {
 		try {
 			statsCollector.jdbcExecuteStatementStart();
 			return ps.executeQuery();
 		}
 		finally {
 			statsCollector.jdbcExecuteStatementEnd();
 		}
 	}
 
 	@SuppressWarnings({"StatementWithEmptyBody", "deprecation"})
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
-		ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
+		final JdbcEnvironment jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
 
 		qualifiedTableName = QualifiedNameParser.INSTANCE.parse(
 				ConfigurationHelper.getString( ID_TABLE, params, DEFAULT_TABLE ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )
 		);
 
-		tableName = jdbcEnv.getQualifiedObjectNameFormatter().format(
+		tableName = jdbcEnvironment.getQualifiedObjectNameFormatter().format(
 				qualifiedTableName,
-				jdbcEnv.getDialect()
+				jdbcEnvironment.getDialect()
 		);
 		pkColumnName = normalizer.toDatabaseIdentifierText(
 				ConfigurationHelper.getString( PK_COLUMN_NAME, params, DEFAULT_PK_COLUMN )
 		);
 		valueColumnName = normalizer.toDatabaseIdentifierText(
 				ConfigurationHelper.getString( VALUE_COLUMN_NAME, params, DEFAULT_VALUE_COLUMN )
 		);
 
 		keySize = ConfigurationHelper.getInt( PK_LENGTH_NAME, params, DEFAULT_PK_LENGTH );
 		String keyValue = ConfigurationHelper.getString( PK_VALUE_NAME, params, params.getProperty( TABLE ) );
 
 		query = "select " +
 				valueColumnName +
 				" from " +
-				jdbcEnv.getDialect().appendLockHint( LockMode.PESSIMISTIC_WRITE, tableName ) +
+				jdbcEnvironment.getDialect().appendLockHint( LockMode.PESSIMISTIC_WRITE, tableName ) +
 				" where " + pkColumnName + " = '" + keyValue + "'" +
-				jdbcEnv.getDialect().getForUpdateString();
+				jdbcEnvironment.getDialect().getForUpdateString();
 
 		update = "update " +
 				tableName +
 				" set " +
 				valueColumnName +
 				" = ? where " +
 				valueColumnName +
 				" = ? and " +
 				pkColumnName +
 				" = '" +
 				keyValue
 				+ "'";
 
 		insert = "insert into " + tableName +
 				"(" + pkColumnName + ", " + valueColumnName + ") " +
 				"values('" + keyValue + "', ?)";
 
 
 		//hilo config
 		maxLo = ConfigurationHelper.getInt( MAX_LO, params, Short.MAX_VALUE );
 		returnClass = type.getReturnedClass();
 
 		if ( maxLo >= 1 ) {
 			hiloOptimizer = new LegacyHiLoAlgorithmOptimizer( returnClass, maxLo );
 		}
 	}
 
 	@Override
 	public void registerExportables(Database database) {
 		final Schema schema = database.locateSchema(
 				qualifiedTableName.getCatalogName(),
 				qualifiedTableName.getSchemaName()
 		);
 
 		final Table table = schema.createTable( qualifiedTableName.getObjectName(), false );
 		table.setPrimaryKey( new PrimaryKey() );
 
 		final Column pkColumn = new ExportableColumn(
 				database,
 				table,
 				pkColumnName,
 				StringType.INSTANCE,
 				database.getDialect().getTypeName( Types.VARCHAR, keySize, 0, 0 )
 		);
 		table.addColumn( pkColumn );
 		table.getPrimaryKey().addColumn( pkColumn );
 
 		final Column valueColumn = new ExportableColumn(
 				database,
 				table,
 				valueColumnName,
 				LongType.INSTANCE
 		);
 		table.addColumn( valueColumn );
 	}
 
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		return new String[] {
 				dialect.getCreateTableString()
 						+ ' ' + tableName + " ( "
 						+ pkColumnName + ' ' + dialect.getTypeName( Types.VARCHAR, keySize, 0, 0 ) + ",  "
 						+ valueColumnName + ' ' + dialect.getTypeName( Types.INTEGER )
 						+ " )" + dialect.getTableTypeString()
 		};
 	}
 
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return new String[] {dialect.getDropTableString( tableName )};
 	}
 
 	public Object generatorKey() {
 		return tableName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SelectGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SelectGenerator.java
index 818cab9bf0..920ecc745f 100755
--- a/hibernate-core/src/main/java/org/hibernate/id/SelectGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SelectGenerator.java
@@ -1,142 +1,142 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.insert.AbstractSelectingDelegate;
 import org.hibernate.id.insert.IdentifierGeneratingInsert;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * A generator that selects the just inserted row to determine the identifier
  * value assigned by the database. The correct row is located using a unique
  * key.
  * <p/>
  * One mapping parameter is required: key (unless a natural-id is defined in the mapping).
  *
  * @author Gavin King
  */
 public class SelectGenerator extends AbstractPostInsertGenerator implements Configurable {
 	private String uniqueKeyPropertyName;
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnvironment) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		uniqueKeyPropertyName = params.getProperty( "key" );
 	}
 
 	public InsertGeneratedIdentifierDelegate getInsertGeneratedIdentifierDelegate(
 			PostInsertIdentityPersister persister,
 			Dialect dialect,
 			boolean isGetGeneratedKeysEnabled) throws HibernateException {
 		return new SelectGeneratorDelegate( persister, dialect, uniqueKeyPropertyName );
 	}
 
 	private static String determineNameOfPropertyToUse(PostInsertIdentityPersister persister, String supplied) {
 		if ( supplied != null ) {
 			return supplied;
 		}
 		int[] naturalIdPropertyIndices = persister.getNaturalIdentifierProperties();
 		if ( naturalIdPropertyIndices == null ) {
 			throw new IdentifierGenerationException(
 					"no natural-id property defined; need to specify [key] in " +
 							"generator parameters"
 			);
 		}
 		if ( naturalIdPropertyIndices.length > 1 ) {
 			throw new IdentifierGenerationException(
 					"select generator does not currently support composite " +
 							"natural-id properties; need to specify [key] in generator parameters"
 			);
 		}
 		if ( persister.getEntityMetamodel().isNaturalIdentifierInsertGenerated() ) {
 			throw new IdentifierGenerationException(
 					"natural-id also defined as insert-generated; need to specify [key] " +
 							"in generator parameters"
 			);
 		}
 		return persister.getPropertyNames()[naturalIdPropertyIndices[0]];
 	}
 
 
 	/**
 	 * The delegate for the select generation strategy.
 	 */
 	public static class SelectGeneratorDelegate
 			extends AbstractSelectingDelegate
 			implements InsertGeneratedIdentifierDelegate {
 		private final PostInsertIdentityPersister persister;
 		private final Dialect dialect;
 
 		private final String uniqueKeyPropertyName;
 		private final Type uniqueKeyType;
 		private final Type idType;
 
 		private final String idSelectString;
 
 		private SelectGeneratorDelegate(
 				PostInsertIdentityPersister persister,
 				Dialect dialect,
 				String suppliedUniqueKeyPropertyName) {
 			super( persister );
 			this.persister = persister;
 			this.dialect = dialect;
 			this.uniqueKeyPropertyName = determineNameOfPropertyToUse( persister, suppliedUniqueKeyPropertyName );
 
 			idSelectString = persister.getSelectByUniqueKeyString( uniqueKeyPropertyName );
 			uniqueKeyType = persister.getPropertyType( uniqueKeyPropertyName );
 			idType = persister.getIdentifierType();
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			return new IdentifierGeneratingInsert( dialect );
 		}
 
 
 		// AbstractSelectingDelegate impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		protected String getSelectSQL() {
 			return idSelectString;
 		}
 
 		protected void bindParameters(
 				SessionImplementor session,
 				PreparedStatement ps,
 				Object entity) throws SQLException {
 			Object uniqueKeyValue = persister.getPropertyValue( entity, uniqueKeyPropertyName );
 			uniqueKeyType.nullSafeSet( ps, uniqueKeyValue, 1, session );
 		}
 
 		protected Serializable getResult(
 				SessionImplementor session,
 				ResultSet rs,
 				Object entity) throws SQLException {
 			if ( !rs.next() ) {
 				throw new IdentifierGenerationException(
 						"the inserted row could not be located by the unique key: " +
 								uniqueKeyPropertyName
 				);
 			}
 			return (Serializable) idType.nullSafeGet(
 					rs,
 					persister.getRootTableKeyColumnNames(),
 					session,
 					entity
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
index d7114c37ff..6f0ea39154 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SequenceGenerator.java
@@ -1,182 +1,184 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Collections;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.QualifiedName;
 import org.hibernate.boot.model.relational.QualifiedNameParser;
 import org.hibernate.boot.model.relational.Schema;
 import org.hibernate.boot.model.relational.SimpleAuxiliaryDatabaseObject;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * <b>sequence</b><br>
  * <br>
  * Generates <tt>long</tt> values using an oracle-style sequence. A higher
  * performance algorithm is <tt>SequenceHiLoGenerator</tt>.<br>
  * <br>
  * Mapping parameters supported: sequence, parameters.
  *
  * @see SequenceHiLoGenerator
  * @author Gavin King
  *
  * @deprecated Use {@link org.hibernate.id.enhanced.SequenceStyleGenerator} instead
  */
 @Deprecated
 public class SequenceGenerator
 		implements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator, Configurable {
 
 	private static final Logger LOG = Logger.getLogger( SequenceGenerator.class.getName() );
 
 	/**
 	 * The sequence parameter
 	 */
 	public static final String SEQUENCE = "sequence";
 
 	/**
 	 * The parameters parameter, appended to the create sequence DDL.
 	 * For example (Oracle): <tt>INCREMENT BY 1 START WITH 1 MAXVALUE 100 NOCACHE</tt>.
 	 */
 	public static final String PARAMETERS = "parameters";
 
 	private QualifiedName qualifiedSequenceName;
 	private String sequenceName;
 	private String parameters;
 	private Type identifierType;
 	private String sql;
 
 	protected Type getIdentifierType() {
 		return identifierType;
 	}
 
 	public Object generatorKey() {
 		return getSequenceName();
 	}
 
 	public String getSequenceName() {
 		return sequenceName;
 	}
 
 	@Override
 	@SuppressWarnings("StatementWithEmptyBody")
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		identifierType = type;
 		parameters = params.getProperty( PARAMETERS );
 
-		final Dialect dialect = jdbcEnv.getDialect();
+		final JdbcEnvironment jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		final Dialect dialect = jdbcEnvironment.getDialect();
 		final ObjectNameNormalizer normalizer = ( ObjectNameNormalizer ) params.get( IDENTIFIER_NORMALIZER );
 		qualifiedSequenceName = QualifiedNameParser.INSTANCE.parse(
 				ConfigurationHelper.getString( SEQUENCE, params, "hibernate_sequence" ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )
 		);
-		sequenceName = jdbcEnv.getQualifiedObjectNameFormatter().format( qualifiedSequenceName, dialect );
+		sequenceName = jdbcEnvironment.getQualifiedObjectNameFormatter().format( qualifiedSequenceName, dialect );
 
 		sql = dialect.getSequenceNextValString( sequenceName );
 	}
 
 	@Override
 	public Serializable generate(SessionImplementor session, Object obj) {
 		return generateHolder( session ).makeValue();
 	}
 
 	protected IntegralDataTypeHolder generateHolder(SessionImplementor session) {
 		try {
 			PreparedStatement st = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( sql );
 			try {
 				ResultSet rs = session.getJdbcCoordinator().getResultSetReturn().extract( st );
 				try {
 					rs.next();
 					IntegralDataTypeHolder result = buildHolder();
 					result.initialize( rs, 1 );
 					LOG.debugf( "Sequence identifier generated: %s", result );
 					return result;
 				}
 				finally {
 					session.getJdbcCoordinator().getResourceRegistry().release( rs, st );
 				}
 			}
 			finally {
 				session.getJdbcCoordinator().getResourceRegistry().release( st );
 				session.getJdbcCoordinator().afterStatementExecution();
 			}
 
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not get next sequence value",
 					sql
 			);
 		}
 	}
 
 	protected IntegralDataTypeHolder buildHolder() {
 		return IdentifierGeneratorHelper.getIntegralDataTypeHolder( identifierType.getReturnedClass() );
 	}
 
 	@Override
 	@SuppressWarnings( {"deprecation"})
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		String[] ddl = dialect.getCreateSequenceStrings( sequenceName );
 		if ( parameters != null ) {
 			ddl[ddl.length - 1] += ' ' + parameters;
 		}
 		return ddl;
 	}
 
 	@Override
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return dialect.getDropSequenceStrings(sequenceName);
 	}
 
 	@Override
 	public boolean supportsBulkInsertionIdentifierGeneration() {
 		return true;
 	}
 
 	@Override
 	public String determineBulkInsertionIdentifierGenerationSelectFragment(Dialect dialect) {
 		return dialect.getSelectSequenceNextValString( getSequenceName() );
 	}
 
 	@Override
 	public void registerExportables(Database database) {
 		// we cannot register a proper Sequence object here because of the free-form
 		//'parameters' as opposed to specific initialValue/increment values
 
 		final Schema schema = database.locateSchema(
 				qualifiedSequenceName.getCatalogName(),
 				qualifiedSequenceName.getSchemaName()
 		);
 
 		database.addAuxiliaryDatabaseObject(
 				new SimpleAuxiliaryDatabaseObject(
 						schema,
 						sqlCreateStrings( database.getDialect() ),
 						sqlDropStrings( database.getDialect() ),
 						Collections.<String>emptySet()
 				)
 		);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java
index 13e4bbcb95..23cece3031 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java
@@ -1,90 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.MappingException;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.enhanced.AccessCallback;
 import org.hibernate.id.enhanced.LegacyHiLoAlgorithmOptimizer;
 import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * <b>seqhilo</b><br>
  * <br>
  * An <tt>IdentifierGenerator</tt> that combines a hi/lo algorithm with an underlying
  * oracle-style sequence that generates hi values. The user may specify a
  * maximum lo value to determine how often new hi values are fetched.<br>
  * <br>
  * Mapping parameters supported: sequence, max_lo, parameters.
  *
  * @author Gavin King
  *
  * @deprecated See deprecation discussion on {@link SequenceGenerator}
  */
 @Deprecated
 public class SequenceHiLoGenerator extends SequenceGenerator {
 	public static final String MAX_LO = "max_lo";
 
 	private int maxLo;
 
 	private LegacyHiLoAlgorithmOptimizer hiloOptimizer;
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment d) throws MappingException {
-		super.configure(type, params, d);
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
+		super.configure( type, params, serviceRegistry );
 
 		maxLo = ConfigurationHelper.getInt( MAX_LO, params, 9 );
 
 		if ( maxLo >= 1 ) {
 			hiloOptimizer = new LegacyHiLoAlgorithmOptimizer(
 					getIdentifierType().getReturnedClass(),
 					maxLo
 			);
 		}
 	}
 
 	@Override
 	public synchronized Serializable generate(final SessionImplementor session, Object obj) {
 		// maxLo < 1 indicates a hilo generator with no hilo :?
 		if ( maxLo < 1 ) {
 			//keep the behavior consistent even for boundary usages
 			IntegralDataTypeHolder value = null;
 			while ( value == null || value.lt( 0 ) ) {
 				value = super.generateHolder( session );
 			}
 			return value.makeValue();
 		}
 
 		return hiloOptimizer.generate(
 				new AccessCallback() {
 					@Override
 					public IntegralDataTypeHolder getNextValue() {
 						return generateHolder( session );
 					}
 
 					@Override
 					public String getTenantIdentifier() {
 						return session.getTenantIdentifier();
 					}
 				}
 		);
 	}
 
 	/**
 	 * For testing/assertion purposes
 	 *
 	 * @return The optimizer
 	 */
 	LegacyHiLoAlgorithmOptimizer getHiloOptimizer() {
 		return hiloOptimizer;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
index 724df07574..4b4cacf229 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/SequenceIdentityGenerator.java
@@ -1,121 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.insert.AbstractReturningDelegate;
 import org.hibernate.id.insert.IdentifierGeneratingInsert;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.internal.CoreMessageLogger;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.sql.Insert;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * A generator which combines sequence generation with immediate retrieval
  * through JDBC3 {@link java.sql.Connection#prepareStatement(String, String[]) getGeneratedKeys}.
  * In this respect it works much like ANSI-SQL IDENTITY generation.
  * <p/>
  * This generator only known to work with newer Oracle drivers compiled for
  * JDK 1.4 (JDBC3).
  * <p/>
  * Note: Due to a bug in Oracle drivers, sql comments on these insert statements
  * are completely disabled.
  *
  * @author Steve Ebersole
  * @deprecated See deprecation discussion on {@link SequenceGenerator}
  */
 @Deprecated
 public class SequenceIdentityGenerator
 		extends SequenceGenerator
 		implements PostInsertIdentifierGenerator {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			SequenceIdentityGenerator.class.getName()
 	);
 
 	@Override
 	public Serializable generate(SessionImplementor s, Object obj) {
 		return IdentifierGeneratorHelper.POST_INSERT_INDICATOR;
 	}
 
 	@Override
 	public InsertGeneratedIdentifierDelegate getInsertGeneratedIdentifierDelegate(
 			PostInsertIdentityPersister persister,
 			Dialect dialect,
 			boolean isGetGeneratedKeysEnabled) throws HibernateException {
 		return new Delegate( persister, dialect, getSequenceName() );
 	}
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment env) throws MappingException {
-		super.configure( type, params, env );
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
+		super.configure( type, params, serviceRegistry );
 	}
 
 	public static class Delegate extends AbstractReturningDelegate {
 		private final Dialect dialect;
 		private final String sequenceNextValFragment;
 		private final String[] keyColumns;
 
 		public Delegate(PostInsertIdentityPersister persister, Dialect dialect, String sequenceName) {
 			super( persister );
 			this.dialect = dialect;
 			this.sequenceNextValFragment = dialect.getSelectSequenceNextValString( sequenceName );
 			this.keyColumns = getPersister().getRootTableKeyColumnNames();
 			if ( keyColumns.length > 1 ) {
 				throw new HibernateException( "sequence-identity generator cannot be used with with multi-column keys" );
 			}
 		}
 
 		public IdentifierGeneratingInsert prepareIdentifierGeneratingInsert() {
 			NoCommentsInsert insert = new NoCommentsInsert( dialect );
 			insert.addColumn( getPersister().getRootTableKeyColumnNames()[0], sequenceNextValFragment );
 			return insert;
 		}
 
 		@Override
 		protected PreparedStatement prepare(String insertSQL, SessionImplementor session) throws SQLException {
 			return session.getJdbcCoordinator().getStatementPreparer().prepareStatement( insertSQL, keyColumns );
 		}
 
 		@Override
 		protected Serializable executeAndExtract(PreparedStatement insert, SessionImplementor session)
 				throws SQLException {
 			session.getJdbcCoordinator().getResultSetReturn().executeUpdate( insert );
 			return IdentifierGeneratorHelper.getGeneratedIdentity(
 					insert.getGeneratedKeys(),
 					getPersister().getRootTableKeyColumnNames()[0],
 					getPersister().getIdentifierType()
 			);
 		}
 	}
 
 	public static class NoCommentsInsert extends IdentifierGeneratingInsert {
 		public NoCommentsInsert(Dialect dialect) {
 			super( dialect );
 		}
 
 		@Override
 		public Insert setComment(String comment) {
 			// don't allow comments on these insert statements as comments totally
 			// blow up the Oracle getGeneratedKeys "support" :(
 			LOG.disallowingInsertStatementComment();
 			return this;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/UUIDGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/UUIDGenerator.java
index 9b5ca85d4a..73442c7f17 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/UUIDGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/UUIDGenerator.java
@@ -1,101 +1,103 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.util.Properties;
 import java.util.UUID;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.uuid.StandardRandomStrategy;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 import org.hibernate.type.descriptor.java.UUIDTypeDescriptor;
 
 /**
  * An {@link IdentifierGenerator} which generates {@link UUID} values using a pluggable
  * {@link UUIDGenerationStrategy generation strategy}.  The values this generator can return
  * include {@link UUID}, {@link String} and byte[16]
  * <p/>
  * Supports 2 config parameters:<ul>
  * <li>{@link #UUID_GEN_STRATEGY} - names the {@link UUIDGenerationStrategy} instance to use</li>
  * <li>{@link #UUID_GEN_STRATEGY_CLASS} - names the {@link UUIDGenerationStrategy} class to use</li>
  * </ul>
  * <p/>
  * Currently there are 2 standard implementations of {@link UUIDGenerationStrategy}:<ul>
  * <li>{@link StandardRandomStrategy} (the default, if none specified)</li>
  * <li>{@link org.hibernate.id.uuid.CustomVersionOneStrategy}</li>
  * </ul>
  *
  * @author Steve Ebersole
  */
 public class UUIDGenerator implements IdentifierGenerator, Configurable {
 	public static final String UUID_GEN_STRATEGY = "uuid_gen_strategy";
 	public static final String UUID_GEN_STRATEGY_CLASS = "uuid_gen_strategy_class";
 
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( UUIDGenerator.class );
 
 	private UUIDGenerationStrategy strategy;
 	private UUIDTypeDescriptor.ValueTransformer valueTransformer;
 
 	public static UUIDGenerator buildSessionFactoryUniqueIdentifierGenerator() {
 		final UUIDGenerator generator = new UUIDGenerator();
 		generator.strategy = StandardRandomStrategy.INSTANCE;
 		generator.valueTransformer = UUIDTypeDescriptor.ToStringTransformer.INSTANCE;
 		return generator;
 	}
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		// check first for the strategy instance
 		strategy = (UUIDGenerationStrategy) params.get( UUID_GEN_STRATEGY );
 		if ( strategy == null ) {
 			// next check for the strategy class
 			final String strategyClassName = params.getProperty( UUID_GEN_STRATEGY_CLASS );
 			if ( strategyClassName != null ) {
 				try {
-					final Class strategyClass = ReflectHelper.classForName( strategyClassName );
+					final ClassLoaderService cls = serviceRegistry.getService( ClassLoaderService.class );
+					final Class strategyClass = cls.classForName( strategyClassName );
 					try {
 						strategy = (UUIDGenerationStrategy) strategyClass.newInstance();
 					}
 					catch ( Exception ignore ) {
 						LOG.unableToInstantiateUuidGenerationStrategy(ignore);
 					}
 				}
-				catch ( ClassNotFoundException ignore ) {
-						LOG.unableToLocateUuidGenerationStrategy(strategyClassName);
+				catch ( ClassLoadingException ignore ) {
+					LOG.unableToLocateUuidGenerationStrategy( strategyClassName );
 				}
 			}
 		}
 		if ( strategy == null ) {
 			// lastly use the standard random generator
 			strategy = StandardRandomStrategy.INSTANCE;
 		}
 
 		if ( UUID.class.isAssignableFrom( type.getReturnedClass() ) ) {
 			valueTransformer = UUIDTypeDescriptor.PassThroughTransformer.INSTANCE;
 		}
 		else if ( String.class.isAssignableFrom( type.getReturnedClass() ) ) {
 			valueTransformer = UUIDTypeDescriptor.ToStringTransformer.INSTANCE;
 		}
 		else if ( byte[].class.isAssignableFrom( type.getReturnedClass() ) ) {
 			valueTransformer = UUIDTypeDescriptor.ToBytesTransformer.INSTANCE;
 		}
 		else {
 			throw new HibernateException( "Unanticipated return type [" + type.getReturnedClass().getName() + "] for UUID conversion" );
 		}
 	}
 
 	public Serializable generate(SessionImplementor session, Object object) throws HibernateException {
 		return valueTransformer.transform( strategy.generateUUID( session ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/UUIDHexGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/UUIDHexGenerator.java
index fffeea0c9b..73eb54f34c 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/UUIDHexGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/UUIDHexGenerator.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.MappingException;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * <b>uuid</b><br>
  * <br>
  * A <tt>UUIDGenerator</tt> that returns a string of length 32,
  * This string will consist of only hex digits. Optionally,
  * the string may be generated with separators between each
  * component of the UUID.
  * <p/>
  * Mapping parameters supported: separator.
  *
  * @author Gavin King
  */
 public class UUIDHexGenerator extends AbstractUUIDGenerator implements Configurable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( UUIDHexGenerator.class );
 
 	private static boolean WARNED;
 
 	private String sep = "";
 
 	public UUIDHexGenerator() {
 		if ( !WARNED ) {
 			WARNED = true;
 			LOG.usingUuidHexGenerator( this.getClass().getName(), UUIDGenerator.class.getName() );
 		}
 	}
 
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		sep = ConfigurationHelper.getString( "separator", params, "" );
 	}
 
 	@Override
 	public Serializable generate(SessionImplementor session, Object obj) {
 		return format( getIP() ) + sep
 				+ format( getJVM() ) + sep
 				+ format( getHiTime() ) + sep
 				+ format( getLoTime() ) + sep
 				+ format( getCount() );
 	}
 
 	protected String format(int intValue) {
 		String formatted = Integer.toHexString( intValue );
 		StringBuilder buf = new StringBuilder( "00000000" );
 		buf.replace( 8 - formatted.length(), 8, formatted );
 		return buf.toString();
 	}
 
 	protected String format(short shortValue) {
 		String formatted = Integer.toHexString( shortValue );
 		StringBuilder buf = new StringBuilder( "0000" );
 		buf.replace( 4 - formatted.length(), 4, formatted );
 		return buf.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java
index 9104a98705..41b8d7a643 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java
@@ -1,457 +1,459 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id.enhanced;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.naming.Identifier;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.QualifiedName;
 import org.hibernate.boot.model.relational.QualifiedNameParser;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.BulkInsertionCapableIdentifierGenerator;
 import org.hibernate.id.Configurable;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * Generates identifier values based on an sequence-style database structure.
  * Variations range from actually using a sequence to using a table to mimic
  * a sequence.  These variations are encapsulated by the {@link DatabaseStructure}
  * interface internally.
  * <p/>
  * <b>NOTE</b> that by default we utilize a single database sequence for all
  * generators.  The configuration parameter {@link #CONFIG_PREFER_SEQUENCE_PER_ENTITY}
  * can be used to create dedicated sequence for each entity based on its name.
  * Sequence suffix can be controlled with {@link #CONFIG_SEQUENCE_PER_ENTITY_SUFFIX}
  * option.
  * <p/>
  * General configuration parameters:
  * <table>
  * 	 <tr>
  *     <td><b>NAME</b></td>
  *     <td><b>DEFAULT</b></td>
  *     <td><b>DESCRIPTION</b></td>
  *   </tr>
  *   <tr>
  *     <td>{@link #SEQUENCE_PARAM}</td>
  *     <td>{@link #DEF_SEQUENCE_NAME}</td>
  *     <td>The name of the sequence/table to use to store/retrieve values</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #INITIAL_PARAM}</td>
  *     <td>{@link #DEFAULT_INITIAL_VALUE}</td>
  *     <td>The initial value to be stored for the given segment; the effect in terms of storage varies based on {@link Optimizer} and {@link DatabaseStructure}</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #INCREMENT_PARAM}</td>
  *     <td>{@link #DEFAULT_INCREMENT_SIZE}</td>
  *     <td>The increment size for the underlying segment; the effect in terms of storage varies based on {@link Optimizer} and {@link DatabaseStructure}</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #OPT_PARAM}</td>
  *     <td><i>depends on defined increment size</i></td>
  *     <td>Allows explicit definition of which optimization strategy to use</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #FORCE_TBL_PARAM}</td>
  *     <td><b><i>false</i></b></td>
  *     <td>Allows explicit definition of which optimization strategy to use</td>
  *   </tr>
  * </table>
  * <p/>
  * Configuration parameters used specifically when the underlying structure is a table:
  * <table>
  * 	 <tr>
  *     <td><b>NAME</b></td>
  *     <td><b>DEFAULT</b></td>
  *     <td><b>DESCRIPTION</b></td>
  *   </tr>
  *   <tr>
  *     <td>{@link #VALUE_COLUMN_PARAM}</td>
  *     <td>{@link #DEF_VALUE_COLUMN}</td>
  *     <td>The name of column which holds the sequence value for the given segment</td>
  *   </tr>
  * </table>
  *
  * @author Steve Ebersole
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class SequenceStyleGenerator
 		implements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator, Configurable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			SequenceStyleGenerator.class.getName()
 	);
 
 
 	// general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Indicates the name of the sequence (or table) to use.  The default value is {@link #DEF_SEQUENCE_NAME},
 	 * although {@link #CONFIG_PREFER_SEQUENCE_PER_ENTITY} effects the default as well.
 	 */
 	public static final String SEQUENCE_PARAM = "sequence_name";
 
 	/**
 	 * The default value for {@link #SEQUENCE_PARAM}, in the absence of any {@link #CONFIG_PREFER_SEQUENCE_PER_ENTITY}
 	 * setting.
 	 */
 	public static final String DEF_SEQUENCE_NAME = "hibernate_sequence";
 
 	/**
 	 * Indicates the initial value to use.  The default value is {@link #DEFAULT_INITIAL_VALUE}
 	 */
 	public static final String INITIAL_PARAM = "initial_value";
 
 	/**
 	 * The default value for {@link #INITIAL_PARAM}
 	 */
 	public static final int DEFAULT_INITIAL_VALUE = 1;
 
 	/**
 	 * Indicates the increment size to use.  The default value is {@link #DEFAULT_INCREMENT_SIZE}
 	 */
 	public static final String INCREMENT_PARAM = "increment_size";
 
 	/**
 	 * The default value for {@link #INCREMENT_PARAM}
 	 */
 	public static final int DEFAULT_INCREMENT_SIZE = 1;
 
 	/**
 	 * Used to create dedicated sequence for each entity based on the entity name.  Sequence suffix can be
 	 * controlled with {@link #CONFIG_SEQUENCE_PER_ENTITY_SUFFIX} option.
 	 */
 	public static final String CONFIG_PREFER_SEQUENCE_PER_ENTITY = "prefer_sequence_per_entity";
 
 	/**
 	 * Indicates the suffix to use in naming the identifier sequence/table name, by appending the suffix to
 	 * the name of the entity.  Used in conjunction with {@link #CONFIG_PREFER_SEQUENCE_PER_ENTITY}.
 	 */
 	public static final String CONFIG_SEQUENCE_PER_ENTITY_SUFFIX = "sequence_per_entity_suffix";
 
 	/**
 	 * The default value for {@link #CONFIG_SEQUENCE_PER_ENTITY_SUFFIX}
 	 */
 	public static final String DEF_SEQUENCE_SUFFIX = "_SEQ";
 
 	/**
 	 * Indicates the optimizer to use, either naming a {@link Optimizer} implementation class or naming
 	 * a {@link StandardOptimizerDescriptor} by name
 	 */
 	public static final String OPT_PARAM = "optimizer";
 
 	/**
 	 * A flag to force using a table as the underlying structure rather than a sequence.
 	 */
 	public static final String FORCE_TBL_PARAM = "force_table_use";
 
 
 	// table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Indicates the name of the column holding the identifier values.  The default value is {@link #DEF_VALUE_COLUMN}
 	 */
 	public static final String VALUE_COLUMN_PARAM = "value_column";
 
 	/**
 	 * The default value for {@link #VALUE_COLUMN_PARAM}
 	 */
 	public static final String DEF_VALUE_COLUMN = "next_val";
 
 
 	// state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private DatabaseStructure databaseStructure;
 	private Optimizer optimizer;
 	private Type identifierType;
 
 	/**
 	 * Getter for property 'databaseStructure'.
 	 *
 	 * @return Value for property 'databaseStructure'.
 	 */
 	public DatabaseStructure getDatabaseStructure() {
 		return databaseStructure;
 	}
 
 	/**
 	 * Getter for property 'optimizer'.
 	 *
 	 * @return Value for property 'optimizer'.
 	 */
 	public Optimizer getOptimizer() {
 		return optimizer;
 	}
 
 	/**
 	 * Getter for property 'identifierType'.
 	 *
 	 * @return Value for property 'identifierType'.
 	 */
 	public Type getIdentifierType() {
 		return identifierType;
 	}
 
 
 
 	// Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
-		final Dialect dialect = jdbcEnv.getDialect();
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
+		final JdbcEnvironment jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		final Dialect dialect = jdbcEnvironment.getDialect();
 
 		this.identifierType = type;
 		boolean forceTableUse = ConfigurationHelper.getBoolean( FORCE_TBL_PARAM, params, false );
 
-		final QualifiedName sequenceName = determineSequenceName( params, dialect, jdbcEnv );
+		final QualifiedName sequenceName = determineSequenceName( params, dialect, jdbcEnvironment );
 
 		final int initialValue = determineInitialValue( params );
 		int incrementSize = determineIncrementSize( params );
 
 		final String optimizationStrategy = determineOptimizationStrategy( params, incrementSize );
 		incrementSize = determineAdjustedIncrementSize( optimizationStrategy, incrementSize );
 
 		if ( dialect.supportsSequences() && !forceTableUse ) {
 			if ( !dialect.supportsPooledSequences() && OptimizerFactory.isPooledOptimizer( optimizationStrategy ) ) {
 				forceTableUse = true;
 				LOG.forcingTableUse();
 			}
 		}
 
 		this.databaseStructure = buildDatabaseStructure(
 				type,
 				params,
-				jdbcEnv,
+				jdbcEnvironment,
 				forceTableUse,
 				sequenceName,
 				initialValue,
 				incrementSize
 		);
 		this.optimizer = OptimizerFactory.buildOptimizer(
 				optimizationStrategy,
 				identifierType.getReturnedClass(),
 				incrementSize,
 				ConfigurationHelper.getInt( INITIAL_PARAM, params, -1 )
 		);
 		this.databaseStructure.prepare( optimizer );
 	}
 
 	/**
 	 * Determine the name of the sequence (or table if this resolves to a physical table)
 	 * to use.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param dialect The dialect in effect
-	 * @param jdbcEnv
+	 * @param jdbcEnv The JdbcEnvironment
 	 * @return The sequence name
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected QualifiedName determineSequenceName(Properties params, Dialect dialect, JdbcEnvironment jdbcEnv) {
 		final String sequencePerEntitySuffix = ConfigurationHelper.getString( CONFIG_SEQUENCE_PER_ENTITY_SUFFIX, params, DEF_SEQUENCE_SUFFIX );
 		// JPA_ENTITY_NAME value honors <class ... entity-name="..."> (HBM) and @Entity#name (JPA) overrides.
 		final String defaultSequenceName = ConfigurationHelper.getBoolean( CONFIG_PREFER_SEQUENCE_PER_ENTITY, params, false )
 				? params.getProperty( JPA_ENTITY_NAME ) + sequencePerEntitySuffix
 				: DEF_SEQUENCE_NAME;
 
 		final String sequenceName = ConfigurationHelper.getString( SEQUENCE_PARAM, params, defaultSequenceName );
 		if ( sequenceName.contains( "." ) ) {
 			return QualifiedNameParser.INSTANCE.parse( sequenceName );
 		}
 		else {
 			// todo : need to incorporate implicit catalog and schema names
 			final Identifier catalog = jdbcEnv.getIdentifierHelper().toIdentifier(
 					ConfigurationHelper.getString( CATALOG, params )
 			);
 			final Identifier schema =  jdbcEnv.getIdentifierHelper().toIdentifier(
 					ConfigurationHelper.getString( SCHEMA, params )
 			);
 			return new QualifiedNameParser.NameParts(
 					catalog,
 					schema,
 					jdbcEnv.getIdentifierHelper().toIdentifier( sequenceName )
 			);
 		}
 	}
 
 	/**
 	 * Determine the name of the column used to store the generator value in
 	 * the db.
 	 * <p/>
 	 * Called during {@link #configure configuration} <b>when resolving to a
 	 * physical table</b>.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param jdbcEnvironment The JDBC environment
 	 * @return The value column name
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected Identifier determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {
 		final String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );
 		return jdbcEnvironment.getIdentifierHelper().toIdentifier( name );
 	}
 
 	/**
 	 * Determine the initial sequence value to use.  This value is used when
 	 * initializing the {@link #getDatabaseStructure() database structure}
 	 * (i.e. sequence/table).
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @return The initial value
 	 */
 	protected int determineInitialValue(Properties params) {
 		return ConfigurationHelper.getInt( INITIAL_PARAM, params, DEFAULT_INITIAL_VALUE );
 	}
 
 	/**
 	 * Determine the increment size to be applied.  The exact implications of
 	 * this value depends on the {@link #getOptimizer() optimizer} being used.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @return The increment size
 	 */
 	protected int determineIncrementSize(Properties params) {
 		return ConfigurationHelper.getInt( INCREMENT_PARAM, params, DEFAULT_INCREMENT_SIZE );
 	}
 
 	/**
 	 * Determine the optimizer to use.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param incrementSize The {@link #determineIncrementSize determined increment size}
 	 * @return The optimizer strategy (name)
 	 */
 	protected String determineOptimizationStrategy(Properties params, int incrementSize) {
 		// if the increment size is greater than one, we prefer pooled optimization; but we first
 		// need to see if the user prefers POOL or POOL_LO...
 		final String defaultPooledOptimizerStrategy = ConfigurationHelper.getBoolean( Environment.PREFER_POOLED_VALUES_LO, params, false )
 				? StandardOptimizerDescriptor.POOLED_LO.getExternalName()
 				: StandardOptimizerDescriptor.POOLED.getExternalName();
 		final String defaultOptimizerStrategy = incrementSize <= 1
 				? StandardOptimizerDescriptor.NONE.getExternalName()
 				: defaultPooledOptimizerStrategy;
 		return ConfigurationHelper.getString( OPT_PARAM, params, defaultOptimizerStrategy );
 	}
 
 	/**
 	 * In certain cases we need to adjust the increment size based on the
 	 * selected optimizer.  This is the hook to achieve that.
 	 *
 	 * @param optimizationStrategy The optimizer strategy (name)
 	 * @param incrementSize The {@link #determineIncrementSize determined increment size}
 	 * @return The adjusted increment size.
 	 */
 	protected int determineAdjustedIncrementSize(String optimizationStrategy, int incrementSize) {
 		if ( incrementSize > 1 && StandardOptimizerDescriptor.NONE.getExternalName().equals( optimizationStrategy ) ) {
 			LOG.honoringOptimizerSetting(
 					StandardOptimizerDescriptor.NONE.getExternalName(),
 					INCREMENT_PARAM,
 					incrementSize
 			);
 			incrementSize = 1;
 		}
 		return incrementSize;
 	}
 
 	/**
 	 * Build the database structure.
 	 *
 	 * @param type The Hibernate type of the identifier property
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param jdbcEnvironment The JDBC environment in which the sequence will be used.
 	 * @param forceTableUse Should a table be used even if the dialect supports sequences?
 	 * @param sequenceName The name to use for the sequence or table.
 	 * @param initialValue The initial value.
 	 * @param incrementSize the increment size to use (after any adjustments).
 	 *
 	 * @return An abstraction for the actual database structure in use (table vs. sequence).
 	 */
 	protected DatabaseStructure buildDatabaseStructure(
 			Type type,
 			Properties params,
 			JdbcEnvironment jdbcEnvironment,
 			boolean forceTableUse,
 			QualifiedName sequenceName,
 			int initialValue,
 			int incrementSize) {
 		final boolean useSequence = jdbcEnvironment.getDialect().supportsSequences() && !forceTableUse;
 		if ( useSequence ) {
 			return new SequenceStructure( jdbcEnvironment, sequenceName, initialValue, incrementSize, type.getReturnedClass() );
 		}
 		else {
 			final Identifier valueColumnName = determineValueColumnName( params, jdbcEnvironment );
 			return new TableStructure( jdbcEnvironment, sequenceName, valueColumnName, initialValue, incrementSize, type.getReturnedClass() );
 		}
 	}
 
 
 	// IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public Serializable generate(SessionImplementor session, Object object) throws HibernateException {
 		return optimizer.generate( databaseStructure.buildCallback( session ) );
 	}
 
 
 	// PersistentIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public Object generatorKey() {
 		return databaseStructure.getName();
 	}
 
 	@Override
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		return databaseStructure.sqlCreateStrings( dialect );
 	}
 
 	@Override
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return databaseStructure.sqlDropStrings( dialect );
 	}
 
 
 	// BulkInsertionCapableIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~
 
 	@Override
 	public boolean supportsBulkInsertionIdentifierGeneration() {
 		// it does, as long as
 		// 		1) there is no (non-noop) optimizer in use
 		//		2) the underlying structure is a sequence
 		return NoopOptimizer.class.isInstance( getOptimizer() )
 				&& getDatabaseStructure().isPhysicalSequence();
 	}
 
 	@Override
 	public String determineBulkInsertionIdentifierGenerationSelectFragment(Dialect dialect) {
 		return dialect.getSelectSequenceNextValString( getDatabaseStructure().getName() );
 	}
 
 	@Override
 	public void registerExportables(Database database) {
 		databaseStructure.registerExportables( database );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableGenerator.java b/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableGenerator.java
index bdb144b189..deb1b8bb1a 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableGenerator.java
@@ -1,693 +1,695 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id.enhanced;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.QualifiedName;
 import org.hibernate.boot.model.relational.QualifiedNameParser;
 import org.hibernate.boot.model.relational.Schema;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.engine.spi.SessionEventListenerManager;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.Configurable;
 import org.hibernate.id.ExportableColumn;
 import org.hibernate.id.IdentifierGeneratorHelper;
 import org.hibernate.id.IntegralDataTypeHolder;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.AbstractReturningWork;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.PrimaryKey;
 import org.hibernate.mapping.Table;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.LongType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * An enhanced version of table-based id generation.
  * <p/>
  * Unlike the simplistic legacy one (which, btw, was only ever intended for subclassing
  * support) we "segment" the table into multiple values.  Thus a single table can
  * actually serve as the persistent storage for multiple independent generators.  One
  * approach would be to segment the values by the name of the entity for which we are
  * performing generation, which would mean that we would have a row in the generator
  * table for each entity name.  Or any configuration really; the setup is very flexible.
  * <p/>
  * In this respect it is very similar to the legacy
  * {@link org.hibernate.id.MultipleHiLoPerTableGenerator} in terms of the
  * underlying storage structure (namely a single table capable of holding
  * multiple generator values).  The differentiator is, as with
  * {@link SequenceStyleGenerator} as well, the externalized notion
  * of an optimizer.
  * <p/>
  * <b>NOTE</b> that by default we use a single row for all generators (based
  * on {@link #DEF_SEGMENT_VALUE}).  The configuration parameter
  * {@link #CONFIG_PREFER_SEGMENT_PER_ENTITY} can be used to change that to
  * instead default to using a row for each entity name.
  * <p/>
  * Configuration parameters:
  * <table>
  * 	 <tr>
  *     <td><b>NAME</b></td>
  *     <td><b>DEFAULT</b></td>
  *     <td><b>DESCRIPTION</b></td>
  *   </tr>
  *   <tr>
  *     <td>{@link #TABLE_PARAM}</td>
  *     <td>{@link #DEF_TABLE}</td>
  *     <td>The name of the table to use to store/retrieve values</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #VALUE_COLUMN_PARAM}</td>
  *     <td>{@link #DEF_VALUE_COLUMN}</td>
  *     <td>The name of column which holds the sequence value for the given segment</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #SEGMENT_COLUMN_PARAM}</td>
  *     <td>{@link #DEF_SEGMENT_COLUMN}</td>
  *     <td>The name of the column which holds the segment key</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #SEGMENT_VALUE_PARAM}</td>
  *     <td>{@link #DEF_SEGMENT_VALUE}</td>
  *     <td>The value indicating which segment is used by this generator; refers to values in the {@link #SEGMENT_COLUMN_PARAM} column</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #SEGMENT_LENGTH_PARAM}</td>
  *     <td>{@link #DEF_SEGMENT_LENGTH}</td>
  *     <td>The data length of the {@link #SEGMENT_COLUMN_PARAM} column; used for schema creation</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #INITIAL_PARAM}</td>
  *     <td>{@link #DEFAULT_INITIAL_VALUE}</td>
  *     <td>The initial value to be stored for the given segment</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #INCREMENT_PARAM}</td>
  *     <td>{@link #DEFAULT_INCREMENT_SIZE}</td>
  *     <td>The increment size for the underlying segment; see the discussion on {@link Optimizer} for more details.</td>
  *   </tr>
  *   <tr>
  *     <td>{@link #OPT_PARAM}</td>
  *     <td><i>depends on defined increment size</i></td>
  *     <td>Allows explicit definition of which optimization strategy to use</td>
  *   </tr>
  * </table>
  *
  * @author Steve Ebersole
  */
 public class TableGenerator implements PersistentIdentifierGenerator, Configurable {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TableGenerator.class.getName()
 	);
 
 	/**
 	 * By default (in the absence of a {@link #SEGMENT_VALUE_PARAM} setting) we use a single row for all
 	 * generators.  This setting can be used to change that to instead default to using a row for each entity name.
 	 */
 	public static final String CONFIG_PREFER_SEGMENT_PER_ENTITY = "prefer_entity_table_as_segment_value";
 
 	/**
 	 * Configures the name of the table to use.  The default value is {@link #DEF_TABLE}
 	 */
 	public static final String TABLE_PARAM = "table_name";
 
 	/**
 	 * The default {@link #TABLE_PARAM} value
 	 */
 	public static final String DEF_TABLE = "hibernate_sequences";
 
 	/**
 	 * The name of column which holds the sequence value.  The default value is {@link #DEF_VALUE_COLUMN}
 	 */
 	public static final String VALUE_COLUMN_PARAM = "value_column_name";
 
 	/**
 	 * The default {@link #VALUE_COLUMN_PARAM} value
 	 */
 	public static final String DEF_VALUE_COLUMN = "next_val";
 
 	/**
 	 * The name of the column which holds the segment key.  The segment defines the different buckets (segments)
 	 * of values currently tracked in the table.  The default value is {@link #DEF_SEGMENT_COLUMN}
 	 */
 	public static final String SEGMENT_COLUMN_PARAM = "segment_column_name";
 
 	/**
 	 * The default {@link #SEGMENT_COLUMN_PARAM} value
 	 */
 	public static final String DEF_SEGMENT_COLUMN = "sequence_name";
 
 	/**
 	 * The value indicating which segment is used by this generator, as indicated by the actual value stored in the
 	 * column indicated by {@link #SEGMENT_COLUMN_PARAM}.  The default value for setting is {@link #DEF_SEGMENT_VALUE},
 	 * although {@link #CONFIG_PREFER_SEGMENT_PER_ENTITY} effects the default as well.
 	 */
 	public static final String SEGMENT_VALUE_PARAM = "segment_value";
 
 	/**
 	 * The default {@link #SEGMENT_VALUE_PARAM} value, unless {@link #CONFIG_PREFER_SEGMENT_PER_ENTITY} is specified
 	 */
 	public static final String DEF_SEGMENT_VALUE = "default";
 
 	/**
 	 * Indicates the length of the column defined by {@link #SEGMENT_COLUMN_PARAM}.  Used in schema export.  The
 	 * default value is {@link #DEF_SEGMENT_LENGTH}
 	 */
 	public static final String SEGMENT_LENGTH_PARAM = "segment_value_length";
 
 	/**
 	 * The default {@link #SEGMENT_LENGTH_PARAM} value
 	 */
 	public static final int DEF_SEGMENT_LENGTH = 255;
 
 	/**
 	 * Indicates the initial value to use.  The default value is {@link #DEFAULT_INITIAL_VALUE}
 	 */
 	public static final String INITIAL_PARAM = "initial_value";
 
 	/**
 	 * The default {@link #INITIAL_PARAM} value
 	 */
 	public static final int DEFAULT_INITIAL_VALUE = 1;
 
 	/**
 	 * Indicates the increment size to use.  The default value is {@link #DEFAULT_INCREMENT_SIZE}
 	 */
 	public static final String INCREMENT_PARAM = "increment_size";
 
 	/**
 	 * The default {@link #INCREMENT_PARAM} value
 	 */
 	public static final int DEFAULT_INCREMENT_SIZE = 1;
 
 	/**
 	 * Indicates the optimizer to use, either naming a {@link Optimizer} implementation class or by naming
 	 * a {@link StandardOptimizerDescriptor} by name
 	 */
 	public static final String OPT_PARAM = "optimizer";
 
 
 	private Type identifierType;
 
 	private QualifiedName qualifiedTableName;
 	private String renderedTableName;
 
 	private String segmentColumnName;
 	private String segmentValue;
 	private int segmentValueLength;
 
 	private String valueColumnName;
 	private int initialValue;
 	private int incrementSize;
 
 	private String selectQuery;
 	private String insertQuery;
 	private String updateQuery;
 
 	private Optimizer optimizer;
 	private long accessCount;
 
 	@Override
 	public Object generatorKey() {
 		return qualifiedTableName.render();
 	}
 
 	/**
 	 * Type mapping for the identifier.
 	 *
 	 * @return The identifier type mapping.
 	 */
 	public final Type getIdentifierType() {
 		return identifierType;
 	}
 
 	/**
 	 * The name of the table in which we store this generator's persistent state.
 	 *
 	 * @return The table name.
 	 */
 	public final String getTableName() {
 		return qualifiedTableName.render();
 	}
 
 	/**
 	 * The name of the column in which we store the segment to which each row
 	 * belongs.  The value here acts as PK.
 	 *
 	 * @return The segment column name
 	 */
 	public final String getSegmentColumnName() {
 		return segmentColumnName;
 	}
 
 	/**
 	 * The value in {@link #getSegmentColumnName segment column} which
 	 * corresponding to this generator instance.  In other words this value
 	 * indicates the row in which this generator instance will store values.
 	 *
 	 * @return The segment value for this generator instance.
 	 */
 	public final String getSegmentValue() {
 		return segmentValue;
 	}
 
 	/**
 	 * The size of the {@link #getSegmentColumnName segment column} in the
 	 * underlying table.
 	 * <p/>
 	 * <b>NOTE</b> : should really have been called 'segmentColumnLength' or
 	 * even better 'segmentColumnSize'
 	 *
 	 * @return the column size.
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public final int getSegmentValueLength() {
 		return segmentValueLength;
 	}
 
 	/**
 	 * The name of the column in which we store our persistent generator value.
 	 *
 	 * @return The name of the value column.
 	 */
 	public final String getValueColumnName() {
 		return valueColumnName;
 	}
 
 	/**
 	 * The initial value to use when we find no previous state in the
 	 * generator table corresponding to our sequence.
 	 *
 	 * @return The initial value to use.
 	 */
 	public final int getInitialValue() {
 		return initialValue;
 	}
 
 	/**
 	 * The amount of increment to use.  The exact implications of this
 	 * depends on the {@link #getOptimizer() optimizer} being used.
 	 *
 	 * @return The increment amount.
 	 */
 	public final int getIncrementSize() {
 		return incrementSize;
 	}
 
 	/**
 	 * The optimizer being used by this generator.
 	 *
 	 * @return Out optimizer.
 	 */
 	public final Optimizer getOptimizer() {
 		return optimizer;
 	}
 
 	/**
 	 * Getter for property 'tableAccessCount'.  Only really useful for unit test
 	 * assertions.
 	 *
 	 * @return Value for property 'tableAccessCount'.
 	 */
 	public final long getTableAccessCount() {
 		return accessCount;
 	}
 
 	@Override
-	public void configure(Type type, Properties params, JdbcEnvironment jdbcEnv) throws MappingException {
+	public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException {
 		identifierType = type;
 
-		final Dialect dialect = jdbcEnv.getDialect();
+		final JdbcEnvironment jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		final Dialect dialect = jdbcEnvironment.getDialect();
 
 		qualifiedTableName = determineGeneratorTableName( params, dialect );
-		renderedTableName = jdbcEnv.getQualifiedObjectNameFormatter().format( qualifiedTableName, dialect );
+		renderedTableName = jdbcEnvironment.getQualifiedObjectNameFormatter().format( qualifiedTableName, dialect );
 		segmentColumnName = determineSegmentColumnName( params, dialect );
 		valueColumnName = determineValueColumnName( params, dialect );
 
 		segmentValue = determineSegmentValue( params );
 
 		segmentValueLength = determineSegmentColumnSize( params );
 		initialValue = determineInitialValue( params );
 		incrementSize = determineIncrementSize( params );
 
 		this.selectQuery = buildSelectQuery( dialect );
 		this.updateQuery = buildUpdateQuery();
 		this.insertQuery = buildInsertQuery();
 
 		// if the increment size is greater than one, we prefer pooled optimization; but we
 		// need to see if the user prefers POOL or POOL_LO...
 		final String defaultPooledOptimizerStrategy = ConfigurationHelper.getBoolean( Environment.PREFER_POOLED_VALUES_LO, params, false )
 				? StandardOptimizerDescriptor.POOLED_LO.getExternalName()
 				: StandardOptimizerDescriptor.POOLED.getExternalName();
 		final String defaultOptimizerStrategy = incrementSize <= 1
 				? StandardOptimizerDescriptor.NONE.getExternalName()
 				: defaultPooledOptimizerStrategy;
 		final String optimizationStrategy = ConfigurationHelper.getString( OPT_PARAM, params, defaultOptimizerStrategy );
 		optimizer = OptimizerFactory.buildOptimizer(
 				optimizationStrategy,
 				identifierType.getReturnedClass(),
 				incrementSize,
 				ConfigurationHelper.getInt( INITIAL_PARAM, params, -1 )
 		);
 	}
 
 	/**
 	 * Determine the table name to use for the generator values.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @see #getTableName()
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param dialect The dialect in effect
 	 * @return The table name to use.
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {
 		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
 
 		return QualifiedNameParser.INSTANCE.parse(
 				ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),
 				normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )
 		);
 	}
 
 	/**
 	 * Determine the name of the column used to indicate the segment for each
 	 * row.  This column acts as the primary key.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @see #getSegmentColumnName()
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param dialect The dialect in effect
 	 * @return The name of the segment column
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected String determineSegmentColumnName(Properties params, Dialect dialect) {
 		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
 		final String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );
 		return normalizer.toDatabaseIdentifierText( name );
 	}
 
 	/**
 	 * Determine the name of the column in which we will store the generator persistent value.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @see #getValueColumnName()
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @param dialect The dialect in effect
 	 * @return The name of the value column
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected String determineValueColumnName(Properties params, Dialect dialect) {
 		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
 		final String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );
 		return normalizer.toDatabaseIdentifierText( name );
 	}
 
 	/**
 	 * Determine the segment value corresponding to this generator instance.
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @see #getSegmentValue()
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @return The name of the value column
 	 */
 	protected String determineSegmentValue(Properties params) {
 		String segmentValue = params.getProperty( SEGMENT_VALUE_PARAM );
 		if ( StringHelper.isEmpty( segmentValue ) ) {
 			segmentValue = determineDefaultSegmentValue( params );
 		}
 		return segmentValue;
 	}
 
 	/**
 	 * Used in the cases where {@link #determineSegmentValue} is unable to
 	 * determine the value to use.
 	 *
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @return The default segment value to use.
 	 */
 	protected String determineDefaultSegmentValue(Properties params) {
 		final boolean preferSegmentPerEntity = ConfigurationHelper.getBoolean( CONFIG_PREFER_SEGMENT_PER_ENTITY, params, false );
 		final String defaultToUse = preferSegmentPerEntity ? params.getProperty( TABLE ) : DEF_SEGMENT_VALUE;
 		LOG.usingDefaultIdGeneratorSegmentValue( qualifiedTableName.render(), segmentColumnName, defaultToUse );
 		return defaultToUse;
 	}
 
 	/**
 	 * Determine the size of the {@link #getSegmentColumnName segment column}
 	 * <p/>
 	 * Called during {@link #configure configuration}.
 	 *
 	 * @see #getSegmentValueLength()
 	 * @param params The params supplied in the generator config (plus some standard useful extras).
 	 * @return The size of the segment column
 	 */
 	protected int determineSegmentColumnSize(Properties params) {
 		return ConfigurationHelper.getInt( SEGMENT_LENGTH_PARAM, params, DEF_SEGMENT_LENGTH );
 	}
 
 	protected int determineInitialValue(Properties params) {
 		return ConfigurationHelper.getInt( INITIAL_PARAM, params, DEFAULT_INITIAL_VALUE );
 	}
 
 	protected int determineIncrementSize(Properties params) {
 		return ConfigurationHelper.getInt( INCREMENT_PARAM, params, DEFAULT_INCREMENT_SIZE );
 	}
 
 	@SuppressWarnings("unchecked")
 	protected String buildSelectQuery(Dialect dialect) {
 		final String alias = "tbl";
 		final String query = "select " + StringHelper.qualify( alias, valueColumnName ) +
 				" from " + renderedTableName + ' ' + alias +
 				" where " + StringHelper.qualify( alias, segmentColumnName ) + "=?";
 		final LockOptions lockOptions = new LockOptions( LockMode.PESSIMISTIC_WRITE );
 		lockOptions.setAliasSpecificLockMode( alias, LockMode.PESSIMISTIC_WRITE );
 		final Map updateTargetColumnsMap = Collections.singletonMap( alias, new String[] { valueColumnName } );
 		return dialect.applyLocksToSql( query, lockOptions, updateTargetColumnsMap );
 	}
 
 	protected String buildUpdateQuery() {
 		return "update " + renderedTableName +
 				" set " + valueColumnName + "=? " +
 				" where " + valueColumnName + "=? and " + segmentColumnName + "=?";
 	}
 
 	protected String buildInsertQuery() {
 		return "insert into " + renderedTableName + " (" + segmentColumnName + ", " + valueColumnName + ") " + " values (?,?)";
 	}
 
 	private IntegralDataTypeHolder makeValue() {
 		return IdentifierGeneratorHelper.getIntegralDataTypeHolder( identifierType.getReturnedClass() );
 	}
 
 	@Override
 	public Serializable generate(final SessionImplementor session, final Object obj) {
 		final SqlStatementLogger statementLogger = session.getFactory().getServiceRegistry()
 				.getService( JdbcServices.class )
 				.getSqlStatementLogger();
 		final SessionEventListenerManager statsCollector = session.getEventListenerManager();
 
 		return optimizer.generate(
 				new AccessCallback() {
 					@Override
 					public IntegralDataTypeHolder getNextValue() {
 						return session.getTransactionCoordinator().createIsolationDelegate().delegateWork(
 								new AbstractReturningWork<IntegralDataTypeHolder>() {
 									@Override
 									public IntegralDataTypeHolder execute(Connection connection) throws SQLException {
 										final IntegralDataTypeHolder value = makeValue();
 										int rows;
 										do {
 											final PreparedStatement selectPS = prepareStatement( connection, selectQuery, statementLogger, statsCollector );
 
 											try {
 												selectPS.setString( 1, segmentValue );
 												final ResultSet selectRS = executeQuery( selectPS, statsCollector );
 												if ( !selectRS.next() ) {
 													value.initialize( initialValue );
 
 													final PreparedStatement insertPS = prepareStatement( connection, insertQuery, statementLogger, statsCollector );
 													try {
 														insertPS.setString( 1, segmentValue );
 														value.bind( insertPS, 2 );
 														executeUpdate( insertPS, statsCollector );
 													}
 													finally {
 														insertPS.close();
 													}
 												}
 												else {
 													value.initialize( selectRS, 1 );
 												}
 												selectRS.close();
 											}
 											catch (SQLException e) {
 												LOG.unableToReadOrInitHiValue( e );
 												throw e;
 											}
 											finally {
 												selectPS.close();
 											}
 
 
 											final PreparedStatement updatePS = prepareStatement( connection, updateQuery, statementLogger, statsCollector );
 											try {
 												final IntegralDataTypeHolder updateValue = value.copy();
 												if ( optimizer.applyIncrementSizeToSourceValues() ) {
 													updateValue.add( incrementSize );
 												}
 												else {
 													updateValue.increment();
 												}
 												updateValue.bind( updatePS, 1 );
 												value.bind( updatePS, 2 );
 												updatePS.setString( 3, segmentValue );
 												rows = executeUpdate( updatePS, statsCollector );
 											}
 											catch (SQLException e) {
 												LOG.unableToUpdateQueryHiValue( renderedTableName, e );
 												throw e;
 											}
 											finally {
 												updatePS.close();
 											}
 										}
 										while ( rows == 0 );
 
 										accessCount++;
 
 										return value;
 									}
 								},
 								true
 						);
 					}
 
 					@Override
 					public String getTenantIdentifier() {
 						return session.getTenantIdentifier();
 					}
 				}
 		);
 	}
 
 	private PreparedStatement prepareStatement(
 			Connection connection,
 			String sql,
 			SqlStatementLogger statementLogger,
 			SessionEventListenerManager statsCollector) throws SQLException {
 		statementLogger.logStatement( sql, FormatStyle.BASIC.getFormatter() );
 		try {
 			statsCollector.jdbcPrepareStatementStart();
 			return connection.prepareStatement( sql );
 		}
 		finally {
 			statsCollector.jdbcPrepareStatementEnd();
 		}
 	}
 
 	private int executeUpdate(PreparedStatement ps, SessionEventListenerManager statsCollector) throws SQLException {
 		try {
 			statsCollector.jdbcExecuteStatementStart();
 			return ps.executeUpdate();
 		}
 		finally {
 			statsCollector.jdbcExecuteStatementEnd();
 		}
 
 	}
 
 	private ResultSet executeQuery(PreparedStatement ps, SessionEventListenerManager statsCollector) throws SQLException {
 		try {
 			statsCollector.jdbcExecuteStatementStart();
 			return ps.executeQuery();
 		}
 		finally {
 			statsCollector.jdbcExecuteStatementEnd();
 		}
 	}
 
 	@Override
 	public String[] sqlCreateStrings(Dialect dialect) throws HibernateException {
 		return new String[] {
 				dialect.getCreateTableString() + ' ' + renderedTableName + " ( "
 						+ segmentColumnName + ' ' + dialect.getTypeName( Types.VARCHAR, segmentValueLength, 0, 0 ) + " not null "
 						+ ", " + valueColumnName + ' ' + dialect.getTypeName( Types.BIGINT )
 						+ ", primary key ( " + segmentColumnName + " ) )" + dialect.getTableTypeString()
 		};
 	}
 
 	@Override
 	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
 		return new String[] { dialect.getDropTableString( renderedTableName ) };
 	}
 
 	@Override
 	public void registerExportables(Database database) {
 		final Dialect dialect = database.getJdbcEnvironment().getDialect();
 
 		final Schema schema = database.locateSchema(
 				qualifiedTableName.getCatalogName(),
 				qualifiedTableName.getSchemaName()
 		);
 		final Table table = schema.createTable( qualifiedTableName.getObjectName(), false );
 
 		final Column segmentColumn = new ExportableColumn(
 				database,
 				table,
 				segmentColumnName,
 				StringType.INSTANCE,
 				dialect.getTypeName( Types.VARCHAR, segmentValueLength, 0, 0 )
 		);
 		segmentColumn.setNullable( false );
 		table.addColumn( segmentColumn );
 
 		// lol
 		table.setPrimaryKey( new PrimaryKey() );
 		table.getPrimaryKey().setTable( table );
 		table.getPrimaryKey().addColumn( segmentColumn );
 
 		final Column valueColumn = new ExportableColumn(
 				database,
 				table,
 				valueColumnName,
 				LongType.INSTANCE
 		);
 		table.addColumn( valueColumn );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/factory/internal/DefaultIdentifierGeneratorFactory.java b/hibernate-core/src/main/java/org/hibernate/id/factory/internal/DefaultIdentifierGeneratorFactory.java
index 83b767082d..6141109204 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/factory/internal/DefaultIdentifierGeneratorFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/factory/internal/DefaultIdentifierGeneratorFactory.java
@@ -1,146 +1,153 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id.factory.internal;
 
 import java.io.Serializable;
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.id.Assigned;
 import org.hibernate.id.Configurable;
 import org.hibernate.id.ForeignGenerator;
 import org.hibernate.id.GUIDGenerator;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.id.IncrementGenerator;
 import org.hibernate.id.SelectGenerator;
 import org.hibernate.id.SequenceGenerator;
 import org.hibernate.id.SequenceHiLoGenerator;
 import org.hibernate.id.SequenceIdentityGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.UUIDHexGenerator;
 import org.hibernate.id.enhanced.SequenceStyleGenerator;
 import org.hibernate.id.enhanced.TableGenerator;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.type.Type;
 
 /**
  * Basic <tt>templated</tt> support for {@link org.hibernate.id.factory.IdentifierGeneratorFactory} implementations.
  *
  * @author Steve Ebersole
  */
 public class DefaultIdentifierGeneratorFactory
 		implements MutableIdentifierGeneratorFactory, Serializable, ServiceRegistryAwareService {
 
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultIdentifierGeneratorFactory.class );
 
-	private JdbcEnvironment jdbcEnvironment;
+	private ServiceRegistry serviceRegistry;
+	private Dialect dialect;
+
 	private ConcurrentHashMap<String, Class> generatorStrategyToClassNameMap = new ConcurrentHashMap<String, Class>();
 
 	/**
 	 * Constructs a new DefaultIdentifierGeneratorFactory.
 	 */
+	@SuppressWarnings("deprecation")
 	public DefaultIdentifierGeneratorFactory() {
 		register( "uuid2", UUIDGenerator.class );
 		register( "guid", GUIDGenerator.class );			// can be done with UUIDGenerator + strategy
 		register( "uuid", UUIDHexGenerator.class );			// "deprecated" for new use
 		register( "uuid.hex", UUIDHexGenerator.class ); 	// uuid.hex is deprecated
 		register( "assigned", Assigned.class );
 		register( "identity", IdentityGenerator.class );
 		register( "select", SelectGenerator.class );
 		register( "sequence", SequenceGenerator.class );
 		register( "seqhilo", SequenceHiLoGenerator.class );
 		register( "increment", IncrementGenerator.class );
 		register( "foreign", ForeignGenerator.class );
 		register( "sequence-identity", SequenceIdentityGenerator.class );
 		register( "enhanced-sequence", SequenceStyleGenerator.class );
 		register( "enhanced-table", TableGenerator.class );
 	}
 
 	public void register(String strategy, Class generatorClass) {
 		LOG.debugf( "Registering IdentifierGenerator strategy [%s] -> [%s]", strategy, generatorClass.getName() );
 		final Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );
 		if ( previous != null ) {
 			LOG.debugf( "    - overriding [%s]", previous.getName() );
 		}
 	}
 
 	@Override
 	public Dialect getDialect() {
-		return jdbcEnvironment.getDialect();
+		return dialect;
 	}
 
 	@Override
 	public void setDialect(Dialect dialect) {
 //		LOG.debugf( "Setting dialect [%s]", dialect );
 //		this.dialect = dialect;
 //
 //		if ( dialect == jdbcEnvironment.getDialect() ) {
 //			LOG.debugf(
 //					"Call to unsupported method IdentifierGeneratorFactory#setDialect; " +
 //							"ignoring as passed Dialect matches internal Dialect"
 //			);
 //		}
 //		else {
 //			throw new UnsupportedOperationException(
 //					"Call to unsupported method IdentifierGeneratorFactory#setDialect attempting to" +
 //							"set a non-matching Dialect : " + dialect.getClass().getName()
 //			);
 //		}
 	}
 
 	@Override
 	public IdentifierGenerator createIdentifierGenerator(String strategy, Type type, Properties config) {
 		try {
 			Class clazz = getIdentifierGeneratorClass( strategy );
 			IdentifierGenerator identifierGenerator = ( IdentifierGenerator ) clazz.newInstance();
 			if ( identifierGenerator instanceof Configurable ) {
-				( ( Configurable ) identifierGenerator ).configure( type, config, jdbcEnvironment );
+				( ( Configurable ) identifierGenerator ).configure( type, config, serviceRegistry );
 			}
 			return identifierGenerator;
 		}
 		catch ( Exception e ) {
 			final String entityName = config.getProperty( IdentifierGenerator.ENTITY_NAME );
 			throw new MappingException( String.format( "Could not instantiate id generator [entity-name=%s]", entityName ), e );
 		}
 	}
 
 	@Override
 	public Class getIdentifierGeneratorClass(String strategy) {
 		if ( "native".equals( strategy ) ) {
 			return getDialect().getNativeIdentifierGeneratorClass();
 		}
 
 		if ( "hilo".equals( strategy ) ) {
 			throw new UnsupportedOperationException( "Support for 'hilo' generator has been removed" );
 		}
 
 		Class generatorClass = generatorStrategyToClassNameMap.get( strategy );
 		try {
 			if ( generatorClass == null ) {
-				generatorClass = ReflectHelper.classForName( strategy );
+				final ClassLoaderService cls = serviceRegistry.getService( ClassLoaderService.class );
+				generatorClass = cls.classForName( strategy );
 			}
 		}
-		catch ( ClassNotFoundException e ) {
+		catch ( ClassLoadingException e ) {
 			throw new MappingException( String.format( "Could not interpret id generator strategy [%s]", strategy ) );
 		}
 		return generatorClass;
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
-		this.jdbcEnvironment = serviceRegistry.getService( JdbcEnvironment.class );
+		this.serviceRegistry = serviceRegistry;
+		this.dialect = serviceRegistry.getService( JdbcEnvironment.class ).getDialect();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
index e7c2717642..9c7300701d 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
@@ -1,1031 +1,1036 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.ParameterMetadata;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.TypedValue;
 import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.util.MarkerObject;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.BuiltInPropertyAccessStrategies;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
 import org.hibernate.proxy.HibernateProxyHelper;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.SerializableType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * Abstract implementation of the Query interface.
  *
  * @author Gavin King
  * @author Max Andersen
  */
 public abstract class AbstractQueryImpl implements Query {
 	private static final CoreMessageLogger log = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractQueryImpl.class.getName()
 	);
 
 	private static final Object UNSET_PARAMETER = new MarkerObject( "<unset parameter>" );
 	private static final Object UNSET_TYPE = new MarkerObject( "<unset type>" );
 
 	private final String queryString;
 	protected final SessionImplementor session;
 	protected final ParameterMetadata parameterMetadata;
 
 	// parameter bind values...
 	private List values = new ArrayList( 4 );
 	private List types = new ArrayList( 4 );
 	private Map<String, TypedValue> namedParameters = new HashMap<String, TypedValue>( 4 );
 	private Map<String, TypedValue> namedParameterLists = new HashMap<String, TypedValue>( 4 );
 
 	private Object optionalObject;
 	private Serializable optionalId;
 	private String optionalEntityName;
 
 	private RowSelection selection;
 	private boolean cacheable;
 	private String cacheRegion;
 	private String comment;
 	private final List<String> queryHints = new ArrayList<String>();
 	private FlushMode flushMode;
 	private CacheMode cacheMode;
 	private FlushMode sessionFlushMode;
 	private CacheMode sessionCacheMode;
 	private Serializable collectionKey;
 	private Boolean readOnly;
 	private ResultTransformer resultTransformer;
 
 	private HQLQueryPlan queryPlan;
 
 	public AbstractQueryImpl(
 			String queryString,
 			FlushMode flushMode,
 			SessionImplementor session,
 			ParameterMetadata parameterMetadata) {
 		this.session = session;
 		this.queryString = queryString;
 		this.selection = new RowSelection();
 		this.flushMode = flushMode;
 		this.cacheMode = null;
 		this.parameterMetadata = parameterMetadata;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	@Override
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + '(' + queryString + ')';
 	}
 
 	@Override
 	public final String getQueryString() {
 		return queryString;
 	}
 
 	@Override
 	public boolean isCacheable() {
 		return cacheable;
 	}
 
 	@Override
 	public Query setCacheable(boolean cacheable) {
 		this.cacheable = cacheable;
 		return this;
 	}
 
 	@Override
 	public String getCacheRegion() {
 		return cacheRegion;
 	}
 
 	@Override
 	public Query setCacheRegion(String cacheRegion) {
 		if ( cacheRegion != null ) {
 			this.cacheRegion = cacheRegion.trim();
 		}
 		return this;
 	}
 
 	@Override
 	public FlushMode getFlushMode() {
 		return flushMode;
 	}
 
 	@Override
 	public Query setFlushMode(FlushMode flushMode) {
 		this.flushMode = flushMode;
 		return this;
 	}
 
 	@Override
 	public CacheMode getCacheMode() {
 		return cacheMode;
 	}
 
 	@Override
 	public Query setCacheMode(CacheMode cacheMode) {
 		this.cacheMode = cacheMode;
 		return this;
 	}
 
 	@Override
 	public String getComment() {
 		return comment;
 	}
 
 	@Override
 	public Query setComment(String comment) {
 		this.comment = comment;
 		return this;
 	}
 
 	@Override
 	public Query addQueryHint(String queryHint) {
 		queryHints.add( queryHint );
 		return this;
 	}
 
 	@Override
 	public Integer getFirstResult() {
 		return selection.getFirstRow();
 	}
 
 	@Override
 	public Query setFirstResult(int firstResult) {
 		selection.setFirstRow( firstResult );
 		return this;
 	}
 
 	@Override
 	public Integer getMaxResults() {
 		return selection.getMaxRows();
 	}
 
 	@Override
 	public Query setMaxResults(int maxResults) {
 		if ( maxResults <= 0 ) {
 			// treat zero and negatives specically as meaning no limit...
 			selection.setMaxRows( null );
 		}
 		else {
 			selection.setMaxRows( maxResults );
 		}
 		return this;
 	}
 
 	@Override
 	public Integer getTimeout() {
 		return selection.getTimeout();
 	}
 
 	@Override
 	public Query setTimeout(int timeout) {
 		selection.setTimeout( timeout );
 		return this;
 	}
 
 	@Override
 	public Integer getFetchSize() {
 		return selection.getFetchSize();
 	}
 
 	@Override
 	public Query setFetchSize(int fetchSize) {
 		selection.setFetchSize( fetchSize );
 		return this;
 	}
 
 	public Type[] getReturnTypes() throws HibernateException {
 		return session.getFactory().getReturnTypes( queryString );
 	}
 
 	public String[] getReturnAliases() throws HibernateException {
 		return session.getFactory().getReturnAliases( queryString );
 	}
 
 	public Query setCollectionKey(Serializable collectionKey) {
 		this.collectionKey = collectionKey;
 		return this;
 	}
 
 	@Override
 	public boolean isReadOnly() {
 		return ( readOnly == null ?
 				getSession().getPersistenceContext().isDefaultReadOnly() :
 				readOnly
 		);
 	}
 
 	@Override
 	public Query setReadOnly(boolean readOnly) {
 		this.readOnly = readOnly;
 		return this;
 	}
 
 	@Override
 	public Query setResultTransformer(ResultTransformer transformer) {
 		this.resultTransformer = transformer;
 		return this;
 	}
 
 	public void setOptionalEntityName(String optionalEntityName) {
 		this.optionalEntityName = optionalEntityName;
 	}
 
 	public void setOptionalId(Serializable optionalId) {
 		this.optionalId = optionalId;
 	}
 
 	public void setOptionalObject(Object optionalObject) {
 		this.optionalObject = optionalObject;
 	}
 
 	SessionImplementor getSession() {
 		return session;
 	}
 
 	@Override
 	public abstract LockOptions getLockOptions();
 
 
 	// Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Returns a shallow copy of the named parameter value map.
 	 *
 	 * @return Shallow copy of the named parameter value map
 	 */
 	protected Map<String, TypedValue> getNamedParams() {
 		return new HashMap<String, TypedValue>( namedParameters );
 	}
 
 	/**
 	 * Returns an array representing all named parameter names encountered
 	 * during (intial) parsing of the query.
 	 * <p/>
 	 * Note <i>initial</i> here means different things depending on whether
 	 * this is a native-sql query or an HQL/filter query.  For native-sql, a
 	 * precursory inspection of the query string is performed specifically to
 	 * locate defined parameters.  For HQL/filter queries, this is the
 	 * information returned from the query-translator.  This distinction
 	 * holds true for all parameter metadata exposed here.
 	 *
 	 * @return Array of named parameter names.
 	 *
 	 * @throws HibernateException
 	 */
 	@Override
 	public String[] getNamedParameters() throws HibernateException {
 		return ArrayHelper.toStringArray( parameterMetadata.getNamedParameterNames() );
 	}
 
 	/**
 	 * Does this query contain named parameters?
 	 *
 	 * @return True if the query was found to contain named parameters; false
 	 * otherwise;
 	 */
 	public boolean hasNamedParameters() {
 		return parameterMetadata.getNamedParameterNames().size() > 0;
 	}
 
 	/**
 	 * Retreive the value map for any named parameter lists (i.e., for
 	 * auto-expansion) bound to this query.
 	 *
 	 * @return The parameter list value map.
 	 */
 	protected Map<String, TypedValue> getNamedParameterLists() {
 		return namedParameterLists;
 	}
 
 	/**
 	 * Retreives the list of parameter values bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter values.
 	 */
 	protected List getValues() {
 		return values;
 	}
 
 	/**
 	 * Retreives the list of parameter {@link Type type}s bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter types.
 	 */
 	protected List getTypes() {
 		return types;
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @throws QueryException
 	 */
 	protected void verifyParameters() throws QueryException {
 		verifyParameters( false );
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @param reserveFirstParameter if true, the first ? will not be verified since
 	 * its needed for e.g. callable statements returning a out parameter
 	 *
 	 * @throws HibernateException
 	 */
 	protected void verifyParameters(boolean reserveFirstParameter) throws HibernateException {
 		if ( parameterMetadata.getNamedParameterNames()
 				.size() != namedParameters.size() + namedParameterLists.size() ) {
 			Set<String> missingParams = new HashSet<String>( parameterMetadata.getNamedParameterNames() );
 			missingParams.removeAll( namedParameterLists.keySet() );
 			missingParams.removeAll( namedParameters.keySet() );
 			throw new QueryException( "Not all named parameters have been set: " + missingParams, getQueryString() );
 		}
 
 		int positionalValueSpan = 0;
 		for ( int i = 0; i < values.size(); i++ ) {
 			Object object = types.get( i );
 			if ( values.get( i ) == UNSET_PARAMETER || object == UNSET_TYPE ) {
 				if ( reserveFirstParameter && i == 0 ) {
 					continue;
 				}
 				else {
 					throw new QueryException( "Unset positional parameter at position: " + i, getQueryString() );
 				}
 			}
 			positionalValueSpan += ( (Type) object ).getColumnSpan( session.getFactory() );
 		}
 
 		if ( parameterMetadata.getOrdinalParameterCount() != positionalValueSpan ) {
 			if ( reserveFirstParameter && parameterMetadata.getOrdinalParameterCount() - 1 != positionalValueSpan ) {
 				throw new QueryException(
 						"Expected positional parameter count: " +
 								( parameterMetadata.getOrdinalParameterCount() - 1 ) +
 								", actual parameters: " +
 								values,
 						getQueryString()
 				);
 			}
 			else if ( !reserveFirstParameter ) {
 				throw new QueryException(
 						"Expected positional parameter count: " +
 								parameterMetadata.getOrdinalParameterCount() +
 								", actual parameters: " +
 								values,
 						getQueryString()
 				);
 			}
 		}
 	}
 
 	public Query setParameter(int position, Object val, Type type) {
 		if ( parameterMetadata.getOrdinalParameterCount() == 0 ) {
 			throw new IllegalArgumentException( "No positional parameters in query: " + getQueryString() );
 		}
 		if ( position < 0 || position > parameterMetadata.getOrdinalParameterCount() - 1 ) {
 			throw new IllegalArgumentException( "Positional parameter does not exist: " + position + " in query: " + getQueryString() );
 		}
 		int size = values.size();
 		if ( position < size ) {
 			values.set( position, val );
 			types.set( position, type );
 		}
 		else {
 			// prepend value and type list with null for any positions before the wanted position.
 			for ( int i = 0; i < position - size; i++ ) {
 				values.add( UNSET_PARAMETER );
 				types.add( UNSET_TYPE );
 			}
 			values.add( val );
 			types.add( type );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val, Type type) {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException( "Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]" );
 		}
 		else {
 			namedParameters.put( name, new TypedValue( type, val ) );
 			return this;
 		}
 	}
 
 	public Query setParameter(int position, Object val) throws HibernateException {
 		if ( val == null ) {
 			setParameter( position, val, StandardBasicTypes.SERIALIZABLE );
 		}
 		else {
 			setParameter( position, val, determineType( position, val ) );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val) throws HibernateException {
 		if ( val == null ) {
 			Type type = parameterMetadata.getNamedParameterExpectedType( name );
 			if ( type == null ) {
 				type = StandardBasicTypes.SERIALIZABLE;
 			}
 			setParameter( name, val, type );
 		}
 		else {
 			setParameter( name, val, determineType( name, val ) );
 		}
 		return this;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Class clazz) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( clazz );
 		}
 		return type;
 	}
 
 	private Type guessType(Object param) throws HibernateException {
 		Class clazz = HibernateProxyHelper.getClassWithoutInitializingProxy( param );
 		return guessType( clazz );
 	}
 
 	private Type guessType(Class clazz) throws HibernateException {
 		String typename = clazz.getName();
 		Type type = session.getFactory().getTypeResolver().heuristicType( typename );
 		boolean serializable = type != null && type instanceof SerializableType;
 		if ( type == null || serializable ) {
 			try {
 				session.getFactory().getEntityPersister( clazz.getName() );
 			}
 			catch (MappingException me) {
 				if ( serializable ) {
 					return type;
 				}
 				else {
 					throw new HibernateException( "Could not determine a type for class: " + typename );
 				}
 			}
 			return ( (Session) session ).getTypeHelper().entity( clazz );
 		}
 		else {
 			return type;
 		}
 	}
 
 	public Query setString(int position, String val) {
 		setParameter( position, val, StandardBasicTypes.STRING );
 		return this;
 	}
 
 	public Query setCharacter(int position, char val) {
 		setParameter( position, Character.valueOf( val ), StandardBasicTypes.CHARACTER );
 		return this;
 	}
 
 	public Query setBoolean(int position, boolean val) {
 		Boolean valueToUse = val;
 		Type typeToUse = determineType( position, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( position, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(int position, byte val) {
 		setParameter( position, val, StandardBasicTypes.BYTE );
 		return this;
 	}
 
 	public Query setShort(int position, short val) {
 		setParameter( position, val, StandardBasicTypes.SHORT );
 		return this;
 	}
 
 	public Query setInteger(int position, int val) {
 		setParameter( position, val, StandardBasicTypes.INTEGER );
 		return this;
 	}
 
 	public Query setLong(int position, long val) {
 		setParameter( position, val, StandardBasicTypes.LONG );
 		return this;
 	}
 
 	public Query setFloat(int position, float val) {
 		setParameter( position, val, StandardBasicTypes.FLOAT );
 		return this;
 	}
 
 	public Query setDouble(int position, double val) {
 		setParameter( position, val, StandardBasicTypes.DOUBLE );
 		return this;
 	}
 
 	public Query setBinary(int position, byte[] val) {
 		setParameter( position, val, StandardBasicTypes.BINARY );
 		return this;
 	}
 
 	public Query setText(int position, String val) {
 		setParameter( position, val, StandardBasicTypes.TEXT );
 		return this;
 	}
 
 	public Query setSerializable(int position, Serializable val) {
 		setParameter( position, val, StandardBasicTypes.SERIALIZABLE );
 		return this;
 	}
 
 	public Query setDate(int position, Date date) {
 		setParameter( position, date, StandardBasicTypes.DATE );
 		return this;
 	}
 
 	public Query setTime(int position, Date date) {
 		setParameter( position, date, StandardBasicTypes.TIME );
 		return this;
 	}
 
 	public Query setTimestamp(int position, Date date) {
 		setParameter( position, date, StandardBasicTypes.TIMESTAMP );
 		return this;
 	}
 
 	public Query setEntity(int position, Object val) {
 		setParameter( position, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	private String resolveEntityName(Object val) {
 		if ( val == null ) {
 			throw new IllegalArgumentException( "entity for parameter binding cannot be null" );
 		}
 		return session.bestGuessEntityName( val );
 	}
 
 	public Query setLocale(int position, Locale locale) {
 		setParameter( position, locale, StandardBasicTypes.LOCALE );
 		return this;
 	}
 
 	public Query setCalendar(int position, Calendar calendar) {
 		setParameter( position, calendar, StandardBasicTypes.CALENDAR );
 		return this;
 	}
 
 	public Query setCalendarDate(int position, Calendar calendar) {
 		setParameter( position, calendar, StandardBasicTypes.CALENDAR_DATE );
 		return this;
 	}
 
 	public Query setBinary(String name, byte[] val) {
 		setParameter( name, val, StandardBasicTypes.BINARY );
 		return this;
 	}
 
 	public Query setText(String name, String val) {
 		setParameter( name, val, StandardBasicTypes.TEXT );
 		return this;
 	}
 
 	public Query setBoolean(String name, boolean val) {
 		Boolean valueToUse = val;
 		Type typeToUse = determineType( name, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( name, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(String name, byte val) {
 		setParameter( name, val, StandardBasicTypes.BYTE );
 		return this;
 	}
 
 	public Query setCharacter(String name, char val) {
 		setParameter( name, val, StandardBasicTypes.CHARACTER );
 		return this;
 	}
 
 	public Query setDate(String name, Date date) {
 		setParameter( name, date, StandardBasicTypes.DATE );
 		return this;
 	}
 
 	public Query setDouble(String name, double val) {
 		setParameter( name, val, StandardBasicTypes.DOUBLE );
 		return this;
 	}
 
 	public Query setEntity(String name, Object val) {
 		setParameter( name, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	public Query setFloat(String name, float val) {
 		setParameter( name, val, StandardBasicTypes.FLOAT );
 		return this;
 	}
 
 	public Query setInteger(String name, int val) {
 		setParameter( name, val, StandardBasicTypes.INTEGER );
 		return this;
 	}
 
 	public Query setLocale(String name, Locale locale) {
 		setParameter( name, locale, StandardBasicTypes.LOCALE );
 		return this;
 	}
 
 	public Query setCalendar(String name, Calendar calendar) {
 		setParameter( name, calendar, StandardBasicTypes.CALENDAR );
 		return this;
 	}
 
 	public Query setCalendarDate(String name, Calendar calendar) {
 		setParameter( name, calendar, StandardBasicTypes.CALENDAR_DATE );
 		return this;
 	}
 
 	public Query setLong(String name, long val) {
 		setParameter( name, val, StandardBasicTypes.LONG );
 		return this;
 	}
 
 	public Query setSerializable(String name, Serializable val) {
 		setParameter( name, val, StandardBasicTypes.SERIALIZABLE );
 		return this;
 	}
 
 	public Query setShort(String name, short val) {
 		setParameter( name, val, StandardBasicTypes.SHORT );
 		return this;
 	}
 
 	public Query setString(String name, String val) {
 		setParameter( name, val, StandardBasicTypes.STRING );
 		return this;
 	}
 
 	public Query setTime(String name, Date date) {
 		setParameter( name, date, StandardBasicTypes.TIME );
 		return this;
 	}
 
 	public Query setTimestamp(String name, Date date) {
 		setParameter( name, date, StandardBasicTypes.TIMESTAMP );
 		return this;
 	}
 
 	public Query setBigDecimal(int position, BigDecimal number) {
 		setParameter( position, number, StandardBasicTypes.BIG_DECIMAL );
 		return this;
 	}
 
 	public Query setBigDecimal(String name, BigDecimal number) {
 		setParameter( name, number, StandardBasicTypes.BIG_DECIMAL );
 		return this;
 	}
 
 	public Query setBigInteger(int position, BigInteger number) {
 		setParameter( position, number, StandardBasicTypes.BIG_INTEGER );
 		return this;
 	}
 
 	public Query setBigInteger(String name, BigInteger number) {
 		setParameter( name, number, StandardBasicTypes.BIG_INTEGER );
 		return this;
 	}
 
 	@Override
 	public Query setParameterList(String name, Collection vals, Type type) throws HibernateException {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException( "Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]" );
 		}
 		namedParameterLists.put( name, new TypedValue( type, vals ) );
 		return this;
 	}
 
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	protected String expandParameterLists(Map namedParamsCopy) {
 		String query = this.queryString;
 		for ( Map.Entry<String, TypedValue> stringTypedValueEntry : namedParameterLists.entrySet() ) {
 			Map.Entry me = (Map.Entry) stringTypedValueEntry;
 			query = expandParameterList( query, (String) me.getKey(), (TypedValue) me.getValue(), namedParamsCopy );
 		}
 		return query;
 	}
 
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	private String expandParameterList(String query, String name, TypedValue typedList, Map namedParamsCopy) {
 		Collection vals = (Collection) typedList.getValue();
 
 		// HHH-1123
 		// Some DBs limit number of IN expressions.  For now, warn...
 		final Dialect dialect = session.getFactory().getDialect();
 		final int inExprLimit = dialect.getInExpressionCountLimit();
 		if ( inExprLimit > 0 && vals.size() > inExprLimit ) {
 			log.tooManyInExpressions( dialect.getClass().getName(), inExprLimit, name, vals.size() );
 		}
 
 		Type type = typedList.getType();
 
 		boolean isJpaPositionalParam = parameterMetadata.getNamedParameterDescriptor( name ).isJpaStyle();
 		String paramPrefix = isJpaPositionalParam ? "?" : ParserHelper.HQL_VARIABLE_PREFIX;
 		String placeholder = paramPrefix + name;
 
 		if ( query == null ) {
 			return null;
 		}
 		int loc = query.indexOf( placeholder );
 
 		if ( loc < 0 ) {
 			return query;
 		}
 
 		String beforePlaceholder = query.substring( 0, loc );
 		String afterPlaceholder = query.substring( loc + placeholder.length() );
 
 		// check if placeholder is already immediately enclosed in parentheses
 		// (ignoring whitespace)
 		boolean isEnclosedInParens =
 				StringHelper.getLastNonWhitespaceCharacter( beforePlaceholder ) == '(' &&
 						StringHelper.getFirstNonWhitespaceCharacter( afterPlaceholder ) == ')';
 
 		if ( vals.size() == 1 && isEnclosedInParens ) {
 			// short-circuit for performance when only 1 value and the
 			// placeholder is already enclosed in parentheses...
 			namedParamsCopy.put( name, new TypedValue( type, vals.iterator().next() ) );
 			return query;
 		}
 
 		StringBuilder list = new StringBuilder( 16 );
 		Iterator iter = vals.iterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			// Variable 'name' can represent a number or contain digit at the end. Surrounding it with
 			// characters to avoid ambiguous definition after concatenating value of 'i' counter.
 			String alias = ( isJpaPositionalParam ? 'x' + name : name ) + '_' + i++ + '_';
 			if ( namedParamsCopy.put( alias, new TypedValue( type, iter.next() ) ) != null ) {
 				throw new HibernateException( "Repeated usage of alias '" + alias + "' while expanding list parameter." );
 			}
 			list.append( ParserHelper.HQL_VARIABLE_PREFIX ).append( alias );
 			if ( iter.hasNext() ) {
 				list.append( ", " );
 			}
 		}
 		return StringHelper.replace(
 				beforePlaceholder,
 				afterPlaceholder,
 				placeholder.toString(),
 				list.toString(),
 				true,
 				true
 		);
 	}
 
 	public Query setParameterList(String name, Collection vals) throws HibernateException {
 		if ( vals == null ) {
 			throw new QueryException( "Collection must be not null!" );
 		}
 
 		if ( vals.size() == 0 ) {
 			setParameterList( name, vals, null );
 		}
 		else {
 			setParameterList( name, vals, determineType( name, vals.iterator().next() ) );
 		}
 
 		return this;
 	}
 
 	public Query setParameterList(String name, Object[] vals, Type type) throws HibernateException {
 		return setParameterList( name, Arrays.asList( vals ), type );
 	}
 
 	public Query setParameterList(String name, Object[] values) throws HibernateException {
 		return setParameterList( name, Arrays.asList( values ) );
 	}
 
 	public Query setProperties(Map map) throws HibernateException {
 		String[] params = getNamedParameters();
 		for ( int i = 0; i < params.length; i++ ) {
 			String namedParam = params[i];
 			final Object object = map.get( namedParam );
 			if ( object == null ) {
 				continue;
 			}
 			Class retType = object.getClass();
 			if ( Collection.class.isAssignableFrom( retType ) ) {
 				setParameterList( namedParam, (Collection) object );
 			}
 			else if ( retType.isArray() ) {
 				setParameterList( namedParam, (Object[]) object );
 			}
 			else {
 				setParameter( namedParam, object, determineType( namedParam, retType ) );
 			}
 
 
 		}
 		return this;
 	}
 
 	public Query setProperties(Object bean) throws HibernateException {
 		Class clazz = bean.getClass();
 		String[] params = getNamedParameters();
 		for ( String namedParam : params ) {
 			try {
-				Getter getter = ReflectHelper.getGetter( clazz, namedParam );
-				Class retType = getter.getReturnType();
+				final PropertyAccess propertyAccess = BuiltInPropertyAccessStrategies.BASIC.getStrategy().buildPropertyAccess(
+						clazz,
+						namedParam
+				);
+				final Getter getter = propertyAccess.getGetter();
+				final Class retType = getter.getReturnType();
 				final Object object = getter.get( bean );
 				if ( Collection.class.isAssignableFrom( retType ) ) {
 					setParameterList( namedParam, (Collection) object );
 				}
 				else if ( retType.isArray() ) {
 					setParameterList( namedParam, (Object[]) object );
 				}
 				else {
 					setParameter( namedParam, object, determineType( namedParam, retType ) );
 				}
 			}
 			catch (PropertyNotFoundException pnfe) {
 				// ignore
 			}
 		}
 		return this;
 	}
 
 	public Query setParameters(Object[] values, Type[] types) {
 		this.values = Arrays.asList( values );
 		this.types = Arrays.asList( types );
 		return this;
 	}
 
 
 	// Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object uniqueResult() throws HibernateException {
 		return uniqueElement( list() );
 	}
 
 	static Object uniqueElement(List list) throws NonUniqueResultException {
 		int size = list.size();
 		if ( size == 0 ) {
 			return null;
 		}
 		Object first = list.get( 0 );
 		for ( int i = 1; i < size; i++ ) {
 			if ( list.get( i ) != first ) {
 				throw new NonUniqueResultException( list.size() );
 			}
 		}
 		return first;
 	}
 
 	protected RowSelection getRowSelection() {
 		return selection;
 	}
 
 	public Type[] typeArray() {
 		return ArrayHelper.toTypeArray( getTypes() );
 	}
 
 	public Object[] valueArray() {
 		return getValues().toArray();
 	}
 
 	public QueryParameters getQueryParameters(Map namedParams) {
 		QueryParameters queryParameters = new QueryParameters(
 				typeArray(),
 				valueArray(),
 				namedParams,
 				getLockOptions(),
 				getRowSelection(),
 				true,
 				isReadOnly(),
 				cacheable,
 				cacheRegion,
 				comment,
 				queryHints,
 				collectionKey == null ? null : new Serializable[] {collectionKey},
 				optionalObject,
 				optionalEntityName,
 				optionalId,
 				resultTransformer
 		);
 		queryParameters.setQueryPlan( queryPlan );
 		return queryParameters;
 	}
 
 	protected void before() {
 		if ( flushMode != null ) {
 			sessionFlushMode = getSession().getFlushMode();
 			getSession().setFlushMode( flushMode );
 		}
 		if ( cacheMode != null ) {
 			sessionCacheMode = getSession().getCacheMode();
 			getSession().setCacheMode( cacheMode );
 		}
 	}
 
 	protected void after() {
 		if ( sessionFlushMode != null ) {
 			getSession().setFlushMode( sessionFlushMode );
 			sessionFlushMode = null;
 		}
 		if ( sessionCacheMode != null ) {
 			getSession().setCacheMode( sessionCacheMode );
 			sessionCacheMode = null;
 		}
 	}
 
 	public HQLQueryPlan getQueryPlan() {
 		return queryPlan;
 	}
 
 	public void setQueryPlan(HQLQueryPlan queryPlan) {
 		this.queryPlan = queryPlan;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/ClassLoaderHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/ClassLoaderHelper.java
deleted file mode 100644
index aee1c0f829..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/ClassLoaderHelper.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.internal.util;
-
-/**
- * This exists purely to allow custom ClassLoaders to be injected and used
- * prior to ServiceRegistry and ClassLoadingService existence.  This should be
- * replaced in Hibernate 5.
- * 
- * @author Brett Meyer
- */
-public final class ClassLoaderHelper {
-	private ClassLoaderHelper() {
-	}
-
-	public static ClassLoader overridenClassLoader;
-	
-	public static ClassLoader getContextClassLoader() {
-		return overridenClassLoader != null ?
-			overridenClassLoader : Thread.currentThread().getContextClassLoader();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
index d9f5bc3077..f87581521c 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
@@ -1,202 +1,165 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal.util;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * A simple class to centralize logic needed to locate config files on the system.
  *
  * @author Steve Ebersole
- * @todo : Update usages to use {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}
+ *
+ * @deprecated Use {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService} instead
  */
+@Deprecated
 public final class ConfigHelper {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( ConfigHelper.class );
 
 	/**
 	 * Try to locate a local URL representing the incoming path.  The first attempt
 	 * assumes that the incoming path is an actual URL string (file://, etc).  If this
 	 * does not work, then the next attempts try to locate this UURL as a java system
 	 * resource.
 	 *
 	 * @param path The path representing the config location.
 	 *
 	 * @return An appropriate URL or null.
 	 */
 	public static URL locateConfig(final String path) {
 		try {
 			return new URL( path );
 		}
 		catch (MalformedURLException e) {
 			return findAsResource( path );
 		}
 	}
 
 	/**
 	 * Try to locate a local URL representing the incoming path.
 	 * This method <b>only</b> attempts to locate this URL as a
 	 * java system resource.
 	 *
 	 * @param path The path representing the config location.
 	 *
 	 * @return An appropriate URL or null.
 	 */
 	public static URL findAsResource(final String path) {
 		URL url = null;
 
 		// First, try to locate this resource through the current
 		// context classloader.
-		ClassLoader contextClassLoader = ClassLoaderHelper.getContextClassLoader();
+		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
 		if ( contextClassLoader != null ) {
 			url = contextClassLoader.getResource( path );
 		}
 		if ( url != null ) {
 			return url;
 		}
 
 		// Next, try to locate this resource through this class's classloader
 		url = ConfigHelper.class.getClassLoader().getResource( path );
 		if ( url != null ) {
 			return url;
 		}
 
 		// Next, try to locate this resource through the system classloader
 		url = ClassLoader.getSystemClassLoader().getResource( path );
 
 		// Anywhere else we should look?
 		return url;
 	}
 
 	/**
 	 * Open an InputStream to the URL represented by the incoming path.  First makes a call
 	 * to {@link #locateConfig(java.lang.String)} in order to find an appropriate URL.
 	 * {@link java.net.URL#openStream()} is then called to obtain the stream.
 	 *
 	 * @param path The path representing the config location.
 	 *
 	 * @return An input stream to the requested config resource.
 	 *
 	 * @throws HibernateException Unable to open stream to that resource.
 	 */
 	public static InputStream getConfigStream(final String path) throws HibernateException {
 		final URL url = ConfigHelper.locateConfig( path );
 
 		if ( url == null ) {
 			String msg = LOG.unableToLocateConfigFile( path );
 			LOG.error( msg );
 			throw new HibernateException( msg );
 		}
 
 		try {
 			return url.openStream();
 		}
 		catch (IOException e) {
 			throw new HibernateException( "Unable to open config file: " + path, e );
 		}
 	}
 
-	/**
-	 * Open an Reader to the URL represented by the incoming path.  First makes a call
-	 * to {@link #locateConfig(java.lang.String)} in order to find an appropriate URL.
-	 * {@link java.net.URL#openStream()} is then called to obtain a stream, which is then
-	 * wrapped in a Reader.
-	 *
-	 * @param path The path representing the config location.
-	 *
-	 * @return An input stream to the requested config resource.
-	 *
-	 * @throws HibernateException Unable to open reader to that resource.
-	 */
-	public static Reader getConfigStreamReader(final String path) throws HibernateException {
-		return new InputStreamReader( getConfigStream( path ) );
-	}
-
-	/**
-	 * Loads a properties instance based on the data at the incoming config location.
-	 *
-	 * @param path The path representing the config location.
-	 *
-	 * @return The loaded properties instance.
-	 *
-	 * @throws HibernateException Unable to load properties from that resource.
-	 */
-	public static Properties getConfigProperties(String path) throws HibernateException {
-		try {
-			Properties properties = new Properties();
-			properties.load( getConfigStream( path ) );
-			return properties;
-		}
-		catch (IOException e) {
-			throw new HibernateException( "Unable to load properties from specified config file: " + path, e );
-		}
-	}
-
 	private ConfigHelper() {
 	}
 
 	public static InputStream getResourceAsStream(String resource) {
 		String stripped = resource.startsWith( "/" )
 				? resource.substring( 1 )
 				: resource;
 
 		InputStream stream = null;
-		ClassLoader classLoader = ClassLoaderHelper.getContextClassLoader();
+		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 		if ( classLoader != null ) {
 			stream = classLoader.getResourceAsStream( stripped );
 		}
 		if ( stream == null ) {
 			stream = Environment.class.getResourceAsStream( resource );
 		}
 		if ( stream == null ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( stripped );
 		}
 		if ( stream == null ) {
 			throw new HibernateException( resource + " not found" );
 		}
 		return stream;
 	}
 
 
 	public static InputStream getUserResourceAsStream(String resource) {
 		boolean hasLeadingSlash = resource.startsWith( "/" );
 		String stripped = hasLeadingSlash ? resource.substring( 1 ) : resource;
 
 		InputStream stream = null;
 
-		ClassLoader classLoader = ClassLoaderHelper.getContextClassLoader();
+		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 		if ( classLoader != null ) {
 			stream = classLoader.getResourceAsStream( resource );
 			if ( stream == null && hasLeadingSlash ) {
 				stream = classLoader.getResourceAsStream( stripped );
 			}
 		}
 
 		if ( stream == null ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( resource );
 		}
 		if ( stream == null && hasLeadingSlash ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( stripped );
 		}
 
 		if ( stream == null ) {
 			throw new HibernateException( resource + " not found" );
 		}
 
 		return stream;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/ReflectHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/ReflectHelper.java
index 4f0d226fcf..bf425a9174 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/ReflectHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/ReflectHelper.java
@@ -1,363 +1,507 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal.util;
 
+import java.beans.Introspector;
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.Locale;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.MappingException;
 import org.hibernate.PropertyNotFoundException;
-import org.hibernate.property.BasicPropertyAccessor;
-import org.hibernate.property.DirectPropertyAccessor;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMixedImpl;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.type.PrimitiveType;
 import org.hibernate.type.Type;
 
 /**
  * Utility class for various reflection operations.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 @SuppressWarnings("unchecked")
 public final class ReflectHelper {
-
-	//TODO: this dependency is kinda Bad
-	private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();
-	private static final PropertyAccessor DIRECT_PROPERTY_ACCESSOR = new DirectPropertyAccessor();
-
 	public static final Class[] NO_PARAM_SIGNATURE = new Class[0];
 	public static final Object[] NO_PARAMS = new Object[0];
 
 	public static final Class[] SINGLE_OBJECT_PARAM_SIGNATURE = new Class[] { Object.class };
 
 	private static final Method OBJECT_EQUALS;
 	private static final Method OBJECT_HASHCODE;
 
 	static {
 		Method eq;
 		Method hash;
 		try {
 			eq = extractEqualsMethod( Object.class );
 			hash = extractHashCodeMethod( Object.class );
 		}
 		catch ( Exception e ) {
 			throw new AssertionFailure( "Could not find Object.equals() or Object.hashCode()", e );
 		}
 		OBJECT_EQUALS = eq;
 		OBJECT_HASHCODE = hash;
 	}
 
 	/**
 	 * Disallow instantiation of ReflectHelper.
 	 */
 	private ReflectHelper() {
 	}
 
 	/**
 	 * Encapsulation of getting hold of a class's {@link Object#equals equals}  method.
 	 *
 	 * @param clazz The class from which to extract the equals method.
 	 * @return The equals method reference
 	 * @throws NoSuchMethodException Should indicate an attempt to extract equals method from interface.
 	 */
 	public static Method extractEqualsMethod(Class clazz) throws NoSuchMethodException {
 		return clazz.getMethod( "equals", SINGLE_OBJECT_PARAM_SIGNATURE );
 	}
 
 	/**
 	 * Encapsulation of getting hold of a class's {@link Object#hashCode hashCode} method.
 	 *
 	 * @param clazz The class from which to extract the hashCode method.
 	 * @return The hashCode method reference
 	 * @throws NoSuchMethodException Should indicate an attempt to extract hashCode method from interface.
 	 */
 	public static Method extractHashCodeMethod(Class clazz) throws NoSuchMethodException {
 		return clazz.getMethod( "hashCode", NO_PARAM_SIGNATURE );
 	}
 
 	/**
 	 * Determine if the given class defines an {@link Object#equals} override.
 	 *
 	 * @param clazz The class to check
 	 * @return True if clazz defines an equals override.
 	 */
 	public static boolean overridesEquals(Class clazz) {
 		Method equals;
 		try {
 			equals = extractEqualsMethod( clazz );
 		}
 		catch ( NoSuchMethodException nsme ) {
 			return false; //its an interface so we can't really tell anything...
 		}
 		return !OBJECT_EQUALS.equals( equals );
 	}
 
 	/**
 	 * Determine if the given class defines a {@link Object#hashCode} override.
 	 *
 	 * @param clazz The class to check
 	 * @return True if clazz defines an hashCode override.
 	 */
 	public static boolean overridesHashCode(Class clazz) {
 		Method hashCode;
 		try {
 			hashCode = extractHashCodeMethod( clazz );
 		}
 		catch ( NoSuchMethodException nsme ) {
 			return false; //its an interface so we can't really tell anything...
 		}
 		return !OBJECT_HASHCODE.equals( hashCode );
 	}
 
 	/**
 	 * Determine if the given class implements the given interface.
 	 *
 	 * @param clazz The class to check
 	 * @param intf The interface to check it against.
 	 * @return True if the class does implement the interface, false otherwise.
 	 */
 	public static boolean implementsInterface(Class clazz, Class intf) {
 		assert intf.isInterface() : "Interface to check was not an interface";
 		return intf.isAssignableFrom( clazz );
 	}
 
 	/**
 	 * Perform resolution of a class name.
 	 * <p/>
 	 * Here we first check the context classloader, if one, before delegating to
 	 * {@link Class#forName(String, boolean, ClassLoader)} using the caller's classloader
 	 *
 	 * @param name The class name
 	 * @param caller The class from which this call originated (in order to access that class's loader).
 	 * @return The class reference.
 	 * @throws ClassNotFoundException From {@link Class#forName(String, boolean, ClassLoader)}.
 	 */
 	public static Class classForName(String name, Class caller) throws ClassNotFoundException {
 		try {
-			ClassLoader classLoader = ClassLoaderHelper.getContextClassLoader();
+			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 			if ( classLoader != null ) {
 				return classLoader.loadClass( name );
 			}
 		}
 		catch ( Throwable ignore ) {
 		}
 		return Class.forName( name, true, caller.getClassLoader() );
 	}
 
 	/**
 	 * Perform resolution of a class name.
 	 * <p/>
 	 * Same as {@link #classForName(String, Class)} except that here we delegate to
 	 * {@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 	 *
 	 * @param name The class name
 	 * @return The class reference.
+	 *
 	 * @throws ClassNotFoundException From {@link Class#forName(String)}.
+	 *
+	 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}
+	 * or {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 	 */
+	@Deprecated
 	public static Class classForName(String name) throws ClassNotFoundException {
 		try {
-			ClassLoader classLoader = ClassLoaderHelper.getContextClassLoader();
+			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 			if ( classLoader != null ) {
 				return classLoader.loadClass(name);
 			}
 		}
 		catch ( Throwable ignore ) {
 		}
 		return Class.forName( name );
 	}
 
 	/**
 	 * Is this member publicly accessible.
-	 * <p/>
-	 * Short-hand for {@link #isPublic(Class, Member)} passing the member + {@link Member#getDeclaringClass()}
-	 *
-	 * @param member The member to check
-	 * @return True if the member is publicly accessible.
-	 */
-	public static boolean isPublic(Member member) {
-		return isPublic( member.getDeclaringClass(), member );
-	}
-
-	/**
-	 * Is this member publicly accessible.
 	 *
 	 * @param clazz The class which defines the member
 	 * @param member The memeber.
 	 * @return True if the member is publicly accessible, false otherwise.
 	 */
 	public static boolean isPublic(Class clazz, Member member) {
 		return Modifier.isPublic( member.getModifiers() ) && Modifier.isPublic( clazz.getModifiers() );
 	}
 
 	/**
 	 * Attempt to resolve the specified property type through reflection.
 	 *
 	 * @param className The name of the class owning the property.
 	 * @param name The name of the property.
+	 * @param classLoaderService ClassLoader services
+	 *
 	 * @return The type of the property.
+	 *
 	 * @throws MappingException Indicates we were unable to locate the property.
 	 */
-	public static Class reflectedPropertyClass(String className, String name) throws MappingException {
+	public static Class reflectedPropertyClass(
+			String className,
+			String name,
+			ClassLoaderService classLoaderService) throws MappingException {
 		try {
-			Class clazz = ReflectHelper.classForName( className );
+			Class clazz = classLoaderService.classForName( className );
 			return getter( clazz, name ).getReturnType();
 		}
-		catch ( ClassNotFoundException cnfe ) {
-			throw new MappingException( "class " + className + " not found while looking for property: " + name, cnfe );
+		catch ( ClassLoadingException e ) {
+			throw new MappingException( "class " + className + " not found while looking for property: " + name, e );
 		}
 	}
 
 	/**
 	 * Attempt to resolve the specified property type through reflection.
 	 *
 	 * @param clazz The class owning the property.
 	 * @param name The name of the property.
 	 * @return The type of the property.
 	 * @throws MappingException Indicates we were unable to locate the property.
 	 */
 	public static Class reflectedPropertyClass(Class clazz, String name) throws MappingException {
 		return getter( clazz, name ).getReturnType();
 	}
 
 	private static Getter getter(Class clazz, String name) throws MappingException {
-		try {
-			return BASIC_PROPERTY_ACCESSOR.getGetter( clazz, name );
-		}
-		catch ( PropertyNotFoundException pnfe ) {
-			return DIRECT_PROPERTY_ACCESSOR.getGetter( clazz, name );
-		}
-	}
-
-	/**
-	 * Directly retrieve the {@link Getter} reference via the {@link BasicPropertyAccessor}.
-	 *
-	 * @param theClass The class owning the property
-	 * @param name The name of the property
-	 * @return The getter.
-	 * @throws MappingException Indicates we were unable to locate the property.
-	 */
-	public static Getter getGetter(Class theClass, String name) throws MappingException {
-		return BASIC_PROPERTY_ACCESSOR.getGetter( theClass, name );
+		return PropertyAccessStrategyMixedImpl.INSTANCE.buildPropertyAccess( clazz, name ).getGetter();
 	}
 
-	/**
-	 * Resolve a constant to its actual value.
-	 *
-	 * @param name The name
-	 * @return The value
-	 */
-	public static Object getConstantValue(String name) {
+	public static Object getConstantValue(String name, ClassLoaderService classLoaderService) {
 		Class clazz;
 		try {
-			clazz = classForName( StringHelper.qualifier( name ) );
+			clazz = classLoaderService.classForName( StringHelper.qualifier( name ) );
 		}
 		catch ( Throwable t ) {
 			return null;
 		}
 		try {
 			return clazz.getField( StringHelper.unqualify( name ) ).get( null );
 		}
 		catch ( Throwable t ) {
 			return null;
 		}
 	}
 
 	/**
 	 * Retrieve the default (no arg) constructor from the given class.
 	 *
 	 * @param clazz The class for which to retrieve the default ctor.
 	 * @return The default constructor.
 	 * @throws PropertyNotFoundException Indicates there was not publicly accessible, no-arg constructor (todo : why PropertyNotFoundException???)
 	 */
 	public static <T> Constructor<T> getDefaultConstructor(Class<T> clazz) throws PropertyNotFoundException {
 		if ( isAbstractClass( clazz ) ) {
 			return null;
 		}
 
 		try {
 			Constructor<T> constructor = clazz.getDeclaredConstructor( NO_PARAM_SIGNATURE );
 			constructor.setAccessible( true );
 			return constructor;
 		}
 		catch ( NoSuchMethodException nme ) {
 			throw new PropertyNotFoundException(
 					"Object class [" + clazz.getName() + "] must declare a default (no-argument) constructor"
 			);
 		}
 	}
 
 	/**
 	 * Determine if the given class is declared abstract.
 	 *
 	 * @param clazz The class to check.
 	 * @return True if the class is abstract, false otherwise.
 	 */
 	public static boolean isAbstractClass(Class clazz) {
 		int modifier = clazz.getModifiers();
 		return Modifier.isAbstract(modifier) || Modifier.isInterface(modifier);
 	}
 
 	/**
 	 * Determine is the given class is declared final.
 	 *
 	 * @param clazz The class to check.
 	 * @return True if the class is final, flase otherwise.
 	 */
 	public static boolean isFinalClass(Class clazz) {
 		return Modifier.isFinal( clazz.getModifiers() );
 	}
 
 	/**
 	 * Retrieve a constructor for the given class, with arguments matching the specified Hibernate mapping
 	 * {@link Type types}.
 	 *
 	 * @param clazz The class needing instantiation
 	 * @param types The types representing the required ctor param signature
 	 * @return The matching constructor.
 	 * @throws PropertyNotFoundException Indicates we could not locate an appropriate constructor (todo : again with PropertyNotFoundException???)
 	 */
 	public static Constructor getConstructor(Class clazz, Type[] types) throws PropertyNotFoundException {
 		final Constructor[] candidates = clazz.getConstructors();
-		for ( int i = 0; i < candidates.length; i++ ) {
-			final Constructor constructor = candidates[i];
+		for ( final Constructor constructor : candidates ) {
 			final Class[] params = constructor.getParameterTypes();
 			if ( params.length == types.length ) {
 				boolean found = true;
 				for ( int j = 0; j < params.length; j++ ) {
 					final boolean ok = params[j].isAssignableFrom( types[j].getReturnedClass() ) || (
 							types[j] instanceof PrimitiveType &&
-									params[j] == ( ( PrimitiveType ) types[j] ).getPrimitiveClass()
+									params[j] == ( (PrimitiveType) types[j] ).getPrimitiveClass()
 					);
 					if ( !ok ) {
 						found = false;
 						break;
 					}
 				}
 				if ( found ) {
 					constructor.setAccessible( true );
 					return constructor;
 				}
 			}
 		}
 		throw new PropertyNotFoundException( "no appropriate constructor in class: " + clazz.getName() );
 	}
 	
 	public static Method getMethod(Class clazz, Method method) {
 		try {
 			return clazz.getMethod( method.getName(), method.getParameterTypes() );
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
+	public static Field findField(Class containerClass, String propertyName) {
+		if ( containerClass == null ) {
+			throw new IllegalArgumentException( "Class on which to find field [" + propertyName + "] cannot be null" );
+		}
+		else if ( containerClass == Object.class ) {
+			throw new IllegalArgumentException( "Illegal attempt to locate field [" + propertyName + "] on Object.class" );
+		}
+
+		Field field = locateField( containerClass, propertyName );
+
+		if ( field == null ) {
+			throw new PropertyNotFoundException(
+					String.format(
+							Locale.ROOT,
+							"Could not locate field name [%s] on class [%s]",
+							propertyName,
+							containerClass.getName()
+					)
+			);
+		}
+
+		field.setAccessible( true );
+		return field;
+	}
+
+	private static Field locateField(Class clazz, String propertyName) {
+		if ( clazz == null || Object.class.equals( clazz ) ) {
+			return null;
+		}
+
+		try {
+			return clazz.getDeclaredField( propertyName );
+		}
+		catch ( NoSuchFieldException nsfe ) {
+			return locateField( clazz.getSuperclass(), propertyName );
+		}
+	}
+
+	public static Method findGetterMethod(Class containerClass, String propertyName) {
+		Class checkClass = containerClass;
+		Method getter = null;
+
+		// check containerClass, and then its super types (if any)
+		while ( getter == null && checkClass != null ) {
+			if ( checkClass.equals( Object.class ) ) {
+				break;
+			}
+
+			getter = getGetterOrNull( checkClass, propertyName );
+			checkClass = checkClass.getSuperclass();
+		}
+
+		// if no getter found yet, check all implemented interfaces
+		if ( getter == null ) {
+			for ( Class theInterface : containerClass.getInterfaces() ) {
+				getter = getGetterOrNull( theInterface, propertyName );
+				if ( getter != null ) {
+					break;
+				}
+			}
+		}
+
+		if ( getter == null ) {
+			throw new PropertyNotFoundException(
+					String.format(
+							Locale.ROOT,
+							"Could not locate getter method for property [%s#%s]",
+							containerClass.getName(),
+							propertyName
+					)
+			);
+		}
+
+		getter.setAccessible( true );
+		return getter;
+	}
+
+	private static Method getGetterOrNull(Class containerClass, String propertyName) {
+		for ( Method method : containerClass.getDeclaredMethods() ) {
+			// if the method has parameters, skip it
+			if ( method.getParameterTypes().length != 0 ) {
+				continue;
+			}
+
+			// if the method is a "bridge", skip it
+			if ( method.isBridge() ) {
+				continue;
+			}
+
+			final String methodName = method.getName();
+
+			// try "get"
+			if ( methodName.startsWith( "get" ) ) {
+				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
+				String testOldMethod = methodName.substring( 3 );
+				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
+					return method;
+				}
+			}
+
+			// if not "get", then try "is"
+			if ( methodName.startsWith( "is" ) ) {
+				String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) );
+				String testOldMethod = methodName.substring( 2 );
+				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
+					return method;
+				}
+			}
+		}
+
+		return null;
+	}
+
+	public static Method findSetterMethod(Class containerClass, String propertyName, Class propertyType) {
+		Class checkClass = containerClass;
+		Method setter = null;
+
+		// check containerClass, and then its super types (if any)
+		while ( setter == null && checkClass != null ) {
+			if ( checkClass.equals( Object.class ) ) {
+				break;
+			}
+
+			setter = setterOrNull( checkClass, propertyName, propertyType );
+			checkClass = checkClass.getSuperclass();
+		}
+
+		// if no setter found yet, check all implemented interfaces
+		if ( setter == null ) {
+			for ( Class theInterface : containerClass.getInterfaces() ) {
+				setter = setterOrNull( theInterface, propertyName, propertyType );
+				if ( setter != null ) {
+					break;
+				}
+			}
+		}
+
+		if ( setter == null ) {
+			throw new PropertyNotFoundException(
+					String.format(
+							Locale.ROOT,
+							"Could not locate setter method for property [%s#%s]",
+							containerClass.getName(),
+							propertyName
+					)
+			);
+		}
+
+		setter.setAccessible( true );
+		return setter;
+	}
+
+	private static Method setterOrNull(Class theClass, String propertyName, Class propertyType) {
+		Method potentialSetter = null;
+
+		for ( Method method : theClass.getDeclaredMethods() ) {
+			final String methodName = method.getName();
+			if ( method.getParameterTypes().length == 1 && methodName.startsWith( "set" ) ) {
+				final String testOldMethod = methodName.substring( 3 );
+				final String testStdMethod = Introspector.decapitalize( testOldMethod );
+				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
+					potentialSetter = method;
+					if ( propertyType == null || method.getParameterTypes()[0].equals( propertyType ) ) {
+						break;
+					}
+				}
+			}
+		}
+
+		return potentialSetter;
+	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/SerializationHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/SerializationHelper.java
index 4a0fb9b4c6..a3e4417b4b 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/SerializationHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/SerializationHelper.java
@@ -1,360 +1,360 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal.util;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamClass;
 import java.io.OutputStream;
 import java.io.Serializable;
 
 import org.hibernate.Hibernate;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.type.SerializationException;
 
 /**
  * <p>Assists with the serialization process and performs additional functionality based
  * on serialization.</p>
  * <p>
  * <ul>
  * <li>Deep clone using serialization
  * <li>Serialize managing finally and IOException
  * <li>Deserialize managing finally and IOException
  * </ul>
  * <p/>
  * <p>This class throws exceptions for invalid <code>null</code> inputs.
  * Each method documents its behaviour in more detail.</p>
  *
  * @author <a href="mailto:nissim@nksystems.com">Nissim Karpenstein</a>
  * @author <a href="mailto:janekdb@yahoo.co.uk">Janek Bogucki</a>
  * @author <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
  * @author Stephen Colebourne
  * @author Jeff Varszegi
  * @author Gary Gregory
  *
  * @since 1.0
  */
 public final class SerializationHelper {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( SerializationHelper.class );
 
 	private SerializationHelper() {
 	}
 
 	// Clone
 	//-----------------------------------------------------------------------
 
 	/**
 	 * <p>Deep clone an <code>Object</code> using serialization.</p>
 	 * <p/>
 	 * <p>This is many times slower than writing clone methods by hand
 	 * on all objects in your object graph. However, for complex object
 	 * graphs, or for those that don't support deep cloning this can
 	 * be a simple alternative implementation. Of course all the objects
 	 * must be <code>Serializable</code>.</p>
 	 *
 	 * @param object the <code>Serializable</code> object to clone
 	 *
 	 * @return the cloned object
 	 *
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static Object clone(Serializable object) throws SerializationException {
 		LOG.trace( "Starting clone through serialization" );
 		if ( object == null ) {
 			return null;
 		}
 		return deserialize( serialize( object ), object.getClass().getClassLoader() );
 	}
 
 	// Serialize
 	//-----------------------------------------------------------------------
 
 	/**
 	 * <p>Serializes an <code>Object</code> to the specified stream.</p>
 	 * <p/>
 	 * <p>The stream will be closed once the object is written.
 	 * This avoids the need for a finally clause, and maybe also exception
 	 * handling, in the application code.</p>
 	 * <p/>
 	 * <p>The stream passed in is not buffered internally within this method.
 	 * This is the responsibility of your application if desired.</p>
 	 *
 	 * @param obj the object to serialize to bytes, may be null
 	 * @param outputStream the stream to write to, must not be null
 	 *
 	 * @throws IllegalArgumentException if <code>outputStream</code> is <code>null</code>
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static void serialize(Serializable obj, OutputStream outputStream) throws SerializationException {
 		if ( outputStream == null ) {
 			throw new IllegalArgumentException( "The OutputStream must not be null" );
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			if ( Hibernate.isInitialized( obj ) ) {
 				LOG.tracev( "Starting serialization of object [{0}]", obj );
 			}
 			else {
 				LOG.trace( "Starting serialization of [uninitialized proxy]" );
 			}
 		}
 
 		ObjectOutputStream out = null;
 		try {
 			// stream closed in the finally
 			out = new ObjectOutputStream( outputStream );
 			out.writeObject( obj );
 
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize", ex );
 		}
 		finally {
 			try {
 				if ( out != null ) {
 					out.close();
 				}
 			}
 			catch (IOException ignored) {
 			}
 		}
 	}
 
 	/**
 	 * <p>Serializes an <code>Object</code> to a byte array for
 	 * storage/serialization.</p>
 	 *
 	 * @param obj the object to serialize to bytes
 	 *
 	 * @return a byte[] with the converted Serializable
 	 *
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static byte[] serialize(Serializable obj) throws SerializationException {
 		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream( 512 );
 		serialize( obj, byteArrayOutputStream );
 		return byteArrayOutputStream.toByteArray();
 	}
 
 	// Deserialize
 	//-----------------------------------------------------------------------
 
 	/**
 	 * Deserializes an object from the specified stream using the Thread Context
 	 * ClassLoader (TCCL).
 	 * <p/>
 	 * Delegates to {@link #doDeserialize}
 	 *
 	 * @param inputStream the serialized object input stream, must not be null
 	 *
 	 * @return the deserialized object
 	 *
 	 * @throws IllegalArgumentException if <code>inputStream</code> is <code>null</code>
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static <T> T deserialize(InputStream inputStream) throws SerializationException {
 		return doDeserialize( inputStream, defaultClassLoader(), hibernateClassLoader(), null );
 	}
 
 	/**
 	 * Returns the Thread Context ClassLoader (TCCL).
 	 *
 	 * @return The current TCCL
 	 */
 	public static ClassLoader defaultClassLoader() {
-		return ClassLoaderHelper.getContextClassLoader();
+		return Thread.currentThread().getContextClassLoader();
 	}
 
 	public static ClassLoader hibernateClassLoader() {
 		return SerializationHelper.class.getClassLoader();
 	}
 
 	/**
 	 * Deserializes an object from the specified stream using the Thread Context
 	 * ClassLoader (TCCL).  If there is no TCCL set, the classloader of the calling
 	 * class is used.
 	 * <p/>
 	 * The stream will be closed once the object is read. This avoids the need
 	 * for a finally clause, and maybe also exception handling, in the application
 	 * code.
 	 * <p/>
 	 * The stream passed in is not buffered internally within this method.  This is
 	 * the responsibility of the caller, if desired.
 	 *
 	 * @param inputStream the serialized object input stream, must not be null
 	 * @param loader The classloader to use
 	 *
 	 * @return the deserialized object
 	 *
 	 * @throws IllegalArgumentException if <code>inputStream</code> is <code>null</code>
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static Object deserialize(InputStream inputStream, ClassLoader loader) throws SerializationException {
 		return doDeserialize( inputStream, loader, defaultClassLoader(), hibernateClassLoader() );
 	}
 
 	@SuppressWarnings("unchecked")
 	public static <T> T doDeserialize(
 			InputStream inputStream,
 			ClassLoader loader,
 			ClassLoader fallbackLoader1,
 			ClassLoader fallbackLoader2) throws SerializationException {
 		if ( inputStream == null ) {
 			throw new IllegalArgumentException( "The InputStream must not be null" );
 		}
 
 		LOG.trace( "Starting deserialization of object" );
 
 		try {
 			CustomObjectInputStream in = new CustomObjectInputStream(
 					inputStream,
 					loader,
 					fallbackLoader1,
 					fallbackLoader2
 			);
 			try {
 				return (T) in.readObject();
 			}
 			catch (ClassNotFoundException e) {
 				throw new SerializationException( "could not deserialize", e );
 			}
 			catch (IOException e) {
 				throw new SerializationException( "could not deserialize", e );
 			}
 			finally {
 				try {
 					in.close();
 				}
 				catch (IOException ignore) {
 					// ignore
 				}
 			}
 		}
 		catch (IOException e) {
 			throw new SerializationException( "could not deserialize", e );
 		}
 	}
 
 	/**
 	 * Deserializes an object from an array of bytes using the Thread Context
 	 * ClassLoader (TCCL).  If there is no TCCL set, the classloader of the calling
 	 * class is used.
 	 * <p/>
 	 * Delegates to {@link #deserialize(byte[], ClassLoader)}
 	 *
 	 * @param objectData the serialized object, must not be null
 	 *
 	 * @return the deserialized object
 	 *
 	 * @throws IllegalArgumentException if <code>objectData</code> is <code>null</code>
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static Object deserialize(byte[] objectData) throws SerializationException {
 		return doDeserialize( wrap( objectData ), defaultClassLoader(), hibernateClassLoader(), null );
 	}
 
 	private static InputStream wrap(byte[] objectData) {
 		if ( objectData == null ) {
 			throw new IllegalArgumentException( "The byte[] must not be null" );
 		}
 		return new ByteArrayInputStream( objectData );
 	}
 
 	/**
 	 * Deserializes an object from an array of bytes.
 	 * <p/>
 	 * Delegates to {@link #deserialize(java.io.InputStream, ClassLoader)} using a
 	 * {@link ByteArrayInputStream} to wrap the array.
 	 *
 	 * @param objectData the serialized object, must not be null
 	 * @param loader The classloader to use
 	 *
 	 * @return the deserialized object
 	 *
 	 * @throws IllegalArgumentException if <code>objectData</code> is <code>null</code>
 	 * @throws SerializationException (runtime) if the serialization fails
 	 */
 	public static Object deserialize(byte[] objectData, ClassLoader loader) throws SerializationException {
 		return doDeserialize( wrap( objectData ), loader, defaultClassLoader(), hibernateClassLoader() );
 	}
 
 
 	/**
 	 * By default, to resolve the classes being deserialized JDK serialization uses the
 	 * classes loader which loaded the class which initiated the deserialization call.  Here
 	 * that would be hibernate classes.  However, there are cases where that is not the correct
 	 * class loader to use; mainly here we are worried about deserializing user classes in
 	 * environments (app servers, etc) where Hibernate is on a parent classes loader.  To
 	 * facilitate for that we allow passing in the class loader we should use.
 	 */
 	private static final class CustomObjectInputStream extends ObjectInputStream {
 		private final ClassLoader loader1;
 		private final ClassLoader loader2;
 		private final ClassLoader loader3;
 
 		private CustomObjectInputStream(
 				InputStream in,
 				ClassLoader loader1,
 				ClassLoader loader2,
 				ClassLoader loader3) throws IOException {
 			super( in );
 			this.loader1 = loader1;
 			this.loader2 = loader2;
 			this.loader3 = loader3;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		@Override
 		protected Class resolveClass(ObjectStreamClass v) throws IOException, ClassNotFoundException {
 			final String className = v.getName();
 			LOG.tracev( "Attempting to locate class [{0}]", className );
 
 			try {
 				return Class.forName( className, false, loader1 );
 			}
 			catch (ClassNotFoundException e) {
 				LOG.trace( "Unable to locate class using given classloader" );
 			}
 
 			if ( different( loader1, loader2 ) ) {
 				try {
 					return Class.forName( className, false, loader2 );
 				}
 				catch (ClassNotFoundException e) {
 					LOG.trace( "Unable to locate class using given classloader" );
 				}
 			}
 
 			if ( different( loader1, loader3 ) && different( loader2, loader3 ) ) {
 				try {
 					return Class.forName( className, false, loader3 );
 				}
 				catch (ClassNotFoundException e) {
 					LOG.trace( "Unable to locate class using given classloader" );
 				}
 			}
 
 			// By default delegate to normal JDK deserialization which will use the class loader
 			// of the class which is calling this deserialization.
 			return super.resolveClass( v );
 		}
 
 		private boolean different(ClassLoader one, ClassLoader other) {
 			if ( one == null ) {
 				return other != null;
 			}
 			return !one.equals( other );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/DTDEntityResolver.java b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/DTDEntityResolver.java
index 46ccfa6970..e7b77e8e9e 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/DTDEntityResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/DTDEntityResolver.java
@@ -1,111 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal.util.xml;
 
 import java.io.InputStream;
 import java.io.Serializable;
 
+import org.hibernate.boot.jaxb.internal.stax.*;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ConfigHelper;
 
 import org.jboss.logging.Logger;
 
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 /**
  * An {@link EntityResolver} implementation which attempts to resolve
  * various systemId URLs to local classpath look ups<ol>
  * <li>Any systemId URL beginning with <tt>http://www.hibernate.org/dtd/</tt> is
  * searched for as a classpath resource in the classloader which loaded the
  * Hibernate classes.</li>
  * <li>Any systemId URL using <tt>classpath</tt> as the scheme (i.e. starting
  * with <tt>classpath://</tt> is searched for as a classpath resource using first
  * the current thread context classloader and then the classloader which loaded
  * the Hibernate classes.
  * </ol>
  * <p/>
  * Any entity references which cannot be resolved in relation to the above
  * rules result in returning null, which should force the SAX reader to
  * handle the entity reference in its default manner.
  *
  * @author Markus Meissner
  * @author Gavin King
  * @author Steve Ebersole
  * @author Hardy Ferentschik
+ *
+ * @deprecated Hibernate now uses StAX for XML processing and the role of this class is served
+ * now by {@link org.hibernate.boot.jaxb.internal.stax.LocalXmlResourceResolver}
  */
+@Deprecated
 public class DTDEntityResolver implements EntityResolver, Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, DTDEntityResolver.class.getName() );
 
 	private static final String HIBERNATE_NAMESPACE = "http://www.hibernate.org/dtd/";
 	private static final String OLD_HIBERNATE_NAMESPACE = "http://hibernate.sourceforge.net/";
 	private static final String USER_NAMESPACE = "classpath://";
 
 	public InputSource resolveEntity(String publicId, String systemId) {
 		InputSource source = null; // returning null triggers default behavior
 		if ( systemId != null ) {
 			LOG.debugf( "Trying to resolve system-id [%s]", systemId );
 			if ( systemId.startsWith( HIBERNATE_NAMESPACE ) ) {
 				LOG.debug( "Recognized hibernate namespace; attempting to resolve on classpath under org/hibernate/" );
 				source = resolveOnClassPath( publicId, systemId, HIBERNATE_NAMESPACE );
 			}
 			else if ( systemId.startsWith( OLD_HIBERNATE_NAMESPACE ) ) {
 				LOG.recognizedObsoleteHibernateNamespace( OLD_HIBERNATE_NAMESPACE, HIBERNATE_NAMESPACE );
 				LOG.debug( "Attempting to resolve on classpath under org/hibernate/" );
 				source = resolveOnClassPath( publicId, systemId, OLD_HIBERNATE_NAMESPACE );
 			}
 			else if ( systemId.startsWith( USER_NAMESPACE ) ) {
 				LOG.debug( "Recognized local namespace; attempting to resolve on classpath" );
 				String path = systemId.substring( USER_NAMESPACE.length() );
 				InputStream stream = resolveInLocalNamespace( path );
 				if ( stream == null ) {
 					LOG.debugf( "Unable to locate [%s] on classpath", systemId );
 				}
 				else {
 					LOG.debugf( "Located [%s] in classpath", systemId );
 					source = new InputSource( stream );
 					source.setPublicId( publicId );
 					source.setSystemId( systemId );
 				}
 			}
 		}
 		return source;
 	}
 
 	private InputSource resolveOnClassPath(String publicId, String systemId, String namespace) {
 		InputSource source = null;
 		String path = "org/hibernate/" + systemId.substring( namespace.length() );
 		InputStream dtdStream = resolveInHibernateNamespace( path );
 		if ( dtdStream == null ) {
 			LOG.debugf( "Unable to locate [%s] on classpath", systemId );
 			if ( systemId.substring( namespace.length() ).indexOf( "2.0" ) > -1 ) {
 				LOG.usingOldDtd();
 			}
 		}
 		else {
 			LOG.debugf( "Located [%s] in classpath", systemId );
 			source = new InputSource( dtdStream );
 			source.setPublicId( publicId );
 			source.setSystemId( systemId );
 		}
 		return source;
 	}
 
 	protected InputStream resolveInHibernateNamespace(String path) {
 		return this.getClass().getClassLoader().getResourceAsStream( path );
 	}
 
 	protected InputStream resolveInLocalNamespace(String path) {
 		try {
 			return ConfigHelper.getUserResourceAsStream( path );
 		}
 		catch ( Throwable t ) {
 			return null;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/LocalXmlResourceResolver.java b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/LocalXmlResourceResolver.java
deleted file mode 100644
index 6a6ee8cbd5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/LocalXmlResourceResolver.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.internal.util.xml;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import javax.xml.stream.XMLStreamException;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ConfigHelper;
-
-import org.jboss.logging.Logger;
-
-/**
- * @author Steve Ebersole
- */
-public class LocalXmlResourceResolver implements javax.xml.stream.XMLResolver {
-	private static final CoreMessageLogger log = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			MappingReader.class.getName()
-	);
-
-	public static final LocalXmlResourceResolver INSTANCE = new LocalXmlResourceResolver();
-
-	/**
-	 * Namespace for the orm.xml xsd for jpa 1.0 and 2.0
-	 */
-	public static final String INITIAL_JPA_ORM_NS = "http://java.sun.com/xml/ns/persistence/orm";
-
-	/**
-	 * Namespace for the orm.xml xsd for jpa 2.1
-	 */
-	public static final String SECOND_JPA_ORM_NS = "http://xmlns.jcp.org/xml/ns/persistence/orm";
-
-	public static final String HIBERNATE_MAPPING_DTD_URL_BASE = "http://www.hibernate.org/dtd/";
-	public static final String LEGACY_HIBERNATE_MAPPING_DTD_URL_BASE = "http://hibernate.sourceforge.net/";
-	public static final String CLASSPATH_EXTENSION_URL_BASE = "classpath://";
-
-	@Override
-	public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws XMLStreamException {
-		log.tracef( "In resolveEntity(%s, %s, %s, %s)", publicID, systemID, baseURI, namespace );
-
-		if ( namespace != null ) {
-			log.debugf( "Interpreting namespace : %s", namespace );
-			if ( INITIAL_JPA_ORM_NS.equals( namespace ) ) {
-				return openUrlStream( MappingReader.SupportedOrmXsdVersion.ORM_2_0.getSchemaUrl() );
-			}
-			else if ( SECOND_JPA_ORM_NS.equals( namespace ) ) {
-				return openUrlStream( MappingReader.SupportedOrmXsdVersion.ORM_2_1.getSchemaUrl() );
-			}
-		}
-
-		if ( systemID != null ) {
-			log.debugf( "Interpreting systemID : %s", namespace );
-			InputStream stream = null;
-			if ( systemID.startsWith( HIBERNATE_MAPPING_DTD_URL_BASE ) ) {
-				log.debug( "Recognized hibernate namespace; attempting to resolve on classpath under org/hibernate/" );
-				stream = resolveOnClassPath( systemID, HIBERNATE_MAPPING_DTD_URL_BASE );
-			}
-			else if ( systemID.startsWith( LEGACY_HIBERNATE_MAPPING_DTD_URL_BASE ) ) {
-				log.recognizedObsoleteHibernateNamespace( LEGACY_HIBERNATE_MAPPING_DTD_URL_BASE, HIBERNATE_MAPPING_DTD_URL_BASE );
-				log.debug( "Attempting to resolve on classpath under org/hibernate/" );
-				stream = resolveOnClassPath( systemID, LEGACY_HIBERNATE_MAPPING_DTD_URL_BASE );
-			}
-			else if ( systemID.startsWith( CLASSPATH_EXTENSION_URL_BASE ) ) {
-				log.debug( "Recognized local namespace; attempting to resolve on classpath" );
-				final String path = systemID.substring( CLASSPATH_EXTENSION_URL_BASE.length() );
-				stream = resolveInLocalNamespace( path );
-				if ( stream == null ) {
-					log.debugf( "Unable to resolve [%s] on classpath", systemID );
-				}
-				else {
-					log.debugf( "Resolved [%s] on classpath", systemID );
-				}
-			}
-
-			if ( stream != null ) {
-				return stream;
-			}
-		}
-
-		return null;
-	}
-
-	private InputStream openUrlStream(URL url) {
-		try {
-			return url.openStream();
-		}
-		catch (IOException e) {
-			throw new XmlInfrastructureException( "Could not open url stream : " + url.toExternalForm(), e );
-		}
-	}
-
-	private InputStream resolveOnClassPath(String systemID, String namespace) {
-		final String relativeResourceName = systemID.substring( namespace.length() );
-		final String path = "org/hibernate/" + relativeResourceName;
-		InputStream dtdStream = resolveInHibernateNamespace( path );
-		if ( dtdStream == null ) {
-			log.debugf( "Unable to locate [%s] on classpath", systemID );
-			if ( relativeResourceName.contains( "2.0" ) ) {
-				log.usingOldDtd();
-			}
-			return null;
-		}
-		else {
-			log.debugf( "Located [%s] in classpath", systemID );
-			return dtdStream;
-		}
-	}
-
-	private InputStream resolveInHibernateNamespace(String path) {
-		return this.getClass().getClassLoader().getResourceAsStream( path );
-	}
-
-	private InputStream resolveInLocalNamespace(String path) {
-		try {
-			return ConfigHelper.getUserResourceAsStream( path );
-		}
-		catch ( Throwable t ) {
-			return null;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/MappingReader.java b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/MappingReader.java
deleted file mode 100644
index ff302fe6f7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/MappingReader.java
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.internal.util.xml;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.StringReader;
-import java.net.URL;
-import javax.xml.XMLConstants;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.events.Attribute;
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.transform.stax.StAXSource;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-import javax.xml.validation.Validator;
-
-import org.hibernate.InvalidMappingException;
-import org.hibernate.internal.CoreMessageLogger;
-
-import org.jboss.logging.Logger;
-
-import org.dom4j.Document;
-import org.dom4j.io.SAXReader;
-import org.dom4j.io.STAXEventReader;
-import org.xml.sax.EntityResolver;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-/**
- * Handles reading mapping documents, both {@code hbm} and {@code orm} varieties.
- *
- * @author Steve Ebersole
- */
-public class MappingReader {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			MappingReader.class.getName()
-	);
-
-	public static final MappingReader INSTANCE = new MappingReader();
-
-	/**
-	 * Disallow direct instantiation.
-	 * <p/>
-	 * Eventually we perhaps need to have this configurable by the "configuration" and simply reference it
-	 * from there (registry).  This would allow, for example, injection of the entity resolver to use as
-	 * instance state.
-	 */
-	private MappingReader() {
-	}
-
-	public XmlDocument readMappingDocument(InputSource source, Origin origin) {
-		XMLEventReader staxReader = buildStaxEventReader( source, origin );
-		try {
-			return read( staxReader, origin );
-		}
-		finally {
-			try {
-				staxReader.close();
-			}
-			catch ( Exception ignore ) {
-			}
-		}
-	}
-
-	private XMLEventReader buildStaxEventReader(InputSource source, Origin origin) {
-		XMLEventReader reader = null;
-
-		if ( source.getByteStream() != null ) {
-			try {
-				reader = staxFactory().createXMLEventReader( source.getByteStream() );
-			}
-			catch (XMLStreamException e) {
-				throw new XmlInfrastructureException(
-						"Unable to create stax reader, origin = " + toLoggableString( origin ),
-						e
-				);
-			}
-		}
-		else if ( source.getCharacterStream() != null ) {
-			try {
-				reader = staxFactory().createXMLEventReader( source.getCharacterStream() );
-			}
-			catch (XMLStreamException e) {
-				throw new XmlInfrastructureException(
-						"Unable to create stax reader, origin = " + toLoggableString( origin ),
-						e
-				);
-			}
-		}
-		// todo : try to interpret the InputSource SystemId or Origin path?
-
-		if ( reader == null ) {
-			throw new XmlInfrastructureException( "Unable to convert SAX InputStream into StAX XMLEventReader" );
-		}
-
-		// For performance we wrap the reader in a buffered reader
-		return new BufferedXMLEventReader( reader );
-	}
-
-	private XMLInputFactory staxFactory;
-
-	private XMLInputFactory staxFactory() {
-		if ( staxFactory == null ) {
-			staxFactory = buildStaxFactory();
-		}
-		return staxFactory;
-	}
-
-	@SuppressWarnings( { "UnnecessaryLocalVariable" })
-	private XMLInputFactory buildStaxFactory() {
-		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
-		staxFactory.setXMLResolver( LocalXmlResourceResolver.INSTANCE );
-		return staxFactory;
-	}
-
-	private String toLoggableString(Origin origin) {
-		return "[type=" + origin.getType() + ", name=" + origin.getName() + "]";
-	}
-
-	private static final QName ORM_VERSION_ATTRIBUTE_QNAME = new QName( "version" );
-
-	private XmlDocument read(XMLEventReader staxEventReader, Origin origin) {
-		XMLEvent event;
-		try {
-			event = staxEventReader.peek();
-			while ( event != null && !event.isStartElement() ) {
-				staxEventReader.nextEvent();
-				event = staxEventReader.peek();
-			}
-		}
-		catch ( Exception e ) {
-			throw new InvalidMappingException( "Error accessing stax stream", origin, e );
-		}
-
-		if ( event == null ) {
-			throw new InvalidMappingException( "Could not locate root element", origin );
-		}
-
-		final String rootElementName = event.asStartElement().getName().getLocalPart();
-
-		if ( "entity-mappings".equals( rootElementName ) ) {
-			final Attribute attribute = event.asStartElement().getAttributeByName( ORM_VERSION_ATTRIBUTE_QNAME );
-			final String explicitVersion = attribute == null ? null : attribute.getValue();
-			validateMapping(
-					SupportedOrmXsdVersion.parse( explicitVersion, origin ),
-					staxEventReader,
-					origin
-			);
-		}
-
-		return new XmlDocumentImpl( toDom4jDocument( staxEventReader, origin ), origin );
-	}
-
-	private Document toDom4jDocument(XMLEventReader staxEventReader, Origin origin) {
-		STAXEventReader dom4jStaxEventReader = new STAXEventReader();
-		try {
-			// the dom4j converter class is touchy about comments (aka, comments make it implode)
-			// so wrap the event stream in a filtering stream to filter out comment events
-			staxEventReader = new FilteringXMLEventReader( staxEventReader ) {
-				@Override
-				protected XMLEvent filterEvent(XMLEvent event, boolean peek) {
-					return event.getEventType() == XMLStreamConstants.COMMENT
-							? null
-							: event;
-				}
-			};
-
-			return dom4jStaxEventReader.readDocument( staxEventReader );
-		}
-		catch (XMLStreamException e) {
-			throw new InvalidMappingException( "Unable to read StAX source as dom4j Document for processing", origin, e );
-		}
-	}
-
-	private void validateMapping(SupportedOrmXsdVersion xsdVersion, XMLEventReader staxEventReader, Origin origin) {
-		final Validator validator = xsdVersion.getSchema().newValidator();
-		final StAXSource staxSource;
-		try {
-			staxSource = new StAXSource( staxEventReader );
-		}
-		catch (XMLStreamException e) {
-			throw new InvalidMappingException( "Unable to generate StAXSource from mapping", origin, e );
-		}
-
-		try {
-			validator.validate( staxSource );
-		}
-		catch (SAXException e) {
-			throw new InvalidMappingException( "SAXException performing validation", origin, e );
-		}
-		catch (IOException e) {
-			throw new InvalidMappingException( "IOException performing validation", origin, e );
-		}
-	}
-
-	public static enum SupportedOrmXsdVersion {
-		ORM_1_0( "org/hibernate/jpa/orm_1_0.xsd" ),
-		ORM_2_0( "org/hibernate/jpa/orm_2_0.xsd" ),
-		ORM_2_1( "org/hibernate/jpa/orm_2_1.xsd" );
-
-		private final String schemaResourceName;
-
-		private SupportedOrmXsdVersion(String schemaResourceName) {
-			this.schemaResourceName = schemaResourceName;
-		}
-
-		public static SupportedOrmXsdVersion parse(String name, Origin origin) {
-			if ( "1.0".equals( name ) ) {
-				return ORM_1_0;
-			}
-			else if ( "2.0".equals( name ) ) {
-				return ORM_2_0;
-			}
-			else if ( "2.1".equals( name ) ) {
-				return ORM_2_1;
-			}
-			throw new UnsupportedOrmXsdVersionException( name, origin );
-		}
-
-		private URL schemaUrl;
-
-		public URL getSchemaUrl() {
-			if ( schemaUrl == null ) {
-				schemaUrl = resolveLocalSchemaUrl( schemaResourceName );
-			}
-			return schemaUrl;
-		}
-
-		private Schema schema;
-
-		public Schema getSchema() {
-			if ( schema == null ) {
-				schema = resolveLocalSchema( getSchemaUrl() );
-			}
-			return schema;
-		}
-	}
-
-	private static URL resolveLocalSchemaUrl(String schemaName) {
-		URL url = MappingReader.class.getClassLoader().getResource( schemaName );
-		if ( url == null ) {
-			throw new XmlInfrastructureException( "Unable to locate schema [" + schemaName + "] via classpath" );
-		}
-		return url;
-	}
-
-	private static Schema resolveLocalSchema(URL schemaUrl) {
-
-		try {
-			InputStream schemaStream = schemaUrl.openStream();
-			try {
-				StreamSource source = new StreamSource(schemaUrl.openStream());
-				SchemaFactory schemaFactory = SchemaFactory.newInstance( XMLConstants.W3C_XML_SCHEMA_NS_URI );
-				return schemaFactory.newSchema(source);
-			}
-			catch ( Exception e ) {
-				throw new XmlInfrastructureException( "Unable to load schema [" + schemaUrl.toExternalForm() + "]", e );
-			}
-			finally {
-				try {
-					schemaStream.close();
-				}
-				catch ( IOException e ) {
-					LOG.debugf( "Problem closing schema stream - %s", e.toString() );
-				}
-			}
-		}
-		catch ( IOException e ) {
-			throw new XmlInfrastructureException( "Stream error handling schema url [" + schemaUrl.toExternalForm() + "]" );
-		}
-
-	}
-
-
-	public XmlDocument readMappingDocument(EntityResolver entityResolver, InputSource source, Origin origin) {
-		return legacyReadMappingDocument( entityResolver, source, origin );
-//		return readMappingDocument( source, origin );
-	}
-
-	private XmlDocument legacyReadMappingDocument(EntityResolver entityResolver, InputSource source, Origin origin) {
-		// IMPL NOTE : this is the legacy logic as pulled from the old AnnotationConfiguration code
-
-		Exception failure;
-
-		ErrorLogger errorHandler = new ErrorLogger();
-
-		SAXReader saxReader = new SAXReader();
-		saxReader.setEntityResolver( entityResolver );
-		saxReader.setErrorHandler( errorHandler );
-		saxReader.setMergeAdjacentText( true );
-		saxReader.setValidation( true );
-
-		Document document = null;
-		try {
-			// first try with orm 2.1 xsd validation
-			setValidationFor( saxReader, "orm_2_1.xsd" );
-			document = saxReader.read( source );
-			if ( errorHandler.hasErrors() ) {
-				throw errorHandler.getErrors().get( 0 );
-			}
-			return new XmlDocumentImpl( document, origin.getType(), origin.getName() );
-		}
-		catch ( Exception e ) {
-			if ( LOG.isDebugEnabled() ) {
-				LOG.debugf( "Problem parsing XML using orm 2.1 xsd, trying 2.0 xsd : %s", e.getMessage() );
-			}
-			failure = e;
-			errorHandler.reset();
-
-			if ( document != null ) {
-				// next try with orm 2.0 xsd validation
-				try {
-					setValidationFor( saxReader, "orm_2_0.xsd" );
-					document = saxReader.read( new StringReader( document.asXML() ) );
-					if ( errorHandler.hasErrors() ) {
-						errorHandler.logErrors();
-						throw errorHandler.getErrors().get( 0 );
-					}
-					return new XmlDocumentImpl( document, origin.getType(), origin.getName() );
-				}
-				catch ( Exception e2 ) {
-					if ( LOG.isDebugEnabled() ) {
-						LOG.debugf( "Problem parsing XML using orm 2.0 xsd, trying 1.0 xsd : %s", e2.getMessage() );
-					}
-					errorHandler.reset();
-
-					if ( document != null ) {
-						// next try with orm 1.0 xsd validation
-						try {
-							setValidationFor( saxReader, "orm_1_0.xsd" );
-							document = saxReader.read( new StringReader( document.asXML() ) );
-							if ( errorHandler.hasErrors() ) {
-								errorHandler.logErrors();
-								throw errorHandler.getErrors().get( 0 );
-							}
-							return new XmlDocumentImpl( document, origin.getType(), origin.getName() );
-						}
-						catch ( Exception e3 ) {
-							if ( LOG.isDebugEnabled() ) {
-								LOG.debugf( "Problem parsing XML using orm 1.0 xsd : %s", e3.getMessage() );
-							}
-						}
-					}
-				}
-			}
-		}
-		throw new InvalidMappingException( "Unable to read XML", origin.getType(), origin.getName(), failure );
-	}
-
-	private void setValidationFor(SAXReader saxReader, String xsd) {
-		try {
-			saxReader.setFeature( "http://apache.org/xml/features/validation/schema", true );
-			// saxReader.setFeature( "http://apache.org/xml/features/validation/dynamic", true );
-			if ( "orm_2_1.xsd".equals( xsd ) ) {
-				saxReader.setProperty(
-						"http://apache.org/xml/properties/schema/external-schemaLocation",
-						"http://xmlns.jcp.org/xml/ns/persistence/orm " + xsd
-				);
-			}
-			else {
-				saxReader.setProperty(
-						"http://apache.org/xml/properties/schema/external-schemaLocation",
-						"http://java.sun.com/xml/ns/persistence/orm " + xsd
-				);
-			}
-		}
-		catch ( SAXException e ) {
-			saxReader.setValidation( false );
-		}
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XMLHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XMLHelper.java
index 870bb6a796..4eb276dbfc 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XMLHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XMLHelper.java
@@ -1,96 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.internal.util.xml;
 
-import org.hibernate.internal.util.ClassLoaderHelper;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 import org.dom4j.DocumentFactory;
-import org.dom4j.Element;
-import org.dom4j.io.DOMReader;
-import org.dom4j.io.OutputFormat;
 import org.dom4j.io.SAXReader;
-import org.dom4j.io.XMLWriter;
 import org.xml.sax.EntityResolver;
-import org.xml.sax.ErrorHandler;
 
 /**
  * Small helper class that lazy loads DOM and SAX reader and keep them for fast use afterwards.
+ *
+ * @deprecated Currently only used for integration with HCANN.  The rest of Hibernate uses StAX now
+ * for XML processing.  See {@link org.hibernate.boot.jaxb.internal.stax}
  */
+@Deprecated
 public final class XMLHelper {
+	private final DocumentFactory documentFactory;
+
+	public XMLHelper(ClassLoaderService classLoaderService) {
+		this.documentFactory = classLoaderService.workWithClassLoader(
+				new ClassLoaderService.Work<DocumentFactory>() {
+					@Override
+					public DocumentFactory doWork(ClassLoader classLoader) {
+						final ClassLoader originalTccl = Thread.currentThread().getContextClassLoader();
+						try {
+							Thread.currentThread().setContextClassLoader( classLoader );
+							return DocumentFactory.getInstance();
+						}
+						finally {
+							Thread.currentThread().setContextClassLoader( originalTccl );
+						}
+					}
+				}
+		);
 
-	public static final EntityResolver DEFAULT_DTD_RESOLVER = new DTDEntityResolver();
-
-	private DOMReader domReader;
-	private SAXReader saxReader;
-
-	/**
-	 * @param errorHandler the sax error handler
-	 * @param entityResolver an xml entity resolver
-	 *
-	 * @return Create and return a dom4j {@code SAXReader} which will append all validation errors
-	 *         to the passed error list
-	 */
-	public SAXReader createSAXReader(ErrorHandler errorHandler, EntityResolver entityResolver) {
-		SAXReader saxReader = resolveSAXReader();
-		saxReader.setEntityResolver( entityResolver );
-		saxReader.setErrorHandler( errorHandler );
-		return saxReader;
-	}
-
-	private SAXReader resolveSAXReader() {
-		if ( saxReader == null ) {
-			saxReader = new SAXReader();
-			saxReader.setMergeAdjacentText( true );
-			saxReader.setValidation( true );
-		}
-		return saxReader;
 	}
 
-	/**
-	 * @return create and return a dom4j DOMReader
-	 */
-	public DOMReader createDOMReader() {
-		if ( domReader == null ) {
-			domReader = new DOMReader();
-		}
-		return domReader;
+	public DocumentFactory getDocumentFactory() {
+		return documentFactory;
 	}
 
-	public static Element generateDom4jElement(String elementName) {
-		return getDocumentFactory().createElement( elementName );
-	}
-
-	public static DocumentFactory getDocumentFactory() {
-
-		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
-		DocumentFactory factory;
-		try {
-			Thread.currentThread().setContextClassLoader( XMLHelper.class.getClassLoader() );
-			factory = DocumentFactory.getInstance();
-		}
-		finally {
-			Thread.currentThread().setContextClassLoader( cl );
-		}
-		return factory;
-	}
-
-	public static void dump(Element element) {
-		try {
-			// try to "pretty print" it
-			OutputFormat outFormat = OutputFormat.createPrettyPrint();
-			XMLWriter writer = new XMLWriter( System.out, outFormat );
-			writer.write( element );
-			writer.flush();
-			System.out.println( "" );
-		}
-		catch ( Throwable t ) {
-			// otherwise, just dump it
-			System.out.println( element.asXML() );
-		}
+	public SAXReader createSAXReader(ErrorLogger errorLogger, EntityResolver entityResolver) {
+		SAXReader saxReader = new SAXReader();
+		saxReader.setMergeAdjacentText( true );
+		saxReader.setValidation( true );
+		saxReader.setErrorHandler( errorLogger );
+		saxReader.setEntityResolver( entityResolver );
 
+		return saxReader;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Array.java b/hibernate-core/src/main/java/org/hibernate/mapping/Array.java
index 5e85458fdd..2521f7b5df 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Array.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Array.java
@@ -1,74 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.MetadataImplementor;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.PrimitiveType;
 
 /**
  * An array mapping has a primary key consisting of the key columns + index column.
  *
  * @author Gavin King
  */
 public class Array extends List {
 	private String elementClassName;
 
 	public Array(MetadataImplementor metadata, PersistentClass owner) {
 		super( metadata, owner );
 	}
 
 	public Class getElementClass() throws MappingException {
 		if ( elementClassName == null ) {
 			org.hibernate.type.Type elementType = getElement().getType();
 			return isPrimitiveArray()
 					? ( (PrimitiveType) elementType ).getPrimitiveClass()
 					: elementType.getReturnedClass();
 		}
 		else {
 			try {
-				return ReflectHelper.classForName( elementClassName );
+				return getMetadata().getMetadataBuildingOptions()
+						.getServiceRegistry()
+						.getService( ClassLoaderService.class )
+						.classForName( elementClassName );
 			}
-			catch (ClassNotFoundException cnfe) {
-				throw new MappingException( cnfe );
+			catch (ClassLoadingException e) {
+				throw new MappingException( e );
 			}
 		}
 	}
 
 	@Override
 	public CollectionType getDefaultCollectionType() throws MappingException {
 		return getMetadata().getTypeResolver()
 				.getTypeFactory()
 				.array( getRole(), getReferencedPropertyName(), getElementClass() );
 	}
 
 	@Override
 	public boolean isArray() {
 		return true;
 	}
 
 	/**
 	 * @return Returns the elementClassName.
 	 */
 	public String getElementClassName() {
 		return elementClassName;
 	}
 
 	/**
 	 * @param elementClassName The elementClassName to set.
 	 */
 	public void setElementClassName(String elementClassName) {
 		this.elementClassName = elementClassName;
 	}
 
 	@Override
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept( this );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Backref.java b/hibernate-core/src/main/java/org/hibernate/mapping/Backref.java
index e8eab530fc..3dbc894457 100755
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Backref.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Backref.java
@@ -1,54 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
-import org.hibernate.property.BackrefPropertyAccessor;
-import org.hibernate.property.PropertyAccessor;
+import org.hibernate.MappingException;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
 
 /**
  * @author Gavin King
  */
 public class Backref extends Property {
 	private String collectionRole;
 	private String entityName;
 
 	@Override
 	public boolean isBackRef() {
 		return true;
 	}
 
 	@Override
 	public boolean isSynthetic() {
 		return true;
 	}
 
 	public String getCollectionRole() {
 		return collectionRole;
 	}
 
 	public void setCollectionRole(String collectionRole) {
 		this.collectionRole = collectionRole;
 	}
 
 	@Override
 	public boolean isBasicPropertyAccessor() {
 		return false;
 	}
 
+	private PropertyAccessStrategy propertyAccessStrategy;
+
 	@Override
-	public PropertyAccessor getPropertyAccessor(Class clazz) {
-		return new BackrefPropertyAccessor(collectionRole, entityName);
+	public PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {
+		if ( propertyAccessStrategy == null ) {
+			propertyAccessStrategy = new PropertyAccessStrategyBackRefImpl( collectionRole, entityName );
+		}
+		return propertyAccessStrategy;
 	}
 	
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java b/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
index 16334b141d..4f92d78464 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
@@ -1,717 +1,726 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Properties;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.FilterConfiguration;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 
 /**
  * Mapping for a collection. Subclasses specialize to particular collection styles.
  *
  * @author Gavin King
  */
 public abstract class Collection implements Fetchable, Value, Filterable {
 
 	public static final String DEFAULT_ELEMENT_COLUMN_NAME = "elt";
 	public static final String DEFAULT_KEY_COLUMN_NAME = "id";
 
 	private final MetadataImplementor metadata;
 	private PersistentClass owner;
 
 	private KeyValue key;
 	private Value element;
 	private Table collectionTable;
 	private String role;
 	private boolean lazy;
 	private boolean extraLazy;
 	private boolean inverse;
 	private boolean mutable = true;
 	private boolean subselectLoadable;
 	private String cacheConcurrencyStrategy;
 	private String cacheRegionName;
 	private String orderBy;
 	private String where;
 	private String manyToManyWhere;
 	private String manyToManyOrderBy;
 	private String referencedPropertyName;
 	private String nodeName;
 	private String elementNodeName;
 	private String mappedByProperty;
 	private boolean sorted;
 	private Comparator comparator;
 	private String comparatorClassName;
 	private boolean orphanDelete;
 	private int batchSize = -1;
 	private FetchMode fetchMode;
 	private boolean embedded = true;
 	private boolean optimisticLocked = true;
 	private Class collectionPersisterClass;
 	private String typeName;
 	private Properties typeParameters;
 	private final java.util.List filters = new ArrayList();
 	private final java.util.List manyToManyFilters = new ArrayList();
 	private final java.util.Set<String> synchronizedTables = new HashSet<String>();
 
 	private String customSQLInsert;
 	private boolean customInsertCallable;
 	private ExecuteUpdateResultCheckStyle insertCheckStyle;
 	private String customSQLUpdate;
 	private boolean customUpdateCallable;
 	private ExecuteUpdateResultCheckStyle updateCheckStyle;
 	private String customSQLDelete;
 	private boolean customDeleteCallable;
 	private ExecuteUpdateResultCheckStyle deleteCheckStyle;
 	private String customSQLDeleteAll;
 	private boolean customDeleteAllCallable;
 	private ExecuteUpdateResultCheckStyle deleteAllCheckStyle;
 
 	private String loaderName;
 
 	protected Collection(MetadataImplementor metadata, PersistentClass owner) {
 		this.metadata = metadata;
 		this.owner = owner;
 	}
 
 	public MetadataImplementor getMetadata() {
 		return metadata;
 	}
 
+	@Override
+	public ServiceRegistry getServiceRegistry() {
+		return getMetadata().getMetadataBuildingOptions().getServiceRegistry();
+	}
+
 	public boolean isSet() {
 		return false;
 	}
 
 	public KeyValue getKey() {
 		return key;
 	}
 
 	public Value getElement() {
 		return element;
 	}
 
 	public boolean isIndexed() {
 		return false;
 	}
 
 	public Table getCollectionTable() {
 		return collectionTable;
 	}
 
 	public void setCollectionTable(Table table) {
 		this.collectionTable = table;
 	}
 
 	public boolean isSorted() {
 		return sorted;
 	}
 
 	public Comparator getComparator() {
 		if ( comparator == null && comparatorClassName != null ) {
 			try {
-				setComparator( (Comparator) ReflectHelper.classForName( comparatorClassName ).newInstance() );
+				final ClassLoaderService classLoaderService = getMetadata().getMetadataBuildingOptions()
+						.getServiceRegistry()
+						.getService( ClassLoaderService.class );
+				setComparator( (Comparator) classLoaderService.classForName( comparatorClassName ).newInstance() );
 			}
 			catch (Exception e) {
 				throw new MappingException(
 						"Could not instantiate comparator class [" + comparatorClassName
 								+ "] for collection " + getRole()
 				);
 			}
 		}
 		return comparator;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public String getRole() {
 		return role;
 	}
 
 	public abstract CollectionType getDefaultCollectionType() throws MappingException;
 
 	public boolean isPrimitiveArray() {
 		return false;
 	}
 
 	public boolean isArray() {
 		return false;
 	}
 
 	public boolean hasFormula() {
 		return false;
 	}
 
 	public boolean isOneToMany() {
 		return element instanceof OneToMany;
 	}
 
 	public boolean isInverse() {
 		return inverse;
 	}
 
 	public String getOwnerEntityName() {
 		return owner.getEntityName();
 	}
 
 	public String getOrderBy() {
 		return orderBy;
 	}
 
 	public void setComparator(Comparator comparator) {
 		this.comparator = comparator;
 	}
 
 	public void setElement(Value element) {
 		this.element = element;
 	}
 
 	public void setKey(KeyValue key) {
 		this.key = key;
 	}
 
 	public void setOrderBy(String orderBy) {
 		this.orderBy = orderBy;
 	}
 
 	public void setRole(String role) {
 		this.role = role;
 	}
 
 	public void setSorted(boolean sorted) {
 		this.sorted = sorted;
 	}
 
 	public void setInverse(boolean inverse) {
 		this.inverse = inverse;
 	}
 
 	public PersistentClass getOwner() {
 		return owner;
 	}
 
 	/**
 	 * @param owner The owner
 	 *
 	 * @deprecated Inject the owner into constructor.
 	 */
 	@Deprecated
 	public void setOwner(PersistentClass owner) {
 		this.owner = owner;
 	}
 
 	public String getWhere() {
 		return where;
 	}
 
 	public void setWhere(String where) {
 		this.where = where;
 	}
 
 	public String getManyToManyWhere() {
 		return manyToManyWhere;
 	}
 
 	public void setManyToManyWhere(String manyToManyWhere) {
 		this.manyToManyWhere = manyToManyWhere;
 	}
 
 	public String getManyToManyOrdering() {
 		return manyToManyOrderBy;
 	}
 
 	public void setManyToManyOrdering(String orderFragment) {
 		this.manyToManyOrderBy = orderFragment;
 	}
 
 	public boolean isIdentified() {
 		return false;
 	}
 
 	public boolean hasOrphanDelete() {
 		return orphanDelete;
 	}
 
 	public void setOrphanDelete(boolean orphanDelete) {
 		this.orphanDelete = orphanDelete;
 	}
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int i) {
 		batchSize = i;
 	}
 
 	public FetchMode getFetchMode() {
 		return fetchMode;
 	}
 
 	public void setFetchMode(FetchMode fetchMode) {
 		this.fetchMode = fetchMode;
 	}
 
 	public void setCollectionPersisterClass(Class persister) {
 		this.collectionPersisterClass = persister;
 	}
 
 	public Class getCollectionPersisterClass() {
 		return collectionPersisterClass;
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		assert getKey() != null : "Collection key not bound : " + getRole();
 		assert getElement() != null : "Collection element not bound : " + getRole();
 
 		if ( getKey().isCascadeDeleteEnabled() && ( !isInverse() || !isOneToMany() ) ) {
 			throw new MappingException(
 					"only inverse one-to-many associations may use on-delete=\"cascade\": "
 							+ getRole()
 			);
 		}
 		if ( !getKey().isValid( mapping ) ) {
 			throw new MappingException(
 					"collection foreign key mapping has wrong number of columns: "
 							+ getRole()
 							+ " type: "
 							+ getKey().getType().getName()
 			);
 		}
 		if ( !getElement().isValid( mapping ) ) {
 			throw new MappingException(
 					"collection element mapping has wrong number of columns: "
 							+ getRole()
 							+ " type: "
 							+ getElement().getType().getName()
 			);
 		}
 
 		checkColumnDuplication();
 
 		if ( elementNodeName != null && elementNodeName.startsWith( "@" ) ) {
 			throw new MappingException( "element node must not be an attribute: " + elementNodeName );
 		}
 		if ( elementNodeName != null && elementNodeName.equals( "." ) ) {
 			throw new MappingException( "element node must not be the parent: " + elementNodeName );
 		}
 		if ( nodeName != null && nodeName.indexOf( '@' ) > -1 ) {
 			throw new MappingException( "collection node must not be an attribute: " + elementNodeName );
 		}
 	}
 
 	private void checkColumnDuplication(java.util.Set distinctColumns, Iterator columns)
 			throws MappingException {
 		while ( columns.hasNext() ) {
 			Selectable s = (Selectable) columns.next();
 			if ( !s.isFormula() ) {
 				Column col = (Column) s;
 				if ( !distinctColumns.add( col.getName() ) ) {
 					throw new MappingException(
 							"Repeated column in mapping for collection: "
 									+ getRole()
 									+ " column: "
 									+ col.getName()
 					);
 				}
 			}
 		}
 	}
 
 	private void checkColumnDuplication() throws MappingException {
 		HashSet cols = new HashSet();
 		checkColumnDuplication( cols, getKey().getColumnIterator() );
 		if ( isIndexed() ) {
 			checkColumnDuplication(
 					cols, ( (IndexedCollection) this )
 							.getIndex()
 							.getColumnIterator()
 			);
 		}
 		if ( isIdentified() ) {
 			checkColumnDuplication(
 					cols, ( (IdentifierCollection) this )
 							.getIdentifier()
 							.getColumnIterator()
 			);
 		}
 		if ( !isOneToMany() ) {
 			checkColumnDuplication( cols, getElement().getColumnIterator() );
 		}
 	}
 
 	public Iterator<Selectable> getColumnIterator() {
 		return Collections.<Selectable>emptyList().iterator();
 	}
 
 	public int getColumnSpan() {
 		return 0;
 	}
 
 	public Type getType() throws MappingException {
 		return getCollectionType();
 	}
 
 	public CollectionType getCollectionType() {
 		if ( typeName == null ) {
 			return getDefaultCollectionType();
 		}
 		else {
 			return metadata.getTypeResolver()
 					.getTypeFactory()
 					.customCollection( typeName, typeParameters, role, referencedPropertyName );
 		}
 	}
 
 	public boolean isNullable() {
 		return true;
 	}
 
 	public boolean isAlternateUniqueKey() {
 		return false;
 	}
 
 	public Table getTable() {
 		return owner.getTable();
 	}
 
 	public void createForeignKey() {
 	}
 
 	public boolean isSimpleValue() {
 		return false;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		return true;
 	}
 
 	private void createForeignKeys() throws MappingException {
 		// if ( !isInverse() ) { // for inverse collections, let the "other end" handle it
 		if ( referencedPropertyName == null ) {
 			getElement().createForeignKey();
 			key.createForeignKeyOfEntity( getOwner().getEntityName() );
 		}
 		// }
 	}
 
 	abstract void createPrimaryKey();
 
 	public void createAllKeys() throws MappingException {
 		createForeignKeys();
 		if ( !isInverse() ) {
 			createPrimaryKey();
 		}
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return cacheConcurrencyStrategy;
 	}
 
 	public void setCacheConcurrencyStrategy(String cacheConcurrencyStrategy) {
 		this.cacheConcurrencyStrategy = cacheConcurrencyStrategy;
 	}
 
 	public void setTypeUsingReflection(String className, String propertyName) {
 	}
 
 	public String getCacheRegionName() {
 		return cacheRegionName == null ? role : cacheRegionName;
 	}
 
 	public void setCacheRegionName(String cacheRegionName) {
 		this.cacheRegionName = cacheRegionName;
 	}
 
 
 	public void setCustomSQLInsert(String customSQLInsert, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLInsert = customSQLInsert;
 		this.customInsertCallable = callable;
 		this.insertCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLInsert() {
 		return customSQLInsert;
 	}
 
 	public boolean isCustomInsertCallable() {
 		return customInsertCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLInsertCheckStyle() {
 		return insertCheckStyle;
 	}
 
 	public void setCustomSQLUpdate(String customSQLUpdate, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLUpdate = customSQLUpdate;
 		this.customUpdateCallable = callable;
 		this.updateCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLUpdate() {
 		return customSQLUpdate;
 	}
 
 	public boolean isCustomUpdateCallable() {
 		return customUpdateCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLUpdateCheckStyle() {
 		return updateCheckStyle;
 	}
 
 	public void setCustomSQLDelete(String customSQLDelete, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDelete = customSQLDelete;
 		this.customDeleteCallable = callable;
 		this.deleteCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDelete() {
 		return customSQLDelete;
 	}
 
 	public boolean isCustomDeleteCallable() {
 		return customDeleteCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteCheckStyle() {
 		return deleteCheckStyle;
 	}
 
 	public void setCustomSQLDeleteAll(
 			String customSQLDeleteAll,
 			boolean callable,
 			ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDeleteAll = customSQLDeleteAll;
 		this.customDeleteAllCallable = callable;
 		this.deleteAllCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDeleteAll() {
 		return customSQLDeleteAll;
 	}
 
 	public boolean isCustomDeleteAllCallable() {
 		return customDeleteAllCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteAllCheckStyle() {
 		return deleteAllCheckStyle;
 	}
 
 	public void addFilter(
 			String name,
 			String condition,
 			boolean autoAliasInjection,
 			java.util.Map<String, String> aliasTableMap,
 			java.util.Map<String, String> aliasEntityMap) {
 		filters.add(
 				new FilterConfiguration(
 						name,
 						condition,
 						autoAliasInjection,
 						aliasTableMap,
 						aliasEntityMap,
 						null
 				)
 		);
 	}
 
 	public java.util.List getFilters() {
 		return filters;
 	}
 
 	public void addManyToManyFilter(
 			String name,
 			String condition,
 			boolean autoAliasInjection,
 			java.util.Map<String, String> aliasTableMap,
 			java.util.Map<String, String> aliasEntityMap) {
 		manyToManyFilters.add(
 				new FilterConfiguration(
 						name,
 						condition,
 						autoAliasInjection,
 						aliasTableMap,
 						aliasEntityMap,
 						null
 				)
 		);
 	}
 
 	public java.util.List getManyToManyFilters() {
 		return manyToManyFilters;
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + getRole() + ')';
 	}
 
 	public java.util.Set<String> getSynchronizedTables() {
 		return synchronizedTables;
 	}
 
 	public String getLoaderName() {
 		return loaderName;
 	}
 
 	public void setLoaderName(String name) {
 		this.loaderName = name;
 	}
 
 	public String getReferencedPropertyName() {
 		return referencedPropertyName;
 	}
 
 	public void setReferencedPropertyName(String propertyRef) {
 		this.referencedPropertyName = propertyRef;
 	}
 
 	public boolean isOptimisticLocked() {
 		return optimisticLocked;
 	}
 
 	public void setOptimisticLocked(boolean optimisticLocked) {
 		this.optimisticLocked = optimisticLocked;
 	}
 
 	public boolean isMap() {
 		return false;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 
 	public void setTypeName(String typeName) {
 		this.typeName = typeName;
 	}
 
 	public Properties getTypeParameters() {
 		return typeParameters;
 	}
 
 	public void setTypeParameters(Properties parameterMap) {
 		this.typeParameters = parameterMap;
 	}
 
 	public void setTypeParameters(java.util.Map parameterMap) {
 		if ( parameterMap instanceof Properties ) {
 			this.typeParameters = (Properties) parameterMap;
 		}
 		else {
 			this.typeParameters = new Properties();
 			typeParameters.putAll( parameterMap );
 		}
 	}
 
 	public boolean[] getColumnInsertability() {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 
 	public boolean[] getColumnUpdateability() {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 
 	public String getNodeName() {
 		return nodeName;
 	}
 
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 
 	public String getElementNodeName() {
 		return elementNodeName;
 	}
 
 	public void setElementNodeName(String elementNodeName) {
 		this.elementNodeName = elementNodeName;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public boolean isEmbedded() {
 		return embedded;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public void setEmbedded(boolean embedded) {
 		this.embedded = embedded;
 	}
 
 	public boolean isSubselectLoadable() {
 		return subselectLoadable;
 	}
 
 
 	public void setSubselectLoadable(boolean subqueryLoadable) {
 		this.subselectLoadable = subqueryLoadable;
 	}
 
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	public void setMutable(boolean mutable) {
 		this.mutable = mutable;
 	}
 
 	public boolean isExtraLazy() {
 		return extraLazy;
 	}
 
 	public void setExtraLazy(boolean extraLazy) {
 		this.extraLazy = extraLazy;
 	}
 
 	public boolean hasOrder() {
 		return orderBy != null || manyToManyOrderBy != null;
 	}
 
 	public void setComparatorClassName(String comparatorClassName) {
 		this.comparatorClassName = comparatorClassName;
 	}
 
 	public String getComparatorClassName() {
 		return comparatorClassName;
 	}
 
 	public String getMappedByProperty() {
 		return mappedByProperty;
 	}
 
 	public void setMappedByProperty(String mappedByProperty) {
 		this.mappedByProperty = mappedByProperty;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Component.java b/hibernate-core/src/main/java/org/hibernate/mapping/Component.java
index 1a3b84b509..d2d26867f7 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Component.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Component.java
@@ -1,434 +1,439 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.ExportableProducer;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.id.CompositeNestedGeneratedValueGenerator;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.tuple.component.ComponentMetamodel;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeFactory;
 
 /**
  * The mapping for a component, composite element,
  * composite identifier, etc.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class Component extends SimpleValue implements MetaAttributable {
 	private ArrayList<Property> properties = new ArrayList<Property>();
 	private String componentClassName;
 	private boolean embedded;
 	private String parentProperty;
 	private PersistentClass owner;
 	private boolean dynamic;
 	private Map metaAttributes;
 	private String nodeName;
 	private boolean isKey;
 	private String roleName;
 
 	private java.util.Map<EntityMode,String> tuplizerImpls;
 
 	public Component(MetadataImplementor metadata, PersistentClass owner) throws MappingException {
 		this( metadata, owner.getTable(), owner );
 	}
 
 	public Component(MetadataImplementor metadata, Component component) throws MappingException {
 		this( metadata, component.getTable(), component.getOwner() );
 	}
 
 	public Component(MetadataImplementor metadata, Join join) throws MappingException {
 		this( metadata, join.getTable(), join.getPersistentClass() );
 	}
 
 	public Component(MetadataImplementor metadata, Collection collection) throws MappingException {
 		this( metadata, collection.getCollectionTable(), collection.getOwner() );
 	}
 
 	public Component(MetadataImplementor metadata, Table table, PersistentClass owner) throws MappingException {
 		super( metadata, table );
 		this.owner = owner;
 	}
 
 	public int getPropertySpan() {
 		return properties.size();
 	}
 
 	public Iterator getPropertyIterator() {
 		return properties.iterator();
 	}
 
 	public void addProperty(Property p) {
 		properties.add( p );
 	}
 
 	@Override
 	public void addColumn(Column column) {
 		throw new UnsupportedOperationException("Cant add a column to a component");
 	}
 
 	@Override
 	public int getColumnSpan() {
 		int n=0;
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property p = (Property) iter.next();
 			n+= p.getColumnSpan();
 		}
 		return n;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator<Selectable> getColumnIterator() {
 		Iterator[] iters = new Iterator[ getPropertySpan() ];
 		Iterator iter = getPropertyIterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			iters[i++] = ( (Property) iter.next() ).getColumnIterator();
 		}
 		return new JoinedIterator( iters );
 	}
 
 	public boolean isEmbedded() {
 		return embedded;
 	}
 
 	public String getComponentClassName() {
 		return componentClassName;
 	}
 
 	public Class getComponentClass() throws MappingException {
+		final ClassLoaderService classLoaderService = getMetadata().getMetadataBuildingOptions()
+				.getServiceRegistry()
+				.getService( ClassLoaderService.class );
 		try {
-			return ReflectHelper.classForName(componentClassName);
+			return classLoaderService.classForName( componentClassName );
 		}
-		catch (ClassNotFoundException cnfe) {
-			throw new MappingException("component class not found: " + componentClassName, cnfe);
+		catch (ClassLoadingException e) {
+			throw new MappingException("component class not found: " + componentClassName, e);
 		}
 	}
 
 	public PersistentClass getOwner() {
 		return owner;
 	}
 
 	public String getParentProperty() {
 		return parentProperty;
 	}
 
 	public void setComponentClassName(String componentClass) {
 		this.componentClassName = componentClass;
 	}
 
 	public void setEmbedded(boolean embedded) {
 		this.embedded = embedded;
 	}
 
 	public void setOwner(PersistentClass owner) {
 		this.owner = owner;
 	}
 
 	public void setParentProperty(String parentProperty) {
 		this.parentProperty = parentProperty;
 	}
 
 	public boolean isDynamic() {
 		return dynamic;
 	}
 
 	public void setDynamic(boolean dynamic) {
 		this.dynamic = dynamic;
 	}
 
 	@Override
 	public Type getType() throws MappingException {
 		// TODO : temporary initial step towards HHH-1907
-		final ComponentMetamodel metamodel = new ComponentMetamodel( this );
+		final ComponentMetamodel metamodel = new ComponentMetamodel( this, getMetadata().getMetadataBuildingOptions() );
 		final TypeFactory factory = getMetadata().getTypeResolver().getTypeFactory();
 		return isEmbedded() ? factory.embeddedComponent( metamodel ) : factory.component( metamodel );
 	}
 
 	@Override
 	public void setTypeUsingReflection(String className, String propertyName)
 		throws MappingException {
 	}
 
 	@Override
 	public java.util.Map getMetaAttributes() {
 		return metaAttributes;
 	}
 
 	@Override
 	public MetaAttribute getMetaAttribute(String attributeName) {
 		return metaAttributes==null?null:(MetaAttribute) metaAttributes.get(attributeName);
 	}
 
 	@Override
 	public void setMetaAttributes(java.util.Map metas) {
 		this.metaAttributes = metas;
 	}
 
 	@Override
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept(this);
 	}
 
 	@Override
 	public boolean[] getColumnInsertability() {
 		boolean[] result = new boolean[ getColumnSpan() ];
 		Iterator iter = getPropertyIterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			boolean[] chunk = prop.getValue().getColumnInsertability();
 			if ( prop.isInsertable() ) {
 				System.arraycopy(chunk, 0, result, i, chunk.length);
 			}
 			i+=chunk.length;
 		}
 		return result;
 	}
 
 	@Override
 	public boolean[] getColumnUpdateability() {
 		boolean[] result = new boolean[ getColumnSpan() ];
 		Iterator iter = getPropertyIterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			boolean[] chunk = prop.getValue().getColumnUpdateability();
 			if ( prop.isUpdateable() ) {
 				System.arraycopy(chunk, 0, result, i, chunk.length);
 			}
 			i+=chunk.length;
 		}
 		return result;
 	}
 	
 	public String getNodeName() {
 		return nodeName;
 	}
 	
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 	
 	public boolean isKey() {
 		return isKey;
 	}
 	
 	public void setKey(boolean isKey) {
 		this.isKey = isKey;
 	}
 	
 	public boolean hasPojoRepresentation() {
 		return componentClassName!=null;
 	}
 
 	public void addTuplizer(EntityMode entityMode, String implClassName) {
 		if ( tuplizerImpls == null ) {
 			tuplizerImpls = new HashMap<EntityMode,String>();
 		}
 		tuplizerImpls.put( entityMode, implClassName );
 	}
 
 	public String getTuplizerImplClassName(EntityMode mode) {
 		// todo : remove this once ComponentMetamodel is complete and merged
 		if ( tuplizerImpls == null ) {
 			return null;
 		}
 		return tuplizerImpls.get( mode );
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public Map getTuplizerMap() {
 		if ( tuplizerImpls == null ) {
 			return null;
 		}
 		return java.util.Collections.unmodifiableMap( tuplizerImpls );
 	}
 
 	public Property getProperty(String propertyName) throws MappingException {
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			if ( prop.getName().equals(propertyName) ) {
 				return prop;
 			}
 		}
 		throw new MappingException("component property not found: " + propertyName);
 	}
 
 	public String getRoleName() {
 		return roleName;
 	}
 
 	public void setRoleName(String roleName) {
 		this.roleName = roleName;
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + properties.toString() + ')';
 	}
 
 	private IdentifierGenerator builtIdentifierGenerator;
 
 	@Override
 	public IdentifierGenerator createIdentifierGenerator(
 			IdentifierGeneratorFactory identifierGeneratorFactory,
 			Dialect dialect,
 			String defaultCatalog,
 			String defaultSchema,
 			RootClass rootClass) throws MappingException {
 		if ( builtIdentifierGenerator == null ) {
 			builtIdentifierGenerator = buildIdentifierGenerator(
 					identifierGeneratorFactory,
 					dialect,
 					defaultCatalog,
 					defaultSchema,
 					rootClass
 			);
 		}
 		return builtIdentifierGenerator;
 	}
 
 	private IdentifierGenerator buildIdentifierGenerator(
 			IdentifierGeneratorFactory identifierGeneratorFactory,
 			Dialect dialect,
 			String defaultCatalog,
 			String defaultSchema,
 			RootClass rootClass) throws MappingException {
 		final boolean hasCustomGenerator = ! DEFAULT_ID_GEN_STRATEGY.equals( getIdentifierGeneratorStrategy() );
 		if ( hasCustomGenerator ) {
 			return super.createIdentifierGenerator(
 					identifierGeneratorFactory, dialect, defaultCatalog, defaultSchema, rootClass
 			);
 		}
 
 		final Class entityClass = rootClass.getMappedClass();
 		final Class attributeDeclarer; // what class is the declarer of the composite pk attributes
 		CompositeNestedGeneratedValueGenerator.GenerationContextLocator locator;
 
 		// IMPL NOTE : See the javadoc discussion on CompositeNestedGeneratedValueGenerator wrt the
 		//		various scenarios for which we need to account here
 		if ( rootClass.getIdentifierMapper() != null ) {
 			// we have the @IdClass / <composite-id mapped="true"/> case
 			attributeDeclarer = resolveComponentClass();
 		}
 		else if ( rootClass.getIdentifierProperty() != null ) {
 			// we have the "@EmbeddedId" / <composite-id name="idName"/> case
 			attributeDeclarer = resolveComponentClass();
 		}
 		else {
 			// we have the "straight up" embedded (again the hibernate term) component identifier
 			attributeDeclarer = entityClass;
 		}
 
 		locator = new StandardGenerationContextLocator( rootClass.getEntityName() );
 		final CompositeNestedGeneratedValueGenerator generator = new CompositeNestedGeneratedValueGenerator( locator );
 
 		Iterator itr = getPropertyIterator();
 		while ( itr.hasNext() ) {
 			final Property property = (Property) itr.next();
 			if ( property.getValue().isSimpleValue() ) {
 				final SimpleValue value = (SimpleValue) property.getValue();
 
 				if ( DEFAULT_ID_GEN_STRATEGY.equals( value.getIdentifierGeneratorStrategy() ) ) {
 					// skip any 'assigned' generators, they would have been handled by
 					// the StandardGenerationContextLocator
 					continue;
 				}
 
 				final IdentifierGenerator valueGenerator = value.createIdentifierGenerator(
 						identifierGeneratorFactory,
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						rootClass
 				);
 				generator.addGeneratedValuePlan(
 						new ValueGenerationPlan(
 								valueGenerator,
 								injector( property, attributeDeclarer )
 						)
 				);
 			}
 		}
 		return generator;
 	}
 
 	private Setter injector(Property property, Class attributeDeclarer) {
-		return property.getPropertyAccessor( attributeDeclarer )
-				.getSetter( attributeDeclarer, property.getName() );
+		return property.getPropertyAccessStrategy( attributeDeclarer )
+				.buildPropertyAccess( attributeDeclarer, property.getName() )
+				.getSetter();
 	}
 
 	private Class resolveComponentClass() {
 		try {
 			return getComponentClass();
 		}
 		catch ( Exception e ) {
 			return null;
 		}
 	}
 
 	public static class StandardGenerationContextLocator
 			implements CompositeNestedGeneratedValueGenerator.GenerationContextLocator {
 		private final String entityName;
 
 		public StandardGenerationContextLocator(String entityName) {
 			this.entityName = entityName;
 		}
 
 		@Override
 		public Serializable locateGenerationContext(SessionImplementor session, Object incomingObject) {
 			return session.getEntityPersister( entityName, incomingObject ).getIdentifier( incomingObject, session );
 		}
 	}
 
 	public static class ValueGenerationPlan implements CompositeNestedGeneratedValueGenerator.GenerationPlan {
 		private final IdentifierGenerator subGenerator;
 		private final Setter injector;
 
 		public ValueGenerationPlan(
 				IdentifierGenerator subGenerator,
 				Setter injector) {
 			this.subGenerator = subGenerator;
 			this.injector = injector;
 		}
 
 		@Override
 		public void execute(SessionImplementor session, Object incomingObject, Object injectionContext) {
 			final Object generatedValue = subGenerator.generate( session, incomingObject );
 			injector.set( injectionContext, generatedValue, session.getFactory() );
 		}
 
 		@Override
 		public void registerExportables(Database database) {
 			if ( ExportableProducer.class.isInstance( subGenerator ) ) {
 				( (ExportableProducer) subGenerator ).registerExportables( database );
 			}
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/IndexBackref.java b/hibernate-core/src/main/java/org/hibernate/mapping/IndexBackref.java
index 4fee78803d..f156eb3aca 100755
--- a/hibernate-core/src/main/java/org/hibernate/mapping/IndexBackref.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/IndexBackref.java
@@ -1,54 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
-import org.hibernate.property.IndexPropertyAccessor;
-import org.hibernate.property.PropertyAccessor;
+import org.hibernate.MappingException;
+import org.hibernate.property.access.internal.PropertyAccessStrategyIndexBackRefImpl;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
 
 /**
  * @author Gavin King
  */
 public class IndexBackref extends Property {
 	private String collectionRole;
 	private String entityName;
 
 	@Override
 	public boolean isBackRef() {
 		return true;
 	}
 
 	@Override
 	public boolean isSynthetic() {
 		return true;
 	}
 
 	public String getCollectionRole() {
 		return collectionRole;
 	}
 
 	public void setCollectionRole(String collectionRole) {
 		this.collectionRole = collectionRole;
 	}
 
 	@Override
 	public boolean isBasicPropertyAccessor() {
 		return false;
 	}
 
+	private PropertyAccessStrategy accessStrategy;
+
 	@Override
-	public PropertyAccessor getPropertyAccessor(Class clazz) {
-		return new IndexPropertyAccessor(collectionRole, entityName);
+	public PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {
+		if ( accessStrategy == null ) {
+			accessStrategy = new PropertyAccessStrategyIndexBackRefImpl( collectionRole, entityName );
+		}
+		return accessStrategy;
 	}
-	
+
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/JoinedSubclass.java b/hibernate-core/src/main/java/org/hibernate/mapping/JoinedSubclass.java
index dc0fb7b140..5bac28be01 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/JoinedSubclass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/JoinedSubclass.java
@@ -1,62 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 import java.util.Iterator;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.spi.Mapping;
 
 /**
  * A subclass in a table-per-subclass mapping
  * @author Gavin King
  */
 public class JoinedSubclass extends Subclass implements TableOwner {
-
 	private Table table;
 	private KeyValue key;
 
-	public JoinedSubclass(PersistentClass superclass) {
-		super(superclass);
+	public JoinedSubclass(PersistentClass superclass, MetadataBuildingContext metadataBuildingContext) {
+		super( superclass, metadataBuildingContext );
 	}
 
 	public Table getTable() {
 		return table;
 	}
 
 	public void setTable(Table table) {
 		this.table=table;
 		getSuperclass().addSubclassTable(table);
 	}
 
 	public KeyValue getKey() {
 		return key;
 	}
 
 	public void setKey(KeyValue key) {
 		this.key = key;
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		super.validate(mapping);
 		if ( key!=null && !key.isValid(mapping) ) {
 			throw new MappingException(
 					"subclass key mapping has wrong number of columns: " +
 					getEntityName() +
 					" type: " +
 					key.getType().getName()
 				);
 		}
 	}
 
 	public Iterator getReferenceablePropertyIterator() {
 		return getPropertyIterator();
 	}
 
 	public Object accept(PersistentClassVisitor mv) {
 		return mv.accept(this);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/OneToMany.java b/hibernate-core/src/main/java/org/hibernate/mapping/OneToMany.java
index c621bc236f..3b1da02065 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/OneToMany.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/OneToMany.java
@@ -1,165 +1,171 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.util.Iterator;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.engine.spi.Mapping;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * A mapping for a one-to-many association
  *
  * @author Gavin King
  */
 public class OneToMany implements Value {
 	private final MetadataImplementor metadata;
 	private final Table referencingTable;
 
 	private String referencedEntityName;
 	private PersistentClass associatedClass;
 	private boolean embedded;
 	private boolean ignoreNotFound;
 
 	public OneToMany(MetadataImplementor metadata, PersistentClass owner) throws MappingException {
 		this.metadata = metadata;
 		this.referencingTable = ( owner == null ) ? null : owner.getTable();
 	}
 
+	@Override
+	public ServiceRegistry getServiceRegistry() {
+		return metadata.getMetadataBuildingOptions().getServiceRegistry();
+	}
+
 	private EntityType getEntityType() {
 		return metadata.getTypeResolver().getTypeFactory().manyToOne(
 				getReferencedEntityName(),
 				true,
 				null,
 				false,
 				false,
 				isIgnoreNotFound(),
 				false
 		);
 	}
 
 	public PersistentClass getAssociatedClass() {
 		return associatedClass;
 	}
 
 	/**
 	 * Associated entity on the many side
 	 */
 	public void setAssociatedClass(PersistentClass associatedClass) {
 		this.associatedClass = associatedClass;
 	}
 
 	public void createForeignKey() {
 		// no foreign key element of for a one-to-many
 	}
 
 	public Iterator<Selectable> getColumnIterator() {
 		return associatedClass.getKey().getColumnIterator();
 	}
 
 	public int getColumnSpan() {
 		return associatedClass.getKey().getColumnSpan();
 	}
 
 	public FetchMode getFetchMode() {
 		return FetchMode.JOIN;
 	}
 
 	/**
 	 * Table of the owner entity (the "one" side)
 	 */
 	public Table getTable() {
 		return referencingTable;
 	}
 
 	public Type getType() {
 		return getEntityType();
 	}
 
 	public boolean isNullable() {
 		return false;
 	}
 
 	public boolean isSimpleValue() {
 		return false;
 	}
 
 	public boolean isAlternateUniqueKey() {
 		return false;
 	}
 
 	public boolean hasFormula() {
 		return false;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		if ( referencedEntityName == null ) {
 			throw new MappingException( "one to many association must specify the referenced entity" );
 		}
 		return true;
 	}
 
 	public String getReferencedEntityName() {
 		return referencedEntityName;
 	}
 
 	/**
 	 * Associated entity on the "many" side
 	 */
 	public void setReferencedEntityName(String referencedEntityName) {
 		this.referencedEntityName = referencedEntityName == null ? null : referencedEntityName.intern();
 	}
 
 	public void setTypeUsingReflection(String className, String propertyName) {
 	}
 
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept( this );
 	}
 
 
 	public boolean[] getColumnInsertability() {
 		//TODO: we could just return all false...
 		throw new UnsupportedOperationException();
 	}
 
 	public boolean[] getColumnUpdateability() {
 		//TODO: we could just return all false...
 		throw new UnsupportedOperationException();
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public boolean isEmbedded() {
 		return embedded;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public void setEmbedded(boolean embedded) {
 		this.embedded = embedded;
 	}
 
 	public boolean isIgnoreNotFound() {
 		return ignoreNotFound;
 	}
 
 	public void setIgnoreNotFound(boolean ignoreNotFound) {
 		this.ignoreNotFound = ignoreNotFound;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java b/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
index 712aa3e678..0c47d9687f 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
@@ -1,916 +1,929 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.FilterConfiguration;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.collections.SingletonIterator;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.sql.Alias;
 
 /**
  * Mapping for an entity.
  *
  * @author Gavin King
  */
 public abstract class PersistentClass implements AttributeContainer, Serializable, Filterable, MetaAttributable {
-
 	private static final Alias PK_ALIAS = new Alias( 15, "PK" );
 
 	public static final String NULL_DISCRIMINATOR_MAPPING = "null";
 	public static final String NOT_NULL_DISCRIMINATOR_MAPPING = "not null";
 
+	private final MetadataBuildingContext metadataBuildingContext;
+
 	private String entityName;
 
 	private String className;
 	private transient Class mappedClass;
 
 	private String proxyInterfaceName;
 	private transient Class proxyInterface;
 
 	private String nodeName;
 	private String jpaEntityName;
 
 	private String discriminatorValue;
 	private boolean lazy;
 	private ArrayList properties = new ArrayList();
 	private ArrayList declaredProperties = new ArrayList();
 	private final ArrayList<Subclass> subclasses = new ArrayList<Subclass>();
 	private final ArrayList subclassProperties = new ArrayList();
 	private final ArrayList subclassTables = new ArrayList();
 	private boolean dynamicInsert;
 	private boolean dynamicUpdate;
 	private int batchSize = -1;
 	private boolean selectBeforeUpdate;
 	private java.util.Map metaAttributes;
 	private ArrayList<Join> joins = new ArrayList<Join>();
 	private final ArrayList subclassJoins = new ArrayList();
 	private final java.util.List filters = new ArrayList();
 	protected final java.util.Set synchronizedTables = new HashSet();
 	private String loaderName;
 	private Boolean isAbstract;
 	private boolean hasSubselectLoadableCollections;
 	private Component identifierMapper;
 
 	// Custom SQL
 	private String customSQLInsert;
 	private boolean customInsertCallable;
 	private ExecuteUpdateResultCheckStyle insertCheckStyle;
 	private String customSQLUpdate;
 	private boolean customUpdateCallable;
 	private ExecuteUpdateResultCheckStyle updateCheckStyle;
 	private String customSQLDelete;
 	private boolean customDeleteCallable;
 	private ExecuteUpdateResultCheckStyle deleteCheckStyle;
 
 	private java.util.Map tuplizerImpls;
 
 	private MappedSuperclass superMappedSuperclass;
 	private Component declaredIdentifierMapper;
 	private OptimisticLockStyle optimisticLockStyle;
 
+	public PersistentClass(MetadataBuildingContext metadataBuildingContext) {
+		this.metadataBuildingContext = metadataBuildingContext;
+	}
+
+	public ServiceRegistry getServiceRegistry() {
+		return metadataBuildingContext.getBuildingOptions().getServiceRegistry();
+	}
+
 	public String getClassName() {
 		return className;
 	}
 
 	public void setClassName(String className) {
 		this.className = className == null ? null : className.intern();
 		this.mappedClass = null;
 	}
 
 	public String getProxyInterfaceName() {
 		return proxyInterfaceName;
 	}
 
 	public void setProxyInterfaceName(String proxyInterfaceName) {
 		this.proxyInterfaceName = proxyInterfaceName;
 		this.proxyInterface = null;
 	}
 
 	public Class getMappedClass() throws MappingException {
 		if ( className == null ) {
 			return null;
 		}
+
 		try {
 			if ( mappedClass == null ) {
-				mappedClass = ReflectHelper.classForName( className );
+				mappedClass = metadataBuildingContext.getClassLoaderAccess().classForName( className );
 			}
 			return mappedClass;
 		}
-		catch (ClassNotFoundException cnfe) {
-			throw new MappingException( "entity class not found: " + className, cnfe );
+		catch (ClassLoadingException e) {
+			throw new MappingException( "entity class not found: " + className, e );
 		}
 	}
 
 	public Class getProxyInterface() {
 		if ( proxyInterfaceName == null ) {
 			return null;
 		}
 		try {
 			if ( proxyInterface == null ) {
-				proxyInterface = ReflectHelper.classForName( proxyInterfaceName );
+				proxyInterface = metadataBuildingContext.getClassLoaderAccess().classForName( proxyInterfaceName );
 			}
 			return proxyInterface;
 		}
-		catch (ClassNotFoundException cnfe) {
-			throw new MappingException( "proxy class not found: " + proxyInterfaceName, cnfe );
+		catch (ClassLoadingException e) {
+			throw new MappingException( "proxy class not found: " + proxyInterfaceName, e );
 		}
 	}
 
 	public boolean useDynamicInsert() {
 		return dynamicInsert;
 	}
 
 	abstract int nextSubclassId();
 
 	public abstract int getSubclassId();
 
 	public boolean useDynamicUpdate() {
 		return dynamicUpdate;
 	}
 
 	public void setDynamicInsert(boolean dynamicInsert) {
 		this.dynamicInsert = dynamicInsert;
 	}
 
 	public void setDynamicUpdate(boolean dynamicUpdate) {
 		this.dynamicUpdate = dynamicUpdate;
 	}
 
 
 	public String getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	public void addSubclass(Subclass subclass) throws MappingException {
 		// inheritance cycle detection (paranoid check)
 		PersistentClass superclass = getSuperclass();
 		while ( superclass != null ) {
 			if ( subclass.getEntityName().equals( superclass.getEntityName() ) ) {
 				throw new MappingException(
 						"Circular inheritance mapping detected: " +
 								subclass.getEntityName() +
 								" will have it self as superclass when extending " +
 								getEntityName()
 				);
 			}
 			superclass = superclass.getSuperclass();
 		}
 		subclasses.add( subclass );
 	}
 
 	public boolean hasSubclasses() {
 		return subclasses.size() > 0;
 	}
 
 	public int getSubclassSpan() {
 		int n = subclasses.size();
 		for ( Subclass subclass : subclasses ) {
 			n += subclass.getSubclassSpan();
 		}
 		return n;
 	}
 
 	/**
 	 * Iterate over subclasses in a special 'order', most derived subclasses
 	 * first.
 	 */
 	public Iterator getSubclassIterator() {
 		Iterator[] iters = new Iterator[subclasses.size() + 1];
 		Iterator iter = subclasses.iterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			iters[i++] = ( (Subclass) iter.next() ).getSubclassIterator();
 		}
 		iters[i] = subclasses.iterator();
 		return new JoinedIterator( iters );
 	}
 
 	public Iterator getSubclassClosureIterator() {
 		ArrayList iters = new ArrayList();
 		iters.add( new SingletonIterator( this ) );
 		Iterator iter = getSubclassIterator();
 		while ( iter.hasNext() ) {
 			PersistentClass clazz = (PersistentClass) iter.next();
 			iters.add( clazz.getSubclassClosureIterator() );
 		}
 		return new JoinedIterator( iters );
 	}
 
 	public Table getIdentityTable() {
 		return getRootTable();
 	}
 
 	public Iterator getDirectSubclasses() {
 		return subclasses.iterator();
 	}
 
 	@Override
 	public void addProperty(Property p) {
 		properties.add( p );
 		declaredProperties.add( p );
 		p.setPersistentClass( this );
 	}
 
 	public abstract Table getTable();
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public abstract boolean isMutable();
 
 	public abstract boolean hasIdentifierProperty();
 
 	public abstract Property getIdentifierProperty();
 
 	public abstract Property getDeclaredIdentifierProperty();
 
 	public abstract KeyValue getIdentifier();
 
 	public abstract Property getVersion();
 
 	public abstract Property getDeclaredVersion();
 
 	public abstract Value getDiscriminator();
 
 	public abstract boolean isInherited();
 
 	public abstract boolean isPolymorphic();
 
 	public abstract boolean isVersioned();
 
 	public abstract String getNaturalIdCacheRegionName();
 
 	public abstract String getCacheConcurrencyStrategy();
 
 	public abstract PersistentClass getSuperclass();
 
 	public abstract boolean isExplicitPolymorphism();
 
 	public abstract boolean isDiscriminatorInsertable();
 
 	public abstract Iterator getPropertyClosureIterator();
 
 	public abstract Iterator getTableClosureIterator();
 
 	public abstract Iterator getKeyClosureIterator();
 
 	protected void addSubclassProperty(Property prop) {
 		subclassProperties.add( prop );
 	}
 
 	protected void addSubclassJoin(Join join) {
 		subclassJoins.add( join );
 	}
 
 	protected void addSubclassTable(Table subclassTable) {
 		subclassTables.add( subclassTable );
 	}
 
 	public Iterator getSubclassPropertyClosureIterator() {
 		ArrayList iters = new ArrayList();
 		iters.add( getPropertyClosureIterator() );
 		iters.add( subclassProperties.iterator() );
 		for ( int i = 0; i < subclassJoins.size(); i++ ) {
 			Join join = (Join) subclassJoins.get( i );
 			iters.add( join.getPropertyIterator() );
 		}
 		return new JoinedIterator( iters );
 	}
 
 	public Iterator getSubclassJoinClosureIterator() {
 		return new JoinedIterator( getJoinClosureIterator(), subclassJoins.iterator() );
 	}
 
 	public Iterator getSubclassTableClosureIterator() {
 		return new JoinedIterator( getTableClosureIterator(), subclassTables.iterator() );
 	}
 
 	public boolean isClassOrSuperclassJoin(Join join) {
 		return joins.contains( join );
 	}
 
 	public boolean isClassOrSuperclassTable(Table closureTable) {
 		return getTable() == closureTable;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public abstract boolean hasEmbeddedIdentifier();
 
 	public abstract Class getEntityPersisterClass();
 
 	public abstract void setEntityPersisterClass(Class classPersisterClass);
 
 	public abstract Table getRootTable();
 
 	public abstract RootClass getRootClass();
 
 	public abstract KeyValue getKey();
 
 	public void setDiscriminatorValue(String discriminatorValue) {
 		this.discriminatorValue = discriminatorValue;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName == null ? null : entityName.intern();
 	}
 
 	public void createPrimaryKey() {
 		//Primary key constraint
 		PrimaryKey pk = new PrimaryKey();
 		Table table = getTable();
 		pk.setTable( table );
 		pk.setName( PK_ALIAS.toAliasString( table.getName() ) );
 		table.setPrimaryKey( pk );
 
 		pk.addColumns( getKey().getColumnIterator() );
 	}
 
 	public abstract String getWhere();
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int batchSize) {
 		this.batchSize = batchSize;
 	}
 
 	public boolean hasSelectBeforeUpdate() {
 		return selectBeforeUpdate;
 	}
 
 	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
 		this.selectBeforeUpdate = selectBeforeUpdate;
 	}
 
 	/**
 	 * Build an iterator of properties which are "referenceable".
 	 *
 	 * @return The property iterator.
 	 *
 	 * @see #getReferencedProperty for a discussion of "referenceable"
 	 */
 	public Iterator getReferenceablePropertyIterator() {
 		return getPropertyClosureIterator();
 	}
 
 	/**
 	 * Given a property path, locate the appropriate referenceable property reference.
 	 * <p/>
 	 * A referenceable property is a property  which can be a target of a foreign-key
 	 * mapping (an identifier or explcitly named in a property-ref).
 	 *
 	 * @param propertyPath The property path to resolve into a property reference.
 	 *
 	 * @return The property reference (never null).
 	 *
 	 * @throws MappingException If the property could not be found.
 	 */
 	public Property getReferencedProperty(String propertyPath) throws MappingException {
 		try {
 			return getRecursiveProperty( propertyPath, getReferenceablePropertyIterator() );
 		}
 		catch (MappingException e) {
 			throw new MappingException(
 					"property-ref [" + propertyPath + "] not found on entity [" + getEntityName() + "]", e
 			);
 		}
 	}
 
 	public Property getRecursiveProperty(String propertyPath) throws MappingException {
 		try {
 			return getRecursiveProperty( propertyPath, getPropertyIterator() );
 		}
 		catch (MappingException e) {
 			throw new MappingException(
 					"property [" + propertyPath + "] not found on entity [" + getEntityName() + "]", e
 			);
 		}
 	}
 
 	private Property getRecursiveProperty(String propertyPath, Iterator iter) throws MappingException {
 		Property property = null;
 		StringTokenizer st = new StringTokenizer( propertyPath, ".", false );
 		try {
 			while ( st.hasMoreElements() ) {
 				final String element = (String) st.nextElement();
 				if ( property == null ) {
 					Property identifierProperty = getIdentifierProperty();
 					if ( identifierProperty != null && identifierProperty.getName().equals( element ) ) {
 						// we have a mapped identifier property and the root of
 						// the incoming property path matched that identifier
 						// property
 						property = identifierProperty;
 					}
 					else if ( identifierProperty == null && getIdentifierMapper() != null ) {
 						// we have an embedded composite identifier
 						try {
 							identifierProperty = getProperty( element, getIdentifierMapper().getPropertyIterator() );
 							if ( identifierProperty != null ) {
 								// the root of the incoming property path matched one
 								// of the embedded composite identifier properties
 								property = identifierProperty;
 							}
 						}
 						catch (MappingException ignore) {
 							// ignore it...
 						}
 					}
 
 					if ( property == null ) {
 						property = getProperty( element, iter );
 					}
 				}
 				else {
 					//flat recursive algorithm
 					property = ( (Component) property.getValue() ).getProperty( element );
 				}
 			}
 		}
 		catch (MappingException e) {
 			throw new MappingException( "property [" + propertyPath + "] not found on entity [" + getEntityName() + "]" );
 		}
 
 		return property;
 	}
 
 	private Property getProperty(String propertyName, Iterator iterator) throws MappingException {
 		if ( iterator.hasNext() ) {
 			String root = StringHelper.root( propertyName );
 			while ( iterator.hasNext() ) {
 				Property prop = (Property) iterator.next();
 				if ( prop.getName().equals( root ) ) {
 					return prop;
 				}
 			}
 		}
 		throw new MappingException( "property [" + propertyName + "] not found on entity [" + getEntityName() + "]" );
 	}
 
 	public Property getProperty(String propertyName) throws MappingException {
 		Iterator iter = getPropertyClosureIterator();
 		Property identifierProperty = getIdentifierProperty();
 		if ( identifierProperty != null
 				&& identifierProperty.getName().equals( StringHelper.root( propertyName ) ) ) {
 			return identifierProperty;
 		}
 		else {
 			return getProperty( propertyName, iter );
 		}
 	}
 
 	/**
 	 * @deprecated prefer {@link #getOptimisticLockStyle}
 	 */
 	@Deprecated
 	public int getOptimisticLockMode() {
 		return getOptimisticLockStyle().getOldCode();
 	}
 
 	/**
 	 * @deprecated prefer {@link #setOptimisticLockStyle}
 	 */
 	@Deprecated
 	public void setOptimisticLockMode(int optimisticLockMode) {
 		setOptimisticLockStyle( OptimisticLockStyle.interpretOldCode( optimisticLockMode ) );
 	}
 
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return optimisticLockStyle;
 	}
 
 	public void setOptimisticLockStyle(OptimisticLockStyle optimisticLockStyle) {
 		this.optimisticLockStyle = optimisticLockStyle;
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			if ( !prop.isValid( mapping ) ) {
 				throw new MappingException(
 						"property mapping has wrong number of columns: " +
 								StringHelper.qualify( getEntityName(), prop.getName() ) +
 								" type: " +
 								prop.getType().getName()
 				);
 			}
 		}
 		checkPropertyDuplication();
 		checkColumnDuplication();
 	}
 
 	private void checkPropertyDuplication() throws MappingException {
 		HashSet<String> names = new HashSet<String>();
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			if ( !names.add( prop.getName() ) ) {
 				throw new MappingException( "Duplicate property mapping of " + prop.getName() + " found in " + getEntityName() );
 			}
 		}
 	}
 
 	public boolean isDiscriminatorValueNotNull() {
 		return NOT_NULL_DISCRIMINATOR_MAPPING.equals( getDiscriminatorValue() );
 	}
 
 	public boolean isDiscriminatorValueNull() {
 		return NULL_DISCRIMINATOR_MAPPING.equals( getDiscriminatorValue() );
 	}
 
 	public java.util.Map getMetaAttributes() {
 		return metaAttributes;
 	}
 
 	public void setMetaAttributes(java.util.Map metas) {
 		this.metaAttributes = metas;
 	}
 
 	public MetaAttribute getMetaAttribute(String name) {
 		return metaAttributes == null
 				? null
 				: (MetaAttribute) metaAttributes.get( name );
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + getEntityName() + ')';
 	}
 
 	public Iterator getJoinIterator() {
 		return joins.iterator();
 	}
 
 	public Iterator getJoinClosureIterator() {
 		return joins.iterator();
 	}
 
 	public void addJoin(Join join) {
 		joins.add( join );
 		join.setPersistentClass( this );
 	}
 
 	public int getJoinClosureSpan() {
 		return joins.size();
 	}
 
 	public int getPropertyClosureSpan() {
 		int span = properties.size();
 		for ( Join join : joins ) {
 			span += join.getPropertySpan();
 		}
 		return span;
 	}
 
 	public int getJoinNumber(Property prop) {
 		int result = 1;
 		Iterator iter = getSubclassJoinClosureIterator();
 		while ( iter.hasNext() ) {
 			Join join = (Join) iter.next();
 			if ( join.containsProperty( prop ) ) {
 				return result;
 			}
 			result++;
 		}
 		return 0;
 	}
 
 	/**
 	 * Build an iterator over the properties defined on this class.  The returned
 	 * iterator only accounts for "normal" properties (i.e. non-identifier
 	 * properties).
 	 * <p/>
 	 * Differs from {@link #getUnjoinedPropertyIterator} in that the iterator
 	 * we return here will include properties defined as part of a join.
 	 *
 	 * @return An iterator over the "normal" properties.
 	 */
 	public Iterator getPropertyIterator() {
 		ArrayList iterators = new ArrayList();
 		iterators.add( properties.iterator() );
 		for ( int i = 0; i < joins.size(); i++ ) {
 			Join join = (Join) joins.get( i );
 			iterators.add( join.getPropertyIterator() );
 		}
 		return new JoinedIterator( iterators );
 	}
 
 	/**
 	 * Build an iterator over the properties defined on this class <b>which
 	 * are not defined as part of a join</b>.  As with {@link #getPropertyIterator},
 	 * the returned iterator only accounts for non-identifier properties.
 	 *
 	 * @return An iterator over the non-joined "normal" properties.
 	 */
 	public Iterator getUnjoinedPropertyIterator() {
 		return properties.iterator();
 	}
 
 	public void setCustomSQLInsert(String customSQLInsert, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLInsert = customSQLInsert;
 		this.customInsertCallable = callable;
 		this.insertCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLInsert() {
 		return customSQLInsert;
 	}
 
 	public boolean isCustomInsertCallable() {
 		return customInsertCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLInsertCheckStyle() {
 		return insertCheckStyle;
 	}
 
 	public void setCustomSQLUpdate(String customSQLUpdate, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLUpdate = customSQLUpdate;
 		this.customUpdateCallable = callable;
 		this.updateCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLUpdate() {
 		return customSQLUpdate;
 	}
 
 	public boolean isCustomUpdateCallable() {
 		return customUpdateCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLUpdateCheckStyle() {
 		return updateCheckStyle;
 	}
 
 	public void setCustomSQLDelete(String customSQLDelete, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDelete = customSQLDelete;
 		this.customDeleteCallable = callable;
 		this.deleteCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDelete() {
 		return customSQLDelete;
 	}
 
 	public boolean isCustomDeleteCallable() {
 		return customDeleteCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteCheckStyle() {
 		return deleteCheckStyle;
 	}
 
 	public void addFilter(
 			String name,
 			String condition,
 			boolean autoAliasInjection,
 			java.util.Map<String, String> aliasTableMap,
 			java.util.Map<String, String> aliasEntityMap) {
 		filters.add(
 				new FilterConfiguration(
 						name,
 						condition,
 						autoAliasInjection,
 						aliasTableMap,
 						aliasEntityMap,
 						this
 				)
 		);
 	}
 
 	public java.util.List getFilters() {
 		return filters;
 	}
 
 	public boolean isForceDiscriminator() {
 		return false;
 	}
 
 	public abstract boolean isJoinedSubclass();
 
 	public String getLoaderName() {
 		return loaderName;
 	}
 
 	public void setLoaderName(String loaderName) {
 		this.loaderName = loaderName == null ? null : loaderName.intern();
 	}
 
 	public abstract java.util.Set getSynchronizedTables();
 
 	public void addSynchronizedTable(String table) {
 		synchronizedTables.add( table );
 	}
 
 	public Boolean isAbstract() {
 		return isAbstract;
 	}
 
 	public void setAbstract(Boolean isAbstract) {
 		this.isAbstract = isAbstract;
 	}
 
 	protected void checkColumnDuplication(Set distinctColumns, Iterator columns)
 			throws MappingException {
 		while ( columns.hasNext() ) {
 			Selectable columnOrFormula = (Selectable) columns.next();
 			if ( !columnOrFormula.isFormula() ) {
 				Column col = (Column) columnOrFormula;
 				if ( !distinctColumns.add( col.getName() ) ) {
 					throw new MappingException(
 							"Repeated column in mapping for entity: " +
 									getEntityName() +
 									" column: " +
 									col.getName() +
 									" (should be mapped with insert=\"false\" update=\"false\")"
 					);
 				}
 			}
 		}
 	}
 
 	protected void checkPropertyColumnDuplication(Set distinctColumns, Iterator properties)
 			throws MappingException {
 		while ( properties.hasNext() ) {
 			Property prop = (Property) properties.next();
 			if ( prop.getValue() instanceof Component ) { //TODO: remove use of instanceof!
 				Component component = (Component) prop.getValue();
 				checkPropertyColumnDuplication( distinctColumns, component.getPropertyIterator() );
 			}
 			else {
 				if ( prop.isUpdateable() || prop.isInsertable() ) {
 					checkColumnDuplication( distinctColumns, prop.getColumnIterator() );
 				}
 			}
 		}
 	}
 
 	protected Iterator getNonDuplicatedPropertyIterator() {
 		return getUnjoinedPropertyIterator();
 	}
 
 	protected Iterator getDiscriminatorColumnIterator() {
 		return EmptyIterator.INSTANCE;
 	}
 
 	protected void checkColumnDuplication() {
 		HashSet cols = new HashSet();
 		if ( getIdentifierMapper() == null ) {
 			//an identifier mapper => getKey will be included in the getNonDuplicatedPropertyIterator()
 			//and checked later, so it needs to be excluded
 			checkColumnDuplication( cols, getKey().getColumnIterator() );
 		}
 		checkColumnDuplication( cols, getDiscriminatorColumnIterator() );
 		checkPropertyColumnDuplication( cols, getNonDuplicatedPropertyIterator() );
 		Iterator iter = getJoinIterator();
 		while ( iter.hasNext() ) {
 			cols.clear();
 			Join join = (Join) iter.next();
 			checkColumnDuplication( cols, join.getKey().getColumnIterator() );
 			checkPropertyColumnDuplication( cols, join.getPropertyIterator() );
 		}
 	}
 
 	public abstract Object accept(PersistentClassVisitor mv);
 
 	public String getNodeName() {
 		return nodeName;
 	}
 
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 
 	public String getJpaEntityName() {
 		return jpaEntityName;
 	}
 
 	public void setJpaEntityName(String jpaEntityName) {
 		this.jpaEntityName = jpaEntityName;
 	}
 
 	public boolean hasPojoRepresentation() {
 		return getClassName() != null;
 	}
 
 	public boolean hasDom4jRepresentation() {
 		return getNodeName() != null;
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 
 	public void setSubselectLoadableCollections(boolean hasSubselectCollections) {
 		this.hasSubselectLoadableCollections = hasSubselectCollections;
 	}
 
 	public Component getIdentifierMapper() {
 		return identifierMapper;
 	}
 
 	public Component getDeclaredIdentifierMapper() {
 		return declaredIdentifierMapper;
 	}
 
 	public void setDeclaredIdentifierMapper(Component declaredIdentifierMapper) {
 		this.declaredIdentifierMapper = declaredIdentifierMapper;
 	}
 
 	public boolean hasIdentifierMapper() {
 		return identifierMapper != null;
 	}
 
 	public void setIdentifierMapper(Component handle) {
 		this.identifierMapper = handle;
 	}
 
 	public void addTuplizer(EntityMode entityMode, String implClassName) {
 		if ( tuplizerImpls == null ) {
 			tuplizerImpls = new HashMap();
 		}
 		tuplizerImpls.put( entityMode, implClassName );
 	}
 
 	public String getTuplizerImplClassName(EntityMode mode) {
 		if ( tuplizerImpls == null ) {
 			return null;
 		}
 		return (String) tuplizerImpls.get( mode );
 	}
 
 	public java.util.Map getTuplizerMap() {
 		if ( tuplizerImpls == null ) {
 			return null;
 		}
 		return java.util.Collections.unmodifiableMap( tuplizerImpls );
 	}
 
 	public boolean hasNaturalId() {
 		Iterator props = getRootClass().getPropertyIterator();
 		while ( props.hasNext() ) {
 			if ( ( (Property) props.next() ).isNaturalIdentifier() ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	public abstract boolean isLazyPropertiesCacheable();
 
 	// The following methods are added to support @MappedSuperclass in the metamodel
 	public Iterator getDeclaredPropertyIterator() {
 		ArrayList iterators = new ArrayList();
 		iterators.add( declaredProperties.iterator() );
 		for ( int i = 0; i < joins.size(); i++ ) {
 			Join join = (Join) joins.get( i );
 			iterators.add( join.getDeclaredPropertyIterator() );
 		}
 		return new JoinedIterator( iterators );
 	}
 
 	public void addMappedsuperclassProperty(Property p) {
 		properties.add( p );
 		p.setPersistentClass( this );
 	}
 
 	public MappedSuperclass getSuperMappedSuperclass() {
 		return superMappedSuperclass;
 	}
 
 	public void setSuperMappedSuperclass(MappedSuperclass superMappedSuperclass) {
 		this.superMappedSuperclass = superMappedSuperclass;
 	}
 
 	// End of @Mappedsuperclass support
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Property.java b/hibernate-core/src/main/java/org/hibernate/mapping/Property.java
index 9ff2d77c54..2e06e8bdcb 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Property.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Property.java
@@ -1,335 +1,364 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.StringTokenizer;
 
 import org.hibernate.EntityMode;
+import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.PropertyAccessStrategyResolver;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tuple.ValueGeneration;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
 
 /**
  * Represents a property as part of an entity or a component.
  *
  * @author Gavin King
  */
 public class Property implements Serializable, MetaAttributable {
 	private String name;
 	private Value value;
 	private String cascade;
 	private boolean updateable = true;
 	private boolean insertable = true;
 	private boolean selectable = true;
 	private boolean optimisticLocked = true;
 	private ValueGeneration valueGenerationStrategy;
 	private String propertyAccessorName;
 	private boolean lazy;
 	private boolean optional;
 	private String nodeName;
 	private java.util.Map metaAttributes;
 	private PersistentClass persistentClass;
 	private boolean naturalIdentifier;
 	private boolean lob;
 
 	public boolean isBackRef() {
 		return false;
 	}
 
 	/**
 	 * Does this property represent a synthetic property?  A synthetic property is one we create during
 	 * metamodel binding to represent a collection of columns but which does not represent a property
 	 * physically available on the entity.
 	 *
 	 * @return True if synthetic; false otherwise.
 	 */
 	public boolean isSynthetic() {
 		return false;
 	}
 
 	public Type getType() throws MappingException {
 		return value.getType();
 	}
 	
 	public int getColumnSpan() {
 		return value.getColumnSpan();
 	}
 	
 	public Iterator getColumnIterator() {
 		return value.getColumnIterator();
 	}
 	
 	public String getName() {
 		return name;
 	}
 	
 	public boolean isComposite() {
 		return value instanceof Component;
 	}
 
 	public Value getValue() {
 		return value;
 	}
 	
 	public boolean isPrimitive(Class clazz) {
 		return getGetter(clazz).getReturnType().isPrimitive();
 	}
 
 	public CascadeStyle getCascadeStyle() throws MappingException {
 		Type type = value.getType();
 		if ( type.isComponentType() ) {
 			return getCompositeCascadeStyle( (CompositeType) type, cascade );
 		}
 		else if ( type.isCollectionType() ) {
 			return getCollectionCascadeStyle( ( (Collection) value ).getElement().getType(), cascade );
 		}
 		else {
 			return getCascadeStyle( cascade );			
 		}
 	}
 
 	private static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {
 		if ( compositeType.isAnyType() ) {
 			return getCascadeStyle( cascade );
 		}
 		int length = compositeType.getSubtypes().length;
 		for ( int i=0; i<length; i++ ) {
 			if ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {
 				return CascadeStyles.ALL;
 			}
 		}
 		return getCascadeStyle( cascade );
 	}
 
 	private static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {
 		if ( elementType.isComponentType() ) {
 			return getCompositeCascadeStyle( (CompositeType) elementType, cascade );
 		}
 		else {
 			return getCascadeStyle( cascade );
 		}
 	}
 	
 	private static CascadeStyle getCascadeStyle(String cascade) {
 		if ( cascade==null || cascade.equals("none") ) {
 			return CascadeStyles.NONE;
 		}
 		else {
 			StringTokenizer tokens = new StringTokenizer(cascade, ", ");
 			CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;
 			int i=0;
 			while ( tokens.hasMoreTokens() ) {
 				styles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );
 			}
 			return new CascadeStyles.MultipleCascadeStyle(styles);
 		}		
 	}
 	
 	public String getCascade() {
 		return cascade;
 	}
 
 	public void setCascade(String cascade) {
 		this.cascade = cascade;
 	}
 
 	public void setName(String name) {
 		this.name = name==null ? null : name.intern();
 	}
 
 	public void setValue(Value value) {
 		this.value = value;
 	}
 
 	public boolean isUpdateable() {
 		// if the property mapping consists of all formulas,
 		// make it non-updateable
 		return updateable && !ArrayHelper.isAllFalse( value.getColumnUpdateability() );
 	}
 
 	public boolean isInsertable() {
 		// if the property mapping consists of all formulas, 
 		// make it non-insertable
 		final boolean[] columnInsertability = value.getColumnInsertability();
 		return insertable && (
 				columnInsertability.length==0 ||
 				!ArrayHelper.isAllFalse( columnInsertability )
 			);
 	}
 
 	public ValueGeneration getValueGenerationStrategy() {
 		return valueGenerationStrategy;
 	}
 
 	public void setValueGenerationStrategy(ValueGeneration valueGenerationStrategy) {
 		this.valueGenerationStrategy = valueGenerationStrategy;
 	}
 
 	public void setUpdateable(boolean mutable) {
 		this.updateable = mutable;
 	}
 
 	public void setInsertable(boolean insertable) {
 		this.insertable = insertable;
 	}
 
 	public String getPropertyAccessorName() {
 		return propertyAccessorName;
 	}
 
 	public void setPropertyAccessorName(String string) {
 		propertyAccessorName = string;
 	}
 
 	/**
 	 * Approximate!
 	 */
 	boolean isNullable() {
 		return value==null || value.isNullable();
 	}
 
 	public boolean isBasicPropertyAccessor() {
-		return propertyAccessorName==null || "property".equals(propertyAccessorName);
+		return propertyAccessorName==null || "property".equals( propertyAccessorName );
 	}
 
 	public java.util.Map getMetaAttributes() {
 		return metaAttributes;
 	}
 
 	public MetaAttribute getMetaAttribute(String attributeName) {
 		return metaAttributes==null?null:(MetaAttribute) metaAttributes.get(attributeName);
 	}
 
 	public void setMetaAttributes(java.util.Map metas) {
 		this.metaAttributes = metas;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		return getValue().isValid(mapping);
 	}
 
 	public String toString() {
 		return getClass().getName() + '(' + name + ')';
 	}
 	
 	public void setLazy(boolean lazy) {
 		this.lazy=lazy;
 	}
 	
 	public boolean isLazy() {
 		if ( value instanceof ToOne ) {
 			// both many-to-one and one-to-one are represented as a
 			// Property.  EntityPersister is relying on this value to
 			// determine "lazy fetch groups" in terms of field-level
 			// interception.  So we need to make sure that we return
 			// true here for the case of many-to-one and one-to-one
 			// with lazy="no-proxy"
 			//
 			// * impl note - lazy="no-proxy" currently forces both
 			// lazy and unwrap to be set to true.  The other case we
 			// are extremely interested in here is that of lazy="proxy"
 			// where lazy is set to true, but unwrap is set to false.
 			// thus we use both here under the assumption that this
 			// return is really only ever used during persister
 			// construction to determine the lazy property/field fetch
 			// groupings.  If that assertion changes then this check
 			// needs to change as well.  Partially, this is an issue with
 			// the overloading of the term "lazy" here...
 			ToOne toOneValue = ( ToOne ) value;
 			return toOneValue.isLazy() && toOneValue.isUnwrapProxy();
 		}
 		return lazy;
 	}
 	
 	public boolean isOptimisticLocked() {
 		return optimisticLocked;
 	}
 
 	public void setOptimisticLocked(boolean optimisticLocked) {
 		this.optimisticLocked = optimisticLocked;
 	}
 	
 	public boolean isOptional() {
 		return optional || isNullable();
 	}
 	
 	public void setOptional(boolean optional) {
 		this.optional = optional;
 	}
 
 	public PersistentClass getPersistentClass() {
 		return persistentClass;
 	}
 
 	public void setPersistentClass(PersistentClass persistentClass) {
 		this.persistentClass = persistentClass;
 	}
 
 	public boolean isSelectable() {
 		return selectable;
 	}
 	
 	public void setSelectable(boolean selectable) {
 		this.selectable = selectable;
 	}
 
 	public String getNodeName() {
 		return nodeName;
 	}
 
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 
 	public String getAccessorPropertyName( EntityMode mode ) {
 		return getName();
 	}
 
 	// todo : remove
 	public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
-		return getPropertyAccessor(clazz).getGetter( clazz, name );
+		return getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name ).getGetter();
 	}
 
 	// todo : remove
 	public Setter getSetter(Class clazz) throws PropertyNotFoundException, MappingException {
-		return getPropertyAccessor(clazz).getSetter(clazz, name);
+		return getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name ).getSetter();
 	}
 
 	// todo : remove
-	public PropertyAccessor getPropertyAccessor(Class clazz) throws MappingException {
-		return PropertyAccessorFactory.getPropertyAccessor( clazz, getPropertyAccessorName() );
+	public PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {
+		String accessName = getPropertyAccessorName();
+		if ( accessName == null ) {
+			if ( clazz == null || java.util.Map.class.equals( clazz ) ) {
+				accessName = "map";
+			}
+			else {
+				accessName = "property";
+			}
+		}
+
+		final EntityMode entityMode = clazz == null || java.util.Map.class.equals( clazz )
+				? EntityMode.MAP
+				: EntityMode.POJO;
+
+		return resolveServiceRegistry().getService( PropertyAccessStrategyResolver.class ).resolvePropertyAccessStrategy(
+				accessName,
+				entityMode
+		);
+	}
+
+	protected ServiceRegistry resolveServiceRegistry() {
+		if ( getPersistentClass() != null ) {
+			return getPersistentClass().getServiceRegistry();
+		}
+		if ( getValue() != null ) {
+			return getValue().getServiceRegistry();
+		}
+		throw new HibernateException( "Could not resolve ServiceRegistry" );
 	}
 
 	public boolean isNaturalIdentifier() {
 		return naturalIdentifier;
 	}
 
 	public void setNaturalIdentifier(boolean naturalIdentifier) {
 		this.naturalIdentifier = naturalIdentifier;
 	}
 
 	public boolean isLob() {
 		return lob;
 	}
 
 	public void setLob(boolean lob) {
 		this.lob = lob;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/RootClass.java b/hibernate-core/src/main/java/org/hibernate/mapping/RootClass.java
index 2c3d7b1433..8f21e41f9f 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/RootClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/RootClass.java
@@ -1,365 +1,370 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.SingletonIterator;
 
 /**
  * The root class of an inheritance hierarchy
  *
  * @author Gavin King
  */
 public class RootClass extends PersistentClass implements TableOwner {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( RootClass.class );
 
 	public static final String DEFAULT_IDENTIFIER_COLUMN_NAME = "id";
 	public static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "class";
 
 	private Property identifierProperty;
 	private KeyValue identifier;
 	private Property version;
 	private boolean polymorphic;
 	private String cacheConcurrencyStrategy;
 	private String cacheRegionName;
 	private String naturalIdCacheRegionName;
 	private boolean lazyPropertiesCacheable = true;
 	private Value discriminator;
 	private boolean mutable = true;
 	private boolean embeddedIdentifier;
 	private boolean explicitPolymorphism;
 	private Class entityPersisterClass;
 	private boolean forceDiscriminator;
 	private String where;
 	private Table table;
 	private boolean discriminatorInsertable = true;
 	private int nextSubclassId;
 	private Property declaredIdentifierProperty;
 	private Property declaredVersion;
 	private boolean cachingExplicitlyRequested;
 
+	public RootClass(MetadataBuildingContext metadataBuildingContext) {
+		super( metadataBuildingContext );
+	}
+
 	@Override
 	int nextSubclassId() {
 		return ++nextSubclassId;
 	}
 
 	@Override
 	public int getSubclassId() {
 		return 0;
 	}
 
 	public void setTable(Table table) {
 		this.table = table;
 	}
 
 	@Override
 	public Table getTable() {
 		return table;
 	}
 
 	@Override
 	public Property getIdentifierProperty() {
 		return identifierProperty;
 	}
 
 	@Override
 	public Property getDeclaredIdentifierProperty() {
 		return declaredIdentifierProperty;
 	}
 
 	public void setDeclaredIdentifierProperty(Property declaredIdentifierProperty) {
 		this.declaredIdentifierProperty = declaredIdentifierProperty;
 	}
 
 	@Override
 	public KeyValue getIdentifier() {
 		return identifier;
 	}
 
 	@Override
 	public boolean hasIdentifierProperty() {
 		return identifierProperty != null;
 	}
 
 	@Override
 	public Value getDiscriminator() {
 		return discriminator;
 	}
 
 	@Override
 	public boolean isInherited() {
 		return false;
 	}
 
 	@Override
 	public boolean isPolymorphic() {
 		return polymorphic;
 	}
 
 	public void setPolymorphic(boolean polymorphic) {
 		this.polymorphic = polymorphic;
 	}
 
 	@Override
 	public RootClass getRootClass() {
 		return this;
 	}
 
 	@Override
 	public Iterator getPropertyClosureIterator() {
 		return getPropertyIterator();
 	}
 
 	@Override
 	public Iterator getTableClosureIterator() {
 		return new SingletonIterator( getTable() );
 	}
 
 	@Override
 	public Iterator getKeyClosureIterator() {
 		return new SingletonIterator( getKey() );
 	}
 
 	@Override
 	public void addSubclass(Subclass subclass) throws MappingException {
 		super.addSubclass( subclass );
 		setPolymorphic( true );
 	}
 
 	@Override
 	public boolean isExplicitPolymorphism() {
 		return explicitPolymorphism;
 	}
 
 	@Override
 	public Property getVersion() {
 		return version;
 	}
 
 	@Override
 	public Property getDeclaredVersion() {
 		return declaredVersion;
 	}
 
 	public void setDeclaredVersion(Property declaredVersion) {
 		this.declaredVersion = declaredVersion;
 	}
 
 	public void setVersion(Property version) {
 		this.version = version;
 	}
 
 	@Override
 	public boolean isVersioned() {
 		return version != null;
 	}
 
 	@Override
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	@Override
 	public boolean hasEmbeddedIdentifier() {
 		return embeddedIdentifier;
 	}
 
 	@Override
 	public Class getEntityPersisterClass() {
 		return entityPersisterClass;
 	}
 
 	@Override
 	public Table getRootTable() {
 		return getTable();
 	}
 
 	@Override
 	public void setEntityPersisterClass(Class persister) {
 		this.entityPersisterClass = persister;
 	}
 
 	@Override
 	public PersistentClass getSuperclass() {
 		return null;
 	}
 
 	@Override
 	public KeyValue getKey() {
 		return getIdentifier();
 	}
 
 	public void setDiscriminator(Value discriminator) {
 		this.discriminator = discriminator;
 	}
 
 	public void setEmbeddedIdentifier(boolean embeddedIdentifier) {
 		this.embeddedIdentifier = embeddedIdentifier;
 	}
 
 	public void setExplicitPolymorphism(boolean explicitPolymorphism) {
 		this.explicitPolymorphism = explicitPolymorphism;
 	}
 
 	public void setIdentifier(KeyValue identifier) {
 		this.identifier = identifier;
 	}
 
 	public void setIdentifierProperty(Property identifierProperty) {
 		this.identifierProperty = identifierProperty;
 		identifierProperty.setPersistentClass( this );
 
 	}
 
 	public void setMutable(boolean mutable) {
 		this.mutable = mutable;
 	}
 
 	@Override
 	public boolean isDiscriminatorInsertable() {
 		return discriminatorInsertable;
 	}
 
 	public void setDiscriminatorInsertable(boolean insertable) {
 		this.discriminatorInsertable = insertable;
 	}
 
 	@Override
 	public boolean isForceDiscriminator() {
 		return forceDiscriminator;
 	}
 
 	public void setForceDiscriminator(boolean forceDiscriminator) {
 		this.forceDiscriminator = forceDiscriminator;
 	}
 
 	@Override
 	public String getWhere() {
 		return where;
 	}
 
 	public void setWhere(String string) {
 		where = string;
 	}
 
 	@Override
 	public void validate(Mapping mapping) throws MappingException {
 		super.validate( mapping );
 		if ( !getIdentifier().isValid( mapping ) ) {
 			throw new MappingException(
 					"identifier mapping has wrong number of columns: " +
 							getEntityName() +
 							" type: " +
 							getIdentifier().getType().getName()
 			);
 		}
 		checkCompositeIdentifier();
 	}
 
 	private void checkCompositeIdentifier() {
 		if ( getIdentifier() instanceof Component ) {
 			Component id = (Component) getIdentifier();
 			if ( !id.isDynamic() ) {
 				final Class idClass = id.getComponentClass();
 				if ( idClass != null ) {
 					final String idComponentClassName = idClass.getName();
 					if ( !ReflectHelper.overridesEquals( idClass ) ) {
 						LOG.compositeIdClassDoesNotOverrideEquals( idComponentClassName );
 					}
 					if ( !ReflectHelper.overridesHashCode( idClass ) ) {
 						LOG.compositeIdClassDoesNotOverrideHashCode( idComponentClassName );
 					}
 					if ( !Serializable.class.isAssignableFrom( idClass ) ) {
 						throw new MappingException(
 								"Composite-id class must implement Serializable: " + idComponentClassName
 						);
 					}
 				}
 			}
 		}
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return cacheConcurrencyStrategy;
 	}
 
 	public void setCacheConcurrencyStrategy(String cacheConcurrencyStrategy) {
 		this.cacheConcurrencyStrategy = cacheConcurrencyStrategy;
 	}
 
 	public String getCacheRegionName() {
 		return cacheRegionName == null ? getEntityName() : cacheRegionName;
 	}
 
 	public void setCacheRegionName(String cacheRegionName) {
 		this.cacheRegionName = cacheRegionName;
 	}
 
 	@Override
 	public String getNaturalIdCacheRegionName() {
 		return naturalIdCacheRegionName;
 	}
 
 	public void setNaturalIdCacheRegionName(String naturalIdCacheRegionName) {
 		this.naturalIdCacheRegionName = naturalIdCacheRegionName;
 	}
 
 	@Override
 	public boolean isLazyPropertiesCacheable() {
 		return lazyPropertiesCacheable;
 	}
 
 	public void setLazyPropertiesCacheable(boolean lazyPropertiesCacheable) {
 		this.lazyPropertiesCacheable = lazyPropertiesCacheable;
 	}
 
 	@Override
 	public boolean isJoinedSubclass() {
 		return false;
 	}
 
 	@Override
 	public java.util.Set getSynchronizedTables() {
 		return synchronizedTables;
 	}
 
 	@SuppressWarnings("UnnecessaryUnboxing")
 	public Set<Table> getIdentityTables() {
 		Set<Table> tables = new HashSet<Table>();
 		Iterator iter = getSubclassClosureIterator();
 		while ( iter.hasNext() ) {
 			PersistentClass clazz = (PersistentClass) iter.next();
 			if ( clazz.isAbstract() == null || !clazz.isAbstract().booleanValue() ) {
 				tables.add( clazz.getIdentityTable() );
 			}
 		}
 		return tables;
 	}
 
 	@Override
 	public Object accept(PersistentClassVisitor mv) {
 		return mv.accept( this );
 	}
 
 	public void setCachingExplicitlyRequested(boolean explicitlyRequested) {
 		this.cachingExplicitlyRequested = explicitlyRequested;
 	}
 
 	public boolean isCachingExplicitlyRequested() {
 		return cachingExplicitlyRequested;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java b/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
index 8e8be48b97..2af454ac64 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
@@ -1,633 +1,643 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Properties;
 import javax.persistence.AttributeConverter;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.cfg.AttributeConverterDefinition;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.config.spi.StandardConverters;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 import org.hibernate.type.descriptor.converter.AttributeConverterSqlTypeDescriptorAdapter;
 import org.hibernate.type.descriptor.converter.AttributeConverterTypeAdapter;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptorRegistry;
 import org.hibernate.type.descriptor.sql.JdbcTypeJavaClassMappings;
 import org.hibernate.type.descriptor.sql.NationalizedTypeMappings;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptorRegistry;
 import org.hibernate.usertype.DynamicParameterizedType;
 
 /**
  * Any value that maps to columns.
  * @author Gavin King
  */
 public class SimpleValue implements KeyValue {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( SimpleValue.class );
 
 	public static final String DEFAULT_ID_GEN_STRATEGY = "assigned";
 
 	private final MetadataImplementor metadata;
 
 	private final List<Selectable> columns = new ArrayList<Selectable>();
 
 	private String typeName;
 	private Properties typeParameters;
 	private boolean isNationalized;
 
 	private Properties identifierGeneratorProperties;
 	private String identifierGeneratorStrategy = DEFAULT_ID_GEN_STRATEGY;
 	private String nullValue;
 	private Table table;
 	private String foreignKeyName;
 	private boolean alternateUniqueKey;
 	private boolean cascadeDeleteEnabled;
 
 	private AttributeConverterDefinition attributeConverterDefinition;
 	private Type type;
 
 	public SimpleValue(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	public SimpleValue(MetadataImplementor metadata, Table table) {
 		this( metadata );
 		this.table = table;
 	}
 
 	public MetadataImplementor getMetadata() {
 		return metadata;
 	}
 
 	@Override
+	public ServiceRegistry getServiceRegistry() {
+		return getMetadata().getMetadataBuildingOptions().getServiceRegistry();
+	}
+
+	@Override
 	public boolean isCascadeDeleteEnabled() {
 		return cascadeDeleteEnabled;
 	}
 
 	public void setCascadeDeleteEnabled(boolean cascadeDeleteEnabled) {
 		this.cascadeDeleteEnabled = cascadeDeleteEnabled;
 	}
 	
 	public void addColumn(Column column) {
 		if ( !columns.contains(column) ) {
 			columns.add(column);
 		}
 		column.setValue(this);
 		column.setTypeIndex( columns.size()-1 );
 	}
 	
 	public void addFormula(Formula formula) {
 		columns.add(formula);
 	}
 
 	@Override
 	public boolean hasFormula() {
 		Iterator iter = getColumnIterator();
 		while ( iter.hasNext() ) {
 			Object o = iter.next();
 			if (o instanceof Formula) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	@Override
 	public int getColumnSpan() {
 		return columns.size();
 	}
 
 	@Override
 	public Iterator<Selectable> getColumnIterator() {
 		return columns.iterator();
 	}
 
 	public List getConstraintColumns() {
 		return columns;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 
 	public void setTypeName(String typeName) {
 		if ( typeName != null && typeName.startsWith( AttributeConverterTypeAdapter.NAME_PREFIX ) ) {
 			final String converterClassName = typeName.substring( AttributeConverterTypeAdapter.NAME_PREFIX.length() );
 			final ClassLoaderService cls = getMetadata().getMetadataBuildingOptions()
 					.getServiceRegistry()
 					.getService( ClassLoaderService.class );
 			try {
 				final Class<AttributeConverter> converterClass = cls.classForName( converterClassName );
 				attributeConverterDefinition = new AttributeConverterDefinition( converterClass.newInstance(), false );
 				return;
 			}
 			catch (Exception e) {
 				log.logBadHbmAttributeConverterType( typeName, e.getMessage() );
 			}
 		}
 
 		this.typeName = typeName;
 	}
 
 	public void makeNationalized() {
 		this.isNationalized = true;
 	}
 
 	public boolean isNationalized() {
 		return isNationalized;
 	}
 
 	public void setTable(Table table) {
 		this.table = table;
 	}
 
 	@Override
 	public void createForeignKey() throws MappingException {}
 
 	@Override
 	public void createForeignKeyOfEntity(String entityName) {
 		if ( !hasFormula() && !"none".equals(getForeignKeyName())) {
 			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
 			fk.setCascadeDeleteEnabled(cascadeDeleteEnabled);
 		}
 	}
 
 	@Override
 	public IdentifierGenerator createIdentifierGenerator(
 			IdentifierGeneratorFactory identifierGeneratorFactory,
 			Dialect dialect, 
 			String defaultCatalog, 
 			String defaultSchema, 
 			RootClass rootClass) throws MappingException {
 		
 		Properties params = new Properties();
 		
 		//if the hibernate-mapping did not specify a schema/catalog, use the defaults
 		//specified by properties - but note that if the schema/catalog were specified
 		//in hibernate-mapping, or as params, they will already be initialized and
 		//will override the values set here (they are in identifierGeneratorProperties)
 		if ( defaultSchema!=null ) {
 			params.setProperty(PersistentIdentifierGenerator.SCHEMA, defaultSchema);
 		}
 		if ( defaultCatalog!=null ) {
 			params.setProperty(PersistentIdentifierGenerator.CATALOG, defaultCatalog);
 		}
 		
 		//pass the entity-name, if not a collection-id
 		if (rootClass!=null) {
 			params.setProperty( IdentifierGenerator.ENTITY_NAME, rootClass.getEntityName() );
 			params.setProperty( IdentifierGenerator.JPA_ENTITY_NAME, rootClass.getJpaEntityName() );
 		}
 		
 		//init the table here instead of earlier, so that we can get a quoted table name
 		//TODO: would it be better to simply pass the qualified table name, instead of
 		//      splitting it up into schema/catalog/table names
 		String tableName = getTable().getQuotedName(dialect);
 		params.setProperty( PersistentIdentifierGenerator.TABLE, tableName );
 		
 		//pass the column name (a generated id almost always has a single column)
 		String columnName = ( (Column) getColumnIterator().next() ).getQuotedName(dialect);
 		params.setProperty( PersistentIdentifierGenerator.PK, columnName );
 		
 		if (rootClass!=null) {
 			StringBuilder tables = new StringBuilder();
 			Iterator iter = rootClass.getIdentityTables().iterator();
 			while ( iter.hasNext() ) {
 				Table table= (Table) iter.next();
 				tables.append( table.getQuotedName(dialect) );
 				if ( iter.hasNext() ) {
 					tables.append(", ");
 				}
 			}
 			params.setProperty( PersistentIdentifierGenerator.TABLES, tables.toString() );
 		}
 		else {
 			params.setProperty( PersistentIdentifierGenerator.TABLES, tableName );
 		}
 
 		if (identifierGeneratorProperties!=null) {
 			params.putAll(identifierGeneratorProperties);
 		}
 
 		// TODO : we should pass along all settings once "config lifecycle" is hashed out...
 		final ConfigurationService cs = metadata.getMetadataBuildingOptions().getServiceRegistry()
 				.getService( ConfigurationService.class );
 
 		params.put(
 				AvailableSettings.PREFER_POOLED_VALUES_LO,
 				cs.getSetting( AvailableSettings.PREFER_POOLED_VALUES_LO, StandardConverters.BOOLEAN, false )
 		);
 
 		identifierGeneratorFactory.setDialect( dialect );
 		return identifierGeneratorFactory.createIdentifierGenerator( identifierGeneratorStrategy, getType(), params );
 	}
 
 	public boolean isUpdateable() {
 		//needed to satisfy KeyValue
 		return true;
 	}
 	
 	public FetchMode getFetchMode() {
 		return FetchMode.SELECT;
 	}
 
 	public Properties getIdentifierGeneratorProperties() {
 		return identifierGeneratorProperties;
 	}
 
 	public String getNullValue() {
 		return nullValue;
 	}
 
 	public Table getTable() {
 		return table;
 	}
 
 	/**
 	 * Returns the identifierGeneratorStrategy.
 	 * @return String
 	 */
 	public String getIdentifierGeneratorStrategy() {
 		return identifierGeneratorStrategy;
 	}
 	
 	public boolean isIdentityColumn(IdentifierGeneratorFactory identifierGeneratorFactory, Dialect dialect) {
 		identifierGeneratorFactory.setDialect( dialect );
 		return identifierGeneratorFactory.getIdentifierGeneratorClass( identifierGeneratorStrategy )
 				.equals( IdentityGenerator.class );
 	}
 
 	/**
 	 * Sets the identifierGeneratorProperties.
 	 * @param identifierGeneratorProperties The identifierGeneratorProperties to set
 	 */
 	public void setIdentifierGeneratorProperties(Properties identifierGeneratorProperties) {
 		this.identifierGeneratorProperties = identifierGeneratorProperties;
 	}
 
 	/**
 	 * Sets the identifierGeneratorStrategy.
 	 * @param identifierGeneratorStrategy The identifierGeneratorStrategy to set
 	 */
 	public void setIdentifierGeneratorStrategy(String identifierGeneratorStrategy) {
 		this.identifierGeneratorStrategy = identifierGeneratorStrategy;
 	}
 
 	/**
 	 * Sets the nullValue.
 	 * @param nullValue The nullValue to set
 	 */
 	public void setNullValue(String nullValue) {
 		this.nullValue = nullValue;
 	}
 
 	public String getForeignKeyName() {
 		return foreignKeyName;
 	}
 
 	public void setForeignKeyName(String foreignKeyName) {
 		this.foreignKeyName = foreignKeyName;
 	}
 
 	public boolean isAlternateUniqueKey() {
 		return alternateUniqueKey;
 	}
 
 	public void setAlternateUniqueKey(boolean unique) {
 		this.alternateUniqueKey = unique;
 	}
 
 	public boolean isNullable() {
 		Iterator itr = getColumnIterator();
 		while ( itr.hasNext() ) {
 			final Object selectable = itr.next();
 			if ( selectable instanceof Formula ) {
 				// if there are *any* formulas, then the Value overall is
 				// considered nullable
 				return true;
 			}
 			else if ( !( (Column) selectable ).isNullable() ) {
 				// if there is a single non-nullable column, the Value
 				// overall is considered non-nullable.
 				return false;
 			}
 		}
 		// nullable by default
 		return true;
 	}
 
 	public boolean isSimpleValue() {
 		return true;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		return getColumnSpan()==getType().getColumnSpan(mapping);
 	}
 
 	public Type getType() throws MappingException {
 		if ( type != null ) {
 			return type;
 		}
 
 		if ( typeName == null ) {
 			throw new MappingException( "No type name" );
 		}
 
 		if ( typeParameters != null
 				&& Boolean.valueOf( typeParameters.getProperty( DynamicParameterizedType.IS_DYNAMIC ) )
 				&& typeParameters.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {
 			createParameterImpl();
 		}
 
 		Type result = metadata.getTypeResolver().heuristicType( typeName, typeParameters );
 		if ( result == null ) {
 			String msg = "Could not determine type for: " + typeName;
 			if ( table != null ) {
 				msg += ", at table: " + table.getName();
 			}
 			if ( columns != null && columns.size() > 0 ) {
 				msg += ", for columns: " + columns;
 			}
 			throw new MappingException( msg );
 		}
 
 		return result;
 	}
 
 	public void setTypeUsingReflection(String className, String propertyName) throws MappingException {
 		// NOTE : this is called as the last piece in setting SimpleValue type information, and implementations
 		// rely on that fact, using it as a signal that all information it is going to get is defined at this point...
 
 		if ( typeName != null ) {
 			// assume either (a) explicit type was specified or (b) determine was already performed
 			return;
 		}
 
 		if ( type != null ) {
 			return;
 		}
 
 		if ( attributeConverterDefinition == null ) {
 			// this is here to work like legacy.  This should change when we integrate with metamodel to
 			// look for SqlTypeDescriptor and JavaTypeDescriptor individually and create the BasicType (well, really
 			// keep a registry of [SqlTypeDescriptor,JavaTypeDescriptor] -> BasicType...)
 			if ( className == null ) {
 				throw new MappingException( "Attribute types for a dynamic entity must be explicitly specified: " + propertyName );
 			}
-			typeName = ReflectHelper.reflectedPropertyClass( className, propertyName ).getName();
+			typeName = ReflectHelper.reflectedPropertyClass( className, propertyName, metadata.getMetadataBuildingOptions().getServiceRegistry().getService( ClassLoaderService.class ) ).getName();
 			// todo : to fully support isNationalized here we need do the process hinted at above
 			// 		essentially, much of the logic from #buildAttributeConverterTypeAdapter wrt resolving
 			//		a (1) SqlTypeDescriptor, a (2) JavaTypeDescriptor and dynamically building a BasicType
 			// 		combining them.
 			return;
 		}
 
 		// we had an AttributeConverter...
 		type = buildAttributeConverterTypeAdapter();
 	}
 
 	/**
 	 * Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in
 	 * memory, meaning it converts between one Java representation (the entity attribute representation) and another
 	 * (the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates
 	 * at the lower level of actually dealing directly with those JDBC objects.  So even though we have an
 	 * AttributeConverter, we still need to "fill out" the rest of the BasicType data and bridge calls
 	 * to bind/extract through the converter.
 	 * <p/>
 	 * Essentially the idea here is that an intermediate Java type needs to be used.  Let's use an example as a means
 	 * to illustrate...  Consider an {@code AttributeConverter<Integer,String>}.  This tells Hibernate that the domain
 	 * model defines this attribute as an Integer value (the 'entityAttributeJavaType'), but that we need to treat the
 	 * value as a String (the 'databaseColumnJavaType') when dealing with JDBC (aka, the database type is a
 	 * VARCHAR/CHAR):<ul>
 	 *     <li>
 	 *         When binding values to PreparedStatements we need to convert the Integer value from the entity
 	 *         into a String and pass that String to setString.  The conversion is handled by calling
 	 *         {@link AttributeConverter#convertToDatabaseColumn(Object)}
 	 *     </li>
 	 *     <li>
 	 *         When extracting values from ResultSets (or CallableStatement parameters) we need to handle the
 	 *         value via getString, and convert that returned String to an Integer.  That conversion is handled
 	 *         by calling {@link AttributeConverter#convertToEntityAttribute(Object)}
 	 *     </li>
 	 * </ul>
 	 *
 	 * @return The built AttributeConverter -> Type adapter
 	 *
 	 * @todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately
 	 * then we can "play them against each other" in terms of determining proper typing
 	 *
 	 * @todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching
 	 */
 	@SuppressWarnings("unchecked")
 	private Type buildAttributeConverterTypeAdapter() {
 		// todo : validate the number of columns present here?
 
 		final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();
 		final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();
 
 
 		// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// For the JavaTypeDescriptor portion we simply resolve the "entity attribute representation" part of
 		// the AttributeConverter to resolve the corresponding descriptor.
 		final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );
 
 
 		// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String
 		//		conversions.  This is the more complicated piece.  First we need to determine the JDBC type code
 		//		corresponding to the AttributeConverter's declared "databaseColumnJavaType" (how we read that value out
 		// 		of ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return
 		// 		VARCHAR/CHAR
 		int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );
 		if ( isNationalized() ) {
 			jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );
 		}
 		// find the standard SqlTypeDescriptor for that JDBC type code.
 		final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );
 		// find the JavaTypeDescriptor representing the "intermediate database type representation".  Back to the
 		// 		illustration, this should be the type descriptor for Strings
 		final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );
 		// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction
 		// 		process...
 		final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(
 				attributeConverterDefinition.getAttributeConverter(),
 				sqlTypeDescriptor,
 				intermediateJavaTypeDescriptor
 		);
 
 		// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.
 
 		final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();
 		final String description = String.format(
 				"BasicType adapter for AttributeConverter<%s,%s>",
 				entityAttributeJavaType.getSimpleName(),
 				databaseColumnJavaType.getSimpleName()
 		);
 		return new AttributeConverterTypeAdapter(
 				name,
 				description,
 				attributeConverterDefinition.getAttributeConverter(),
 				sqlTypeDescriptorAdapter,
 				entityAttributeJavaType,
 				databaseColumnJavaType,
 				entityAttributeJavaTypeDescriptor
 		);
 	}
 
 	public boolean isTypeSpecified() {
 		return typeName!=null;
 	}
 
 	public void setTypeParameters(Properties parameterMap) {
 		this.typeParameters = parameterMap;
 	}
 	
 	public Properties getTypeParameters() {
 		return typeParameters;
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + columns.toString() + ')';
 	}
 
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept(this);
 	}
 	
 	public boolean[] getColumnInsertability() {
 		boolean[] result = new boolean[ getColumnSpan() ];
 		int i = 0;
 		Iterator iter = getColumnIterator();
 		while ( iter.hasNext() ) {
 			Selectable s = (Selectable) iter.next();
 			result[i++] = !s.isFormula();
 		}
 		return result;
 	}
 	
 	public boolean[] getColumnUpdateability() {
 		return getColumnInsertability();
 	}
 
 	public void setJpaAttributeConverterDefinition(AttributeConverterDefinition attributeConverterDefinition) {
 		this.attributeConverterDefinition = attributeConverterDefinition;
 	}
 
 	private void createParameterImpl() {
 		try {
 			String[] columnsNames = new String[columns.size()];
 			for ( int i = 0; i < columns.size(); i++ ) {
 				Selectable column = columns.get(i);
 				if (column instanceof Column){
 					columnsNames[i] = ((Column) column).getName();
 				}
 			}
 
 			final XProperty xProperty = (XProperty) typeParameters.get( DynamicParameterizedType.XPROPERTY );
 			// todo : not sure this works for handling @MapKeyEnumerated
 			final Annotation[] annotations = xProperty == null
 					? null
 					: xProperty.getAnnotations();
 
+			final ClassLoaderService classLoaderService = getMetadata().getMetadataBuildingOptions()
+					.getServiceRegistry()
+					.getService( ClassLoaderService.class );
 			typeParameters.put(
 					DynamicParameterizedType.PARAMETER_TYPE,
 					new ParameterTypeImpl(
-							ReflectHelper.classForName(
+							classLoaderService.classForName(
 									typeParameters.getProperty( DynamicParameterizedType.RETURNED_CLASS )
 							),
 							annotations,
 							table.getCatalog(),
 							table.getSchema(),
 							table.getName(),
 							Boolean.valueOf( typeParameters.getProperty( DynamicParameterizedType.IS_PRIMARY_KEY ) ),
 							columnsNames
 					)
 			);
 		}
-		catch ( ClassNotFoundException cnfe ) {
-			throw new MappingException( "Could not create DynamicParameterizedType for type: " + typeName, cnfe );
+		catch ( ClassLoadingException e ) {
+			throw new MappingException( "Could not create DynamicParameterizedType for type: " + typeName, e );
 		}
 	}
 
 	private final class ParameterTypeImpl implements DynamicParameterizedType.ParameterType {
 
 		private final Class returnedClass;
 		private final Annotation[] annotationsMethod;
 		private final String catalog;
 		private final String schema;
 		private final String table;
 		private final boolean primaryKey;
 		private final String[] columns;
 
 		private ParameterTypeImpl(Class returnedClass, Annotation[] annotationsMethod, String catalog, String schema,
 				String table, boolean primaryKey, String[] columns) {
 			this.returnedClass = returnedClass;
 			this.annotationsMethod = annotationsMethod;
 			this.catalog = catalog;
 			this.schema = schema;
 			this.table = table;
 			this.primaryKey = primaryKey;
 			this.columns = columns;
 		}
 
 		@Override
 		public Class getReturnedClass() {
 			return returnedClass;
 		}
 
 		@Override
 		public Annotation[] getAnnotationsMethod() {
 			return annotationsMethod;
 		}
 
 		@Override
 		public String getCatalog() {
 			return catalog;
 		}
 
 		@Override
 		public String getSchema() {
 			return schema;
 		}
 
 		@Override
 		public String getTable() {
 			return table;
 		}
 
 		@Override
 		public boolean isPrimaryKey() {
 			return primaryKey;
 		}
 
 		@Override
 		public String[] getColumns() {
 			return columns;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/SingleTableSubclass.java b/hibernate-core/src/main/java/org/hibernate/mapping/SingleTableSubclass.java
index 562a4a673a..9b7703b8b2 100755
--- a/hibernate-core/src/main/java/org/hibernate/mapping/SingleTableSubclass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/SingleTableSubclass.java
@@ -1,55 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import java.util.Iterator;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.util.collections.JoinedIterator;
 
 /**
  * @author Gavin King
  */
 public class SingleTableSubclass extends Subclass {
 
-	public SingleTableSubclass(PersistentClass superclass) {
-		super( superclass );
+	public SingleTableSubclass(PersistentClass superclass, MetadataBuildingContext metadataBuildingContext) {
+		super( superclass, metadataBuildingContext );
 	}
 
 	@SuppressWarnings("unchecked")
 	protected Iterator getNonDuplicatedPropertyIterator() {
 		return new JoinedIterator(
 				getSuperclass().getUnjoinedPropertyIterator(),
 				getUnjoinedPropertyIterator()
 		);
 	}
 
 	protected Iterator getDiscriminatorColumnIterator() {
 		if ( isDiscriminatorInsertable() && !getDiscriminator().hasFormula() ) {
 			return getDiscriminator().getColumnIterator();
 		}
 		else {
 			return super.getDiscriminatorColumnIterator();
 		}
 	}
 
 	public Object accept(PersistentClassVisitor mv) {
 		return mv.accept( this );
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		if ( getDiscriminator() == null ) {
 			throw new MappingException(
 					"No discriminator found for " + getEntityName()
 							+ ". Discriminator is needed when 'single-table-per-hierarchy' "
 							+ "is used and a class has subclasses"
 			);
 		}
 		super.validate( mapping );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Subclass.java b/hibernate-core/src/main/java/org/hibernate/mapping/Subclass.java
index d0e0d5d2fc..89eb399f81 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Subclass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Subclass.java
@@ -1,287 +1,288 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.collections.SingletonIterator;
 
 /**
  * A sublass in a table-per-class-hierarchy mapping
  * @author Gavin King
  */
 public class Subclass extends PersistentClass {
-
 	private PersistentClass superclass;
 	private Class classPersisterClass;
 	private final int subclassId;
 	
-	public Subclass(PersistentClass superclass) {
+	public Subclass(PersistentClass superclass, MetadataBuildingContext metadataBuildingContext) {
+		super( metadataBuildingContext );
 		this.superclass = superclass;
 		this.subclassId = superclass.nextSubclassId();
 	}
 
 	int nextSubclassId() {
 		return getSuperclass().nextSubclassId();
 	}
 	
 	public int getSubclassId() {
 		return subclassId;
 	}
 	
 	@Override
 	public String getNaturalIdCacheRegionName() {
 		return getSuperclass().getNaturalIdCacheRegionName();
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return getSuperclass().getCacheConcurrencyStrategy();
 	}
 
 	public RootClass getRootClass() {
 		return getSuperclass().getRootClass();
 	}
 
 	public PersistentClass getSuperclass() {
 		return superclass;
 	}
 
 	public Property getIdentifierProperty() {
 		return getSuperclass().getIdentifierProperty();
 	}
 
 	public Property getDeclaredIdentifierProperty() {
 		return null;
 	}
 
 	public KeyValue getIdentifier() {
 		return getSuperclass().getIdentifier();
 	}
 	public boolean hasIdentifierProperty() {
 		return getSuperclass().hasIdentifierProperty();
 	}
 	public Value getDiscriminator() {
 		return getSuperclass().getDiscriminator();
 	}
 	public boolean isMutable() {
 		return getSuperclass().isMutable();
 	}
 	public boolean isInherited() {
 		return true;
 	}
 	public boolean isPolymorphic() {
 		return true;
 	}
 
 	public void addProperty(Property p) {
 		super.addProperty(p);
 		getSuperclass().addSubclassProperty(p);
 	}
 
 	public void addMappedsuperclassProperty(Property p) {
 		super.addMappedsuperclassProperty( p );
 		getSuperclass().addSubclassProperty(p);
 	}
 
 	public void addJoin(Join j) {
 		super.addJoin(j);
 		getSuperclass().addSubclassJoin(j);
 	}
 
 	public Iterator getPropertyClosureIterator() {
 		return new JoinedIterator(
 				getSuperclass().getPropertyClosureIterator(),
 				getPropertyIterator()
 			);
 	}
 	public Iterator getTableClosureIterator() {
 		return new JoinedIterator(
 				getSuperclass().getTableClosureIterator(),
 				new SingletonIterator( getTable() )
 			);
 	}
 	public Iterator getKeyClosureIterator() {
 		return new JoinedIterator(
 				getSuperclass().getKeyClosureIterator(),
 				new SingletonIterator( getKey() )
 			);
 	}
 	protected void addSubclassProperty(Property p) {
 		super.addSubclassProperty(p);
 		getSuperclass().addSubclassProperty(p);
 	}
 	protected void addSubclassJoin(Join j) {
 		super.addSubclassJoin(j);
 		getSuperclass().addSubclassJoin(j);
 	}
 
 	protected void addSubclassTable(Table table) {
 		super.addSubclassTable(table);
 		getSuperclass().addSubclassTable(table);
 	}
 
 	public boolean isVersioned() {
 		return getSuperclass().isVersioned();
 	}
 	public Property getVersion() {
 		return getSuperclass().getVersion();
 	}
 
 	public Property getDeclaredVersion() {
 		return null;
 	}
 
 	public boolean hasEmbeddedIdentifier() {
 		return getSuperclass().hasEmbeddedIdentifier();
 	}
 	public Class getEntityPersisterClass() {
 		if (classPersisterClass==null) {
 			return getSuperclass().getEntityPersisterClass();
 		}
 		else {
 			return classPersisterClass;
 		}
 	}
 
 	public Table getRootTable() {
 		return getSuperclass().getRootTable();
 	}
 
 	public KeyValue getKey() {
 		return getSuperclass().getIdentifier();
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return getSuperclass().isExplicitPolymorphism();
 	}
 
 	public void setSuperclass(PersistentClass superclass) {
 		this.superclass = superclass;
 	}
 
 	public String getWhere() {
 		return getSuperclass().getWhere();
 	}
 
 	public boolean isJoinedSubclass() {
 		return getTable()!=getRootTable();
 	}
 
 	public void createForeignKey() {
 		if ( !isJoinedSubclass() ) {
 			throw new AssertionFailure( "not a joined-subclass" );
 		}
 		getKey().createForeignKeyOfEntity( getSuperclass().getEntityName() );
 	}
 
 	public void setEntityPersisterClass(Class classPersisterClass) {
 		this.classPersisterClass = classPersisterClass;
 	}
 
 	public boolean isLazyPropertiesCacheable() {
 		return getSuperclass().isLazyPropertiesCacheable();
 	}
 
 	public int getJoinClosureSpan() {
 		return getSuperclass().getJoinClosureSpan() + super.getJoinClosureSpan();
 	}
 
 	public int getPropertyClosureSpan() {
 		return getSuperclass().getPropertyClosureSpan() + super.getPropertyClosureSpan();
 	}
 
 	public Iterator getJoinClosureIterator() {
 		return new JoinedIterator(
 			getSuperclass().getJoinClosureIterator(),
 			super.getJoinClosureIterator()
 		);
 	}
 
 	public boolean isClassOrSuperclassJoin(Join join) {
 		return super.isClassOrSuperclassJoin(join) || getSuperclass().isClassOrSuperclassJoin(join);
 	}
 
 	public boolean isClassOrSuperclassTable(Table table) {
 		return super.isClassOrSuperclassTable(table) || getSuperclass().isClassOrSuperclassTable(table);
 	}
 
 	public Table getTable() {
 		return getSuperclass().getTable();
 	}
 
 	public boolean isForceDiscriminator() {
 		return getSuperclass().isForceDiscriminator();
 	}
 
 	public boolean isDiscriminatorInsertable() {
 		return getSuperclass().isDiscriminatorInsertable();
 	}
 
 	public java.util.Set getSynchronizedTables() {
 		HashSet result = new HashSet();
 		result.addAll(synchronizedTables);
 		result.addAll( getSuperclass().getSynchronizedTables() );
 		return result;
 	}
 
 	public Object accept(PersistentClassVisitor mv) {
 		return mv.accept(this);
 	}
 
 	public java.util.List getFilters() {
 		java.util.List filters = new ArrayList(super.getFilters());
 		filters.addAll(getSuperclass().getFilters());
 		return filters;
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return super.hasSubselectLoadableCollections() || 
 			getSuperclass().hasSubselectLoadableCollections();
 	}
 
 	public String getTuplizerImplClassName(EntityMode mode) {
 		String impl = super.getTuplizerImplClassName( mode );
 		if ( impl == null ) {
 			impl = getSuperclass().getTuplizerImplClassName( mode );
 		}
 		return impl;
 	}
 
 	public Map getTuplizerMap() {
 		Map specificTuplizerDefs = super.getTuplizerMap();
 		Map superclassTuplizerDefs = getSuperclass().getTuplizerMap();
 		if ( specificTuplizerDefs == null && superclassTuplizerDefs == null ) {
 			return null;
 		}
 		else {
 			Map combined = new HashMap();
 			if ( superclassTuplizerDefs != null ) {
 				combined.putAll( superclassTuplizerDefs );
 			}
 			if ( specificTuplizerDefs != null ) {
 				combined.putAll( specificTuplizerDefs );
 			}
 			return java.util.Collections.unmodifiableMap( combined );
 		}
 	}
 
 	public Component getIdentifierMapper() {
 		return superclass.getIdentifierMapper();
 	}
 
 	@Override
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return superclass.getOptimisticLockStyle();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/ToOne.java b/hibernate-core/src/main/java/org/hibernate/mapping/ToOne.java
index 7b1b336e20..39890c294f 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/ToOne.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/ToOne.java
@@ -1,126 +1,128 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.type.Type;
 
 /**
  * A simple-point association (ie. a reference to another entity).
  * @author Gavin King
  */
 public abstract class ToOne extends SimpleValue implements Fetchable {
-
 	private FetchMode fetchMode;
 	protected String referencedPropertyName;
 	private String referencedEntityName;
 	private boolean embedded;
 	private boolean lazy = true;
 	protected boolean unwrapProxy;
 	protected boolean referenceToPrimaryKey = true;
 
 	protected ToOne(MetadataImplementor metadata, Table table) {
 		super( metadata, table );
 	}
 
 	public FetchMode getFetchMode() {
 		return fetchMode;
 	}
 
 	public void setFetchMode(FetchMode fetchMode) {
 		this.fetchMode=fetchMode;
 	}
 
 	public abstract void createForeignKey() throws MappingException;
 	public abstract Type getType() throws MappingException;
 
 	public String getReferencedPropertyName() {
 		return referencedPropertyName;
 	}
 
 	public void setReferencedPropertyName(String name) {
 		referencedPropertyName = name==null ? null : name.intern();
 	}
 
 	public String getReferencedEntityName() {
 		return referencedEntityName;
 	}
 
 	public void setReferencedEntityName(String referencedEntityName) {
 		this.referencedEntityName = referencedEntityName==null ? 
 				null : referencedEntityName.intern();
 	}
 
-	public void setTypeUsingReflection(String className, String propertyName)
-	throws MappingException {
-		if (referencedEntityName==null) {
-			referencedEntityName = ReflectHelper.reflectedPropertyClass( className, propertyName ).getName();
+	public void setTypeUsingReflection(String className, String propertyName) throws MappingException {
+		if (referencedEntityName == null) {
+			final ClassLoaderService cls = getMetadata().getMetadataBuildingOptions()
+					.getServiceRegistry()
+					.getService( ClassLoaderService.class );
+			referencedEntityName = ReflectHelper.reflectedPropertyClass( className, propertyName, cls ).getName();
 		}
 	}
 
 	public boolean isTypeSpecified() {
 		return referencedEntityName!=null;
 	}
 	
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept(this);
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public boolean isEmbedded() {
 		return embedded;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public void setEmbedded(boolean embedded) {
 		this.embedded = embedded;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		if (referencedEntityName==null) {
 			throw new MappingException("association must specify the referenced entity");
 		}
 		return super.isValid( mapping );
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 	
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public boolean isUnwrapProxy() {
 		return unwrapProxy;
 	}
 
 	public void setUnwrapProxy(boolean unwrapProxy) {
 		this.unwrapProxy = unwrapProxy;
 	}
 
 	public boolean isReferenceToPrimaryKey() {
 		return referenceToPrimaryKey;
 	}
 
 	public void setReferenceToPrimaryKey(boolean referenceToPrimaryKey) {
 		this.referenceToPrimaryKey = referenceToPrimaryKey;
 	}
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/UnionSubclass.java b/hibernate-core/src/main/java/org/hibernate/mapping/UnionSubclass.java
index ba3362fbdf..75b7a5a294 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/UnionSubclass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/UnionSubclass.java
@@ -1,62 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 import java.util.Iterator;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.spi.Mapping;
 
 /**
  * A subclass in a table-per-concrete-class mapping
  * @author Gavin King
  */
 public class UnionSubclass extends Subclass implements TableOwner {
-
 	private Table table;
 	private KeyValue key;
 
-	public UnionSubclass(PersistentClass superclass) {
-		super(superclass);
+	public UnionSubclass(PersistentClass superclass, MetadataBuildingContext metadataBuildingContext) {
+		super( superclass, metadataBuildingContext );
 	}
 
 	public Table getTable() {
 		return table;
 	}
 
 	public void setTable(Table table) {
 		this.table = table;
 		getSuperclass().addSubclassTable(table);
 	}
 
 	public java.util.Set getSynchronizedTables() {
 		return synchronizedTables;
 	}
 	
 	protected Iterator getNonDuplicatedPropertyIterator() {
 		return getPropertyClosureIterator();
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		super.validate(mapping);
 		if ( key!=null && !key.isValid(mapping) ) {
 			throw new MappingException(
 				"subclass key mapping has wrong number of columns: " +
 				getEntityName() +
 				" type: " +
 				key.getType().getName()
 			);
 		}
 	}
 	
 	public Table getIdentityTable() {
 		return getTable();
 	}
 	
 	public Object accept(PersistentClassVisitor mv) {
 		return mv.accept(this);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Value.java b/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
index 0c91266221..6a7be09bc6 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
@@ -1,41 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.mapping;
 import java.io.Serializable;
 import java.util.Iterator;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.Type;
 
 /**
  * A value is anything that is persisted by value, instead of
  * by reference. It is essentially a Hibernate Type, together
  * with zero or more columns. Values are wrapped by things with
  * higher level semantics, for example properties, collections,
  * classes.
  *
  * @author Gavin King
  */
 public interface Value extends Serializable {
 	public int getColumnSpan();
 	public Iterator<Selectable> getColumnIterator();
 	public Type getType() throws MappingException;
 	public FetchMode getFetchMode();
 	public Table getTable();
 	public boolean hasFormula();
 	public boolean isAlternateUniqueKey();
 	public boolean isNullable();
 	public boolean[] getColumnUpdateability();
 	public boolean[] getColumnInsertability();
 	public void createForeignKey() throws MappingException;
 	public boolean isSimpleValue();
 	public boolean isValid(Mapping mapping) throws MappingException;
 	public void setTypeUsingReflection(String className, String propertyName) throws MappingException;
 	public Object accept(ValueVisitor visitor);
+
+	ServiceRegistry getServiceRegistry();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
index 964b32e220..34de9320e3 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
@@ -1,1097 +1,1097 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.cache.spi.entry.ReferenceCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StandardCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StructuredCacheEntry;
 import org.hibernate.cache.spi.entry.UnstructuredCacheEntry;
 import org.hibernate.dialect.lock.LockingStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.internal.CacheHelper;
 import org.hibernate.engine.internal.ImmutableEntityEntryFactory;
 import org.hibernate.engine.internal.MutableEntityEntryFactory;
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.engine.spi.CachedNaturalIdValueSource;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityEntryFactory;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.PersistenceContext.NaturalIdHelper;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.id.PostInsertIdentityPersister;
 import org.hibernate.id.insert.Binder;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.FilterHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.jdbc.TooManyRowsAffectedException;
 import org.hibernate.loader.entity.BatchingEntityLoaderBuilder;
 import org.hibernate.loader.entity.CascadeEntityLoader;
 import org.hibernate.loader.entity.EntityLoader;
 import org.hibernate.loader.entity.UniqueEntityLoader;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.persister.spi.PersisterCreationContext;
 import org.hibernate.persister.walking.internal.EntityIdentifierDefinitionHelper;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.pretty.MessageHelper;
-import org.hibernate.property.BackrefPropertyAccessor;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;
 import org.hibernate.sql.Alias;
 import org.hibernate.sql.Delete;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.JoinType;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.sql.Template;
 import org.hibernate.sql.Update;
 import org.hibernate.tuple.GenerationTiming;
 import org.hibernate.tuple.InDatabaseValueGenerationStrategy;
 import org.hibernate.tuple.InMemoryValueGenerationStrategy;
 import org.hibernate.tuple.NonIdentifierAttribute;
 import org.hibernate.tuple.ValueGeneration;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 import org.hibernate.type.VersionType;
 
 /**
  * Basic functionality for persisting an entity via JDBC
  * through either generated or custom SQL
  *
  * @author Gavin King
  */
 public abstract class AbstractEntityPersister
 		implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
 				SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
 
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( AbstractEntityPersister.class );
 
 	public static final String ENTITY_CLASS = "class";
 
 	// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final SessionFactoryImplementor factory;
 	private final EntityRegionAccessStrategy cacheAccessStrategy;
 	private final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy;
 	private final boolean isLazyPropertiesCacheable;
 	private final CacheEntryHelper cacheEntryHelper;
 	private final EntityMetamodel entityMetamodel;
 	private final EntityTuplizer entityTuplizer;
 	private final EntityEntryFactory entityEntryFactory;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final String[] rootTableKeyColumnNames;
 	private final String[] rootTableKeyColumnReaders;
 	private final String[] rootTableKeyColumnReaderTemplates;
 	private final String[] identifierAliases;
 	private final int identifierColumnSpan;
 	private final String versionColumnName;
 	private final boolean hasFormulaProperties;
 	private final int batchSize;
 	private final boolean hasSubselectLoadableCollections;
 	protected final String rowIdName;
 
 	private final Set lazyProperties;
 
 	// The optional SQL string defined in the where attribute
 	private final String sqlWhereString;
 	private final String sqlWhereStringTemplate;
 
 	//information about properties of this class,
 	//including inherited properties
 	//(only really needed for updatable/insertable properties)
 	private final int[] propertyColumnSpans;
 	private final String[] propertySubclassNames;
 	private final String[][] propertyColumnAliases;
 	private final String[][] propertyColumnNames;
 	private final String[][] propertyColumnFormulaTemplates;
 	private final String[][] propertyColumnReaderTemplates;
 	private final String[][] propertyColumnWriters;
 	private final boolean[][] propertyColumnUpdateable;
 	private final boolean[][] propertyColumnInsertable;
 	private final boolean[] propertyUniqueness;
 	private final boolean[] propertySelectable;
 
 	private final List<Integer> lobProperties = new ArrayList<Integer>();
 
 	//information about lazy properties of this class
 	private final String[] lazyPropertyNames;
 	private final int[] lazyPropertyNumbers;
 	private final Type[] lazyPropertyTypes;
 	private final String[][] lazyPropertyColumnAliases;
 
 	//information about all properties in class hierarchy
 	private final String[] subclassPropertyNameClosure;
 	private final String[] subclassPropertySubclassNameClosure;
 	private final Type[] subclassPropertyTypeClosure;
 	private final String[][] subclassPropertyFormulaTemplateClosure;
 	private final String[][] subclassPropertyColumnNameClosure;
 	private final String[][] subclassPropertyColumnReaderClosure;
 	private final String[][] subclassPropertyColumnReaderTemplateClosure;
 	private final FetchMode[] subclassPropertyFetchModeClosure;
 	private final boolean[] subclassPropertyNullabilityClosure;
 	private final boolean[] propertyDefinedOnSubclass;
 	private final int[][] subclassPropertyColumnNumberClosure;
 	private final int[][] subclassPropertyFormulaNumberClosure;
 	private final CascadeStyle[] subclassPropertyCascadeStyleClosure;
 
 	//information about all columns/formulas in class hierarchy
 	private final String[] subclassColumnClosure;
 	private final boolean[] subclassColumnLazyClosure;
 	private final String[] subclassColumnAliasClosure;
 	private final boolean[] subclassColumnSelectableClosure;
 	private final String[] subclassColumnReaderTemplateClosure;
 	private final String[] subclassFormulaClosure;
 	private final String[] subclassFormulaTemplateClosure;
 	private final String[] subclassFormulaAliasClosure;
 	private final boolean[] subclassFormulaLazyClosure;
 
 	// dynamic filters attached to the class-level
 	private final FilterHelper filterHelper;
 
 	private final Set<String> affectingFetchProfileNames = new HashSet<String>();
 
 	private final Map uniqueKeyLoaders = new HashMap();
 	private final Map lockers = new HashMap();
 	private final Map loaders = new HashMap();
 
 	// SQL strings
 	private String sqlVersionSelectString;
 	private String sqlSnapshotSelectString;
 	private String sqlLazySelectString;
 
 	private String sqlIdentityInsertString;
 	private String sqlUpdateByRowIdString;
 	private String sqlLazyUpdateByRowIdString;
 
 	private String[] sqlDeleteStrings;
 	private String[] sqlInsertStrings;
 	private String[] sqlUpdateStrings;
 	private String[] sqlLazyUpdateStrings;
 
 	private String sqlInsertGeneratedValuesSelectString;
 	private String sqlUpdateGeneratedValuesSelectString;
 
 	//Custom SQL (would be better if these were private)
 	protected boolean[] insertCallable;
 	protected boolean[] updateCallable;
 	protected boolean[] deleteCallable;
 	protected String[] customSQLInsert;
 	protected String[] customSQLUpdate;
 	protected String[] customSQLDelete;
 	protected ExecuteUpdateResultCheckStyle[] insertResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] updateResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] deleteResultCheckStyles;
 
 	private InsertGeneratedIdentifierDelegate identityDelegate;
 
 	private boolean[] tableHasColumns;
 
 	private final String loaderName;
 
 	private UniqueEntityLoader queryLoader;
 
 	private final Map subclassPropertyAliases = new HashMap();
 	private final Map subclassPropertyColumnNames = new HashMap();
 
 	protected final BasicEntityPropertyMapping propertyMapping;
 
 	private final boolean useReferenceCacheEntries;
 
 	protected void addDiscriminatorToInsert(Insert insert) {
 	}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {
 	}
 
 	protected abstract int[] getSubclassColumnTableNumberClosure();
 
 	protected abstract int[] getSubclassFormulaTableNumberClosure();
 
 	public abstract String getSubclassTableName(int j);
 
 	protected abstract String[] getSubclassTableKeyColumns(int j);
 
 	protected abstract boolean isClassOrSuperclassTable(int j);
 
 	protected abstract int getSubclassTableSpan();
 
 	protected abstract int getTableSpan();
 
 	protected abstract boolean isTableCascadeDeleteEnabled(int j);
 
 	protected abstract String getTableName(int j);
 
 	protected abstract String[] getKeyColumns(int j);
 
 	protected abstract boolean isPropertyOfTable(int property, int j);
 
 	protected abstract int[] getPropertyTableNumbersInSelect();
 
 	protected abstract int[] getPropertyTableNumbers();
 
 	protected abstract int getSubclassPropertyTableNumber(int i);
 
 	protected abstract String filterFragment(String alias) throws MappingException;
 
 	protected abstract String filterFragment(String alias, Set<String> treatAsDeclarations);
 
 	private static final String DISCRIMINATOR_ALIAS = "clazz_";
 
 	public String getDiscriminatorColumnName() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaders() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaderTemplate() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorAlias() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorFormulaTemplate() {
 		return null;
 	}
 
 	protected boolean isInverseTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableSubclassTable(int j) {
 		return false;
 	}
 
 	protected boolean isInverseSubclassTable(int j) {
 		return false;
 	}
 
 	public boolean isSubclassEntityName(String entityName) {
 		return entityMetamodel.getSubclassEntityNames().contains( entityName );
 	}
 
 	private boolean[] getTableHasColumns() {
 		return tableHasColumns;
 	}
 
 	public String[] getRootTableKeyColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	protected String[] getSQLUpdateByRowIdStrings() {
 		if ( sqlUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan() + 1];
 		result[0] = sqlUpdateByRowIdString;
 		System.arraycopy( sqlUpdateStrings, 0, result, 1, getTableSpan() );
 		return result;
 	}
 
 	protected String[] getSQLLazyUpdateByRowIdStrings() {
 		if ( sqlLazyUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan()];
 		result[0] = sqlLazyUpdateByRowIdString;
 		System.arraycopy( sqlLazyUpdateStrings, 1, result, 1, getTableSpan() - 1 );
 		return result;
 	}
 
 	protected String getSQLSnapshotSelectString() {
 		return sqlSnapshotSelectString;
 	}
 
 	protected String getSQLLazySelectString() {
 		return sqlLazySelectString;
 	}
 
 	protected String[] getSQLDeleteStrings() {
 		return sqlDeleteStrings;
 	}
 
 	protected String[] getSQLInsertStrings() {
 		return sqlInsertStrings;
 	}
 
 	protected String[] getSQLUpdateStrings() {
 		return sqlUpdateStrings;
 	}
 
 	protected String[] getSQLLazyUpdateStrings() {
 		return sqlLazyUpdateStrings;
 	}
 
 	/**
 	 * The query that inserts a row, letting the database generate an id
 	 *
 	 * @return The IDENTITY-based insertion query.
 	 */
 	protected String getSQLIdentityInsertString() {
 		return sqlIdentityInsertString;
 	}
 
 	protected String getVersionSelectString() {
 		return sqlVersionSelectString;
 	}
 
 	protected boolean isInsertCallable(int j) {
 		return insertCallable[j];
 	}
 
 	protected boolean isUpdateCallable(int j) {
 		return updateCallable[j];
 	}
 
 	protected boolean isDeleteCallable(int j) {
 		return deleteCallable[j];
 	}
 
 	protected boolean isSubclassPropertyDeferred(String propertyName, String entityName) {
 		return false;
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return false;
 	}
 
 	public boolean hasSequentialSelect() {
 		return false;
 	}
 
 	/**
 	 * Decide which tables need to be updated.
 	 * <p/>
 	 * The return here is an array of boolean values with each index corresponding
 	 * to a given table in the scope of this persister.
 	 *
 	 * @param dirtyProperties The indices of all the entity properties considered dirty.
 	 * @param hasDirtyCollection Whether any collections owned by the entity which were considered dirty.
 	 *
 	 * @return Array of booleans indicating which table require updating.
 	 */
 	protected boolean[] getTableUpdateNeeded(final int[] dirtyProperties, boolean hasDirtyCollection) {
 
 		if ( dirtyProperties == null ) {
 			return getTableHasColumns(); // for objects that came in via update()
 		}
 		else {
 			boolean[] updateability = getPropertyUpdateability();
 			int[] propertyTableNumbers = getPropertyTableNumbers();
 			boolean[] tableUpdateNeeded = new boolean[getTableSpan()];
 			for ( int property : dirtyProperties ) {
 				int table = propertyTableNumbers[property];
 				tableUpdateNeeded[table] = tableUpdateNeeded[table] ||
 						( getPropertyColumnSpan( property ) > 0 && updateability[property] );
 			}
 			if ( isVersioned() ) {
 				tableUpdateNeeded[0] = tableUpdateNeeded[0] ||
 						Versioning.isVersionIncrementRequired(
 								dirtyProperties,
 								hasDirtyCollection,
 								getPropertyVersionability()
 						);
 			}
 			return tableUpdateNeeded;
 		}
 	}
 
 	public boolean hasRowId() {
 		return rowIdName != null;
 	}
 
 	protected boolean[][] getPropertyColumnUpdateable() {
 		return propertyColumnUpdateable;
 	}
 
 	protected boolean[][] getPropertyColumnInsertable() {
 		return propertyColumnInsertable;
 	}
 
 	protected boolean[] getPropertySelectable() {
 		return propertySelectable;
 	}
 
 	@SuppressWarnings("UnnecessaryBoxing")
 	public AbstractEntityPersister(
 			final PersistentClass persistentClass,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final PersisterCreationContext creationContext) throws HibernateException {
 
 		// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		this.factory = creationContext.getSessionFactory();
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		this.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;
 		isLazyPropertiesCacheable = persistentClass.isLazyPropertiesCacheable();
 
 		this.entityMetamodel = new EntityMetamodel( persistentClass, this, factory );
 		this.entityTuplizer = this.entityMetamodel.getTuplizer();
 
 		if ( entityMetamodel.isMutable() ) {
 			this.entityEntryFactory = MutableEntityEntryFactory.INSTANCE;
 		}
 		else {
 			this.entityEntryFactory = ImmutableEntityEntryFactory.INSTANCE;
 		}
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		int batch = persistentClass.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSessionFactoryOptions().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 		hasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();
 
 		propertyMapping = new BasicEntityPropertyMapping( this );
 
 		// IDENTIFIER
 
 		identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
 		rootTableKeyColumnNames = new String[identifierColumnSpan];
 		rootTableKeyColumnReaders = new String[identifierColumnSpan];
 		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
 		identifierAliases = new String[identifierColumnSpan];
 
 		rowIdName = persistentClass.getRootTable().getRowId();
 
 		loaderName = persistentClass.getLoaderName();
 
 		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Column col = (Column) iter.next();
 			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
 			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
 			rootTableKeyColumnReaderTemplates[i] = col.getTemplate(
 					factory.getDialect(),
 					factory.getSqlFunctionRegistry()
 			);
 			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 			i++;
 		}
 
 		// VERSION
 
 		if ( persistentClass.isVersioned() ) {
 			versionColumnName = ( (Column) persistentClass.getVersion().getColumnIterator().next() ).getQuotedName(
 					factory.getDialect()
 			);
 		}
 		else {
 			versionColumnName = null;
 		}
 
 		//WHERE STRING
 
 		sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ?
 				"( " + persistentClass.getWhere() + ") " :
 				null;
 		sqlWhereStringTemplate = sqlWhereString == null ?
 				null :
 				Template.renderWhereStringTemplate(
 						sqlWhereString,
 						factory.getDialect(),
 						factory.getSqlFunctionRegistry()
 				);
 
 		// PROPERTIES
 
 		final boolean lazyAvailable = isInstrumented();
 
 		int hydrateSpan = entityMetamodel.getPropertySpan();
 		propertyColumnSpans = new int[hydrateSpan];
 		propertySubclassNames = new String[hydrateSpan];
 		propertyColumnAliases = new String[hydrateSpan][];
 		propertyColumnNames = new String[hydrateSpan][];
 		propertyColumnFormulaTemplates = new String[hydrateSpan][];
 		propertyColumnReaderTemplates = new String[hydrateSpan][];
 		propertyColumnWriters = new String[hydrateSpan][];
 		propertyUniqueness = new boolean[hydrateSpan];
 		propertySelectable = new boolean[hydrateSpan];
 		propertyColumnUpdateable = new boolean[hydrateSpan][];
 		propertyColumnInsertable = new boolean[hydrateSpan][];
 		HashSet thisClassProperties = new HashSet();
 
 		lazyProperties = new HashSet();
 		ArrayList lazyNames = new ArrayList();
 		ArrayList lazyNumbers = new ArrayList();
 		ArrayList lazyTypes = new ArrayList();
 		ArrayList lazyColAliases = new ArrayList();
 
 		iter = persistentClass.getPropertyClosureIterator();
 		i = 0;
 		boolean foundFormula = false;
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			thisClassProperties.add( prop );
 
 			int span = prop.getColumnSpan();
 			propertyColumnSpans[i] = span;
 			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
 			String[] colNames = new String[span];
 			String[] colAliases = new String[span];
 			String[] colReaderTemplates = new String[span];
 			String[] colWriters = new String[span];
 			String[] formulaTemplates = new String[span];
 			Iterator colIter = prop.getColumnIterator();
 			int k = 0;
 			while ( colIter.hasNext() ) {
 				Selectable thing = (Selectable) colIter.next();
 				colAliases[k] = thing.getAlias( factory.getDialect(), prop.getValue().getTable() );
 				if ( thing.isFormula() ) {
 					foundFormula = true;
 					formulaTemplates[k] = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				}
 				else {
 					Column col = (Column) thing;
 					colNames[k] = col.getQuotedName( factory.getDialect() );
 					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					colWriters[k] = col.getWriteExpr();
 				}
 				k++;
 			}
 			propertyColumnNames[i] = colNames;
 			propertyColumnFormulaTemplates[i] = formulaTemplates;
 			propertyColumnReaderTemplates[i] = colReaderTemplates;
 			propertyColumnWriters[i] = colWriters;
 			propertyColumnAliases[i] = colAliases;
 
 			if ( lazyAvailable && prop.isLazy() ) {
 				lazyProperties.add( prop.getName() );
 				lazyNames.add( prop.getName() );
 				lazyNumbers.add( i );
 				lazyTypes.add( prop.getValue().getType() );
 				lazyColAliases.add( colAliases );
 			}
 
 			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
 			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
 
 			propertySelectable[i] = prop.isSelectable();
 
 			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
 
 			if ( prop.isLob() && getFactory().getDialect().forceLobAsLastValue() ) {
 				lobProperties.add( i );
 			}
 
 			i++;
 
 		}
 		hasFormulaProperties = foundFormula;
 		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
 		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
 		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
 		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
 
 		// SUBCLASS PROPERTY CLOSURE
 
 		ArrayList columns = new ArrayList();
 		ArrayList columnsLazy = new ArrayList();
 		ArrayList columnReaderTemplates = new ArrayList();
 		ArrayList aliases = new ArrayList();
 		ArrayList formulas = new ArrayList();
 		ArrayList formulaAliases = new ArrayList();
 		ArrayList formulaTemplates = new ArrayList();
 		ArrayList formulasLazy = new ArrayList();
 		ArrayList types = new ArrayList();
 		ArrayList names = new ArrayList();
 		ArrayList classes = new ArrayList();
 		ArrayList templates = new ArrayList();
 		ArrayList propColumns = new ArrayList();
 		ArrayList propColumnReaders = new ArrayList();
 		ArrayList propColumnReaderTemplates = new ArrayList();
 		ArrayList joinedFetchesList = new ArrayList();
 		ArrayList cascades = new ArrayList();
 		ArrayList definedBySubclass = new ArrayList();
 		ArrayList propColumnNumbers = new ArrayList();
 		ArrayList propFormulaNumbers = new ArrayList();
 		ArrayList columnSelectables = new ArrayList();
 		ArrayList propNullables = new ArrayList();
 
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			names.add( prop.getName() );
 			classes.add( prop.getPersistentClass().getEntityName() );
 			boolean isDefinedBySubclass = !thisClassProperties.contains( prop );
 			definedBySubclass.add( Boolean.valueOf( isDefinedBySubclass ) );
 			propNullables.add( Boolean.valueOf( prop.isOptional() || isDefinedBySubclass ) ); //TODO: is this completely correct?
 			types.add( prop.getType() );
 
 			Iterator colIter = prop.getColumnIterator();
 			String[] cols = new String[prop.getColumnSpan()];
 			String[] readers = new String[prop.getColumnSpan()];
 			String[] readerTemplates = new String[prop.getColumnSpan()];
 			String[] forms = new String[prop.getColumnSpan()];
 			int[] colnos = new int[prop.getColumnSpan()];
 			int[] formnos = new int[prop.getColumnSpan()];
 			int l = 0;
 			Boolean lazy = Boolean.valueOf( prop.isLazy() && lazyAvailable );
 			while ( colIter.hasNext() ) {
 				Selectable thing = (Selectable) colIter.next();
 				if ( thing.isFormula() ) {
 					String template = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					formnos[l] = formulaTemplates.size();
 					colnos[l] = -1;
 					formulaTemplates.add( template );
 					forms[l] = template;
 					formulas.add( thing.getText( factory.getDialect() ) );
 					formulaAliases.add( thing.getAlias( factory.getDialect() ) );
 					formulasLazy.add( lazy );
 				}
 				else {
 					Column col = (Column) thing;
 					String colName = col.getQuotedName( factory.getDialect() );
 					colnos[l] = columns.size(); //before add :-)
 					formnos[l] = -1;
 					columns.add( colName );
 					cols[l] = colName;
 					aliases.add( thing.getAlias( factory.getDialect(), prop.getValue().getTable() ) );
 					columnsLazy.add( lazy );
 					columnSelectables.add( Boolean.valueOf( prop.isSelectable() ) );
 
 					readers[l] = col.getReadExpr( factory.getDialect() );
 					String readerTemplate = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					readerTemplates[l] = readerTemplate;
 					columnReaderTemplates.add( readerTemplate );
 				}
 				l++;
 			}
 			propColumns.add( cols );
 			propColumnReaders.add( readers );
 			propColumnReaderTemplates.add( readerTemplates );
 			templates.add( forms );
 			propColumnNumbers.add( colnos );
 			propFormulaNumbers.add( formnos );
 
 			joinedFetchesList.add( prop.getValue().getFetchMode() );
 			cascades.add( prop.getCascadeStyle() );
 		}
 		subclassColumnClosure = ArrayHelper.toStringArray( columns );
 		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
 		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
 		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
 		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
 
 		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
 		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
 		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
 		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
 
 		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
 		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
 		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
 		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
 		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
 		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
 		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
 		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
 		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
 		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
 
 		subclassPropertyCascadeStyleClosure = new CascadeStyle[cascades.size()];
 		iter = cascades.iterator();
 		int j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyCascadeStyleClosure[j++] = (CascadeStyle) iter.next();
 		}
 		subclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];
 		iter = joinedFetchesList.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyFetchModeClosure[j++] = (FetchMode) iter.next();
 		}
 
 		propertyDefinedOnSubclass = new boolean[definedBySubclass.size()];
 		iter = definedBySubclass.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			propertyDefinedOnSubclass[j++] = (Boolean) iter.next();
 		}
 
 		// Handle any filters applied to the class level
 		filterHelper = new FilterHelper( persistentClass.getFilters(), factory );
 
 		// Check if we can use Reference Cached entities in 2lc
 		// todo : should really validate that the cache access type is read-only
 		boolean refCacheEntries = true;
 		if ( !factory.getSessionFactoryOptions().isDirectReferenceCacheEntriesEnabled() ) {
 			refCacheEntries = false;
 		}
 
 		// for now, limit this to just entities that:
 		// 		1) are immutable
 		if ( entityMetamodel.isMutable() ) {
 			refCacheEntries = false;
 		}
 
 		//		2)  have no associations.  Eventually we want to be a little more lenient with associations.
 		for ( Type type : getSubclassPropertyTypeClosure() ) {
 			if ( type.isAssociationType() ) {
 				refCacheEntries = false;
 			}
 		}
 
 		useReferenceCacheEntries = refCacheEntries;
 
 		this.cacheEntryHelper = buildCacheEntryHelper();
 
 	}
 
 	protected CacheEntryHelper buildCacheEntryHelper() {
 		if ( cacheAccessStrategy == null ) {
 			// the entity defined no caching...
 			return NoopCacheEntryHelper.INSTANCE;
 		}
 
 		if ( canUseReferenceCacheEntries() ) {
 			entityMetamodel.setLazy( false );
 			// todo : do we also need to unset proxy factory?
 			return new ReferenceCacheEntryHelper( this );
 		}
 
 		return factory.getSessionFactoryOptions().isStructuredCacheEntriesEnabled()
 				? new StructuredCacheEntryHelper( this )
 				: new StandardCacheEntryHelper( this );
 	}
 
 	public boolean canUseReferenceCacheEntries() {
 		return useReferenceCacheEntries;
 	}
 
 	protected static String getTemplateFromString(String string, SessionFactoryImplementor factory) {
 		return string == null ?
 				null :
 				Template.renderWhereStringTemplate( string, factory.getDialect(), factory.getSqlFunctionRegistry() );
 	}
 
 	protected String generateLazySelectString() {
 
 		if ( !entityMetamodel.hasLazyProperties() ) {
 			return null;
 		}
 
 		HashSet tableNumbers = new HashSet();
 		ArrayList columnNumbers = new ArrayList();
 		ArrayList formulaNumbers = new ArrayList();
 		for ( String lazyPropertyName : lazyPropertyNames ) {
 			// all this only really needs to consider properties
 			// of this class, not its subclasses, but since we
 			// are reusing code used for sequential selects, we
 			// use the subclass closure
 			int propertyNumber = getSubclassPropertyIndex( lazyPropertyName );
 
 			int tableNumber = getSubclassPropertyTableNumber( propertyNumber );
 			tableNumbers.add( tableNumber );
 
 			int[] colNumbers = subclassPropertyColumnNumberClosure[propertyNumber];
 			for ( int colNumber : colNumbers ) {
 				if ( colNumber != -1 ) {
 					columnNumbers.add( colNumber );
 				}
 			}
 			int[] formNumbers = subclassPropertyFormulaNumberClosure[propertyNumber];
 			for ( int formNumber : formNumbers ) {
 				if ( formNumber != -1 ) {
 					formulaNumbers.add( formNumber );
 				}
 			}
 		}
 
 		if ( columnNumbers.size() == 0 && formulaNumbers.size() == 0 ) {
 			// only one-to-one is lazy fetched
 			return null;
 		}
 
 		return renderSelect(
 				ArrayHelper.toIntArray( tableNumbers ),
 				ArrayHelper.toIntArray( columnNumbers ),
 				ArrayHelper.toIntArray( formulaNumbers )
 		);
 
 	}
 
 	public Object initializeLazyProperty(String fieldName, Object entity, SessionImplementor session)
 			throws HibernateException {
 
 		final Serializable id = session.getContextEntityIdentifier( entity );
 
 		final EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			throw new HibernateException( "entity is not associated with the session: " + id );
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev(
 					"Initializing lazy properties of: {0}, field access: {1}", MessageHelper.infoString(
 							this,
 							id,
 							getFactory()
 					), fieldName
 			);
 		}
 
 		if ( session.getCacheMode().isGetEnabled() && hasCache() ) {
 			final CacheKey cacheKey = session.generateCacheKey( id, getIdentifierType(), getRootEntityName() );
 			final Object ce = CacheHelper.fromSharedCache( session, cacheKey, getCacheAccessStrategy() );
 			if ( ce != null ) {
 				final CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure( ce, factory );
 				if ( !cacheEntry.areLazyPropertiesUnfetched() ) {
 					//note early exit here:
 					return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
 				}
 			}
 		}
 
 		return initializeLazyPropertiesFromDatastore( fieldName, entity, session, id, entry );
 
 	}
 
 	private Object initializeLazyPropertiesFromDatastore(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Serializable id,
 			final EntityEntry entry) {
 
 		if ( !hasLazyProperties() ) {
 			throw new AssertionFailure( "no lazy properties" );
 		}
 
 		LOG.trace( "Initializing lazy properties from datastore" );
 
 		try {
 
 			Object result = null;
 			PreparedStatement ps = null;
 			try {
 				final String lazySelect = getSQLLazySelectString();
 				ResultSet rs = null;
 				try {
 					if ( lazySelect != null ) {
 						// null sql means that the only lazy properties
 						// are shared PK one-to-one associations which are
 						// handled differently in the Type#nullSafeGet code...
 						ps = session.getJdbcCoordinator()
 								.getStatementPreparer()
 								.prepareStatement( lazySelect );
 						getIdentifierType().nullSafeSet( ps, id, 1, session );
 						rs = session.getJdbcCoordinator().getResultSetReturn().extract( ps );
 						rs.next();
 					}
 					final Object[] snapshot = entry.getLoadedState();
 					for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 						Object propValue = lazyPropertyTypes[j].nullSafeGet(
 								rs,
 								lazyPropertyColumnAliases[j],
 								session,
 								entity
 						);
 						if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 							result = propValue;
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						session.getJdbcCoordinator().getResourceRegistry().release( rs, ps );
 					}
 				}
 			}
 			finally {
 				if ( ps != null ) {
 					session.getJdbcCoordinator().getResourceRegistry().release( ps );
 					session.getJdbcCoordinator().afterStatementExecution();
 				}
 			}
 
 			LOG.trace( "Done initializing lazy properties" );
 
 			return result;
 
 		}
 		catch (SQLException sqle) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize lazy properties: " +
 							MessageHelper.infoString( this, id, getFactory() ),
 					getSQLLazySelectString()
 			);
 		}
 	}
 
 	private Object initializeLazyPropertiesFromCache(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final EntityEntry entry,
 			final CacheEntry cacheEntry
 	) {
 
 		LOG.trace( "Initializing lazy properties from second-level cache" );
 
 		Object result = null;
 		Serializable[] disassembledValues = cacheEntry.getDisassembledState();
 		final Object[] snapshot = entry.getLoadedState();
 		for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 			final Object propValue = lazyPropertyTypes[j].assemble(
 					disassembledValues[lazyPropertyNumbers[j]],
 					session,
 					entity
 			);
 			if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 				result = propValue;
 			}
 		}
 
 		LOG.trace( "Done initializing lazy properties" );
 
 		return result;
 	}
 
 	private boolean initializeLazyProperty(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Object[] snapshot,
 			final int j,
 			final Object propValue) {
 		setPropertyValue( entity, lazyPropertyNumbers[j], propValue );
 		if ( snapshot != null ) {
 			// object have been loaded with setReadOnly(true); HHH-2236
 			snapshot[lazyPropertyNumbers[j]] = lazyPropertyTypes[j].deepCopy( propValue, factory );
 		}
 		return fieldName.equals( lazyPropertyNames[j] );
 	}
 
 	public boolean isBatchable() {
 		return optimisticLockStyle() == OptimisticLockStyle.NONE
 				|| ( !isVersioned() && optimisticLockStyle() == OptimisticLockStyle.VERSION )
 				|| getFactory().getSessionFactoryOptions().isJdbcBatchVersionedData();
 	}
 
 	public Serializable[] getQuerySpaces() {
 		return getPropertySpaces();
 	}
 
 	protected Set getLazyProperties() {
 		return lazyProperties;
 	}
 
 	public boolean isBatchLoadable() {
 		return batchSize > 1;
 	}
 
 	public String[] getIdentifierColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	public String[] getIdentifierColumnReaders() {
 		return rootTableKeyColumnReaders;
 	}
 
 	public String[] getIdentifierColumnReaderTemplates() {
 		return rootTableKeyColumnReaderTemplates;
 	}
 
 	protected int getIdentifierColumnSpan() {
 		return identifierColumnSpan;
 	}
 
 	protected String[] getIdentifierAliases() {
 		return identifierAliases;
 	}
 
 	public String getVersionColumnName() {
 		return versionColumnName;
 	}
 
 	protected String getVersionedTableName() {
 		return getTableName( 0 );
 	}
 
 	protected boolean[] getSubclassColumnLazyiness() {
 		return subclassColumnLazyClosure;
 	}
 
 	protected boolean[] getSubclassFormulaLazyiness() {
 		return subclassFormulaLazyClosure;
 	}
 
 	/**
 	 * We can't immediately add to the cache if we have formulas
 	 * which must be evaluated, or if we have the possibility of
@@ -1648,2001 +1648,2001 @@ public abstract class AbstractEntityPersister
 
 	public void lock(
 			Serializable id,
 			Object version,
 			Object object,
 			LockMode lockMode,
 			SessionImplementor session) throws HibernateException {
 		getLocker( lockMode ).lock( id, version, object, LockOptions.WAIT_FOREVER, session );
 	}
 
 	public void lock(
 			Serializable id,
 			Object version,
 			Object object,
 			LockOptions lockOptions,
 			SessionImplementor session) throws HibernateException {
 		getLocker( lockOptions.getLockMode() ).lock( id, version, object, lockOptions.getTimeOut(), session );
 	}
 
 	public String getRootTableName() {
 		return getSubclassTableName( 0 );
 	}
 
 	public String getRootTableAlias(String drivingAlias) {
 		return drivingAlias;
 	}
 
 	public String[] getRootTableIdentifierColumnNames() {
 		return getRootTableKeyColumnNames();
 	}
 
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		return propertyMapping.toColumns( alias, propertyName );
 	}
 
 	public String[] toColumns(String propertyName) throws QueryException {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	public Type toType(String propertyName) throws QueryException {
 		return propertyMapping.toType( propertyName );
 	}
 
 	public String[] getPropertyColumnNames(String propertyName) {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	/**
 	 * Warning:
 	 * When there are duplicated property names in the subclasses
 	 * of the class, this method may return the wrong table
 	 * number for the duplicated subclass property (note that
 	 * SingleTableEntityPersister defines an overloaded form
 	 * which takes the entity name.
 	 */
 	public int getSubclassPropertyTableNumber(String propertyPath) {
 		String rootPropertyName = StringHelper.root( propertyPath );
 		Type type = propertyMapping.toType( rootPropertyName );
 		if ( type.isAssociationType() ) {
 			AssociationType assocType = (AssociationType) type;
 			if ( assocType.useLHSPrimaryKey() ) {
 				// performance op to avoid the array search
 				return 0;
 			}
 			else if ( type.isCollectionType() ) {
 				// properly handle property-ref-based associations
 				rootPropertyName = assocType.getLHSPropertyName();
 			}
 		}
 		//Enable for HHH-440, which we don't like:
 		/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {
 			String unrooted = StringHelper.unroot(propertyName);
 			int idx = ArrayHelper.indexOf( getSubclassColumnClosure(), unrooted );
 			if ( idx != -1 ) {
 				return getSubclassColumnTableNumberClosure()[idx];
 			}
 		}*/
 		int index = ArrayHelper.indexOf(
 				getSubclassPropertyNameClosure(),
 				rootPropertyName
 		); //TODO: optimize this better!
 		return index == -1 ? 0 : getSubclassPropertyTableNumber( index );
 	}
 
 	public Declarer getSubclassPropertyDeclarer(String propertyPath) {
 		int tableIndex = getSubclassPropertyTableNumber( propertyPath );
 		if ( tableIndex == 0 ) {
 			return Declarer.CLASS;
 		}
 		else if ( isClassOrSuperclassTable( tableIndex ) ) {
 			return Declarer.SUPERCLASS;
 		}
 		else {
 			return Declarer.SUBCLASS;
 		}
 	}
 
 	private DiscriminatorMetadata discriminatorMetadata;
 
 	public DiscriminatorMetadata getTypeDiscriminatorMetadata() {
 		if ( discriminatorMetadata == null ) {
 			discriminatorMetadata = buildTypeDiscriminatorMetadata();
 		}
 		return discriminatorMetadata;
 	}
 
 	private DiscriminatorMetadata buildTypeDiscriminatorMetadata() {
 		return new DiscriminatorMetadata() {
 			public String getSqlFragment(String sqlQualificationAlias) {
 				return toColumns( sqlQualificationAlias, ENTITY_CLASS )[0];
 			}
 
 			public Type getResolutionType() {
 				return new DiscriminatorType( getDiscriminatorType(), AbstractEntityPersister.this );
 			}
 		};
 	}
 
 	public static String generateTableAlias(String rootAlias, int tableNumber) {
 		if ( tableNumber == 0 ) {
 			return rootAlias;
 		}
 		StringBuilder buf = new StringBuilder().append( rootAlias );
 		if ( !rootAlias.endsWith( "_" ) ) {
 			buf.append( '_' );
 		}
 		return buf.append( tableNumber ).append( '_' ).toString();
 	}
 
 	public String[] toColumns(String name, final int i) {
 		final String alias = generateTableAlias( name, getSubclassPropertyTableNumber( i ) );
 		String[] cols = getSubclassPropertyColumnNames( i );
 		String[] templates = getSubclassPropertyFormulaTemplateClosure()[i];
 		String[] result = new String[cols.length];
 		for ( int j = 0; j < cols.length; j++ ) {
 			if ( cols[j] == null ) {
 				result[j] = StringHelper.replace( templates[j], Template.TEMPLATE, alias );
 			}
 			else {
 				result[j] = StringHelper.qualify( alias, cols[j] );
 			}
 		}
 		return result;
 	}
 
 	private int getSubclassPropertyIndex(String propertyName) {
 		return ArrayHelper.indexOf( subclassPropertyNameClosure, propertyName );
 	}
 
 	protected String[] getPropertySubclassNames() {
 		return propertySubclassNames;
 	}
 
 	public String[] getPropertyColumnNames(int i) {
 		return propertyColumnNames[i];
 	}
 
 	public String[] getPropertyColumnWriters(int i) {
 		return propertyColumnWriters[i];
 	}
 
 	protected int getPropertyColumnSpan(int i) {
 		return propertyColumnSpans[i];
 	}
 
 	protected boolean hasFormulaProperties() {
 		return hasFormulaProperties;
 	}
 
 	public FetchMode getFetchMode(int i) {
 		return subclassPropertyFetchModeClosure[i];
 	}
 
 	public CascadeStyle getCascadeStyle(int i) {
 		return subclassPropertyCascadeStyleClosure[i];
 	}
 
 	public Type getSubclassPropertyType(int i) {
 		return subclassPropertyTypeClosure[i];
 	}
 
 	public String getSubclassPropertyName(int i) {
 		return subclassPropertyNameClosure[i];
 	}
 
 	public int countSubclassProperties() {
 		return subclassPropertyTypeClosure.length;
 	}
 
 	public String[] getSubclassPropertyColumnNames(int i) {
 		return subclassPropertyColumnNameClosure[i];
 	}
 
 	public boolean isDefinedOnSubclass(int i) {
 		return propertyDefinedOnSubclass[i];
 	}
 
 	@Override
 	public String[][] getSubclassPropertyFormulaTemplateClosure() {
 		return subclassPropertyFormulaTemplateClosure;
 	}
 
 	protected Type[] getSubclassPropertyTypeClosure() {
 		return subclassPropertyTypeClosure;
 	}
 
 	protected String[][] getSubclassPropertyColumnNameClosure() {
 		return subclassPropertyColumnNameClosure;
 	}
 
 	public String[][] getSubclassPropertyColumnReaderClosure() {
 		return subclassPropertyColumnReaderClosure;
 	}
 
 	public String[][] getSubclassPropertyColumnReaderTemplateClosure() {
 		return subclassPropertyColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassPropertyNameClosure() {
 		return subclassPropertyNameClosure;
 	}
 
 	@Override
 	public int[] resolveAttributeIndexes(String[] attributeNames) {
 		if ( attributeNames == null || attributeNames.length == 0 ) {
 			return new int[0];
 		}
 		int[] fields = new int[attributeNames.length];
 		int counter = 0;
 
 		// We sort to get rid of duplicates
 		Arrays.sort( attributeNames );
 
 		Integer index0 = entityMetamodel.getPropertyIndexOrNull( attributeNames[0] );
 		if ( index0 != null ) {
 			fields[counter++] = index0;
 		}
 
 		for ( int i = 0, j = 1; j < attributeNames.length; ++i, ++j ) {
 			if ( !attributeNames[i].equals( attributeNames[j] ) ) {
 				Integer index = entityMetamodel.getPropertyIndexOrNull( attributeNames[j] );
 				if ( index != null ) {
 					fields[counter++] = index;
 				}
 			}
 		}
 
 		return Arrays.copyOf( fields, counter );
 	}
 
 	protected String[] getSubclassPropertySubclassNameClosure() {
 		return subclassPropertySubclassNameClosure;
 	}
 
 	protected String[] getSubclassColumnClosure() {
 		return subclassColumnClosure;
 	}
 
 	protected String[] getSubclassColumnAliasClosure() {
 		return subclassColumnAliasClosure;
 	}
 
 	public String[] getSubclassColumnReaderTemplateClosure() {
 		return subclassColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaClosure() {
 		return subclassFormulaClosure;
 	}
 
 	protected String[] getSubclassFormulaTemplateClosure() {
 		return subclassFormulaTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaAliasClosure() {
 		return subclassFormulaAliasClosure;
 	}
 
 	public String[] getSubclassPropertyColumnAliases(String propertyName, String suffix) {
 		String[] rawAliases = (String[]) subclassPropertyAliases.get( propertyName );
 
 		if ( rawAliases == null ) {
 			return null;
 		}
 
 		String[] result = new String[rawAliases.length];
 		for ( int i = 0; i < rawAliases.length; i++ ) {
 			result[i] = new Alias( suffix ).toUnquotedAliasString( rawAliases[i] );
 		}
 		return result;
 	}
 
 	public String[] getSubclassPropertyColumnNames(String propertyName) {
 		//TODO: should we allow suffixes on these ?
 		return (String[]) subclassPropertyColumnNames.get( propertyName );
 	}
 
 
 	//This is really ugly, but necessary:
 
 	/**
 	 * Must be called by subclasses, at the end of their constructors
 	 */
 	protected void initSubclassPropertyAliasesMap(PersistentClass model) throws MappingException {
 
 		// ALIASES
 		internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
 
 		// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'
 		if ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			subclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );
 			subclassPropertyColumnNames.put( ENTITY_ID, getIdentifierColumnNames() );
 		}
 
 		// aliases named identifier ( alias.idname )
 		if ( hasIdentifierProperty() ) {
 			subclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );
 			subclassPropertyColumnNames.put( getIdentifierPropertyName(), getIdentifierColumnNames() );
 		}
 
 		// aliases for composite-id's
 		if ( getIdentifierType().isComponentType() ) {
 			// Fetch embedded identifiers propertynames from the "virtual" identifier component
 			CompositeType componentId = (CompositeType) getIdentifierType();
 			String[] idPropertyNames = componentId.getPropertyNames();
 			String[] idAliases = getIdentifierAliases();
 			String[] idColumnNames = getIdentifierColumnNames();
 
 			for ( int i = 0; i < idPropertyNames.length; i++ ) {
 				if ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 					subclassPropertyAliases.put(
 							ENTITY_ID + "." + idPropertyNames[i],
 							new String[] {idAliases[i]}
 					);
 					subclassPropertyColumnNames.put(
 							ENTITY_ID + "." + getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] {idColumnNames[i]}
 					);
 				}
 //				if (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyName() ) ) {
 				if ( hasIdentifierProperty() ) {
 					subclassPropertyAliases.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] {idAliases[i]}
 					);
 					subclassPropertyColumnNames.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] {idColumnNames[i]}
 					);
 				}
 				else {
 					// embedded composite ids ( alias.idname1, alias.idname2 )
 					subclassPropertyAliases.put( idPropertyNames[i], new String[] {idAliases[i]} );
 					subclassPropertyColumnNames.put( idPropertyNames[i], new String[] {idColumnNames[i]} );
 				}
 			}
 		}
 
 		if ( entityMetamodel.isPolymorphic() ) {
 			subclassPropertyAliases.put( ENTITY_CLASS, new String[] {getDiscriminatorAlias()} );
 			subclassPropertyColumnNames.put( ENTITY_CLASS, new String[] {getDiscriminatorColumnName()} );
 		}
 
 	}
 
 	private void internalInitSubclassPropertyAliasesMap(String path, Iterator propertyIterator) {
 		while ( propertyIterator.hasNext() ) {
 
 			Property prop = (Property) propertyIterator.next();
 			String propname = path == null ? prop.getName() : path + "." + prop.getName();
 			if ( prop.isComposite() ) {
 				Component component = (Component) prop.getValue();
 				Iterator compProps = component.getPropertyIterator();
 				internalInitSubclassPropertyAliasesMap( propname, compProps );
 			}
 			else {
 				String[] aliases = new String[prop.getColumnSpan()];
 				String[] cols = new String[prop.getColumnSpan()];
 				Iterator colIter = prop.getColumnIterator();
 				int l = 0;
 				while ( colIter.hasNext() ) {
 					Selectable thing = (Selectable) colIter.next();
 					aliases[l] = thing.getAlias( getFactory().getDialect(), prop.getValue().getTable() );
 					cols[l] = thing.getText( getFactory().getDialect() ); // TODO: skip formulas?
 					l++;
 				}
 
 				subclassPropertyAliases.put( propname, aliases );
 				subclassPropertyColumnNames.put( propname, cols );
 			}
 		}
 
 	}
 
 	public Object loadByUniqueKey(
 			String propertyName,
 			Object uniqueKey,
 			SessionImplementor session) throws HibernateException {
 		return getAppropriateUniqueKeyLoader( propertyName, session ).loadByUniqueKey( session, uniqueKey );
 	}
 
 	private EntityLoader getAppropriateUniqueKeyLoader(String propertyName, SessionImplementor session) {
 		final boolean useStaticLoader = !session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& !session.getLoadQueryInfluencers().hasEnabledFetchProfiles()
 				&& propertyName.indexOf( '.' ) < 0; //ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties
 
 		if ( useStaticLoader ) {
 			return (EntityLoader) uniqueKeyLoaders.get( propertyName );
 		}
 		else {
 			return createUniqueKeyLoader(
 					propertyMapping.toType( propertyName ),
 					propertyMapping.toColumns( propertyName ),
 					session.getLoadQueryInfluencers()
 			);
 		}
 	}
 
 	public int getPropertyIndex(String propertyName) {
 		return entityMetamodel.getPropertyIndex( propertyName );
 	}
 
 	protected void createUniqueKeyLoaders() throws MappingException {
 		Type[] propertyTypes = getPropertyTypes();
 		String[] propertyNames = getPropertyNames();
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( propertyUniqueness[i] ) {
 				//don't need filters for the static loaders
 				uniqueKeyLoaders.put(
 						propertyNames[i],
 						createUniqueKeyLoader(
 								propertyTypes[i],
 								getPropertyColumnNames( i ),
 								LoadQueryInfluencers.NONE
 						)
 				);
 				//TODO: create uk loaders for component properties
 			}
 		}
 	}
 
 	private EntityLoader createUniqueKeyLoader(
 			Type uniqueKeyType,
 			String[] columns,
 			LoadQueryInfluencers loadQueryInfluencers) {
 		if ( uniqueKeyType.isEntityType() ) {
 			String className = ( (EntityType) uniqueKeyType ).getAssociatedEntityName();
 			uniqueKeyType = getFactory().getEntityPersister( className ).getIdentifierType();
 		}
 		return new EntityLoader(
 				this,
 				columns,
 				uniqueKeyType,
 				1,
 				LockMode.NONE,
 				getFactory(),
 				loadQueryInfluencers
 		);
 	}
 
 	protected String getSQLWhereString(String alias) {
 		return StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );
 	}
 
 	protected boolean hasWhere() {
 		return sqlWhereString != null;
 	}
 
 	private void initOrdinaryPropertyPaths(Mapping mapping) throws MappingException {
 		for ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {
 			propertyMapping.initPropertyPaths(
 					getSubclassPropertyNameClosure()[i],
 					getSubclassPropertyTypeClosure()[i],
 					getSubclassPropertyColumnNameClosure()[i],
 					getSubclassPropertyColumnReaderClosure()[i],
 					getSubclassPropertyColumnReaderTemplateClosure()[i],
 					getSubclassPropertyFormulaTemplateClosure()[i],
 					mapping
 			);
 		}
 	}
 
 	private void initIdentifierPropertyPaths(Mapping mapping) throws MappingException {
 		String idProp = getIdentifierPropertyName();
 		if ( idProp != null ) {
 			propertyMapping.initPropertyPaths(
 					idProp, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping
 			);
 		}
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			propertyMapping.initPropertyPaths(
 					null, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping
 			);
 		}
 		if ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			propertyMapping.initPropertyPaths(
 					ENTITY_ID, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping
 			);
 		}
 	}
 
 	private void initDiscriminatorPropertyPath(Mapping mapping) throws MappingException {
 		propertyMapping.initPropertyPaths(
 				ENTITY_CLASS,
 				getDiscriminatorType(),
 				new String[] {getDiscriminatorColumnName()},
 				new String[] {getDiscriminatorColumnReaders()},
 				new String[] {getDiscriminatorColumnReaderTemplate()},
 				new String[] {getDiscriminatorFormulaTemplate()},
 				getFactory()
 		);
 	}
 
 	protected void initPropertyPaths(Mapping mapping) throws MappingException {
 		initOrdinaryPropertyPaths( mapping );
 		initOrdinaryPropertyPaths( mapping ); //do two passes, for collection property-ref!
 		initIdentifierPropertyPaths( mapping );
 		if ( entityMetamodel.isPolymorphic() ) {
 			initDiscriminatorPropertyPath( mapping );
 		}
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockMode lockMode,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
 				.buildLoader( this, batchSize, lockMode, getFactory(), loadQueryInfluencers );
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockOptions lockOptions,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
 				.buildLoader( this, batchSize, lockOptions, getFactory(), loadQueryInfluencers );
 	}
 
 	/**
 	 * Used internally to create static loaders.  These are the default set of loaders used to handle get()/load()
 	 * processing.  lock() handling is done by the LockingStrategy instances (see {@link #getLocker})
 	 *
 	 * @param lockMode The lock mode to apply to the thing being loaded.
 	 *
 	 * @return
 	 *
 	 * @throws MappingException
 	 */
 	protected UniqueEntityLoader createEntityLoader(LockMode lockMode) throws MappingException {
 		return createEntityLoader( lockMode, LoadQueryInfluencers.NONE );
 	}
 
 	protected boolean check(
 			int rows,
 			Serializable id,
 			int tableNumber,
 			Expectation expectation,
 			PreparedStatement statement) throws HibernateException {
 		try {
 			expectation.verifyOutcome( rows, statement, -1 );
 		}
 		catch (StaleStateException e) {
 			if ( !isNullableTable( tableNumber ) ) {
 				if ( getFactory().getStatistics().isStatisticsEnabled() ) {
 					getFactory().getStatisticsImplementor()
 							.optimisticFailure( getEntityName() );
 				}
 				throw new StaleObjectStateException( getEntityName(), id );
 			}
 			return false;
 		}
 		catch (TooManyRowsAffectedException e) {
 			throw new HibernateException(
 					"Duplicate identifier in table for: " +
 							MessageHelper.infoString( this, id, getFactory() )
 			);
 		}
 		catch (Throwable t) {
 			return false;
 		}
 		return true;
 	}
 
 	protected String generateUpdateString(boolean[] includeProperty, int j, boolean useRowId) {
 		return generateUpdateString( includeProperty, j, null, useRowId );
 	}
 
 	/**
 	 * Generate the SQL that updates a row by id (and version)
 	 */
 	protected String generateUpdateString(
 			final boolean[] includeProperty,
 			final int j,
 			final Object[] oldFields,
 			final boolean useRowId) {
 
 		Update update = new Update( getFactory().getDialect() ).setTableName( getTableName( j ) );
 
 		// select the correct row by either pk or rowid
 		if ( useRowId ) {
 			update.addPrimaryKeyColumns( new String[] {rowIdName} ); //TODO: eventually, rowIdName[j]
 		}
 		else {
 			update.addPrimaryKeyColumns( getKeyColumns( j ) );
 		}
 
 		boolean hasColumns = false;
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j )
 					&& !lobProperties.contains( i ) ) {
 				// this is a property of the table, which we are updating
 				update.addColumns(
 						getPropertyColumnNames( i ),
 						propertyColumnUpdateable[i], propertyColumnWriters[i]
 				);
 				hasColumns = hasColumns || getPropertyColumnSpan( i ) > 0;
 			}
 		}
 
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this property belongs on the table and is to be inserted
 				update.addColumns(
 						getPropertyColumnNames( i ),
 						propertyColumnUpdateable[i], propertyColumnWriters[i]
 				);
 				hasColumns = true;
 			}
 		}
 
 		if ( j == 0 && isVersioned() && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
 			// this is the root (versioned) table, and we are using version-based
 			// optimistic locking;  if we are not updating the version, also don't
 			// check it (unless this is a "generated" version column)!
 			if ( checkVersion( includeProperty ) ) {
 				update.setVersionColumnName( getVersionColumnName() );
 				hasColumns = true;
 			}
 		}
 		else if ( isAllOrDirtyOptLocking() && oldFields != null ) {
 			// we are using "all" or "dirty" property-based optimistic locking
 
 			boolean[] includeInWhere = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
 					?
 					getPropertyUpdateability()
 					//optimistic-lock="all", include all updatable properties
 					:
 					includeProperty;             //optimistic-lock="dirty", include all properties we are updating this time
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				boolean include = includeInWhere[i] &&
 						isPropertyOfTable( i, j ) &&
 						versionability[i];
 				if ( include ) {
 					// this property belongs to the table, and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					String[] propertyColumnWriters = getPropertyColumnWriters( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( oldFields[i], getFactory() );
 					for ( int k = 0; k < propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							update.addWhereColumn( propertyColumnNames[k], "=" + propertyColumnWriters[k] );
 						}
 						else {
 							update.addWhereColumn( propertyColumnNames[k], " is null" );
 						}
 					}
 				}
 			}
 
 		}
 
 		if ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {
 			update.setComment( "update " + getEntityName() );
 		}
 
 		return hasColumns ? update.toStatementString() : null;
 	}
 
 	private boolean checkVersion(final boolean[] includeProperty) {
 		return includeProperty[getVersionProperty()]
 				|| entityMetamodel.isVersionGenerated();
 	}
 
 	protected String generateInsertString(boolean[] includeProperty, int j) {
 		return generateInsertString( false, includeProperty, j );
 	}
 
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty) {
 		return generateInsertString( identityInsert, includeProperty, 0 );
 	}
 
 	/**
 	 * Generate the SQL that inserts a row
 	 */
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty, int j) {
 
 		// todo : remove the identityInsert param and variations;
 		//   identity-insert strings are now generated from generateIdentityInsertString()
 
 		Insert insert = new Insert( getFactory().getDialect() )
 				.setTableName( getTableName( j ) );
 
 		// add normal properties
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			// the incoming 'includeProperty' array only accounts for insertable defined at the root level, it
 			// does not account for partially generated composites etc.  We also need to account for generation
 			// values
 			if ( isPropertyOfTable( i, j ) ) {
 				if ( !lobProperties.contains( i ) ) {
 					final InDatabaseValueGenerationStrategy generationStrategy = entityMetamodel.getInDatabaseValueGenerationStrategies()[i];
 					if ( generationStrategy != null && generationStrategy.getGenerationTiming().includesInsert() ) {
 						if ( generationStrategy.referenceColumnsInSql() ) {
 							final String[] values;
 							if ( generationStrategy.getReferencedColumnValues() == null ) {
 								values = propertyColumnWriters[i];
 							}
 							else {
 								final int numberOfColumns = propertyColumnWriters[i].length;
 								values = new String[numberOfColumns];
 								for ( int x = 0; x < numberOfColumns; x++ ) {
 									if ( generationStrategy.getReferencedColumnValues()[x] != null ) {
 										values[x] = generationStrategy.getReferencedColumnValues()[x];
 									}
 									else {
 										values[x] = propertyColumnWriters[i][x];
 									}
 								}
 							}
 							insert.addColumns( getPropertyColumnNames( i ), propertyColumnInsertable[i], values );
 						}
 					}
 					else if ( includeProperty[i] ) {
 						insert.addColumns(
 								getPropertyColumnNames( i ),
 								propertyColumnInsertable[i],
 								propertyColumnWriters[i]
 						);
 					}
 				}
 			}
 		}
 
 		// add the discriminator
 		if ( j == 0 ) {
 			addDiscriminatorToInsert( insert );
 		}
 
 		// add the primary key
 		if ( j == 0 && identityInsert ) {
 			insert.addIdentityColumn( getKeyColumns( 0 )[0] );
 		}
 		else {
 			insert.addColumns( getKeyColumns( j ) );
 		}
 
 		if ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns(
 						getPropertyColumnNames( i ),
 						propertyColumnInsertable[i],
 						propertyColumnWriters[i]
 				);
 			}
 		}
 
 		String result = insert.toStatementString();
 
 		// append the SQL to return the generated identifier
 		if ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert
 			result = getFactory().getDialect().appendIdentitySelectToInsert( result );
 		}
 
 		return result;
 	}
 
 	/**
 	 * Used to generate an insery statement against the root table in the
 	 * case of identifier generation strategies where the insert statement
 	 * executions actually generates the identifier value.
 	 *
 	 * @param includeProperty indices of the properties to include in the
 	 * insert statement.
 	 *
 	 * @return The insert SQL statement string
 	 */
 	protected String generateIdentityInsertString(boolean[] includeProperty) {
 		Insert insert = identityDelegate.prepareIdentifierGeneratingInsert();
 		insert.setTableName( getTableName( 0 ) );
 
 		// add normal properties except lobs
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, 0 ) && !lobProperties.contains( i ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns( getPropertyColumnNames( i ), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// HHH-4635 & HHH-8103
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, 0 ) ) {
 				insert.addColumns( getPropertyColumnNames( i ), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// add the discriminator
 		addDiscriminatorToInsert( insert );
 
 		// delegate already handles PK columns
 
 		if ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 
 		return insert.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL that deletes a row by id (and version)
 	 */
 	protected String generateDeleteString(int j) {
 		final Delete delete = new Delete()
 				.setTableName( getTableName( j ) )
 				.addPrimaryKeyColumns( getKeyColumns( j ) );
 		if ( j == 0 ) {
 			delete.setVersionColumnName( getVersionColumnName() );
 		}
 		if ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {
 			delete.setComment( "delete " + getEntityName() );
 		}
 		return delete.toStatementString();
 	}
 
 	protected int dehydrate(
 			Serializable id,
 			Object[] fields,
 			boolean[] includeProperty,
 			boolean[][] includeColumns,
 			int j,
 			PreparedStatement st,
 			SessionImplementor session,
 			boolean isUpdate) throws HibernateException, SQLException {
 		return dehydrate( id, fields, null, includeProperty, includeColumns, j, st, session, 1, isUpdate );
 	}
 
 	/**
 	 * Marshall the fields of a persistent instance to a prepared statement
 	 */
 	protected int dehydrate(
 			final Serializable id,
 			final Object[] fields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final boolean[][] includeColumns,
 			final int j,
 			final PreparedStatement ps,
 			final SessionImplementor session,
 			int index,
 			boolean isUpdate) throws SQLException, HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Dehydrating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j )
 					&& !lobProperties.contains( i ) ) {
 				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
 				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
 			}
 		}
 
 		if ( !isUpdate ) {
 			index += dehydrateId( id, rowId, ps, session, index );
 		}
 
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
 				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
 			}
 		}
 
 		if ( isUpdate ) {
 			index += dehydrateId( id, rowId, ps, session, index );
 		}
 
 		return index;
 
 	}
 
 	private int dehydrateId(
 			final Serializable id,
 			final Object rowId,
 			final PreparedStatement ps,
 			final SessionImplementor session,
 			int index) throws SQLException {
 		if ( rowId != null ) {
 			ps.setObject( index, rowId );
 			return 1;
 		}
 		else if ( id != null ) {
 			getIdentifierType().nullSafeSet( ps, id, index, session );
 			return getIdentifierColumnSpan();
 		}
 		return 0;
 	}
 
 	/**
 	 * Unmarshall the fields of a persistent instance from a result set,
 	 * without resolving associations or collections. Question: should
 	 * this really be here, or should it be sent back to Loader?
 	 */
 	public Object[] hydrate(
 			final ResultSet rs,
 			final Serializable id,
 			final Object object,
 			final Loadable rootLoadable,
 			final String[][] suffixedPropertyColumns,
 			final boolean allProperties,
 			final SessionImplementor session) throws SQLException, HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Hydrating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		final AbstractEntityPersister rootPersister = (AbstractEntityPersister) rootLoadable;
 
 		final boolean hasDeferred = rootPersister.hasSequentialSelect();
 		PreparedStatement sequentialSelect = null;
 		ResultSet sequentialResultSet = null;
 		boolean sequentialSelectEmpty = false;
 		try {
 
 			if ( hasDeferred ) {
 				final String sql = rootPersister.getSequentialSelect( getEntityName() );
 				if ( sql != null ) {
 					//TODO: I am not so sure about the exception handling in this bit!
 					sequentialSelect = session
 							.getJdbcCoordinator()
 							.getStatementPreparer()
 							.prepareStatement( sql );
 					rootPersister.getIdentifierType().nullSafeSet( sequentialSelect, id, 1, session );
 					sequentialResultSet = session.getJdbcCoordinator().getResultSetReturn().extract( sequentialSelect );
 					if ( !sequentialResultSet.next() ) {
 						// TODO: Deal with the "optional" attribute in the <join> mapping;
 						// this code assumes that optional defaults to "true" because it
 						// doesn't actually seem to work in the fetch="join" code
 						//
 						// Note that actual proper handling of optional-ality here is actually
 						// more involved than this patch assumes.  Remember that we might have
 						// multiple <join/> mappings associated with a single entity.  Really
 						// a couple of things need to happen to properly handle optional here:
 						//  1) First and foremost, when handling multiple <join/>s, we really
 						//      should be using the entity root table as the driving table;
 						//      another option here would be to choose some non-optional joined
 						//      table to use as the driving table.  In all likelihood, just using
 						//      the root table is much simplier
 						//  2) Need to add the FK columns corresponding to each joined table
 						//      to the generated select list; these would then be used when
 						//      iterating the result set to determine whether all non-optional
 						//      data is present
 						// My initial thoughts on the best way to deal with this would be
 						// to introduce a new SequentialSelect abstraction that actually gets
 						// generated in the persisters (ok, SingleTable...) and utilized here.
 						// It would encapsulated all this required optional-ality checking...
 						sequentialSelectEmpty = true;
 					}
 				}
 			}
 
 			final String[] propNames = getPropertyNames();
 			final Type[] types = getPropertyTypes();
 			final Object[] values = new Object[types.length];
 			final boolean[] laziness = getPropertyLaziness();
 			final String[] propSubclassNames = getSubclassPropertySubclassNameClosure();
 
 			for ( int i = 0; i < types.length; i++ ) {
 				if ( !propertySelectable[i] ) {
-					values[i] = BackrefPropertyAccessor.UNKNOWN;
+					values[i] = PropertyAccessStrategyBackRefImpl.UNKNOWN;
 				}
 				else if ( allProperties || !laziness[i] ) {
 					//decide which ResultSet to get the property value from:
 					final boolean propertyIsDeferred = hasDeferred &&
 							rootPersister.isSubclassPropertyDeferred( propNames[i], propSubclassNames[i] );
 					if ( propertyIsDeferred && sequentialSelectEmpty ) {
 						values[i] = null;
 					}
 					else {
 						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
 						final String[] cols = propertyIsDeferred ?
 								propertyColumnAliases[i] :
 								suffixedPropertyColumns[i];
 						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );
 					}
 				}
 				else {
 					values[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 				}
 			}
 
 			if ( sequentialResultSet != null ) {
 				session.getJdbcCoordinator().getResourceRegistry().release( sequentialResultSet, sequentialSelect );
 			}
 
 			return values;
 
 		}
 		finally {
 			if ( sequentialSelect != null ) {
 				session.getJdbcCoordinator().getResourceRegistry().release( sequentialSelect );
 				session.getJdbcCoordinator().afterStatementExecution();
 			}
 		}
 	}
 
 	protected boolean useInsertSelectIdentity() {
 		return !useGetGeneratedKeys() && getFactory().getDialect().supportsInsertSelectIdentity();
 	}
 
 	protected boolean useGetGeneratedKeys() {
 		return getFactory().getSessionFactoryOptions().isGetGeneratedKeysEnabled();
 	}
 
 	protected String getSequentialSelect(String entityName) {
 		throw new UnsupportedOperationException( "no sequential selects" );
 	}
 
 	/**
 	 * Perform an SQL INSERT, and then retrieve a generated identifier.
 	 * <p/>
 	 * This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY,
 	 * select, etc).
 	 */
 	protected Serializable insert(
 			final Object[] fields,
 			final boolean[] notNull,
 			String sql,
 			final Object object,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Inserting entity: {0} (native id)", getEntityName() );
 			if ( isVersioned() ) {
 				LOG.tracev( "Version: {0}", Versioning.getVersion( fields, this ) );
 			}
 		}
 
 		Binder binder = new Binder() {
 			public void bindValues(PreparedStatement ps) throws SQLException {
 				dehydrate( null, fields, notNull, propertyColumnInsertable, 0, ps, session, false );
 			}
 
 			public Object getEntity() {
 				return object;
 			}
 		};
 
 		return identityDelegate.performInsert( sql, session, binder );
 	}
 
 	public String getIdentitySelectString() {
 		//TODO: cache this in an instvar
 		return getFactory().getDialect().getIdentitySelectString(
 				getTableName( 0 ),
 				getKeyColumns( 0 )[0],
 				getIdentifierType().sqlTypes( getFactory() )[0]
 		);
 	}
 
 	public String getSelectByUniqueKeyString(String propertyName) {
 		return new SimpleSelect( getFactory().getDialect() )
 				.setTableName( getTableName( 0 ) )
 				.addColumns( getKeyColumns( 0 ) )
 				.addCondition( getPropertyColumnNames( propertyName ), "=?" )
 				.toStatementString();
 	}
 
 	private BasicBatchKey inserBatchKey;
 
 	/**
 	 * Perform an SQL INSERT.
 	 * <p/>
 	 * This for is used for all non-root tables as well as the root table
 	 * in cases where the identifier value is known before the insert occurs.
 	 */
 	protected void insert(
 			final Serializable id,
 			final Object[] fields,
 			final boolean[] notNull,
 			final int j,
 			final String sql,
 			final Object object,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		//note: it is conceptually possible that a UserType could map null to
 		//	  a non-null value, so the following is arguable:
 		if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 			return;
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Inserting entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( j == 0 && isVersioned() ) {
 				LOG.tracev( "Version: {0}", Versioning.getVersion( fields, this ) );
 			}
 		}
 
 		// TODO : shouldn't inserts be Expectations.NONE?
 		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
 		// we can't batch joined inserts, *especially* not if it is an identity insert;
 		// nor can we batch statements where the expectation is based on an output param
 		final boolean useBatch = j == 0 && expectation.canBeBatched();
 		if ( useBatch && inserBatchKey == null ) {
 			inserBatchKey = new BasicBatchKey(
 					getEntityName() + "#INSERT",
 					expectation
 			);
 		}
 		final boolean callable = isInsertCallable( j );
 
 		try {
 			// Render the SQL query
 			final PreparedStatement insert;
 			if ( useBatch ) {
 				insert = session
 						.getJdbcCoordinator()
 						.getBatch( inserBatchKey )
 						.getBatchStatement( sql, callable );
 			}
 			else {
 				insert = session
 						.getJdbcCoordinator()
 						.getStatementPreparer()
 						.prepareStatement( sql, callable );
 			}
 
 			try {
 				int index = 1;
 				index += expectation.prepare( insert );
 
 				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
 				// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
 
 				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
 
 				if ( useBatch ) {
 					session.getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
 				}
 				else {
 					expectation.verifyOutcome(
 							session.getJdbcCoordinator()
 									.getResultSetReturn()
 									.executeUpdate( insert ), insert, -1
 					);
 				}
 
 			}
 			catch (SQLException e) {
 				if ( useBatch ) {
 					session.getJdbcCoordinator().abortBatch();
 				}
 				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					session.getJdbcCoordinator().getResourceRegistry().release( insert );
 					session.getJdbcCoordinator().afterStatementExecution();
 				}
 			}
 		}
 		catch (SQLException e) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not insert: " + MessageHelper.infoString( this ),
 					sql
 			);
 		}
 
 	}
 
 	/**
 	 * Perform an SQL UPDATE or SQL INSERT
 	 */
 	protected void updateOrInsert(
 			final Serializable id,
 			final Object[] fields,
 			final Object[] oldFields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final int j,
 			final Object oldVersion,
 			final Object object,
 			final String sql,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( !isInverseTable( j ) ) {
 
 			final boolean isRowToUpdate;
 			if ( isNullableTable( j ) && oldFields != null && isAllNull( oldFields, j ) ) {
 				//don't bother trying to update, we know there is no row there yet
 				isRowToUpdate = false;
 			}
 			else if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 				//if all fields are null, we might need to delete existing row
 				isRowToUpdate = true;
 				delete( id, oldVersion, j, object, getSQLDeleteStrings()[j], session, null );
 			}
 			else {
 				//there is probably a row there, so try to update
 				//if no rows were updated, we will find out
 				isRowToUpdate = update(
 						id,
 						fields,
 						oldFields,
 						rowId,
 						includeProperty,
 						j,
 						oldVersion,
 						object,
 						sql,
 						session
 				);
 			}
 
 			if ( !isRowToUpdate && !isAllNull( fields, j ) ) {
 				// assume that the row was not there since it previously had only null
 				// values, so do an INSERT instead
 				//TODO: does not respect dynamic-insert
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 
 		}
 
 	}
 
 	private BasicBatchKey updateBatchKey;
 
 	protected boolean update(
 			final Serializable id,
 			final Object[] fields,
 			final Object[] oldFields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final int j,
 			final Object oldVersion,
 			final Object object,
 			final String sql,
 			final SessionImplementor session) throws HibernateException {
 
 		final Expectation expectation = Expectations.appropriateExpectation( updateResultCheckStyles[j] );
 		final boolean useBatch = j == 0 && expectation.canBeBatched() && isBatchable(); //note: updates to joined tables can't be batched...
 		if ( useBatch && updateBatchKey == null ) {
 			updateBatchKey = new BasicBatchKey(
 					getEntityName() + "#UPDATE",
 					expectation
 			);
 		}
 		final boolean callable = isUpdateCallable( j );
 		final boolean useVersion = j == 0 && isVersioned();
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Updating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion ) {
 				LOG.tracev( "Existing version: {0} -> New version:{1}", oldVersion, fields[getVersionProperty()] );
 			}
 		}
 
 		try {
 			int index = 1; // starting index
 			final PreparedStatement update;
 			if ( useBatch ) {
 				update = session
 						.getJdbcCoordinator()
 						.getBatch( updateBatchKey )
 						.getBatchStatement( sql, callable );
 			}
 			else {
 				update = session
 						.getJdbcCoordinator()
 						.getStatementPreparer()
 						.prepareStatement( sql, callable );
 			}
 
 			try {
 				index += expectation.prepare( update );
 
 				//Now write the values of fields onto the prepared statement
 				index = dehydrate(
 						id,
 						fields,
 						rowId,
 						includeProperty,
 						propertyColumnUpdateable,
 						j,
 						update,
 						session,
 						index,
 						true
 				);
 
 				// Write any appropriate versioning conditional parameters
 				if ( useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
 					if ( checkVersion( includeProperty ) ) {
 						getVersionType().nullSafeSet( update, oldVersion, index, session );
 					}
 				}
 				else if ( isAllOrDirtyOptLocking() && oldFields != null ) {
 					boolean[] versionability = getPropertyVersionability(); //TODO: is this really necessary????
 					boolean[] includeOldField = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
 							? getPropertyUpdateability()
 							: includeProperty;
 					Type[] types = getPropertyTypes();
 					for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 						boolean include = includeOldField[i] &&
 								isPropertyOfTable( i, j ) &&
 								versionability[i]; //TODO: is this really necessary????
 						if ( include ) {
 							boolean[] settable = types[i].toColumnNullness( oldFields[i], getFactory() );
 							types[i].nullSafeSet(
 									update,
 									oldFields[i],
 									index,
 									settable,
 									session
 							);
 							index += ArrayHelper.countTrue( settable );
 						}
 					}
 				}
 
 				if ( useBatch ) {
 					session.getJdbcCoordinator().getBatch( updateBatchKey ).addToBatch();
 					return true;
 				}
 				else {
 					return check(
 							session.getJdbcCoordinator().getResultSetReturn().executeUpdate( update ),
 							id,
 							j,
 							expectation,
 							update
 					);
 				}
 
 			}
 			catch (SQLException e) {
 				if ( useBatch ) {
 					session.getJdbcCoordinator().abortBatch();
 				}
 				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					session.getJdbcCoordinator().getResourceRegistry().release( update );
 					session.getJdbcCoordinator().afterStatementExecution();
 				}
 			}
 
 		}
 		catch (SQLException e) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not update: " + MessageHelper.infoString( this, id, getFactory() ),
 					sql
 			);
 		}
 	}
 
 	private BasicBatchKey deleteBatchKey;
 
 	/**
 	 * Perform an SQL DELETE
 	 */
 	protected void delete(
 			final Serializable id,
 			final Object version,
 			final int j,
 			final Object object,
 			final String sql,
 			final SessionImplementor session,
 			final Object[] loadedState) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		final boolean useVersion = j == 0 && isVersioned();
 		final boolean callable = isDeleteCallable( j );
 		final Expectation expectation = Expectations.appropriateExpectation( deleteResultCheckStyles[j] );
 		final boolean useBatch = j == 0 && isBatchable() && expectation.canBeBatched();
 		if ( useBatch && deleteBatchKey == null ) {
 			deleteBatchKey = new BasicBatchKey(
 					getEntityName() + "#DELETE",
 					expectation
 			);
 		}
 
 		final boolean traceEnabled = LOG.isTraceEnabled();
 		if ( traceEnabled ) {
 			LOG.tracev( "Deleting entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion ) {
 				LOG.tracev( "Version: {0}", version );
 			}
 		}
 
 		if ( isTableCascadeDeleteEnabled( j ) ) {
 			if ( traceEnabled ) {
 				LOG.tracev( "Delete handled by foreign key constraint: {0}", getTableName( j ) );
 			}
 			return; //EARLY EXIT!
 		}
 
 		try {
 			//Render the SQL query
 			PreparedStatement delete;
 			int index = 1;
 			if ( useBatch ) {
 				delete = session
 						.getJdbcCoordinator()
 						.getBatch( deleteBatchKey )
 						.getBatchStatement( sql, callable );
 			}
 			else {
 				delete = session
 						.getJdbcCoordinator()
 						.getStatementPreparer()
 						.prepareStatement( sql, callable );
 			}
 
 			try {
 
 				index += expectation.prepare( delete );
 
 				// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
 				// the state at the time the delete was issued
 				getIdentifierType().nullSafeSet( delete, id, index, session );
 				index += getIdentifierColumnSpan();
 
 				// We should use the _current_ object state (ie. after any updates that occurred during flush)
 
 				if ( useVersion ) {
 					getVersionType().nullSafeSet( delete, version, index, session );
 				}
 				else if ( isAllOrDirtyOptLocking() && loadedState != null ) {
 					boolean[] versionability = getPropertyVersionability();
 					Type[] types = getPropertyTypes();
 					for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 						if ( isPropertyOfTable( i, j ) && versionability[i] ) {
 							// this property belongs to the table and it is not specifically
 							// excluded from optimistic locking by optimistic-lock="false"
 							boolean[] settable = types[i].toColumnNullness( loadedState[i], getFactory() );
 							types[i].nullSafeSet( delete, loadedState[i], index, settable, session );
 							index += ArrayHelper.countTrue( settable );
 						}
 					}
 				}
 
 				if ( useBatch ) {
 					session.getJdbcCoordinator().getBatch( deleteBatchKey ).addToBatch();
 				}
 				else {
 					check(
 							session.getJdbcCoordinator().getResultSetReturn().executeUpdate( delete ),
 							id,
 							j,
 							expectation,
 							delete
 					);
 				}
 
 			}
 			catch (SQLException sqle) {
 				if ( useBatch ) {
 					session.getJdbcCoordinator().abortBatch();
 				}
 				throw sqle;
 			}
 			finally {
 				if ( !useBatch ) {
 					session.getJdbcCoordinator().getResourceRegistry().release( delete );
 					session.getJdbcCoordinator().afterStatementExecution();
 				}
 			}
 
 		}
 		catch (SQLException sqle) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not delete: " +
 							MessageHelper.infoString( this, id, getFactory() ),
 					sql
 			);
 
 		}
 
 	}
 
 	private String[] getUpdateStrings(boolean byRowId, boolean lazy) {
 		if ( byRowId ) {
 			return lazy ? getSQLLazyUpdateByRowIdStrings() : getSQLUpdateByRowIdStrings();
 		}
 		else {
 			return lazy ? getSQLLazyUpdateStrings() : getSQLUpdateStrings();
 		}
 	}
 
 	/**
 	 * Update an object
 	 */
 	public void update(
 			final Serializable id,
 			final Object[] fields,
 			final int[] dirtyFields,
 			final boolean hasDirtyCollection,
 			final Object[] oldFields,
 			final Object oldVersion,
 			final Object object,
 			final Object rowId,
 			final SessionImplementor session) throws HibernateException {
 
 		// apply any pre-update in-memory value generation
 		if ( getEntityMetamodel().hasPreUpdateGeneratedValues() ) {
 			final InMemoryValueGenerationStrategy[] strategies = getEntityMetamodel().getInMemoryValueGenerationStrategies();
 			for ( int i = 0; i < strategies.length; i++ ) {
 				if ( strategies[i] != null && strategies[i].getGenerationTiming().includesUpdate() ) {
 					fields[i] = strategies[i].getValueGenerator().generateValue( (Session) session, object );
 					setPropertyValue( object, i, fields[i] );
 					// todo : probably best to add to dirtyFields if not-null
 				}
 			}
 		}
 
 		//note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update
 		//	  oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)
 
 		final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );
 		final int span = getTableSpan();
 
 		final boolean[] propsToUpdate;
 		final String[] updateStrings;
 		EntityEntry entry = session.getPersistenceContext().getEntry( object );
 
 		// Ensure that an immutable or non-modifiable entity is not being updated unless it is
 		// in the process of being deleted.
 		if ( entry == null && !isMutable() ) {
 			throw new IllegalStateException( "Updating immutable entity that is not in session yet!" );
 		}
 		if ( ( entityMetamodel.isDynamicUpdate() && dirtyFields != null ) ) {
 			// We need to generate the UPDATE SQL when dynamic-update="true"
 			propsToUpdate = getPropertiesToUpdate( dirtyFields, hasDirtyCollection );
 			// don't need to check laziness (dirty checking algorithm handles that)
 			updateStrings = new String[span];
 			for ( int j = 0; j < span; j++ ) {
 				updateStrings[j] = tableUpdateNeeded[j] ?
 						generateUpdateString( propsToUpdate, j, oldFields, j == 0 && rowId != null ) :
 						null;
 			}
 		}
 		else if ( !isModifiableEntity( entry ) ) {
 			// We need to generate UPDATE SQL when a non-modifiable entity (e.g., read-only or immutable)
 			// needs:
 			// - to have references to transient entities set to null before being deleted
 			// - to have version incremented do to a "dirty" association
 			// If dirtyFields == null, then that means that there are no dirty properties to
 			// to be updated; an empty array for the dirty fields needs to be passed to
 			// getPropertiesToUpdate() instead of null.
 			propsToUpdate = getPropertiesToUpdate(
 					( dirtyFields == null ? ArrayHelper.EMPTY_INT_ARRAY : dirtyFields ),
 					hasDirtyCollection
 			);
 			// don't need to check laziness (dirty checking algorithm handles that)
 			updateStrings = new String[span];
 			for ( int j = 0; j < span; j++ ) {
 				updateStrings[j] = tableUpdateNeeded[j] ?
 						generateUpdateString( propsToUpdate, j, oldFields, j == 0 && rowId != null ) :
 						null;
 			}
 		}
 		else {
 			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
 			updateStrings = getUpdateStrings(
 					rowId != null,
 					hasUninitializedLazyProperties( object )
 			);
 			propsToUpdate = getPropertyUpdateability( object );
 		}
 
 		for ( int j = 0; j < span; j++ ) {
 			// Now update only the tables with dirty properties (and the table with the version number)
 			if ( tableUpdateNeeded[j] ) {
 				updateOrInsert(
 						id,
 						fields,
 						oldFields,
 						j == 0 ? rowId : null,
 						propsToUpdate,
 						j,
 						oldVersion,
 						object,
 						updateStrings[j],
 						session
 				);
 			}
 		}
 	}
 
 	public Serializable insert(Object[] fields, Object object, SessionImplementor session)
 			throws HibernateException {
 		// apply any pre-insert in-memory value generation
 		preInsertInMemoryValueGeneration( fields, object, session );
 
 		final int span = getTableSpan();
 		final Serializable id;
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			id = insert( fields, notNull, generateInsertString( true, notNull ), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			id = insert( fields, getPropertyInsertability(), getSQLIdentityInsertString(), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 		return id;
 	}
 
 	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) {
 		// apply any pre-insert in-memory value generation
 		preInsertInMemoryValueGeneration( fields, object, session );
 
 		final int span = getTableSpan();
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 	}
 
 	private void preInsertInMemoryValueGeneration(Object[] fields, Object object, SessionImplementor session) {
 		if ( getEntityMetamodel().hasPreInsertGeneratedValues() ) {
 			final InMemoryValueGenerationStrategy[] strategies = getEntityMetamodel().getInMemoryValueGenerationStrategies();
 			for ( int i = 0; i < strategies.length; i++ ) {
 				if ( strategies[i] != null && strategies[i].getGenerationTiming().includesInsert() ) {
 					fields[i] = strategies[i].getValueGenerator().generateValue( (Session) session, object );
 					setPropertyValue( object, i, fields[i] );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Delete an object
 	 */
 	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
 			throws HibernateException {
 		final int span = getTableSpan();
 		boolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && isAllOrDirtyOptLocking();
 		Object[] loadedState = null;
 		if ( isImpliedOptimisticLocking ) {
 			// need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense);
 			// first we need to locate the "loaded" state
 			//
 			// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
 			final EntityKey key = session.generateEntityKey( id, this );
 			Object entity = session.getPersistenceContext().getEntity( key );
 			if ( entity != null ) {
 				EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 				loadedState = entry.getLoadedState();
 			}
 		}
 
 		final String[] deleteStrings;
 		if ( isImpliedOptimisticLocking && loadedState != null ) {
 			// we need to utilize dynamic delete statements
 			deleteStrings = generateSQLDeletStrings( loadedState );
 		}
 		else {
 			// otherwise, utilize the static delete statements
 			deleteStrings = getSQLDeleteStrings();
 		}
 
 		for ( int j = span - 1; j >= 0; j-- ) {
 			delete( id, version, j, object, deleteStrings[j], session, loadedState );
 		}
 
 	}
 
 	private boolean isAllOrDirtyOptLocking() {
 		return entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.DIRTY
 				|| entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL;
 	}
 
 	private String[] generateSQLDeletStrings(Object[] loadedState) {
 		int span = getTableSpan();
 		String[] deleteStrings = new String[span];
 		for ( int j = span - 1; j >= 0; j-- ) {
 			Delete delete = new Delete()
 					.setTableName( getTableName( j ) )
 					.addPrimaryKeyColumns( getKeyColumns( j ) );
 			if ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {
 				delete.setComment( "delete " + getEntityName() + " [" + j + "]" );
 			}
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				if ( isPropertyOfTable( i, j ) && versionability[i] ) {
 					// this property belongs to the table and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( loadedState[i], getFactory() );
 					for ( int k = 0; k < propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							delete.addWhereFragment( propertyColumnNames[k] + " = ?" );
 						}
 						else {
 							delete.addWhereFragment( propertyColumnNames[k] + " is null" );
 						}
 					}
 				}
 			}
 			deleteStrings[j] = delete.toStatementString();
 		}
 		return deleteStrings;
 	}
 
 	protected void logStaticSQL() {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Static SQL for entity: %s", getEntityName() );
 			if ( sqlLazySelectString != null ) {
 				LOG.debugf( " Lazy select: %s", sqlLazySelectString );
 			}
 			if ( sqlVersionSelectString != null ) {
 				LOG.debugf( " Version select: %s", sqlVersionSelectString );
 			}
 			if ( sqlSnapshotSelectString != null ) {
 				LOG.debugf( " Snapshot select: %s", sqlSnapshotSelectString );
 			}
 			for ( int j = 0; j < getTableSpan(); j++ ) {
 				LOG.debugf( " Insert %s: %s", j, getSQLInsertStrings()[j] );
 				LOG.debugf( " Update %s: %s", j, getSQLUpdateStrings()[j] );
 				LOG.debugf( " Delete %s: %s", j, getSQLDeleteStrings()[j] );
 			}
 			if ( sqlIdentityInsertString != null ) {
 				LOG.debugf( " Identity insert: %s", sqlIdentityInsertString );
 			}
 			if ( sqlUpdateByRowIdString != null ) {
 				LOG.debugf( " Update by row id (all fields): %s", sqlUpdateByRowIdString );
 			}
 			if ( sqlLazyUpdateByRowIdString != null ) {
 				LOG.debugf( " Update by row id (non-lazy fields): %s", sqlLazyUpdateByRowIdString );
 			}
 			if ( sqlInsertGeneratedValuesSelectString != null ) {
 				LOG.debugf( " Insert-generated property select: %s", sqlInsertGeneratedValuesSelectString );
 			}
 			if ( sqlUpdateGeneratedValuesSelectString != null ) {
 				LOG.debugf( " Update-generated property select: %s", sqlUpdateGeneratedValuesSelectString );
 			}
 		}
 	}
 
 	@Override
 	public String filterFragment(String alias, Map enabledFilters) throws MappingException {
 		final StringBuilder sessionFilterFragment = new StringBuilder();
 		filterHelper.render( sessionFilterFragment, getFilterAliasGenerator( alias ), enabledFilters );
 		return sessionFilterFragment.append( filterFragment( alias ) ).toString();
 	}
 
 	@Override
 	public String filterFragment(String alias, Map enabledFilters, Set<String> treatAsDeclarations) {
 		final StringBuilder sessionFilterFragment = new StringBuilder();
 		filterHelper.render( sessionFilterFragment, getFilterAliasGenerator( alias ), enabledFilters );
 		return sessionFilterFragment.append( filterFragment( alias, treatAsDeclarations ) ).toString();
 	}
 
 	public String generateFilterConditionAlias(String rootAlias) {
 		return rootAlias;
 	}
 
 	public String oneToManyFilterFragment(String alias) throws MappingException {
 		return "";
 	}
 
 	@Override
 	public String oneToManyFilterFragment(String alias, Set<String> treatAsDeclarations) {
 		return oneToManyFilterFragment( alias );
 	}
 
 	@Override
 	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		// NOTE : Not calling createJoin here is just a performance optimization
 		return getSubclassTableSpan() == 1
 				? ""
 				: createJoin(
 				alias,
 				innerJoin,
 				includeSubclasses,
 				Collections.<String>emptySet()
 		).toFromFragmentString();
 	}
 
 	@Override
 	public String fromJoinFragment(
 			String alias,
 			boolean innerJoin,
 			boolean includeSubclasses,
 			Set<String> treatAsDeclarations) {
 		// NOTE : Not calling createJoin here is just a performance optimization
 		return getSubclassTableSpan() == 1
 				? ""
 				: createJoin( alias, innerJoin, includeSubclasses, treatAsDeclarations ).toFromFragmentString();
 	}
 
 	@Override
 	public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		// NOTE : Not calling createJoin here is just a performance optimization
 		return getSubclassTableSpan() == 1
 				? ""
 				: createJoin(
 				alias,
 				innerJoin,
 				includeSubclasses,
 				Collections.<String>emptySet()
 		).toWhereFragmentString();
 	}
 
 	@Override
 	public String whereJoinFragment(
 			String alias,
 			boolean innerJoin,
 			boolean includeSubclasses,
 			Set<String> treatAsDeclarations) {
 		// NOTE : Not calling createJoin here is just a performance optimization
 		return getSubclassTableSpan() == 1
 				? ""
 				: createJoin( alias, innerJoin, includeSubclasses, treatAsDeclarations ).toWhereFragmentString();
 	}
 
 	protected boolean isSubclassTableLazy(int j) {
 		return false;
 	}
 
 	protected JoinFragment createJoin(
 			String name,
 			boolean innerJoin,
 			boolean includeSubclasses,
 			Set<String> treatAsDeclarations) {
 		// IMPL NOTE : all joins join to the pk of the driving table
 		final String[] idCols = StringHelper.qualify( name, getIdentifierColumnNames() );
 		final JoinFragment join = getFactory().getDialect().createOuterJoinFragment();
 		final int tableSpan = getSubclassTableSpan();
 		// IMPL NOTE : notice that we skip the first table; it is the driving table!
 		for ( int j = 1; j < tableSpan; j++ ) {
 			final JoinType joinType = determineSubclassTableJoinType(
 					j,
 					innerJoin,
 					includeSubclasses,
 					treatAsDeclarations
 			);
 
 			if ( joinType != null && joinType != JoinType.NONE ) {
 				join.addJoin(
 						getSubclassTableName( j ),
 						generateTableAlias( name, j ),
 						idCols,
 						getSubclassTableKeyColumns( j ),
 						joinType
 				);
 			}
 		}
 		return join;
 	}
 
 	protected JoinType determineSubclassTableJoinType(
 			int subclassTableNumber,
 			boolean canInnerJoin,
 			boolean includeSubclasses,
 			Set<String> treatAsDeclarations) {
 
 		if ( isClassOrSuperclassTable( subclassTableNumber ) ) {
 			final boolean shouldInnerJoin = canInnerJoin
 					&& !isInverseTable( subclassTableNumber )
 					&& !isNullableTable( subclassTableNumber );
 			// the table is either this persister's driving table or (one of) its super class persister's driving
 			// tables which can be inner joined as long as the `shouldInnerJoin` condition resolves to true
 			return shouldInnerJoin ? JoinType.INNER_JOIN : JoinType.LEFT_OUTER_JOIN;
 		}
 
 		// otherwise we have a subclass table and need to look a little deeper...
 
 		// IMPL NOTE : By default includeSubclasses indicates that all subclasses should be joined and that each
 		// subclass ought to be joined by outer-join.  However, TREAT-AS always requires that an inner-join be used
 		// so we give TREAT-AS higher precedence...
 
 		if ( isSubclassTableIndicatedByTreatAsDeclarations( subclassTableNumber, treatAsDeclarations ) ) {
 			return JoinType.INNER_JOIN;
 		}
 
 		if ( includeSubclasses
 				&& !isSubclassTableSequentialSelect( subclassTableNumber )
 				&& !isSubclassTableLazy( subclassTableNumber ) ) {
 			return JoinType.LEFT_OUTER_JOIN;
 		}
 
 		return JoinType.NONE;
 	}
 
 	protected boolean isSubclassTableIndicatedByTreatAsDeclarations(
 			int subclassTableNumber,
 			Set<String> treatAsDeclarations) {
 		return false;
 	}
 
 
 	protected JoinFragment createJoin(int[] tableNumbers, String drivingAlias) {
 		final String[] keyCols = StringHelper.qualify( drivingAlias, getSubclassTableKeyColumns( tableNumbers[0] ) );
 		final JoinFragment jf = getFactory().getDialect().createOuterJoinFragment();
 		// IMPL NOTE : notice that we skip the first table; it is the driving table!
 		for ( int i = 1; i < tableNumbers.length; i++ ) {
 			final int j = tableNumbers[i];
 			jf.addJoin(
 					getSubclassTableName( j ),
 					generateTableAlias( getRootAlias(), j ),
 					keyCols,
 					getSubclassTableKeyColumns( j ),
 					isInverseSubclassTable( j ) || isNullableSubclassTable( j )
 							? JoinType.LEFT_OUTER_JOIN
 							: JoinType.INNER_JOIN
 			);
 		}
 		return jf;
 	}
 
 	protected SelectFragment createSelect(
 			final int[] subclassColumnNumbers,
 			final int[] subclassFormulaNumbers) {
 
 		SelectFragment selectFragment = new SelectFragment();
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < subclassColumnNumbers.length; i++ ) {
 			int columnNumber = subclassColumnNumbers[i];
 			if ( subclassColumnSelectableClosure[columnNumber] ) {
 				final String subalias = generateTableAlias( getRootAlias(), columnTableNumbers[columnNumber] );
 				selectFragment.addColumnTemplate(
 						subalias,
 						columnReaderTemplates[columnNumber],
 						columnAliases[columnNumber]
 				);
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < subclassFormulaNumbers.length; i++ ) {
 			int formulaNumber = subclassFormulaNumbers[i];
 			final String subalias = generateTableAlias( getRootAlias(), formulaTableNumbers[formulaNumber] );
 			selectFragment.addFormula( subalias, formulaTemplates[formulaNumber], formulaAliases[formulaNumber] );
 		}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/BasicPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/BasicPropertyAccessor.java
deleted file mode 100644
index 115a65bd67..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/BasicPropertyAccessor.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-
-import java.beans.Introspector;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.PropertyAccessException;
-import org.hibernate.PropertyNotFoundException;
-import org.hibernate.PropertySetterAccessException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.internal.CoreLogging;
-import org.hibernate.internal.CoreMessageLogger;
-
-/**
- * Accesses property values via a get/set pair, which may be nonpublic.
- * The default (and recommended strategy).
- *
- * @author Gavin King
- */
-public class BasicPropertyAccessor implements PropertyAccessor {
-	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( BasicPropertyAccessor.class );
-
-	public static final class BasicSetter implements Setter {
-		private Class clazz;
-		private final transient Method method;
-		private final String propertyName;
-
-		private BasicSetter(Class clazz, Method method, String propertyName) {
-			this.clazz = clazz;
-			this.method = method;
-			this.propertyName = propertyName;
-		}
-
-		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor factory)
-				throws HibernateException {
-			try {
-				method.invoke( target, value );
-			}
-			catch (NullPointerException npe) {
-				if ( value == null && method.getParameterTypes()[0].isPrimitive() ) {
-					throw new PropertyAccessException(
-							npe,
-							"Null value was assigned to a property of primitive type",
-							true,
-							clazz,
-							propertyName
-					);
-				}
-				else {
-					throw new PropertyAccessException(
-							npe,
-							"NullPointerException occurred while calling",
-							true,
-							clazz,
-							propertyName
-					);
-				}
-			}
-			catch (InvocationTargetException ite) {
-				throw new PropertyAccessException(
-						ite,
-						"Exception occurred inside",
-						true,
-						clazz,
-						propertyName
-				);
-			}
-			catch (IllegalAccessException iae) {
-				throw new PropertyAccessException(
-						iae,
-						"IllegalAccessException occurred while calling",
-						true,
-						clazz,
-						propertyName
-				);
-				//cannot occur
-			}
-			catch (IllegalArgumentException iae) {
-				if ( value == null && method.getParameterTypes()[0].isPrimitive() ) {
-					throw new PropertyAccessException(
-							iae,
-							"Null value was assigned to a property of primitive type",
-							true,
-							clazz,
-							propertyName
-					);
-				}
-				else {
-					final Class expectedType = method.getParameterTypes()[0];
-					LOG.illegalPropertySetterArgument( clazz.getName(), propertyName );
-					LOG.expectedType( expectedType.getName(), value == null ? null : value.getClass().getName() );
-					throw new PropertySetterAccessException(
-							iae,
-							clazz,
-							propertyName,
-							expectedType,
-							target,
-							value
-					);
-				}
-			}
-		}
-
-		@Override
-		public Method getMethod() {
-			return method;
-		}
-
-		@Override
-		public String getMethodName() {
-			return method.getName();
-		}
-
-		Object readResolve() {
-			return createSetter( clazz, propertyName );
-		}
-
-		@Override
-		public String toString() {
-			return "BasicSetter(" + clazz.getName() + '.' + propertyName + ')';
-		}
-	}
-
-	public static final class BasicGetter implements Getter {
-		private Class clazz;
-		private final transient Method method;
-		private final String propertyName;
-
-		private BasicGetter(Class clazz, Method method, String propertyName) {
-			this.clazz = clazz;
-			this.method = method;
-			this.propertyName = propertyName;
-		}
-
-		@Override
-		public Object get(Object target) throws HibernateException {
-			try {
-				return method.invoke( target, (Object[]) null );
-			}
-			catch (InvocationTargetException ite) {
-				throw new PropertyAccessException(
-						ite,
-						"Exception occurred inside",
-						false,
-						clazz,
-						propertyName
-				);
-			}
-			catch (IllegalAccessException iae) {
-				throw new PropertyAccessException(
-						iae,
-						"IllegalAccessException occurred while calling",
-						false,
-						clazz,
-						propertyName
-				);
-				//cannot occur
-			}
-			catch (IllegalArgumentException iae) {
-				LOG.illegalPropertyGetterArgument( clazz.getName(), propertyName );
-				throw new PropertyAccessException(
-						iae,
-						"IllegalArgumentException occurred calling",
-						false,
-						clazz,
-						propertyName
-				);
-			}
-		}
-
-		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
-			return get( target );
-		}
-
-		@Override
-		public Class getReturnType() {
-			return method.getReturnType();
-		}
-
-		@Override
-		public Member getMember() {
-			return method;
-		}
-
-		@Override
-		public Method getMethod() {
-			return method;
-		}
-
-		@Override
-		public String getMethodName() {
-			return method.getName();
-		}
-
-		@Override
-		public String toString() {
-			return "BasicGetter(" + clazz.getName() + '.' + propertyName + ')';
-		}
-
-		Object readResolve() {
-			return createGetter( clazz, propertyName );
-		}
-	}
-
-
-	@Override
-	public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return createSetter( theClass, propertyName );
-	}
-
-	private static Setter createSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		BasicSetter result = getSetterOrNull( theClass, propertyName );
-		if ( result == null ) {
-			throw new PropertyNotFoundException(
-					"Could not find a setter for property " +
-							propertyName +
-							" in class " +
-							theClass.getName()
-			);
-		}
-		return result;
-	}
-
-	private static BasicSetter getSetterOrNull(Class theClass, String propertyName) {
-		if ( theClass == Object.class || theClass == null ) {
-			return null;
-		}
-
-		Method method = setterMethod( theClass, propertyName );
-
-		if ( method != null ) {
-			method.setAccessible( true );
-			return new BasicSetter( theClass, method, propertyName );
-		}
-		else {
-			BasicSetter setter = getSetterOrNull( theClass.getSuperclass(), propertyName );
-			if ( setter == null ) {
-				Class[] interfaces = theClass.getInterfaces();
-				for ( int i = 0; setter == null && i < interfaces.length; i++ ) {
-					setter = getSetterOrNull( interfaces[i], propertyName );
-				}
-			}
-			return setter;
-		}
-
-	}
-
-	private static Method setterMethod(Class theClass, String propertyName) {
-		BasicGetter getter = getGetterOrNull( theClass, propertyName );
-		Class returnType = ( getter == null ) ? null : getter.getReturnType();
-
-		Method[] methods = theClass.getDeclaredMethods();
-		Method potentialSetter = null;
-		for ( Method method : methods ) {
-			final String methodName = method.getName();
-			if ( method.getParameterTypes().length == 1 && methodName.startsWith( "set" ) ) {
-				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
-				String testOldMethod = methodName.substring( 3 );
-				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
-					potentialSetter = method;
-					if ( returnType == null || method.getParameterTypes()[0].equals( returnType ) ) {
-						return potentialSetter;
-					}
-				}
-			}
-		}
-		return potentialSetter;
-	}
-
-	@Override
-	public Getter getGetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return createGetter( theClass, propertyName );
-	}
-
-	public static Getter createGetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		BasicGetter result = getGetterOrNull( theClass, propertyName );
-		if ( result == null ) {
-			throw new PropertyNotFoundException(
-					"Could not find a getter for " +
-							propertyName +
-							" in class " +
-							theClass.getName()
-			);
-		}
-		return result;
-	}
-
-	private static BasicGetter getGetterOrNull(Class theClass, String propertyName) {
-		if ( theClass == Object.class || theClass == null ) {
-			return null;
-		}
-
-		Method method = getterMethod( theClass, propertyName );
-
-		if ( method != null ) {
-			method.setAccessible( true );
-			return new BasicGetter( theClass, method, propertyName );
-		}
-		else {
-			BasicGetter getter = getGetterOrNull( theClass.getSuperclass(), propertyName );
-			if ( getter == null ) {
-				Class[] interfaces = theClass.getInterfaces();
-				for ( int i = 0; getter == null && i < interfaces.length; i++ ) {
-					getter = getGetterOrNull( interfaces[i], propertyName );
-				}
-			}
-			return getter;
-		}
-	}
-
-	private static Method getterMethod(Class theClass, String propertyName) {
-		Method[] methods = theClass.getDeclaredMethods();
-		for ( Method method : methods ) {
-			// if the method has parameters, skip it
-			if ( method.getParameterTypes().length != 0 ) {
-				continue;
-			}
-			// if the method is a "bridge", skip it
-			if ( method.isBridge() ) {
-				continue;
-			}
-
-			final String methodName = method.getName();
-
-			// try "get"
-			if ( methodName.startsWith( "get" ) ) {
-				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
-				String testOldMethod = methodName.substring( 3 );
-				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
-					return method;
-				}
-			}
-
-			// if not "get", then try "is"
-			if ( methodName.startsWith( "is" ) ) {
-				String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) );
-				String testOldMethod = methodName.substring( 2 );
-				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
-					return method;
-				}
-			}
-		}
-
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/ChainedPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/ChainedPropertyAccessor.java
deleted file mode 100644
index e884691a46..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/ChainedPropertyAccessor.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-
-import org.hibernate.PropertyNotFoundException;
-
-/**
- * @author max
- */
-public class ChainedPropertyAccessor implements PropertyAccessor {
-
-	final PropertyAccessor[] chain;
-
-	public ChainedPropertyAccessor(PropertyAccessor[] chain) {
-		this.chain = chain;
-	}
-
-	public Getter getGetter(Class theClass, String propertyName)
-			throws PropertyNotFoundException {
-		Getter result = null;
-		for ( PropertyAccessor candidate : chain ) {
-			try {
-				result = candidate.getGetter( theClass, propertyName );
-				return result;
-			}
-			catch (PropertyNotFoundException pnfe) {
-				// ignore
-			}
-		}
-		throw new PropertyNotFoundException( "Could not find getter for " + propertyName + " on " + theClass );
-	}
-
-	public Setter getSetter(Class theClass, String propertyName)
-			throws PropertyNotFoundException {
-		Setter result = null;
-		for ( PropertyAccessor candidate : chain ) {
-			try {
-				result = candidate.getSetter( theClass, propertyName );
-				return result;
-			}
-			catch (PropertyNotFoundException pnfe) {
-				// ignore
-			}
-		}
-		throw new PropertyNotFoundException( "Could not find setter for " + propertyName + " on " + theClass );
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/DirectPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/DirectPropertyAccessor.java
deleted file mode 100644
index af01970925..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/DirectPropertyAccessor.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.PropertyAccessException;
-import org.hibernate.PropertyNotFoundException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-
-/**
- * Accesses fields directly.
- * @author Gavin King
- */
-public class DirectPropertyAccessor implements PropertyAccessor {
-
-	public static final class DirectGetter implements Getter {
-		private final transient Field field;
-		private final Class clazz;
-		private final String name;
-
-		DirectGetter(Field field, Class clazz, String name) {
-			this.field = field;
-			this.clazz = clazz;
-			this.name = name;
-		}
-
-		@Override
-		public Object get(Object target) throws HibernateException {
-			try {
-				return field.get(target);
-			}
-			catch (Exception e) {
-				throw new PropertyAccessException(e, "could not get a field value by reflection", false, clazz, name);
-			}
-		}
-
-		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
-			return get( target );
-		}
-
-		@Override
-		public Member getMember() {
-			return field;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Class getReturnType() {
-			return field.getType();
-		}
-
-		Object readResolve() {
-			return new DirectGetter( getField(clazz, name), clazz, name );
-		}
-
-		@Override
-		public String toString() {
-			return "DirectGetter(" + clazz.getName() + '.' + name + ')';
-		}
-	}
-
-	public static final class DirectSetter implements Setter {
-		private final transient Field field;
-		private final Class clazz;
-		private final String name;
-		DirectSetter(Field field, Class clazz, String name) {
-			this.field = field;
-			this.clazz = clazz;
-			this.name = name;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor factory) throws HibernateException {
-			try {
-				field.set(target, value);
-			}
-			catch (Exception e) {
-				if(value == null && field.getType().isPrimitive()) {
-					throw new PropertyAccessException(
-							e, 
-							"Null value was assigned to a property of primitive type", 
-							true, 
-							clazz, 
-							name
-						);					
-				}
-				else {
-					throw new PropertyAccessException(e, "could not set a field value by reflection", true, clazz, name);
-				}
-			}
-		}
-
-		@Override
-		public String toString() {
-			return "DirectSetter(" + clazz.getName() + '.' + name + ')';
-		}
-		
-		Object readResolve() {
-			return new DirectSetter( getField(clazz, name), clazz, name );
-		}
-	}
-
-	private static Field getField(Class clazz, String name) throws PropertyNotFoundException {
-		if ( clazz==null || clazz==Object.class ) {
-			throw new PropertyNotFoundException("field not found: " + name); 
-		}
-		Field field;
-		try {
-			field = clazz.getDeclaredField(name);
-		}
-		catch (NoSuchFieldException nsfe) {
-			field = getField( clazz, clazz.getSuperclass(), name );
-		}
-		field.setAccessible(true);
-		return field;
-	}
-
-	private static Field getField(Class root, Class clazz, String name) throws PropertyNotFoundException {
-		if ( clazz==null || clazz==Object.class ) {
-			throw new PropertyNotFoundException("field [" + name + "] not found on " + root.getName()); 
-		}
-		Field field;
-		try {
-			field = clazz.getDeclaredField(name);
-		}
-		catch (NoSuchFieldException nsfe) {
-			field = getField( root, clazz.getSuperclass(), name );
-		}
-		field.setAccessible(true);
-		return field;
-	}
-
-	@Override
-	public Getter getGetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return new DirectGetter( getField(theClass, propertyName), theClass, propertyName );
-	}
-
-	@Override
-	public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return new DirectSetter( getField(theClass, propertyName), theClass, propertyName );
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/EmbeddedPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/EmbeddedPropertyAccessor.java
deleted file mode 100755
index 92fbe85590..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/EmbeddedPropertyAccessor.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.PropertyNotFoundException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-
-/**
- * @author Gavin King
- */
-public class EmbeddedPropertyAccessor implements PropertyAccessor {
-
-	public static final class EmbeddedGetter implements Getter {
-		private final Class clazz;
-		
-		EmbeddedGetter(Class clazz) {
-			this.clazz = clazz;
-		}
-
-		@Override
-		public Object get(Object target) throws HibernateException {
-			return target;
-		}
-
-		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
-			return get( target );
-		}
-
-		@Override
-		public Member getMember() {
-			return null;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Class getReturnType() {
-			return clazz;
-		}
-
-		@Override
-		public String toString() {
-			return "EmbeddedGetter(" + clazz.getName() + ')';
-		}
-	}
-
-	public static final class EmbeddedSetter implements Setter {
-		private final Class clazz;
-		
-		EmbeddedSetter(Class clazz) {
-			this.clazz = clazz;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor factory) {
-		}
-
-		@Override
-		public String toString() {
-			return "EmbeddedSetter(" + clazz.getName() + ')';
-		}
-	}
-
-	@Override
-	public Getter getGetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return new EmbeddedGetter(theClass);
-	}
-
-	@Override
-	public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
-		return new EmbeddedSetter(theClass);
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/IndexPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/IndexPropertyAccessor.java
deleted file mode 100755
index cce7a78ca5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/IndexPropertyAccessor.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-
-/**
- * Represents a "back-reference" to the index of a collection.
- *
- * @author Gavin King
- */
-public class IndexPropertyAccessor implements PropertyAccessor {
-	private final String propertyName;
-	private final String entityName;
-
-	/**
-	 * Constructs a new instance of IndexPropertyAccessor.
-	 *
-	 * @param collectionRole The collection role which this back ref references.
-	 * @param entityName The name of the entity owning the collection.
-	 */
-	public IndexPropertyAccessor(String collectionRole, String entityName) {
-		this.propertyName = collectionRole.substring( entityName.length()+1 );
-		this.entityName = entityName;
-	}
-
-	@Override
-	public Setter getSetter(Class theClass, String propertyName) {
-		return new IndexSetter();
-	}
-
-	@Override
-	public Getter getGetter(Class theClass, String propertyName) {
-		return new IndexGetter();
-	}
-
-
-	/**
-	 * The Setter implementation for index backrefs.
-	 */
-	public static final class IndexSetter implements Setter {
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor factory) {
-			// do nothing...
-		}
-	}
-
-
-	/**
-	 * The Getter implementation for index backrefs.
-	 */
-	public class IndexGetter implements Getter {
-		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) throws HibernateException {
-			if ( session == null ) {
-				return BackrefPropertyAccessor.UNKNOWN;
-			}
-			else {
-				return session.getPersistenceContext().getIndexInOwner( entityName, propertyName, target, mergeMap );
-			}
-		}
-
-		@Override
-		public Object get(Object target)  {
-			return BackrefPropertyAccessor.UNKNOWN;
-		}
-
-		@Override
-		public Member getMember() {
-			return null;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Class getReturnType() {
-			return Object.class;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/MapAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/MapAccessor.java
deleted file mode 100644
index 945002b778..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/MapAccessor.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.PropertyNotFoundException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-
-/**
- * @author Gavin King
- */
-public class MapAccessor implements PropertyAccessor {
-	@Override
-	public Getter getGetter(Class theClass, String propertyName)
-		throws PropertyNotFoundException {
-		return new MapGetter(propertyName);
-	}
-
-	@Override
-	public Setter getSetter(Class theClass, String propertyName)
-		throws PropertyNotFoundException {
-		return new MapSetter(propertyName);
-	}
-
-	public static final class MapSetter implements Setter {
-		private String name;
-
-		MapSetter(String name) {
-			this.name = name;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		@SuppressWarnings("unchecked")
-		public void set(Object target, Object value, SessionFactoryImplementor factory)
-			throws HibernateException {
-			( (Map) target ).put( name, value );
-		}
-
-	}
-
-	public static final class MapGetter implements Getter {
-		private String name;
-
-		MapGetter(String name) {
-			this.name = name;
-		}
-
-		@Override
-		public Member getMember() {
-			return null;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Object get(Object target) throws HibernateException {
-			return ( (Map) target ).get(name);
-		}
-
-		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
-			return get( target );
-		}
-
-		@Override
-		public Class getReturnType() {
-			return Object.class;
-		}
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/NoopAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/NoopAccessor.java
deleted file mode 100755
index 4c61cdc916..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/NoopAccessor.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.hibernate.HibernateException;
-import org.hibernate.PropertyNotFoundException;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.engine.spi.SessionImplementor;
-
-/**
- * Used to declare properties not represented at the pojo level
- * 
- * @author Michael Bartmann
- */
-public class NoopAccessor implements PropertyAccessor {
-	@Override
-	public Getter getGetter(Class arg0, String arg1) throws PropertyNotFoundException {
-		return new NoopGetter();
-	}
-
-	@Override
-	public Setter getSetter(Class arg0, String arg1) throws PropertyNotFoundException {
-		return new NoopSetter();
-	}
-
-	/**
-	 * A Getter which will always return null. It should not be called anyway.
-	 */
-	private static class NoopGetter implements Getter {
-		/**
-		 * {@inheritDoc}
-		 * <p/>
-		 * Here we always return <tt>null</tt>
-		 */
-		@Override
-		public Object get(Object target) throws HibernateException {
-			return null;
-		}
-
-		@Override
-		public Object getForInsert(Object target, Map map, SessionImplementor arg1)
-				throws HibernateException {
-			return null;
-		}
-
-		@Override
-		public Class getReturnType() {
-			return Object.class;
-		}
-
-		@Override
-		public Member getMember() {
-			return null;
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-	}
-
-	/**
-	 * A Setter which will just do nothing.
-	 */
-	private static class NoopSetter implements Setter {
-		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor arg2) {
-			// nothing to do
-		}
-
-		@Override
-		public String getMethodName() {
-			return null;
-		}
-
-		@Override
-		public Method getMethod() {
-			return null;
-		}
-
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessor.java
deleted file mode 100644
index aaccfaf3cb..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessor.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-import org.hibernate.PropertyNotFoundException;
-
-/**
- * Abstracts the notion of a "property". Defines a strategy for accessing the
- * value of an attribute.
- *
- * @author Gavin King
- */
-public interface PropertyAccessor {
-	/**
-	 * Create a "getter" for the named attribute
-	 *
-	 * @param theClass The class on which the property is defined.
-	 * @param propertyName The name of the property.
-	 *
-	 * @return An appropriate getter.
-	 *
-	 * @throws PropertyNotFoundException Indicates a problem interpretting the propertyName
-	 */
-	public Getter getGetter(Class theClass, String propertyName) throws PropertyNotFoundException;
-
-	/**
-	 * Create a "setter" for the named attribute
-	 *
-	 * @param theClass The class on which the property is defined.
-	 * @param propertyName The name of the property.
-	 *
-	 * @return An appropriate setter
-	 *
-	 * @throws PropertyNotFoundException Indicates a problem interpretting the propertyName
-	 */
-	public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException;
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java b/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java
deleted file mode 100644
index 31d592f569..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.property;
-
-import java.util.Map;
-
-import org.hibernate.EntityMode;
-import org.hibernate.MappingException;
-import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.mapping.Property;
-
-/**
- * A factory for building/retrieving PropertyAccessor instances.
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public final class PropertyAccessorFactory {
-	private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();
-	private static final PropertyAccessor DIRECT_PROPERTY_ACCESSOR = new DirectPropertyAccessor();
-	private static final PropertyAccessor MAP_ACCESSOR = new MapAccessor();
-	private static final PropertyAccessor NOOP_ACCESSOR = new NoopAccessor();
-	private static final PropertyAccessor EMBEDDED_PROPERTY_ACCESSOR = new EmbeddedPropertyAccessor();
-
-	//TODO: ideally we need the construction of PropertyAccessor to take the following:
-	//      1) EntityMode
-	//      2) EntityMode-specific data (i.e., the classname for pojo entities)
-	//      3) Property-specific data based on the EntityMode (i.e., property-name or dom4j-node-name)
-	// The easiest way, with the introduction of the new runtime-metamodel classes, would be the
-	// the following predicates:
-	//      1) PropertyAccessorFactory.getPropertyAccessor() takes references to both a
-	//          org.hibernate.metadata.EntityModeMetadata and org.hibernate.metadata.Property
-	//      2) What is now termed a "PropertyAccessor" stores any values needed from those two
-	//          pieces of information
-	//      3) Code can then simply call PropertyAccess.getGetter() with no parameters; likewise with
-	//          PropertyAccessor.getSetter()
-
-	/**
-	 * Retrieves a PropertyAccessor instance based on the given property definition and
-	 * entity mode.
-	 *
-	 * @param property The property for which to retrieve an accessor.
-	 * @param mode The mode for the resulting entity.
-	 *
-	 * @return An appropriate accessor.
-	 *
-	 * @throws MappingException
-	 */
-	public static PropertyAccessor getPropertyAccessor(Property property, EntityMode mode) throws MappingException {
-		//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
-		if ( null == mode || EntityMode.POJO.equals( mode ) ) {
-			return getPojoPropertyAccessor( property.getPropertyAccessorName() );
-		}
-		else if ( EntityMode.MAP.equals( mode ) ) {
-			return getDynamicMapPropertyAccessor();
-		}
-		else {
-			throw new MappingException( "Unknown entity mode [" + mode + "]" );
-		}
-	}
-
-
-	/**
-	 * Retreives a PropertyAccessor specific for a PojoRepresentation with the given access strategy.
-	 *
-	 * @param pojoAccessorStrategy The access strategy.
-	 *
-	 * @return An appropriate accessor.
-	 */
-	private static PropertyAccessor getPojoPropertyAccessor(String pojoAccessorStrategy) {
-		if ( StringHelper.isEmpty( pojoAccessorStrategy ) || "property".equals( pojoAccessorStrategy ) ) {
-			return BASIC_PROPERTY_ACCESSOR;
-		}
-		else if ( "field".equals( pojoAccessorStrategy ) ) {
-			return DIRECT_PROPERTY_ACCESSOR;
-		}
-		else if ( "embedded".equals( pojoAccessorStrategy ) ) {
-			return EMBEDDED_PROPERTY_ACCESSOR;
-		}
-		else if ( "noop".equals( pojoAccessorStrategy ) ) {
-			return NOOP_ACCESSOR;
-		}
-		else {
-			return resolveCustomAccessor( pojoAccessorStrategy );
-		}
-	}
-
-	public static PropertyAccessor getDynamicMapPropertyAccessor() throws MappingException {
-		return MAP_ACCESSOR;
-	}
-
-	private static PropertyAccessor resolveCustomAccessor(String accessorName) {
-		Class accessorClass;
-		try {
-			accessorClass = ReflectHelper.classForName( accessorName );
-		}
-		catch (ClassNotFoundException cnfe) {
-			throw new MappingException( "could not find PropertyAccessor class: " + accessorName, cnfe );
-		}
-		try {
-			return (PropertyAccessor) accessorClass.newInstance();
-		}
-		catch (Exception e) {
-			throw new MappingException( "could not instantiate PropertyAccessor class: " + accessorName, e );
-		}
-	}
-
-	private PropertyAccessorFactory() {
-	}
-
-	// todo : this eventually needs to be removed
-	public static PropertyAccessor getPropertyAccessor(Class optionalClass, String type) throws MappingException {
-		if ( type == null ) {
-			type = optionalClass == null || optionalClass == Map.class ? "map" : "property";
-		}
-		return getPropertyAccessor( type );
-	}
-
-	// todo : this eventually needs to be removed
-	public static PropertyAccessor getPropertyAccessor(String type) throws MappingException {
-		if ( type == null || "property".equals( type ) ) {
-			return BASIC_PROPERTY_ACCESSOR;
-		}
-		if ( "field".equals( type ) ) {
-			return DIRECT_PROPERTY_ACCESSOR;
-		}
-		if ( "map".equals( type ) ) {
-			return MAP_ACCESSOR;
-		}
-		if ( "embedded".equals( type ) ) {
-			return EMBEDDED_PROPERTY_ACCESSOR;
-		}
-		if ( "noop".equals( type ) ) {
-			return NOOP_ACCESSOR;
-		}
-
-		return resolveCustomAccessor( type );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/AbstractFieldSerialForm.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/AbstractFieldSerialForm.java
new file mode 100644
index 0000000000..4088f0b1e9
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/AbstractFieldSerialForm.java
@@ -0,0 +1,42 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.io.Serializable;
+import java.lang.reflect.Field;
+
+import org.hibernate.property.access.spi.PropertyAccessSerializationException;
+
+/**
+ * Abstract serialization replacement for field based Getter and Setter impls.
+ *
+ * @author Steve Ebersole
+ */
+public abstract class AbstractFieldSerialForm implements Serializable {
+	private final Class declaringClass;
+	private final String fieldName;
+
+	protected AbstractFieldSerialForm(Field field) {
+		this( field.getDeclaringClass(), field.getName() );
+	}
+
+	protected AbstractFieldSerialForm(Class declaringClass, String fieldName) {
+		this.declaringClass = declaringClass;
+		this.fieldName = fieldName;
+	}
+
+	protected Field resolveField() {
+		try {
+			return declaringClass.getDeclaredField( fieldName );
+		}
+		catch (NoSuchFieldException e) {
+			throw new PropertyAccessSerializationException(
+					"Unable to resolve field on deserialization : " + declaringClass.getName() + "#" + fieldName
+			);
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessBasicImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessBasicImpl.java
new file mode 100644
index 0000000000..520cf71fce
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessBasicImpl.java
@@ -0,0 +1,62 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Method;
+
+import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.GetterMethodImpl;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.property.access.spi.SetterMethodImpl;
+
+import org.jboss.logging.Logger;
+
+/**
+ * PropertyAccessor for accessing the wrapped property via get/set pair, which may be nonpublic.
+ *
+ * @author Steve Ebersole
+ *
+ * @see PropertyAccessStrategyBasicImpl
+ */
+public class PropertyAccessBasicImpl implements PropertyAccess {
+	private static final Logger log = Logger.getLogger( PropertyAccessBasicImpl.class );
+
+	private final PropertyAccessStrategyBasicImpl strategy;
+	private final GetterMethodImpl getter;
+	private final SetterMethodImpl setter;
+
+	public PropertyAccessBasicImpl(
+			PropertyAccessStrategyBasicImpl strategy,
+			Class containerJavaType,
+			final String propertyName) {
+		this.strategy = strategy;
+
+		final Method getterMethod = ReflectHelper.findGetterMethod( containerJavaType, propertyName );
+		this.getter = new GetterMethodImpl( containerJavaType, propertyName, getterMethod );
+
+		final Method setterMethod = ReflectHelper.findSetterMethod( containerJavaType, propertyName, getterMethod.getReturnType() );
+		this.setter = new SetterMethodImpl( containerJavaType, propertyName, setterMethod );
+	}
+
+	@Override
+	public PropertyAccessStrategy getPropertyAccessStrategy() {
+		return strategy;
+	}
+
+	@Override
+	public Getter getGetter() {
+		return getter;
+	}
+
+	@Override
+	public Setter getSetter() {
+		return setter;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessEmbeddedImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessEmbeddedImpl.java
new file mode 100644
index 0000000000..65b79803b1
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessEmbeddedImpl.java
@@ -0,0 +1,117 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+
+/**
+ * PropertyAccess for handling non-aggregated composites.
+ * <p/>
+ * IMPL NOTE : We actually use a singleton for the Setter; we cannot for the getter mainly
+ * because we need to differentiate {@link Getter#getReturnType()}.  Ultimately I'd prefer to
+ * model that "common information" on PropertyAccess itself.
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class PropertyAccessEmbeddedImpl implements PropertyAccess {
+	private final PropertyAccessStrategyEmbeddedImpl strategy;
+	private final GetterImpl getter;
+
+	@SuppressWarnings("UnusedParameters")
+	public PropertyAccessEmbeddedImpl(
+			PropertyAccessStrategyEmbeddedImpl strategy,
+			Class containerType,
+			String propertyName) {
+		this.strategy = strategy;
+		this.getter = new GetterImpl( containerType );
+	}
+
+	@Override
+	public PropertyAccessStrategy getPropertyAccessStrategy() {
+		return strategy;
+	}
+
+	@Override
+	public Getter getGetter() {
+		return getter;
+	}
+
+	@Override
+	public Setter getSetter() {
+		return SetterImpl.INSTANCE;
+	}
+
+	private static class GetterImpl implements Getter {
+		private final Class containerType;
+
+		public GetterImpl(Class containerType) {
+			this.containerType = containerType;
+		}
+
+		@Override
+		public Object get(Object owner) {
+			return owner;
+		}
+
+		@Override
+		public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+			return owner;
+		}
+
+		@Override
+		public Class getReturnType() {
+			return containerType;
+		}
+
+		@Override
+		public Member getMember() {
+			return null;
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+
+	private static class SetterImpl implements Setter {
+		/**
+		 * Singleton access - we can actually use a singleton for the setter
+		 */
+		public static final SetterImpl INSTANCE = new SetterImpl();
+
+		@Override
+		public void set(Object target, Object value, SessionFactoryImplementor factory) {
+			// nothing to do
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessFieldImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessFieldImpl.java
new file mode 100644
index 0000000000..06aba35636
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessFieldImpl.java
@@ -0,0 +1,53 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Field;
+
+import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.GetterFieldImpl;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.property.access.spi.SetterFieldImpl;
+
+/**
+ * @author Steve Ebersole
+ * @author Gavin King
+ */
+public class PropertyAccessFieldImpl implements PropertyAccess {
+	private final PropertyAccessStrategyFieldImpl strategy;
+	private final GetterFieldImpl getter;
+	private final SetterFieldImpl setter;
+
+	public PropertyAccessFieldImpl(
+			PropertyAccessStrategyFieldImpl strategy,
+			Class containerJavaType,
+			final String propertyName) {
+		this.strategy = strategy;
+
+		final Field field = ReflectHelper.findField( containerJavaType, propertyName );
+		this.getter = new GetterFieldImpl( containerJavaType, propertyName, field );
+		this.setter = new SetterFieldImpl( containerJavaType, propertyName, field );
+	}
+
+	@Override
+	public PropertyAccessStrategy getPropertyAccessStrategy() {
+		return strategy;
+	}
+
+	@Override
+	public Getter getGetter() {
+		return getter;
+	}
+
+	@Override
+	public Setter getSetter() {
+		return setter;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMapImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMapImpl.java
new file mode 100644
index 0000000000..e4d5c523d1
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMapImpl.java
@@ -0,0 +1,115 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+
+/**
+ * PropertyAccess implementation that deal with an underlying Map as the container using
+ * {@link Map#get} and {@link Map#put}
+ *
+ * @author Steve Ebersole
+ * @author Gavin King
+ */
+public class PropertyAccessMapImpl implements PropertyAccess {
+	private final Getter getter;
+	private final Setter setter;
+	private final PropertyAccessStrategyMapImpl strategy;
+
+	public PropertyAccessMapImpl(PropertyAccessStrategyMapImpl strategy, final String propertyName) {
+		this.strategy = strategy;
+		this.getter = new GetterImpl( propertyName );
+		this.setter = new SetterImpl( propertyName );
+	}
+
+	@Override
+	public PropertyAccessStrategy getPropertyAccessStrategy() {
+		return strategy;
+	}
+
+	@Override
+	public Getter getGetter() {
+		return getter;
+	}
+
+	@Override
+	public Setter getSetter() {
+		return setter;
+	}
+
+	public static class GetterImpl implements Getter {
+		private final String propertyName;
+
+		public GetterImpl(String propertyName) {
+			this.propertyName = propertyName;
+		}
+
+		@Override
+		public Object get(Object owner) {
+			return ( (Map) owner ).get( propertyName );
+		}
+
+		@Override
+		public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+			return get( owner );
+		}
+
+		@Override
+		public Class getReturnType() {
+			// we just don't know...
+			return Object.class;
+		}
+
+		@Override
+		public Member getMember() {
+			return null;
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+
+	public static class SetterImpl implements Setter {
+		private final String propertyName;
+
+		public SetterImpl(String propertyName) {
+			this.propertyName = propertyName;
+		}
+
+		@Override
+		@SuppressWarnings("unchecked")
+		public void set(Object target, Object value, SessionFactoryImplementor factory) {
+			( (Map) target ).put( propertyName, value );
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMixedImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMixedImpl.java
new file mode 100644
index 0000000000..ac3f07c995
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessMixedImpl.java
@@ -0,0 +1,120 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import org.hibernate.PropertyNotFoundException;
+import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.GetterFieldImpl;
+import org.hibernate.property.access.spi.GetterMethodImpl;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessBuildingException;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.property.access.spi.SetterFieldImpl;
+import org.hibernate.property.access.spi.SetterMethodImpl;
+
+/**
+ * A PropertyAccess based on mix of getter/setter method and/or field.
+ *
+ * @author Steve Ebersole
+ */
+public class PropertyAccessMixedImpl implements PropertyAccess {
+	private final PropertyAccessStrategyMixedImpl strategy;
+
+	private final Getter getter;
+	private final Setter setter;
+
+	public PropertyAccessMixedImpl(
+			PropertyAccessStrategyMixedImpl strategy,
+			Class containerJavaType,
+			String propertyName) {
+		this.strategy = strategy;
+
+		final Field field = fieldOrNull( containerJavaType, propertyName );
+		final Method getterMethod = getterMethodOrNull( containerJavaType, propertyName );
+
+		final Class propertyJavaType;
+
+		// need one of field or getterMethod to be non-null
+		if ( field == null && getterMethod == null ) {
+			throw new PropertyAccessBuildingException(
+					"Could not locate field nor getter method for property named [" + containerJavaType.getName() +
+							"#" + propertyName + "]"
+			);
+		}
+		else if ( field != null ) {
+			propertyJavaType = field.getType();
+			this.getter = new GetterFieldImpl( containerJavaType, propertyName, field );
+		}
+		else {
+			propertyJavaType = getterMethod.getReturnType();
+			this.getter = new GetterMethodImpl( containerJavaType, propertyName, getterMethod );
+		}
+
+		final Method setterMethod = setterMethodOrNull( containerJavaType, propertyName, propertyJavaType );
+
+		// need one of field or setterMethod to be non-null
+		if ( field == null && setterMethod == null ) {
+			throw new PropertyAccessBuildingException(
+					"Could not locate field nor setter method for property named [" + containerJavaType.getName() +
+							"#" + propertyName + "]"
+			);
+		}
+		else if ( field != null ) {
+			this.setter = new SetterFieldImpl( containerJavaType, propertyName, field );
+		}
+		else {
+			this.setter = new SetterMethodImpl( containerJavaType, propertyName, setterMethod );
+		}
+	}
+
+	private static Field fieldOrNull(Class containerJavaType, String propertyName) {
+		try {
+			return ReflectHelper.findField( containerJavaType, propertyName );
+		}
+		catch (PropertyNotFoundException e) {
+			return null;
+		}
+	}
+
+	private static Method getterMethodOrNull(Class containerJavaType, String propertyName) {
+		try {
+			return ReflectHelper.findGetterMethod( containerJavaType, propertyName );
+		}
+		catch (PropertyNotFoundException e) {
+			return null;
+		}
+	}
+
+	private static Method setterMethodOrNull(Class containerJavaType, String propertyName, Class propertyJavaType) {
+		try {
+			return ReflectHelper.findSetterMethod( containerJavaType, propertyName, propertyJavaType );
+		}
+		catch (PropertyNotFoundException e) {
+			return null;
+		}
+	}
+
+	@Override
+	public PropertyAccessStrategy getPropertyAccessStrategy() {
+		return strategy;
+	}
+
+	@Override
+	public Getter getGetter() {
+		return getter;
+	}
+
+	@Override
+	public Setter getSetter() {
+		return setter;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/BackrefPropertyAccessor.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBackRefImpl.java
old mode 100755
new mode 100644
similarity index 50%
rename from hibernate-core/src/main/java/org/hibernate/property/BackrefPropertyAccessor.java
rename to hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBackRefImpl.java
index 77c1b095b7..65501417c8
--- a/hibernate-core/src/main/java/org/hibernate/property/BackrefPropertyAccessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBackRefImpl.java
@@ -1,138 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.property;
+package org.hibernate.property.access.internal;
+
 import java.io.Serializable;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
 
 /**
- * Represents a "back-reference" to the id of a collection owner.  A "back-reference" is pertinent in mapping scenarios
- * where we have a uni-directional one-to-many association in which only the many side is mapped.  In this case it is
- * the collection itself which is responsible for the FK value.
- * <p/>
- * In this scenario, the one side has no inherent knowledge of its "owner".  So we introduce a synthetic property into
- * the one side to represent the association; a so-called back-reference.
- *
  * @author Gavin King
  * @author Steve Ebersole
  */
-public class BackrefPropertyAccessor implements PropertyAccessor {
-
-	private final String propertyName;
-	private final String entityName;
-
-	// cache these since they are stateless
-	private final BackrefSetter setter; // this one could even be static...
-	private final BackrefGetter getter;
-
+public class PropertyAccessStrategyBackRefImpl implements PropertyAccessStrategy {
 	/**
 	 * A placeholder for a property value, indicating that
 	 * we don't know the value of the back reference
 	 */
 	public static final Serializable UNKNOWN = new Serializable() {
 		@Override
 		public String toString() {
 			return "<unknown>";
 		}
 
 		public Object readResolve() {
 			return UNKNOWN;
 		}
 	};
 
-	/**
-	 * Constructs a new instance of BackrefPropertyAccessor.
-	 *
-	 * @param collectionRole The collection role which this back ref references.
-	 * @param entityName The owner's entity name.
-	 */
-	public BackrefPropertyAccessor(String collectionRole, String entityName) {
-		this.propertyName = collectionRole.substring( entityName.length() + 1 );
-		this.entityName = entityName;
+	private final String entityName;
+	private final String propertyName;
 
-		this.setter = new BackrefSetter();
-		this.getter = new BackrefGetter();
+	public PropertyAccessStrategyBackRefImpl(String collectionRole, String entityName) {
+		this.entityName = entityName;
+		this.propertyName = collectionRole.substring( entityName.length() + 1 );
 	}
 
 	@Override
-	public Setter getSetter(Class theClass, String propertyName) {
-		return setter;
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessBackRefImpl( this );
 	}
 
-	@Override
-	public Getter getGetter(Class theClass, String propertyName) {
-		return getter;
-	}
+	private static class PropertyAccessBackRefImpl implements PropertyAccess {
+		private PropertyAccessStrategyBackRefImpl strategy;
 
+		private final GetterImpl getter;
 
-	/**
-	 * Internal implementation of a property setter specific to these back-ref properties.
-	 */
-	public static final class BackrefSetter implements Setter {
-		@Override
-		public Method getMethod() {
-			return null;
+		public PropertyAccessBackRefImpl(PropertyAccessStrategyBackRefImpl strategy) {
+			this.strategy = strategy;
+			this.getter = new GetterImpl( strategy.entityName, strategy.propertyName );
 		}
 
 		@Override
-		public String getMethodName() {
-			return null;
+		public PropertyAccessStrategy getPropertyAccessStrategy() {
+			return strategy;
 		}
 
 		@Override
-		public void set(Object target, Object value, SessionFactoryImplementor factory) {
-			// this page intentionally left blank :)
+		public Getter getGetter() {
+			return getter;
 		}
 
+		@Override
+		public Setter getSetter() {
+			return SetterImpl.INSTANCE;
+		}
 	}
 
+	private static class GetterImpl implements Getter {
+		private final String entityName;
+		private final String propertyName;
+
+		public GetterImpl(String entityName, String propertyName) {
+			this.entityName = entityName;
+			this.propertyName = propertyName;
+		}
+
+		@Override
+		public Object get(Object owner) {
+			return UNKNOWN;
+		}
 
-	/**
-	 * Internal implementation of a property getter specific to these back-ref properties.
-	 */
-	public class BackrefGetter implements Getter {
 		@Override
-		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
+		public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
 			if ( session == null ) {
 				return UNKNOWN;
 			}
 			else {
-				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );
+				return session.getPersistenceContext().getOwnerId( entityName, propertyName, owner, mergeMap );
 			}
 		}
 
 		@Override
+		public Class getReturnType() {
+			return Object.class;
+		}
+
+		@Override
 		public Member getMember() {
 			return null;
 		}
 
 		@Override
-		public Object get(Object target) {
-			return UNKNOWN;
+		public String getMethodName() {
+			return null;
 		}
 
 		@Override
 		public Method getMethod() {
 			return null;
 		}
+	}
+
+	private static class SetterImpl implements Setter {
+		/**
+		 * Singleton access
+		 */
+		public static final SetterImpl INSTANCE = new SetterImpl();
+
+		@Override
+		public void set(Object target, Object value, SessionFactoryImplementor factory) {
+			// this page intentionally left blank :)
+		}
 
 		@Override
 		public String getMethodName() {
 			return null;
 		}
 
 		@Override
-		public Class getReturnType() {
-			return Object.class;
+		public Method getMethod() {
+			return null;
 		}
 	}
 }
-
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBasicImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBasicImpl.java
new file mode 100644
index 0000000000..c61cbc22b9
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyBasicImpl.java
@@ -0,0 +1,29 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * Defines a strategy for accessing property values via a get/set pair, which may be nonpublic.  This
+ * is the default (and recommended) strategy.
+ *
+ * @author Steve Ebersole
+ * @author Gavin King
+ */
+public class PropertyAccessStrategyBasicImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyBasicImpl INSTANCE = new PropertyAccessStrategyBasicImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, final String propertyName) {
+		return new PropertyAccessBasicImpl( this, containerJavaType, propertyName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyChainedImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyChainedImpl.java
new file mode 100644
index 0000000000..acc0e55c10
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyChainedImpl.java
@@ -0,0 +1,37 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.PropertyNotFoundException;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * @author Max Andersen
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyChainedImpl implements PropertyAccessStrategy {
+	private final PropertyAccessStrategy[] chain;
+
+	public PropertyAccessStrategyChainedImpl(PropertyAccessStrategy... chain) {
+		this.chain = chain;
+	}
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		for ( PropertyAccessStrategy candidate : chain ) {
+			try {
+				return candidate.buildPropertyAccess( containerJavaType, propertyName );
+			}
+			catch (Exception ignore) {
+				// ignore
+			}
+		}
+
+		throw new PropertyNotFoundException( "Could not resolve PropertyAccess for " + propertyName + " on " + containerJavaType );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyEmbeddedImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyEmbeddedImpl.java
new file mode 100644
index 0000000000..9fdd3ae072
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyEmbeddedImpl.java
@@ -0,0 +1,28 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * A PropertyAccessStrategy that deals with non-aggregated composites.
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyEmbeddedImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyEmbeddedImpl INSTANCE = new PropertyAccessStrategyEmbeddedImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessEmbeddedImpl( this, containerJavaType, propertyName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyFieldImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyFieldImpl.java
new file mode 100644
index 0000000000..314aa4a4cf
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyFieldImpl.java
@@ -0,0 +1,28 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * Defines a strategy for accessing property values directly via a field, which may be non-public.
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyFieldImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyFieldImpl INSTANCE = new PropertyAccessStrategyFieldImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessFieldImpl( this, containerJavaType, propertyName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyIndexBackRefImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyIndexBackRefImpl.java
new file mode 100644
index 0000000000..ea15921901
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyIndexBackRefImpl.java
@@ -0,0 +1,129 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+
+/**
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyIndexBackRefImpl implements PropertyAccessStrategy {
+	private final String entityName;
+	private final String propertyName;
+
+	public PropertyAccessStrategyIndexBackRefImpl(String collectionRole, String entityName) {
+		this.entityName = entityName;
+		this.propertyName = collectionRole.substring( entityName.length() + 1 );
+	}
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessIndexBackRefImpl( this );
+	}
+
+	private static class PropertyAccessIndexBackRefImpl implements PropertyAccess {
+		private final PropertyAccessStrategyIndexBackRefImpl strategy;
+		private final GetterImpl getter;
+
+		public PropertyAccessIndexBackRefImpl(PropertyAccessStrategyIndexBackRefImpl strategy) {
+			this.strategy = strategy;
+			this.getter = new GetterImpl( strategy.entityName, strategy.propertyName );
+		}
+
+		@Override
+		public PropertyAccessStrategy getPropertyAccessStrategy() {
+			return strategy;
+		}
+
+		@Override
+		public Getter getGetter() {
+			return getter;
+		}
+
+		@Override
+		public Setter getSetter() {
+			return SetterImpl.INSTANCE;
+		}
+	}
+
+	private static class GetterImpl implements Getter {
+		private final String entityName;
+		private final String propertyName;
+
+		public GetterImpl(String entityName, String propertyName) {
+			this.entityName = entityName;
+			this.propertyName = propertyName;
+		}
+
+		@Override
+		public Object get(Object owner) {
+			return PropertyAccessStrategyBackRefImpl.UNKNOWN;
+		}
+
+		@Override
+		public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+			if ( session == null ) {
+				return PropertyAccessStrategyBackRefImpl.UNKNOWN;
+			}
+			else {
+				return session.getPersistenceContext().getIndexInOwner( entityName, propertyName, owner, mergeMap );
+			}
+		}
+
+		@Override
+		public Class getReturnType() {
+			return Object.class;
+		}
+
+		@Override
+		public Member getMember() {
+			return null;
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+
+	private static class SetterImpl implements Setter {
+		/**
+		 * Singleton access
+		 */
+		public static final SetterImpl INSTANCE = new SetterImpl();
+
+		@Override
+		public void set(Object target, Object value, SessionFactoryImplementor factory) {
+			// this page intentionally left blank :)
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMapImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMapImpl.java
new file mode 100644
index 0000000000..562df0e3d0
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMapImpl.java
@@ -0,0 +1,26 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * @author Steve Ebersole
+ * @author Gavin King
+ */
+public class PropertyAccessStrategyMapImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyMapImpl INSTANCE = new PropertyAccessStrategyMapImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessMapImpl( this, propertyName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMixedImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMixedImpl.java
new file mode 100644
index 0000000000..5d823f0a9c
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyMixedImpl.java
@@ -0,0 +1,27 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+
+/**
+ * A PropertyAccessStrategy that selects between available getter/setter method and/or field.
+ *
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyMixedImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyMixedImpl INSTANCE = new PropertyAccessStrategyMixedImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return new PropertyAccessMixedImpl( this, containerJavaType, propertyName );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyNoopImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyNoopImpl.java
new file mode 100644
index 0000000000..35c6399355
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyNoopImpl.java
@@ -0,0 +1,117 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.Setter;
+
+/**
+ * Yeah, right, so....  No idea...
+ *
+ * @author Michael Bartmann
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyNoopImpl implements PropertyAccessStrategy {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyNoopImpl INSTANCE = new PropertyAccessStrategyNoopImpl();
+
+	@Override
+	public PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName) {
+		return PropertyAccessNoopImpl.INSTANCE;
+	}
+
+	private static class PropertyAccessNoopImpl implements PropertyAccess {
+		/**
+		 * Singleton access
+		 */
+		public static final PropertyAccessNoopImpl INSTANCE = new PropertyAccessNoopImpl();
+
+		@Override
+		public PropertyAccessStrategy getPropertyAccessStrategy() {
+			return PropertyAccessStrategyNoopImpl.INSTANCE;
+		}
+
+		@Override
+		public Getter getGetter() {
+			return GetterImpl.INSTANCE;
+		}
+
+		@Override
+		public Setter getSetter() {
+			return SetterImpl.INSTANCE;
+		}
+	}
+
+	private static class GetterImpl implements Getter {
+		/**
+		 * Singleton access
+		 */
+		public static final GetterImpl INSTANCE = new GetterImpl();
+
+		@Override
+		public Object get(Object owner) {
+			return null;
+		}
+
+		@Override
+		public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+			return null;
+		}
+
+		@Override
+		public Class getReturnType() {
+			return Object.class;
+		}
+
+		@Override
+		public Member getMember() {
+			return null;
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+
+	private static class SetterImpl implements Setter {
+		/**
+		 * Singleton access
+		 */
+		public static final SetterImpl INSTANCE = new SetterImpl();
+
+		@Override
+		public void set(Object target, Object value, SessionFactoryImplementor factory) {
+		}
+
+		@Override
+		public String getMethodName() {
+			return null;
+		}
+
+		@Override
+		public Method getMethod() {
+			return null;
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverInitiator.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverInitiator.java
new file mode 100644
index 0000000000..809caa6c23
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverInitiator.java
@@ -0,0 +1,33 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import java.util.Map;
+
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.property.access.spi.PropertyAccessStrategyResolver;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
+
+/**
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyResolverInitiator implements StandardServiceInitiator<PropertyAccessStrategyResolver> {
+	/**
+	 * Singleton access
+	 */
+	public static final PropertyAccessStrategyResolverInitiator INSTANCE = new PropertyAccessStrategyResolverInitiator();
+
+	@Override
+	public Class<PropertyAccessStrategyResolver> getServiceInitiated() {
+		return PropertyAccessStrategyResolver.class;
+	}
+
+	@Override
+	public PropertyAccessStrategyResolver initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
+		return new PropertyAccessStrategyResolverStandardImpl( registry );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverStandardImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverStandardImpl.java
new file mode 100644
index 0000000000..43bd1de2c3
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/internal/PropertyAccessStrategyResolverStandardImpl.java
@@ -0,0 +1,68 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.internal;
+
+import org.hibernate.EntityMode;
+import org.hibernate.HibernateException;
+import org.hibernate.boot.registry.selector.spi.StrategySelector;
+import org.hibernate.internal.util.StringHelper;
+import org.hibernate.property.access.spi.BuiltInPropertyAccessStrategies;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.PropertyAccessStrategyResolver;
+import org.hibernate.service.ServiceRegistry;
+
+/**
+ * Standard implementation of PropertyAccessStrategyResolver
+ *
+ * @author Steve Ebersole
+ */
+public class PropertyAccessStrategyResolverStandardImpl implements PropertyAccessStrategyResolver {
+	private final ServiceRegistry serviceRegistry;
+
+	public PropertyAccessStrategyResolverStandardImpl(ServiceRegistry serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
+	}
+
+	@Override
+	public PropertyAccessStrategy resolvePropertyAccessStrategy(
+			String explicitAccessStrategyName,
+			EntityMode entityMode) {
+		if ( StringHelper.isNotEmpty( explicitAccessStrategyName ) ) {
+			return resolveExplicitlyNamedPropertyAccessStrategy( explicitAccessStrategyName );
+		}
+
+		if ( entityMode == EntityMode.MAP ) {
+			return BuiltInPropertyAccessStrategies.MAP.getStrategy();
+		}
+		else {
+			return BuiltInPropertyAccessStrategies.BASIC.getStrategy();
+		}
+	}
+
+	protected PropertyAccessStrategy resolveExplicitlyNamedPropertyAccessStrategy(String explicitAccessStrategyName) {
+		final BuiltInPropertyAccessStrategies builtInStrategyEnum = BuiltInPropertyAccessStrategies.interpret(
+				explicitAccessStrategyName
+		);
+		if ( builtInStrategyEnum != null ) {
+			return builtInStrategyEnum.getStrategy();
+		}
+
+		return strategySelectorService().resolveStrategy( PropertyAccessStrategy.class, explicitAccessStrategyName );
+	}
+
+	private StrategySelector strategySelectorService;
+
+	protected StrategySelector strategySelectorService() {
+		if ( strategySelectorService == null ) {
+			if ( serviceRegistry == null ) {
+				throw new HibernateException( "ServiceRegistry not yet injected; PropertyAccessStrategyResolver not ready for use." );
+			}
+			strategySelectorService = serviceRegistry.getService( StrategySelector.class );
+		}
+		return strategySelectorService;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/BuiltInPropertyAccessStrategies.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/BuiltInPropertyAccessStrategies.java
new file mode 100644
index 0000000000..aa6dc073f7
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/BuiltInPropertyAccessStrategies.java
@@ -0,0 +1,65 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import org.hibernate.property.access.internal.PropertyAccessStrategyBasicImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyEmbeddedImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyFieldImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMapImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMixedImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyNoopImpl;
+
+/**
+ * Describes the built-in externally-nameable PropertyAccessStrategy implementations.
+ *
+ * @author Steve Ebersole
+ */
+public enum BuiltInPropertyAccessStrategies {
+	BASIC( "property", PropertyAccessStrategyBasicImpl.INSTANCE ),
+	FIELD( "field", PropertyAccessStrategyFieldImpl.INSTANCE ),
+	MIXED( "mixed", PropertyAccessStrategyMixedImpl.INSTANCE ),
+	MAP( "map", PropertyAccessStrategyMapImpl.INSTANCE ),
+	EMBEDDED( "embedded", PropertyAccessStrategyEmbeddedImpl.INSTANCE ),
+	NOOP( "noop", PropertyAccessStrategyNoopImpl.INSTANCE )
+	;
+
+	private final String externalName;
+	private final PropertyAccessStrategy strategy;
+
+	BuiltInPropertyAccessStrategies(String externalName, PropertyAccessStrategy strategy) {
+		this.externalName = externalName;
+		this.strategy = strategy;
+	}
+
+	public String getExternalName() {
+		return externalName;
+	}
+
+	public PropertyAccessStrategy getStrategy() {
+		return strategy;
+	}
+
+	public static BuiltInPropertyAccessStrategies interpret(String name) {
+		if ( BASIC.externalName.equals( name ) ) {
+			return BASIC;
+		}
+		else if ( FIELD.externalName.equals( name ) ) {
+			return FIELD;
+		}
+		else if ( MAP.externalName.equals( name ) ) {
+			return MAP;
+		}
+		else if ( EMBEDDED.externalName.equals( name ) ) {
+			return EMBEDDED;
+		}
+		else if ( NOOP.externalName.equals( name ) ) {
+			return NOOP;
+		}
+
+		return null;
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/Getter.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/Getter.java
similarity index 56%
rename from hibernate-core/src/main/java/org/hibernate/property/Getter.java
rename to hibernate-core/src/main/java/org/hibernate/property/access/spi/Getter.java
index a667141241..45e45e11b7 100644
--- a/hibernate-core/src/main/java/org/hibernate/property/Getter.java
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/Getter.java
@@ -1,74 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.property;
+package org.hibernate.property.access.spi;
+
 import java.io.Serializable;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.util.Map;
 
-import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 
 /**
- * Gets values of a particular property
+ * The contract for getting value for a persistent property from its container/owner
  *
  * @author Gavin King
+ * @author Steve Ebersole
  */
 public interface Getter extends Serializable {
 	/**
-	 * Get the property value from the given instance .
-	 * @param owner The instance containing the value to be retreived.
+	 * Get the property value from the given owner instance.
+	 *
+	 * @param owner The instance containing the property value to be retrieved.
+	 *
 	 * @return The extracted value.
-	 * @throws HibernateException
+	 *
+	 * @throws org.hibernate.HibernateException
 	 */
-	public Object get(Object owner) throws HibernateException;
+	Object get(Object owner);
 
 	/**
 	 * Get the property value from the given owner instance.
 	 *
 	 * @param owner The instance containing the value to be retreived.
 	 * @param mergeMap a map of merged persistent instances to detached instances
 	 * @param session The session from which this request originated.
+	 *
 	 * @return The extracted value.
-	 * @throws HibernateException
+	 *
+	 * @throws org.hibernate.HibernateException
 	 */
-	public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) 
-	throws HibernateException;
+	Object getForInsert(Object owner, Map mergeMap, SessionImplementor session);
 
 	/**
-	 * Retrieve the member to which this property maps.  This might be the
-	 * field or it might be the getter method.
+	 * Retrieve the declared Java type
 	 *
-	 * @return The mapped member.
+	 * @return The declared java type.
 	 */
-	public Member getMember();
+	Class getReturnType();
 
 	/**
-	 * Retrieve the declared Java type
+	 * Retrieve the member to which this property maps.  This might be the
+	 * field or it might be the getter method.
+	 * <p/>
+	 * Optional operation (may return {@code null})
 	 *
-	 * @return The declared java type.
+	 * @return The mapped member, or {@code null}.
 	 */
-	public Class getReturnType();
+	Member getMember();
 
 	/**
 	 * Retrieve the getter-method name.
 	 * <p/>
-	 * Optional operation (return null)
+	 * Optional operation (may return {@code null})
 	 *
-	 * @return The name of the getter method, or null.
+	 * @return The name of the getter method, or {@code null}.
 	 */
-	public String getMethodName();
+	String getMethodName();
 
 	/**
 	 * Retrieve the getter-method.
 	 * <p/>
-	 * Optional operation (return null)
+	 * Optional operation (may return {@code null})
 	 *
-	 * @return The getter method, or null.
+	 * @return The getter method, or {@code null}.
 	 */
-	public Method getMethod();
+	Method getMethod();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterFieldImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterFieldImpl.java
new file mode 100644
index 0000000000..2e15bac18d
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterFieldImpl.java
@@ -0,0 +1,99 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Locale;
+import java.util.Map;
+
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.property.access.internal.AbstractFieldSerialForm;
+
+/**
+ * Field-based implementation of Getter
+ *
+ * @author Steve Ebersole
+ */
+public class GetterFieldImpl implements Getter {
+	private final Class containerClass;
+	private final String propertyName;
+	private final Field field;
+
+	public GetterFieldImpl(Class containerClass, String propertyName, Field field) {
+		this.containerClass = containerClass;
+		this.propertyName = propertyName;
+		this.field = field;
+	}
+
+	@Override
+	public Object get(Object owner) {
+		try {
+			return field.get( owner );
+		}
+		catch (Exception e) {
+			throw new PropertyAccessException(
+					String.format(
+							Locale.ROOT,
+							"Error accessing field [%s] by reflection for persistent property [%s#%s] : %s",
+							field.toGenericString(),
+							containerClass.getName(),
+							propertyName,
+							owner
+					),
+					e
+			);
+		}
+	}
+
+	@Override
+	public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+		return get( owner );
+	}
+
+	@Override
+	public Class getReturnType() {
+		return field.getType();
+	}
+
+	@Override
+	public Member getMember() {
+		return field;
+	}
+
+	@Override
+	public String getMethodName() {
+		return null;
+	}
+
+	@Override
+	public Method getMethod() {
+		return null;
+	}
+
+	private Object writeReplace() throws ObjectStreamException {
+		return new SerialForm( containerClass, propertyName, field );
+	}
+
+	private static class SerialForm extends AbstractFieldSerialForm implements Serializable {
+		private final Class containerClass;
+		private final String propertyName;
+
+		private SerialForm(Class containerClass, String propertyName, Field field) {
+			super( field );
+			this.containerClass = containerClass;
+			this.propertyName = propertyName;
+		}
+
+		private Object readResolve() {
+			return new GetterFieldImpl( containerClass, propertyName, resolveField() );
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterMethodImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterMethodImpl.java
new file mode 100644
index 0000000000..bbd981eaee
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/GetterMethodImpl.java
@@ -0,0 +1,133 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+import org.hibernate.PropertyAccessException;
+import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.internal.CoreMessageLogger;
+
+import static org.hibernate.internal.CoreLogging.messageLogger;
+
+/**
+ * @author Steve Ebersole
+ */
+public class GetterMethodImpl implements Getter {
+	private static final CoreMessageLogger LOG = messageLogger( GetterMethodImpl.class );
+
+	private final Class containerClass;
+	private final String propertyName;
+	private final Method getterMethod;
+
+	public GetterMethodImpl(Class containerClass, String propertyName, Method getterMethod) {
+		this.containerClass = containerClass;
+		this.propertyName = propertyName;
+		this.getterMethod = getterMethod;
+	}
+
+	@Override
+	public Object get(Object owner) {
+		try {
+			return getterMethod.invoke( owner );
+		}
+		catch (InvocationTargetException ite) {
+			throw new PropertyAccessException(
+					ite,
+					"Exception occurred inside",
+					false,
+					containerClass,
+					propertyName
+			);
+		}
+		catch (IllegalAccessException iae) {
+			throw new PropertyAccessException(
+					iae,
+					"IllegalAccessException occurred while calling",
+					false,
+					containerClass,
+					propertyName
+			);
+			//cannot occur
+		}
+		catch (IllegalArgumentException iae) {
+			LOG.illegalPropertyGetterArgument( containerClass.getName(), propertyName );
+			throw new PropertyAccessException(
+					iae,
+					"IllegalArgumentException occurred calling",
+					false,
+					containerClass,
+					propertyName
+			);
+		}
+	}
+
+	@Override
+	public Object getForInsert(Object owner, Map mergeMap, SessionImplementor session) {
+		return get( owner );
+	}
+
+	@Override
+	public Class getReturnType() {
+		return getterMethod.getReturnType();
+	}
+
+	@Override
+	public Member getMember() {
+		return getterMethod;
+	}
+
+	@Override
+	public String getMethodName() {
+		return getterMethod.getName();
+	}
+
+	@Override
+	public Method getMethod() {
+		return getterMethod;
+	}
+
+	private Object writeReplace() throws ObjectStreamException {
+		return new SerialForm( containerClass, propertyName, getterMethod );
+	}
+
+	private static class SerialForm implements Serializable {
+		private final Class containerClass;
+		private final String propertyName;
+
+		private final Class declaringClass;
+		private final String methodName;
+
+		private SerialForm(Class containerClass, String propertyName, Method method) {
+			this.containerClass = containerClass;
+			this.propertyName = propertyName;
+			this.declaringClass = method.getDeclaringClass();
+			this.methodName = method.getName();
+		}
+
+		private Object readResolve() {
+			return new GetterMethodImpl( containerClass, propertyName, resolveMethod() );
+		}
+
+		@SuppressWarnings("unchecked")
+		private Method resolveMethod() {
+			try {
+				return declaringClass.getDeclaredMethod( methodName );
+			}
+			catch (NoSuchMethodException e) {
+				throw new PropertyAccessSerializationException(
+						"Unable to resolve getter method on deserialization : " + declaringClass.getName() + "#" + methodName
+				);
+			}
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccess.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccess.java
new file mode 100644
index 0000000000..ee53557ee3
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccess.java
@@ -0,0 +1,39 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+/**
+ * Describes access to a particular persistent property in terms of getting and setting
+ * values.
+ * <p/>
+ * Instances are obtained from {@link PropertyAccessStrategy}
+ *
+ * @author Steve Ebersole
+ * @author Gavin King
+ */
+public interface PropertyAccess {
+	/**
+	 * Access to the PropertyAccessStrategy that created this PropertyAccess
+	 *
+	 * @return The PropertyAccessStrategy that created this PropertyAccess
+	 */
+	PropertyAccessStrategy getPropertyAccessStrategy();
+
+	/**
+	 * Obtain the delegate for getting values for the described persistent property
+	 *
+	 * @return The property getter
+	 */
+	Getter getGetter();
+
+	/**
+	 * Obtain the delegate for setting values for the described persistent property
+	 *
+	 * @return The property setter
+	 */
+	Setter getSetter();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessBuildingException.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessBuildingException.java
new file mode 100644
index 0000000000..c3d32bc686
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessBuildingException.java
@@ -0,0 +1,24 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import org.hibernate.HibernateException;
+
+/**
+ * Indicates a problem while building a PropertyAccess
+ *
+ * @author Steve Ebersole
+ */
+public class PropertyAccessBuildingException extends HibernateException {
+	public PropertyAccessBuildingException(String message) {
+		super( message );
+	}
+
+	public PropertyAccessBuildingException(String message, Throwable cause) {
+		super( message, cause );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessException.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessException.java
new file mode 100644
index 0000000000..30646b4e4c
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessException.java
@@ -0,0 +1,24 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import org.hibernate.HibernateException;
+
+/**
+ * Indicates a problem reading or writing value from/to a persistent property.
+ *
+ * @author Steve Ebersole
+ */
+public class PropertyAccessException extends HibernateException {
+	public PropertyAccessException(String message) {
+		super( message );
+	}
+
+	public PropertyAccessException(String message, Throwable cause) {
+		super( message, cause );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessSerializationException.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessSerializationException.java
new file mode 100644
index 0000000000..bd3cbf9a59
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessSerializationException.java
@@ -0,0 +1,22 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import org.hibernate.HibernateException;
+
+/**
+ * @author Steve Ebersole
+ */
+public class PropertyAccessSerializationException extends HibernateException {
+	public PropertyAccessSerializationException(String message) {
+		super( message );
+	}
+
+	public PropertyAccessSerializationException(String message, Throwable cause) {
+		super( message, cause );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategy.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategy.java
new file mode 100644
index 0000000000..b6f0b9fb66
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategy.java
@@ -0,0 +1,25 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+/**
+ * Describes a strategy for persistent property access (field, JavaBean-style property, etc).
+ * Acts as a factory for {@link PropertyAccess} instances.
+ *
+ * @author Steve Ebersole
+ */
+public interface PropertyAccessStrategy {
+	/**
+	 * Build a PropertyAccess for the indicated property
+	 *
+	 * @param containerJavaType The Java type that contains the property; may be {@code null} for non-pojo cases.
+	 * @param propertyName The property name
+	 *
+	 * @return The appropriate PropertyAccess
+	 */
+	PropertyAccess buildPropertyAccess(Class containerJavaType, String propertyName);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategyResolver.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategyResolver.java
new file mode 100644
index 0000000000..2189afd9cb
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/PropertyAccessStrategyResolver.java
@@ -0,0 +1,29 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import org.hibernate.EntityMode;
+import org.hibernate.service.Service;
+
+/**
+ * Contract for resolving the PropertyAccessStrategy to use.
+ * <p/>
+ * todo : moving forward I'd prefer this not be a service, but instead a strategy on the MetadataBuildingContext or MetadataBuildingOptions
+ *
+ * @author Steve Ebersole
+ */
+public interface PropertyAccessStrategyResolver extends Service {
+	/**
+	 * Resolve the PropertyAccessStrategy to use
+	 *
+	 * @param explicitAccessStrategyName The access strategy name explicitly specified, if any.
+	 * @param entityMode The entity mode in effect for the property, used to interpret different default strategies.
+	 *
+	 * @return The resolved PropertyAccessStrategy
+	 */
+	PropertyAccessStrategy resolvePropertyAccessStrategy(String explicitAccessStrategyName, EntityMode entityMode);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/Setter.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/Setter.java
similarity index 62%
rename from hibernate-core/src/main/java/org/hibernate/property/Setter.java
rename to hibernate-core/src/main/java/org/hibernate/property/access/spi/Setter.java
index 69afef0fc7..39c647f593 100644
--- a/hibernate-core/src/main/java/org/hibernate/property/Setter.java
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/Setter.java
@@ -1,37 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.property;
+package org.hibernate.property.access.spi;
+
 import java.io.Serializable;
 import java.lang.reflect.Method;
 
-import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 
 /**
- * Sets values to a particular property.
- * 
+ * The contract for setting a persistent property value into its container/owner
+ *
  * @author Gavin King
+ * @author Steve Ebersole
  */
 public interface Setter extends Serializable {
 	/**
 	 * Set the property value from the given instance
 	 *
 	 * @param target The instance upon which to set the given value.
 	 * @param value The value to be set on the target.
 	 * @param factory The session factory from which this request originated.
-	 * @throws HibernateException
+	 *
+	 * @throws org.hibernate.HibernateException
 	 */
-	public void set(Object target, Object value, SessionFactoryImplementor factory) throws HibernateException;
+	void set(Object target, Object value, SessionFactoryImplementor factory);
+
 	/**
-	 * Optional operation (return null)
+	 * Optional operation (may return {@code null})
 	 */
-	public String getMethodName();
+	String getMethodName();
+
 	/**
-	 * Optional operation (return null)
+	 * Optional operation (may return {@code null})
 	 */
-	public Method getMethod();
+	Method getMethod();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterFieldImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterFieldImpl.java
new file mode 100644
index 0000000000..7c1bb6c624
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterFieldImpl.java
@@ -0,0 +1,101 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Locale;
+
+import org.hibernate.PropertyAccessException;
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.property.access.internal.AbstractFieldSerialForm;
+
+/**
+ * Field-based implementation of Setter
+ *
+ * @author Steve Ebersole
+ */
+public class SetterFieldImpl implements Setter {
+	private final Class containerClass;
+	private final String propertyName;
+	private final Field field;
+
+	public SetterFieldImpl(Class containerClass, String propertyName, Field field) {
+		this.containerClass = containerClass;
+		this.propertyName = propertyName;
+		this.field = field;
+	}
+
+	@Override
+	public void set(Object target, Object value, SessionFactoryImplementor factory) {
+		try {
+			field.set( target, value );
+		}
+		catch (Exception e) {
+			if (value == null && field.getType().isPrimitive()) {
+				throw new PropertyAccessException(
+						e,
+						String.format(
+								Locale.ROOT,
+								"Null value was assigned to a property [%s.%s] of primitive type",
+								containerClass,
+								propertyName
+						),
+						true,
+						containerClass,
+						propertyName
+				);
+			}
+			else {
+				throw new PropertyAccessException(
+						e,
+						String.format(
+								Locale.ROOT,
+								"Could not set field value [%s] value by reflection : [%s.%s]",
+								value,
+								containerClass,
+								propertyName
+						),
+						true,
+						containerClass,
+						propertyName
+				);
+			}
+		}
+	}
+
+	@Override
+	public String getMethodName() {
+		return null;
+	}
+
+	@Override
+	public Method getMethod() {
+		return null;
+	}
+
+	private Object writeReplace() throws ObjectStreamException {
+		return new SerialForm( containerClass, propertyName, field );
+	}
+
+	private static class SerialForm extends AbstractFieldSerialForm implements Serializable {
+		private final Class containerClass;
+		private final String propertyName;
+
+		private SerialForm(Class containerClass, String propertyName, Field field) {
+			super( field );
+			this.containerClass = containerClass;
+			this.propertyName = propertyName;
+		}
+
+		private Object readResolve() {
+			return new SetterFieldImpl( containerClass, propertyName, resolveField() );
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterMethodImpl.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterMethodImpl.java
new file mode 100644
index 0000000000..30f841bfb5
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/SetterMethodImpl.java
@@ -0,0 +1,158 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.property.access.spi;
+
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.hibernate.PropertyAccessException;
+import org.hibernate.PropertySetterAccessException;
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.internal.CoreMessageLogger;
+
+import static org.hibernate.internal.CoreLogging.messageLogger;
+
+/**
+ * @author Steve Ebersole
+ */
+public class SetterMethodImpl implements Setter {
+	private static final CoreMessageLogger LOG = messageLogger( SetterMethodImpl.class );
+
+	private final Class containerClass;
+	private final String propertyName;
+	private final Method setterMethod;
+
+	private final boolean isPrimitive;
+
+	public SetterMethodImpl(Class containerClass, String propertyName, Method setterMethod) {
+		this.containerClass = containerClass;
+		this.propertyName = propertyName;
+		this.setterMethod = setterMethod;
+
+		this.isPrimitive = setterMethod.getParameterTypes()[0].isPrimitive();
+	}
+
+	@Override
+	public void set(Object target, Object value, SessionFactoryImplementor factory) {
+		try {
+			setterMethod.invoke( target, value );
+		}
+		catch (NullPointerException npe) {
+			if ( value == null && isPrimitive ) {
+				throw new PropertyAccessException(
+						npe,
+						"Null value was assigned to a property of primitive type",
+						true,
+						containerClass,
+						propertyName
+				);
+			}
+			else {
+				throw new PropertyAccessException(
+						npe,
+						"NullPointerException occurred while calling",
+						true,
+						containerClass,
+						propertyName
+				);
+			}
+		}
+		catch (InvocationTargetException ite) {
+			throw new PropertyAccessException(
+					ite,
+					"Exception occurred inside",
+					true,
+					containerClass,
+					propertyName
+			);
+		}
+		catch (IllegalAccessException iae) {
+			throw new PropertyAccessException(
+					iae,
+					"IllegalAccessException occurred while calling",
+					true,
+					containerClass,
+					propertyName
+			);
+			//cannot occur
+		}
+		catch (IllegalArgumentException iae) {
+			if ( value == null && isPrimitive ) {
+				throw new PropertyAccessException(
+						iae,
+						"Null value was assigned to a property of primitive type",
+						true,
+						containerClass,
+						propertyName
+				);
+			}
+			else {
+				final Class expectedType = setterMethod.getParameterTypes()[0];
+				LOG.illegalPropertySetterArgument( containerClass.getName(), propertyName );
+				LOG.expectedType( expectedType.getName(), value == null ? null : value.getClass().getName() );
+				throw new PropertySetterAccessException(
+						iae,
+						containerClass,
+						propertyName,
+						expectedType,
+						target,
+						value
+				);
+			}
+		}
+	}
+
+	@Override
+	public String getMethodName() {
+		return setterMethod.getName();
+	}
+
+	@Override
+	public Method getMethod() {
+		return setterMethod;
+	}
+
+	private Object writeReplace() throws ObjectStreamException {
+		return new SerialForm( containerClass, propertyName, setterMethod );
+	}
+
+	private static class SerialForm implements Serializable {
+		private final Class containerClass;
+		private final String propertyName;
+
+		private final Class declaringClass;
+		private final String methodName;
+		private final Class argumentType;
+
+		private SerialForm(Class containerClass, String propertyName, Method method) {
+			this.containerClass = containerClass;
+			this.propertyName = propertyName;
+			this.declaringClass = method.getDeclaringClass();
+			this.methodName = method.getName();
+			this.argumentType = method.getParameterTypes()[0];
+		}
+
+		private Object readResolve() {
+			return new SetterMethodImpl( containerClass, propertyName, resolveMethod() );
+		}
+
+		@SuppressWarnings("unchecked")
+		private Method resolveMethod() {
+			try {
+				return declaringClass.getDeclaredMethod( methodName, argumentType );
+			}
+			catch (NoSuchMethodException e) {
+				throw new PropertyAccessSerializationException(
+						"Unable to resolve setter method on deserialization : " + declaringClass.getName() + "#"
+								+ methodName + "(" + argumentType.getName() + ")"
+				);
+			}
+		}
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/property/access/spi/package-info.java b/hibernate-core/src/main/java/org/hibernate/property/access/spi/package-info.java
new file mode 100644
index 0000000000..37df34be29
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/property/access/spi/package-info.java
@@ -0,0 +1,26 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+
+/**
+ * Defines strategies for accessing the persistent properties of an entity or composite.
+ * <p/>
+ * The overall strategy of the various ways to access a property is defined by the
+ * {@link org.hibernate.property.access.spi.PropertyAccessStrategy} contract.
+ * <p/>
+ * The access for a specific property is modeled by a
+ * {@link org.hibernate.property.access.spi.PropertyAccess} instance build from the strategy, exposing
+ * {@link org.hibernate.property.access.spi.Getter} and {@link org.hibernate.property.access.spi.Setter}
+ * delegates for accessing the properties values.
+ * <p/>
+ * {@link org.hibernate.property.access.spi.BuiltInPropertyAccessStrategies} defines the built-in
+ * named strategies understood in terms of mappings.  In mappings, users may refer to those short names
+ * for referring to certain built-in strategies.  Users may also implement their own
+ * strategy and refer to that by fully-qualified name, or they may leverage the
+ * {@link org.hibernate.boot.registry.selector.spi.StrategySelector} service to define short-naming
+ * for their custom strategies.
+ */
+package org.hibernate.property.access.spi;
diff --git a/hibernate-core/src/main/java/org/hibernate/property/package.html b/hibernate-core/src/main/java/org/hibernate/property/package.html
deleted file mode 100755
index aa335fd170..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/property/package.html
+++ /dev/null
@@ -1,17 +0,0 @@
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.
-  ~ See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
-  -->
-
-<html>
-<head></head>
-<body>
-<p>
-	This package abstracts the notion of a "property" of
-	an entity. Support for JavaBean properties and
-	<tt>Map</tt> elements is included.
-</p>
-</body>
-</html>
diff --git a/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java b/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
index c00b98833a..b837cd3c27 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
@@ -1,87 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.service;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 import org.hibernate.boot.cfgxml.internal.CfgXmlAccessServiceInitiator;
 import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cache.internal.RegionFactoryInitiator;
 import org.hibernate.engine.config.internal.ConfigurationServiceInitiator;
 import org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator;
 import org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;
 import org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator;
 import org.hibernate.engine.jdbc.cursor.internal.RefCursorSupportInitiator;
 import org.hibernate.engine.jdbc.dialect.internal.DialectFactoryInitiator;
 import org.hibernate.engine.jdbc.dialect.internal.DialectResolverInitiator;
 import org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator;
 import org.hibernate.engine.jdbc.internal.JdbcServicesInitiator;
 import org.hibernate.engine.jndi.internal.JndiServiceInitiator;
 import org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator;
 import org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformResolverInitiator;
 import org.hibernate.hql.internal.QueryTranslatorFactoryInitiator;
 import org.hibernate.id.factory.internal.MutableIdentifierGeneratorFactoryInitiator;
 import org.hibernate.jmx.internal.JmxServiceInitiator;
 import org.hibernate.persister.internal.PersisterClassResolverInitiator;
 import org.hibernate.persister.internal.PersisterFactoryInitiator;
+import org.hibernate.property.access.internal.PropertyAccessStrategyResolverInitiator;
 import org.hibernate.resource.transaction.internal.TransactionCoordinatorBuilderInitiator;
 import org.hibernate.service.internal.SessionFactoryServiceRegistryFactoryInitiator;
 import org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractorInitiator;
 import org.hibernate.tool.schema.internal.SchemaManagementToolInitiator;
 
 /**
  * Central definition of the standard set of service initiators defined by Hibernate.
  * 
  * @author Steve Ebersole
  */
 public final class StandardServiceInitiators {
 	private StandardServiceInitiators() {
 	}
 
 	public static List<StandardServiceInitiator> LIST = buildStandardServiceInitiatorList();
 
 	private static List<StandardServiceInitiator> buildStandardServiceInitiatorList() {
 		final List<StandardServiceInitiator> serviceInitiators = new ArrayList<StandardServiceInitiator>();
 
 		serviceInitiators.add( CfgXmlAccessServiceInitiator.INSTANCE );
 		serviceInitiators.add( ConfigurationServiceInitiator.INSTANCE );
+		serviceInitiators.add( PropertyAccessStrategyResolverInitiator.INSTANCE );
 
 		serviceInitiators.add( ImportSqlCommandExtractorInitiator.INSTANCE );
 		serviceInitiators.add( SchemaManagementToolInitiator.INSTANCE );
 
 		serviceInitiators.add( JdbcEnvironmentInitiator.INSTANCE );
 		serviceInitiators.add( JndiServiceInitiator.INSTANCE );
 		serviceInitiators.add( JmxServiceInitiator.INSTANCE );
 
 		serviceInitiators.add( PersisterClassResolverInitiator.INSTANCE );
 		serviceInitiators.add( PersisterFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( ConnectionProviderInitiator.INSTANCE );
 		serviceInitiators.add( MultiTenantConnectionProviderInitiator.INSTANCE );
 		serviceInitiators.add( DialectResolverInitiator.INSTANCE );
 		serviceInitiators.add( DialectFactoryInitiator.INSTANCE );
 		serviceInitiators.add( BatchBuilderInitiator.INSTANCE );
 		serviceInitiators.add( JdbcServicesInitiator.INSTANCE );
 		serviceInitiators.add( RefCursorSupportInitiator.INSTANCE );
 
 		serviceInitiators.add( QueryTranslatorFactoryInitiator.INSTANCE );
 		serviceInitiators.add( MutableIdentifierGeneratorFactoryInitiator.INSTANCE);
 
 		serviceInitiators.add( JtaPlatformResolverInitiator.INSTANCE );
 		serviceInitiators.add( JtaPlatformInitiator.INSTANCE );
 
 		serviceInitiators.add( SessionFactoryServiceRegistryFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( RegionFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( TransactionCoordinatorBuilderInitiator.INSTANCE );
 
 		return Collections.unmodifiableList( serviceInitiators );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
index 45a1ff6828..6cf4a2d005 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
@@ -1,743 +1,748 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.selector.spi.StrategySelector;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.internal.Formatter;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.log.DeprecationLogger;
-import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tool.schema.spi.SchemaManagementTool;
 
 /**
  * Commandline tool to export table schema to the database. This class may also be called from inside an application.
  *
  * @author Daniel Bradby
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class SchemaExport {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( SchemaExport.class );
 
 	private static final String DEFAULT_IMPORT_FILE = "/import.sql";
 
 	public static enum Type {
 		CREATE,
 		DROP,
 		NONE,
 		BOTH;
 
 		public boolean doCreate() {
 			return this == BOTH || this == CREATE;
 		}
 
 		public boolean doDrop() {
 			return this == BOTH || this == DROP;
 		}
 	}
 
 	private final ConnectionHelper connectionHelper;
 	private final SqlStatementLogger sqlStatementLogger;
 	private final SqlExceptionHelper sqlExceptionHelper;
+	private final ClassLoaderService classLoaderService;
 	private final String[] dropSQL;
 	private final String[] createSQL;
 	private final String importFiles;
 
 	private final List<Exception> exceptions = new ArrayList<Exception>();
 
 	private Formatter formatter;
 	private ImportSqlCommandExtractor importSqlCommandExtractor = ImportSqlCommandExtractorInitiator.DEFAULT_EXTRACTOR;
 
 	private String outputFile;
 	private String delimiter;
 	private boolean haltOnError;
 
 	/**
 	 * Builds a SchemaExport object.
 	 *
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 */
 	public SchemaExport(MetadataImplementor metadata) {
 		this( metadata.getMetadataBuildingOptions().getServiceRegistry(), metadata );
 	}
 
 	/**
 	 * Builds a SchemaExport object.
 	 *
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 */
 	public SchemaExport(MetadataImplementor metadata, boolean exportSchemas) {
 		this( metadata.getMetadataBuildingOptions().getServiceRegistry(), metadata, exportSchemas );
 	}
 
 	/**
 	 * Builds a SchemaExport object.
 	 *
 	 * @param serviceRegistry The registry of services available for use.  Should, at a minimum, contain
 	 * the JdbcServices service.
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 */
 	public SchemaExport(ServiceRegistry serviceRegistry, MetadataImplementor metadata) {
 		this(
 				new SuppliedConnectionProviderConnectionHelper(
 						serviceRegistry.getService( ConnectionProvider.class )
 				),
 				serviceRegistry,
 				metadata,
 				false
 		);
 	}
 
 	/**
 	 * Builds a SchemaExport object.
 	 *
 	 * @param serviceRegistry The registry of services available for use.  Should, at a minimum, contain
 	 * the JdbcServices service.
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 */
 	public SchemaExport(ServiceRegistry serviceRegistry, MetadataImplementor metadata, boolean exportSchemas) {
 		this(
 				new SuppliedConnectionProviderConnectionHelper(
 						serviceRegistry.getService( ConnectionProvider.class )
 				),
 				serviceRegistry,
 				metadata,
 				exportSchemas
 		);
 	}
 
 	private SchemaExport(
 			ConnectionHelper connectionHelper,
 			ServiceRegistry serviceRegistry,
 			MetadataImplementor metadata,
 			boolean exportSchemas) {
 		this.connectionHelper = connectionHelper;
 		this.sqlStatementLogger = serviceRegistry.getService( JdbcServices.class ).getSqlStatementLogger();
 		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		this.sqlExceptionHelper = serviceRegistry.getService( JdbcEnvironment.class ).getSqlExceptionHelper();
+		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				serviceRegistry.getService( ConfigurationService.class ).getSettings(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		// uses the schema management tool service to generate the create/drop scripts
 		// longer term this class should instead just leverage the tool for its execution phase.
 		// That is part of the larger task to consolidate Hibernate and JPA schema management
 
 		SchemaManagementTool schemaManagementTool = serviceRegistry.getService( SchemaManagementTool.class );
 		final List<String> commands = new ArrayList<String>();
 		final org.hibernate.tool.schema.spi.Target target = new org.hibernate.tool.schema.spi.Target() {
 			@Override
 			public boolean acceptsImportScriptActions() {
 				return false;
 			}
 
 			@Override
 			public void prepare() {
 				commands.clear();
 			}
 
 			@Override
 			public void accept(String command) {
 				commands.add( command );
 			}
 
 			@Override
 			public void release() {
 			}
 		};
 
 		final Map settings = serviceRegistry.getService( ConfigurationService.class ).getSettings();
 
 		schemaManagementTool.getSchemaDropper( settings ).doDrop( metadata, exportSchemas, target );
 		this.dropSQL = commands.toArray( new String[commands.size()] );
 
 		schemaManagementTool.getSchemaCreator( settings ).doCreation( metadata, exportSchemas, target );
 		this.createSQL = commands.toArray( new String[commands.size()] );
 	}
 
 	/**
 	 * Intended for testing use
 	 *
 	 * @param connectionHelper Access to the JDBC Connection
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 */
 	public SchemaExport(
 			ConnectionHelper connectionHelper,
 			MetadataImplementor metadata) {
 		this(
 				connectionHelper,
 				metadata.getMetadataBuildingOptions().getServiceRegistry(),
 				metadata,
 				false
 		);
 	}
 
 	/**
 	 * Create a SchemaExport for the given Metadata, using the supplied connection for connectivity.
 	 *
 	 * @param metadata The metadata object holding the mapping info to be exported
 	 * @param connection The JDBC connection to use.
 	 *
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 */
 	public SchemaExport(MetadataImplementor metadata, Connection connection) throws HibernateException {
 		this( new SuppliedConnectionHelper( connection ), metadata );
 	}
 
 	/**
 	 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather
 	 * than {@link Configuration}, instead.
 	 */
 	@Deprecated
 	public SchemaExport(ServiceRegistry serviceRegistry, Configuration configuration) {
 		throw new UnsupportedOperationException(
 				"Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; " +
 						"one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"
 		);
 	}
 
 	/**
 	 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather
 	 * than {@link Configuration}, instead.
 	 */
 	@Deprecated
 	public SchemaExport(Configuration configuration) {
 		throw new UnsupportedOperationException(
 				"Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; " +
 						"one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"
 		);
 	}
 
 	/**
 	 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather
 	 * than {@link Configuration}, instead.
 	 */
 	@Deprecated
 	public SchemaExport(Configuration configuration, Connection connection) throws HibernateException {
 		throw new UnsupportedOperationException(
 				"Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; " +
 						"one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"
 		);
 	}
 
 	public SchemaExport(
 			ConnectionHelper connectionHelper,
 			String[] dropSql,
 			String[] createSql) {
 		this.connectionHelper = connectionHelper;
 		this.dropSQL = dropSql;
 		this.createSQL = createSql;
 		this.importFiles = "";
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.sqlExceptionHelper = new SqlExceptionHelper();
+		this.classLoaderService = new ClassLoaderServiceImpl();
 		this.formatter = FormatStyle.DDL.getFormatter();
 	}
 
 	/**
 	 * For generating a export script file, this is the file which will be written.
 	 *
 	 * @param filename The name of the file to which to write the export script.
 	 *
 	 * @return this
 	 */
 	public SchemaExport setOutputFile(String filename) {
 		outputFile = filename;
 		return this;
 	}
 
 	/**
 	 * Set the end of statement delimiter
 	 *
 	 * @param delimiter The delimiter
 	 *
 	 * @return this
 	 */
 	public SchemaExport setDelimiter(String delimiter) {
 		this.delimiter = delimiter;
 		return this;
 	}
 
 	/**
 	 * Should we format the sql strings?
 	 *
 	 * @param format Should we format SQL strings
 	 *
 	 * @return this
 	 */
 	public SchemaExport setFormat(boolean format) {
 		this.formatter = ( format ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		return this;
 	}
 
 	/**
 	 * Set <i>import.sql</i> command extractor. By default {@link SingleLineSqlCommandExtractor} is used.
 	 *
 	 * @param importSqlCommandExtractor <i>import.sql</i> command extractor.
 	 *
 	 * @return this
 	 */
 	public SchemaExport setImportSqlCommandExtractor(ImportSqlCommandExtractor importSqlCommandExtractor) {
 		this.importSqlCommandExtractor = importSqlCommandExtractor;
 		return this;
 	}
 
 	/**
 	 * Should we stop once an error occurs?
 	 *
 	 * @param haltOnError True if export should stop after error.
 	 *
 	 * @return this
 	 */
 	public SchemaExport setHaltOnError(boolean haltOnError) {
 		this.haltOnError = haltOnError;
 		return this;
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void create(boolean script, boolean export) {
 		create( Target.interpret( script, export ) );
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param output the target of the script.
 	 */
 	public void create(Target output) {
 		// need to drop tables before creating so need to specify Type.BOTH
 		execute( output, Type.BOTH );
 	}
 
 	/**
 	 * Run the drop schema script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void drop(boolean script, boolean export) {
 		drop( Target.interpret( script, export ) );
 	}
 
 	public void drop(Target output) {
 		execute( output, Type.DROP );
 	}
 
 	public void execute(boolean script, boolean export, boolean justDrop, boolean justCreate) {
 		execute( Target.interpret( script, export ), interpretType( justDrop, justCreate ) );
 	}
 
 	private Type interpretType(boolean justDrop, boolean justCreate) {
 		if ( justDrop ) {
 			return Type.DROP;
 		}
 		else if ( justCreate ) {
 			return Type.CREATE;
 		}
 		else {
 			return Type.BOTH;
 		}
 	}
 
 	public void execute(Target output, Type type) {
 		if ( ( outputFile == null && output == Target.NONE ) || type == SchemaExport.Type.NONE ) {
 			return;
 		}
 		exceptions.clear();
 
 		LOG.runningHbm2ddlSchemaExport();
 
 		final List<NamedReader> importFileReaders = new ArrayList<NamedReader>();
 		for ( String currentFile : importFiles.split( "," ) ) {
-			try {
-				final String resourceName = currentFile.trim();
-				InputStream stream = ConfigHelper.getResourceAsStream( resourceName );
-				importFileReaders.add( new NamedReader( resourceName, stream ) );
-			}
-			catch (HibernateException e) {
+			final String resourceName = currentFile.trim();
+
+			InputStream stream = classLoaderService.locateResourceStream( resourceName );
+			if ( stream == null ) {
 				LOG.debugf( "Import file not found: %s", currentFile );
 			}
+			else {
+				importFileReaders.add( new NamedReader( resourceName, stream ) );
+			}
 		}
 
 		final List<Exporter> exporters = new ArrayList<Exporter>();
 		try {
 			// prepare exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( output.doScript() ) {
 				exporters.add( new ScriptExporter() );
 			}
 			if ( outputFile != null ) {
 				exporters.add( new FileExporter( outputFile ) );
 			}
 			if ( output.doExport() ) {
 				exporters.add( new DatabaseExporter( connectionHelper, sqlExceptionHelper ) );
 			}
 
 			// perform exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( type.doDrop() ) {
 				perform( dropSQL, exporters );
 			}
 			if ( type.doCreate() ) {
 				perform( createSQL, exporters );
 				if ( !importFileReaders.isEmpty() ) {
 					for ( NamedReader namedReader : importFileReaders ) {
 						importScript( namedReader, exporters );
 					}
 				}
 			}
 		}
 		catch (Exception e) {
 			exceptions.add( e );
 			LOG.schemaExportUnsuccessful( e );
 		}
 		finally {
 			// release exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.release();
 				}
 				catch (Exception ignore) {
 				}
 			}
 
 			// release the named readers from import scripts
 			for ( NamedReader namedReader : importFileReaders ) {
 				try {
 					namedReader.getReader().close();
 				}
 				catch (Exception ignore) {
 				}
 			}
 			LOG.schemaExportComplete();
 		}
 	}
 
 	private void perform(String[] sqlCommands, List<Exporter> exporters) {
 		for ( String sqlCommand : sqlCommands ) {
 			String formatted = formatter.format( sqlCommand );
 			if ( delimiter != null ) {
 				formatted += delimiter;
 			}
 			sqlStatementLogger.logStatement( sqlCommand, formatter );
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.export( formatted );
 				}
 				catch (Exception e) {
 					if ( haltOnError ) {
 						throw new HibernateException( "Error during DDL export", e );
 					}
 					exceptions.add( e );
 					LOG.unsuccessfulCreate( sqlCommand );
 					LOG.error( e.getMessage() );
 				}
 			}
 		}
 	}
 
 	private void importScript(NamedReader namedReader, List<Exporter> exporters) throws Exception {
 		BufferedReader reader = new BufferedReader( namedReader.getReader() );
 		String[] statements = importSqlCommandExtractor.extractCommands( reader );
 		if ( statements != null ) {
 			for ( String statement : statements ) {
 				if ( statement != null ) {
 					String trimmedSql = statement.trim();
 					if ( trimmedSql.endsWith( ";" ) ) {
 						trimmedSql = trimmedSql.substring( 0, statement.length() - 1 );
 					}
 					if ( !StringHelper.isEmpty( trimmedSql ) ) {
 						try {
 							for ( Exporter exporter : exporters ) {
 								if ( exporter.acceptsImportScripts() ) {
 									exporter.export( trimmedSql );
 								}
 							}
 						}
 						catch (Exception e) {
 							if ( haltOnError ) {
 								throw new ImportScriptException(
 										"Error during statement execution (file: '"
 												+ namedReader.getName() + "'): " + trimmedSql, e
 								);
 							}
 							exceptions.add( e );
 							LOG.unsuccessful( trimmedSql );
 							LOG.error( e.getMessage() );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private static class NamedReader {
 		private final Reader reader;
 		private final String name;
 
 		public NamedReader(String name, InputStream stream) {
 			this.name = name;
 			this.reader = new InputStreamReader( stream );
 		}
 
 		public Reader getReader() {
 			return reader;
 		}
 
 		public String getName() {
 			return name;
 		}
 	}
 
 	public static void main(String[] args) {
 		try {
 			final CommandLineArgs commandLineArgs = CommandLineArgs.parseCommandLineArgs( args );
 			StandardServiceRegistry serviceRegistry = buildStandardServiceRegistry( commandLineArgs );
 			try {
 				final MetadataImplementor metadata = buildMetadata( commandLineArgs, serviceRegistry );
 
 				SchemaExport schemaExport = new SchemaExport( serviceRegistry, metadata, commandLineArgs.exportSchemas )
 						.setHaltOnError( commandLineArgs.halt )
 						.setOutputFile( commandLineArgs.outputFile )
 						.setDelimiter( commandLineArgs.delimiter )
 						.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
 						.setFormat( commandLineArgs.format );
 				schemaExport.execute(
 						commandLineArgs.script,
 						commandLineArgs.export,
 						commandLineArgs.drop,
 						commandLineArgs.create
 				);
 			}
 			finally {
 				StandardServiceRegistryBuilder.destroy( serviceRegistry );
 			}
 		}
 		catch (Exception e) {
 			LOG.unableToCreateSchema( e );
 			e.printStackTrace();
 		}
 	}
 
 	private static StandardServiceRegistry buildStandardServiceRegistry(CommandLineArgs commandLineArgs)
 			throws Exception {
 		final BootstrapServiceRegistry bsr = new BootstrapServiceRegistryBuilder().build();
 		final StandardServiceRegistryBuilder ssrBuilder = new StandardServiceRegistryBuilder( bsr );
 
 		if ( commandLineArgs.cfgXmlFile != null ) {
 			ssrBuilder.configure( commandLineArgs.cfgXmlFile );
 		}
 
 		Properties properties = new Properties();
 		if ( commandLineArgs.propertiesFile != null ) {
 			properties.load( new FileInputStream( commandLineArgs.propertiesFile ) );
 		}
 		ssrBuilder.applySettings( properties );
 
 		if ( commandLineArgs.importFile != null ) {
 			ssrBuilder.applySetting( AvailableSettings.HBM2DDL_IMPORT_FILES, commandLineArgs.importFile );
 		}
 
 		return ssrBuilder.build();
 	}
 
 	private static MetadataImplementor buildMetadata(
 			CommandLineArgs parsedArgs,
 			StandardServiceRegistry serviceRegistry) throws Exception {
 		final MetadataSources metadataSources = new MetadataSources( serviceRegistry );
 
 		for ( String filename : parsedArgs.hbmXmlFiles ) {
 			metadataSources.addFile( filename );
 		}
 
 		for ( String filename : parsedArgs.jarFiles ) {
 			metadataSources.addJar( new File( filename ) );
 		}
 
 
 		final MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();
 		final StrategySelector strategySelector = serviceRegistry.getService( StrategySelector.class );
 		if ( parsedArgs.implicitNamingStrategyImplName != null ) {
 			metadataBuilder.applyImplicitNamingStrategy(
 					strategySelector.resolveStrategy(
 							ImplicitNamingStrategy.class,
 							parsedArgs.implicitNamingStrategyImplName
 					)
 			);
 		}
 		if ( parsedArgs.physicalNamingStrategyImplName != null ) {
 			metadataBuilder.applyPhysicalNamingStrategy(
 					strategySelector.resolveStrategy(
 							PhysicalNamingStrategy.class,
 							parsedArgs.physicalNamingStrategyImplName
 					)
 			);
 		}
 
 		return (MetadataImplementor) metadataBuilder.build();
 	}
 
 	/**
 	 * Intended for test usage only.  Builds a Metadata using the same algorithm  as
 	 * {@link #main}
 	 *
 	 * @param args The "command line args"
 	 *
 	 * @return The built Metadata
 	 *
 	 * @throws Exception Problems building the Metadata
 	 */
 	public static MetadataImplementor buildMetadataFromMainArgs(String[] args) throws Exception {
 		final CommandLineArgs commandLineArgs = CommandLineArgs.parseCommandLineArgs( args );
 		StandardServiceRegistry serviceRegistry = buildStandardServiceRegistry( commandLineArgs );
 		try {
 			return buildMetadata( commandLineArgs, serviceRegistry );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	/**
 	 * Returns a List of all Exceptions which occured during the export.
 	 *
 	 * @return A List containig the Exceptions occured during the export
 	 */
 	public List getExceptions() {
 		return exceptions;
 	}
 
 	private static class CommandLineArgs {
 		boolean script = true;
 		boolean drop = false;
 		boolean create = false;
 		boolean halt = false;
 		boolean export = true;
 		boolean format = false;
 
 		boolean exportSchemas = false;
 
 		String delimiter = null;
 
 		String outputFile = null;
 		String importFile = DEFAULT_IMPORT_FILE;
 
 		String propertiesFile = null;
 		String cfgXmlFile = null;
 		String implicitNamingStrategyImplName = null;
 		String physicalNamingStrategyImplName = null;
 
 		List<String> hbmXmlFiles = new ArrayList<String>();
 		List<String> jarFiles = new ArrayList<String>();
 
 		public static CommandLineArgs parseCommandLineArgs(String[] args) {
 			CommandLineArgs parsedArgs = new CommandLineArgs();
 
 			for ( String arg : args ) {
 				if ( arg.startsWith( "--" ) ) {
 					if ( arg.equals( "--quiet" ) ) {
 						parsedArgs.script = false;
 					}
 					else if ( arg.equals( "--drop" ) ) {
 						parsedArgs.drop = true;
 					}
 					else if ( arg.equals( "--create" ) ) {
 						parsedArgs.create = true;
 					}
 					else if ( arg.equals( "--schemas" ) ) {
 						parsedArgs.exportSchemas = true;
 					}
 					else if ( arg.equals( "--haltonerror" ) ) {
 						parsedArgs.halt = true;
 					}
 					else if ( arg.equals( "--text" ) ) {
 						parsedArgs.export = false;
 					}
 					else if ( arg.startsWith( "--output=" ) ) {
 						parsedArgs.outputFile = arg.substring( 9 );
 					}
 					else if ( arg.startsWith( "--import=" ) ) {
 						parsedArgs.importFile = arg.substring( 9 );
 					}
 					else if ( arg.startsWith( "--properties=" ) ) {
 						parsedArgs.propertiesFile = arg.substring( 13 );
 					}
 					else if ( arg.equals( "--format" ) ) {
 						parsedArgs.format = true;
 					}
 					else if ( arg.startsWith( "--delimiter=" ) ) {
 						parsedArgs.delimiter = arg.substring( 12 );
 					}
 					else if ( arg.startsWith( "--config=" ) ) {
 						parsedArgs.cfgXmlFile = arg.substring( 9 );
 					}
 					else if ( arg.startsWith( "--naming=" ) ) {
 						DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyArgument();
 					}
 					else if ( arg.startsWith( "--implicit-naming=" ) ) {
 						parsedArgs.implicitNamingStrategyImplName = arg.substring( 18 );
 					}
 					else if ( arg.startsWith( "--physical-naming=" ) ) {
 						parsedArgs.physicalNamingStrategyImplName = arg.substring( 18 );
 					}
 				}
 				else {
 					if ( arg.endsWith( ".jar" ) ) {
 						parsedArgs.jarFiles.add( arg );
 					}
 					else {
 						parsedArgs.hbmXmlFiles.add( arg );
 					}
 				}
 			}
 
 			return parsedArgs;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdateTask.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdateTask.java
index e948d77a30..8019caaab1 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdateTask.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdateTask.java
@@ -1,280 +1,285 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
+import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.internal.log.DeprecationLogger;
-import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * An Ant task for <tt>SchemaUpdate</tt>.
  * <p/>
  * <pre>
  * &lt;taskdef name="schemaupdate"
  *     classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
  *     classpathref="class.path"/&gt;
  *
  * &lt;schemaupdate
  *     properties="${build.classes.dir}/hibernate.properties"
  *     quiet="no"
  *     &lt;fileset dir="${build.classes.dir}"&gt;
  *         &lt;include name="*.hbm.xml"/&gt;
  *     &lt;/fileset&gt;
  * &lt;/schemaupdate&gt;
  * </pre>
  *
  * @author Rong C Ou, Gavin King
  * @see SchemaUpdate
  */
 public class SchemaUpdateTask extends MatchingTask {
 	private List<FileSet> fileSets = new LinkedList<FileSet>();
 	private File propertiesFile;
 	private File configurationFile;
 	private File outputFile;
 	private boolean quiet;
 	private boolean text = true;
 	private boolean haltOnError;
 	private String delimiter;
 
 	private String implicitNamingStrategy = null;
 	private String physicalNamingStrategy = null;
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void addFileset(FileSet fileSet) {
 		fileSets.add( fileSet );
 	}
 
 	/**
 	 * Set a properties file
 	 *
 	 * @param propertiesFile the properties file name
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public void setProperties(File propertiesFile) {
 		if ( !propertiesFile.exists() ) {
 			throw new BuildException( "Properties file: " + propertiesFile + " does not exist." );
 		}
 
 		log( "Using properties file " + propertiesFile, Project.MSG_DEBUG );
 		this.propertiesFile = propertiesFile;
 	}
 
 	/**
 	 * Set a {@code cfg.xml} file
 	 *
 	 * @param configurationFile the file name
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public void setConfig(File configurationFile) {
 		this.configurationFile = configurationFile;
 	}
 
 	/**
 	 * Enable "text-only" mode. The schema will not be updated in the database.
 	 *
 	 * @param text true to enable text-only mode
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public void setText(boolean text) {
 		this.text = text;
 	}
 
 	/**
 	 * Enable "quiet" mode. The schema will not be written to standard out.
 	 *
 	 * @param quiet true to enable quiet mode
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public void setQuiet(boolean quiet) {
 		this.quiet = quiet;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setNamingStrategy(String namingStrategy) {
 		DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyAntArgument();
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setImplicitNamingStrategy(String implicitNamingStrategy) {
 		this.implicitNamingStrategy = implicitNamingStrategy;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setPhysicalNamingStrategy(String physicalNamingStrategy) {
 		this.physicalNamingStrategy = physicalNamingStrategy;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public File getOutputFile() {
 		return outputFile;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setOutputFile(File outputFile) {
 		this.outputFile = outputFile;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public boolean isHaltOnError() {
 		return haltOnError;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setHaltOnError(boolean haltOnError) {
 		this.haltOnError = haltOnError;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public String getDelimiter() {
 		return delimiter;
 	}
 
 	@SuppressWarnings("UnusedDeclaration")
 	public void setDelimiter(String delimiter) {
 		this.delimiter = delimiter;
 	}
 
 	/**
 	 * Execute the task
 	 */
 	@Override
 	public void execute() throws BuildException {
 		log( "Running Hibernate Core SchemaUpdate." );
 		log( "This is an Ant task supporting only mapping files, if you want to use annotations see http://tools.hibernate.org." );
 
 		try {
 			final StandardServiceRegistryBuilder ssrBuilder = new StandardServiceRegistryBuilder();
 			configure( ssrBuilder );
 
-			final MetadataSources metadataSources = new MetadataSources( ssrBuilder.build() );
+			final StandardServiceRegistry ssr = ssrBuilder.build();
+
+			final MetadataSources metadataSources = new MetadataSources( ssr );
 			configure( metadataSources );
 
 			final MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();
-			configure( metadataBuilder );
+			configure( metadataBuilder, ssr );
 
 			final MetadataImplementor metadata = (MetadataImplementor) metadataBuilder.build();
 
 			final SchemaUpdate su = new SchemaUpdate( metadata );
 			su.setOutputFile( outputFile.getPath() );
 			su.setDelimiter( delimiter );
 			su.setHaltOnError( haltOnError );
 			su.execute( !quiet, !text );
 		}
 		catch (HibernateException e) {
 			throw new BuildException( "Schema text failed: " + e.getMessage(), e );
 		}
 		catch (FileNotFoundException e) {
 			throw new BuildException( "File not found: " + e.getMessage(), e );
 		}
 		catch (IOException e) {
 			throw new BuildException( "IOException : " + e.getMessage(), e );
 		}
 		catch (BuildException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new BuildException( e );
 		}
 	}
 
 	private void configure(StandardServiceRegistryBuilder registryBuilder) throws IOException {
 		if ( configurationFile != null ) {
 			registryBuilder.configure( configurationFile );
 		}
 
 		Properties properties = new Properties();
 		if ( propertiesFile == null ) {
 			properties.putAll( getProject().getProperties() );
 		}
 		else {
 			properties.load( new FileInputStream( propertiesFile ) );
 		}
 
 		registryBuilder.applySettings( properties );
 	}
 
 	private void configure(MetadataSources metadataSources) {
 		for ( String filename : collectFiles() ) {
 			if ( filename.endsWith( ".jar" ) ) {
 				metadataSources.addJar( new File( filename ) );
 			}
 			else {
 				metadataSources.addFile( filename );
 			}
 		}
 	}
 
 	private String[] collectFiles() {
 		List<String> files = new LinkedList<String>();
 		for ( FileSet fileSet : fileSets ) {
 			final DirectoryScanner ds = fileSet.getDirectoryScanner( getProject() );
 			final String[] dsFiles = ds.getIncludedFiles();
 			for ( String dsFileName : dsFiles ) {
 				File f = new File( dsFileName );
 				if ( !f.isFile() ) {
 					f = new File( ds.getBasedir(), dsFileName );
 				}
 
 				files.add( f.getAbsolutePath() );
 			}
 		}
 		return ArrayHelper.toStringArray( files );
 	}
 
 	@SuppressWarnings("deprecation")
-	private void configure(MetadataBuilder metadataBuilder) {
+	private void configure(MetadataBuilder metadataBuilder, StandardServiceRegistry serviceRegistry) {
+		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+
 		if ( implicitNamingStrategy != null ) {
 			try {
 				metadataBuilder.applyImplicitNamingStrategy(
-						(ImplicitNamingStrategy) ReflectHelper.classForName( implicitNamingStrategy ).newInstance()
+						(ImplicitNamingStrategy) classLoaderService.classForName( implicitNamingStrategy ).newInstance()
 				);
 			}
 			catch (Exception e) {
 				throw new BuildException(
 						"Unable to instantiate specified ImplicitNamingStrategy [" + implicitNamingStrategy + "]",
 						e
 				);
 			}
 		}
 
 		if ( physicalNamingStrategy != null ) {
 			try {
 				metadataBuilder.applyPhysicalNamingStrategy(
-						(PhysicalNamingStrategy) ReflectHelper.classForName( physicalNamingStrategy ).newInstance()
+						(PhysicalNamingStrategy) classLoaderService.classForName( physicalNamingStrategy ).newInstance()
 				);
 			}
 			catch (Exception e) {
 				throw new BuildException(
 						"Unable to instantiate specified PhysicalNamingStrategy [" + physicalNamingStrategy + "]",
 						e
 				);
 			}
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/transform/AliasToBeanResultTransformer.java b/hibernate-core/src/main/java/org/hibernate/transform/AliasToBeanResultTransformer.java
index c9cb074dd4..1aeabd65e6 100644
--- a/hibernate-core/src/main/java/org/hibernate/transform/AliasToBeanResultTransformer.java
+++ b/hibernate-core/src/main/java/org/hibernate/transform/AliasToBeanResultTransformer.java
@@ -1,144 +1,145 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.transform;
+
 import java.util.Arrays;
 
 import org.hibernate.HibernateException;
-import org.hibernate.property.ChainedPropertyAccessor;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBasicImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyChainedImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyFieldImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMapImpl;
+import org.hibernate.property.access.spi.Setter;
 
 /**
  * Result transformer that allows to transform a result to
  * a user specified class which will be populated via setter
  * methods or fields matching the alias names.
  * <p/>
  * <pre>
  * List resultWithAliasedBean = s.createCriteria(Enrolment.class)
  * 			.createAlias("student", "st")
  * 			.createAlias("course", "co")
  * 			.setProjection( Projections.projectionList()
  * 					.add( Projections.property("co.description"), "courseDescription" )
  * 			)
  * 			.setResultTransformer( new AliasToBeanResultTransformer(StudentDTO.class) )
  * 			.list();
  * <p/>
  *  StudentDTO dto = (StudentDTO)resultWithAliasedBean.get(0);
  * 	</pre>
  *
  * @author max
  */
 public class AliasToBeanResultTransformer extends AliasedTupleSubsetResultTransformer {
 
 	// IMPL NOTE : due to the delayed population of setters (setters cached
 	// 		for performance), we really cannot properly define equality for
 	// 		this transformer
 
 	private final Class resultClass;
 	private boolean isInitialized;
 	private String[] aliases;
 	private Setter[] setters;
 
 	public AliasToBeanResultTransformer(Class resultClass) {
 		if ( resultClass == null ) {
 			throw new IllegalArgumentException( "resultClass cannot be null" );
 		}
 		isInitialized = false;
 		this.resultClass = resultClass;
 	}
 
 	@Override
 	public boolean isTransformedValueATupleElement(String[] aliases, int tupleLength) {
 		return false;
 	}
 
 	@Override
 	public Object transformTuple(Object[] tuple, String[] aliases) {
 		Object result;
 
 		try {
 			if ( ! isInitialized ) {
 				initialize( aliases );
 			}
 			else {
 				check( aliases );
 			}
 			
 			result = resultClass.newInstance();
 
 			for ( int i = 0; i < aliases.length; i++ ) {
 				if ( setters[i] != null ) {
 					setters[i].set( result, tuple[i], null );
 				}
 			}
 		}
 		catch ( InstantiationException e ) {
 			throw new HibernateException( "Could not instantiate resultclass: " + resultClass.getName() );
 		}
 		catch ( IllegalAccessException e ) {
 			throw new HibernateException( "Could not instantiate resultclass: " + resultClass.getName() );
 		}
 
 		return result;
 	}
 
 	private void initialize(String[] aliases) {
-		PropertyAccessor propertyAccessor = new ChainedPropertyAccessor(
-				new PropertyAccessor[] {
-						PropertyAccessorFactory.getPropertyAccessor( resultClass, null ),
-						PropertyAccessorFactory.getPropertyAccessor( "field" )
-				}
+		PropertyAccessStrategyChainedImpl propertyAccessStrategy = new PropertyAccessStrategyChainedImpl(
+				PropertyAccessStrategyBasicImpl.INSTANCE,
+				PropertyAccessStrategyFieldImpl.INSTANCE,
+				PropertyAccessStrategyMapImpl.INSTANCE
 		);
 		this.aliases = new String[ aliases.length ];
 		setters = new Setter[ aliases.length ];
 		for ( int i = 0; i < aliases.length; i++ ) {
 			String alias = aliases[ i ];
 			if ( alias != null ) {
 				this.aliases[ i ] = alias;
-				setters[ i ] = propertyAccessor.getSetter( resultClass, alias );
+				setters[ i ] = propertyAccessStrategy.buildPropertyAccess( resultClass, alias ).getSetter();
 			}
 		}
 		isInitialized = true;
 	}
 
 	private void check(String[] aliases) {
 		if ( ! Arrays.equals( aliases, this.aliases ) ) {
 			throw new IllegalStateException(
 					"aliases are different from what is cached; aliases=" + Arrays.asList( aliases ) +
 							" cached=" + Arrays.asList( this.aliases ) );
 		}
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		AliasToBeanResultTransformer that = ( AliasToBeanResultTransformer ) o;
 
 		if ( ! resultClass.equals( that.resultClass ) ) {
 			return false;
 		}
 		if ( ! Arrays.equals( aliases, that.aliases ) ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	@Override
 	public int hashCode() {
 		int result = resultClass.hashCode();
 		result = 31 * result + ( aliases != null ? Arrays.hashCode( aliases ) : 0 );
 		return result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java
deleted file mode 100755
index cc2bd69755..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.tuple;
-
-import java.io.Serializable;
-import java.util.HashSet;
-import java.util.Iterator;
-
-import org.hibernate.internal.util.xml.XMLHelper;
-import org.hibernate.mapping.Component;
-import org.hibernate.mapping.PersistentClass;
-
-import org.dom4j.Element;
-
-/**
- * Performs "instantiation" based on DOM4J elements.
- */
-public class Dom4jInstantiator implements Instantiator {
-	private final String nodeName;
-	private final HashSet isInstanceNodeNames = new HashSet();
-
-	public Dom4jInstantiator(Component component) {
-		this.nodeName = component.getNodeName();
-		isInstanceNodeNames.add( nodeName );
-	}
-
-	public Dom4jInstantiator(PersistentClass mappingInfo) {
-		this.nodeName = mappingInfo.getNodeName();
-		isInstanceNodeNames.add( nodeName );
-
-		if ( mappingInfo.hasSubclasses() ) {
-			Iterator itr = mappingInfo.getSubclassClosureIterator();
-			while ( itr.hasNext() ) {
-				final PersistentClass subclassInfo = ( PersistentClass ) itr.next();
-				isInstanceNodeNames.add( subclassInfo.getNodeName() );
-			}
-		}
-	}
-	
-	public Object instantiate(Serializable id) {
-		return instantiate();
-	}
-	
-	public Object instantiate() {
-		return XMLHelper.generateDom4jElement( nodeName );
-	}
-
-	public boolean isInstance(Object object) {
-		if ( object instanceof Element ) {
-			return isInstanceNodeNames.contains( ( ( Element ) object ).getName() );
-		}
-		else {
-			return false;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
index 8b6f9a0062..93b8be7b55 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
@@ -1,317 +1,330 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple;
 
 import java.lang.reflect.Constructor;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.UnsavedValueFactory;
 import org.hibernate.engine.spi.IdentifierValue;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.VersionValue;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.PropertyAccessStrategyResolver;
 import org.hibernate.tuple.entity.EntityBasedAssociationAttribute;
 import org.hibernate.tuple.entity.EntityBasedBasicAttribute;
 import org.hibernate.tuple.entity.EntityBasedCompositionAttribute;
 import org.hibernate.tuple.entity.VersionProperty;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Responsible for generation of runtime metamodel {@link Property} representations.
  * Makes distinction between identifier, version, and other (standard) properties.
  *
  * @author Steve Ebersole
  */
 public final class PropertyFactory {
 	private PropertyFactory() {
 	}
 
 	/**
 	 * Generates the attribute representation of the identifier for a given entity mapping.
 	 *
 	 * @param mappedEntity The mapping definition of the entity.
 	 * @param generator The identifier value generator to use for this identifier.
 	 *
 	 * @return The appropriate IdentifierProperty definition.
 	 */
 	public static IdentifierProperty buildIdentifierAttribute(
 			PersistentClass mappedEntity,
 			IdentifierGenerator generator) {
 		String mappedUnsavedValue = mappedEntity.getIdentifier().getNullValue();
 		Type type = mappedEntity.getIdentifier().getType();
 		Property property = mappedEntity.getIdentifierProperty();
 
 		IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				type,
 				getConstructor( mappedEntity )
 		);
 
 		if ( property == null ) {
 			// this is a virtual id property...
 			return new IdentifierProperty(
 					type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					mappedEntity.hasIdentifierMapper(),
 					unsavedValue,
 					generator
 			);
 		}
 		else {
 			return new IdentifierProperty(
 					property.getName(),
 					property.getNodeName(),
 					type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					unsavedValue,
 					generator
 			);
 		}
 	}
 
 	/**
 	 * Generates a VersionProperty representation for an entity mapping given its
 	 * version mapping Property.
 	 *
 	 * @param property The version mapping Property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 *
 	 * @return The appropriate VersionProperty definition.
 	 */
 	public static VersionProperty buildVersionProperty(
 			EntityPersister persister,
 			SessionFactoryImplementor sessionFactory,
 			int attributeNumber,
 			Property property,
 			boolean lazyAvailable) {
 		String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();
 
 		VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				(VersionType) property.getType(),
 				getConstructor( property.getPersistentClass() )
 		);
 
 		boolean lazy = lazyAvailable && property.isLazy();
 
 		return new VersionProperty(
 				persister,
 				sessionFactory,
 				attributeNumber,
 				property.getName(),
 				property.getValue().getType(),
 				new BaselineAttributeInformation.Builder()
 						.setLazy( lazy )
 						.setInsertable( property.isInsertable() )
 						.setUpdateable( property.isUpdateable() )
 						.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 						.setNullable( property.isOptional() )
 						.setDirtyCheckable( property.isUpdateable() && !lazy )
 						.setVersionable( property.isOptimisticLocked() )
 						.setCascadeStyle( property.getCascadeStyle() )
 						.createInformation(),
 				unsavedValue
 		);
 	}
 
 	public static enum NonIdentifierAttributeNature {
 		BASIC,
 		COMPOSITE,
 		ANY,
 		ENTITY,
 		COLLECTION
 	}
 
 	/**
 	 * Generate a non-identifier (and non-version) attribute based on the given mapped property from the given entity
 	 *
 	 * @param property The mapped property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 *
 	 * @return The appropriate NonIdentifierProperty definition.
 	 */
 	public static NonIdentifierAttribute buildEntityBasedAttribute(
 			EntityPersister persister,
 			SessionFactoryImplementor sessionFactory,
 			int attributeNumber,
 			Property property,
 			boolean lazyAvailable) {
 		final Type type = property.getValue().getType();
 
 		final NonIdentifierAttributeNature nature = decode( type );
 
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 
 		// we need to dirty check many-to-ones with not-found="ignore" in order 
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 
 		boolean alwaysDirtyCheck = type.isAssociationType() &&
 				( (AssociationType) type ).isAlwaysDirtyChecked();
 
 		switch ( nature ) {
 			case BASIC: {
 				return new EntityBasedBasicAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			case COMPOSITE: {
 				return new EntityBasedCompositionAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						(CompositeType) type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			case ENTITY:
 			case ANY:
 			case COLLECTION: {
 				return new EntityBasedAssociationAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						(AssociationType) type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			default: {
 				throw new HibernateException( "Internal error" );
 			}
 		}
 	}
 
 	private static NonIdentifierAttributeNature decode(Type type) {
 		if ( type.isAssociationType() ) {
 			AssociationType associationType = (AssociationType) type;
 
 			if ( type.isComponentType() ) {
 				// an any type is both an association and a composite...
 				return NonIdentifierAttributeNature.ANY;
 			}
 
 			return type.isCollectionType()
 					? NonIdentifierAttributeNature.COLLECTION
 					: NonIdentifierAttributeNature.ENTITY;
 		}
 		else {
 			if ( type.isComponentType() ) {
 				return NonIdentifierAttributeNature.COMPOSITE;
 			}
 
 			return NonIdentifierAttributeNature.BASIC;
 		}
 	}
 
 	/**
 	 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 	 */
 	@Deprecated
 	public static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {
 		final Type type = property.getValue().getType();
 
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 
 		// we need to dirty check many-to-ones with not-found="ignore" in order
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 
 		boolean alwaysDirtyCheck = type.isAssociationType() &&
 				( (AssociationType) type ).isAlwaysDirtyChecked();
 
 		return new StandardProperty(
 				property.getName(),
 				type,
 				lazyAvailable && property.isLazy(),
 				property.isInsertable(),
 				property.isUpdateable(),
 				property.getValueGenerationStrategy(),
 				property.isOptional(),
 				alwaysDirtyCheck || property.isUpdateable(),
 				property.isOptimisticLocked(),
 				property.getCascadeStyle(),
 				property.getValue().getFetchMode()
 		);
 	}
 
 
 	private static Constructor getConstructor(PersistentClass persistentClass) {
 		if ( persistentClass == null || !persistentClass.hasPojoRepresentation() ) {
 			return null;
 		}
 
 		try {
 			return ReflectHelper.getDefaultConstructor( persistentClass.getMappedClass() );
 		}
 		catch (Throwable t) {
 			return null;
 		}
 	}
 
 	private static Getter getGetter(Property mappingProperty) {
 		if ( mappingProperty == null || !mappingProperty.getPersistentClass().hasPojoRepresentation() ) {
 			return null;
 		}
 
-		PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( mappingProperty, EntityMode.POJO );
-		return pa.getGetter( mappingProperty.getPersistentClass().getMappedClass(), mappingProperty.getName() );
+		final PropertyAccessStrategyResolver propertyAccessStrategyResolver =
+				mappingProperty.getPersistentClass().getServiceRegistry().getService( PropertyAccessStrategyResolver.class );
+
+		final PropertyAccessStrategy propertyAccessStrategy = propertyAccessStrategyResolver.resolvePropertyAccessStrategy(
+				mappingProperty.getPropertyAccessorName(),
+				EntityMode.POJO
+		);
+
+		final PropertyAccess propertyAccess = propertyAccessStrategy.buildPropertyAccess(
+				mappingProperty.getPersistentClass().getMappedClass(),
+				mappingProperty.getName()
+		);
+
+		return propertyAccess.getGetter();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/Tuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/Tuplizer.java
index 575e14ec8c..5de7424fa8 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/Tuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/Tuplizer.java
@@ -1,101 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple;
-import org.hibernate.property.Getter;
+
+import org.hibernate.property.access.spi.Getter;
 
 /**
  * A tuplizer defines the contract for things which know how to manage
  * a particular representation of a piece of data, given that
  * representation's {@link org.hibernate.EntityMode} (the entity-mode
  * essentially defining which representation).
  * </p>
  * If that given piece of data is thought of as a data structure, then a tuplizer
  * is the thing which knows how to<ul>
  * <li>create such a data structure appropriately
  * <li>extract values from and inject values into such a data structure
  * </ul>
  * </p>
  * For example, a given piece of data might be represented as a POJO class.
  * Here, it's representation and entity-mode is POJO.  Well a tuplizer for POJO
  * entity-modes would know how to<ul>
  * <li>create the data structure by calling the POJO's constructor
  * <li>extract and inject values through getters/setter, or by direct field access, etc
  * </ul>
  * </p>
  * That same piece of data might also be represented as a DOM structure, using
  * the tuplizer associated with the DOM4J entity-mode, which would generate instances
  * of {@link org.dom4j.Element} as the data structure and know how to access the
  * values as either nested {@link org.dom4j.Element}s or as {@link org.dom4j.Attribute}s.
  *
  * @see org.hibernate.tuple.entity.EntityTuplizer
  * @see org.hibernate.tuple.component.ComponentTuplizer
  *
  * @author Steve Ebersole
  */
 public interface Tuplizer {
 	/**
 	 * Extract the current values contained on the given entity.
 	 *
 	 * @param entity The entity from which to extract values.
 	 * @return The current property values.
 	 */
 	public Object[] getPropertyValues(Object entity);
 
 	/**
 	 * Inject the given values into the given entity.
 	 *
 	 * @param entity The entity.
 	 * @param values The values to be injected.
 	 */
 	public void setPropertyValues(Object entity, Object[] values);
 
 	/**
 	 * Extract the value of a particular property from the given entity.
 	 *
 	 * @param entity The entity from which to extract the property value.
 	 * @param i The index of the property for which to extract the value.
 	 * @return The current value of the given property on the given entity.
 	 */
 	public Object getPropertyValue(Object entity, int i);
 
 	/**
 	 * Generate a new, empty entity.
 	 *
 	 * @return The new, empty entity instance.
 	 */
 	public Object instantiate();
 	
 	/**
 	 * Is the given object considered an instance of the the entity (acconting
 	 * for entity-mode) managed by this tuplizer.
 	 *
 	 * @param object The object to be checked.
 	 * @return True if the object is considered as an instance of this entity
 	 *      within the given mode.
 	 */
 	public boolean isInstance(Object object);
 
 	/**
 	 * Return the pojo class managed by this tuplizer.
 	 * </p>
 	 * Need to determine how to best handle this for the Tuplizers for EntityModes
 	 * other than POJO.
 	 * </p>
 	 * todo : be really nice to not have this here since it is essentially pojo specific...
 	 *
 	 * @return The persistent class.
 	 */
 	public Class getMappedClass();
 
 	/**
 	 * Retrieve the getter for the specified property.
 	 *
 	 * @param i The property index.
 	 * @return The property getter.
 	 */
 	public Getter getGetter(int i);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/AbstractComponentTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/AbstractComponentTuplizer.java
index 3b20acb581..7404390916 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/AbstractComponentTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/AbstractComponentTuplizer.java
@@ -1,105 +1,105 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.component;
 import java.lang.reflect.Method;
 import java.util.Iterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.tuple.Instantiator;
 
 /**
  * Support for tuplizers relating to components.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public abstract class AbstractComponentTuplizer implements ComponentTuplizer {
 	protected final Getter[] getters;
 	protected final Setter[] setters;
 	protected final int propertySpan;
 	protected final Instantiator instantiator;
 	protected final boolean hasCustomAccessors;
 
 	protected abstract Instantiator buildInstantiator(Component component);
 	protected abstract Getter buildGetter(Component component, Property prop);
 	protected abstract Setter buildSetter(Component component, Property prop);
 
 	protected AbstractComponentTuplizer(Component component) {
 		propertySpan = component.getPropertySpan();
 		getters = new Getter[propertySpan];
 		setters = new Setter[propertySpan];
 
 		Iterator iter = component.getPropertyIterator();
 		boolean foundCustomAccessor=false;
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			getters[i] = buildGetter( component, prop );
 			setters[i] = buildSetter( component, prop );
 			if ( !prop.isBasicPropertyAccessor() ) {
 				foundCustomAccessor = true;
 			}
 			i++;
 		}
 		hasCustomAccessors = foundCustomAccessor;
 		instantiator = buildInstantiator( component );
 	}
 
 	public Object getPropertyValue(Object component, int i) throws HibernateException {
 		return getters[i].get( component );
 	}
 
 	public Object[] getPropertyValues(Object component) throws HibernateException {
 		Object[] values = new Object[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			values[i] = getPropertyValue( component, i );
 		}
 		return values;
 	}
 
 	public boolean isInstance(Object object) {
 		return instantiator.isInstance(object);
 	}
 
 	public void setPropertyValues(Object component, Object[] values) throws HibernateException {
 		for ( int i = 0; i < propertySpan; i++ ) {
 			setters[i].set( component, values[i], null );
 		}
 	}
 
 	/**
 	* This method does not populate the component parent
 	*/
 	public Object instantiate() throws HibernateException {
 		return instantiator.instantiate();
 	}
 
 	public Object getParent(Object component) {
 		return null;
 	}
 
 	public boolean hasParentProperty() {
 		return false;
 	}
 
 	public boolean isMethodOf(Method method) {
 		return false;
 	}
 
 	public void setParent(Object component, Object parent, SessionFactoryImplementor factory) {
 		throw new UnsupportedOperationException();
 	}
 
 	public Getter getGetter(int i) {
 		return getters[i];
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentMetamodel.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentMetamodel.java
index d05b37aaf7..ef33912950 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentMetamodel.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentMetamodel.java
@@ -1,108 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.component;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
+import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
 import org.hibernate.tuple.PropertyFactory;
 import org.hibernate.tuple.StandardProperty;
 
 /**
  * Centralizes metamodel information about a component.
  *
  * @author Steve Ebersole
  */
 public class ComponentMetamodel implements Serializable {
 
 	// TODO : will need reference to session factory to fully complete HHH-1907
 
 //	private final SessionFactoryImplementor sessionFactory;
 	private final String role;
 	private final boolean isKey;
 	private final StandardProperty[] properties;
 
 	private final EntityMode entityMode;
 	private final ComponentTuplizer componentTuplizer;
 
 	// cached for efficiency...
 	private final int propertySpan;
 	private final Map propertyIndexes = new HashMap();
 
 //	public ComponentMetamodel(Component component, SessionFactoryImplementor sessionFactory) {
-	public ComponentMetamodel(Component component) {
+	public ComponentMetamodel(Component component, MetadataBuildingOptions metadataBuildingOptions) {
 //		this.sessionFactory = sessionFactory;
 		this.role = component.getRoleName();
 		this.isKey = component.isKey();
 		propertySpan = component.getPropertySpan();
 		properties = new StandardProperty[propertySpan];
 		Iterator itr = component.getPropertyIterator();
 		int i = 0;
 		while ( itr.hasNext() ) {
 			Property property = ( Property ) itr.next();
 			properties[i] = PropertyFactory.buildStandardProperty( property, false );
 			propertyIndexes.put( property.getName(), i );
 			i++;
 		}
 
 		entityMode = component.hasPojoRepresentation() ? EntityMode.POJO : EntityMode.MAP;
 
 		// todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodel
-		final ComponentTuplizerFactory componentTuplizerFactory = new ComponentTuplizerFactory();
+		final ComponentTuplizerFactory componentTuplizerFactory = new ComponentTuplizerFactory( metadataBuildingOptions );
 		final String tuplizerClassName = component.getTuplizerImplClassName( entityMode );
 		this.componentTuplizer = tuplizerClassName == null ? componentTuplizerFactory.constructDefaultTuplizer(
 				entityMode,
 				component
 		) : componentTuplizerFactory.constructTuplizer( tuplizerClassName, component );
 	}
 
 	public boolean isKey() {
 		return isKey;
 	}
 
 	public int getPropertySpan() {
 		return propertySpan;
 	}
 
 	public StandardProperty[] getProperties() {
 		return properties;
 	}
 
 	public StandardProperty getProperty(int index) {
 		if ( index < 0 || index >= propertySpan ) {
 			throw new IllegalArgumentException( "illegal index value for component property access [request=" + index + ", span=" + propertySpan + "]" );
 		}
 		return properties[index];
 	}
 
 	public int getPropertyIndex(String propertyName) {
 		Integer index = ( Integer ) propertyIndexes.get( propertyName );
 		if ( index == null ) {
 			throw new HibernateException( "component does not contain such a property [" + propertyName + "]" );
 		}
 		return index;
 	}
 
 	public StandardProperty getProperty(String propertyName) {
 		return getProperty( getPropertyIndex( propertyName ) );
 	}
 
 	public EntityMode getEntityMode() {
 		return entityMode;
 	}
 
 	public ComponentTuplizer getComponentTuplizer() {
 		return componentTuplizer;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
index ea0996110f..2f58459960 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
@@ -1,140 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.component;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
+import org.hibernate.boot.internal.ClassLoaderAccessImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
+import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 
 /**
  * A registry allowing users to define the default {@link ComponentTuplizer} class to use per {@link EntityMode}.
  *
  * @author Steve Ebersole
  */
 public class ComponentTuplizerFactory implements Serializable {
 	private static final Class[] COMPONENT_TUP_CTOR_SIG = new Class[] { Component.class };
 
 	private Map<EntityMode,Class<? extends ComponentTuplizer>> defaultImplClassByMode = buildBaseMapping();
 
+	private final ClassLoaderAccess classLoaderAccess;
+
+	public ComponentTuplizerFactory(MetadataBuildingOptions metadataBuildingOptions) {
+		classLoaderAccess = new ClassLoaderAccessImpl(
+				metadataBuildingOptions.getTempClassLoader(),
+				metadataBuildingOptions.getServiceRegistry().getService( ClassLoaderService.class )
+		);
+	}
+
 	/**
 	 * Method allowing registration of the tuplizer class to use as default for a particular entity-mode.
 	 *
 	 * @param entityMode The entity-mode for which to register the tuplizer class
 	 * @param tuplizerClass The class to use as the default tuplizer for the given entity-mode.
 	 */
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public void registerDefaultTuplizerClass(EntityMode entityMode, Class<? extends ComponentTuplizer> tuplizerClass) {
 		assert isComponentTuplizerImplementor( tuplizerClass )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] does not implement " + ComponentTuplizer.class.getName();
 		assert hasProperConstructor( tuplizerClass )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] is not properly instantiatable";
 
 		defaultImplClassByMode.put( entityMode, tuplizerClass );
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
 	 * @param tuplizerClassName The name of the tuplizer class to instantiate
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If class name cannot be resolved to a class reference, or if the
 	 * {@link Constructor#newInstance} call fails.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public ComponentTuplizer constructTuplizer(String tuplizerClassName, Component metadata) {
 		try {
-			Class<? extends ComponentTuplizer> tuplizerClass = ReflectHelper.classForName( tuplizerClassName );
+			Class<? extends ComponentTuplizer> tuplizerClass = classLoaderAccess.classForName( tuplizerClassName );
 			return constructTuplizer( tuplizerClass, metadata );
 		}
-		catch ( ClassNotFoundException e ) {
+		catch ( ClassLoadingException e ) {
 			throw new HibernateException( "Could not locate specified tuplizer class [" + tuplizerClassName + "]" );
 		}
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
 	 * @param tuplizerClass The tuplizer class to instantiate
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException if the {@link java.lang.reflect.Constructor#newInstance} call fails.
 	 */
 	public ComponentTuplizer constructTuplizer(Class<? extends ComponentTuplizer> tuplizerClass, Component metadata) {
 		Constructor<? extends ComponentTuplizer> constructor = getProperConstructor( tuplizerClass );
 		assert constructor != null : "Unable to locate proper constructor for tuplizer [" + tuplizerClass.getName() + "]";
 		try {
 			return constructor.newInstance( metadata );
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Unable to instantiate default tuplizer [" + tuplizerClass.getName() + "]", t );
 		}
 	}
 
 	/**
 	 * Construct am instance of the default tuplizer for the given entity-mode.
 	 *
 	 * @param entityMode The entity mode for which to build a default tuplizer.
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If no default tuplizer found for that entity-mode; may be re-thrown from
 	 * {@link #constructTuplizer} too.
 	 */
 	public ComponentTuplizer constructDefaultTuplizer(EntityMode entityMode, Component metadata) {
 		Class<? extends ComponentTuplizer> tuplizerClass = defaultImplClassByMode.get( entityMode );
 		if ( tuplizerClass == null ) {
 			throw new HibernateException( "could not determine default tuplizer class to use [" + entityMode + "]" );
 		}
 
 		return constructTuplizer( tuplizerClass, metadata );
 	}
 
 	private boolean isComponentTuplizerImplementor(Class tuplizerClass) {
 		return ReflectHelper.implementsInterface( tuplizerClass, ComponentTuplizer.class );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private boolean hasProperConstructor(Class tuplizerClass) {
 		return getProperConstructor( tuplizerClass ) != null;
 	}
 
+	@SuppressWarnings("unchecked")
 	private Constructor<? extends ComponentTuplizer> getProperConstructor(Class<? extends ComponentTuplizer> clazz) {
 		Constructor<? extends ComponentTuplizer> constructor = null;
 		try {
 			constructor = clazz.getDeclaredConstructor( COMPONENT_TUP_CTOR_SIG );
 			try {
 				constructor.setAccessible( true );
 			}
 			catch ( SecurityException e ) {
 				constructor = null;
 			}
 		}
 		catch ( NoSuchMethodException ignore ) {
 		}
 
 		return constructor;
 	}
 
 	private static Map<EntityMode,Class<? extends ComponentTuplizer>> buildBaseMapping() {
 		Map<EntityMode,Class<? extends ComponentTuplizer>> map = new ConcurrentHashMap<EntityMode,Class<? extends ComponentTuplizer>>();
 		map.put( EntityMode.POJO, PojoComponentTuplizer.class );
 		map.put( EntityMode.MAP, DynamicMapComponentTuplizer.class );
 		return map;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/DynamicMapComponentTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/DynamicMapComponentTuplizer.java
index c94d0c7d4f..295fdd88fe 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/DynamicMapComponentTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/DynamicMapComponentTuplizer.java
@@ -1,51 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.component;
 import java.util.Map;
 
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMapImpl;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.tuple.DynamicMapInstantiator;
 import org.hibernate.tuple.Instantiator;
 
 /**
  * A {@link ComponentTuplizer} specific to the dynamic-map entity mode.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class DynamicMapComponentTuplizer extends AbstractComponentTuplizer {
 
 	public Class getMappedClass() {
 		return Map.class;
 	}
 
 	protected Instantiator buildInstantiator(Component component) {
 		return new DynamicMapInstantiator();
 	}
 
 	public DynamicMapComponentTuplizer(Component component) {
 		super(component);
 	}
 
-	private PropertyAccessor buildPropertyAccessor(Property property) {
-		return PropertyAccessorFactory.getDynamicMapPropertyAccessor();
-	}
-
 	protected Getter buildGetter(Component component, Property prop) {
-		return buildPropertyAccessor(prop).getGetter( null, prop.getName() );
+		return PropertyAccessStrategyMapImpl.INSTANCE.buildPropertyAccess( null, prop.getName() ).getGetter();
 	}
 
 	protected Setter buildSetter(Component component, Property prop) {
-		return buildPropertyAccessor(prop).getSetter( null, prop.getName() );
+		return PropertyAccessStrategyMapImpl.INSTANCE.buildPropertyAccess( null, prop.getName() ).getSetter();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/PojoComponentTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/PojoComponentTuplizer.java
index 1458d69eea..4eb801485c 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/PojoComponentTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/PojoComponentTuplizer.java
@@ -1,174 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.component;
 import java.io.Serializable;
 import java.lang.reflect.Method;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.bytecode.spi.BasicProxyFactory;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
-import org.hibernate.property.BackrefPropertyAccessor;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBasicImpl;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.PojoInstantiator;
 
 /**
  * A {@link ComponentTuplizer} specific to the pojo entity mode.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class PojoComponentTuplizer extends AbstractComponentTuplizer {
 	private final Class componentClass;
 	private ReflectionOptimizer optimizer;
 	private final Getter parentGetter;
 	private final Setter parentSetter;
 
 	public PojoComponentTuplizer(Component component) {
 		super( component );
 
 		this.componentClass = component.getComponentClass();
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[i].getMethodName();
 			setterNames[i] = setters[i].getMethodName();
 			propTypes[i] = getters[i].getReturnType();
 		}
 
 		final String parentPropertyName = component.getParentProperty();
 		if ( parentPropertyName == null ) {
 			parentSetter = null;
 			parentGetter = null;
 		}
 		else {
-			PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( null );
-			parentSetter = pa.getSetter( componentClass, parentPropertyName );
-			parentGetter = pa.getGetter( componentClass, parentPropertyName );
+			final ServiceRegistry serviceRegistry =
+					component.getMetadata().getMetadataBuildingOptions().getServiceRegistry();
+			final PropertyAccess propertyAccess = PropertyAccessStrategyBasicImpl.INSTANCE.buildPropertyAccess(
+					componentClass,
+					parentPropertyName
+			);
+			parentSetter = propertyAccess.getSetter();
+			parentGetter = propertyAccess.getGetter();
 		}
 
 		if ( hasCustomAccessors || !Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// TODO: here is why we need to make bytecode provider global :(
 			// TODO : again, fix this after HHH-1907 is complete
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
 					componentClass, getterNames, setterNames, propTypes
 			);
 		}
 	}
 
 	public Class getMappedClass() {
 		return componentClass;
 	}
 
 	public Object[] getPropertyValues(Object component) throws HibernateException {
-		if ( component == BackrefPropertyAccessor.UNKNOWN ) {
+		if ( component == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 			return new Object[propertySpan];
 		}
 		else if ( optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return optimizer.getAccessOptimizer().getPropertyValues( component );
 		}
 		else {
 			return super.getPropertyValues( component );
 		}
 	}
 
 	public void setPropertyValues(Object component, Object[] values) throws HibernateException {
 		if ( optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			optimizer.getAccessOptimizer().setPropertyValues( component, values );
 		}
 		else {
 			super.setPropertyValues( component, values );
 		}
 	}
 
 	public Object getParent(Object component) {
 		return parentGetter.get( component );
 	}
 
 	public boolean hasParentProperty() {
 		return parentGetter != null;
 	}
 
 	public boolean isMethodOf(Method method) {
 		for ( int i = 0; i < propertySpan; i++ ) {
 			final Method getterMethod = getters[i].getMethod();
 			if ( getterMethod != null && getterMethod.equals( method ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	public void setParent(Object component, Object parent, SessionFactoryImplementor factory) {
 		parentSetter.set( component, parent, factory );
 	}
 
 	protected Instantiator buildInstantiator(Component component) {
 		if ( component.isEmbedded() && ReflectHelper.isAbstractClass( component.getComponentClass() ) ) {
 			return new ProxiedInstantiator( component );
 		}
 		if ( optimizer == null ) {
 			return new PojoInstantiator( component, null );
 		}
 		else {
 			return new PojoInstantiator( component, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	protected Getter buildGetter(Component component, Property prop) {
 		return prop.getGetter( component.getComponentClass() );
 	}
 
 	protected Setter buildSetter(Component component, Property prop) {
 		return prop.getSetter( component.getComponentClass() );
 	}
 
 	private static class ProxiedInstantiator implements Instantiator {
 		private final Class proxiedClass;
 		private final BasicProxyFactory factory;
 
 		public ProxiedInstantiator(Component component) {
 			proxiedClass = component.getComponentClass();
 			if ( proxiedClass.isInterface() ) {
 				factory = Environment.getBytecodeProvider()
 						.getProxyFactoryFactory()
 						.buildBasicProxyFactory( null, new Class[] { proxiedClass } );
 			}
 			else {
 				factory = Environment.getBytecodeProvider()
 						.getProxyFactoryFactory()
 						.buildBasicProxyFactory( proxiedClass, null );
 			}
 		}
 
 		public Object instantiate(Serializable id) {
 			throw new AssertionFailure( "ProxiedInstantiator can only be used to instantiate component" );
 		}
 
 		public Object instantiate() {
 			return factory.getProxy();
 		}
 
 		public boolean isInstance(Object object) {
 			return proxiedClass.isInstance( object );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
index 4a7037e07f..5ecd0e7d8c 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
@@ -1,712 +1,712 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.entity;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PersistEvent;
 import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.id.Assigned;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.NonIdentifierAttribute;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 import static org.hibernate.internal.CoreLogging.messageLogger;
 
 
 /**
  * Support for tuplizers relating to entities.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public abstract class AbstractEntityTuplizer implements EntityTuplizer {
 	private static final CoreMessageLogger LOG = messageLogger( AbstractEntityTuplizer.class );
 
 	//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!
 
 	private final EntityMetamodel entityMetamodel;
 
 	private final Getter idGetter;
 	private final Setter idSetter;
 
 	protected final Getter[] getters;
 	protected final Setter[] setters;
 	protected final int propertySpan;
 	protected final boolean hasCustomAccessors;
 	private final Instantiator instantiator;
 	private final ProxyFactory proxyFactory;
 	private final CompositeType identifierMapperType;
 
 	public Type getIdentifierMapperType() {
 		return identifierMapperType;
 	}
 
 	/**
 	 * Build an appropriate Getter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Getter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 *
 	 * @return An appropriate Getter instance.
 	 */
 	protected abstract Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Setter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Setter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 *
 	 * @return An appropriate Setter instance.
 	 */
 	protected abstract Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Instantiator for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 *
 	 * @return An appropriate Instantiator instance.
 	 */
 	protected abstract Instantiator buildInstantiator(PersistentClass mappingInfo);
 
 	/**
 	 * Build an appropriate ProxyFactory for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @param idGetter The constructed Getter relating to the entity's id property.
 	 * @param idSetter The constructed Setter relating to the entity's id property.
 	 *
 	 * @return An appropriate ProxyFactory instance.
 	 */
 	protected abstract ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter);
 
 	/**
 	 * Constructs a new AbstractEntityTuplizer instance.
 	 *
 	 * @param entityMetamodel The "interpreted" information relating to the mapped entity.
 	 * @param mappingInfo The parsed "raw" mapping data relating to the given entity.
 	 */
 	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
 		this.entityMetamodel = entityMetamodel;
 
 		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
 			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 		}
 		else {
 			idGetter = null;
 			idSetter = null;
 		}
 
 		propertySpan = entityMetamodel.getPropertySpan();
 
 		getters = new Getter[propertySpan];
 		setters = new Setter[propertySpan];
 
 		Iterator itr = mappingInfo.getPropertyClosureIterator();
 		boolean foundCustomAccessor = false;
 		int i = 0;
 		while ( itr.hasNext() ) {
 			//TODO: redesign how PropertyAccessors are acquired...
 			Property property = (Property) itr.next();
 			getters[i] = buildPropertyGetter( property, mappingInfo );
 			setters[i] = buildPropertySetter( property, mappingInfo );
 			if ( !property.isBasicPropertyAccessor() ) {
 				foundCustomAccessor = true;
 			}
 			i++;
 		}
 		hasCustomAccessors = foundCustomAccessor;
 
 		instantiator = buildInstantiator( mappingInfo );
 
 		if ( entityMetamodel.isLazy() ) {
 			proxyFactory = buildProxyFactory( mappingInfo, idGetter, idSetter );
 			if ( proxyFactory == null ) {
 				entityMetamodel.setLazy( false );
 			}
 		}
 		else {
 			proxyFactory = null;
 		}
 
 		Component mapper = mappingInfo.getIdentifierMapper();
 		if ( mapper == null ) {
 			identifierMapperType = null;
 			mappedIdentifierValueMarshaller = null;
 		}
 		else {
 			identifierMapperType = (CompositeType) mapper.getType();
 			mappedIdentifierValueMarshaller = buildMappedIdentifierValueMarshaller(
 					(ComponentType) entityMetamodel.getIdentifierProperty().getType(),
 					(ComponentType) identifierMapperType
 			);
 		}
 	}
 
 	/**
 	 * Retreives the defined entity-name for the tuplized entity.
 	 *
 	 * @return The entity-name.
 	 */
 	protected String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	/**
 	 * Retrieves the defined entity-names for any subclasses defined for this
 	 * entity.
 	 *
 	 * @return Any subclass entity-names.
 	 */
 	protected Set getSubclassEntityNames() {
 		return entityMetamodel.getSubclassEntityNames();
 	}
 
 	@Override
 	public Serializable getIdentifier(Object entity) throws HibernateException {
 		return getIdentifier( entity, null );
 	}
 
 	@Override
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		final Object id;
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			id = entity;
 		}
 		else if ( HibernateProxy.class.isInstance( entity ) ) {
 			id = ( (HibernateProxy) entity ).getHibernateLazyInitializer().getIdentifier();
 		}
 		else {
 			if ( idGetter == null ) {
 				if ( identifierMapperType == null ) {
 					throw new HibernateException( "The class has no identifier property: " + getEntityName() );
 				}
 				else {
 					id = mappedIdentifierValueMarshaller.getIdentifier( entity, getEntityMode(), session );
 				}
 			}
 			else {
 				id = idGetter.get( entity );
 			}
 		}
 
 		try {
 			return (Serializable) id;
 		}
 		catch (ClassCastException cce) {
 			StringBuilder msg = new StringBuilder( "Identifier classes must be serializable. " );
 			if ( id != null ) {
 				msg.append( id.getClass().getName() ).append( " is not serializable. " );
 			}
 			if ( cce.getMessage() != null ) {
 				msg.append( cce.getMessage() );
 			}
 			throw new ClassCastException( msg.toString() );
 		}
 	}
 
 	@Override
 	public void setIdentifier(Object entity, Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		setIdentifier( entity, id, null );
 	}
 
 	@Override
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			if ( entity != id ) {
 				CompositeType copier = (CompositeType) entityMetamodel.getIdentifierProperty().getType();
 				copier.setPropertyValues( entity, copier.getPropertyValues( id, getEntityMode() ), getEntityMode() );
 			}
 		}
 		else if ( idSetter != null ) {
 			idSetter.set( entity, id, getFactory() );
 		}
 		else if ( identifierMapperType != null ) {
 			mappedIdentifierValueMarshaller.setIdentifier( entity, id, getEntityMode(), session );
 		}
 	}
 
 	private static interface MappedIdentifierValueMarshaller {
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session);
 
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session);
 	}
 
 	private final MappedIdentifierValueMarshaller mappedIdentifierValueMarshaller;
 
 	private static MappedIdentifierValueMarshaller buildMappedIdentifierValueMarshaller(
 			ComponentType mappedIdClassComponentType,
 			ComponentType virtualIdComponent) {
 		// so basically at this point we know we have a "mapped" composite identifier
 		// which is an awful way to say that the identifier is represented differently
 		// in the entity and in the identifier value.  The incoming value should
 		// be an instance of the mapped identifier class (@IdClass) while the incoming entity
 		// should be an instance of the entity class as defined by metamodel.
 		//
 		// However, even within that we have 2 potential scenarios:
 		//		1) @IdClass types and entity @Id property types match
 		//			- return a NormalMappedIdentifierValueMarshaller
 		//		2) They do not match
 		//			- return a IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller
 		boolean wereAllEquivalent = true;
 		// the sizes being off is a much bigger problem that should have been caught already...
 		for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 			if ( virtualIdComponent.getSubtypes()[i].isEntityType()
 					&& !mappedIdClassComponentType.getSubtypes()[i].isEntityType() ) {
 				wereAllEquivalent = false;
 				break;
 			}
 		}
 
 		return wereAllEquivalent
 				? new NormalMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType )
 				: new IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller(
 				virtualIdComponent,
 				mappedIdClassComponentType
 		);
 	}
 
 	private static class NormalMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private NormalMappedIdentifierValueMarshaller(
 				ComponentType virtualIdComponent,
 				ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		@Override
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			virtualIdComponent.setPropertyValues(
 					entity,
 					mappedIdentifierType.getPropertyValues( id, session ),
 					entityMode
 			);
 		}
 	}
 
 	private static class IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller
 			implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller(
 				ComponentType virtualIdComponent,
 				ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		@Override
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			final Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			final Type[] subTypes = virtualIdComponent.getSubtypes();
 			final Type[] copierSubTypes = mappedIdentifierType.getSubtypes();
 			final Iterable<PersistEventListener> persistEventListeners = persistEventListeners( session );
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			final int length = subTypes.length;
 			for ( int i = 0; i < length; i++ ) {
 				if ( propertyValues[i] == null ) {
 					throw new HibernateException( "No part of a composite identifier may be null" );
 				}
 				//JPA 2 @MapsId + @IdClass points to the pk of the entity
 				if ( subTypes[i].isAssociationType() && !copierSubTypes[i].isAssociationType() ) {
 					// we need a session to handle this use case
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final Object subId;
 					if ( HibernateProxy.class.isInstance( propertyValues[i] ) ) {
 						subId = ( (HibernateProxy) propertyValues[i] ).getHibernateLazyInitializer().getIdentifier();
 					}
 					else {
 						EntityEntry pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 						if ( pcEntry != null ) {
 							subId = pcEntry.getId();
 						}
 						else {
 							LOG.debug( "Performing implicit derived identity cascade" );
 							final PersistEvent event = new PersistEvent(
 									null,
 									propertyValues[i],
 									(EventSource) session
 							);
 							for ( PersistEventListener listener : persistEventListeners ) {
 								listener.onPersist( event );
 							}
 							pcEntry = persistenceContext.getEntry( propertyValues[i] );
 							if ( pcEntry == null || pcEntry.getId() == null ) {
 								throw new HibernateException( "Unable to process implicit derived identity cascade" );
 							}
 							else {
 								subId = pcEntry.getId();
 							}
 						}
 					}
 					propertyValues[i] = subId;
 				}
 			}
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			final Object[] extractedValues = mappedIdentifierType.getPropertyValues( id, entityMode );
 			final Object[] injectionValues = new Object[extractedValues.length];
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 				final Type virtualPropertyType = virtualIdComponent.getSubtypes()[i];
 				final Type idClassPropertyType = mappedIdentifierType.getSubtypes()[i];
 				if ( virtualPropertyType.isEntityType() && !idClassPropertyType.isEntityType() ) {
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final String associatedEntityName = ( (EntityType) virtualPropertyType ).getAssociatedEntityName();
 					final EntityKey entityKey = session.generateEntityKey(
 							(Serializable) extractedValues[i],
 							session.getFactory().getEntityPersister( associatedEntityName )
 					);
 					// it is conceivable there is a proxy, so check that first
 					Object association = persistenceContext.getProxy( entityKey );
 					if ( association == null ) {
 						// otherwise look for an initialized version
 						association = persistenceContext.getEntity( entityKey );
 					}
 					injectionValues[i] = association;
 				}
 				else {
 					injectionValues[i] = extractedValues[i];
 				}
 			}
 			virtualIdComponent.setPropertyValues( entity, injectionValues, entityMode );
 		}
 	}
 
 	private static Iterable<PersistEventListener> persistEventListeners(SessionImplementor session) {
 		return session
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( EventType.PERSIST )
 				.listeners();
 	}
 
 	@Override
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion) {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	@Override
 	public void resetIdentifier(
 			Object entity,
 			Serializable currentId,
 			Object currentVersion,
 			SessionImplementor session) {
 		//noinspection StatementWithEmptyBody
 		if ( entityMetamodel.getIdentifierProperty().getIdentifierGenerator() instanceof Assigned ) {
 		}
 		else {
 			//reset the id
 			Serializable result = entityMetamodel.getIdentifierProperty()
 					.getUnsavedValue()
 					.getDefaultValue( currentId );
 			setIdentifier( entity, result, session );
 			//reset the version
 			VersionProperty versionProperty = entityMetamodel.getVersionProperty();
 			if ( entityMetamodel.isVersioned() ) {
 				setPropertyValue(
 						entity,
 						entityMetamodel.getVersionPropertyIndex(),
 						versionProperty.getUnsavedValue().getDefaultValue( currentVersion )
 				);
 			}
 		}
 	}
 
 	@Override
 	public Object getVersion(Object entity) throws HibernateException {
 		if ( !entityMetamodel.isVersioned() ) {
 			return null;
 		}
 		return getters[entityMetamodel.getVersionPropertyIndex()].get( entity );
 	}
 
 	protected boolean shouldGetAllProperties(Object entity) {
 		return !hasUninitializedLazyProperties( entity );
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object entity) throws HibernateException {
 		boolean getAll = shouldGetAllProperties( entity );
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
 			if ( getAll || !property.isLazy() ) {
 				result[j] = getters[j].get( entity );
 			}
 			else {
 				result[j] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 			}
 		}
 		return result;
 	}
 
 	@Override
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 			throws HibernateException {
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			result[j] = getters[j].getForInsert( entity, mergeMap, session );
 		}
 		return result;
 	}
 
 	@Override
 	public Object getPropertyValue(Object entity, int i) throws HibernateException {
 		return getters[i].get( entity );
 	}
 
 	@Override
 	public Object getPropertyValue(Object entity, String propertyPath) throws HibernateException {
 		int loc = propertyPath.indexOf( '.' );
 		String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		//final int index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		Integer index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		if ( index == null ) {
 			propertyPath = PropertyPath.IDENTIFIER_MAPPER_PROPERTY + "." + propertyPath;
 			loc = propertyPath.indexOf( '.' );
 			basePropertyName = loc > 0
 					? propertyPath.substring( 0, loc )
 					: propertyPath;
 		}
 		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		final Object baseValue = getPropertyValue( entity, index );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) entityMetamodel.getPropertyTypes()[index],
 					baseValue,
 					propertyPath.substring( loc + 1 )
 			);
 		}
 		else {
 			return baseValue;
 		}
 	}
 
 	/**
 	 * Extract a component property value.
 	 *
 	 * @param type The component property types.
 	 * @param component The component instance itself.
 	 * @param propertyPath The property path for the property to be extracted.
 	 *
 	 * @return The property value extracted.
 	 */
 	protected Object getComponentValue(ComponentType type, Object component, String propertyPath) {
 		final int loc = propertyPath.indexOf( '.' );
 		final String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		final int index = findSubPropertyIndex( type, basePropertyName );
 		final Object baseValue = type.getPropertyValue( component, index );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) type.getSubtypes()[index],
 					baseValue,
 					propertyPath.substring( loc + 1 )
 			);
 		}
 		else {
 			return baseValue;
 		}
 
 	}
 
 	private int findSubPropertyIndex(ComponentType type, String subPropertyName) {
 		final String[] propertyNames = type.getPropertyNames();
 		for ( int index = 0; index < propertyNames.length; index++ ) {
 			if ( subPropertyName.equals( propertyNames[index] ) ) {
 				return index;
 			}
 		}
 		throw new MappingException( "component property not found: " + subPropertyName );
 	}
 
 	@Override
 	public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		boolean setAll = !entityMetamodel.hasLazyProperties();
 
 		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
 			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 				setters[j].set( entity, values[j], getFactory() );
 			}
 		}
 	}
 
 	@Override
 	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException {
 		setters[i].set( entity, value, getFactory() );
 	}
 
 	@Override
 	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException {
 		setters[entityMetamodel.getPropertyIndex( propertyName )].set( entity, value, getFactory() );
 	}
 
 	@Override
 	public final Object instantiate(Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		return instantiate( id, null );
 	}
 
 	@Override
 	public final Object instantiate(Serializable id, SessionImplementor session) {
 		Object result = getInstantiator().instantiate( id );
 		if ( id != null ) {
 			setIdentifier( result, id, session );
 		}
 		return result;
 	}
 
 	@Override
 	public final Object instantiate() throws HibernateException {
 		return instantiate( null, null );
 	}
 
 	@Override
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 	}
 
 	@Override
 	public boolean hasUninitializedLazyProperties(Object entity) {
 		// the default is to simply not lazy fetch properties for now...
 		return false;
 	}
 
 	@Override
 	public final boolean isInstance(Object object) {
 		return getInstantiator().isInstance( object );
 	}
 
 	@Override
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	@Override
 	public final Object createProxy(Serializable id, SessionImplementor session)
 			throws HibernateException {
 		return getProxyFactory().getProxy( id, session );
 	}
 
 	@Override
 	public boolean isLifecycleImplementor() {
 		return false;
 	}
 
 	protected final EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	protected final SessionFactoryImplementor getFactory() {
 		return entityMetamodel.getSessionFactory();
 	}
 
 	protected final Instantiator getInstantiator() {
 		return instantiator;
 	}
 
 	protected final ProxyFactory getProxyFactory() {
 		return proxyFactory;
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + getEntityMetamodel().getName() + ')';
 	}
 
 	@Override
 	public Getter getIdentifierGetter() {
 		return idGetter;
 	}
 
 	@Override
 	public Getter getVersionGetter() {
 		if ( getEntityMetamodel().isVersioned() ) {
 			return getGetter( getEntityMetamodel().getVersionPropertyIndex() );
 		}
 		return null;
 	}
 
 	@Override
 	public Getter getGetter(int i) {
 		return getters[i];
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
index e151c4ef99..0d0cfe62e5 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
@@ -1,146 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.entity;
 
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.property.access.internal.PropertyAccessStrategyMapImpl;
+import org.hibernate.property.access.spi.PropertyAccess;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.proxy.map.MapProxyFactory;
 import org.hibernate.tuple.DynamicMapInstantiator;
 import org.hibernate.tuple.Instantiator;
 
 /**
  * An {@link EntityTuplizer} specific to the dynamic-map entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class DynamicMapEntityTuplizer extends AbstractEntityTuplizer {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DynamicMapEntityTuplizer.class );
 
 	DynamicMapEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
 	@Override
 	public EntityMode getEntityMode() {
 		return EntityMode.MAP;
 	}
 
-	private PropertyAccessor buildPropertyAccessor(Property mappedProperty) {
+	private PropertyAccess buildPropertyAccess(Property mappedProperty) {
 		if ( mappedProperty.isBackRef() ) {
-			return mappedProperty.getPropertyAccessor( null );
+			return mappedProperty.getPropertyAccessStrategy( null ).buildPropertyAccess( null, mappedProperty.getName() );
 		}
 		else {
-			return PropertyAccessorFactory.getDynamicMapPropertyAccessor();
+			return PropertyAccessStrategyMapImpl.INSTANCE.buildPropertyAccess( null, mappedProperty.getName() );
 		}
 	}
 
 	@Override
 	protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
-		return buildPropertyAccessor( mappedProperty ).getGetter( null, mappedProperty.getName() );
+		return buildPropertyAccess( mappedProperty ).getGetter();
 	}
 
 	@Override
 	protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
-		return buildPropertyAccessor( mappedProperty ).getSetter( null, mappedProperty.getName() );
+		return buildPropertyAccess( mappedProperty ).getSetter();
 	}
 
 	@Override
 	protected Instantiator buildInstantiator(PersistentClass mappingInfo) {
 		return new DynamicMapInstantiator( mappingInfo );
 	}
 
 	@Override
 	protected ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter) {
 
 		ProxyFactory pf = new MapProxyFactory();
 		try {
 			//TODO: design new lifecycle for ProxyFactory
 			pf.postInstantiate(
 					getEntityName(),
 					null,
 					null,
 					null,
 					null,
 					null
 			);
 		}
 		catch (HibernateException he) {
 			LOG.unableToCreateProxyFactory( getEntityName(), he );
 			pf = null;
 		}
 		return pf;
 	}
 
 	@Override
 	public Class getMappedClass() {
 		return Map.class;
 	}
 
 	@Override
 	public Class getConcreteProxyClass() {
 		return Map.class;
 	}
 
 	@Override
 	public boolean isInstrumented() {
 		return false;
 	}
 
 	@Override
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return new EntityNameResolver[] {BasicEntityNameResolver.INSTANCE};
 	}
 
 	@Override
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		return extractEmbeddedEntityName( (Map) entityInstance );
 	}
 
 	public static String extractEmbeddedEntityName(Map entity) {
 		return (String) entity.get( DynamicMapInstantiator.KEY );
 	}
 
 	public static class BasicEntityNameResolver implements EntityNameResolver {
 		public static final BasicEntityNameResolver INSTANCE = new BasicEntityNameResolver();
 
 		@Override
 		public String resolveEntityName(Object entity) {
 			if ( !Map.class.isInstance( entity ) ) {
 				return null;
 			}
 			final String entityName = extractEmbeddedEntityName( (Map) entity );
 			if ( entityName == null ) {
 				throw new HibernateException( "Could not determine type of dynamic map entity" );
 			}
 			return entityName;
 		}
 
 		@Override
 		public boolean equals(Object obj) {
 			return getClass().equals( obj.getClass() );
 		}
 
 		@Override
 		public int hashCode() {
 			return getClass().hashCode();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
index a84d34f1c6..59432a5299 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
@@ -1,291 +1,291 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.entity;
 import java.io.Serializable;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.tuple.Tuplizer;
 
 /**
  * Defines further responsibilities reagarding tuplization based on
  * a mapped entity.
  * <p/>
  * EntityTuplizer implementations should have the following constructor signatures:
  *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.mapping.PersistentClass)
  *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.metamodel.binding.EntityBinding)
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface EntityTuplizer extends Tuplizer {
 	/**
 	 * Return the entity-mode handled by this tuplizer instance.
 	 *
 	 * @return The entity-mode
 	 */
 	EntityMode getEntityMode();
 
     /**
      * Create an entity instance initialized with the given identifier.
      *
      * @param id The identifier value for the entity to be instantiated.
      * @return The instantiated entity.
      * @throws HibernateException
 	 *
 	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead.
      */
 	@Deprecated
 	@SuppressWarnings( {"JavaDoc"})
 	Object instantiate(Serializable id) throws HibernateException;
 
     /**
      * Create an entity instance initialized with the given identifier.
      *
      * @param id The identifier value for the entity to be instantiated.
 	 * @param session The session from which is requests originates
 	 *
      * @return The instantiated entity.
      */
 	Object instantiate(Serializable id, SessionImplementor session);
 
     /**
      * Extract the identifier value from the given entity.
      *
      * @param entity The entity from which to extract the identifier value.
 	 *
      * @return The identifier value.
 	 *
      * @throws HibernateException If the entity does not define an identifier property, or an
      * error occurs accessing its value.
 	 *
 	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
      */
 	@Deprecated
 	Serializable getIdentifier(Object entity) throws HibernateException;
 
     /**
      * Extract the identifier value from the given entity.
      *
      * @param entity The entity from which to extract the identifier value.
 	 * @param session The session from which is requests originates
 	 *
      * @return The identifier value.
      */
 	Serializable getIdentifier(Object entity, SessionImplementor session);
 
     /**
      * Inject the identifier value into the given entity.
      * </p>
      * Has no effect if the entity does not define an identifier property
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 *
 	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
      */
 	@Deprecated
 	@SuppressWarnings( {"JavaDoc"})
 	void setIdentifier(Object entity, Serializable id) throws HibernateException;
 
     /**
      * Inject the identifier value into the given entity.
      * </p>
      * Has no effect if the entity does not define an identifier property
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 * @param session The session from which is requests originates
      */
 	void setIdentifier(Object entity, Serializable id, SessionImplementor session);
 
 	/**
 	 * Inject the given identifier and version into the entity, in order to
 	 * "roll back" to their original values.
 	 *
 	 * @param entity The entity for which to reset the id/version values
 	 * @param currentId The identifier value to inject into the entity.
 	 * @param currentVersion The version value to inject into the entity.
 	 *
 	 * @deprecated Use {@link #resetIdentifier(Object, Serializable, Object, SessionImplementor)} instead
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	void resetIdentifier(Object entity, Serializable currentId, Object currentVersion);
 
 	/**
 	 * Inject the given identifier and version into the entity, in order to
 	 * "roll back" to their original values.
 	 *
 	 * @param entity The entity for which to reset the id/version values
 	 * @param currentId The identifier value to inject into the entity.
 	 * @param currentVersion The version value to inject into the entity.
 	 * @param session The session from which the request originated
 	 */
 	void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session);
 
     /**
      * Extract the value of the version property from the given entity.
      *
      * @param entity The entity from which to extract the version value.
      * @return The value of the version property, or null if not versioned.
 	 * @throws HibernateException Indicates a problem accessing the version property
      */
 	Object getVersion(Object entity) throws HibernateException;
 
 	/**
 	 * Inject the value of a particular property.
 	 *
 	 * @param entity The entity into which to inject the value.
 	 * @param i The property's index.
 	 * @param value The property value to inject.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	void setPropertyValue(Object entity, int i, Object value) throws HibernateException;
 
 	/**
 	 * Inject the value of a particular property.
 	 *
 	 * @param entity The entity into which to inject the value.
 	 * @param propertyName The name of the property.
 	 * @param value The property value to inject.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException;
 
 	/**
 	 * Extract the values of the insertable properties of the entity (including backrefs)
 	 *
 	 * @param entity The entity from which to extract.
 	 * @param mergeMap a map of instances being merged to merged instances
 	 * @param session The session in which the resuest is being made.
 	 * @return The insertable property values.
 	 * @throws HibernateException Indicates a problem access the properties
 	 */
 	Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Extract the value of a particular property from the given entity.
 	 *
 	 * @param entity The entity from which to extract the property value.
 	 * @param propertyName The name of the property for which to extract the value.
 	 * @return The current value of the given property on the given entity.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	Object getPropertyValue(Object entity, String propertyName) throws HibernateException;
 
     /**
      * Called just after the entities properties have been initialized.
      *
      * @param entity The entity being initialized.
      * @param lazyPropertiesAreUnfetched Are defined lazy properties currently unfecthed
      * @param session The session initializing this entity.
      */
 	void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session);
 
 	/**
 	 * Does this entity, for this mode, present a possibility for proxying?
 	 *
 	 * @return True if this tuplizer can generate proxies for this entity.
 	 */
 	boolean hasProxy();
 
 	/**
 	 * Generates an appropriate proxy representation of this entity for this
 	 * entity-mode.
 	 *
 	 * @param id The id of the instance for which to generate a proxy.
 	 * @param session The session to which the proxy should be bound.
 	 * @return The generate proxies.
 	 * @throws HibernateException Indicates an error generating the proxy.
 	 */
 	Object createProxy(Serializable id, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Does the {@link #getMappedClass() class} managed by this tuplizer implement
 	 * the {@link org.hibernate.classic.Lifecycle} interface.
 	 *
 	 * @return True if the Lifecycle interface is implemented; false otherwise.
 	 */
 	boolean isLifecycleImplementor();
 
 	/**
 	 * Returns the java class to which generated proxies will be typed.
 	 * <p/>
 	 * todo : look at fully encapsulating {@link org.hibernate.engine.spi.PersistenceContext#narrowProxy} here,
 	 * since that is the only external use of this method
 	 *
 	 * @return The java class to which generated proxies will be typed
 	 */
 	Class getConcreteProxyClass();
 	
     /**
      * Does the given entity instance have any currently uninitialized lazy properties?
      *
      * @param entity The entity to be check for uninitialized lazy properties.
      * @return True if uninitialized lazy properties were found; false otherwise.
      */
 	boolean hasUninitializedLazyProperties(Object entity);
 	
 	/**
 	 * Is it an instrumented POJO?
 	 *
 	 * @return {@code true} if the entity class is instrumented; {@code false} otherwise.
 	 */
 	boolean isInstrumented();
 
 	/**
 	 * Get any {@link EntityNameResolver EntityNameResolvers} associated with this {@link Tuplizer}.
 	 *
 	 * @return The associated resolvers.  May be null or empty.
 	 */
 	EntityNameResolver[] getEntityNameResolvers();
 
 	/**
 	 * Given an entity instance, determine the most appropriate (most targeted) entity-name which represents it.
 	 * This is called in situations where we already know an entity name for the given entityInstance; we are being
 	 * asked to determine if there is a more appropriate entity-name to use, specifically within an inheritence
 	 * hierarchy.
 	 * <p/>
 	 * For example, consider a case where a user calls <tt>session.update( "Animal", cat );</tt>.  Here, the
 	 * user has explicitly provided <tt>Animal</tt> as the entity-name.  However, they have passed in an instance
 	 * of <tt>Cat</tt> which is a subclass of <tt>Animal</tt>.  In this case, we would return <tt>Cat</tt> as the
 	 * entity-name.
 	 * <p/>
 	 * <tt>null</tt> may be returned from calls to this method.  The meaining of <tt>null</tt> in that case is assumed
 	 * to be that we should use whatever explicit entity-name the user provided (<tt>Animal</tt> rather than <tt>Cat</tt>
 	 * in the example above).
 	 *
 	 * @param entityInstance The entity instance.
 	 * @param factory Reference to the SessionFactory.
 	 *
 	 * @return The most appropriate entity name to use.
 	 *
 	 * @throws HibernateException If we are unable to determine an entity-name within the inheritence hierarchy.
 	 */
 	String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory);
 
 	/**
 	 * Retrieve the getter for the identifier property.  May return null.
 	 *
 	 * @return The getter for the identifier property.
 	 */
 	Getter getIdentifierGetter();
 
 	/**
 	 * Retrieve the getter for the version property.  May return null.
 	 *
 	 * @return The getter for the version property.
 	 */
 	Getter getVersionGetter();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
index ce8241b39a..03a9988753 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
@@ -1,332 +1,332 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.tuple.entity;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.cfg.Environment;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Subclass;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.PojoInstantiator;
 import org.hibernate.type.CompositeType;
 
 /**
  * An {@link EntityTuplizer} specific to the pojo entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class PojoEntityTuplizer extends AbstractEntityTuplizer {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( PojoEntityTuplizer.class );
 
 	private final Class mappedClass;
 	private final Class proxyInterface;
 	private final boolean lifecycleImplementor;
 	private final Set<String> lazyPropertyNames = new HashSet<String>();
 	private final ReflectionOptimizer optimizer;
 	private final boolean isInstrumented;
 
 	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 		this.mappedClass = mappedEntity.getMappedClass();
 		this.proxyInterface = mappedEntity.getProxyInterface();
 		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
 		this.isInstrumented = entityMetamodel.isInstrumented();
 
 		Iterator iter = mappedEntity.getPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property property = (Property) iter.next();
 			if ( property.isLazy() ) {
 				lazyPropertyNames.add( property.getName() );
 			}
 		}
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[i].getMethodName();
 			setterNames[i] = setters[i].getMethodName();
 			propTypes[i] = getters[i].getReturnType();
 		}
 
 		if ( hasCustomAccessors || !Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// todo : YUCK!!!
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
 					mappedClass,
 					getterNames,
 					setterNames,
 					propTypes
 			);
 //			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
 //					mappedClass, getterNames, setterNames, propTypes
 //			);
 		}
 	}
 
 	@Override
 	protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// determine the id getter and setter methods from the proxy interface (if any)
 		// determine all interfaces needed by the resulting proxy
 		
 		/*
 		 * We need to preserve the order of the interfaces they were put into the set, since javassist will choose the
 		 * first one's class-loader to construct the proxy class with. This is also the reason why HibernateProxy.class
 		 * should be the last one in the order (on JBossAS7 its class-loader will be org.hibernate module's class-
 		 * loader, which will not see the classes inside deployed apps.  See HHH-3078
 		 */
 		Set<Class> proxyInterfaces = new java.util.LinkedHashSet<Class>();
 
 		Class mappedClass = persistentClass.getMappedClass();
 		Class proxyInterface = persistentClass.getProxyInterface();
 
 		if ( proxyInterface != null && !mappedClass.equals( proxyInterface ) ) {
 			if ( !proxyInterface.isInterface() ) {
 				throw new MappingException(
 						"proxy must be either an interface, or the class itself: " + getEntityName()
 				);
 			}
 			proxyInterfaces.add( proxyInterface );
 		}
 
 		if ( mappedClass.isInterface() ) {
 			proxyInterfaces.add( mappedClass );
 		}
 
 		Iterator<Subclass> subclasses = persistentClass.getSubclassIterator();
 		while ( subclasses.hasNext() ) {
 			final Subclass subclass = subclasses.next();
 			final Class subclassProxy = subclass.getProxyInterface();
 			final Class subclassClass = subclass.getMappedClass();
 			if ( subclassProxy != null && !subclassClass.equals( subclassProxy ) ) {
 				if ( !subclassProxy.isInterface() ) {
 					throw new MappingException(
 							"proxy must be either an interface, or the class itself: " + subclass.getEntityName()
 					);
 				}
 				proxyInterfaces.add( subclassProxy );
 			}
 		}
 
 		proxyInterfaces.add( HibernateProxy.class );
 
 		Iterator properties = persistentClass.getPropertyIterator();
 		Class clazz = persistentClass.getMappedClass();
 		while ( properties.hasNext() ) {
 			Property property = (Property) properties.next();
 			Method method = property.getGetter( clazz ).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
 				LOG.gettersOfLazyClassesCannotBeFinal( persistentClass.getEntityName(), property.getName() );
 			}
 			method = property.getSetter( clazz ).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
 				LOG.settersOfLazyClassesCannotBeFinal( persistentClass.getEntityName(), property.getName() );
 			}
 		}
 
 		Method idGetterMethod = idGetter == null ? null : idGetter.getMethod();
 		Method idSetterMethod = idSetter == null ? null : idSetter.getMethod();
 
 		Method proxyGetIdentifierMethod = idGetterMethod == null || proxyInterface == null ?
 				null :
 				ReflectHelper.getMethod( proxyInterface, idGetterMethod );
 		Method proxySetIdentifierMethod = idSetterMethod == null || proxyInterface == null ?
 				null :
 				ReflectHelper.getMethod( proxyInterface, idSetterMethod );
 
 		ProxyFactory pf = buildProxyFactoryInternal( persistentClass, idGetter, idSetter );
 		try {
 			pf.postInstantiate(
 					getEntityName(),
 					mappedClass,
 					proxyInterfaces,
 					proxyGetIdentifierMethod,
 					proxySetIdentifierMethod,
 					persistentClass.hasEmbeddedIdentifier() ?
 							(CompositeType) persistentClass.getIdentifier().getType() :
 							null
 			);
 		}
 		catch (HibernateException he) {
 			LOG.unableToCreateProxyFactory( getEntityName(), he );
 			pf = null;
 		}
 		return pf;
 	}
 
 	protected ProxyFactory buildProxyFactoryInternal(
 			PersistentClass persistentClass,
 			Getter idGetter,
 			Setter idSetter) {
 		// TODO : YUCK!!!  fix after HHH-1907 is complete
 		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 //		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 	}
 
 	@Override
 	protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		if ( optimizer == null ) {
 			return new PojoInstantiator( persistentClass, null );
 		}
 		else {
 			return new PojoInstantiator( persistentClass, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	@Override
 	public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		if ( !getEntityMetamodel().hasLazyProperties() && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			setPropertyValuesWithOptimizer( entity, values );
 		}
 		else {
 			super.setPropertyValues( entity, values );
 		}
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object entity) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValues( entity );
 		}
 	}
 
 	@Override
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 			throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValuesToInsert( entity, mergeMap, session );
 		}
 	}
 
 	protected void setPropertyValuesWithOptimizer(Object object, Object[] values) {
 		optimizer.getAccessOptimizer().setPropertyValues( object, values );
 	}
 
 	protected Object[] getPropertyValuesWithOptimizer(Object object) {
 		return optimizer.getAccessOptimizer().getPropertyValues( object );
 	}
 
 	@Override
 	public EntityMode getEntityMode() {
 		return EntityMode.POJO;
 	}
 
 	@Override
 	public Class getMappedClass() {
 		return mappedClass;
 	}
 
 	@Override
 	public boolean isLifecycleImplementor() {
 		return lifecycleImplementor;
 	}
 
 	@Override
 	protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getGetter( mappedEntity.getMappedClass() );
 	}
 
 	@Override
 	protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getSetter( mappedEntity.getMappedClass() );
 	}
 
 	@Override
 	public Class getConcreteProxyClass() {
 		return proxyInterface;
 	}
 
 	//TODO: need to make the majority of this functionality into a top-level support class for custom impl support
 
 	@Override
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		if ( isInstrumented() ) {
 			Set<String> lazyProps = lazyPropertiesAreUnfetched && getEntityMetamodel().hasLazyProperties() ?
 					lazyPropertyNames : null;
 			//TODO: if we support multiple fetch groups, we would need
 			//      to clone the set of lazy properties!
 			FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
 
 			//also clear the fields that are marked as dirty in the dirtyness tracker
 			if ( entity instanceof org.hibernate.engine.spi.SelfDirtinessTracker ) {
 				( (org.hibernate.engine.spi.SelfDirtinessTracker) entity ).$$_hibernate_clearDirtyAttributes();
 			}
 		}
 	}
 
 	@Override
 	public boolean hasUninitializedLazyProperties(Object entity) {
 		if ( getEntityMetamodel().hasLazyProperties() ) {
 			FieldInterceptor callback = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			return callback != null && !callback.isInitialized();
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	public boolean isInstrumented() {
 		return isInstrumented;
 	}
 
 	@Override
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		final Class concreteEntityClass = entityInstance.getClass();
 		if ( concreteEntityClass == getMappedClass() ) {
 			return getEntityName();
 		}
 		else {
 			String entityName = getEntityMetamodel().findEntityNameByEntityClass( concreteEntityClass );
 			if ( entityName == null ) {
 				throw new HibernateException(
 						"Unable to resolve entity name from Class [" + concreteEntityClass.getName() + "]"
 								+ " expected instance/subclass of [" + getEntityName() + "]"
 				);
 			}
 			return entityName;
 		}
 	}
 
 	@Override
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/TypeHelper.java b/hibernate-core/src/main/java/org/hibernate/type/TypeHelper.java
index 70bc9c1054..57dc9f93f9 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/TypeHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/TypeHelper.java
@@ -1,346 +1,347 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.type;
+
 import java.io.Serializable;
 import java.util.Map;
 
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.property.BackrefPropertyAccessor;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;
 import org.hibernate.tuple.NonIdentifierAttribute;
 
 /**
  * Collection of convenience methods relating to operations across arrays of types...
  *
  * @author Steve Ebersole
  */
 public class TypeHelper {
 	/**
 	 * Disallow instantiation
 	 */
 	private TypeHelper() {
 	}
 
 	/**
 	 * Deep copy a series of values from one array to another...
 	 *
 	 * @param values The values to copy (the source)
 	 * @param types The value types
 	 * @param copy an array indicating which values to include in the copy
 	 * @param target The array into which to copy the values
 	 * @param session The originating session
 	 */
 	public static void deepCopy(
 			final Object[] values,
 			final Type[] types,
 			final boolean[] copy,
 			final Object[] target,
 			final SessionImplementor session) {
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( copy[i] ) {
 				if ( values[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY
-					|| values[i] == BackrefPropertyAccessor.UNKNOWN ) {
+					|| values[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 					target[i] = values[i];
 				}
 				else {
 					target[i] = types[i].deepCopy( values[i], session
 						.getFactory() );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Apply the {@link Type#beforeAssemble} operation across a series of values.
 	 *
 	 * @param row The values
 	 * @param types The value types
 	 * @param session The originating session
 	 */
 	public static void beforeAssemble(
 			final Serializable[] row,
 			final Type[] types,
 			final SessionImplementor session) {
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( row[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
-				&& row[i] != BackrefPropertyAccessor.UNKNOWN ) {
+				&& row[i] != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				types[i].beforeAssemble( row[i], session );
 			}
 		}
 	}
 
 	/**
 	 * Apply the {@link Type#assemble} operation across a series of values.
 	 *
 	 * @param row The values
 	 * @param types The value types
 	 * @param session The originating session
 	 * @param owner The entity "owning" the values
 	 * @return The assembled state
 	 */
 	public static Object[] assemble(
 			final Serializable[] row,
 			final Type[] types,
 			final SessionImplementor session,
 			final Object owner) {
 		Object[] assembled = new Object[row.length];
 		for ( int i = 0; i < types.length; i++ ) {
-			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
+			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				assembled[i] = row[i];
 			}
 			else {
 				assembled[i] = types[i].assemble( row[i], session, owner );
 			}
 		}
 		return assembled;
 	}
 
 	/**
 	 * Apply the {@link Type#disassemble} operation across a series of values.
 	 *
 	 * @param row The values
 	 * @param types The value types
 	 * @param nonCacheable An array indicating which values to include in the disassembled state
 	 * @param session The originating session
 	 * @param owner The entity "owning" the values
 	 *
 	 * @return The disassembled state
 	 */
 	public static Serializable[] disassemble(
 			final Object[] row,
 			final Type[] types,
 			final boolean[] nonCacheable,
 			final SessionImplementor session,
 			final Object owner) {
 		Serializable[] disassembled = new Serializable[row.length];
 		for ( int i = 0; i < row.length; i++ ) {
 			if ( nonCacheable!=null && nonCacheable[i] ) {
 				disassembled[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 			}
-			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
+			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				disassembled[i] = (Serializable) row[i];
 			}
 			else {
 				disassembled[i] = types[i].disassemble( row[i], session, owner );
 			}
 		}
 		return disassembled;
 	}
 
 	/**
 	 * Apply the {@link Type#replace} operation across a series of values.
 	 *
 	 * @param original The source of the state
 	 * @param target The target into which to replace the source values.
 	 * @param types The value types
 	 * @param session The originating session
 	 * @param owner The entity "owning" the values
 	 * @param copyCache A map representing a cache of already replaced state
 	 *
 	 * @return The replaced state
 	 */
 	public static Object[] replace(
 			final Object[] original,
 			final Object[] target,
 			final Type[] types,
 			final SessionImplementor session,
 			final Object owner,
 			final Map copyCache) {
 		Object[] copied = new Object[original.length];
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY
-				|| original[i] == BackrefPropertyAccessor.UNKNOWN ) {
+				|| original[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				copied[i] = target[i];
 			}
 			else {
 				copied[i] = types[i].replace( original[i], target[i], session, owner, copyCache );
 			}
 		}
 		return copied;
 	}
 
 	/**
 	 * Apply the {@link Type#replace} operation across a series of values.
 	 *
 	 * @param original The source of the state
 	 * @param target The target into which to replace the source values.
 	 * @param types The value types
 	 * @param session The originating session
 	 * @param owner The entity "owning" the values
 	 * @param copyCache A map representing a cache of already replaced state
 	 * @param foreignKeyDirection FK directionality to be applied to the replacement
 	 *
 	 * @return The replaced state
 	 */
 	public static Object[] replace(
 			final Object[] original,
 			final Object[] target,
 			final Type[] types,
 			final SessionImplementor session,
 			final Object owner,
 			final Map copyCache,
 			final ForeignKeyDirection foreignKeyDirection) {
 		Object[] copied = new Object[original.length];
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY
-				|| original[i] == BackrefPropertyAccessor.UNKNOWN ) {
+				|| original[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				copied[i] = target[i];
 			}
 			else {
 				copied[i] = types[i].replace( original[i], target[i], session, owner, copyCache, foreignKeyDirection );
 			}
 		}
 		return copied;
 	}
 
 	/**
 	 * Apply the {@link Type#replace} operation across a series of values, as long as the corresponding
 	 * {@link Type} is an association.
 	 * <p/>
 	 * If the corresponding type is a component type, then apply {@link Type#replace} across the component
 	 * subtypes but do not replace the component value itself.
 	 *
 	 * @param original The source of the state
 	 * @param target The target into which to replace the source values.
 	 * @param types The value types
 	 * @param session The originating session
 	 * @param owner The entity "owning" the values
 	 * @param copyCache A map representing a cache of already replaced state
 	 * @param foreignKeyDirection FK directionality to be applied to the replacement
 	 *
 	 * @return The replaced state
 	 */
 	public static Object[] replaceAssociations(
 			final Object[] original,
 			final Object[] target,
 			final Type[] types,
 			final SessionImplementor session,
 			final Object owner,
 			final Map copyCache,
 			final ForeignKeyDirection foreignKeyDirection) {
 		Object[] copied = new Object[original.length];
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY
-					|| original[i] == BackrefPropertyAccessor.UNKNOWN ) {
+					|| original[i] == PropertyAccessStrategyBackRefImpl.UNKNOWN ) {
 				copied[i] = target[i];
 			}
 			else if ( types[i].isComponentType() ) {
 				// need to extract the component values and check for subtype replacements...
 				CompositeType componentType = ( CompositeType ) types[i];
 				Type[] subtypes = componentType.getSubtypes();
 				Object[] origComponentValues = original[i] == null ? new Object[subtypes.length] : componentType.getPropertyValues( original[i], session );
 				Object[] targetComponentValues = target[i] == null ? new Object[subtypes.length] : componentType.getPropertyValues( target[i], session );
 				replaceAssociations( origComponentValues, targetComponentValues, subtypes, session, null, copyCache, foreignKeyDirection );
 				copied[i] = target[i];
 			}
 			else if ( !types[i].isAssociationType() ) {
 				copied[i] = target[i];
 			}
 			else {
 				copied[i] = types[i].replace( original[i], target[i], session, owner, copyCache, foreignKeyDirection );
 			}
 		}
 		return copied;
 	}
 
 	/**
 	 * Determine if any of the given field values are dirty, returning an array containing
 	 * indices of the dirty fields.
 	 * <p/>
 	 * If it is determined that no fields are dirty, null is returned.
 	 *
 	 * @param properties The property definitions
 	 * @param currentState The current state of the entity
 	 * @param previousState The baseline state of the entity
 	 * @param includeColumns Columns to be included in the dirty checking, per property
 	 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 	 * @param session The session from which the dirty check request originated.
 	 * 
 	 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 	 */
 	public static int[] findDirty(
 			final NonIdentifierAttribute[] properties,
 			final Object[] currentState,
 			final Object[] previousState,
 			final boolean[][] includeColumns,
 			final boolean anyUninitializedProperties,
 			final SessionImplementor session) {
 		int[] results = null;
 		int count = 0;
 		int span = properties.length;
 
 		for ( int i = 0; i < span; i++ ) {
 			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
 					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
 					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );
 			if ( dirty ) {
 				if ( results == null ) {
 					results = new int[span];
 				}
 				results[count++] = i;
 			}
 		}
 
 		if ( count == 0 ) {
 			return null;
 		}
 		else {
 			int[] trimmed = new int[count];
 			System.arraycopy( results, 0, trimmed, 0, count );
 			return trimmed;
 		}
 	}
 
 	/**
 	 * Determine if any of the given field values are modified, returning an array containing
 	 * indices of the modified fields.
 	 * <p/>
 	 * If it is determined that no fields are dirty, null is returned.
 	 *
 	 * @param properties The property definitions
 	 * @param currentState The current state of the entity
 	 * @param previousState The baseline state of the entity
 	 * @param includeColumns Columns to be included in the mod checking, per property
 	 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 	 * @param session The session from which the dirty check request originated.
 	 *
 	 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 	 */
 	public static int[] findModified(
 			final NonIdentifierAttribute[] properties,
 			final Object[] currentState,
 			final Object[] previousState,
 			final boolean[][] includeColumns,
 			final boolean anyUninitializedProperties,
 			final SessionImplementor session) {
 		int[] results = null;
 		int count = 0;
 		int span = properties.length;
 
 		for ( int i = 0; i < span; i++ ) {
 			final boolean modified = currentState[i]!=LazyPropertyInitializer.UNFETCHED_PROPERTY
 					&& properties[i].isDirtyCheckable(anyUninitializedProperties)
 					&& properties[i].getType().isModified( previousState[i], currentState[i], includeColumns[i], session );
 
 			if ( modified ) {
 				if ( results == null ) {
 					results = new int[span];
 				}
 				results[count++] = i;
 			}
 		}
 
 		if ( count == 0 ) {
 			return null;
 		}
 		else {
 			int[] trimmed = new int[count];
 			System.arraycopy( results, 0, trimmed, 0, count );
 			return trimmed;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/connection/DriverManagerRegistrationTest.java b/hibernate-core/src/test/java/org/hibernate/connection/DriverManagerRegistrationTest.java
index d35d965142..4cc3df61b4 100644
--- a/hibernate-core/src/test/java/org/hibernate/connection/DriverManagerRegistrationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/connection/DriverManagerRegistrationTest.java
@@ -1,177 +1,175 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.connection;
 
 import java.sql.Connection;
 import java.sql.Driver;
 import java.sql.DriverManager;
 import java.sql.DriverPropertyInfo;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.Properties;
 import java.util.logging.Logger;
 
-import org.hibernate.internal.util.ClassLoaderHelper;
-
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.junit.AfterClass;
 import org.junit.Test;
 
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 /**
  * This test illustrates the problem with calling {@link ClassLoader#loadClass(String)} rather than
  * {@link Class#forName(String, boolean, ClassLoader)} in terms of invoking static ini
  *
  * @author Steve Ebersole
  */
 @TestForIssue( jiraKey = "HHH-7272" )
 public class DriverManagerRegistrationTest extends BaseUnitTestCase {
 
 	@Test
 	public void testDriverRegistrationUsingLoadClassFails() {
 		final String driverClassName = "org.hibernate.connection.DriverManagerRegistrationTest$TestDriver1";
 		final String url = "jdbc:hibernate:test";
 
 		try {
 			determineClassLoader().loadClass( driverClassName );
 		}
 		catch (ClassNotFoundException e) {
 			fail( "Error loading JDBC Driver class : " + e.getMessage() );
 		}
 
 		try {
 			DriverManager.getDriver( url );
 			fail( "This test should have failed to locate JDBC driver per HHH-7272" );
 		}
 		catch (SQLException expected) {
 			// actually this should fail due to the reasons discussed on HHH-7272
 		}
 	}
 
 	@Test
 	public void testDriverRegistrationUsingClassForNameSucceeds() {
 		final String driverClassName = "org.hibernate.connection.DriverManagerRegistrationTest$TestDriver2";
 		final String url = "jdbc:hibernate:test2";
 		try {
 			Class.forName( driverClassName, true, determineClassLoader() );
 		}
 		catch (ClassNotFoundException e) {
 			fail( "Error loading JDBC Driver class : " + e.getMessage() );
 		}
 
 		try {
 			assertNotNull( DriverManager.getDriver( url ) );
 		}
 		catch (SQLException expected) {
 			fail( "Unanticipated failure according to HHH-7272" );
 		}
 	}
 
 	private static ClassLoader determineClassLoader() {
-		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
-		if ( cl == null ) {
-			cl = DriverManagerRegistrationTest.class.getClassLoader();
+		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+		if ( classLoader == null ) {
+			classLoader = DriverManagerRegistrationTest.class.getClassLoader();
 		}
-		return cl;
+		return classLoader;
 	}
 
 	@AfterClass
 	public static void afterwards() {
 		try {
 			DriverManager.deregisterDriver( TestDriver1.INSTANCE );
 		}
 		catch (SQLException ignore) {
 		}
 		try {
 			DriverManager.deregisterDriver( TestDriver2.INSTANCE );
 		}
 		catch (SQLException ignore) {
 		}
 	}
 
 	public static abstract class AbstractTestJdbcDriver implements Driver {
 		public final String matchUrl;
 
 		protected AbstractTestJdbcDriver(String matchUrl) {
 			this.matchUrl = matchUrl;
 		}
 
 		@Override
 		public Connection connect(String url, Properties info) throws SQLException {
 			throw new RuntimeException( "Not real driver" );
 		}
 
 		@Override
 		public boolean acceptsURL(String url) throws SQLException {
 			return url.equals( matchUrl );
 		}
 
 		@Override
 		public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
 			return new DriverPropertyInfo[0];
 		}
 
 		@Override
 		public int getMajorVersion() {
 			return 1;
 		}
 
 		@Override
 		public int getMinorVersion() {
 			return 0;
 		}
 
 		@Override
 		public boolean jdbcCompliant() {
 			return false;
 		}
 
 		public Logger getParentLogger()
 				throws SQLFeatureNotSupportedException {
 			throw new SQLFeatureNotSupportedException();
 		}
 	}
 
 	public static class TestDriver1 extends AbstractTestJdbcDriver {
 		public static final TestDriver1 INSTANCE = new TestDriver1( "jdbc:hibernate:test" );
 
 		public TestDriver1(String matchUrl) {
 			super( matchUrl );
 		}
 
 		static {
 			try {
 				DriverManager.registerDriver( INSTANCE );
 			}
 			catch (SQLException e) {
 				System.err.println( "Unable to register driver : " + e.getMessage() );
 				e.printStackTrace();
 			}
 		}
 	}
 
 	public static class TestDriver2 extends AbstractTestJdbcDriver {
 		public static final TestDriver2 INSTANCE = new TestDriver2( "jdbc:hibernate:test2" );
 
 		public TestDriver2(String matchUrl) {
 			super( matchUrl );
 		}
 
 		static {
 			try {
 				DriverManager.registerDriver( INSTANCE );
 			}
 			catch (SQLException e) {
 				System.err.println( "Unable to register driver : " + e.getMessage() );
 				e.printStackTrace();
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
index 050be45132..e03a2f18e4 100644
--- a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
@@ -1,170 +1,170 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Collections;
 import java.util.Properties;
 
 import org.hibernate.Session;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.SimpleAuxiliaryDatabaseObject;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.SessionImpl;
 import org.hibernate.jdbc.Work;
 import org.hibernate.type.StandardBasicTypes;
 
 import org.hibernate.testing.env.TestingDatabaseInfo;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.test.common.BasicTestingJdbcServiceImpl;
-import org.hibernate.test.common.MetadataBuildingContextTestingImpl;
+import org.hibernate.testing.boot.BasicTestingJdbcServiceImpl;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * I went back to 3.3 source and grabbed the code/logic as it existed back then and crafted this
  * unit test so that we can make sure the value keep being generated in the expected manner
  *
  * @author Steve Ebersole
  */
 @SuppressWarnings({ "deprecation" })
 public class SequenceHiLoGeneratorNoIncrementTest extends BaseUnitTestCase {
 	private static final String TEST_SEQUENCE = "test_sequence";
 
 	private StandardServiceRegistry serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 	private SequenceHiLoGenerator generator;
     private SessionImplementor session;
 
 	@Before
 	public void setUp() throws Exception {
 		BasicTestingJdbcServiceImpl jdbcServices = new BasicTestingJdbcServiceImpl();
 		jdbcServices.prepare( false );
 
 		serviceRegistry = new StandardServiceRegistryBuilder()
 				.enableAutoClose()
 				.addService( JdbcEnvironment.class, jdbcServices.getJdbcEnvironment() )
 				.addService( JdbcServices.class, jdbcServices )
 				.applySetting( AvailableSettings.HBM2DDL_AUTO, "create-drop" )
 				.build();
 
 		generator = new SequenceHiLoGenerator();
 
 		// Build the properties used to configure the id generator
 		Properties properties = new Properties();
 		properties.setProperty( SequenceGenerator.SEQUENCE, TEST_SEQUENCE );
 		properties.setProperty( SequenceHiLoGenerator.MAX_LO, "0" ); // JPA allocationSize of 1
 		properties.put(
 				PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER,
 				new ObjectNameNormalizer() {
 					@Override
 					protected MetadataBuildingContext getBuildingContext() {
 						return new MetadataBuildingContextTestingImpl( serviceRegistry );
 					}
 				}
 		);
-		generator.configure( StandardBasicTypes.LONG, properties, jdbcServices.getJdbcEnvironment() );
+		generator.configure( StandardBasicTypes.LONG, properties, serviceRegistry );
 
 		final Metadata metadata = new MetadataSources( serviceRegistry ).buildMetadata();
 		metadata.getDatabase().addAuxiliaryDatabaseObject(
 				new SimpleAuxiliaryDatabaseObject(
 						Collections.<String>emptySet(),
 						null,
 						null,
 						generator.sqlCreateStrings( TestingDatabaseInfo.DIALECT ),
 						generator.sqlDropStrings( TestingDatabaseInfo.DIALECT )
 				)
 		);
 
 		sessionFactory = (SessionFactoryImplementor) metadata.buildSessionFactory();
 	}
 
 	@After
 	public void tearDown() throws Exception {
         if(session != null && !session.isClosed()) {
             ((Session)session).close();
         }
 		if ( sessionFactory != null ) {
 			sessionFactory.close();
 		}
 		if ( serviceRegistry != null ) {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	@Test
 	public void testHiLoAlgorithm() {
 		session = (SessionImpl) sessionFactory.openSession();
 		((Session)session).beginTransaction();
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// initially sequence should be uninitialized
 		assertEquals( 0L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// historically the hilo generators skipped the initial block of values;
 		// 		so the first generated id value is maxlo + 1, here be 4
 		Long generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 1L, generatedValue.longValue() );
 		// which should also perform the first read on the sequence which should set it to its "start with" value (1)
 		assertEquals( 1L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 2L, generatedValue.longValue() );
 		assertEquals( 2L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 3L, generatedValue.longValue() );
 		assertEquals( 3L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 4L, generatedValue.longValue() );
 		assertEquals( 4L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 5L, generatedValue.longValue() );
 		assertEquals( 5L, extractSequenceValue( (session) ) );
 
 		((Session)session).getTransaction().commit();
 		((Session)session).close();
 	}
 
 	private long extractSequenceValue(final SessionImplementor session) {
 		class WorkImpl implements Work {
 			private long value;
 			public void execute(Connection connection) throws SQLException {
 				
 				PreparedStatement query = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( "select currval('" + TEST_SEQUENCE + "');" );
 				ResultSet resultSet = session.getJdbcCoordinator().getResultSetReturn().extract( query );
 				resultSet.next();
 				value = resultSet.getLong( 1 );
 			}
 		}
 		WorkImpl work = new WorkImpl();
 		( (Session) session ).doWork( work );
 		return work.value;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorTest.java b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorTest.java
index d9af118eac..27959167c0 100644
--- a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorTest.java
@@ -1,143 +1,142 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.Session;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.SessionImpl;
 import org.hibernate.jdbc.Work;
 import org.hibernate.type.StandardBasicTypes;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.test.common.MetadataBuildingContextTestingImpl;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * I went back to 3.3 source and grabbed the code/logic as it existed back then and crafted this
  * unit test so that we can make sure the value keep being generated in the expected manner
  * 
  * @author Steve Ebersole
  */
 @SuppressWarnings({ "deprecation" })
 public class SequenceHiLoGeneratorTest extends BaseUnitTestCase {
 	private static final String TEST_SEQUENCE = "test_sequence";
 
 	private StandardServiceRegistry serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 	private SequenceHiLoGenerator generator;
 
 	@Before
 	public void setUp() throws Exception {
 		serviceRegistry = new StandardServiceRegistryBuilder()
 				.enableAutoClose()
 				.applySetting( AvailableSettings.HBM2DDL_AUTO, "create-drop" )
 				.build();
 
 		MetadataBuildingContext buildingContext = new MetadataBuildingContextTestingImpl( serviceRegistry );
 
 		Properties properties = new Properties();
 		properties.setProperty( SequenceGenerator.SEQUENCE, TEST_SEQUENCE );
 		properties.setProperty( SequenceHiLoGenerator.MAX_LO, "3" );
 		properties.put( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER, buildingContext.getObjectNameNormalizer() );
 
 		generator = new SequenceHiLoGenerator();
-		generator.configure( StandardBasicTypes.LONG, properties, serviceRegistry.getService( JdbcEnvironment.class ) );
+		generator.configure( StandardBasicTypes.LONG, properties, serviceRegistry );
 
 		Metadata metadata = new MetadataSources( serviceRegistry ).buildMetadata();
 		generator.registerExportables( metadata.getDatabase() );
 
 		sessionFactory = (SessionFactoryImplementor) metadata.buildSessionFactory();
 	}
 
 	@After
 	public void tearDown() throws Exception {
 		if ( sessionFactory != null ) {
 			sessionFactory.close();
 		}
 		if ( serviceRegistry != null ) {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	@Test
 	public void testHiLoAlgorithm() {
 		SessionImpl session = (SessionImpl) sessionFactory.openSession();
 		session.beginTransaction();
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// initially sequence should be uninitialized
 		assertEquals( 0L, extractSequenceValue( session ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// historically the hilo generators skipped the initial block of values;
 		// so the first generated id value is maxlo + 1, here be 4
 		Long generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 4L, generatedValue.longValue() );
 		// which should also perform the first read on the sequence which should set it to its "start with" value (1)
 		assertEquals( 1L, extractSequenceValue( session ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 5L, generatedValue.longValue() );
 		assertEquals( 1L, extractSequenceValue( session ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 6L, generatedValue.longValue() );
 		assertEquals( 1L, extractSequenceValue( session ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 7L, generatedValue.longValue() );
 		// unlike the newer strategies, the db value will not get update here. It gets updated on the next invocation
 		// after a clock over
 		assertEquals( 1L, extractSequenceValue( session ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 8L, generatedValue.longValue() );
 		// this should force an increment in the sequence value
 		assertEquals( 2L, extractSequenceValue( session ) );
 
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private long extractSequenceValue(final SessionImplementor session) {
 		class WorkImpl implements Work {
 			private long value;
 
 			public void execute(Connection connection) throws SQLException {
 				PreparedStatement query = session.getJdbcCoordinator().getStatementPreparer().prepareStatement( "select currval('" + TEST_SEQUENCE + "');" );
 				ResultSet resultSet = session.getJdbcCoordinator().getResultSetReturn().extract( query );
 				resultSet.next();
 				value = resultSet.getLong( 1 );
 			}
 		}
 		WorkImpl work = new WorkImpl();
 		( (Session) session ).doWork( work );
 		return work.value;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/id/enhanced/SequenceStyleConfigUnitTest.java b/hibernate-core/src/test/java/org/hibernate/id/enhanced/SequenceStyleConfigUnitTest.java
index e3278f25f0..f084dd2ea8 100644
--- a/hibernate-core/src/test/java/org/hibernate/id/enhanced/SequenceStyleConfigUnitTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/id/enhanced/SequenceStyleConfigUnitTest.java
@@ -1,285 +1,284 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.id.enhanced;
 
 import java.util.Properties;
 
 import org.hibernate.MappingException;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.type.StandardBasicTypes;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.test.common.MetadataBuildingContextTestingImpl;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
 import org.junit.Test;
 
 import static org.hibernate.testing.junit4.ExtraAssertions.assertClassAssignability;
 import static org.junit.Assert.assertEquals;
 
 /**
  * Tests that SequenceStyleGenerator configures itself as expected in various scenarios
  *
  * @author Steve Ebersole
  */
 public class SequenceStyleConfigUnitTest extends BaseUnitTestCase {
 
 	/**
 	 * Test all params defaulted with a dialect supporting sequences
 	 */
 	@Test
 	public void testDefaultedSequenceBackedConfiguration() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, SequenceDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( NoopOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	private Properties buildGeneratorPropertiesBase(StandardServiceRegistry serviceRegistry) {
 		Properties props = new Properties();
 		props.put(
 				PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER,
 				new MetadataBuildingContextTestingImpl( serviceRegistry ).getObjectNameNormalizer()
 		);
 		return props;
 	}
 
 	/**
 	 * Test all params defaulted with a dialect which does not support sequences
 	 */
 	@Test
 	public void testDefaultedTableBackedConfiguration() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, TableDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 
 			assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( NoopOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	/**
 	 * Test default optimizer selection for sequence backed generators
 	 * based on the configured increment size; both in the case of the
 	 * dialect supporting pooled sequences (pooled) and not (hilo)
 	 */
 	@Test
 	public void testDefaultOptimizerBasedOnIncrementBackedBySequence() {
 		// for dialects which do not support pooled sequences, we default to pooled+table
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, SequenceDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "10" );
 
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 
 		// for dialects which do support pooled sequences, we default to pooled+sequence
 		serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, PooledSequenceDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "10" );
 
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	/**
 	 * Test default optimizer selection for table backed generators
 	 * based on the configured increment size.  Here we always prefer
 	 * pooled.
 	 */
 	@Test
 	public void testDefaultOptimizerBasedOnIncrementBackedByTable() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, TableDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "10" );
 
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	/**
 	 * Test forcing of table as backing structure with dialect supporting sequences
 	 */
 	@Test
 	public void testForceTableUse() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, SequenceDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.FORCE_TBL_PARAM, "true" );
 
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( NoopOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	/**
 	 * Test explicitly specifying both optimizer and increment
 	 */
 	@Test
 	public void testExplicitOptimizerWithExplicitIncrementSize() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, SequenceDialect.class.getName() )
 				.build();
 
 		// optimizer=none w/ increment > 1 => should honor optimizer
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.OPT_PARAM, StandardOptimizerDescriptor.NONE.getExternalName() );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "20" );
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( NoopOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( 1, generator.getOptimizer().getIncrementSize() );
 			assertEquals( 1, generator.getDatabaseStructure().getIncrementSize() );
 
 			// optimizer=hilo w/ increment > 1 => hilo
 			props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.OPT_PARAM, StandardOptimizerDescriptor.HILO.getExternalName() );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "20" );
 			generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( HiLoOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( 20, generator.getOptimizer().getIncrementSize() );
 			assertEquals( 20, generator.getDatabaseStructure().getIncrementSize() );
 
 			// optimizer=pooled w/ increment > 1 => hilo
 			props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.OPT_PARAM, StandardOptimizerDescriptor.POOLED.getExternalName() );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "20" );
 			generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			// because the dialect reports to not support pooled seqyences, the expectation is that we will
 			// use a table for the backing structure...
 			assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
 			assertEquals( 20, generator.getOptimizer().getIncrementSize() );
 			assertEquals( 20, generator.getDatabaseStructure().getIncrementSize() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	@Test
 	public void testPreferPooledLoSettingHonored() {
 		StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.DIALECT, PooledSequenceDialect.class.getName() )
 				.build();
 
 		try {
 			Properties props = buildGeneratorPropertiesBase( serviceRegistry );
 			props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, "20" );
 			SequenceStyleGenerator generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
 
 			props.setProperty( Environment.PREFER_POOLED_VALUES_LO, "true" );
 			generator = new SequenceStyleGenerator();
-			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry.getService( JdbcEnvironment.class ) );
+			generator.configure( StandardBasicTypes.LONG, props, serviceRegistry );
 			assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
 			assertClassAssignability( PooledLoOptimizer.class, generator.getOptimizer().getClass() );
 		}
 		finally {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	public static class TableDialect extends Dialect {
 		public boolean supportsSequences() {
 			return false;
 		}
 	}
 
 	public static class SequenceDialect extends Dialect {
 		public boolean supportsSequences() {
 			return true;
 		}
 		public boolean supportsPooledSequences() {
 			return false;
 		}
 		public String getSequenceNextValString(String sequenceName) throws MappingException {
 			return "";
 		}
 	}
 
 	public static class PooledSequenceDialect extends SequenceDialect {
 		public boolean supportsPooledSequences() {
 			return true;
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/property/BasicPropertyAccessorTest.java b/hibernate-core/src/test/java/org/hibernate/property/BasicPropertyAccessorTest.java
index 1934e05536..84a1cd845e 100644
--- a/hibernate-core/src/test/java/org/hibernate/property/BasicPropertyAccessorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/property/BasicPropertyAccessorTest.java
@@ -1,89 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.property;
 
-import org.junit.Test;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBasicImpl;
+import org.hibernate.property.access.spi.PropertyAccess;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class BasicPropertyAccessorTest extends BaseUnitTestCase {
 	public static abstract class Super {
 		public abstract Object getIt();
 		public abstract void setIt(Object it);
 	}
 
 	public static class Duper extends Super {
 		private String it;
 
 		public Duper(String it) {
 			this.it = it;
 		}
 
 		public String getIt() {
 			return it;
 		}
 
 		@Override
 		public void setIt(Object it) {
 			this.it = ( it == null || String.class.isInstance( it ) )
 					? (String) it
 					: it.toString();
 		}
 	}
 
 	public static class Duper2 extends Super {
 		private String it;
 
 		public Duper2(String it) {
 			this.it = it;
 		}
 
 		public String getIt() {
 			return it;
 		}
 
 		public void setIt(String it) {
 			this.it = it;
 		}
 
 		@Override
 		public void setIt(Object it) {
 			if ( it == null || String.class.isInstance( it ) ) {
 				setIt( (String) it );
 			}
 			else {
 				setIt( it.toString() );
 			}
 		}
 	}
 
 	@Test
 	public void testBridgeMethodDisregarded() {
-		BasicPropertyAccessor accessor = new BasicPropertyAccessor();
+		PropertyAccessStrategyBasicImpl accessStrategy = PropertyAccessStrategyBasicImpl.INSTANCE;
 
 		{
-			BasicPropertyAccessor.BasicGetter getter = (BasicPropertyAccessor.BasicGetter) accessor.getGetter( Duper.class, "it" );
-			assertEquals( String.class, getter.getReturnType() );
-
-			BasicPropertyAccessor.BasicSetter setter = (BasicPropertyAccessor.BasicSetter) accessor.getSetter( Duper.class, "it" );
-			assertEquals( Object.class, setter.getMethod().getParameterTypes()[0] );
+			final PropertyAccess access = accessStrategy.buildPropertyAccess( Duper.class, "it" );
+			assertEquals( String.class, access.getGetter().getReturnType() );
+			assertEquals( Object.class, access.getSetter().getMethod().getParameterTypes()[0] );
 		}
 
 		{
-			BasicPropertyAccessor.BasicGetter getter = (BasicPropertyAccessor.BasicGetter) accessor.getGetter( Duper2.class, "it" );
-			assertEquals( String.class, getter.getReturnType() );
-
-			BasicPropertyAccessor.BasicSetter setter = (BasicPropertyAccessor.BasicSetter) accessor.getSetter( Duper2.class, "it" );
-			assertEquals( String.class, setter.getMethod().getParameterTypes()[0] );
+			final PropertyAccess access = accessStrategy.buildPropertyAccess( Duper2.class, "it" );
+			assertEquals( String.class, access.getGetter().getReturnType() );
+			assertEquals( String.class, access.getSetter().getMethod().getParameterTypes()[0] );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
index 7b092828cd..a672af6b59 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
@@ -1,234 +1,234 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.annotations.access.jpa;
 
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.property.BasicPropertyAccessor;
-import org.hibernate.property.DirectPropertyAccessor;
+import org.hibernate.property.access.spi.GetterFieldImpl;
+import org.hibernate.property.access.spi.GetterMethodImpl;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.TestForIssue;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 
 /**
  * Tests verifying the correct behaviour for the usage of {@code @javax.persistence.Access}.
  *
  * @author Hardy Ferentschik
  */
 @SuppressWarnings({ "deprecation" })
 public class AccessMappingTest {
     private ServiceRegistry serviceRegistry;
 
     @Before
     public void setUp() {
         serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( Environment.getProperties() );
     }
 
     @After
     public void tearDown() {
         if ( serviceRegistry != null ) {
             ServiceRegistryBuilder.destroy( serviceRegistry );
         }
     }
 
     @Test
     public void testInconsistentAnnotationPlacement() throws Exception {
         Configuration cfg = new Configuration();
         cfg.addAnnotatedClass( Course1.class );
         cfg.addAnnotatedClass( Student.class );
 		SessionFactory sf = null;
         try {
            sf= cfg.buildSessionFactory( serviceRegistry );
             fail( "@Id and @OneToMany are not placed consistently in test entities. SessionFactory creation should fail." );
         }
         catch ( MappingException e ) {
             // success
         } finally {
 			if(sf!=null){
 				sf.close();
 			}
 		}
     }
 
     @Test
     public void testFieldAnnotationPlacement() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = Course6.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
-                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
+				tuplizer.getIdentifierGetter() instanceof GetterFieldImpl
         );
 		factory.close();
     }
 
     @Test
     public void testPropertyAnnotationPlacement() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = Course7.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used.",
-                tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
+                tuplizer.getIdentifierGetter() instanceof GetterMethodImpl
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsOnProperty() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = Course2.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used.",
-                tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
+                tuplizer.getIdentifierGetter() instanceof GetterMethodImpl
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsOnField() throws Exception {
         Configuration cfg = new Configuration();
         cfg.addAnnotatedClass( Course4.class );
         cfg.addAnnotatedClass( Student.class );
 		SessionFactory sf= null;
         try {
            sf = cfg.buildSessionFactory( serviceRegistry );
             fail( "@Id and @OneToMany are not placed consistently in test entities. SessionFactory creation should fail." );
         }
         catch ( MappingException e ) {
             // success
         }  finally {
 			if(sf!=null){
 				sf.close();
 			}
 		}
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsWithHibernateStyleOverride() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = Course3.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
-                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
+                tuplizer.getIdentifierGetter() instanceof GetterFieldImpl
         );
 
         assertTrue(
                 "Property access should be used.",
-                tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
+                tuplizer.getGetter( 0 ) instanceof GetterMethodImpl
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsWithJpaStyleOverride() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = Course5.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
-                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
+                tuplizer.getIdentifierGetter() instanceof GetterFieldImpl
         );
 
         assertTrue(
                 "Property access should be used.",
-                tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
+                tuplizer.getGetter( 0 ) instanceof GetterMethodImpl
         );
 		factory.close();
     }
 
     @Test
     public void testDefaultFieldAccessIsInherited() throws Exception {
         Configuration cfg = new Configuration();
         Class<?> classUnderTest = User.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Person.class );
         cfg.addAnnotatedClass( Being.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used since the default access mode gets inherited",
-                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
+                tuplizer.getIdentifierGetter() instanceof GetterFieldImpl
         );
 		factory.close();
     }
 
     @Test
     public void testDefaultPropertyAccessIsInherited() throws Exception {
         Configuration cfg = new Configuration();
         cfg.addAnnotatedClass( Horse.class );
         cfg.addAnnotatedClass( Animal.class );
 
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( Animal.class.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used since explicity configured via @Access",
-                tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
+                tuplizer.getIdentifierGetter() instanceof GetterMethodImpl
         );
 
         tuplizer = factory.getEntityPersister( Horse.class.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used since the default access mode gets inherited",
-                tuplizer.getGetter( 0 ) instanceof DirectPropertyAccessor.DirectGetter
+                tuplizer.getGetter( 0 ) instanceof GetterFieldImpl
         );
 		factory.close();
     }
 
     @TestForIssue(jiraKey = "HHH-5004")
     @Test
     public void testAccessOnClassAndId() throws Exception {
         Configuration cfg = new Configuration();
         cfg.addAnnotatedClass( Course8.class );
         cfg.addAnnotatedClass( Student.class );
         cfg.buildSessionFactory( serviceRegistry ).close();
     }
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
index c500fb2ede..1a6688db8b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
@@ -1,192 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.annotations.access.xml;
 
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import javax.persistence.AccessType;
 
-import org.junit.Assert;
-import org.junit.Test;
-
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.property.BasicPropertyAccessor;
-import org.hibernate.property.DirectPropertyAccessor;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.hibernate.property.access.spi.GetterFieldImpl;
+import org.hibernate.property.access.spi.GetterMethodImpl;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
+import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.junit.Assert;
+import org.junit.Test;
+
 
 /**
  * Test verifying that it is possible to configure the access type via xml configuration.
  *
  * @author Hardy Ferentschik
  */
 public class XmlAccessTest extends BaseUnitTestCase {
 	@Test
 	public void testAccessOnBasicXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using basic
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnPersistenceUnitDefaultsXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using persitence unit defaults
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist2.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEntityMappingsXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using default in entity-mappings
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist3.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEntityXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using entity level config
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist4.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnMappedSuperClassXmlElement() throws Exception {
 		Class<?> classUnderTest = Waiter.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Crew.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Crew.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnAssociationXmlElement() throws Exception {
 		Class<?> classUnderTest = RentalCar.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Driver.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/RentalCar.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEmbeddedXmlElement() throws Exception {
 		Class<?> classUnderTest = Cook.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Knive.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Cook.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnElementCollectionXmlElement() throws Exception {
 		Class<?> classUnderTest = Boy.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Boy.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	private SessionFactoryImplementor buildSessionFactory(List<Class<?>> classesUnderTest, List<String> configFiles) {
 		assert classesUnderTest != null;
 		assert configFiles != null;
 		Configuration cfg = new Configuration();
 		for ( Class<?> clazz : classesUnderTest ) {
 			cfg.addAnnotatedClass( clazz );
 		}
 		for ( String configFile : configFiles ) {
 			InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( configFile );
 			cfg.addInputStream( is );
 		}
 		return ( SessionFactoryImplementor ) cfg.buildSessionFactory();
 	}
 
 	// uses the first getter of the tupelizer for the assertions
 
 	private void assertAccessType(SessionFactoryImplementor factory, Class<?> classUnderTest, AccessType accessType) {
 		EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
 				.getEntityMetamodel()
 				.getTuplizer();
 		if ( AccessType.FIELD.equals( accessType ) ) {
 			Assert.assertTrue(
 					"Field access was expected.",
-					tuplizer.getGetter( 0 ) instanceof DirectPropertyAccessor.DirectGetter
+					tuplizer.getGetter( 0 ) instanceof GetterFieldImpl
 			);
 		}
 		else {
 			Assert.assertTrue(
 					"Property access was expected.",
-					tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
+					tuplizer.getGetter( 0 ) instanceof GetterMethodImpl
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/JPAOverriddenAnnotationReaderTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/JPAOverriddenAnnotationReaderTest.java
index 4da94655e7..dac0679548 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/JPAOverriddenAnnotationReaderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/JPAOverriddenAnnotationReaderTest.java
@@ -1,458 +1,460 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.annotations.reflection;
 
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import javax.persistence.AssociationOverrides;
 import javax.persistence.AttributeOverrides;
 import javax.persistence.Basic;
 import javax.persistence.Column;
 import javax.persistence.DiscriminatorColumn;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.Embedded;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.EntityListeners;
 import javax.persistence.EnumType;
 import javax.persistence.Enumerated;
 import javax.persistence.ExcludeDefaultListeners;
 import javax.persistence.ExcludeSuperclassListeners;
 import javax.persistence.FetchType;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.JoinColumns;
 import javax.persistence.JoinTable;
 import javax.persistence.Lob;
 import javax.persistence.ManyToMany;
 import javax.persistence.MapKey;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedQueries;
 import javax.persistence.OneToMany;
 import javax.persistence.OneToOne;
 import javax.persistence.OrderBy;
 import javax.persistence.PostLoad;
 import javax.persistence.PostPersist;
 import javax.persistence.PrePersist;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.PrimaryKeyJoinColumns;
 import javax.persistence.SecondaryTable;
 import javax.persistence.SecondaryTables;
 import javax.persistence.SequenceGenerator;
 import javax.persistence.SqlResultSetMappings;
 import javax.persistence.Table;
 import javax.persistence.TableGenerator;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 import javax.persistence.Transient;
 import javax.persistence.Version;
 
-import org.dom4j.DocumentException;
-import org.dom4j.io.SAXReader;
-import org.junit.Test;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotSupportedException;
-
 import org.hibernate.annotations.Columns;
 import org.hibernate.cfg.EJB3DTDEntityResolver;
 import org.hibernate.cfg.annotations.reflection.JPAOverriddenAnnotationReader;
 import org.hibernate.cfg.annotations.reflection.XMLContext;
 import org.hibernate.internal.util.xml.ErrorLogger;
 import org.hibernate.internal.util.xml.XMLHelper;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.hibernate.testing.boot.ClassLoaderAccessTestingImpl;
+import org.hibernate.testing.boot.ClassLoaderServiceTestingImpl;
+import org.junit.Test;
+
+import org.dom4j.DocumentException;
+import org.dom4j.io.SAXReader;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXNotSupportedException;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class JPAOverriddenAnnotationReaderTest extends BaseUnitTestCase {
 	@Test
 	public void testMappedSuperclassAnnotations() throws Exception {
 		XMLContext context = buildContext(
 				"org/hibernate/test/annotations/reflection/metadata-complete.xml"
 		);
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Organization.class, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Organization.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertTrue( reader.isAnnotationPresent( MappedSuperclass.class ) );
 	}
 
 	@Test
 	public void testEntityRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Administration.class, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Administration.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Entity.class ) );
 		assertEquals(
 				"Default value in xml entity should not override @Entity.name", "JavaAdministration",
 				reader.getAnnotation( Entity.class ).name()
 		);
 		assertNotNull( reader.getAnnotation( Table.class ) );
 		assertEquals( "@Table not overridden", "tbl_admin", reader.getAnnotation( Table.class ).name() );
 		assertEquals( "Default schema not overridden", "myschema", reader.getAnnotation( Table.class ).schema() );
 		assertEquals(
 				"Proper @Table.uniqueConstraints", 2,
 				reader.getAnnotation( Table.class ).uniqueConstraints()[0].columnNames().length
 		);
 		String columnName = reader.getAnnotation( Table.class ).uniqueConstraints()[0].columnNames()[0];
 		assertTrue(
 				"Proper @Table.uniqueConstraints", "firstname".equals( columnName ) || "lastname".equals( columnName )
 		);
 		assertNull( "Both Java and XML used", reader.getAnnotation( SecondaryTable.class ) );
 		assertNotNull( "XML does not work", reader.getAnnotation( SecondaryTables.class ) );
 		SecondaryTable[] tables = reader.getAnnotation( SecondaryTables.class ).value();
 		assertEquals( 1, tables.length );
 		assertEquals( "admin2", tables[0].name() );
 		assertEquals( "unique constraints ignored", 1, tables[0].uniqueConstraints().length );
 		assertEquals( "pk join column ignored", 1, tables[0].pkJoinColumns().length );
 		assertEquals( "pk join column ignored", "admin_id", tables[0].pkJoinColumns()[0].name() );
 		assertNotNull( "Sequence Overriding not working", reader.getAnnotation( SequenceGenerator.class ) );
 		assertEquals(
 				"wrong sequence name", "seqhilo", reader.getAnnotation( SequenceGenerator.class ).sequenceName()
 		);
 		assertEquals( "default fails", 50, reader.getAnnotation( SequenceGenerator.class ).allocationSize() );
 		assertNotNull( "TableOverriding not working", reader.getAnnotation( TableGenerator.class ) );
 		assertEquals( "wrong tble name", "tablehilo", reader.getAnnotation( TableGenerator.class ).table() );
 		assertEquals( "no schema overriding", "myschema", reader.getAnnotation( TableGenerator.class ).schema() );
 
-		reader = new JPAOverriddenAnnotationReader( Match.class, context );
+		reader = new JPAOverriddenAnnotationReader( Match.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Table.class ) );
 		assertEquals(
 				"Java annotation not taken into account", "matchtable", reader.getAnnotation( Table.class ).name()
 		);
 		assertEquals(
 				"Java annotation not taken into account", "matchschema", reader.getAnnotation( Table.class ).schema()
 		);
 		assertEquals( "Overriding not taken into account", "mycatalog", reader.getAnnotation( Table.class ).catalog() );
 		assertNotNull( "SecondaryTable swallowed", reader.getAnnotation( SecondaryTables.class ) );
 		assertEquals(
 				"Default schema not taken into account", "myschema",
 				reader.getAnnotation( SecondaryTables.class ).value()[0].schema()
 		);
 		assertNotNull( reader.getAnnotation( Inheritance.class ) );
 		assertEquals(
 				"inheritance strategy not overriden", InheritanceType.JOINED,
 				reader.getAnnotation( Inheritance.class ).strategy()
 		);
 		assertNotNull( "NamedQuery not overriden", reader.getAnnotation( NamedQueries.class ) );
 		assertEquals( "No deduplication", 3, reader.getAnnotation( NamedQueries.class ).value().length );
 		assertEquals(
 				"deduplication kept the Java version", 1,
 				reader.getAnnotation( NamedQueries.class ).value()[1].hints().length
 		);
 		assertEquals(
 				"org.hibernate.timeout", reader.getAnnotation( NamedQueries.class ).value()[1].hints()[0].name()
 		);
 		assertNotNull( "NamedNativeQuery not overriden", reader.getAnnotation( NamedNativeQueries.class ) );
 		assertEquals( "No deduplication", 3, reader.getAnnotation( NamedNativeQueries.class ).value().length );
 		assertEquals(
 				"deduplication kept the Java version", 1,
 				reader.getAnnotation( NamedNativeQueries.class ).value()[1].hints().length
 		);
 		assertEquals(
 				"org.hibernate.timeout", reader.getAnnotation( NamedNativeQueries.class ).value()[1].hints()[0].name()
 		);
 		assertNotNull( reader.getAnnotation( SqlResultSetMappings.class ) );
 		assertEquals(
 				"competitor1Point", reader.getAnnotation( SqlResultSetMappings.class ).value()[0].columns()[0].name()
 		);
 		assertEquals(
 				"competitor1Point",
 				reader.getAnnotation( SqlResultSetMappings.class ).value()[0].entities()[0].fields()[0].column()
 		);
 		assertNotNull( reader.getAnnotation( ExcludeSuperclassListeners.class ) );
 		assertNotNull( reader.getAnnotation( ExcludeDefaultListeners.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( Competition.class, context );
+		reader = new JPAOverriddenAnnotationReader( Competition.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( MappedSuperclass.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( TennisMatch.class, context );
+		reader = new JPAOverriddenAnnotationReader( TennisMatch.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( "Mutualize PKJC into PKJCs", reader.getAnnotation( PrimaryKeyJoinColumn.class ) );
 		assertNotNull( reader.getAnnotation( PrimaryKeyJoinColumns.class ) );
 		assertEquals(
 				"PrimaryKeyJoinColumn overrden", "id",
 				reader.getAnnotation( PrimaryKeyJoinColumns.class ).value()[0].name()
 		);
 		assertNotNull( reader.getAnnotation( AttributeOverrides.class ) );
 		assertEquals( "Wrong deduplication", 3, reader.getAnnotation( AttributeOverrides.class ).value().length );
 		assertEquals(
 				"Wrong priority (XML vs java annotations)", "fld_net",
 				reader.getAnnotation( AttributeOverrides.class ).value()[0].column().name()
 		);
 		assertEquals(
 				"Column mapping", 2, reader.getAnnotation( AttributeOverrides.class ).value()[1].column().scale()
 		);
 		assertEquals(
 				"Column mapping", true, reader.getAnnotation( AttributeOverrides.class ).value()[1].column().unique()
 		);
 		assertNotNull( reader.getAnnotation( AssociationOverrides.class ) );
 		assertEquals( "no XML processing", 1, reader.getAnnotation( AssociationOverrides.class ).value().length );
 		assertEquals(
 				"wrong xml processing", "id",
 				reader.getAnnotation( AssociationOverrides.class ).value()[0].joinColumns()[0].referencedColumnName()
 		);
 
 
-		reader = new JPAOverriddenAnnotationReader( SocialSecurityPhysicalAccount.class, context );
+		reader = new JPAOverriddenAnnotationReader( SocialSecurityPhysicalAccount.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( IdClass.class ) );
 		assertEquals( "id-class not used", SocialSecurityNumber.class, reader.getAnnotation( IdClass.class ).value() );
 		assertEquals(
 				"discriminator-value not used", "Physical", reader.getAnnotation( DiscriminatorValue.class ).value()
 		);
 		assertNotNull( "discriminator-column not used", reader.getAnnotation( DiscriminatorColumn.class ) );
 		assertEquals(
 				"discriminator-column.name default value broken", "DTYPE",
 				reader.getAnnotation( DiscriminatorColumn.class ).name()
 		);
 		assertEquals(
 				"discriminator-column.length broken", 34, reader.getAnnotation( DiscriminatorColumn.class ).length()
 		);
 	}
 
 	@Test
 	public void testEntityRelatedAnnotationsMetadataComplete() throws Exception {
 		XMLContext context = buildContext(
 				"org/hibernate/test/annotations/reflection/metadata-complete.xml"
 		);
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Administration.class, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( Administration.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Entity.class ) );
 		assertEquals(
 				"Metadata complete should ignore java annotations", "", reader.getAnnotation( Entity.class ).name()
 		);
 		assertNotNull( reader.getAnnotation( Table.class ) );
 		assertEquals( "@Table should not be used", "", reader.getAnnotation( Table.class ).name() );
 		assertEquals( "Default schema not overriden", "myschema", reader.getAnnotation( Table.class ).schema() );
 
-		reader = new JPAOverriddenAnnotationReader( Match.class, context );
+		reader = new JPAOverriddenAnnotationReader( Match.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Table.class ) );
 		assertEquals( "@Table should not be used", "", reader.getAnnotation( Table.class ).name() );
 		assertEquals( "Overriding not taken into account", "myschema", reader.getAnnotation( Table.class ).schema() );
 		assertEquals( "Overriding not taken into account", "mycatalog", reader.getAnnotation( Table.class ).catalog() );
 		assertNull( "Ignore Java annotation", reader.getAnnotation( SecondaryTable.class ) );
 		assertNull( "Ignore Java annotation", reader.getAnnotation( SecondaryTables.class ) );
 		assertNull( "Ignore Java annotation", reader.getAnnotation( Inheritance.class ) );
 		assertNull( reader.getAnnotation( NamedQueries.class ) );
 		assertNull( reader.getAnnotation( NamedNativeQueries.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( TennisMatch.class, context );
+		reader = new JPAOverriddenAnnotationReader( TennisMatch.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( reader.getAnnotation( PrimaryKeyJoinColumn.class ) );
 		assertNull( reader.getAnnotation( PrimaryKeyJoinColumns.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( Competition.class, context );
+		reader = new JPAOverriddenAnnotationReader( Competition.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( reader.getAnnotation( MappedSuperclass.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( SocialSecurityMoralAccount.class, context );
+		reader = new JPAOverriddenAnnotationReader( SocialSecurityMoralAccount.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( reader.getAnnotation( IdClass.class ) );
 		assertNull( reader.getAnnotation( DiscriminatorValue.class ) );
 		assertNull( reader.getAnnotation( DiscriminatorColumn.class ) );
 		assertNull( reader.getAnnotation( SequenceGenerator.class ) );
 		assertNull( reader.getAnnotation( TableGenerator.class ) );
 	}
 
 	@Test
 	public void testIdRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
 		Method method = Administration.class.getDeclaredMethod( "getId" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( reader.getAnnotation( Id.class ) );
 		assertNull( reader.getAnnotation( Column.class ) );
 		Field field = Administration.class.getDeclaredField( "id" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Id.class ) );
 		assertNotNull( reader.getAnnotation( GeneratedValue.class ) );
 		assertEquals( GenerationType.SEQUENCE, reader.getAnnotation( GeneratedValue.class ).strategy() );
 		assertEquals( "generator", reader.getAnnotation( GeneratedValue.class ).generator() );
 		assertNotNull( reader.getAnnotation( SequenceGenerator.class ) );
 		assertEquals( "seq", reader.getAnnotation( SequenceGenerator.class ).sequenceName() );
 		assertNotNull( reader.getAnnotation( Columns.class ) );
 		assertEquals( 1, reader.getAnnotation( Columns.class ).columns().length );
 		assertEquals( "fld_id", reader.getAnnotation( Columns.class ).columns()[0].name() );
 		assertNotNull( reader.getAnnotation( Temporal.class ) );
 		assertEquals( TemporalType.DATE, reader.getAnnotation( Temporal.class ).value() );
 
 		context = buildContext(
 				"org/hibernate/test/annotations/reflection/metadata-complete.xml"
 		);
 		method = Administration.class.getDeclaredMethod( "getId" );
-		reader = new JPAOverriddenAnnotationReader( method, context );
+		reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull(
 				"Default access type when not defined in metadata complete should be property",
 				reader.getAnnotation( Id.class )
 		);
 		field = Administration.class.getDeclaredField( "id" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull(
 				"Default access type when not defined in metadata complete should be property",
 				reader.getAnnotation( Id.class )
 		);
 
 		method = BusTrip.class.getDeclaredMethod( "getId" );
-		reader = new JPAOverriddenAnnotationReader( method, context );
+		reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNull( reader.getAnnotation( EmbeddedId.class ) );
 		field = BusTrip.class.getDeclaredField( "id" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( EmbeddedId.class ) );
 		assertNotNull( reader.getAnnotation( AttributeOverrides.class ) );
 		assertEquals( 1, reader.getAnnotation( AttributeOverrides.class ).value().length );
 	}
 
 	@Test
 	public void testBasicRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext(
 				"org/hibernate/test/annotations/reflection/metadata-complete.xml"
 		);
 		Field field = BusTrip.class.getDeclaredField( "status" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Enumerated.class ) );
 		assertEquals( EnumType.STRING, reader.getAnnotation( Enumerated.class ).value() );
 		assertEquals( false, reader.getAnnotation( Basic.class ).optional() );
 		field = BusTrip.class.getDeclaredField( "serial" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Lob.class ) );
 		assertEquals( "serialbytes", reader.getAnnotation( Columns.class ).columns()[0].name() );
 		field = BusTrip.class.getDeclaredField( "terminusTime" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Temporal.class ) );
 		assertEquals( TemporalType.TIMESTAMP, reader.getAnnotation( Temporal.class ).value() );
 		assertEquals( FetchType.LAZY, reader.getAnnotation( Basic.class ).fetch() );
 
 		field = BusTripPk.class.getDeclaredField( "busDriver" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.isAnnotationPresent( Basic.class ) );
 	}
 
 	@Test
 	public void testVersionRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
 		Method method = Administration.class.getDeclaredMethod( "getVersion" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Version.class ) );
 
 		Field field = Match.class.getDeclaredField( "version" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Version.class ) );
 	}
 
 	@Test
 	public void testTransientAndEmbeddedRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
 
 		Field field = Administration.class.getDeclaredField( "transientField" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Transient.class ) );
 		assertNull( reader.getAnnotation( Basic.class ) );
 
 		field = Match.class.getDeclaredField( "playerASSN" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( Embedded.class ) );
 	}
 
 	@Test
 	public void testAssociationRelatedAnnotations() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
 
 		Field field = Administration.class.getDeclaredField( "defaultBusTrip" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( OneToOne.class ) );
 		assertNull( reader.getAnnotation( JoinColumns.class ) );
 		assertNotNull( reader.getAnnotation( PrimaryKeyJoinColumns.class ) );
 		assertEquals( "pk", reader.getAnnotation( PrimaryKeyJoinColumns.class ).value()[0].name() );
 		assertEquals( 5, reader.getAnnotation( OneToOne.class ).cascade().length );
 		assertEquals( FetchType.LAZY, reader.getAnnotation( OneToOne.class ).fetch() );
 		assertEquals( "test", reader.getAnnotation( OneToOne.class ).mappedBy() );
 
 		context = buildContext(
 				"org/hibernate/test/annotations/reflection/metadata-complete.xml"
 		);
 		field = BusTrip.class.getDeclaredField( "players" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( OneToMany.class ) );
 		assertNotNull( reader.getAnnotation( JoinColumns.class ) );
 		assertEquals( 2, reader.getAnnotation( JoinColumns.class ).value().length );
 		assertEquals( "driver", reader.getAnnotation( JoinColumns.class ).value()[0].name() );
 		assertNotNull( reader.getAnnotation( MapKey.class ) );
 		assertEquals( "name", reader.getAnnotation( MapKey.class ).name() );
 
 		field = BusTrip.class.getDeclaredField( "roads" );
-		reader = new JPAOverriddenAnnotationReader( field, context );
+		reader = new JPAOverriddenAnnotationReader( field, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertNotNull( reader.getAnnotation( ManyToMany.class ) );
 		assertNotNull( reader.getAnnotation( JoinTable.class ) );
 		assertEquals( "bus_road", reader.getAnnotation( JoinTable.class ).name() );
 		assertEquals( 2, reader.getAnnotation( JoinTable.class ).joinColumns().length );
 		assertEquals( 1, reader.getAnnotation( JoinTable.class ).inverseJoinColumns().length );
 		assertEquals( 2, reader.getAnnotation( JoinTable.class ).uniqueConstraints()[0].columnNames().length );
 		assertNotNull( reader.getAnnotation( OrderBy.class ) );
 		assertEquals( "maxSpeed", reader.getAnnotation( OrderBy.class ).value() );
 	}
 
 	@Test
 	public void testEntityListeners() throws Exception {
 		XMLContext context = buildContext( "org/hibernate/test/annotations/reflection/orm.xml" );
 
 		Method method = Administration.class.getDeclaredMethod( "calculate" );
-		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context );
+		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertTrue( reader.isAnnotationPresent( PrePersist.class ) );
 
-		reader = new JPAOverriddenAnnotationReader( Administration.class, context );
+		reader = new JPAOverriddenAnnotationReader( Administration.class, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertTrue( reader.isAnnotationPresent( EntityListeners.class ) );
 		assertEquals( 1, reader.getAnnotation( EntityListeners.class ).value().length );
 		assertEquals( LogListener.class, reader.getAnnotation( EntityListeners.class ).value()[0] );
 
 		method = LogListener.class.getDeclaredMethod( "noLog", Object.class );
-		reader = new JPAOverriddenAnnotationReader( method, context );
+		reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertTrue( reader.isAnnotationPresent( PostLoad.class ) );
 
 		method = LogListener.class.getDeclaredMethod( "log", Object.class );
-		reader = new JPAOverriddenAnnotationReader( method, context );
+		reader = new JPAOverriddenAnnotationReader( method, context, ClassLoaderAccessTestingImpl.INSTANCE );
 		assertTrue( reader.isAnnotationPresent( PrePersist.class ) );
 		assertFalse( reader.isAnnotationPresent( PostPersist.class ) );
 
 		assertEquals( 1, context.getDefaultEntityListeners().size() );
 		assertEquals( OtherLogListener.class.getName(), context.getDefaultEntityListeners().get( 0 ) );
 	}
 
 	private XMLContext buildContext(String ormfile) throws SAXException, DocumentException, IOException {
-		XMLHelper xmlHelper = new XMLHelper();
-		ClassLoader cl = Thread.currentThread().getContextClassLoader();
-		InputStream is = cl.getResourceAsStream( ormfile );
+		XMLHelper xmlHelper = new XMLHelper( ClassLoaderServiceTestingImpl.INSTANCE );
+		InputStream is = ClassLoaderServiceTestingImpl.INSTANCE.locateResourceStream( ormfile );
 		assertNotNull( "ORM.xml not found: " + ormfile, is );
-		XMLContext context = new XMLContext();
+		XMLContext context = new XMLContext( ClassLoaderAccessTestingImpl.INSTANCE );
 		ErrorLogger errorLogger = new ErrorLogger();
 		SAXReader saxReader = xmlHelper.createSAXReader( errorLogger, EJB3DTDEntityResolver.INSTANCE );
 		//saxReader.setValidation( false );
 		try {
 			saxReader.setFeature( "http://apache.org/xml/features/validation/schema", true );
 		}
 		catch ( SAXNotSupportedException e ) {
 			saxReader.setValidation( false );
 		}
 		org.dom4j.Document doc;
 		try {
 			doc = saxReader.read( new InputSource( new BufferedInputStream( is ) ) );
 		}
 		finally {
 			is.close();
 		}
 		if ( errorLogger.hasErrors() ) {
 			System.out.println( errorLogger.getErrors().get( 0 ) );
 		}
 		assertFalse( errorLogger.hasErrors() );
 		context.addDocument( doc );
 		return context;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/XMLContextTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/XMLContextTest.java
index 1d6e1f7003..b4195e2c5d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/XMLContextTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/reflection/XMLContextTest.java
@@ -1,62 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.annotations.reflection;
 
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 import org.dom4j.io.SAXReader;
 import org.junit.Assert;
 import org.junit.Test;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXNotSupportedException;
 
 import org.hibernate.cfg.EJB3DTDEntityResolver;
 import org.hibernate.cfg.annotations.reflection.XMLContext;
 import org.hibernate.internal.util.xml.ErrorLogger;
 import org.hibernate.internal.util.xml.XMLHelper;
 
+import org.hibernate.testing.boot.ClassLoaderAccessTestingImpl;
+import org.hibernate.testing.boot.ClassLoaderServiceTestingImpl;
+
 /**
  * @author Emmanuel Bernard
  */
 public class XMLContextTest {
 	@Test
 	public void testAll() throws Exception {
-		XMLHelper xmlHelper = new XMLHelper();
-		ClassLoader cl = Thread.currentThread().getContextClassLoader();
-		InputStream is = cl.getResourceAsStream(
+		final XMLHelper xmlHelper = new XMLHelper( ClassLoaderServiceTestingImpl.INSTANCE );
+		final XMLContext context = new XMLContext( ClassLoaderAccessTestingImpl.INSTANCE );
+
+		InputStream is = ClassLoaderServiceTestingImpl.INSTANCE.locateResourceStream(
 				"org/hibernate/test/annotations/reflection/orm.xml"
 		);
 		Assert.assertNotNull( "ORM.xml not found", is );
-		XMLContext context = new XMLContext();
-		ErrorLogger errorLogger = new ErrorLogger();
-		SAXReader saxReader = xmlHelper.createSAXReader( errorLogger, EJB3DTDEntityResolver.INSTANCE );
-		//saxReader.setValidation( false );
+
+		final ErrorLogger errorLogger = new ErrorLogger();
+		final SAXReader saxReader = xmlHelper.createSAXReader( errorLogger, EJB3DTDEntityResolver.INSTANCE );
+
 		try {
 			saxReader.setFeature( "http://apache.org/xml/features/validation/schema", true );
 		}
 		catch ( SAXNotSupportedException e ) {
 			saxReader.setValidation( false );
 		}
 		org.dom4j.Document doc;
 		try {
-			doc = saxReader
-					.read( new InputSource( new BufferedInputStream( is ) ) );
+			doc = saxReader.read( new InputSource( new BufferedInputStream( is ) ) );
 		}
 		finally {
 			try {
 				is.close();
 			}
 			catch ( IOException ioe ) {
 				//log.warn( "Could not close input stream", ioe );
 			}
 		}
 		Assert.assertFalse( errorLogger.hasErrors() );
 		context.addDocument( doc );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/tuplizer/DynamicEntityTuplizer.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/tuplizer/DynamicEntityTuplizer.java
index 980a1719ee..4d86de1bf4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/tuplizer/DynamicEntityTuplizer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/tuplizer/DynamicEntityTuplizer.java
@@ -1,38 +1,37 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-
-//$Id$
 package org.hibernate.test.annotations.tuplizer;
+
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.PojoEntityTuplizer;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DynamicEntityTuplizer extends PojoEntityTuplizer {
 
 		public DynamicEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 			super( entityMetamodel, mappedEntity );
 		}
 
 		protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 			return new DynamicInstantiator( persistentClass.getEntityName() );
 		}
 
 		protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 			// allows defining a custom proxy factory, which is responsible for
 			// generating lazy proxies for a given entity.
 			//
 			// Here we simply use the default...
 			return super.buildProxyFactory( persistentClass, idGetter, idSetter );
 		}
 	}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/ejb3/Ejb3XmlTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/ejb3/Ejb3XmlTestCase.java
index e15617da76..acc9d01c43 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/ejb3/Ejb3XmlTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/ejb3/Ejb3XmlTestCase.java
@@ -1,69 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.annotations.xml.ejb3;
 
 import java.io.InputStream;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 
 import org.dom4j.Document;
 import org.dom4j.io.SAXReader;
 
 import org.hibernate.cfg.annotations.reflection.JPAOverriddenAnnotationReader;
 import org.hibernate.cfg.annotations.reflection.XMLContext;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
+import org.hibernate.testing.boot.ClassLoaderAccessTestingImpl;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Test superclass to provide utility methods for testing the mapping of JPA
  * XML to JPA annotations.  The configuration is built within each test, and no
  * database is used.  Thus, no schema generation or cleanup will be performed.
  */
 abstract class Ejb3XmlTestCase extends BaseUnitTestCase {
 	protected JPAOverriddenAnnotationReader reader;
 
 	protected void assertAnnotationPresent(Class<? extends Annotation> annotationType) {
 		assertTrue(
 				"Expected annotation " + annotationType.getSimpleName() + " was not present",
 				reader.isAnnotationPresent( annotationType )
 		);
 	}
 
 	protected void assertAnnotationNotPresent(Class<? extends Annotation> annotationType) {
 		assertFalse(
 				"Unexpected annotation " + annotationType.getSimpleName() + " was present",
 				reader.isAnnotationPresent( annotationType )
 		);
 	}
 
 	protected JPAOverriddenAnnotationReader getReader(Class<?> entityClass, String fieldName, String ormResourceName)
 			throws Exception {
 		AnnotatedElement el = getAnnotatedElement( entityClass, fieldName );
 		XMLContext xmlContext = getContext( ormResourceName );
-		return new JPAOverriddenAnnotationReader( el, xmlContext );
+		return new JPAOverriddenAnnotationReader( el, xmlContext, ClassLoaderAccessTestingImpl.INSTANCE );
 	}
 
 	protected AnnotatedElement getAnnotatedElement(Class<?> entityClass, String fieldName) throws Exception {
 		return entityClass.getDeclaredField( fieldName );
 	}
 
 	protected XMLContext getContext(String resourceName) throws Exception {
 		InputStream is = getClass().getResourceAsStream( resourceName );
 		assertNotNull( "Could not load resource " + resourceName, is );
 		return getContext( is );
 	}
 
 	protected XMLContext getContext(InputStream is) throws Exception {
-		XMLContext xmlContext = new XMLContext();
+		XMLContext xmlContext = new XMLContext( ClassLoaderAccessTestingImpl.INSTANCE );
 		Document doc = new SAXReader().read( is );
 		xmlContext.addDocument( doc );
 		return xmlContext;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/bytecode/BeanReflectionHelper.java b/hibernate-core/src/test/java/org/hibernate/test/bytecode/BeanReflectionHelper.java
index d3a6a42686..164558b793 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/bytecode/BeanReflectionHelper.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/bytecode/BeanReflectionHelper.java
@@ -1,83 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.bytecode;
 import java.util.Date;
 
-import org.hibernate.property.BasicPropertyAccessor;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.internal.PropertyAccessStrategyBasicImpl;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccess;
+import org.hibernate.property.access.spi.Setter;
 
 /**
  * @author Steve Ebersole
  */
 public class BeanReflectionHelper {
 
 	public static final Object[] TEST_VALUES = new Object[] {
 			"hello", new Long(1), new Integer(1), new Date(), new Long(1), new Integer(1), new Object()
 	};
 
 	private static final String[] getterNames = new String[7];
 	private static final String[] setterNames = new String[7];
 	private static final Class[] types = new Class[7];
 
 	static {
-		BasicPropertyAccessor propertyAccessor = new BasicPropertyAccessor();
-		Getter getter = propertyAccessor.getGetter( Bean.class, "someString" );
-		Setter setter = propertyAccessor.getSetter( Bean.class, "someString" );
+		final PropertyAccessStrategyBasicImpl propertyAccessStrategy = new PropertyAccessStrategyBasicImpl();
+
+		PropertyAccess propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someString" );
+		Getter getter = propertyAccess.getGetter();
+		Setter setter = propertyAccess.getSetter();
 		getterNames[0] = getter.getMethodName();
 		types[0] = getter.getReturnType();
 		setterNames[0] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "someLong" );
-		setter = propertyAccessor.getSetter( Bean.class, "someLong" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someLong" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[1] = getter.getMethodName();
 		types[1] = getter.getReturnType();
 		setterNames[1] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "someInteger" );
-		setter = propertyAccessor.getSetter( Bean.class, "someInteger" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someInteger" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[2] = getter.getMethodName();
 		types[2] = getter.getReturnType();
 		setterNames[2] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "someDate" );
-		setter = propertyAccessor.getSetter( Bean.class, "someDate" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someDate" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[3] = getter.getMethodName();
 		types[3] = getter.getReturnType();
 		setterNames[3] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "somelong" );
-		setter = propertyAccessor.getSetter( Bean.class, "somelong" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "somelong" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[4] = getter.getMethodName();
 		types[4] = getter.getReturnType();
 		setterNames[4] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "someint" );
-		setter = propertyAccessor.getSetter( Bean.class, "someint" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someint" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[5] = getter.getMethodName();
 		types[5] = getter.getReturnType();
 		setterNames[5] = setter.getMethodName();
 
-		getter = propertyAccessor.getGetter( Bean.class, "someObject" );
-		setter = propertyAccessor.getSetter( Bean.class, "someObject" );
+		propertyAccess = propertyAccessStrategy.buildPropertyAccess( Bean.class, "someObject" );
+		getter = propertyAccess.getGetter();
+		setter = propertyAccess.getSetter();
 		getterNames[6] = getter.getMethodName();
 		types[6] = getter.getReturnType();
 		setterNames[6] = setter.getMethodName();
 	}
 
 	public static String[] getGetterNames() {
 		return getterNames;
 	}
 
 	public static String[] getSetterNames() {
 		return setterNames;
 	}
 
 	public static Class[] getTypes() {
 		return types;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer/MyEntityTuplizer.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer/MyEntityTuplizer.java
index e9132a6575..043ad7b011 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer/MyEntityTuplizer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer/MyEntityTuplizer.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.dynamicentity.tuplizer;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.PojoEntityTuplizer;
 
 /**
  * @author Steve Ebersole
  */
 public class MyEntityTuplizer extends PojoEntityTuplizer {
 
 	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
 	protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		return new MyEntityInstantiator( persistentClass.getEntityName() );
 	}
 
 	protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// allows defining a custom proxy factory, which is responsible for
 		// generating lazy proxies for a given entity.
 		//
 		// Here we simply use the default...
 		return super.buildProxyFactory( persistentClass, idGetter, idSetter );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
index 4f71744875..f519710578 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
@@ -1,68 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.dynamicentity.tuplizer2;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.test.dynamicentity.ProxyHelper;
 import org.hibernate.test.dynamicentity.tuplizer.MyEntityInstantiator;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.PojoEntityTuplizer;
 
 /**
  * @author Steve Ebersole
  */
 public class MyEntityTuplizer extends PojoEntityTuplizer {
 
 	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
 	}
 
 	protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		return new MyEntityInstantiator( persistentClass.getEntityName() );
 	}
 
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		String entityName = ProxyHelper.extractEntityName( entityInstance );
 		if ( entityName == null ) {
 			entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
 		}
 		return entityName;
 	}
 
 	protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// allows defining a custom proxy factory, which is responsible for
 		// generating lazy proxies for a given entity.
 		//
 		// Here we simply use the default...
 		return super.buildProxyFactory( persistentClass, idGetter, idSetter );
 	}
 
 	public static class MyEntityNameResolver implements EntityNameResolver {
 		public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();
 
 		public String resolveEntityName(Object entity) {
 			return ProxyHelper.extractEntityName( entity );
 		}
 
 		public boolean equals(Object obj) {
 			return getClass().equals( obj.getClass() );
 		}
 
 		public int hashCode() {
 			return getClass().hashCode();
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/AbstractExecutable.java b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/AbstractExecutable.java
index 56449819fb..b3738284c8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/AbstractExecutable.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/AbstractExecutable.java
@@ -1,59 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.instrument.cases;
 
 import org.hibernate.SessionFactory;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.MetadataSources;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.bytecode.spi.InstrumentedClassLoader;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.ServiceRegistry;
 
-import org.hibernate.testing.ServiceRegistryBuilder;
-
 /**
  * @author Steve Ebersole
  */
 public abstract class AbstractExecutable implements Executable {
 	private ServiceRegistry serviceRegistry;
 	private SessionFactory factory;
 
     @Override
 	public final void prepare() {
-		Configuration cfg = new Configuration().setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
-		String[] resources = getResources();
-		for ( String resource : resources ) {
-			cfg.addResource( resource );
+		BootstrapServiceRegistryBuilder bsrb = new BootstrapServiceRegistryBuilder();
+		// make sure we pick up the TCCL, and make sure its the isolated CL...
+		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+		if ( classLoader == null ) {
+			throw new RuntimeException( "Isolated ClassLoader not yet set as TCCL" );
+		}
+		if ( !InstrumentedClassLoader.class.isInstance( classLoader ) ) {
+			throw new RuntimeException( "Isolated ClassLoader not yet set as TCCL" );
+		}
+		bsrb.applyClassLoader( classLoader );
+
+		serviceRegistry = new StandardServiceRegistryBuilder( bsrb.build() )
+				.applySetting( Environment.HBM2DDL_AUTO, "create-drop" )
+				.build();
+
+		MetadataSources metadataSources = new MetadataSources( serviceRegistry );
+		for ( String resource : getResources() ) {
+			metadataSources.addResource( resource );
 		}
-		serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() );
-		factory = cfg.buildSessionFactory( serviceRegistry );
+
+		factory = metadataSources.buildMetadata().buildSessionFactory();
 	}
 
     @Override
 	public final void complete() {
 		try {
 			cleanup();
 		}
 		finally {
 			factory.close();
-			factory = null;
-			if ( serviceRegistry != null ) {
-				ServiceRegistryBuilder.destroy( serviceRegistry );
-				serviceRegistry = null;
-			}
+			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	protected SessionFactory getFactory() {
 		return factory;
 	}
 
 	protected void cleanup() {
 	}
 
 	protected String[] getResources() {
 		return new String[] { "org/hibernate/test/instrument/domain/Documents.hbm.xml" };
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestFetchingLazyToOneExecutable.java b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestFetchingLazyToOneExecutable.java
index 6f9caaa0ed..e76cc1a487 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestFetchingLazyToOneExecutable.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestFetchingLazyToOneExecutable.java
@@ -1,160 +1,175 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.instrument.cases;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
+import org.hibernate.boot.MetadataSources;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.bytecode.spi.InstrumentedClassLoader;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
+import org.hibernate.cfg.Environment;
 import org.hibernate.service.ServiceRegistry;
 
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.test.instrument.domain.Passport;
 import org.hibernate.test.instrument.domain.Person;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 public class TestFetchingLazyToOneExecutable implements Executable {
 	private ServiceRegistry serviceRegistry;
 	private SessionFactory factory;
 
 	@Override
 	public void execute() throws Exception {
 		doBaselineAssertions();
 
 		doFetchNonMappedBySideAssertions();
 		doFetchMappedBySideAssertions();
 	}
 
 	private void doBaselineAssertions() {
 		{
 			// First, load from the non-owning side by id.  Person#passport should be uninitialized
 			Session s = factory.openSession();
 			s.beginTransaction();
 			Person person = (Person) s.get( Person.class, 1 );
 			assertTrue( Hibernate.isInitialized( person ) );
 			assertFalse( Hibernate.isPropertyInitialized( person, "passport" ) );
 			assertNotNull( person.getPassport() );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// Then, load from the owning side by id.  Passport#person should be uninitialized
 			Session s = factory.openSession();
 			s.beginTransaction();
 			Passport passport = (Passport) s.get( Passport.class, 1 );
 			assertTrue( Hibernate.isInitialized( passport ) );
 			assertFalse( Hibernate.isPropertyInitialized( passport, "person" ) );
 			assertNotNull( passport.getPerson() );
 			s.getTransaction().commit();
 			s.close();
 		}
 	}
 
 	private void doFetchNonMappedBySideAssertions() {
 		// try to eagerly fetch the association from the owning (non-mappedBy) side
 		Session s = factory.openSession();
 		s.beginTransaction();
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // the whole question here is design, and whether the `fetch all properties` should be needed
 //		Passport p = (Passport) s.createQuery( "select p from Passport p join fetch p.person" ).uniqueResult();
 // versus:
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		Passport p = (Passport) s.createQuery( "select p from Passport p fetch all properties join fetch p.person" ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( p ) );
 		assertTrue(
 				"Assertion that the eager fetch of non-mappedBy association (Passport#person) was performed properly",
 				Hibernate.isPropertyInitialized( p, "person" )
 		);
 		assertNotNull( p.getPerson() );
 		assertTrue( Hibernate.isInitialized( p.getPerson() ) );
 		assertSame( p, p.getPerson().getPassport() );
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	private void doFetchMappedBySideAssertions() {
 		// try to eagerly fetch the association from the non-owning (mappedBy) side
 		Session s = factory.openSession();
 		s.beginTransaction();
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // the whole question here is design, and whether the `fetch all properties` should be needed
 //		Person p  = (Person) s.createQuery( "select p from Person p join fetch p.passport" ).uniqueResult();
 // versus:
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		Person p  = (Person) s.createQuery( "select p from Person p fetch all properties join fetch p.passport" ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( p ) );
 		assertTrue(
 				"Assertion that the eager fetch of mappedBy association (Person#passport) was performed properly",
 				Hibernate.isPropertyInitialized( p, "passport" )
 		);
 		assertNotNull( p.getPassport() );
 		assertTrue( Hibernate.isInitialized( p.getPassport() ) );
 		assertSame( p, p.getPassport().getPerson() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	public final void prepare() {
-		Configuration cfg = new Configuration()
-				.setProperty( AvailableSettings.HBM2DDL_AUTO, "create-drop" )
-				.setProperty( AvailableSettings.USE_SECOND_LEVEL_CACHE, "false" );
-		cfg.addAnnotatedClass( Person.class );
-		cfg.addAnnotatedClass( Passport.class );
-		serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() );
-		factory = cfg.buildSessionFactory( serviceRegistry );
+		BootstrapServiceRegistryBuilder bsrb = new BootstrapServiceRegistryBuilder();
+		// make sure we pick up the TCCL, and make sure its the isolated CL...
+		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+		if ( classLoader == null ) {
+			throw new RuntimeException( "Isolated ClassLoader not yet set as TCCL" );
+		}
+		if ( !InstrumentedClassLoader.class.isInstance( classLoader ) ) {
+			throw new RuntimeException( "Isolated ClassLoader not yet set as TCCL" );
+		}
+		bsrb.applyClassLoader( classLoader );
+
+		serviceRegistry = new StandardServiceRegistryBuilder( bsrb.build() )
+				.applySetting( Environment.HBM2DDL_AUTO, "create-drop" )
+				.applySetting( AvailableSettings.USE_SECOND_LEVEL_CACHE, "false" )
+				.build();
+
+		MetadataSources metadataSources = new MetadataSources( serviceRegistry );
+		metadataSources.addAnnotatedClass( Person.class );
+		metadataSources.addAnnotatedClass( Passport.class );
+
+		factory = metadataSources.buildMetadata().buildSessionFactory();
 
 		createData();
 	}
 
 	private void createData() {
 		Person steve = new Person( "Steve" );
 		Passport passport = new Passport( steve, "123456789", "Acme Emirates" );
 
 		Session s = factory.openSession();
 		s.beginTransaction();
 		s.save( steve );
 		s.save( passport );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	public final void complete() {
 		try {
 			cleanupData();
 		}
 		finally {
 			factory.close();
-			factory = null;
-			if ( serviceRegistry != null ) {
-				ServiceRegistryBuilder.destroy( serviceRegistry );
-				serviceRegistry = null;
-			}
+			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	private void cleanupData() {
 		Session s = factory.openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Passport" ).executeUpdate();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jdbc/internal/AggressiveReleaseTest.java b/hibernate-core/src/test/java/org/hibernate/test/jdbc/internal/AggressiveReleaseTest.java
index 2052ae3c5b..ff19199c91 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jdbc/internal/AggressiveReleaseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jdbc/internal/AggressiveReleaseTest.java
@@ -1,251 +1,242 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.jdbc.internal;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.sql.Connection;
-import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 
-import org.hibernate.ConnectionReleaseMode;
-import org.hibernate.Session;
-import org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl;
-import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;
-
-import org.hibernate.test.common.BasicTestingJdbcServiceImpl;
-import org.hibernate.test.common.JdbcConnectionAccessImpl;
-import org.hibernate.test.common.JournalingConnectionObserver;
+import org.hibernate.testing.boot.BasicTestingJdbcServiceImpl;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.junit.Test;
 
 /**
  * @author Steve Ebersole
  */
 public class AggressiveReleaseTest extends BaseCoreFunctionalTestCase {
 	
 	private BasicTestingJdbcServiceImpl services = new BasicTestingJdbcServiceImpl();
 	
 	@Override
 	protected void prepareTest() throws Exception {
 		services.prepare( true );
 
 		Connection connection = null;
 		Statement stmnt = null;
 		try {
 			connection = services.getBootstrapJdbcConnectionAccess().obtainConnection();
 			stmnt = connection.createStatement();
 			stmnt.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			stmnt.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 		}
 		finally {
 			if ( stmnt != null ) {
 				try {
 					stmnt.close();
 				}
 				catch ( SQLException ignore ) {
 				}
 			}
 			if ( connection != null ) {
 				try {
 					services.getBootstrapJdbcConnectionAccess().releaseConnection( connection );
 				}
 				catch ( SQLException ignore ) {
 				}
 			}
 		}
 	}
 	
 	@Override
 	protected void cleanupTest() throws Exception {
 		Connection connection = null;
 		Statement stmnt = null;
 		try {
 			connection = services.getBootstrapJdbcConnectionAccess().obtainConnection();
 			stmnt = connection.createStatement();
 			stmnt.execute( "drop table SANDBOX_JDBC_TST if exists" );
 		}
 		finally {
 			if ( stmnt != null ) {
 				try {
 					stmnt.close();
 				}
 				catch ( SQLException ignore ) {
 				}
 			}
 			if ( connection != null ) {
 				try {
 					services.getBootstrapJdbcConnectionAccess().releaseConnection( connection );
 				}
 				catch ( SQLException ignore ) {
 				}
 			}
 		}
 
 		services.release();
 	}
 	
 	@Test
 	public void testBasicRelease() {
 //		Session session = openSession();
 //		SessionImplementor sessionImpl = (SessionImplementor) session;
 //
 //		LogicalConnectionImplementor logicalConnection = new LogicalConnectionImpl( null,
 //				ConnectionReleaseMode.AFTER_STATEMENT, services, new JdbcConnectionAccessImpl(
 //						services.getConnectionProvider() ) );
 //
 //		JdbcCoordinatorImpl jdbcCoord = new JdbcCoordinatorImpl( logicalConnection,
 //				sessionImpl );
 //		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 //		logicalConnection.addObserver( observer );
 //
 //		try {
 //			PreparedStatement ps = jdbcCoord.getStatementPreparer().prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 //			ps.setLong( 1, 1 );
 //			ps.setString( 2, "name" );
 //			jdbcCoord.getResultSetReturn().execute( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 //			jdbcCoord.release( ps );
 //			assertFalse( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //		}
 //		catch ( SQLException sqle ) {
 //			fail( "incorrect exception type : sqlexception" );
 //		}
 //		finally {
 //			session.close();
 //		}
 //
 //		assertFalse( jdbcCoord.hasRegisteredResources() );
 	}
 
 	@Test
 	public void testReleaseCircumventedByHeldResources() {
 //		Session session = openSession();
 //		SessionImplementor sessionImpl = (SessionImplementor) session;
 //
 //		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl( null,
 //				ConnectionReleaseMode.AFTER_STATEMENT, services, new JdbcConnectionAccessImpl(
 //						services.getConnectionProvider() ) );
 //		JdbcCoordinatorImpl jdbcCoord = new JdbcCoordinatorImpl( logicalConnection,
 //				sessionImpl.getTransactionCoordinator() );
 //		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 //		logicalConnection.addObserver( observer );
 //
 //		try {
 //			PreparedStatement ps = jdbcCoord.getStatementPreparer().prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 //			ps.setLong( 1, 1 );
 //			ps.setString( 2, "name" );
 //			jdbcCoord.getResultSetReturn().execute( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 //			jdbcCoord.release( ps );
 //			assertFalse( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //
 //			// open a result set and hold it open...
 //			ps = jdbcCoord.getStatementPreparer().prepareStatement( "select * from SANDBOX_JDBC_TST" );
 //			jdbcCoord.getResultSetReturn().extract( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //
 //			// open a second result set
 //			PreparedStatement ps2 = jdbcCoord.getStatementPreparer().prepareStatement( "select * from SANDBOX_JDBC_TST" );
 //			jdbcCoord.getResultSetReturn().execute( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //			// and close it...
 //			jdbcCoord.release( ps2 );
 //			// the release should be circumvented...
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //
 //			// let the close of the logical connection below release all resources (hopefully)...
 //		}
 //		catch ( SQLException sqle ) {
 //			fail( "incorrect exception type : sqlexception" );
 //		}
 //		finally {
 //			jdbcCoord.close();
 //			session.close();
 //		}
 //
 //		assertFalse( jdbcCoord.hasRegisteredResources() );
 //		assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //		assertEquals( 2, observer.getPhysicalConnectionReleasedCount() );
 	}
 
 	@Test
 	public void testReleaseCircumventedManually() {
 //		Session session = openSession();
 //		SessionImplementor sessionImpl = (SessionImplementor) session;
 //
 //		LogicalConnectionImpl logicalConnection = new LogicalConnectionImpl( null,
 //				ConnectionReleaseMode.AFTER_STATEMENT, services, new JdbcConnectionAccessImpl(
 //						services.getConnectionProvider() ) );
 //		JdbcCoordinatorImpl jdbcCoord = new JdbcCoordinatorImpl( logicalConnection,
 //				sessionImpl.getTransactionCoordinator() );
 //		JournalingConnectionObserver observer = new JournalingConnectionObserver();
 //		logicalConnection.addObserver( observer );
 //
 //		try {
 //			PreparedStatement ps = jdbcCoord.getStatementPreparer().prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 //			ps.setLong( 1, 1 );
 //			ps.setString( 2, "name" );
 //			jdbcCoord.getResultSetReturn().execute( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 0, observer.getPhysicalConnectionReleasedCount() );
 //			jdbcCoord.release( ps );
 //			assertFalse( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 1, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //
 //			// disable releases...
 //			jdbcCoord.disableReleases();
 //
 //			// open a result set...
 //			ps = jdbcCoord.getStatementPreparer().prepareStatement( "select * from SANDBOX_JDBC_TST" );
 //			jdbcCoord.getResultSetReturn().extract( ps );
 //			assertTrue( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //			// and close it...
 //			jdbcCoord.release( ps );
 //			// the release should be circumvented...
 //			assertFalse( jdbcCoord.hasRegisteredResources() );
 //			assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //			assertEquals( 1, observer.getPhysicalConnectionReleasedCount() );
 //
 //			// let the close of the logical connection below release all resources (hopefully)...
 //		}
 //		catch ( SQLException sqle ) {
 //			fail( "incorrect exception type : sqlexception" );
 //		}
 //		finally {
 //			jdbcCoord.close();
 //			session.close();
 //		}
 //
 //		assertFalse( jdbcCoord.hasRegisteredResources() );
 //		assertEquals( 2, observer.getPhysicalConnectionObtainedCount() );
 //		assertEquals( 2, observer.getPhysicalConnectionReleasedCount() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
index 67d248a319..af6aaf2ee1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
@@ -1,684 +1,690 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.legacy;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.dialect.TeradataDialect;
 import org.jboss.logging.Logger;
 import org.junit.Test;
 
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InterbaseDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.dialect.function.SQLFunction;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 
 public class SQLFunctionsTest extends LegacyTestCase {
 	private static final Logger log = Logger.getLogger( SQLFunctionsTest.class );
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/AltSimple.hbm.xml",
 			"legacy/Broken.hbm.xml",
 			"legacy/Blobber.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testDialectSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Iterator iter = s.createQuery( "select max(s.count) from Simple s" ).iterate();
 
 		if ( getDialect() instanceof MySQLDialect ) assertTrue( iter.hasNext() && iter.next()==null );
 
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple Dialect Function Test");
 		simple.setAddress("Simple Address");
 		simple.setPay( Float.valueOf(45.8f) );
 		simple.setCount(2);
 		s.save( simple );
 
 		// Test to make sure allocating an specified object operates correctly.
 		assertTrue(
 				s.createQuery( "select new org.hibernate.test.legacy.S(s.count, s.address) from Simple s" ).list().size() == 1
 		);
 
 		// Quick check the base dialect functions operate correctly
 		assertTrue(
 				s.createQuery( "select max(s.count) from Simple s" ).list().size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select count(*) from Simple s" ).list().size() == 1
 		);
 
 		if ( getDialect() instanceof Oracle9iDialect ) {
 			// Check Oracle Dialect mix of dialect functions - no args (no parenthesis and single arg functions
 			List rset = s.createQuery( "select s.name, sysdate, trunc(s.pay), round(s.pay) from Simple s" ).list();
 			assertNotNull("Name string should have been returned",(((Object[])rset.get(0))[0]));
 			assertNotNull("Todays Date should have been returned",(((Object[])rset.get(0))[1]));
 			assertEquals("trunc(45.8) result was incorrect ", Float.valueOf(45), ( (Object[]) rset.get(0) )[2] );
 			assertEquals("round(45.8) result was incorrect ", Float.valueOf(46), ( (Object[]) rset.get(0) )[3] );
 
 			simple.setPay(new Float(-45.8));
 			s.update(simple);
 
 			// Test type conversions while using nested functions (Float to Int).
 			rset = s.createQuery( "select abs(round(s.pay)) from Simple s" ).list();
 			assertEquals("abs(round(-45.8)) result was incorrect ", Float.valueOf( 46 ), rset.get(0));
 
 			// Test a larger depth 3 function example - Not a useful combo other than for testing
 			assertTrue(
 					s.createQuery( "select trunc(round(sysdate)) from Simple s" ).list().size() == 1
 			);
 
 			// Test the oracle standard NVL funtion as a test of multi-param functions...
 			simple.setPay(null);
 			s.update(simple);
 			Integer value = (Integer) s.createQuery(
 					"select MOD( NVL(s.pay, 5000), 2 ) from Simple as s where s.id = 10"
 			).list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		if ( (getDialect() instanceof HSQLDialect) ) {
 			// Test the hsql standard MOD funtion as a test of multi-param functions...
 			Integer value = (Integer) s.createQuery( "select MOD(s.count, 2) from Simple as s where s.id = 10" )
 					.list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetProperties() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties(simple);
 		assertTrue( q.list().get(0)==simple );
 		//misuse of "Single" as a propertyobject, but it was the first testclass i found with a collection ;)
 		Single single = new Single() { // trivial hack to test properties with arrays.
-			String[] getStuff() { return (String[]) getSeveral().toArray(new String[getSeveral().size()]); }
+			String[] getStuff() {
+				return (String[]) getSeveral().toArray(new String[getSeveral().size()]);
+			}
+			void setStuff(String[] stuff) {
+				setSeveral( Arrays.asList( stuff ) );
+			}
 		};
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		single.setSeveral(l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :several");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :stuff");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetPropertiesMap() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		Map parameters = new HashMap();
 		parameters.put("name", simple.getName());
 		parameters.put("count", new Integer(simple.getCount()));
 
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties((parameters));
 		assertTrue( q.list().get(0)==simple );
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		parameters.put("several", l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 
 
 		parameters.put("stuff", l.toArray(new String[0]));
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testBroken() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Broken b = new Fixed();
 		b.setId( new Long(123));
 		b.setOtherId("foobar");
 		s.save(b);
 		s.flush();
 		b.setTimestamp( new Date() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		b = (Broken) s.load( Broken.class, b );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNothinToUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName( "Simple 1" );
 		Long id = (Long) s.save( simple );
 		assertEquals( Long.valueOf( 10 ), id );
 		assertEquals( Long.valueOf( 10 ), simple.getId() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setString("name", "Simple 2");
 		q.setCacheable(true);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQueryRegion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 
 		if ( getDialect() instanceof DB2Dialect) {
 			s.createQuery( "from Simple s where repeat('foo', 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat(s.name, 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat( lower(s.name), 3 + (1-1) / 2) = 'foofoofoo'" ).list();
 		}
 
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.name ) ='SIMPLE 1'" ).list().size()==1
 		);
 		if ( !(getDialect() instanceof HSQLDialect) ) {
 			assertTrue(
 					s.createQuery(
 							"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"
 					).list()
 							.size()==1
 			);
 		}
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof SybaseDialect) && !(getDialect() instanceof SQLServerDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof InterbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) { //My SQL has a funny concatenation operator
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name || ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof SybaseDialect) ) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name + ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof MckoiDialect) || (getDialect() instanceof TimesTenDialect)) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( concat(s.name, ' foo') ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 
 		Simple other = new Simple( Long.valueOf(20) );
 		other.setName("Simple 2");
 		other.setCount(12);
 		simple.setOther(other);
 		s.save( other );
 		//s.find("from Simple s where s.name ## 'cat|rat|bag'");
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.other.name ) ='SIMPLE 2'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where not ( upper( s.other.name ) ='SIMPLE 2' )" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery(
 						"select distinct s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"
 				).list()
 						.size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"select s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"
 				).list()
 						.size()==1
 		);
 		Simple min = new Simple( Long.valueOf(30) );
 		min.setCount(-1);
 		s.save( min );
 		if ( ! (getDialect() instanceof MySQLDialect) && ! (getDialect() instanceof HSQLDialect) ) { //My SQL has no subqueries
 			assertTrue(
 					s.createQuery( "from Simple s where s.count > ( select min(sim.count) from Simple sim )" )
 							.list()
 							.size()==2
 			);
 			t.commit();
 			t = s.beginTransaction();
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.count>=0 ) and s.count >= 0"
 					).list()
 							.size()==2
 			);
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"
 					).list()
 							.size()==1
 			);
 		}
 
 		Iterator iter = s.createQuery( "select sum(s.count) from Simple s group by s.count having sum(s.count) > 10" )
 				.iterate();
 		assertTrue( iter.hasNext() );
 		assertEquals( Long.valueOf(12), iter.next() );
 		assertTrue( !iter.hasNext() );
 		if ( ! (getDialect() instanceof MySQLDialect) ) {
 			iter = s.createQuery( "select s.count from Simple s group by s.count having s.count = 12" ).iterate();
 			assertTrue( iter.hasNext() );
 		}
 
 		s.createQuery(
 				"select s.id, s.count, count(t), max(t.date) from Simple s, Simple t where s.count = t.count group by s.id, s.count order by s.count"
 		).iterate();
 
 		Query q = s.createQuery("from Simple s");
 		q.setMaxResults(10);
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s");
 		q.setMaxResults(1);
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s");
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s where s.name = ?");
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name = ? and upper(s.name) = ?");
 		q.setString(1, "SIMPLE 1");
 		q.setString(0, "Simple 1");
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("from Simple s where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1");
 		q.setParameter("bar", "SIMPLE 1");
 		q.setString("foo", "Simple 1");
 		q.setInteger("count", 69);
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("select s.id from Simple s");
 		q.setFirstResult(1);
 		q.setMaxResults(2);
 		iter = q.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Long );
 			i++;
 		}
 		assertTrue(i==2);
 		q = s.createQuery("select all s, s.other from Simple s where s = :s");
 		q.setParameter("s", simple);
 		assertTrue( q.list().size()==1 );
 
 
 		q = s.createQuery("from Simple s where s.name in (:name_list) and s.count > :count");
 		HashSet set = new HashSet();
 		set.add("Simple 1"); set.add("foo");
 		q.setParameterList( "name_list", set );
 		q.setParameter("count", Integer.valueOf( -1 ) );
 		assertTrue( q.list().size()==1 );
 
 		ScrollableResults sr = s.createQuery("from Simple s").scroll();
 		sr.next();
 		sr.get(0);
 		sr.close();
 
 		s.delete(other);
 		s.delete(simple);
 		s.delete(min);
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testBlobClob() throws Exception {
 		// Sybase does not support ResultSet.getBlob(String)
 		if ( getDialect() instanceof SybaseDialect || getDialect() instanceof Sybase11Dialect || getDialect() instanceof SybaseASE15Dialect || getDialect() instanceof SybaseAnywhereDialect  || getDialect() instanceof TeradataDialect) {
 			return;
 		}
 		Session s = openSession();
 		s.beginTransaction();
 		Blobber b = new Blobber();
 		b.setBlob( s.getLobHelper().createBlob( "foo/bar/baz".getBytes() ) );
 		b.setClob( s.getLobHelper().createClob("foo/bar/baz") );
 		s.save(b);
 		//s.refresh(b);
 		//assertTrue( b.getClob() instanceof ClobImpl );
 		s.flush();
 
 		s.refresh(b);
 		//b.getBlob().setBytes( 2, "abc".getBytes() );
 		b.getClob().getSubString(2, 3);
 		//b.getClob().setString(2, "abc");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		Blobber b2 = new Blobber();
 		s.save(b2);
 		b2.setBlob( b.getBlob() );
 		b.setBlob(null);
 		//assertTrue( b.getClob().getSubString(1, 3).equals("fab") );
 		b.getClob().getSubString(1, 6);
 		//b.getClob().setString(1, "qwerty");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		b.setClob( s.getLobHelper().createClob("xcvfxvc xcvbx cvbx cvbx cvbxcvbxcvbxcvb") );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		assertTrue( b.getClob().getSubString(1, 7).equals("xcvfxvc") );
 		//b.getClob().setString(5, "1234567890");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSqlFunctionAsAlias() throws Exception {
 		String functionName = locateAppropriateDialectFunctionNameForAliasTest();
 		if (functionName == null) {
             log.info("Dialect does not list any no-arg functions");
 			return;
 		}
 
         log.info("Using function named [" + functionName + "] for 'function as alias' test");
 		String query = "select " + functionName + " from Simple as " + functionName + " where " + functionName + ".id = 10";
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List result = s.createQuery( query ).list();
 		assertTrue( result.size() == 1 );
 		assertTrue(result.get(0) instanceof Simple);
 		s.delete( result.get(0) );
 		t.commit();
 		s.close();
 	}
 
 	private String locateAppropriateDialectFunctionNameForAliasTest() {
 		for (Iterator itr = getDialect().getFunctions().entrySet().iterator(); itr.hasNext(); ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final SQLFunction function = (SQLFunction) entry.getValue();
 			if ( !function.hasArguments() && !function.hasParenthesesIfNoArguments() ) {
 				return (String) entry.getKey();
 			}
 		}
 		return null;
 	}
 
 	@Test
 	public void testCachedQueryOnInsert() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s");
 		List list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Simple simple2 = new Simple( Long.valueOf(12) );
 		simple2.setCount(133);
 		s.save( simple2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		Iterator i = list.iterator();
 		while ( i.hasNext() ) s.delete( i.next() );
 		t.commit();
 		s.close();
 
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassTest.java b/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassTest.java
index dceb4bae3a..96637a2332 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassTest.java
@@ -1,55 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.mapping;
 
 import org.hibernate.MappingException;
+import org.hibernate.boot.registry.StandardServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
+import org.junit.After;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 public class PersistentClassTest extends BaseUnitTestCase {
 
+	private StandardServiceRegistry serviceRegistry;
+	private MetadataBuildingContext metadataBuildingContext;
+
+	@Before
+	public void prepare() {
+		serviceRegistry = new StandardServiceRegistryBuilder().build();
+		metadataBuildingContext = new MetadataBuildingContextTestingImpl( serviceRegistry );
+	}
+
+	@After
+	public void release() {
+		StandardServiceRegistryBuilder.destroy( serviceRegistry );
+	}
+
 	@Test
 	public void testGetMappedClass() {
-		RootClass pc = new RootClass();
+		RootClass pc = new RootClass( metadataBuildingContext );
 		pc.setClassName(String.class.getName());
 		Assert.assertEquals(String.class.getName(), pc.getClassName());
 		Assert.assertEquals(String.class, pc.getMappedClass());
 		pc.setClassName(Integer.class.getName());
 		Assert.assertEquals(Integer.class, pc.getMappedClass());
 	}
 	
 	@Test
 	public void testGetProxyInterface() {
-		RootClass pc = new RootClass();
+		RootClass pc = new RootClass( metadataBuildingContext );
 		pc.setProxyInterfaceName(String.class.getName());
 		Assert.assertEquals(String.class.getName(), pc.getProxyInterfaceName());
 		Assert.assertEquals(String.class, pc.getProxyInterface());
 		pc.setProxyInterfaceName(Integer.class.getName());
 		Assert.assertEquals(Integer.class, pc.getProxyInterface());
 	}
 	
 	@Test
 	public void testGetProperty() {
-		RootClass pc = new RootClass();
+		RootClass pc = new RootClass( metadataBuildingContext );
 		Property p = new Property();
 		p.setName("name");
 		pc.addProperty(p);
 		Assert.assertEquals(p, pc.getProperty("name"));
 		Assert.assertEquals(p, pc.getProperty("name.test"));
 		try {
 			Assert.assertNull(pc.getProperty("test"));
 			Assert.fail("MappingException expected");
 		} catch (MappingException e) {
 			// expected
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassVisitorTest.java b/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassVisitorTest.java
index 0a5548c2ff..7dae8b308b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassVisitorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/mapping/PersistentClassVisitorTest.java
@@ -1,67 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.mapping;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.PersistentClassVisitor;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.mapping.UnionSubclass;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
 
 /**
  * Simple smoke style tests to make sure visitors keep working.
  * 
  * @author max
  */
 public class PersistentClassVisitorTest extends BaseUnitTestCase {
+
+	private StandardServiceRegistry serviceRegistry;
+	private MetadataBuildingContext metadataBuildingContext;
+
+	@Before
+	public void prepare() {
+		serviceRegistry = new StandardServiceRegistryBuilder().build();
+		metadataBuildingContext = new MetadataBuildingContextTestingImpl( serviceRegistry );
+	}
+
+	@After
+	public void release() {
+		StandardServiceRegistryBuilder.destroy( serviceRegistry );
+	}
+
 	@Test
 	public void testProperCallbacks() {
 		PersistentClassVisitorValidator vv = new PersistentClassVisitorValidator();
-		new RootClass().accept( vv );
-		new Subclass( new RootClass() ).accept( vv );
-		new JoinedSubclass( new RootClass() ).accept( vv );
-		new SingleTableSubclass( new RootClass() ).accept( vv );
-		new UnionSubclass( new RootClass() ).accept( vv );
+		new RootClass( metadataBuildingContext ).accept( vv );
+		new Subclass( new RootClass( metadataBuildingContext ), metadataBuildingContext ).accept( vv );
+		new JoinedSubclass( new RootClass( metadataBuildingContext ), metadataBuildingContext ).accept( vv );
+		new SingleTableSubclass( new RootClass( metadataBuildingContext ), metadataBuildingContext ).accept( vv );
+		new UnionSubclass( new RootClass( metadataBuildingContext ), metadataBuildingContext ).accept( vv );
 	}
 
 	static public class PersistentClassVisitorValidator implements PersistentClassVisitor {
 
 		private Object validate(Class expectedClass, Object visitee) {
 			if (!visitee.getClass().getName().equals(expectedClass.getName())) {
 				throw new IllegalStateException(visitee.getClass().getName()
 						+ " did not call proper accept method. Was "
 						+ expectedClass.getName());
 			}
 			return null;
 		}
 
 		public Object accept(RootClass class1) {
 			return validate(RootClass.class, class1);
 		}
 
 		public Object accept(UnionSubclass subclass) {
 			return validate(UnionSubclass.class, subclass);
 		}
 
 		public Object accept(SingleTableSubclass subclass) {
 			return validate(SingleTableSubclass.class, subclass);
 		}
 
 		public Object accept(JoinedSubclass subclass) {
 			return validate(JoinedSubclass.class, subclass);
 		}
 
 		public Object accept(Subclass subclass) {
 			return validate(Subclass.class, subclass);
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/mapping/ValueVisitorTest.java b/hibernate-core/src/test/java/org/hibernate/test/mapping/ValueVisitorTest.java
index 8e0b62e6c9..adc718b19f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/mapping/ValueVisitorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/mapping/ValueVisitorTest.java
@@ -1,130 +1,151 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.mapping;
 
 import org.hibernate.boot.MetadataSources;
+import org.hibernate.boot.registry.StandardServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.mapping.Any;
 import org.hibernate.mapping.Array;
 import org.hibernate.mapping.Bag;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.IdentifierBag;
 import org.hibernate.mapping.List;
 import org.hibernate.mapping.ManyToOne;
 import org.hibernate.mapping.Map;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.PrimitiveArray;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.Set;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.ValueVisitor;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
+import org.hibernate.testing.boot.MetadataBuildingContextTestingImpl;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
  * @author max
  */
 public class ValueVisitorTest extends BaseUnitTestCase {
+
+	private StandardServiceRegistry serviceRegistry;
+	private MetadataBuildingContext metadataBuildingContext;
+
+	@Before
+	public void prepare() {
+		serviceRegistry = new StandardServiceRegistryBuilder().build();
+		metadataBuildingContext = new MetadataBuildingContextTestingImpl( serviceRegistry );
+	}
+
+	@After
+	public void release() {
+		StandardServiceRegistryBuilder.destroy( serviceRegistry );
+	}
+
 	@Test
 	public void testProperCallbacks() {
 		final MetadataImplementor metadata = (MetadataImplementor) new MetadataSources().buildMetadata();
 		final Table tbl = new Table();
-		final RootClass rootClass = new RootClass();
+		final RootClass rootClass = new RootClass( metadataBuildingContext );
 
 		ValueVisitor vv = new ValueVisitorValidator();
 
 		new Any( metadata, tbl ).accept( vv );
 		new Array( metadata, rootClass ).accept( vv );
 		new Bag( metadata, rootClass ).accept( vv );
 		new Component( metadata, rootClass ).accept( vv );
 		new DependantValue( metadata, tbl, null ).accept( vv );
 		new IdentifierBag( metadata, rootClass ).accept( vv );
 		new List( metadata, rootClass ).accept( vv );
 		new ManyToOne( metadata, tbl ).accept( vv );
 		new Map( metadata, rootClass ).accept( vv );
 		new OneToMany( metadata, rootClass ).accept( vv );
 		new OneToOne( metadata, tbl, rootClass ).accept( vv );
 		new PrimitiveArray( metadata, rootClass ).accept( vv );
 		new Set( metadata, rootClass ).accept( vv );
 		new SimpleValue( metadata ).accept( vv );
 	}
 
 	static public class ValueVisitorValidator implements ValueVisitor {
 
 		public Object accept(PrimitiveArray primitiveArray) {
 			return validate( PrimitiveArray.class, primitiveArray );
 		}
 
 		public Object accept(Bag bag) {
 			return validate( Bag.class, bag );
 		}
 
 		public Object accept(DependantValue value) {
 			return validate( DependantValue.class, value );
 		}
 
 		private Object validate(Class expectedClass, Object visitee) {
 			if ( !visitee.getClass().getName().equals( expectedClass.getName() ) ) {
 				throw new IllegalStateException(
 						visitee.getClass().getName()
 								+ " did not call proper accept method. Was "
 								+ expectedClass.getName()
 				);
 			}
 			return null;
 		}
 
 		public Object accept(IdentifierBag bag) {
 			return validate( IdentifierBag.class, bag );
 		}
 
 		public Object accept(List list) {
 			return validate( List.class, list );
 		}
 
 		public Object accept(Map map) {
 			return validate( Map.class, map );
 		}
 
 		public Object accept(Array list) {
 			return validate( Array.class, list );
 		}
 
 		public Object accept(OneToMany many) {
 			return validate( OneToMany.class, many );
 		}
 
 		public Object accept(Set set) {
 			return validate( Set.class, set );
 		}
 
 		public Object accept(Any any) {
 			return validate( Any.class, any );
 		}
 
 		public Object accept(SimpleValue value) {
 			return validate( SimpleValue.class, value );
 		}
 
 		public Object accept(Component component) {
 			return validate( Component.class, component );
 		}
 
 		public Object accept(ManyToOne mto) {
 			return validate( ManyToOne.class, mto );
 		}
 
 		public Object accept(OneToOne oto) {
 			return validate( OneToOne.class, oto );
 		}
 
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
index 3bdfae8acd..ad08b17228 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
@@ -1,285 +1,285 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.multitenancy.schema;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.Session;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.SessionFactoryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
 import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.tool.schema.internal.TargetDatabaseImpl;
 import org.hibernate.tool.schema.spi.SchemaManagementTool;
 
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.cache.CachingRegionFactory;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.test.common.JdbcConnectionAccessImpl;
+import org.hibernate.testing.boot.JdbcConnectionAccessImpl;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 /**
  * @author Steve Ebersole
  */
 @RequiresDialectFeature( value = ConnectionProviderBuilder.class )
 public class SchemaBasedMultiTenancyTest extends BaseUnitTestCase {
 	private DriverManagerConnectionProviderImpl acmeProvider;
 	private DriverManagerConnectionProviderImpl jbossProvider;
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	protected SessionFactoryImplementor sessionFactory;
 
 	@Before
 	public void setUp() {
 		AbstractMultiTenantConnectionProvider multiTenantConnectionProvider = buildMultiTenantConnectionProvider();
 
 		Map settings = new HashMap();
 		settings.put( Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA );
 		settings.put( Environment.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );
 		settings.put( Environment.GENERATE_STATISTICS, "true" );
 
 		serviceRegistry = (ServiceRegistryImplementor) new StandardServiceRegistryBuilder()
 				.applySettings( settings )
 				.addService( MultiTenantConnectionProvider.class, multiTenantConnectionProvider )
 				.build();
 
 		MetadataSources ms = new MetadataSources( serviceRegistry );
 		ms.addAnnotatedClass( Customer.class );
 		ms.addAnnotatedClass( Invoice.class );
 
 		Metadata metadata = ms.buildMetadata();
 		( (RootClass) metadata.getEntityBinding( Customer.class.getName() ) ).setCacheConcurrencyStrategy( "read-write" );
 
 		final TargetDatabaseImpl acmeTarget = new TargetDatabaseImpl( new JdbcConnectionAccessImpl( acmeProvider ) );
 		final TargetDatabaseImpl jbossTarget = new TargetDatabaseImpl( new JdbcConnectionAccessImpl( jbossProvider ) );
 
 		serviceRegistry.getService( SchemaManagementTool.class ).getSchemaDropper( settings ).doDrop(
 				metadata,
 				true,
 				acmeTarget,
 				jbossTarget
 		);
 
 		serviceRegistry.getService( SchemaManagementTool.class ).getSchemaCreator( settings ).doCreation(
 				metadata,
 				true,
 				acmeTarget,
 				jbossTarget
 		);
 
 		final SessionFactoryBuilder sfb = metadata.getSessionFactoryBuilder();
 		configure( sfb );
 		sessionFactory = (SessionFactoryImplementor) sfb.build();
 	}
 
 	protected void configure(SessionFactoryBuilder sfb) {
 	}
 
 	private AbstractMultiTenantConnectionProvider buildMultiTenantConnectionProvider() {
 		acmeProvider = ConnectionProviderBuilder.buildConnectionProvider( "acme" );
 		jbossProvider = ConnectionProviderBuilder.buildConnectionProvider( "jboss" );
 		return new AbstractMultiTenantConnectionProvider() {
 			@Override
 			protected ConnectionProvider getAnyConnectionProvider() {
 				return acmeProvider;
 			}
 
 			@Override
 			protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {
 				if ( "acme".equals( tenantIdentifier ) ) {
 					return acmeProvider;
 				}
 				else if ( "jboss".equals( tenantIdentifier ) ) {
 					return jbossProvider;
 				}
 				throw new HibernateException( "Unknown tenant identifier" );
 			}
 		};
 	}
 
 	@After
 	public void tearDown() {
 		if ( sessionFactory != null ) {
 			sessionFactory.close();
 		}
 		if ( serviceRegistry != null ) {
 			serviceRegistry.destroy();
 		}
 		if ( jbossProvider != null ) {
 			jbossProvider.stop();
 		}
 		if ( acmeProvider != null ) {
 			acmeProvider.stop();
 		}
 	}
 
 	@Test
 	public void testBasicExpectedBehavior() {
 		Session session = getNewSession("jboss");
 		session.beginTransaction();
 		Customer steve = new Customer( 1L, "steve" );
 		session.save( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession("acme");
 		try {
 			session.beginTransaction();
 			Customer check = (Customer) session.get( Customer.class, steve.getId() );
 			Assert.assertNull( "tenancy not properly isolated", check );
 		}
 		finally {
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		session = getNewSession("jboss");
 		session.beginTransaction();
 		session.delete( steve );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testSameIdentifiers() {
 		// create a customer 'steve' in jboss
 		Session session = getNewSession("jboss");
 		session.beginTransaction();
 		Customer steve = new Customer( 1L, "steve" );
 		session.save( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		// now, create a customer 'john' in acme
 		session = getNewSession("acme");
 		session.beginTransaction();
 		Customer john = new Customer( 1L, "john" );
 		session.save( john );
 		session.getTransaction().commit();
 		session.close();
 
 		sessionFactory.getStatisticsImplementor().clear();
 
 		// make sure we get the correct people back, from cache
 		// first, jboss
 		{
 			session = getNewSession("jboss");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "steve", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 1, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 		sessionFactory.getStatisticsImplementor().clear();
 		// then, acme
 		{
 			session = getNewSession("acme");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "john", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 1, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		// make sure the same works from datastore too
 		sessionFactory.getStatisticsImplementor().clear();
 		sessionFactory.getCache().evictEntityRegions();
 		// first jboss
 		{
 			session = getNewSession("jboss");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "steve", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 0, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 		sessionFactory.getStatisticsImplementor().clear();
 		// then, acme
 		{
 			session = getNewSession("acme");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "john", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 0, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		session = getNewSession("jboss");
 		session.beginTransaction();
 		session.delete( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession("acme");
 		session.beginTransaction();
 		session.delete( john );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testTableIdentifiers() {
 		Session session = getNewSession( "jboss" );
 		session.beginTransaction();
 		Invoice orderJboss = new Invoice();
 		session.save( orderJboss );
 		Assert.assertEquals( Long.valueOf( 1 ), orderJboss.getId() );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession( "acme" );
 		session.beginTransaction();
 		Invoice orderAcme = new Invoice();
 		session.save( orderAcme );
 		Assert.assertEquals( Long.valueOf( 1 ), orderAcme.getId() );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession( "jboss" );
 		session.beginTransaction();
 		session.delete( orderJboss );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession( "acme" );
 		session.beginTransaction();
 		session.delete( orderAcme );
 		session.getTransaction().commit();
 		session.close();
 
 		sessionFactory.getStatisticsImplementor().clear();
 	}
 
 	protected Session getNewSession(String tenant) {
 		return sessionFactory.withOptions().tenantIdentifier( tenant ).openSession();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/quote/TableGeneratorQuotingTest.java b/hibernate-core/src/test/java/org/hibernate/test/quote/TableGeneratorQuotingTest.java
index 93aae5359a..eb64cd61f5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/quote/TableGeneratorQuotingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/quote/TableGeneratorQuotingTest.java
@@ -1,87 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.quote;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tool.schema.internal.TargetDatabaseImpl;
 import org.hibernate.tool.schema.spi.SchemaManagementTool;
 import org.hibernate.tool.schema.spi.Target;
 
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.test.common.JdbcConnectionAccessImpl;
+import org.hibernate.testing.boot.JdbcConnectionAccessImpl;
 import org.junit.After;
-import org.junit.AfterClass;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Test;
 
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 public class TableGeneratorQuotingTest extends BaseUnitTestCase {
 	private StandardServiceRegistry serviceRegistry;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySetting( AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS, "true" )
 				.build();
 	}
 
 	@After
 	public void tearDown() {
 		if ( serviceRegistry != null ) {
 			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-7927")
 	public void testTableGeneratorQuoting() {
 		final Metadata metadata = new MetadataSources( serviceRegistry ).addAnnotatedClass( TestEntity.class ).buildMetadata();
 
 		final ConnectionProvider connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
 		final Target target = new TargetDatabaseImpl( new JdbcConnectionAccessImpl( connectionProvider ) );
 		final SchemaManagementTool tool = serviceRegistry.getService( SchemaManagementTool.class );
 
 		tool.getSchemaDropper( null ).doDrop( metadata, false, target );
 		tool.getSchemaCreator( null ).doCreation( metadata, false, target );
 
 		try {
 			new SchemaValidator( serviceRegistry, (MetadataImplementor) metadata ).validate();
 		}
 		catch (HibernateException e) {
 			fail( "The identifier generator table should have validated.  " + e.getMessage() );
 		}
 		finally {
 			tool.getSchemaDropper( null ).doDrop( metadata, false, target );
 		}
 	}
 
 	@Entity
 	private static class TestEntity {
 		@Id
 		@GeneratedValue(strategy = GenerationType.TABLE)
 		private int id;
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/internal/metamodel/AttributeFactory.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/internal/metamodel/AttributeFactory.java
index d3d8188578..58b2ae8287 100755
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/internal/metamodel/AttributeFactory.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/internal/metamodel/AttributeFactory.java
@@ -1,1056 +1,1062 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.jpa.internal.metamodel;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.TypeVariable;
 import java.util.Iterator;
 import javax.persistence.ManyToMany;
 import javax.persistence.OneToOne;
 import javax.persistence.metamodel.Attribute;
 import javax.persistence.metamodel.PluralAttribute;
 import javax.persistence.metamodel.Type;
 
 import org.hibernate.annotations.common.AssertionFailure;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.internal.HEMLogging;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Map;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Value;
-import org.hibernate.property.Getter;
-import org.hibernate.property.MapAccessor;
+import org.hibernate.property.access.internal.PropertyAccessMapImpl;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.EmbeddedComponentType;
 import org.hibernate.type.EntityType;
 
 /**
  * A factory for building {@link Attribute} instances.  Exposes 3 main services for building<ol>
  * <li>{@link #buildAttribute normal attributes}</li>
  * <li>{@link #buildIdAttribute id attributes}</li>
  * <li>{@link #buildVersionAttribute version attributes}</li>
  * <ol>
  *
  * @author Steve Ebersole
  * @author Emmanuel Bernard
  */
 public class AttributeFactory {
 	private static final EntityManagerMessageLogger LOG = HEMLogging.messageLogger( AttributeFactory.class );
 
 	private final MetadataContext context;
 
 	public AttributeFactory(MetadataContext context) {
 		this.context = context;
 	}
 
 	/**
 	 * Build a normal attribute.
 	 *
 	 * @param ownerType The descriptor of the attribute owner (aka declarer).
 	 * @param property The Hibernate property descriptor for the attribute
 	 * @param <X> The type of the owner
 	 * @param <Y> The attribute type
 	 *
 	 * @return The built attribute descriptor or null if the attribute is not part of the JPA 2 model (eg backrefs)
 	 */
 	@SuppressWarnings({"unchecked"})
 	public <X, Y> AttributeImplementor<X, Y> buildAttribute(AbstractManagedType<X> ownerType, Property property) {
 		if ( property.isSynthetic() ) {
 			// hide synthetic/virtual properties (fabricated by Hibernate) from the JPA metamodel.
 			LOG.tracef( "Skipping synthetic property %s(%s)", ownerType.getTypeName(), property.getName() );
 			return null;
 		}
 		LOG.trace( "Building attribute [" + ownerType.getTypeName() + "." + property.getName() + "]" );
 		final AttributeContext<X> attributeContext = wrap( ownerType, property );
 		final AttributeMetadata<X, Y> attributeMetadata =
 				determineAttributeMetadata( attributeContext, normalMemberResolver );
 		if ( attributeMetadata == null ) {
 			return null;
 		}
 		if ( attributeMetadata.isPlural() ) {
 			return buildPluralAttribute( (PluralAttributeMetadata) attributeMetadata );
 		}
 		final SingularAttributeMetadata<X, Y> singularAttributeMetadata = (SingularAttributeMetadata<X, Y>) attributeMetadata;
 		final Type<Y> metaModelType = getMetaModelType( singularAttributeMetadata.getValueContext() );
 		return new SingularAttributeImpl<X, Y>(
 				attributeMetadata.getName(),
 				attributeMetadata.getJavaType(),
 				ownerType,
 				attributeMetadata.getMember(),
 				false,
 				false,
 				property.isOptional(),
 				metaModelType,
 				attributeMetadata.getPersistentAttributeType()
 		);
 	}
 
 	private <X> AttributeContext<X> wrap(final AbstractManagedType<X> ownerType, final Property property) {
 		return new AttributeContext<X>() {
 			public AbstractManagedType<X> getOwnerType() {
 				return ownerType;
 			}
 
 			public Property getPropertyMapping() {
 				return property;
 			}
 		};
 	}
 
 	/**
 	 * Build the identifier attribute descriptor
 	 *
 	 * @param ownerType The descriptor of the attribute owner (aka declarer).
 	 * @param property The Hibernate property descriptor for the identifier attribute
 	 * @param <X> The type of the owner
 	 * @param <Y> The attribute type
 	 *
 	 * @return The built attribute descriptor
 	 */
 	@SuppressWarnings({"unchecked"})
 	public <X, Y> SingularAttributeImpl<X, Y> buildIdAttribute(
 			AbstractIdentifiableType<X> ownerType,
 			Property property) {
 		LOG.trace( "Building identifier attribute [" + ownerType.getTypeName() + "." + property.getName() + "]" );
 		final AttributeContext<X> attributeContext = wrap( ownerType, property );
 		final SingularAttributeMetadata<X, Y> attributeMetadata =
 				(SingularAttributeMetadata<X, Y>) determineAttributeMetadata(
 						attributeContext,
 						identifierMemberResolver
 				);
 		final Type<Y> metaModelType = getMetaModelType( attributeMetadata.getValueContext() );
 		return new SingularAttributeImpl.Identifier(
 				property.getName(),
 				attributeMetadata.getJavaType(),
 				ownerType,
 				attributeMetadata.getMember(),
 				metaModelType,
 				attributeMetadata.getPersistentAttributeType()
 		);
 	}
 
 	/**
 	 * Build the version attribute descriptor
 	 *
 	 * @param ownerType The descriptor of the attribute owner (aka declarer).
 	 * @param property The Hibernate property descriptor for the version attribute
 	 * @param <X> The type of the owner
 	 * @param <Y> The attribute type
 	 *
 	 * @return The built attribute descriptor
 	 */
 	@SuppressWarnings({"unchecked"})
 	public <X, Y> SingularAttributeImpl<X, Y> buildVersionAttribute(
 			AbstractIdentifiableType<X> ownerType,
 			Property property) {
 		LOG.trace( "Building version attribute [ownerType.getTypeName()" + "." + "property.getName()]" );
 		final AttributeContext<X> attributeContext = wrap( ownerType, property );
 		final SingularAttributeMetadata<X, Y> attributeMetadata =
 				(SingularAttributeMetadata<X, Y>) determineAttributeMetadata( attributeContext, versionMemberResolver );
 		final Type<Y> metaModelType = getMetaModelType( attributeMetadata.getValueContext() );
 		return new SingularAttributeImpl.Version(
 				property.getName(),
 				attributeMetadata.getJavaType(),
 				ownerType,
 				attributeMetadata.getMember(),
 				metaModelType,
 				attributeMetadata.getPersistentAttributeType()
 		);
 	}
 
 	@SuppressWarnings("unchecked")
 	private <X, Y, E, K> AttributeImplementor<X, Y> buildPluralAttribute(PluralAttributeMetadata<X, Y, E> attributeMetadata) {
 		final Type<E> elementType = getMetaModelType( attributeMetadata.getElementValueContext() );
 		if ( java.util.Map.class.isAssignableFrom( attributeMetadata.getJavaType() ) ) {
 			final Type<K> keyType = getMetaModelType( attributeMetadata.getMapKeyValueContext() );
 			return PluralAttributeImpl.create(
 					attributeMetadata.getOwnerType(),
 					elementType,
 					attributeMetadata.getJavaType(),
 					keyType
 			)
 					.member( attributeMetadata.getMember() )
 					.property( attributeMetadata.getPropertyMapping() )
 					.persistentAttributeType( attributeMetadata.getPersistentAttributeType() )
 					.build();
 		}
 		return PluralAttributeImpl.create(
 				attributeMetadata.getOwnerType(),
 				elementType,
 				attributeMetadata.getJavaType(),
 				null
 		)
 				.member( attributeMetadata.getMember() )
 				.property( attributeMetadata.getPropertyMapping() )
 				.persistentAttributeType( attributeMetadata.getPersistentAttributeType() )
 				.build();
 	}
 
 	@SuppressWarnings("unchecked")
 	private <Y> Type<Y> getMetaModelType(ValueContext typeContext) {
 		switch ( typeContext.getValueClassification() ) {
 			case BASIC: {
 				return new BasicTypeImpl<Y>(
 						typeContext.getBindableType(),
 						Type.PersistenceType.BASIC
 				);
 			}
 			case ENTITY: {
 				final org.hibernate.type.EntityType type = (EntityType) typeContext.getValue().getType();
 				return (Type<Y>) context.locateEntityType( type.getAssociatedEntityName() );
 			}
 			case EMBEDDABLE: {
 				final Component component = (Component) typeContext.getValue();
 				final EmbeddableTypeImpl<Y> embeddableType = new EmbeddableTypeImpl<Y>(
 						typeContext.getBindableType(),
 						typeContext.getAttributeMetadata().getOwnerType(),
 						(ComponentType) typeContext.getValue().getType()
 				);
 				context.registerEmbeddedableType( embeddableType );
 				final Iterator<Property> subProperties = component.getPropertyIterator();
 				while ( subProperties.hasNext() ) {
 					final Property property = subProperties.next();
 					final AttributeImplementor<Y, Object> attribute = buildAttribute( embeddableType, property );
 					if ( attribute != null ) {
 						embeddableType.getBuilder().addAttribute( attribute );
 					}
 				}
 				embeddableType.lock();
 				return embeddableType;
 			}
 			default: {
 				throw new AssertionFailure( "Unknown type : " + typeContext.getValueClassification() );
 			}
 		}
 	}
 
 	private EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) {
 		final Type.PersistenceType persistenceType = ownerType.getPersistenceType();
 		if ( persistenceType == Type.PersistenceType.ENTITY ) {
 			return context.getSessionFactory()
 					.getEntityPersister( ownerType.getTypeName() )
 					.getEntityMetamodel();
 		}
 		else if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) {
 			PersistentClass persistentClass =
 					context.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType );
 			return context.getSessionFactory()
 					.getEntityPersister( persistentClass.getClassName() )
 					.getEntityMetamodel();
 		}
 		else {
 			throw new AssertionFailure( "Cannot get the metamodel for PersistenceType: " + persistenceType );
 		}
 	}
 
 	/**
 	 * A contract for defining the meta information about a {@link Value}
 	 */
 	private interface ValueContext {
 		/**
 		 * Enum of the simplified types a value might be.  These relate more to the Hibernate classification
 		 * then the JPA classification
 		 */
 		enum ValueClassification {
 			EMBEDDABLE,
 			ENTITY,
 			BASIC
 		}
 
 		/**
 		 * Retrieve the value itself
 		 *
 		 * @return The value
 		 */
 		public Value getValue();
 
 		public Class getBindableType();
 
 		/**
 		 * Retrieve the simplified value classification
 		 *
 		 * @return The value type
 		 */
 		public ValueClassification getValueClassification();
 
 		/**
 		 * Retrieve the metadata about the attribute from which this value comes
 		 *
 		 * @return The "containing" attribute metadata.
 		 */
 		public AttributeMetadata getAttributeMetadata();
 	}
 
 	/**
 	 * Basic contract for describing an attribute.  The "description" is partially in terms
 	 * of JPA ({@link #getPersistentAttributeType} and {@link #getOwnerType}), partially in
 	 * terms of Hibernate ({@link #getPropertyMapping}) and partially just in terms of the java
 	 * model itself ({@link #getName}, {@link #getMember} and {@link #getJavaType}).
 	 *
 	 * @param <X> The attribute owner type
 	 * @param <Y> The attribute type.
 	 */
 	private interface AttributeMetadata<X, Y> {
 		/**
 		 * Retrieve the name of the attribute
 		 *
 		 * @return The attribute name
 		 */
 		public String getName();
 
 		/**
 		 * Retrieve the member defining the attribute
 		 *
 		 * @return The attribute member
 		 */
 		public Member getMember();
 
 		/**
 		 * Retrieve the attribute java type.
 		 *
 		 * @return The java type of the attribute.
 		 */
 		public Class<Y> getJavaType();
 
 		/**
 		 * Get the JPA attribute type classification for this attribute.
 		 *
 		 * @return The JPA attribute type classification
 		 */
 		public Attribute.PersistentAttributeType getPersistentAttributeType();
 
 		/**
 		 * Retrieve the attribute owner's metamodel information
 		 *
 		 * @return The metamodel information for the attribute owner
 		 */
 		public AbstractManagedType<X> getOwnerType();
 
 		/**
 		 * Retrieve the Hibernate property mapping related to this attribute.
 		 *
 		 * @return The Hibernate property mapping
 		 */
 		public Property getPropertyMapping();
 
 		/**
 		 * Is the attribute plural (a collection)?
 		 *
 		 * @return True if it is plural, false otherwise.
 		 */
 		public boolean isPlural();
 	}
 
 	/**
 	 * Attribute metadata contract for a non-plural attribute.
 	 *
 	 * @param <X> The owner type
 	 * @param <Y> The attribute type
 	 */
 	private interface SingularAttributeMetadata<X, Y> extends AttributeMetadata<X, Y> {
 		/**
 		 * Retrieve the value context for this attribute
 		 *
 		 * @return The attributes value context
 		 */
 		public ValueContext getValueContext();
 	}
 
 	/**
 	 * Attribute metadata contract for a plural attribute.
 	 *
 	 * @param <X> The owner type
 	 * @param <Y> The attribute type (the collection type)
 	 * @param <E> The collection element type
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	private interface PluralAttributeMetadata<X, Y, E> extends AttributeMetadata<X, Y> {
 		/**
 		 * Retrieve the JPA collection type classification for this attribute
 		 *
 		 * @return The JPA collection type classification
 		 */
 		public PluralAttribute.CollectionType getAttributeCollectionType();
 
 		/**
 		 * Retrieve the value context for the collection's elements.
 		 *
 		 * @return The value context for the collection's elements.
 		 */
 		public ValueContext getElementValueContext();
 
 		/**
 		 * Retrieve the value context for the collection's keys (if a map, null otherwise).
 		 *
 		 * @return The value context for the collection's keys (if a map, null otherwise).
 		 */
 		public ValueContext getMapKeyValueContext();
 	}
 
 	/**
 	 * Bundle's a Hibernate property mapping together with the JPA metamodel information
 	 * of the attribute owner.
 	 *
 	 * @param <X> The owner type.
 	 */
 	private interface AttributeContext<X> {
 		/**
 		 * Retrieve the attribute owner.
 		 *
 		 * @return The owner.
 		 */
 		public AbstractManagedType<X> getOwnerType();
 
 		/**
 		 * Retrieve the Hibernate property mapping.
 		 *
 		 * @return The Hibernate property mapping.
 		 */
 		public Property getPropertyMapping();
 	}
 
 	/**
 	 * Contract for how we resolve the {@link Member} for a give attribute context.
 	 */
 	private interface MemberResolver {
 		public Member resolveMember(AttributeContext attributeContext);
 	}
 
 	/**
 	 * Here is most of the nuts and bolts of this factory, where we interpret the known JPA metadata
 	 * against the known Hibernate metadata and build a descriptor for the attribute.
 	 *
 	 * @param attributeContext The attribute to be described
 	 * @param memberResolver Strategy for how to resolve the member defining the attribute.
 	 * @param <X> The owner type
 	 * @param <Y> The attribute type
 	 *
 	 * @return The attribute description
 	 */
 	@SuppressWarnings({"unchecked"})
 	private <X, Y> AttributeMetadata<X, Y> determineAttributeMetadata(
 			AttributeContext<X> attributeContext,
 			MemberResolver memberResolver) {
 		LOG.trace(
 				"Starting attribute metadata determination [" + attributeContext.getPropertyMapping()
 						.getName() + "]"
 		);
 		final Member member = memberResolver.resolveMember( attributeContext );
 		LOG.trace( "    Determined member [" + member + "]" );
 
 		final Value value = attributeContext.getPropertyMapping().getValue();
 		final org.hibernate.type.Type type = value.getType();
 		LOG.trace( "    Determined type [name=" + type.getName() + ", class=" + type.getClass().getName() + "]" );
 
 		if ( type.isAnyType() ) {
 			// ANY mappings are currently not supported in the JPA metamodel; see HHH-6589
 			if ( context.isIgnoreUnsupported() ) {
 				return null;
 			}
 			else {
 				throw new UnsupportedOperationException( "ANY not supported" );
 			}
 		}
 		else if ( type.isAssociationType() ) {
 			// collection or entity
 			if ( type.isEntityType() ) {
 				// entity
 				return new SingularAttributeMetadataImpl<X, Y>(
 						attributeContext.getPropertyMapping(),
 						attributeContext.getOwnerType(),
 						member,
 						determineSingularAssociationAttributeType( member )
 				);
 			}
 			// collection
 			if ( value instanceof Collection ) {
 				final Collection collValue = (Collection) value;
 				final Value elementValue = collValue.getElement();
 				final org.hibernate.type.Type elementType = elementValue.getType();
 
 				// First, determine the type of the elements and use that to help determine the
 				// collection type)
 				final Attribute.PersistentAttributeType elementPersistentAttributeType;
 				final Attribute.PersistentAttributeType persistentAttributeType;
 				if ( elementType.isAnyType() ) {
 					if ( context.isIgnoreUnsupported() ) {
 						return null;
 					}
 					else {
 						throw new UnsupportedOperationException( "collection of any not supported yet" );
 					}
 				}
 				final boolean isManyToMany = isManyToMany( member );
 				if ( elementValue instanceof Component ) {
 					elementPersistentAttributeType = Attribute.PersistentAttributeType.EMBEDDED;
 					persistentAttributeType = Attribute.PersistentAttributeType.ELEMENT_COLLECTION;
 				}
 				else if ( elementType.isAssociationType() ) {
 					elementPersistentAttributeType = isManyToMany ?
 							Attribute.PersistentAttributeType.MANY_TO_MANY :
 							Attribute.PersistentAttributeType.ONE_TO_MANY;
 					persistentAttributeType = elementPersistentAttributeType;
 				}
 				else {
 					elementPersistentAttributeType = Attribute.PersistentAttributeType.BASIC;
 					persistentAttributeType = Attribute.PersistentAttributeType.ELEMENT_COLLECTION;
 				}
 
 				final Attribute.PersistentAttributeType keyPersistentAttributeType;
 
 				// Finally, we determine the type of the map key (if needed)
 				if ( value instanceof Map ) {
 					final Value keyValue = ( (Map) value ).getIndex();
 					final org.hibernate.type.Type keyType = keyValue.getType();
 
 					if ( keyType.isAnyType() ) {
 						if ( context.isIgnoreUnsupported() ) {
 							return null;
 						}
 						else {
 							throw new UnsupportedOperationException( "collection of any not supported yet" );
 						}
 					}
 					if ( keyValue instanceof Component ) {
 						keyPersistentAttributeType = Attribute.PersistentAttributeType.EMBEDDED;
 					}
 					else if ( keyType.isAssociationType() ) {
 						keyPersistentAttributeType = Attribute.PersistentAttributeType.MANY_TO_ONE;
 					}
 					else {
 						keyPersistentAttributeType = Attribute.PersistentAttributeType.BASIC;
 					}
 				}
 				else {
 					keyPersistentAttributeType = null;
 				}
 				return new PluralAttributeMetadataImpl(
 						attributeContext.getPropertyMapping(), attributeContext.getOwnerType(),
 						member, persistentAttributeType, elementPersistentAttributeType,
 						keyPersistentAttributeType
 				);
 			}
 			else if ( value instanceof OneToMany ) {
 				// TODO : is this even possible??? Really OneToMany should be describing the
 				// element value within a o.h.mapping.Collection (see logic branch above)
 				throw new IllegalArgumentException( "HUH???" );
 //					final boolean isManyToMany = isManyToMany( member );
 //					//one to many with FK => entity
 //					return new PluralAttributeMetadataImpl(
 //							attributeContext.getPropertyMapping(),
 //							attributeContext.getOwnerType(),
 //							member,
 //							isManyToMany
 //									? Attribute.PersistentAttributeType.MANY_TO_MANY
 //									: Attribute.PersistentAttributeType.ONE_TO_MANY
 //							value,
 //							AttributeContext.TypeStatus.ENTITY,
 //							Attribute.PersistentAttributeType.ONE_TO_MANY,
 //							null, null, null
 //					);
 			}
 		}
 		else if ( attributeContext.getPropertyMapping().isComposite() ) {
 			// component
 			return new SingularAttributeMetadataImpl<X, Y>(
 					attributeContext.getPropertyMapping(),
 					attributeContext.getOwnerType(),
 					member,
 					Attribute.PersistentAttributeType.EMBEDDED
 			);
 		}
 		else {
 			// basic type
 			return new SingularAttributeMetadataImpl<X, Y>(
 					attributeContext.getPropertyMapping(),
 					attributeContext.getOwnerType(),
 					member,
 					Attribute.PersistentAttributeType.BASIC
 			);
 		}
 		throw new UnsupportedOperationException( "oops, we are missing something: " + attributeContext.getPropertyMapping() );
 	}
 
 	public static Attribute.PersistentAttributeType determineSingularAssociationAttributeType(Member member) {
 		if ( Field.class.isInstance( member ) ) {
 			return ( (Field) member ).getAnnotation( OneToOne.class ) != null
 					? Attribute.PersistentAttributeType.ONE_TO_ONE
 					: Attribute.PersistentAttributeType.MANY_TO_ONE;
 		}
 		else if ( MapMember.class.isInstance( member ) ) {
 			return Attribute.PersistentAttributeType.MANY_TO_ONE; // curious to see how this works for non-annotated methods
 		}
 		else {
 			return ( (Method) member ).getAnnotation( OneToOne.class ) != null
 					? Attribute.PersistentAttributeType.ONE_TO_ONE
 					: Attribute.PersistentAttributeType.MANY_TO_ONE;
 		}
 	}
 
 	private abstract class BaseAttributeMetadata<X, Y> implements AttributeMetadata<X, Y> {
 		private final Property propertyMapping;
 		private final AbstractManagedType<X> ownerType;
 		private final Member member;
 		private final Class<Y> javaType;
 		private final Attribute.PersistentAttributeType persistentAttributeType;
 
 		@SuppressWarnings({"unchecked"})
 		protected BaseAttributeMetadata(
 				Property propertyMapping,
 				AbstractManagedType<X> ownerType,
 				Member member,
 				Attribute.PersistentAttributeType persistentAttributeType) {
 			this.propertyMapping = propertyMapping;
 			this.ownerType = ownerType;
 			this.member = member;
 			this.persistentAttributeType = persistentAttributeType;
 
 			final Class declaredType;
 
 			if ( member == null ) {
 				// assume we have a MAP entity-mode "class"
 				declaredType = propertyMapping.getType().getReturnedClass();
 			}
 			else if ( Field.class.isInstance( member ) ) {
 				declaredType = ( (Field) member ).getType();
 			}
 			else if ( Method.class.isInstance( member ) ) {
 				declaredType = ( (Method) member ).getReturnType();
 			}
 			else if ( MapMember.class.isInstance( member ) ) {
 				declaredType = ( (MapMember) member ).getType();
 			}
 			else {
 				throw new IllegalArgumentException( "Cannot determine java-type from given member [" + member + "]" );
 			}
 			this.javaType = accountForPrimitiveTypes( declaredType );
 		}
 
 		public String getName() {
 			return propertyMapping.getName();
 		}
 
 		public Member getMember() {
 			return member;
 		}
 
 		public String getMemberDescription() {
 			return determineMemberDescription( getMember() );
 		}
 
 		public String determineMemberDescription(Member member) {
 			return member.getDeclaringClass().getName() + '#' + member.getName();
 		}
 
 		public Class<Y> getJavaType() {
 			return javaType;
 		}
 
 		public Attribute.PersistentAttributeType getPersistentAttributeType() {
 			return persistentAttributeType;
 		}
 
 		public AbstractManagedType<X> getOwnerType() {
 			return ownerType;
 		}
 
 		public boolean isPlural() {
 			return propertyMapping.getType().isCollectionType();
 		}
 
 		public Property getPropertyMapping() {
 			return propertyMapping;
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	protected <Y> Class<Y> accountForPrimitiveTypes(Class<Y> declaredType) {
 //		if ( !declaredType.isPrimitive() ) {
 //			return declaredType;
 //		}
 //
 //		if ( Boolean.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Boolean.class;
 //		}
 //		if ( Character.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Character.class;
 //		}
 //		if( Byte.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Byte.class;
 //		}
 //		if ( Short.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Short.class;
 //		}
 //		if ( Integer.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Integer.class;
 //		}
 //		if ( Long.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Long.class;
 //		}
 //		if ( Float.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Float.class;
 //		}
 //		if ( Double.TYPE.equals( declaredType ) ) {
 //			return (Class<Y>) Double.class;
 //		}
 //
 //		throw new IllegalArgumentException( "Unexpected type [" + declaredType + "]" );
 		// if the field is defined as int, return int not Integer...
 		return declaredType;
 	}
 
 	private class SingularAttributeMetadataImpl<X, Y>
 			extends BaseAttributeMetadata<X, Y>
 			implements SingularAttributeMetadata<X, Y> {
 		private final ValueContext valueContext;
 
 		private SingularAttributeMetadataImpl(
 				Property propertyMapping,
 				AbstractManagedType<X> ownerType,
 				Member member,
 				Attribute.PersistentAttributeType persistentAttributeType) {
 			super( propertyMapping, ownerType, member, persistentAttributeType );
 			valueContext = new ValueContext() {
 				public Value getValue() {
 					return getPropertyMapping().getValue();
 				}
 
 				public Class getBindableType() {
 					return getAttributeMetadata().getJavaType();
 				}
 
 				public ValueClassification getValueClassification() {
 					switch ( getPersistentAttributeType() ) {
 						case EMBEDDED: {
 							return ValueClassification.EMBEDDABLE;
 						}
 						case BASIC: {
 							return ValueClassification.BASIC;
 						}
 						default: {
 							return ValueClassification.ENTITY;
 						}
 					}
 				}
 
 				public AttributeMetadata getAttributeMetadata() {
 					return SingularAttributeMetadataImpl.this;
 				}
 			};
 		}
 
 		public ValueContext getValueContext() {
 			return valueContext;
 		}
 	}
 
 	private class PluralAttributeMetadataImpl<X, Y, E>
 			extends BaseAttributeMetadata<X, Y>
 			implements PluralAttributeMetadata<X, Y, E> {
 		private final PluralAttribute.CollectionType attributeCollectionType;
 		private final Attribute.PersistentAttributeType elementPersistentAttributeType;
 		private final Attribute.PersistentAttributeType keyPersistentAttributeType;
 		private final Class elementJavaType;
 		private final Class keyJavaType;
 		private final ValueContext elementValueContext;
 		private final ValueContext keyValueContext;
 
 		private PluralAttributeMetadataImpl(
 				Property propertyMapping,
 				AbstractManagedType<X> ownerType,
 				Member member,
 				Attribute.PersistentAttributeType persistentAttributeType,
 				Attribute.PersistentAttributeType elementPersistentAttributeType,
 				Attribute.PersistentAttributeType keyPersistentAttributeType) {
 			super( propertyMapping, ownerType, member, persistentAttributeType );
 			this.attributeCollectionType = determineCollectionType( getJavaType() );
 			this.elementPersistentAttributeType = elementPersistentAttributeType;
 			this.keyPersistentAttributeType = keyPersistentAttributeType;
 
 			ParameterizedType signatureType = getSignatureType( member );
 			if ( keyPersistentAttributeType == null ) {
 				elementJavaType = signatureType != null ?
 						getClassFromGenericArgument( signatureType.getActualTypeArguments()[0] ) :
 						Object.class; //FIXME and honor targetEntity?
 				keyJavaType = null;
 			}
 			else {
 				keyJavaType = signatureType != null ?
 						getClassFromGenericArgument( signatureType.getActualTypeArguments()[0] ) :
 						Object.class; //FIXME and honor targetEntity?
 				elementJavaType = signatureType != null ?
 						getClassFromGenericArgument( signatureType.getActualTypeArguments()[1] ) :
 						Object.class; //FIXME and honor targetEntity?
 			}
 
 			this.elementValueContext = new ValueContext() {
 				public Value getValue() {
 					return ( (Collection) getPropertyMapping().getValue() ).getElement();
 				}
 
 				public Class getBindableType() {
 					return elementJavaType;
 				}
 
 				public ValueClassification getValueClassification() {
 					switch ( PluralAttributeMetadataImpl.this.elementPersistentAttributeType ) {
 						case EMBEDDED: {
 							return ValueClassification.EMBEDDABLE;
 						}
 						case BASIC: {
 							return ValueClassification.BASIC;
 						}
 						default: {
 							return ValueClassification.ENTITY;
 						}
 					}
 				}
 
 				public AttributeMetadata getAttributeMetadata() {
 					return PluralAttributeMetadataImpl.this;
 				}
 			};
 
 			// interpret the key, if one
 			if ( keyPersistentAttributeType != null ) {
 				this.keyValueContext = new ValueContext() {
 					public Value getValue() {
 						return ( (Map) getPropertyMapping().getValue() ).getIndex();
 					}
 
 					public Class getBindableType() {
 						return keyJavaType;
 					}
 
 					public ValueClassification getValueClassification() {
 						switch ( PluralAttributeMetadataImpl.this.keyPersistentAttributeType ) {
 							case EMBEDDED: {
 								return ValueClassification.EMBEDDABLE;
 							}
 							case BASIC: {
 								return ValueClassification.BASIC;
 							}
 							default: {
 								return ValueClassification.ENTITY;
 							}
 						}
 					}
 
 					public AttributeMetadata getAttributeMetadata() {
 						return PluralAttributeMetadataImpl.this;
 					}
 				};
 			}
 			else {
 				keyValueContext = null;
 			}
 		}
 
 		private Class<?> getClassFromGenericArgument(java.lang.reflect.Type type) {
 			if ( type instanceof Class ) {
 				return (Class) type;
 			}
 			else if ( type instanceof TypeVariable ) {
 				final java.lang.reflect.Type upperBound = ( (TypeVariable) type ).getBounds()[0];
 				return getClassFromGenericArgument( upperBound );
 			}
 			else if ( type instanceof ParameterizedType ) {
 				final java.lang.reflect.Type rawType = ( (ParameterizedType) type ).getRawType();
 				return getClassFromGenericArgument( rawType );
 			}
 			else {
 				throw new AssertionFailure(
 						"Fail to process type argument in a generic declaration. Member : " + getMemberDescription()
 								+ " Type: " + type.getClass()
 				);
 			}
 		}
 
 		public ValueContext getElementValueContext() {
 			return elementValueContext;
 		}
 
 		public PluralAttribute.CollectionType getAttributeCollectionType() {
 			return attributeCollectionType;
 		}
 
 		public ValueContext getMapKeyValueContext() {
 			return keyValueContext;
 		}
 	}
 
 	public static ParameterizedType getSignatureType(Member member) {
 		final java.lang.reflect.Type type;
 		if ( Field.class.isInstance( member ) ) {
 			type = ( (Field) member ).getGenericType();
 		}
 		else if ( Method.class.isInstance( member ) ) {
 			type = ( (Method) member ).getGenericReturnType();
 		}
 		else {
 			type = ( (MapMember) member ).getType();
 		}
 		//this is a raw type
 		if ( type instanceof Class ) {
 			return null;
 		}
 		return (ParameterizedType) type;
 	}
 
 	public static PluralAttribute.CollectionType determineCollectionType(Class javaType) {
 		if ( java.util.List.class.isAssignableFrom( javaType ) ) {
 			return PluralAttribute.CollectionType.LIST;
 		}
 		else if ( java.util.Set.class.isAssignableFrom( javaType ) ) {
 			return PluralAttribute.CollectionType.SET;
 		}
 		else if ( java.util.Map.class.isAssignableFrom( javaType ) ) {
 			return PluralAttribute.CollectionType.MAP;
 		}
 		else if ( java.util.Collection.class.isAssignableFrom( javaType ) ) {
 			return PluralAttribute.CollectionType.COLLECTION;
 		}
 		else {
 			throw new IllegalArgumentException( "Expecting collection type [" + javaType.getName() + "]" );
 		}
 	}
 
 	public static boolean isManyToMany(Member member) {
 		if ( Field.class.isInstance( member ) ) {
 			return ( (Field) member ).getAnnotation( ManyToMany.class ) != null;
 		}
 		else if ( Method.class.isInstance( member ) ) {
 			return ( (Method) member ).getAnnotation( ManyToMany.class ) != null;
 		}
 
 		return false;
 	}
 
 	private final MemberResolver embeddedMemberResolver = new MemberResolver() {
 		@Override
 		public Member resolveMember(AttributeContext attributeContext) {
 			final EmbeddableTypeImpl embeddableType = (EmbeddableTypeImpl<?>) attributeContext.getOwnerType();
 			final String attributeName = attributeContext.getPropertyMapping().getName();
 
 			final Getter getter = embeddableType.getHibernateType()
 					.getComponentTuplizer()
 					.getGetter( embeddableType.getHibernateType().getPropertyIndex( attributeName ) );
-			return MapAccessor.MapGetter.class.isInstance( getter )
+			return PropertyAccessMapImpl.GetterImpl.class.isInstance( getter )
 					? new MapMember( attributeName, attributeContext.getPropertyMapping().getType().getReturnedClass() )
 					: getter.getMember();
 		}
 	};
 
 
 	private final MemberResolver virtualIdentifierMemberResolver = new MemberResolver() {
 		@Override
 		public Member resolveMember(AttributeContext attributeContext) {
 			final AbstractIdentifiableType identifiableType = (AbstractIdentifiableType) attributeContext.getOwnerType();
 			final EntityMetamodel entityMetamodel = getDeclarerEntityMetamodel( identifiableType );
 			if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
 				throw new IllegalArgumentException( "expecting IdClass mapping" );
 			}
 			org.hibernate.type.Type type = entityMetamodel.getIdentifierProperty().getType();
 			if ( !EmbeddedComponentType.class.isInstance( type ) ) {
 				throw new IllegalArgumentException( "expecting IdClass mapping" );
 			}
 
 			final EmbeddedComponentType componentType = (EmbeddedComponentType) type;
 			final String attributeName = attributeContext.getPropertyMapping().getName();
 
 			final Getter getter = componentType.getComponentTuplizer()
 					.getGetter( componentType.getPropertyIndex( attributeName ) );
 
-			return MapAccessor.MapGetter.class.isInstance( getter )
+			return PropertyAccessMapImpl.GetterImpl.class.isInstance( getter )
 					? new MapMember( attributeName, attributeContext.getPropertyMapping().getType().getReturnedClass() )
 					: getter.getMember();
 		}
 	};
 
 	/**
 	 * A {@link Member} resolver for normal attributes.
 	 */
 	private final MemberResolver normalMemberResolver = new MemberResolver() {
 		@Override
 		public Member resolveMember(AttributeContext attributeContext) {
 			final AbstractManagedType ownerType = attributeContext.getOwnerType();
 			final Property property = attributeContext.getPropertyMapping();
 			final Type.PersistenceType persistenceType = ownerType.getPersistenceType();
 			if ( Type.PersistenceType.EMBEDDABLE == persistenceType ) {
 				return embeddedMemberResolver.resolveMember( attributeContext );
 			}
 			else if ( Type.PersistenceType.ENTITY == persistenceType
 					|| Type.PersistenceType.MAPPED_SUPERCLASS == persistenceType ) {
 				final AbstractIdentifiableType identifiableType = (AbstractIdentifiableType) ownerType;
 				final EntityMetamodel entityMetamodel = getDeclarerEntityMetamodel( identifiableType );
 				final String propertyName = property.getName();
 				final Integer index = entityMetamodel.getPropertyIndexOrNull( propertyName );
 				if ( index == null ) {
 					// just like in #determineIdentifierJavaMember , this *should* indicate we have an IdClass mapping
 					return virtualIdentifierMemberResolver.resolveMember( attributeContext );
 				}
 				else {
 					final Getter getter = entityMetamodel.getTuplizer().getGetter( index );
-					return MapAccessor.MapGetter.class.isInstance( getter )
+					return PropertyAccessMapImpl.GetterImpl.class.isInstance( getter )
 							? new MapMember( propertyName, property.getType().getReturnedClass() )
 							: getter.getMember();
 				}
 			}
 			else {
 				throw new IllegalArgumentException( "Unexpected owner type : " + persistenceType );
 			}
 		}
 	};
 
 	private final MemberResolver identifierMemberResolver = new MemberResolver() {
 		@Override
 		public Member resolveMember(AttributeContext attributeContext) {
 			final AbstractIdentifiableType identifiableType = (AbstractIdentifiableType) attributeContext.getOwnerType();
 			final EntityMetamodel entityMetamodel = getDeclarerEntityMetamodel( identifiableType );
 			if ( !attributeContext.getPropertyMapping().getName()
 					.equals( entityMetamodel.getIdentifierProperty().getName() ) ) {
 				// this *should* indicate processing part of an IdClass...
 				return virtualIdentifierMemberResolver.resolveMember( attributeContext );
 			}
 			final Getter getter = entityMetamodel.getTuplizer().getIdentifierGetter();
-			return MapAccessor.MapGetter.class.isInstance( getter )
-					? new MapMember(
-					entityMetamodel.getIdentifierProperty().getName(),
-					entityMetamodel.getIdentifierProperty().getType().getReturnedClass()
-			)
-					: getter.getMember();
+			if ( PropertyAccessMapImpl.GetterImpl.class.isInstance( getter ) ) {
+				return new MapMember(
+						entityMetamodel.getIdentifierProperty().getName(),
+						entityMetamodel.getIdentifierProperty().getType().getReturnedClass()
+				);
+			}
+			else {
+				return getter.getMember();
+			}
 		}
 	};
 
 	private final MemberResolver versionMemberResolver = new MemberResolver() {
 		@Override
 		public Member resolveMember(AttributeContext attributeContext) {
 			final AbstractIdentifiableType identifiableType = (AbstractIdentifiableType) attributeContext.getOwnerType();
 			final EntityMetamodel entityMetamodel = getDeclarerEntityMetamodel( identifiableType );
 			final String versionPropertyName = attributeContext.getPropertyMapping().getName();
 			if ( !versionPropertyName.equals( entityMetamodel.getVersionProperty().getName() ) ) {
 				// this should never happen, but to be safe...
 				throw new IllegalArgumentException( "Given property did not match declared version property" );
 			}
 
 			final Getter getter = entityMetamodel.getTuplizer().getVersionGetter();
-			return MapAccessor.MapGetter.class.isInstance( getter )
-					? new MapMember(
-					versionPropertyName,
-					attributeContext.getPropertyMapping().getType().getReturnedClass()
-			)
-					: getter.getMember();
+			if ( PropertyAccessMapImpl.GetterImpl.class.isInstance( getter ) ) {
+				return new MapMember(
+						versionPropertyName,
+						attributeContext.getPropertyMapping().getType().getReturnedClass()
+				);
+			}
+			else {
+				return getter.getMember();
+			}
 		}
 	};
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java
index 0598e6681c..e722bd650f 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java
@@ -1,80 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.boot.internal;
 
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.configuration.internal.MappingCollector;
 import org.hibernate.envers.internal.entities.EntitiesConfigurations;
 import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.internal.synchronization.AuditProcessManager;
 import org.hibernate.envers.strategy.AuditStrategy;
+import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.service.Service;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Provides central access to Envers' configuration.
  *
  * In many ways, this replaces the legacy static map Envers used originally as
  * a means to share the old AuditConfiguration.
  *
  * @author Steve Ebersole
  */
 public interface EnversService extends Service {
 	/**
 	 * The name of the configuration setting used to control whether the Envers integration
 	 * is enabled.  Default is true
 	 */
 	public static final String INTEGRATION_ENABLED = "hibernate.integration.envers.enabled";
 
 	/**
 	 * The name of the legacy configuration setting used to control whether auto registration
 	 * of envers listeners should happen or not.  Default is true
 	 */
 	public static final String LEGACY_AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
 
 	/**
 	 * Is the Envers integration enabled?  This is generally used as a
 	 * protection for other Envers services (in the ServiceLoader sense)
 	 * determine whether they should do their work.
 	 *
 	 * @return {@code true} If the integration is enabled; {@code false} otherwise.
 	 */
 	boolean isEnabled();
 
 	/**
 	 * Assuming {@link #isEnabled()} is {@code true}, has {@link #initialize}
 	 * been called yet?
 	 *
 	 * @return {@code true} indicates {@link #initialize} has been called; {@code false}
 	 * indicates that {@link #initialize} has not (yet) been called.
 	 */
 	boolean isInitialized();
 
 	void initialize(MetadataImplementor metadata, MappingCollector mappingCollector);
 
+	XMLHelper getXmlHelper();
+
 	GlobalConfiguration getGlobalConfiguration();
 
 	AuditEntitiesConfiguration getAuditEntitiesConfiguration();
 
 	AuditProcessManager getAuditProcessManager();
 
 	AuditStrategy getAuditStrategy();
 
 	EntitiesConfigurations getEntitiesConfigurations();
 
 	RevisionInfoQueryCreator getRevisionInfoQueryCreator();
 
 	RevisionInfoNumberReader getRevisionInfoNumberReader();
 
 	ModifiedEntityNamesReader getModifiedEntityNamesReader();
 
 	ClassLoaderService getClassLoaderService();
+
+	ServiceRegistry getServiceRegistry();
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java
index a5431f096b..54d26e940a 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java
@@ -1,278 +1,294 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.boot.internal;
 
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.EntitiesConfigurator;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.configuration.internal.MappingCollector;
 import org.hibernate.envers.configuration.internal.RevisionInfoConfiguration;
 import org.hibernate.envers.configuration.internal.RevisionInfoConfigurationResult;
 import org.hibernate.envers.internal.entities.EntitiesConfigurations;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.internal.synchronization.AuditProcessManager;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.strategy.AuditStrategy;
 import org.hibernate.envers.strategy.ValidityAuditStrategy;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.property.Getter;
+import org.hibernate.internal.util.xml.XMLHelper;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.Stoppable;
 
 import org.jboss.logging.Logger;
 
 /**
  * Provides central access to Envers' configuration.
  *
  * In many ways, this replaces the legacy static map Envers used originally as
  * a means to share the old AuditConfiguration.
  *
  * @author Steve Ebersole
  */
 public class EnversServiceImpl implements EnversService, Configurable, Stoppable {
 	private static final Logger log = Logger.getLogger( EnversServiceImpl.class );
 
 	private boolean integrationEnabled;
 	private boolean initialized;
 
 	private ServiceRegistry serviceRegistry;
 	private ClassLoaderService classLoaderService;
 
 	// todo : not at all a fan of all these...
 	//		1) GlobalConfiguration, AuditEntitiesConfiguration and AuditStrategy are
 	// 			all "configuration" objects.  They seem unnecessarily split apart from
 	//			each other.  Why 3?  Why not just one?
 	//		2) AuditProcessManager is a glorified Map of AuditProcess instances (BeforeTransactionCompletionProcess)
 	//			keyed by Transaction (Session)
 	//		3) Make sure that the info kept here is all really needed at run time, and not just at
 	//			"mapping time"
 	private GlobalConfiguration globalConfiguration;
 	private AuditEntitiesConfiguration auditEntitiesConfiguration;
 	private AuditProcessManager auditProcessManager;
 	private AuditStrategy auditStrategy;
 	private EntitiesConfigurations entitiesConfigurations;
 	private RevisionInfoQueryCreator revisionInfoQueryCreator;
 	private RevisionInfoNumberReader revisionInfoNumberReader;
 	private ModifiedEntityNamesReader modifiedEntityNamesReader;
 
+	private XMLHelper xmlHelper;
+
 	@Override
 	public void configure(Map configurationValues) {
 		final boolean legacySetting = ConfigurationHelper.getBoolean( LEGACY_AUTO_REGISTER, configurationValues, true );
 		this.integrationEnabled = ConfigurationHelper.getBoolean( INTEGRATION_ENABLED, configurationValues, legacySetting );
 
 		log.infof( "Envers integration enabled? : %s", integrationEnabled );
 	}
 
 	@Override
 	public boolean isEnabled() {
 		return integrationEnabled;
 	}
 
 	@Override
 	public boolean isInitialized() {
 		return initialized;
 	}
 
 	@Override
 	public void initialize(final MetadataImplementor metadata, final MappingCollector mappingCollector) {
 		if ( initialized ) {
 			throw new UnsupportedOperationException( "EnversService#initialize should be called only once" );
 		}
 
 		initialized = true;
 
 
 		this.serviceRegistry = metadata.getMetadataBuildingOptions().getServiceRegistry();
-
 		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+		this.xmlHelper = new XMLHelper( classLoaderService );
 
-		doInitialize( metadata, mappingCollector, serviceRegistry, classLoaderService );
+		doInitialize( metadata, mappingCollector, serviceRegistry );
 	}
 
 	private void doInitialize(
 			final MetadataImplementor metadata,
 			final MappingCollector mappingCollector,
-			ServiceRegistry serviceRegistry,
-			ClassLoaderService classLoaderService) {
+			ServiceRegistry serviceRegistry) {
 		final ConfigurationService cfgService = serviceRegistry.getService( ConfigurationService.class );
 		final Properties properties = new Properties();
 		properties.putAll( cfgService.getSettings() );
 
-		this.globalConfiguration = new GlobalConfiguration( properties, classLoaderService );
+		this.globalConfiguration = new GlobalConfiguration( this, properties );
 
 		final ReflectionManager reflectionManager = metadata.getMetadataBuildingOptions()
 				.getReflectionManager();
 		final RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalConfiguration );
 		final RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure(
 				metadata,
 				reflectionManager
 		);
 
 		EnversServiceImpl.this.auditEntitiesConfiguration = new AuditEntitiesConfiguration(
 				properties,
 				revInfoCfgResult.getRevisionInfoEntityName()
 		);
-		EnversServiceImpl.this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
-		EnversServiceImpl.this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
-		EnversServiceImpl.this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
-		EnversServiceImpl.this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
-		EnversServiceImpl.this.auditStrategy = initializeAuditStrategy(
+		this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
+		this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
+		this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
+		this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
+		this.auditStrategy = initializeAuditStrategy(
 				auditEntitiesConfiguration.getAuditStrategyName(),
 				revInfoCfgResult.getRevisionInfoClass(),
 				revInfoCfgResult.getRevisionInfoTimestampData(),
-				classLoaderService
+				serviceRegistry
 		);
-		EnversServiceImpl.this.entitiesConfigurations = new EntitiesConfigurator().configure(
+		this.entitiesConfigurations = new EntitiesConfigurator().configure(
 				metadata,
 				serviceRegistry,
 				reflectionManager,
 				mappingCollector,
 				globalConfiguration,
 				auditEntitiesConfiguration,
 				auditStrategy,
 				revInfoCfgResult.getRevisionInfoXmlMapping(),
 				revInfoCfgResult.getRevisionInfoRelationMapping()
 		);
 	}
 
 	private static AuditStrategy initializeAuditStrategy(
 			String auditStrategyName,
 			Class<?> revisionInfoClass,
 			PropertyData revisionInfoTimestampData,
-			ClassLoaderService classLoaderService) {
+			ServiceRegistry serviceRegistry) {
 		AuditStrategy strategy;
 
 		try {
-			Class<?> auditStrategyClass = loadClass( auditStrategyName, classLoaderService );
+			final Class<?> auditStrategyClass = loadClass( auditStrategyName, serviceRegistry );
 			strategy = (AuditStrategy) ReflectHelper.getDefaultConstructor( auditStrategyClass ).newInstance();
 		}
 		catch (Exception e) {
 			throw new MappingException(
 					String.format( "Unable to create AuditStrategy [%s] instance.", auditStrategyName ),
 					e
 			);
 		}
 
 		if ( strategy instanceof ValidityAuditStrategy ) {
 			// further initialization required
 			final Getter revisionTimestampGetter = ReflectionTools.getGetter(
 					revisionInfoClass,
-					revisionInfoTimestampData
+					revisionInfoTimestampData,
+					serviceRegistry
 			);
 			( (ValidityAuditStrategy) strategy ).setRevisionTimestampGetter( revisionTimestampGetter );
 		}
 
 		return strategy;
 	}
 
+	@Override
+	public XMLHelper getXmlHelper() {
+		return xmlHelper;
+	}
+
 	/**
 	 * Load a class by name, preferring our ClassLoader and then the ClassLoaderService.
 	 *
 	 * @param auditStrategyName The name of the class to load
-	 * @param classLoaderService The ClassLoaderService
+	 * @param serviceRegistry The ServiceRegistry
 	 *
 	 * @return The loaded class.
 	 */
-	private static Class<?> loadClass(String auditStrategyName, ClassLoaderService classLoaderService) {
+	private static Class<?> loadClass(String auditStrategyName, ServiceRegistry serviceRegistry) {
 		try {
 			return EnversServiceImpl.class.getClassLoader().loadClass( auditStrategyName );
 		}
 		catch (Exception e) {
-			return ReflectionTools.loadClass( auditStrategyName, classLoaderService );
+			return ReflectionTools.loadClass( auditStrategyName, serviceRegistry.getService( ClassLoaderService.class ) );
 		}
 	}
 
 	@Override
 	public GlobalConfiguration getGlobalConfiguration() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return globalConfiguration;
 	}
 
 	@Override
 	public AuditEntitiesConfiguration getAuditEntitiesConfiguration() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return auditEntitiesConfiguration;
 	}
 
 	@Override
 	public AuditProcessManager getAuditProcessManager() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return auditProcessManager;
 	}
 
 	@Override
 	public AuditStrategy getAuditStrategy() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return auditStrategy;
 	}
 
 	@Override
 	public EntitiesConfigurations getEntitiesConfigurations() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return entitiesConfigurations;
 	}
 
 	@Override
 	public RevisionInfoQueryCreator getRevisionInfoQueryCreator() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return revisionInfoQueryCreator;
 	}
 
 	@Override
 	public RevisionInfoNumberReader getRevisionInfoNumberReader() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return revisionInfoNumberReader;
 	}
 
 	@Override
 	public ModifiedEntityNamesReader getModifiedEntityNamesReader() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return modifiedEntityNamesReader;
 	}
 
 	@Override
 	public ClassLoaderService getClassLoaderService() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "Service is not yet initialized" );
 		}
 		return classLoaderService;
 	}
 
 	@Override
+	public ServiceRegistry getServiceRegistry() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return serviceRegistry;
+	}
+
+	@Override
 	public void stop() {
 		// anything to release?
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
index e32619baed..3a4a8e51d9 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
@@ -1,163 +1,166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.strategy.DefaultAuditStrategy;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * Configuration of versions entities - names of fields, entities and tables created to store versioning information.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Stephanie Pau at Markit Group Plc
  */
 public class  AuditEntitiesConfiguration {
 	private final String auditTablePrefix;
 	private final String auditTableSuffix;
 
 	private final String auditStrategyName;
 	private final String originalIdPropName;
 
 	private final String revisionFieldName;
 	private final String revisionNumberPath;
 	private final String revisionPropBasePath;
 
 	private final String revisionTypePropName;
 	private final String revisionTypePropType;
 
 	private final String revisionInfoEntityName;
 
 	private final Map<String, String> customAuditTablesNames;
 
 	private final String revisionEndFieldName;
 
 	private final boolean revisionEndTimestampEnabled;
 	private final String revisionEndTimestampFieldName;
 
 	private final String embeddableSetOrdinalPropertyName;
 
-	public AuditEntitiesConfiguration(Properties properties, String revisionInfoEntityName) {
+	public AuditEntitiesConfiguration(
+			Properties properties,
+			String revisionInfoEntityName) {
 		this.revisionInfoEntityName = revisionInfoEntityName;
 
 		auditTablePrefix = ConfigurationHelper.getString( EnversSettings.AUDIT_TABLE_PREFIX, properties, "" );
 		auditTableSuffix = ConfigurationHelper.getString( EnversSettings.AUDIT_TABLE_SUFFIX, properties, "_AUD" );
 
 		auditStrategyName = ConfigurationHelper.getString(
 				EnversSettings.AUDIT_STRATEGY, properties, DefaultAuditStrategy.class.getName()
 		);
 
 		originalIdPropName = "originalId";
 
 		revisionFieldName = ConfigurationHelper.getString( EnversSettings.REVISION_FIELD_NAME, properties, "REV" );
 
 		revisionTypePropName = ConfigurationHelper.getString(
 				EnversSettings.REVISION_TYPE_FIELD_NAME, properties, "REVTYPE"
 		);
 		revisionTypePropType = "byte";
 
 		revisionEndFieldName = ConfigurationHelper.getString(
 				EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME, properties, "REVEND"
 		);
 
 		revisionEndTimestampEnabled = ConfigurationHelper.getBoolean(
 				EnversSettings.AUDIT_STRATEGY_VALIDITY_STORE_REVEND_TIMESTAMP, properties, false
 		);
 
 		if ( revisionEndTimestampEnabled ) {
 			revisionEndTimestampFieldName = ConfigurationHelper.getString(
 					EnversSettings.AUDIT_STRATEGY_VALIDITY_REVEND_TIMESTAMP_FIELD_NAME, properties, "REVEND_TSTMP"
 			);
 		}
 		else {
 			revisionEndTimestampFieldName = null;
 		}
 
 		customAuditTablesNames = new HashMap<String, String>();
 
 		revisionNumberPath = originalIdPropName + "." + revisionFieldName + ".id";
 		revisionPropBasePath = originalIdPropName + "." + revisionFieldName + ".";
 
 		embeddableSetOrdinalPropertyName = ConfigurationHelper.getString(
 				EnversSettings.EMBEDDABLE_SET_ORDINAL_FIELD_NAME, properties, "SETORDINAL"
 		);
 	}
 
 	public String getOriginalIdPropName() {
 		return originalIdPropName;
 	}
 
 	public String getRevisionFieldName() {
 		return revisionFieldName;
 	}
 
 	public boolean isRevisionEndTimestampEnabled() {
 		return revisionEndTimestampEnabled;
 	}
 
 	public String getRevisionEndTimestampFieldName() {
 		return revisionEndTimestampFieldName;
 	}
 
 	public String getRevisionNumberPath() {
 		return revisionNumberPath;
 	}
 
 	/**
 	 * @param propertyName Property of the revision entity.
 	 *
 	 * @return A path to the given property of the revision entity associated with an audit entity.
 	 */
 	public String getRevisionPropPath(String propertyName) {
 		return revisionPropBasePath + propertyName;
 	}
 
 	public String getRevisionTypePropName() {
 		return revisionTypePropName;
 	}
 
 	public String getRevisionTypePropType() {
 		return revisionTypePropType;
 	}
 
 	public String getRevisionInfoEntityName() {
 		return revisionInfoEntityName;
 	}
 
 	public void addCustomAuditTableName(String entityName, String tableName) {
 		customAuditTablesNames.put( entityName, tableName );
 	}
 
 	public String getAuditEntityName(String entityName) {
 		return auditTablePrefix + entityName + auditTableSuffix;
 	}
 
 	public String getAuditTableName(String entityName, String tableName) {
 		final String customHistoryTableName = customAuditTablesNames.get( entityName );
 		if ( customHistoryTableName == null ) {
 			return auditTablePrefix + tableName + auditTableSuffix;
 		}
 
 		return customHistoryTableName;
 	}
 
 	public String getAuditStrategyName() {
 		return auditStrategyName;
 	}
 
 	public String getRevisionEndFieldName() {
 		return revisionEndFieldName;
 	}
 
 	public String getEmbeddableSetOrdinalPropertyName() {
 		return embeddableSetOrdinalPropertyName;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
index d76bd484f7..9e3d67e282 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
@@ -1,211 +1,224 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.Map;
 
 import org.hibernate.MappingException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.envers.RevisionListener;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Nicolas Doroskevich
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class GlobalConfiguration {
+	private final EnversService enversService;
+
 	// Should a revision be generated when a not-owned relation field changes
 	private final boolean generateRevisionsForCollections;
 
 	// Should the optimistic locking property of an entity be considered unversioned
 	private final boolean doNotAuditOptimisticLockingField;
 
 	// Should entity data be stored when it is deleted
 	private final boolean storeDataAtDelete;
 
 	// The default name of the schema of audit tables.
 	private final String defaultSchemaName;
 
 	// The default name of the catalog of the audit tables.
 	private final String defaultCatalogName;
 
 	// Should Envers track (persist) entity names that have been changed during each revision.
 	private boolean trackEntitiesChangedInRevision;
 
 	// Revision listener class name.
 	private final Class<? extends RevisionListener> revisionListenerClass;
 
 	// Should Envers use modified property flags by default
 	private boolean globalWithModifiedFlag;
 
 	// Indicates that user defined global behavior for modified flags feature
 	private boolean hasGlobalSettingForWithModifiedFlag;
 
 	// Suffix to be used for modified flags columns
 	private String modifiedFlagSuffix;
 
 	// Use revision entity with native id generator
 	private final boolean useRevisionEntityWithNativeId;
 	
 	// While deleting revision entry, remove data of associated audited entities
 	private final boolean cascadeDeleteRevision;
 
 	// Support reused identifiers of previously deleted entities
 	private final boolean allowIdentifierReuse;
 
 	/*
 		 Which operator to use in correlated subqueries (when we want a property to be equal to the result of
 		 a correlated subquery, for example: e.p <operator> (select max(e2.p) where e2.p2 = e.p2 ...).
 		 Normally, this should be "=". However, HSQLDB has an issue related to that, so as a workaround,
 		 "in" is used. See {@link org.hibernate.envers.test.various.HsqlTest}.
 	*/
 	private final String correlatedSubqueryOperator;
 
-	public GlobalConfiguration(Map properties, ClassLoaderService classLoaderService) {
+	public GlobalConfiguration(
+			EnversService enversService,
+			Map properties) {
+		this.enversService = enversService;
+
 		generateRevisionsForCollections = ConfigurationHelper.getBoolean(
 				EnversSettings.REVISION_ON_COLLECTION_CHANGE,
 				properties,
 				true
 		);
 
 		doNotAuditOptimisticLockingField = ConfigurationHelper.getBoolean(
 				EnversSettings.DO_NOT_AUDIT_OPTIMISTIC_LOCKING_FIELD,
 				properties,
 				true
 		);
 
 		storeDataAtDelete = ConfigurationHelper.getBoolean(
 				EnversSettings.STORE_DATA_AT_DELETE,
 				properties,
 				false
 		);
 
 		defaultSchemaName = (String) properties.get( EnversSettings.DEFAULT_SCHEMA );
 		defaultCatalogName = (String) properties.get( EnversSettings.DEFAULT_CATALOG );
 
 		correlatedSubqueryOperator = HSQLDialect.class.getName().equals( properties.get( Environment.DIALECT ) )
 				? "in"
 				: "=";
 
 		trackEntitiesChangedInRevision = ConfigurationHelper.getBoolean(
 				EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION,
 				properties,
 				false
 		);
 		
 		cascadeDeleteRevision = ConfigurationHelper.getBoolean(
 				"org.hibernate.envers.cascade_delete_revision",
 				properties,
 				false
 		);
 
 		useRevisionEntityWithNativeId = ConfigurationHelper.getBoolean(
 				EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID,
 				properties,
 				true
 		);
 
 		hasGlobalSettingForWithModifiedFlag = properties.get( EnversSettings.GLOBAL_WITH_MODIFIED_FLAG ) != null;
 		globalWithModifiedFlag = ConfigurationHelper.getBoolean(
 				EnversSettings.GLOBAL_WITH_MODIFIED_FLAG,
 				properties,
 				false
 		);
 		modifiedFlagSuffix = ConfigurationHelper.getString(
 				EnversSettings.MODIFIED_FLAG_SUFFIX,
 				properties,
 				"_MOD"
 		);
 
 		final String revisionListenerClassName = (String) properties.get( EnversSettings.REVISION_LISTENER );
 		if ( revisionListenerClassName != null ) {
 			try {
-				revisionListenerClass = ReflectionTools.loadClass( revisionListenerClassName, classLoaderService );
+				revisionListenerClass = ReflectionTools.loadClass(
+						revisionListenerClassName,
+						enversService.getClassLoaderService()
+				);
 			}
 			catch (ClassLoadingException e) {
 				throw new MappingException(
 						"Revision listener class not found: " + revisionListenerClassName + ".",
 						e
 				);
 			}
 		}
 		else {
 			revisionListenerClass = null;
 		}
 
 		allowIdentifierReuse = ConfigurationHelper.getBoolean(
 				EnversSettings.ALLOW_IDENTIFIER_REUSE, properties, false
 		);
 	}
 
+	public EnversService getEnversService() {
+		return enversService;
+	}
+
 	public boolean isGenerateRevisionsForCollections() {
 		return generateRevisionsForCollections;
 	}
 
 	public boolean isDoNotAuditOptimisticLockingField() {
 		return doNotAuditOptimisticLockingField;
 	}
 
 	public String getCorrelatedSubqueryOperator() {
 		return correlatedSubqueryOperator;
 	}
 
 	public boolean isStoreDataAtDelete() {
 		return storeDataAtDelete;
 	}
 
 	public String getDefaultSchemaName() {
 		return defaultSchemaName;
 	}
 
 	public String getDefaultCatalogName() {
 		return defaultCatalogName;
 	}
 
 	public boolean isTrackEntitiesChangedInRevision() {
 		return trackEntitiesChangedInRevision;
 	}
 
 	public void setTrackEntitiesChangedInRevision(boolean trackEntitiesChangedInRevision) {
 		this.trackEntitiesChangedInRevision = trackEntitiesChangedInRevision;
 	}
 
 	public Class<? extends RevisionListener> getRevisionListenerClass() {
 		return revisionListenerClass;
 	}
 
 	public boolean hasSettingForUsingModifiedFlag() {
 		return hasGlobalSettingForWithModifiedFlag;
 	}
 
 	public boolean isGlobalWithModifiedFlag() {
 		return globalWithModifiedFlag;
 	}
 
 	public String getModifiedFlagSuffix() {
 		return modifiedFlagSuffix;
 	}
 
 	public boolean isUseRevisionEntityWithNativeId() {
 		return useRevisionEntityWithNativeId;
 	}
 	
 	public boolean isCascadeDeleteRevision() {
 		return cascadeDeleteRevision;
 	}
 
 	public boolean isAllowIdentifierReuse() {
 		return allowIdentifierReuse;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
index 1b2a9ff1f4..650f6b0210 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
@@ -1,443 +1,457 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.Date;
 import java.util.Set;
 import javax.persistence.Column;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ClassLoadingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.DefaultRevisionEntity;
 import org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity;
 import org.hibernate.envers.ModifiedEntityNames;
 import org.hibernate.envers.RevisionEntity;
 import org.hibernate.envers.RevisionListener;
 import org.hibernate.envers.RevisionNumber;
 import org.hibernate.envers.RevisionTimestamp;
 import org.hibernate.envers.configuration.internal.metadata.AuditTableData;
 import org.hibernate.envers.configuration.internal.metadata.MetadataTools;
 import org.hibernate.envers.enhanced.SequenceIdRevisionEntity;
 import org.hibernate.envers.enhanced.SequenceIdTrackingModifiedEntitiesRevisionEntity;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.revisioninfo.DefaultRevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.DefaultTrackingModifiedEntitiesRevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.internal.tools.MutableBoolean;
-import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.type.LongType;
 import org.hibernate.type.Type;
 
 import org.dom4j.Document;
 import org.dom4j.Element;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class RevisionInfoConfiguration {
 	private String revisionInfoEntityName;
 	private PropertyData revisionInfoIdData;
 	private PropertyData revisionInfoTimestampData;
 	private PropertyData modifiedEntityNamesData;
 	private Type revisionInfoTimestampType;
 	private GlobalConfiguration globalCfg;
 
 	private String revisionPropType;
 	private String revisionPropSqlType;
 
 	public RevisionInfoConfiguration(GlobalConfiguration globalCfg) {
 		this.globalCfg = globalCfg;
 		if ( globalCfg.isUseRevisionEntityWithNativeId() ) {
 			revisionInfoEntityName = "org.hibernate.envers.DefaultRevisionEntity";
 		}
 		else {
 			revisionInfoEntityName = "org.hibernate.envers.enhanced.SequenceIdRevisionEntity";
 		}
 		revisionInfoIdData = new PropertyData( "id", "id", "field", null );
 		revisionInfoTimestampData = new PropertyData( "timestamp", "timestamp", "field", null );
 		modifiedEntityNamesData = new PropertyData( "modifiedEntityNames", "modifiedEntityNames", "field", null );
 		revisionInfoTimestampType = new LongType();
 
 		revisionPropType = "integer";
 	}
 
 	private Document generateDefaultRevisionInfoXmlMapping() {
-		final Document document = XMLHelper.getDocumentFactory().createDocument();
+		final Document document = globalCfg.getEnversService().getXmlHelper().getDocumentFactory().createDocument();
 
 		final Element classMapping = MetadataTools.createEntity(
 				document,
 				new AuditTableData( null, null, globalCfg.getDefaultSchemaName(), globalCfg.getDefaultCatalogName() ),
 				null,
 				null
 		);
 
 		classMapping.addAttribute( "name", revisionInfoEntityName );
 		classMapping.addAttribute( "table", "REVINFO" );
 
 		final Element idProperty = MetadataTools.addNativelyGeneratedId(
 				classMapping,
 				revisionInfoIdData.getName(),
 				revisionPropType,
 				globalCfg.isUseRevisionEntityWithNativeId()
 		);
 		MetadataTools.addColumn( idProperty, "REV", null, null, null, null, null, null, false );
 
 		final Element timestampProperty = MetadataTools.addProperty(
 				classMapping,
 				revisionInfoTimestampData.getName(),
 				revisionInfoTimestampType.getName(),
 				true,
 				false
 		);
 		MetadataTools.addColumn( timestampProperty, "REVTSTMP", null, null, null, null, null, null, false );
 
 		if ( globalCfg.isTrackEntitiesChangedInRevision() ) {
 			generateEntityNamesTrackingTableMapping(
 					classMapping,
 					"modifiedEntityNames",
 					globalCfg.getDefaultSchemaName(),
 					globalCfg.getDefaultCatalogName(),
 					"REVCHANGES",
 					"REV",
 					"ENTITYNAME",
 					"string"
 			);
 		}
 
 		return document;
 	}
 
 	/**
 	 * Generates mapping that represents a set of primitive types.<br />
 	 * <code>
 	 * &lt;set name="propertyName" table="joinTableName" schema="joinTableSchema" catalog="joinTableCatalog"
 	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cascade="persist, delete" lazy="false" fetch="join"&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;key column="joinTablePrimaryKeyColumnName" /&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;element type="joinTableValueColumnType"&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;column name="joinTableValueColumnName" /&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;/element&gt;<br />
 	 * &lt;/set&gt;
 	 * </code>
 	 */
 	private void generateEntityNamesTrackingTableMapping(
 			Element classMapping,
 			String propertyName,
 			String joinTableSchema,
 			String joinTableCatalog,
 			String joinTableName,
 			String joinTablePrimaryKeyColumnName,
 			String joinTableValueColumnName,
 			String joinTableValueColumnType) {
 		final Element set = classMapping.addElement( "set" );
 		set.addAttribute( "name", propertyName );
 		set.addAttribute( "table", joinTableName );
 		set.addAttribute( "schema", joinTableSchema );
 		set.addAttribute( "catalog", joinTableCatalog );
 		set.addAttribute( "cascade", "persist, delete" );
 		set.addAttribute( "fetch", "join" );
 		set.addAttribute( "lazy", "false" );
 		final Element key = set.addElement( "key" );
 		key.addAttribute( "column", joinTablePrimaryKeyColumnName );
 		final Element element = set.addElement( "element" );
 		element.addAttribute( "type", joinTableValueColumnType );
 		final Element column = element.addElement( "column" );
 		column.addAttribute( "name", joinTableValueColumnName );
 	}
 
 	private Element generateRevisionInfoRelationMapping() {
-		final Document document = XMLHelper.getDocumentFactory().createDocument();
+		final Document document = globalCfg.getEnversService().getXmlHelper().getDocumentFactory().createDocument();
 		final Element revRelMapping = document.addElement( "key-many-to-one" );
 		revRelMapping.addAttribute( "type", revisionPropType );
 		revRelMapping.addAttribute( "class", revisionInfoEntityName );
 
 		if ( revisionPropSqlType != null ) {
 			// Putting a fake name to make Hibernate happy. It will be replaced later anyway.
 			MetadataTools.addColumn( revRelMapping, "*", null, null, null, revisionPropSqlType, null, null, false );
 		}
 
 		return revRelMapping;
 	}
 
 	private void searchForRevisionInfoCfgInProperties(
 			XClass clazz,
 			ReflectionManager reflectionManager,
 			MutableBoolean revisionNumberFound,
 			MutableBoolean revisionTimestampFound,
 			MutableBoolean modifiedEntityNamesFound,
 			String accessType) {
 		for ( XProperty property : clazz.getDeclaredProperties( accessType ) ) {
 			final RevisionNumber revisionNumber = property.getAnnotation( RevisionNumber.class );
 			final RevisionTimestamp revisionTimestamp = property.getAnnotation( RevisionTimestamp.class );
 			final ModifiedEntityNames modifiedEntityNames = property.getAnnotation( ModifiedEntityNames.class );
 
 			if ( revisionNumber != null ) {
 				if ( revisionNumberFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @RevisionNumber!" );
 				}
 
 				final XClass revisionNumberClass = property.getType();
 				if ( reflectionManager.equals( revisionNumberClass, Integer.class ) ||
 						reflectionManager.equals( revisionNumberClass, Integer.TYPE ) ) {
 					revisionInfoIdData = new PropertyData( property.getName(), property.getName(), accessType, null );
 					revisionNumberFound.set();
 				}
 				else if ( reflectionManager.equals( revisionNumberClass, Long.class ) ||
 						reflectionManager.equals( revisionNumberClass, Long.TYPE ) ) {
 					revisionInfoIdData = new PropertyData( property.getName(), property.getName(), accessType, null );
 					revisionNumberFound.set();
 
 					// The default is integer
 					revisionPropType = "long";
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @RevisionNumber must be of type " +
 									"int, Integer, long or Long"
 					);
 				}
 
 				// Getting the @Column definition of the revision number property, to later use that info to
 				// generate the same mapping for the relation from an audit table's revision number to the
 				// revision entity revision number.
 				final Column revisionPropColumn = property.getAnnotation( Column.class );
 				if ( revisionPropColumn != null ) {
 					revisionPropSqlType = revisionPropColumn.columnDefinition();
 				}
 			}
 
 			if ( revisionTimestamp != null ) {
 				if ( revisionTimestampFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @RevisionTimestamp!" );
 				}
 
 				final XClass revisionTimestampClass = property.getType();
 				if ( reflectionManager.equals( revisionTimestampClass, Long.class ) ||
 						reflectionManager.equals( revisionTimestampClass, Long.TYPE ) ||
 						reflectionManager.equals( revisionTimestampClass, Date.class ) ||
 						reflectionManager.equals( revisionTimestampClass, java.sql.Date.class ) ) {
 					revisionInfoTimestampData = new PropertyData(
 							property.getName(),
 							property.getName(),
 							accessType,
 							null
 					);
 					revisionTimestampFound.set();
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @RevisionTimestamp must be of type " +
 									"long, Long, java.util.Date or java.sql.Date"
 					);
 				}
 			}
 
 			if ( modifiedEntityNames != null ) {
 				if ( modifiedEntityNamesFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @ModifiedEntityNames!" );
 				}
 				final XClass modifiedEntityNamesClass = property.getType();
 				if ( reflectionManager.equals( modifiedEntityNamesClass, Set.class ) &&
 						reflectionManager.equals( property.getElementClass(), String.class ) ) {
 					modifiedEntityNamesData = new PropertyData(
 							property.getName(),
 							property.getName(),
 							accessType,
 							null
 					);
 					modifiedEntityNamesFound.set();
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @ModifiedEntityNames must be of Set<String> type."
 					);
 				}
 			}
 		}
 	}
 
 	private void searchForRevisionInfoCfg(
 			XClass clazz, ReflectionManager reflectionManager,
 			MutableBoolean revisionNumberFound, MutableBoolean revisionTimestampFound,
 			MutableBoolean modifiedEntityNamesFound) {
 		final XClass superclazz = clazz.getSuperclass();
 		if ( !"java.lang.Object".equals( superclazz.getName() ) ) {
 			searchForRevisionInfoCfg(
 					superclazz,
 					reflectionManager,
 					revisionNumberFound,
 					revisionTimestampFound,
 					modifiedEntityNamesFound
 			);
 		}
 
 		searchForRevisionInfoCfgInProperties(
 				clazz, reflectionManager, revisionNumberFound, revisionTimestampFound,
 				modifiedEntityNamesFound, "field"
 		);
 		searchForRevisionInfoCfgInProperties(
 				clazz, reflectionManager, revisionNumberFound, revisionTimestampFound,
 				modifiedEntityNamesFound, "property"
 		);
 	}
 
 	public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {
 		boolean revisionEntityFound = false;
 		RevisionInfoGenerator revisionInfoGenerator = null;
 		Class<?> revisionInfoClass = null;
 
 		for ( PersistentClass persistentClass : metadata.getEntityBindings() ) {
 			// Ensure we're in POJO, not dynamic model, mapping.
 			if (persistentClass.getClassName() != null) {
 				XClass clazz;
 				try {
 					clazz = reflectionManager.classForName( persistentClass.getClassName() );
 				}
 				catch (ClassLoadingException e) {
 					throw new MappingException( e );
 				}
 
 				final RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );
 				if ( revisionEntity != null ) {
 					if (revisionEntityFound) {
 						throw new MappingException("Only one entity may be annotated with @RevisionEntity!");
 					}
 
 					// Checking if custom revision entity isn't audited
 					if (clazz.getAnnotation(Audited.class) != null) {
 						throw new MappingException("An entity annotated with @RevisionEntity cannot be audited!");
 					}
 
 					revisionEntityFound = true;
 
 					final MutableBoolean revisionNumberFound = new MutableBoolean();
 					final MutableBoolean revisionTimestampFound = new MutableBoolean();
 					final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();
 
 					searchForRevisionInfoCfg(
 							clazz,
 							reflectionManager,
 							revisionNumberFound,
 							revisionTimestampFound,
 							modifiedEntityNamesFound
 					);
 
 					if (!revisionNumberFound.isSet()) {
 						throw new MappingException(
 								"An entity annotated with @RevisionEntity must have a field annotated " +
 										"with @RevisionNumber!"
 						);
 					}
 
 					if (!revisionTimestampFound.isSet()) {
 						throw new MappingException(
 								"An entity annotated with @RevisionEntity must have a field annotated " +
 										"with @RevisionTimestamp!"
 						);
 					}
 
 					revisionInfoEntityName = persistentClass.getEntityName();
 					revisionInfoClass = persistentClass.getMappedClass();
 					final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());
 					revisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();
 					if (globalCfg.isTrackEntitiesChangedInRevision()
 							|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class
 							.isAssignableFrom(revisionInfoClass))
 							|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class
 							.isAssignableFrom(revisionInfoClass))
 							|| modifiedEntityNamesFound.isSet()) {
 						// If tracking modified entities parameter is enabled, custom revision info entity is a subtype
 						// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.
 						revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(
 								revisionInfoEntityName,
-								revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),
-								modifiedEntityNamesData
+								revisionInfoClass,
+								revisionListenerClass,
+								revisionInfoTimestampData,
+								isTimestampAsDate(),
+								modifiedEntityNamesData,
+								metadata.getMetadataBuildingOptions().getServiceRegistry()
 						);
 						globalCfg.setTrackEntitiesChangedInRevision(true);
 					}
 					else {
 						revisionInfoGenerator = new DefaultRevisionInfoGenerator(
-								revisionInfoEntityName, revisionInfoClass,
-								revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()
+								revisionInfoEntityName,
+								revisionInfoClass,
+								revisionListenerClass,
+								revisionInfoTimestampData,
+								isTimestampAsDate(),
+								metadata.getMetadataBuildingOptions().getServiceRegistry()
 						);
 					}
 				}
 			}
 		}
 
 		// In case of a custom revision info generator, the mapping will be null.
 		Document revisionInfoXmlMapping = null;
 
 		final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );
 
 		if ( revisionInfoGenerator == null ) {
 			if ( globalCfg.isTrackEntitiesChangedInRevision() ) {
-				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?
-						DefaultTrackingModifiedEntitiesRevisionEntity.class
-						:
-						SequenceIdTrackingModifiedEntitiesRevisionEntity.class;
+				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId()
+						? DefaultTrackingModifiedEntitiesRevisionEntity.class
+						: SequenceIdTrackingModifiedEntitiesRevisionEntity.class;
 				revisionInfoEntityName = revisionInfoClass.getName();
 				revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(
-						revisionInfoEntityName, revisionInfoClass,
-						revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData
+						revisionInfoEntityName,
+						revisionInfoClass,
+						revisionListenerClass,
+						revisionInfoTimestampData,
+						isTimestampAsDate(),
+						modifiedEntityNamesData,
+						metadata.getMetadataBuildingOptions().getServiceRegistry()
 				);
 			}
 			else {
-				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class
+				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId()
+						? DefaultRevisionEntity.class
 						: SequenceIdRevisionEntity.class;
 				revisionInfoGenerator = new DefaultRevisionInfoGenerator(
-						revisionInfoEntityName, revisionInfoClass,
-						revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()
+						revisionInfoEntityName,
+						revisionInfoClass,
+						revisionListenerClass,
+						revisionInfoTimestampData,
+						isTimestampAsDate(),
+						metadata.getMetadataBuildingOptions().getServiceRegistry()
 				);
 			}
 			revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();
 		}
 
 		return new RevisionInfoConfigurationResult(
 				revisionInfoGenerator, revisionInfoXmlMapping,
 				new RevisionInfoQueryCreator(
 						revisionInfoEntityName, revisionInfoIdData.getName(),
 						revisionInfoTimestampData.getName(), isTimestampAsDate()
 				),
 				generateRevisionInfoRelationMapping(),
-				new RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),
-				globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(
-						revisionInfoClass,
-						modifiedEntityNamesData
-				)
+				new RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry() ),
+				globalCfg.isTrackEntitiesChangedInRevision()
+						? new ModifiedEntityNamesReader( revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry() )
 						: null,
 				revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData
 		);
 	}
 
 	private boolean isTimestampAsDate() {
 		final String typename = revisionInfoTimestampType.getName();
 		return "date".equals( typename ) || "time".equals( typename ) || "timestamp".equals( typename );
 	}
 
 	/**
 	 * @param defaultListener Revision listener that shall be applied if {@code org.hibernate.envers.revision_listener}
 	 * parameter has not been set.
 	 *
 	 * @return Revision listener.
 	 */
 	private Class<? extends RevisionListener> getRevisionListenerClass(Class<? extends RevisionListener> defaultListener) {
 		if ( globalCfg.getRevisionListenerClass() != null ) {
 			return globalCfg.getRevisionListenerClass();
 		}
 		return defaultListener;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/IdMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/IdMetadataGenerator.java
index 0bac4fe592..07084911ee 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/IdMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/IdMetadataGenerator.java
@@ -1,211 +1,211 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.Iterator;
 
 import org.hibernate.MappingException;
 import org.hibernate.envers.ModificationStore;
 import org.hibernate.envers.RelationTargetAuditMode;
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.entities.IdMappingData;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.SimpleMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.id.EmbeddedIdMapper;
 import org.hibernate.envers.internal.entities.mapper.id.MultipleIdMapper;
 import org.hibernate.envers.internal.entities.mapper.id.SimpleIdMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.id.SingleIdMapper;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.type.ManyToOneType;
 import org.hibernate.type.Type;
 
 import org.dom4j.Element;
 import org.dom4j.tree.DefaultElement;
 
 /**
  * Generates metadata for primary identifiers (ids) of versions entities.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public final class IdMetadataGenerator {
 	private final AuditMetadataGenerator mainGenerator;
 
 	IdMetadataGenerator(AuditMetadataGenerator auditMetadataGenerator) {
 		mainGenerator = auditMetadataGenerator;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private boolean addIdProperties(
 			Element parent,
 			Iterator<Property> properties,
 			SimpleMapperBuilder mapper,
 			boolean key,
 			boolean audited) {
 		while ( properties.hasNext() ) {
 			final Property property = properties.next();
 			final Type propertyType = property.getType();
 			if ( !"_identifierMapper".equals( property.getName() ) ) {
 				boolean added = false;
 				if ( propertyType instanceof ManyToOneType ) {
 					added = mainGenerator.getBasicMetadataGenerator().addManyToOne(
 							parent,
 							getIdPersistentPropertyAuditingData( property ),
 							property.getValue(),
 							mapper
 					);
 				}
 				else {
 					// Last but one parameter: ids are always insertable
 					added = mainGenerator.getBasicMetadataGenerator().addBasic(
 							parent,
 							getIdPersistentPropertyAuditingData( property ),
 							property.getValue(),
 							mapper,
 							true,
 							key
 					);
 				}
 				if ( !added ) {
 					// If the entity is audited, and a non-supported id component is used, throwing an exception.
 					// If the entity is not audited, then we simply don't support this entity, even in
 					// target relation mode not audited.
 					if ( audited ) {
 						throw new MappingException( "Type not supported: " + propertyType.getClass().getName() );
 					}
 					else {
 						return false;
 					}
 				}
 			}
 		}
 
 		return true;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	IdMappingData addId(PersistentClass pc, boolean audited) {
 		// Xml mapping which will be used for relations
 		final Element relIdMapping = new DefaultElement( "properties" );
 		// Xml mapping which will be used for the primary key of the versions table
 		final Element origIdMapping = new DefaultElement( "composite-id" );
 
 		final Property idProp = pc.getIdentifierProperty();
 		final Component idMapper = pc.getIdentifierMapper();
 
 		// Checking if the id mapping is supported
 		if ( idMapper == null && idProp == null ) {
 			return null;
 		}
 
 		SimpleIdMapperBuilder mapper;
 		if ( idMapper != null ) {
 			// Multiple id
 			final Class componentClass = ReflectionTools.loadClass(
 					( (Component) pc.getIdentifier() ).getComponentClassName(),
 					mainGenerator.getClassLoaderService()
 			);
-			mapper = new MultipleIdMapper( componentClass );
+			mapper = new MultipleIdMapper( componentClass, pc.getServiceRegistry() );
 			if ( !addIdProperties(
 					relIdMapping,
 					(Iterator<Property>) idMapper.getPropertyIterator(),
 					mapper,
 					false,
 					audited
 			) ) {
 				return null;
 			}
 
 			// null mapper - the mapping where already added the first time, now we only want to generate the xml
 			if ( !addIdProperties(
 					origIdMapping,
 					(Iterator<Property>) idMapper.getPropertyIterator(),
 					null,
 					true,
 					audited
 			) ) {
 				return null;
 			}
 		}
 		else if ( idProp.isComposite() ) {
 			// Embedded id
 			final Component idComponent = (Component) idProp.getValue();
 			final Class embeddableClass = ReflectionTools.loadClass(
 					idComponent.getComponentClassName(),
 					mainGenerator.getClassLoaderService()
 			);
-			mapper = new EmbeddedIdMapper( getIdPropertyData( idProp ), embeddableClass );
+			mapper = new EmbeddedIdMapper( getIdPropertyData( idProp ), embeddableClass, pc.getServiceRegistry() );
 			if ( !addIdProperties(
 					relIdMapping,
 					(Iterator<Property>) idComponent.getPropertyIterator(),
 					mapper,
 					false,
 					audited
 			) ) {
 				return null;
 			}
 
 			// null mapper - the mapping where already added the first time, now we only want to generate the xml
 			if ( !addIdProperties(
 					origIdMapping,
 					(Iterator<Property>) idComponent.getPropertyIterator(),
 					null,
 					true,
 					audited
 			) ) {
 				return null;
 			}
 		}
 		else {
 			// Single id
-			mapper = new SingleIdMapper();
+			mapper = new SingleIdMapper( pc.getServiceRegistry() );
 
 			// Last but one parameter: ids are always insertable
 			mainGenerator.getBasicMetadataGenerator().addBasic(
 					relIdMapping,
 					getIdPersistentPropertyAuditingData( idProp ),
 					idProp.getValue(),
 					mapper,
 					true,
 					false
 			);
 
 			// null mapper - the mapping where already added the first time, now we only want to generate the xml
 			mainGenerator.getBasicMetadataGenerator().addBasic(
 					origIdMapping,
 					getIdPersistentPropertyAuditingData( idProp ),
 					idProp.getValue(),
 					null,
 					true,
 					true
 			);
 		}
 
 		origIdMapping.addAttribute( "name", mainGenerator.getVerEntCfg().getOriginalIdPropName() );
 
 		// Adding a relation to the revision entity (effectively: the "revision number" property)
 		mainGenerator.addRevisionInfoRelation( origIdMapping );
 
 		return new IdMappingData( mapper, origIdMapping, relIdMapping );
 	}
 
 	private PropertyData getIdPropertyData(Property property) {
 		return new PropertyData(
 				property.getName(), property.getName(), property.getPropertyAccessorName(),
 				ModificationStore.FULL
 		);
 	}
 
 	private PropertyAuditingData getIdPersistentPropertyAuditingData(Property property) {
 		return new PropertyAuditingData(
 				property.getName(), property.getPropertyAccessorName(),
 				ModificationStore.FULL, RelationTargetAuditMode.AUDITED, null, null, false
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ToOneRelationMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ToOneRelationMetadataGenerator.java
index d8bf2cf63f..681402a03a 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ToOneRelationMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ToOneRelationMetadataGenerator.java
@@ -1,184 +1,195 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import org.hibernate.MappingException;
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.IdMappingData;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.CompositeMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.OneToOneNotOwningMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.OneToOnePrimaryKeyJoinColumnMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.ToOneIdMapper;
 import org.hibernate.envers.internal.tools.MappingTools;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.ToOne;
 import org.hibernate.mapping.Value;
 
 import org.dom4j.Element;
 
 /**
  * Generates metadata for to-one relations (reference-valued properties).
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public final class ToOneRelationMetadataGenerator {
 	private final AuditMetadataGenerator mainGenerator;
 
 	ToOneRelationMetadataGenerator(AuditMetadataGenerator auditMetadataGenerator) {
 		mainGenerator = auditMetadataGenerator;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	void addToOne(
 			Element parent,
 			PropertyAuditingData propertyAuditingData,
 			Value value,
 			CompositeMapperBuilder mapper,
 			String entityName,
 			boolean insertable) {
 		final String referencedEntityName = ((ToOne) value).getReferencedEntityName();
 
 		final IdMappingData idMapping = mainGenerator.getReferencedIdMappingData(
 				entityName,
 				referencedEntityName,
 				propertyAuditingData,
 				true
 		);
 
 		final String lastPropertyPrefix = MappingTools.createToOneRelationPrefix( propertyAuditingData.getName() );
 
 		// Generating the id mapper for the relation
 		final IdMapper relMapper = idMapping.getIdMapper().prefixMappedProperties( lastPropertyPrefix );
 
 		// Storing information about this relation
 		mainGenerator.getEntitiesConfigurations().get( entityName ).addToOneRelation(
 				propertyAuditingData.getName(), referencedEntityName, relMapper,
 				insertable, MappingTools.ignoreNotFound( value )
 		);
 
 		// If the property isn't insertable, checking if this is not a "fake" bidirectional many-to-one relationship,
 		// that is, when the one side owns the relation (and is a collection), and the many side is non insertable.
 		// When that's the case and the user specified to store this relation without a middle table (using
 		// @AuditMappedBy), we have to make the property insertable for the purposes of Envers. In case of changes to
 		// the entity that didn't involve the relation, it's value will then be stored properly. In case of changes
 		// to the entity that did involve the relation, it's the responsibility of the collection side to store the
 		// proper data.
 		boolean nonInsertableFake;
 		if ( !insertable && propertyAuditingData.isForceInsertable() ) {
 			nonInsertableFake = true;
 			insertable = true;
 		}
 		else {
 			nonInsertableFake = false;
 		}
 
 		// Adding an element to the mapping corresponding to the references entity id's
 		final Element properties = (Element) idMapping.getXmlRelationMapping().clone();
 		properties.addAttribute( "name", propertyAuditingData.getName() );
 
 		MetadataTools.prefixNamesInPropertyElement(
 				properties,
 				lastPropertyPrefix,
 				MetadataTools.getColumnNameIterator( value.getColumnIterator() ),
 				false,
 				insertable
 		);
 
 		// Extracting related id properties from properties tag
 		for ( Object o : properties.content() ) {
 			final Element element = (Element) o;
 			element.setParent( null );
 			parent.add( element );
 		}
 
 		// Adding mapper for the id
 		final PropertyData propertyData = propertyAuditingData.getPropertyData();
 		mapper.addComposite(
 				propertyData,
 				new ToOneIdMapper( relMapper, propertyData, referencedEntityName, nonInsertableFake )
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	void addOneToOneNotOwning(
 			PropertyAuditingData propertyAuditingData,
 			Value value,
 			CompositeMapperBuilder mapper,
 			String entityName) {
 		final OneToOne propertyValue = (OneToOne) value;
 		final String owningReferencePropertyName = propertyValue.getReferencedPropertyName();
 
 		final EntityConfiguration configuration = mainGenerator.getEntitiesConfigurations().get( entityName );
 		if ( configuration == null ) {
 			throw new MappingException( "An audited relation to a non-audited entity " + entityName + "!" );
 		}
 
 		final IdMappingData ownedIdMapping = configuration.getIdMappingData();
 
 		if ( ownedIdMapping == null ) {
 			throw new MappingException( "An audited relation to a non-audited entity " + entityName + "!" );
 		}
 
 		final String lastPropertyPrefix = MappingTools.createToOneRelationPrefix( owningReferencePropertyName );
 		final String referencedEntityName = propertyValue.getReferencedEntityName();
 
 		// Generating the id mapper for the relation
 		final IdMapper ownedIdMapper = ownedIdMapping.getIdMapper().prefixMappedProperties( lastPropertyPrefix );
 
 		// Storing information about this relation
 		mainGenerator.getEntitiesConfigurations().get( entityName ).addToOneNotOwningRelation(
 				propertyAuditingData.getName(), owningReferencePropertyName, referencedEntityName,
 				ownedIdMapper, MappingTools.ignoreNotFound( value )
 		);
 
 		// Adding mapper for the id
 		final PropertyData propertyData = propertyAuditingData.getPropertyData();
 		mapper.addComposite(
 				propertyData,
-				new OneToOneNotOwningMapper( entityName, referencedEntityName, owningReferencePropertyName, propertyData )
+				new OneToOneNotOwningMapper(
+						entityName,
+						referencedEntityName,
+						owningReferencePropertyName,
+						propertyData,
+						mainGenerator.getServiceRegistry()
+				)
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	void addOneToOnePrimaryKeyJoinColumn(
 			PropertyAuditingData propertyAuditingData,
 			Value value,
 			CompositeMapperBuilder mapper,
 			String entityName,
 			boolean insertable) {
 		final String referencedEntityName = ((ToOne) value).getReferencedEntityName();
 
 		final IdMappingData idMapping = mainGenerator.getReferencedIdMappingData(
 				entityName,
 				referencedEntityName,
 				propertyAuditingData,
 				true
 		);
 
 		final String lastPropertyPrefix = MappingTools.createToOneRelationPrefix( propertyAuditingData.getName() );
 
 		// Generating the id mapper for the relation
 		final IdMapper relMapper = idMapping.getIdMapper().prefixMappedProperties( lastPropertyPrefix );
 
 		// Storing information about this relation
 		mainGenerator.getEntitiesConfigurations().get( entityName ).addToOneRelation(
 				propertyAuditingData.getName(), referencedEntityName, relMapper, insertable,
 				MappingTools.ignoreNotFound( value )
 		);
 
 		// Adding mapper for the id
 		final PropertyData propertyData = propertyAuditingData.getPropertyData();
 		mapper.addComposite(
 				propertyData,
-				new OneToOnePrimaryKeyJoinColumnMapper( entityName, referencedEntityName, propertyData )
+				new OneToOnePrimaryKeyJoinColumnMapper(
+						entityName,
+						referencedEntityName,
+						propertyData,
+						mainGenerator.getServiceRegistry()
+				)
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java
deleted file mode 100644
index de932f39e3..0000000000
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
- * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
- */
-package org.hibernate.envers.configuration.spi;
-
-import java.util.Properties;
-
-import org.hibernate.MappingException;
-import org.hibernate.annotations.common.reflection.ReflectionManager;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.spi.MetadataImplementor;
-import org.hibernate.engine.config.spi.ConfigurationService;
-import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.internal.EntitiesConfigurator;
-import org.hibernate.envers.configuration.internal.GlobalConfiguration;
-import org.hibernate.envers.configuration.internal.MappingCollector;
-import org.hibernate.envers.configuration.internal.RevisionInfoConfiguration;
-import org.hibernate.envers.configuration.internal.RevisionInfoConfigurationResult;
-import org.hibernate.envers.internal.entities.EntitiesConfigurations;
-import org.hibernate.envers.internal.entities.PropertyData;
-import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
-import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
-import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
-import org.hibernate.envers.internal.synchronization.AuditProcessManager;
-import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.envers.strategy.AuditStrategy;
-import org.hibernate.envers.strategy.ValidityAuditStrategy;
-import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.property.Getter;
-import org.hibernate.service.ServiceRegistry;
-
-/**
- * @author Adam Warski (adam at warski dot org)
- * @author Stephanie Pau at Markit Group Plc
- * @author Steve Ebersole
- */
-public class AuditConfiguration {
-	private final ServiceRegistry serviceRegistry;
-
-	private final GlobalConfiguration globalCfg;
-	private final AuditEntitiesConfiguration auditEntCfg;
-	private final AuditProcessManager auditProcessManager;
-	private final AuditStrategy auditStrategy;
-	private final EntitiesConfigurations entCfg;
-	private final RevisionInfoQueryCreator revisionInfoQueryCreator;
-	private final RevisionInfoNumberReader revisionInfoNumberReader;
-	private final ModifiedEntityNamesReader modifiedEntityNamesReader;
-
-	public AuditConfiguration(MetadataImplementor metadata, MappingCollector mappingCollector) {
-		this.serviceRegistry = metadata.getMetadataBuildingOptions().getServiceRegistry();
-
-		final ConfigurationService cfgService = serviceRegistry.getService( ConfigurationService.class );
-		final Properties properties = new Properties();
-		properties.putAll( cfgService.getSettings() );
-
-		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
-
-		this.globalCfg = new GlobalConfiguration( properties, classLoaderService );
-
-		final ReflectionManager reflectionManager = metadata.getMetadataBuildingOptions().getReflectionManager();
-		final RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalCfg );
-		final RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure( metadata, reflectionManager );
-
-		this.auditEntCfg = new AuditEntitiesConfiguration( properties, revInfoCfgResult.getRevisionInfoEntityName() );
-		this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
-		this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
-		this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
-		this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
-		this.auditStrategy = initializeAuditStrategy(
-				auditEntCfg.getAuditStrategyName(),
-				revInfoCfgResult.getRevisionInfoClass(),
-				revInfoCfgResult.getRevisionInfoTimestampData(),
-				classLoaderService
-		);
-		this.entCfg = new EntitiesConfigurator().configure(
-				metadata,
-				serviceRegistry,
-				reflectionManager,
-				mappingCollector,
-				globalCfg,
-				auditEntCfg,
-				auditStrategy,
-				revInfoCfgResult.getRevisionInfoXmlMapping(),
-				revInfoCfgResult.getRevisionInfoRelationMapping()
-		);
-
-	}
-
-
-	public AuditEntitiesConfiguration getAuditEntCfg() {
-		return auditEntCfg;
-	}
-
-	public AuditProcessManager getSyncManager() {
-		return auditProcessManager;
-	}
-
-	public GlobalConfiguration getGlobalCfg() {
-		return globalCfg;
-	}
-
-	public EntitiesConfigurations getEntCfg() {
-		return entCfg;
-	}
-
-	public RevisionInfoQueryCreator getRevisionInfoQueryCreator() {
-		return revisionInfoQueryCreator;
-	}
-
-	public RevisionInfoNumberReader getRevisionInfoNumberReader() {
-		return revisionInfoNumberReader;
-	}
-
-	public ModifiedEntityNamesReader getModifiedEntityNamesReader() {
-		return modifiedEntityNamesReader;
-	}
-
-	public AuditStrategy getAuditStrategy() {
-		return auditStrategy;
-	}
-
-	private static AuditStrategy initializeAuditStrategy(
-			String auditStrategyName,
-			Class<?> revisionInfoClass,
-			PropertyData revisionInfoTimestampData,
-			ClassLoaderService classLoaderService) {
-		AuditStrategy strategy;
-
-		try {
-			Class<?> auditStrategyClass = loadClass( auditStrategyName, classLoaderService );
-			strategy = (AuditStrategy) ReflectHelper.getDefaultConstructor( auditStrategyClass ).newInstance();
-		}
-		catch (Exception e) {
-			throw new MappingException(
-					String.format( "Unable to create AuditStrategy [%s] instance.", auditStrategyName ),
-					e
-			);
-		}
-
-		if ( strategy instanceof ValidityAuditStrategy ) {
-			// further initialization required
-			final Getter revisionTimestampGetter = ReflectionTools.getGetter( revisionInfoClass, revisionInfoTimestampData );
-			( (ValidityAuditStrategy) strategy ).setRevisionTimestampGetter( revisionTimestampGetter );
-		}
-
-		return strategy;
-	}
-
-	/**
-	 * Load a class by name, preferring our ClassLoader and then the ClassLoaderService.
-	 *
-	 * @param auditStrategyName The name of the class to load
-	 * @param classLoaderService The ClassLoaderService
-	 *
-	 * @return The loaded class.
-	 */
-	private static Class<?> loadClass(String auditStrategyName, ClassLoaderService classLoaderService) {
-		try {
-			return AuditConfiguration.class.getClassLoader().loadClass( auditStrategyName );
-		}
-		catch (Exception e) {
-			return ReflectionTools.loadClass( auditStrategyName, classLoaderService );
-		}
-	}
-
-	public void destroy() {
-		// Anything we need to release in here?
-	}
-}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
index 41c90cfda4..75cf80a831 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
@@ -1,161 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class ComponentPropertyMapper implements PropertyMapper, CompositeMapperBuilder {
 	private final PropertyData propertyData;
 	private final MultiPropertyMapper delegate;
 	private final Class componentClass;
 
 	public ComponentPropertyMapper(PropertyData propertyData, Class componentClass) {
 		this.propertyData = propertyData;
 		//if class is a map it means that this is dynamic component
 		if ( Map.class.isAssignableFrom( componentClass ) ) {
 			this.delegate = new MultiDynamicComponentMapper( propertyData );
 			this.componentClass = HashMap.class;
 		}
 		else {
 			this.delegate = new MultiPropertyMapper();
 			this.componentClass = componentClass;
 		}
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		delegate.add( propertyData );
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		return delegate.addComponent( propertyData, componentClass );
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		delegate.addComposite( propertyData, propertyMapper );
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		return delegate.mapToMapFromEntity( session, data, newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put(
 					propertyData.getModifiedFlagPropertyName(),
 					delegate.mapToMapFromEntity( session, new HashMap<String, Object>(), newObj, oldObj )
 			);
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			boolean hasModifiedCollection = false;
 			for ( PropertyData propData : delegate.getProperties().keySet() ) {
 				if ( collectionPropertyName.equals( propData.getName() ) ) {
 					hasModifiedCollection = true;
 					break;
 				}
 			}
 			data.put( propertyData.getModifiedFlagPropertyName(), hasModifiedCollection );
 		}
 	}
 
 	@Override
 	public void mapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		if ( data == null || obj == null ) {
 			return;
 		}
 
 		if ( propertyData.getBeanName() == null ) {
 			// If properties are not encapsulated in a component but placed directly in a class
 			// (e.g. by applying <properties> tag).
 			delegate.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 			return;
 		}
 
-		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData );
+		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData, enversService.getServiceRegistry() );
 
 		// If all properties are null and single, then the component has to be null also.
 		boolean allNullAndSingle = true;
 		for ( Map.Entry<PropertyData, PropertyMapper> property : delegate.getProperties().entrySet() ) {
 			if ( data.get(
 					property.getKey()
 							.getName()
 			) != null || !( property.getValue() instanceof SinglePropertyMapper ) ) {
 				allNullAndSingle = false;
 				break;
 			}
 		}
 
 		if ( allNullAndSingle ) {
 			// single property, but default value need not be null, so we'll set it to null anyway
 			setter.set( obj, null, null );
 		}
 		else {
 			// set the component
 			try {
 				final Object subObj = ReflectHelper.getDefaultConstructor( componentClass ).newInstance();
 				setter.set( obj, subObj, null );
 				delegate.mapToEntityFromMap( enversService, subObj, data, primaryKey, versionsReader, revision );
 			}
 			catch ( Exception e ) {
 				throw new AuditException( e );
 			}
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session, String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		return delegate.mapCollectionChanges( session, referencingPropertyName, newColl, oldColl, id );
 	}
 
 	@Override
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		return delegate.getProperties();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
index e7b8025a5c..d487935189 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
@@ -1,221 +1,221 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.MappingTools;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.envers.tools.Pair;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class MultiPropertyMapper implements ExtendedPropertyMapper {
 	protected final Map<PropertyData, PropertyMapper> properties;
 	private final Map<String, PropertyData> propertyDatas;
 
 	public MultiPropertyMapper() {
 		properties = Tools.newHashMap();
 		propertyDatas = Tools.newHashMap();
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		final SinglePropertyMapper single = new SinglePropertyMapper();
 		single.add( propertyData );
 		properties.put( propertyData, single );
 		propertyDatas.put( propertyData.getName(), propertyData );
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		if ( properties.get( propertyData ) != null ) {
 			// This is needed for second pass to work properly in the components mapper
 			return (CompositeMapperBuilder) properties.get( propertyData );
 		}
 
 		final ComponentPropertyMapper componentMapperBuilder = new ComponentPropertyMapper(
 				propertyData,
 				componentClass
 		);
 		addComposite( propertyData, componentMapperBuilder );
 
 		return componentMapperBuilder;
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		properties.put( propertyData, propertyMapper );
 		propertyDatas.put( propertyData.getName(), propertyData );
 	}
 
 	protected Object getAtIndexOrNull(Object[] array, int index) {
 		return array == null ? null : array[index];
 	}
 
 	@Override
 	public boolean map(
 			SessionImplementor session,
 			Map<String, Object> data,
 			String[] propertyNames,
 			Object[] newState,
 			Object[] oldState) {
 		boolean ret = false;
 		for ( int i = 0; i < propertyNames.length; i++ ) {
 			final String propertyName = propertyNames[i];
 
 			if ( propertyDatas.containsKey( propertyName ) ) {
 				final PropertyMapper propertyMapper = properties.get( propertyDatas.get( propertyName ) );
 				final Object newObj = getAtIndexOrNull( newState, i );
 				final Object oldObj = getAtIndexOrNull( oldState, i );
 				ret |= propertyMapper.mapToMapFromEntity( session, data, newObj, oldObj );
 				propertyMapper.mapModifiedFlagsToMapFromEntity( session, data, newObj, oldObj );
 			}
 		}
 
 		return ret;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		boolean ret = false;
 		for ( PropertyData propertyData : properties.keySet() ) {
 			Getter getter;
 			if ( newObj != null ) {
-				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData );
+				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData, session.getFactory().getServiceRegistry() );
 			}
 			else if ( oldObj != null ) {
-				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData );
+				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData, session.getFactory().getServiceRegistry() );
 			}
 			else {
 				return false;
 			}
 
 			ret |= properties.get( propertyData ).mapToMapFromEntity(
 					session, data,
 					newObj == null ? null : getter.get( newObj ),
 					oldObj == null ? null : getter.get( oldObj )
 			);
 		}
 
 		return ret;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		for ( PropertyData propertyData : properties.keySet() ) {
 			Getter getter;
 			if ( newObj != null ) {
-				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData );
+				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData, session.getFactory().getServiceRegistry() );
 			}
 			else if ( oldObj != null ) {
-				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData );
+				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData, session.getFactory().getServiceRegistry() );
 			}
 			else {
 				return;
 			}
 
 			properties.get( propertyData ).mapModifiedFlagsToMapFromEntity(
 					session, data,
 					newObj == null ? null : getter.get( newObj ),
 					oldObj == null ? null : getter.get( oldObj )
 			);
 		}
 	}
 
 	@Override
 	public void mapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		for ( PropertyMapper mapper : properties.values() ) {
 			mapper.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 		}
 	}
 
 	private Pair<PropertyMapper, String> getMapperAndDelegatePropName(String referencingPropertyName) {
 		// Name of the property, to which we will delegate the mapping.
 		String delegatePropertyName;
 
 		// Checking if the property name doesn't reference a collection in a component - then the name will containa a .
 		final int dotIndex = referencingPropertyName.indexOf( '.' );
 		if ( dotIndex != -1 ) {
 			// Computing the name of the component
 			final String componentName = referencingPropertyName.substring( 0, dotIndex );
 			// And the name of the property in the component
 			final String propertyInComponentName = MappingTools.createComponentPrefix( componentName )
 					+ referencingPropertyName.substring( dotIndex + 1 );
 
 			// We need to get the mapper for the component.
 			referencingPropertyName = componentName;
 			// As this is a component, we delegate to the property in the component.
 			delegatePropertyName = propertyInComponentName;
 		}
 		else {
 			// If this is not a component, we delegate to the same property.
 			delegatePropertyName = referencingPropertyName;
 		}
 		return Pair.make( properties.get( propertyDatas.get( referencingPropertyName ) ), delegatePropertyName );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		final Pair<PropertyMapper, String> pair = getMapperAndDelegatePropName( collectionPropertyName );
 		final PropertyMapper mapper = pair.getFirst();
 		if ( mapper != null ) {
 			mapper.mapModifiedFlagsToMapForCollectionChange( pair.getSecond(), data );
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		final Pair<PropertyMapper, String> pair = getMapperAndDelegatePropName( referencingPropertyName );
 		final PropertyMapper mapper = pair.getFirst();
 		if ( mapper != null ) {
 			return mapper.mapCollectionChanges( session, pair.getSecond(), newColl, oldColl, id );
 		}
 		else {
 			return null;
 		}
 	}
 
 	@Override
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		return properties;
 	}
 
 	public Map<String, PropertyData> getPropertyDatas() {
 		return propertyDatas;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
index edf121a4e8..cba8f0e182 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.envers.internal.tools.Tools;
-import org.hibernate.property.DirectPropertyAccessor;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.property.access.spi.SetterFieldImpl;
 
 /**
  * TODO: diff
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class SinglePropertyMapper implements PropertyMapper, SimpleMapperBuilder {
 	private PropertyData propertyData;
 
 	public SinglePropertyMapper(PropertyData propertyData) {
 		this.propertyData = propertyData;
 	}
 
 	public SinglePropertyMapper() {
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		if ( this.propertyData != null ) {
 			throw new AuditException( "Only one property can be added!" );
 		}
 
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		data.put( propertyData.getName(), newObj );
 		boolean dbLogicallyDifferent = true;
 		if ( (session.getFactory()
 				.getDialect() instanceof Oracle8iDialect) && (newObj instanceof String || oldObj instanceof String) ) {
 			// Don't generate new revision when database replaces empty string with NULL during INSERT or UPDATE statements.
 			dbLogicallyDifferent = !(StringTools.isEmpty( newObj ) && StringTools.isEmpty( oldObj ));
 		}
 		return dbLogicallyDifferent && !Tools.objectsEqual( newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put( propertyData.getModifiedFlagPropertyName(), !Tools.objectsEqual( newObj, oldObj ) );
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 	}
 
 	@Override
 	public void mapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		if ( data == null || obj == null ) {
 			return;
 		}
 
-		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData );
+		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData, enversService.getServiceRegistry() );
 		final Object value = data.get( propertyData.getName() );
 		// We only set a null value if the field is not primite. Otherwise, we leave it intact.
 		if ( value != null || !isPrimitive( setter, propertyData, obj.getClass() ) ) {
 			setter.set( obj, value, null );
 		}
 	}
 
 	private boolean isPrimitive(Setter setter, PropertyData propertyData, Class<?> cls) {
 		if ( cls == null ) {
 			throw new HibernateException( "No field found for property: " + propertyData.getName() );
 		}
 
-		if ( setter instanceof DirectPropertyAccessor.DirectSetter ) {
+		if ( setter instanceof SetterFieldImpl ) {
 			// In a direct setter, getMethod() returns null
 			// Trying to look up the field
 			try {
 				return cls.getDeclaredField( propertyData.getBeanName() ).getType().isPrimitive();
 			}
 			catch (NoSuchFieldException e) {
 				return isPrimitive( setter, propertyData, cls.getSuperclass() );
 			}
 		}
 		else {
 			return setter.getMethod().getParameterTypes()[0].isPrimitive();
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor sessionImplementor,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			Serializable id) {
 		return null;
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractCompositeIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractCompositeIdMapper.java
index 28d10588e4..4ff69fd667 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractCompositeIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractCompositeIdMapper.java
@@ -1,56 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.Map;
 
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractCompositeIdMapper extends AbstractIdMapper implements SimpleIdMapperBuilder {
+	protected final Class compositeIdClass;
+
 	protected Map<PropertyData, SingleIdMapper> ids;
-	protected Class compositeIdClass;
 
-	protected AbstractCompositeIdMapper(Class compositeIdClass) {
-		ids = Tools.newLinkedHashMap();
+	protected AbstractCompositeIdMapper(Class compositeIdClass, ServiceRegistry serviceRegistry) {
+		super( serviceRegistry );
 		this.compositeIdClass = compositeIdClass;
+		ids = Tools.newLinkedHashMap();
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
-		ids.put( propertyData, new SingleIdMapper( propertyData ) );
+		ids.put( propertyData, new SingleIdMapper( getServiceRegistry(), propertyData ) );
 	}
 
 	@Override
 	public Object mapToIdFromMap(Map data) {
 		if ( data == null ) {
 			return null;
 		}
 
 		final Object ret;
 		try {
 			ret = ReflectHelper.getDefaultConstructor( compositeIdClass ).newInstance();
 		}
 		catch (Exception e) {
 			throw new AuditException( e );
 		}
 
 		for ( SingleIdMapper mapper : ids.values() ) {
 			if ( !mapper.mapToEntityFromMap( ret, data ) ) {
 				return null;
 			}
 		}
 
 		return ret;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractIdMapper.java
index 3bd9536582..fcd338d684 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/AbstractIdMapper.java
@@ -1,110 +1,122 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.envers.internal.tools.query.Parameters;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public abstract class AbstractIdMapper implements IdMapper {
+	private final ServiceRegistry serviceRegistry;
+
+	public AbstractIdMapper(ServiceRegistry serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
+	}
+
+	@Override
+	public ServiceRegistry getServiceRegistry() {
+		return serviceRegistry;
+	}
+
 	private Parameters getParametersToUse(Parameters parameters, List<QueryParameterData> paramDatas) {
 		if ( paramDatas.size() > 1 ) {
 			return parameters.addSubParameters( "and" );
 		}
 		else {
 			return parameters;
 		}
 	}
 
 	@Override
 	public void addIdsEqualToQuery(Parameters parameters, String prefix1, String prefix2) {
 		final List<QueryParameterData> paramDatas = mapToQueryParametersFromId( null );
 
 		final Parameters parametersToUse = getParametersToUse( parameters, paramDatas );
 
 		for ( QueryParameterData paramData : paramDatas ) {
 			parametersToUse.addWhere(
 					paramData.getProperty( prefix1 ),
 					false,
 					"=",
 					paramData.getProperty( prefix2 ),
 					false
 			);
 		}
 	}
 
 	@Override
 	public void addIdsEqualToQuery(Parameters parameters, String prefix1, IdMapper mapper2, String prefix2) {
 		final List<QueryParameterData> paramDatas1 = mapToQueryParametersFromId( null );
 		final List<QueryParameterData> paramDatas2 = mapper2.mapToQueryParametersFromId( null );
 
 		final Parameters parametersToUse = getParametersToUse( parameters, paramDatas1 );
 
 		final Iterator<QueryParameterData> paramDataIter1 = paramDatas1.iterator();
 		final Iterator<QueryParameterData> paramDataIter2 = paramDatas2.iterator();
 		while ( paramDataIter1.hasNext() ) {
 			final QueryParameterData paramData1 = paramDataIter1.next();
 			final QueryParameterData paramData2 = paramDataIter2.next();
 
 			parametersToUse.addWhere(
 					paramData1.getProperty( prefix1 ),
 					false,
 					"=",
 					paramData2.getProperty( prefix2 ),
 					false
 			);
 		}
 	}
 
 	@Override
 	public void addIdEqualsToQuery(Parameters parameters, Object id, String prefix, boolean equals) {
 		final List<QueryParameterData> paramDatas = mapToQueryParametersFromId( id );
 
 		final Parameters parametersToUse = getParametersToUse( parameters, paramDatas );
 
 		for ( QueryParameterData paramData : paramDatas ) {
 			if ( paramData.getValue() == null ) {
 				handleNullValue( parametersToUse, paramData.getProperty( prefix ), equals );
 			}
 			else {
 				parametersToUse.addWhereWithParam(
 						paramData.getProperty( prefix ),
 						equals ? "=" : "<>",
 						paramData.getValue()
 				);
 			}
 		}
 	}
 
 	@Override
 	public void addNamedIdEqualsToQuery(Parameters parameters, String prefix, boolean equals) {
 		final List<QueryParameterData> paramDatas = mapToQueryParametersFromId( null );
 
 		final Parameters parametersToUse = getParametersToUse( parameters, paramDatas );
 
 		for ( QueryParameterData paramData : paramDatas ) {
 			parametersToUse.addWhereWithNamedParam(
 					paramData.getProperty( prefix ),
 					equals ? "=" : "<>",
 					paramData.getQueryParameterName()
 			);
 		}
 	}
 
 	private void handleNullValue(Parameters parameters, String propertyName, boolean equals) {
 		if ( equals ) {
 			parameters.addNullRestriction( propertyName, equals );
 		}
 		else {
 			parameters.addNotNullRestriction( propertyName, equals );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/EmbeddedIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/EmbeddedIdMapper.java
index 53f3890765..3429917dc6 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/EmbeddedIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/EmbeddedIdMapper.java
@@ -1,113 +1,114 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class EmbeddedIdMapper extends AbstractCompositeIdMapper implements SimpleIdMapperBuilder {
 	private PropertyData idPropertyData;
 
-	public EmbeddedIdMapper(PropertyData idPropertyData, Class compositeIdClass) {
-		super( compositeIdClass );
+	public EmbeddedIdMapper(PropertyData idPropertyData, Class compositeIdClass, ServiceRegistry serviceRegistry) {
+		super( compositeIdClass, serviceRegistry );
 
 		this.idPropertyData = idPropertyData;
 	}
 
 	@Override
 	public void mapToMapFromId(Map<String, Object> data, Object obj) {
 		for ( IdMapper idMapper : ids.values() ) {
 			idMapper.mapToMapFromEntity( data, obj );
 		}
 	}
 
 	@Override
 	public void mapToMapFromEntity(Map<String, Object> data, Object obj) {
 		if ( obj == null ) {
 			return;
 		}
 
-		final Getter getter = ReflectionTools.getGetter( obj.getClass(), idPropertyData );
+		final Getter getter = ReflectionTools.getGetter( obj.getClass(), idPropertyData, getServiceRegistry() );
 		mapToMapFromId( data, getter.get( obj ) );
 	}
 
 	@Override
 	public boolean mapToEntityFromMap(Object obj, Map data) {
 		if ( data == null || obj == null ) {
 			return false;
 		}
 
-		final Getter getter = ReflectionTools.getGetter( obj.getClass(), idPropertyData );
-		final Setter setter = ReflectionTools.getSetter( obj.getClass(), idPropertyData );
+		final Getter getter = ReflectionTools.getGetter( obj.getClass(), idPropertyData, getServiceRegistry() );
+		final Setter setter = ReflectionTools.getSetter( obj.getClass(), idPropertyData, getServiceRegistry() );
 
 		try {
 			final Object subObj = ReflectHelper.getDefaultConstructor( getter.getReturnType() ).newInstance();
 
 			boolean ret = true;
 			for ( IdMapper idMapper : ids.values() ) {
 				ret &= idMapper.mapToEntityFromMap( subObj, data );
 			}
 
 			if ( ret ) {
 				setter.set( obj, subObj, null );
 			}
 
 			return ret;
 		}
 		catch (Exception e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	public IdMapper prefixMappedProperties(String prefix) {
-		final EmbeddedIdMapper ret = new EmbeddedIdMapper( idPropertyData, compositeIdClass );
+		final EmbeddedIdMapper ret = new EmbeddedIdMapper( idPropertyData, compositeIdClass, getServiceRegistry() );
 
 		for ( PropertyData propertyData : ids.keySet() ) {
 			final String propertyName = propertyData.getName();
-			ret.ids.put( propertyData, new SingleIdMapper( new PropertyData( prefix + propertyName, propertyData ) ) );
+			ret.ids.put( propertyData, new SingleIdMapper( getServiceRegistry(), new PropertyData( prefix + propertyName, propertyData ) ) );
 		}
 
 		return ret;
 	}
 
 	@Override
 	public Object mapToIdFromEntity(Object data) {
 		if ( data == null ) {
 			return null;
 		}
 
-		final Getter getter = ReflectionTools.getGetter( data.getClass(), idPropertyData );
+		final Getter getter = ReflectionTools.getGetter( data.getClass(), idPropertyData, getServiceRegistry() );
 		return getter.get( data );
 	}
 
 	@Override
 	public List<QueryParameterData> mapToQueryParametersFromId(Object obj) {
 		final Map<String, Object> data = new LinkedHashMap<String, Object>();
 		mapToMapFromId( data, obj );
 
 		final List<QueryParameterData> ret = new ArrayList<QueryParameterData>();
 
 		for ( Map.Entry<String, Object> propertyData : data.entrySet() ) {
 			ret.add( new QueryParameterData( propertyData.getKey(), propertyData.getValue() ) );
 		}
 
 		return ret;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/IdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/IdMapper.java
index ac69f6a5d2..0cb6ea0bbe 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/IdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/IdMapper.java
@@ -1,95 +1,98 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.internal.tools.query.Parameters;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public interface IdMapper {
+	ServiceRegistry getServiceRegistry();
+
 	void mapToMapFromId(Map<String, Object> data, Object obj);
 
 	void mapToMapFromEntity(Map<String, Object> data, Object obj);
 
 	/**
 	 * @param obj Object to map to.
 	 * @param data Data to map.
 	 *
 	 * @return True if data was mapped; false otherwise (when the id is {@code null}).
 	 */
 	boolean mapToEntityFromMap(Object obj, Map data);
 
 	Object mapToIdFromEntity(Object data);
 
 	Object mapToIdFromMap(Map data);
 
 	/**
 	 * Creates a mapper with all mapped properties prefixed. A mapped property is a property which
 	 * is directly mapped to values (not composite).
 	 *
 	 * @param prefix Prefix to add to mapped properties
 	 *
 	 * @return A copy of the current property mapper, with mapped properties prefixed.
 	 */
 	IdMapper prefixMappedProperties(String prefix);
 
 	/**
 	 * @param obj Id from which to map.
 	 *
 	 * @return A set parameter data, needed to build a query basing on the given id.
 	 */
 	List<QueryParameterData> mapToQueryParametersFromId(Object obj);
 
 	/**
 	 * Adds query statements, which contains restrictions, which express the property that the id of the entity
 	 * with alias prefix1, is equal to the id of the entity with alias prefix2 (the entity is the same).
 	 *
 	 * @param parameters Parameters, to which to add the statements.
 	 * @param prefix1 First alias of the entity + prefix to add to the properties.
 	 * @param prefix2 Second alias of the entity + prefix to add to the properties.
 	 */
 	void addIdsEqualToQuery(Parameters parameters, String prefix1, String prefix2);
 
 	/**
 	 * Adds query statements, which contains restrictions, which express the property that the id of the entity
 	 * with alias prefix1, is equal to the id of the entity with alias prefix2 mapped by the second mapper
 	 * (the second mapper must be for the same entity, but it can have, for example, prefixed properties).
 	 *
 	 * @param parameters Parameters, to which to add the statements.
 	 * @param prefix1 First alias of the entity + prefix to add to the properties.
 	 * @param mapper2 Second mapper for the same entity, which will be used to get properties for the right side
 	 * of the equation.
 	 * @param prefix2 Second alias of the entity + prefix to add to the properties.
 	 */
 	void addIdsEqualToQuery(Parameters parameters, String prefix1, IdMapper mapper2, String prefix2);
 
 	/**
 	 * Adds query statements, which contains restrictions, which express the property that the id of the entity
 	 * with alias prefix, is equal to the given object.
 	 *
 	 * @param parameters Parameters, to which to add the statements.
 	 * @param id Value of id.
 	 * @param prefix Prefix to add to the properties (may be null).
 	 * @param equals Should this query express the "=" relation or the "<>" relation.
 	 */
 	void addIdEqualsToQuery(Parameters parameters, Object id, String prefix, boolean equals);
 
 	/**
 	 * Adds query statements, which contains named parameters, which express the property that the id of the entity
 	 * with alias prefix, is equal to the given object. It is the responsibility of the using method to read
 	 * parameter values from the id and specify them on the final query object.
 	 *
 	 * @param parameters Parameters, to which to add the statements.
 	 * @param prefix Prefix to add to the properties (may be null).
 	 * @param equals Should this query express the "=" relation or the "<>" relation.
 	 */
 	void addNamedIdEqualsToQuery(Parameters parameters, String prefix, boolean equals);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/MultipleIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/MultipleIdMapper.java
index b26677dddd..b77a832d14 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/MultipleIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/MultipleIdMapper.java
@@ -1,94 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class MultipleIdMapper extends AbstractCompositeIdMapper implements SimpleIdMapperBuilder {
-	public MultipleIdMapper(Class compositeIdClass) {
-		super( compositeIdClass );
+	public MultipleIdMapper(Class compositeIdClass, ServiceRegistry serviceRegistry) {
+		super( compositeIdClass, serviceRegistry );
 	}
 
 	@Override
 	public void mapToMapFromId(Map<String, Object> data, Object obj) {
 		for ( IdMapper idMapper : ids.values() ) {
 			idMapper.mapToMapFromEntity( data, obj );
 		}
 	}
 
 	@Override
 	public void mapToMapFromEntity(Map<String, Object> data, Object obj) {
 		mapToMapFromId( data, obj );
 	}
 
 	@Override
 	public boolean mapToEntityFromMap(Object obj, Map data) {
 		boolean ret = true;
 		for ( IdMapper idMapper : ids.values() ) {
 			ret &= idMapper.mapToEntityFromMap( obj, data );
 		}
 
 		return ret;
 	}
 
 	@Override
 	public IdMapper prefixMappedProperties(String prefix) {
-		final MultipleIdMapper ret = new MultipleIdMapper( compositeIdClass );
+		final MultipleIdMapper ret = new MultipleIdMapper( compositeIdClass, getServiceRegistry() );
 
 		for ( PropertyData propertyData : ids.keySet() ) {
 			final String propertyName = propertyData.getName();
-			ret.ids.put( propertyData, new SingleIdMapper( new PropertyData( prefix + propertyName, propertyData ) ) );
+			ret.ids.put( propertyData, new SingleIdMapper( getServiceRegistry(), new PropertyData( prefix + propertyName, propertyData ) ) );
 		}
 
 		return ret;
 	}
 
 	@Override
 	public Object mapToIdFromEntity(Object data) {
 		if ( data == null ) {
 			return null;
 		}
 
 		final Object ret;
 		try {
 			ret = ReflectHelper.getDefaultConstructor( compositeIdClass ).newInstance();
 		}
 		catch (Exception e) {
 			throw new AuditException( e );
 		}
 
 		for ( SingleIdMapper mapper : ids.values() ) {
 			mapper.mapToEntityFromEntity( ret, data );
 		}
 
 		return ret;
 	}
 
 	@Override
 	public List<QueryParameterData> mapToQueryParametersFromId(Object obj) {
 		final Map<String, Object> data = new LinkedHashMap<String, Object>();
 		mapToMapFromId( data, obj );
 
 		final List<QueryParameterData> ret = new ArrayList<QueryParameterData>();
 
 		for ( Map.Entry<String, Object> propertyData : data.entrySet() ) {
 			ret.add( new QueryParameterData( propertyData.getKey(), propertyData.getValue() ) );
 		}
 
 		return ret;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/SingleIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/SingleIdMapper.java
index c64750156b..b3f321bfac 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/SingleIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/id/SingleIdMapper.java
@@ -1,131 +1,134 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.id;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 import org.hibernate.proxy.HibernateProxy;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class SingleIdMapper extends AbstractIdMapper implements SimpleIdMapperBuilder {
 	private PropertyData propertyData;
 
-	public SingleIdMapper() {
+	public SingleIdMapper(ServiceRegistry serviceRegistry) {
+		super( serviceRegistry );
 	}
 
-	public SingleIdMapper(PropertyData propertyData) {
+	public SingleIdMapper(ServiceRegistry serviceRegistry, PropertyData propertyData) {
+		this( serviceRegistry );
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		if ( this.propertyData != null ) {
 			throw new AuditException( "Only one property can be added!" );
 		}
 
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public boolean mapToEntityFromMap(Object obj, Map data) {
 		if ( data == null || obj == null ) {
 			return false;
 		}
 
 		final Object value = data.get( propertyData.getName() );
 		if ( value == null ) {
 			return false;
 		}
 
-		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData );
+		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData, getServiceRegistry() );
 		setter.set( obj, value, null );
 
 		return true;
 	}
 
 	@Override
 	public Object mapToIdFromMap(Map data) {
 		if ( data == null ) {
 			return null;
 		}
 
 		return data.get( propertyData.getName() );
 	}
 
 	@Override
 	public Object mapToIdFromEntity(Object data) {
 		if ( data == null ) {
 			return null;
 		}
 
 		if ( data instanceof HibernateProxy ) {
 			final HibernateProxy hibernateProxy = (HibernateProxy) data;
 			return hibernateProxy.getHibernateLazyInitializer().getIdentifier();
 		}
 		else {
-			final Getter getter = ReflectionTools.getGetter( data.getClass(), propertyData );
+			final Getter getter = ReflectionTools.getGetter( data.getClass(), propertyData, getServiceRegistry() );
 			return getter.get( data );
 		}
 	}
 
 	@Override
 	public void mapToMapFromId(Map<String, Object> data, Object obj) {
 		if ( data != null ) {
 			data.put( propertyData.getName(), obj );
 		}
 	}
 
 	@Override
 	public void mapToMapFromEntity(Map<String, Object> data, Object obj) {
 		if ( obj == null ) {
 			data.put( propertyData.getName(), null );
 		}
 		else {
 			if ( obj instanceof HibernateProxy ) {
 				final HibernateProxy hibernateProxy = (HibernateProxy) obj;
 				data.put( propertyData.getName(), hibernateProxy.getHibernateLazyInitializer().getIdentifier() );
 			}
 			else {
-				final Getter getter = ReflectionTools.getGetter( obj.getClass(), propertyData );
+				final Getter getter = ReflectionTools.getGetter( obj.getClass(), propertyData, getServiceRegistry() );
 				data.put( propertyData.getName(), getter.get( obj ) );
 			}
 		}
 	}
 
 	public void mapToEntityFromEntity(Object objTo, Object objFrom) {
 		if ( objTo == null || objFrom == null ) {
 			return;
 		}
 
-		final Getter getter = ReflectionTools.getGetter( objFrom.getClass(), propertyData );
-		final Setter setter = ReflectionTools.getSetter( objTo.getClass(), propertyData );
+		final Getter getter = ReflectionTools.getGetter( objFrom.getClass(), propertyData, getServiceRegistry() );
+		final Setter setter = ReflectionTools.getSetter( objTo.getClass(), propertyData, getServiceRegistry() );
 		setter.set( objTo, getter.get( objFrom ), null );
 	}
 
 	@Override
 	public IdMapper prefixMappedProperties(String prefix) {
-		return new SingleIdMapper( new PropertyData( prefix + propertyData.getName(), propertyData ) );
+		return new SingleIdMapper( getServiceRegistry(), new PropertyData( prefix + propertyData.getName(), propertyData ) );
 	}
 
 	@Override
 	public List<QueryParameterData> mapToQueryParametersFromId(Object obj) {
 		final List<QueryParameterData> ret = new ArrayList<QueryParameterData>();
 
 		ret.add( new QueryParameterData( propertyData.getName(), obj ) );
 
 		return ret;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
index 532314f295..b233340fd7 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
@@ -1,279 +1,280 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.Tools;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public abstract class AbstractCollectionMapper<T> implements PropertyMapper {
 	protected final CommonCollectionMapperData commonCollectionMapperData;
 	protected final Class<? extends T> collectionClass;
 	protected final boolean ordinalInId;
 	protected final boolean revisionTypeInId;
 
 	private final Constructor<? extends T> proxyConstructor;
 
 	protected AbstractCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			Class<? extends T> collectionClass, Class<? extends T> proxyClass, boolean ordinalInId,
 			boolean revisionTypeInId) {
 		this.commonCollectionMapperData = commonCollectionMapperData;
 		this.collectionClass = collectionClass;
 		this.ordinalInId = ordinalInId;
 		this.revisionTypeInId = revisionTypeInId;
 
 		try {
 			proxyConstructor = proxyClass.getConstructor( Initializor.class );
 		}
 		catch (NoSuchMethodException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	protected abstract Collection getNewCollectionContent(PersistentCollection newCollection);
 
 	protected abstract Collection getOldCollectionContent(Serializable oldCollection);
 
 	/**
 	 * Maps the changed collection element to the given map.
 	 *
 	 * @param idData Map to which composite-id data should be added.
 	 * @param data Where to map the data.
 	 * @param changed The changed collection element to map.
 	 */
 	protected abstract void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object changed);
 
 	/**
 	 * Creates map for storing identifier data. Ordinal parameter guarantees uniqueness of primary key.
 	 * Composite primary key cannot contain embeddable properties since they might be nullable.
 	 *
 	 * @param ordinal Iteration ordinal.
 	 *
 	 * @return Map for holding identifier data.
 	 */
 	protected Map<String, Object> createIdMap(int ordinal) {
 		final Map<String, Object> idMap = new HashMap<String, Object>();
 		if ( ordinalInId ) {
 			idMap.put( commonCollectionMapperData.getVerEntCfg().getEmbeddableSetOrdinalPropertyName(), ordinal );
 		}
 		return idMap;
 	}
 
 	private void addCollectionChanges(
 			SessionImplementor session, List<PersistentCollectionChangeData> collectionChanges,
 			Set<Object> changed, RevisionType revisionType, Serializable id) {
 		int ordinal = 0;
 
 		for ( Object changedObj : changed ) {
 			final Map<String, Object> entityData = new HashMap<String, Object>();
 			final Map<String, Object> originalId = createIdMap( ordinal++ );
 			entityData.put( commonCollectionMapperData.getVerEntCfg().getOriginalIdPropName(), originalId );
 
 			collectionChanges.add(
 					new PersistentCollectionChangeData(
 							commonCollectionMapperData.getVersionsMiddleEntityName(), entityData, changedObj
 					)
 			);
 			// Mapping the collection owner's id.
 			commonCollectionMapperData.getReferencingIdData().getPrefixedMapper().mapToMapFromId( originalId, id );
 
 			// Mapping collection element and index (if present).
 			mapToMapFromObject( session, originalId, entityData, changedObj );
 
 			(revisionTypeInId ? originalId : entityData).put(
 					commonCollectionMapperData.getVerEntCfg()
 							.getRevisionTypePropName(), revisionType
 			);
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		if ( !commonCollectionMapperData.getCollectionReferencingPropertyData().getName().equals(
 				referencingPropertyName
 		) ) {
 			return null;
 		}
 
 		final List<PersistentCollectionChangeData> collectionChanges = new ArrayList<PersistentCollectionChangeData>();
 
 		// Comparing new and old collection content.
 		final Collection newCollection = getNewCollectionContent( newColl );
 		final Collection oldCollection = getOldCollectionContent( oldColl );
 
 		final Set<Object> added = new HashSet<Object>();
 		if ( newColl != null ) {
 			added.addAll( newCollection );
 		}
 		// Re-hashing the old collection as the hash codes of the elements there may have changed, and the
 		// removeAll in AbstractSet has an implementation that is hashcode-change sensitive (as opposed to addAll).
 		if ( oldColl != null ) {
 			added.removeAll( new HashSet( oldCollection ) );
 		}
 
 		addCollectionChanges( session, collectionChanges, added, RevisionType.ADD, id );
 
 		final Set<Object> deleted = new HashSet<Object>();
 		if ( oldColl != null ) {
 			deleted.addAll( oldCollection );
 		}
 		// The same as above - re-hashing new collection.
 		if ( newColl != null ) {
 			deleted.removeAll( new HashSet( newCollection ) );
 		}
 
 		addCollectionChanges( session, collectionChanges, deleted, RevisionType.DEL, id );
 
 		return collectionChanges;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		// Changes are mapped in the "mapCollectionChanges" method.
 		return false;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		final PropertyData propertyData = commonCollectionMapperData.getCollectionReferencingPropertyData();
 		if ( propertyData.isUsingModifiedFlag() ) {
 			if ( isNotPersistentCollection( newObj ) || isNotPersistentCollection( oldObj ) ) {
 				// Compare POJOs.
 				data.put( propertyData.getModifiedFlagPropertyName(), !Tools.objectsEqual( newObj, oldObj ) );
 			}
 			else if ( isFromNullToEmptyOrFromEmptyToNull( (PersistentCollection) newObj, (Serializable) oldObj ) ) {
 				data.put( propertyData.getModifiedFlagPropertyName(), true );
 			}
 			else {
 				final List<PersistentCollectionChangeData> changes = mapCollectionChanges(
 						session,
 						commonCollectionMapperData.getCollectionReferencingPropertyData().getName(),
 						(PersistentCollection) newObj,
 						(Serializable) oldObj,
 						null
 				);
 				data.put( propertyData.getModifiedFlagPropertyName(), !changes.isEmpty() );
 			}
 		}
 	}
 
 	private boolean isNotPersistentCollection(Object obj) {
 		return obj != null && !(obj instanceof PersistentCollection);
 	}
 
 	private boolean isFromNullToEmptyOrFromEmptyToNull(PersistentCollection newColl, Serializable oldColl) {
 		// Comparing new and old collection content.
 		final Collection newCollection = getNewCollectionContent( newColl );
 		final Collection oldCollection = getOldCollectionContent( oldColl );
 
 		return oldCollection == null && newCollection != null && newCollection.isEmpty()
 				|| newCollection == null && oldCollection != null && oldCollection.isEmpty();
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		final PropertyData propertyData = commonCollectionMapperData.getCollectionReferencingPropertyData();
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put(
 					propertyData.getModifiedFlagPropertyName(),
 					propertyData.getName().equals( collectionPropertyName )
 			);
 		}
 	}
 
 	protected abstract Initializor<T> getInitializor(
 			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			Object primaryKey,
 			Number revision,
 			boolean removed);
 
 	@Override
 	public void mapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		final Setter setter = ReflectionTools.getSetter(
 				obj.getClass(),
-				commonCollectionMapperData.getCollectionReferencingPropertyData()
+				commonCollectionMapperData.getCollectionReferencingPropertyData(),
+				enversService.getServiceRegistry()
 		);
 		try {
 			setter.set(
 					obj,
 					proxyConstructor.newInstance(
 							getInitializor(
 									enversService,
 									versionsReader,
 									primaryKey,
 									revision,
 									RevisionType.DEL.equals(
 											data.get(
 													enversService.getAuditEntitiesConfiguration().getRevisionTypePropName()
 											)
 									)
 							)
 					),
 					null
 			);
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
index e48c117a9f..028cc0b7f7 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
@@ -1,91 +1,96 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.Map;
 import javax.persistence.NoResultException;
 
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Template class for property mappers that manage one-to-one relation.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractOneToOneMapper extends AbstractToOneMapper {
 	private final String entityName;
 	private final String referencedEntityName;
 
-	protected AbstractOneToOneMapper(String entityName, String referencedEntityName, PropertyData propertyData) {
-		super( propertyData );
+	protected AbstractOneToOneMapper(
+			String entityName,
+			String referencedEntityName,
+			PropertyData propertyData,
+			ServiceRegistry serviceRegistry) {
+		super( serviceRegistry, propertyData );
 		this.entityName = entityName;
 		this.referencedEntityName = referencedEntityName;
 	}
 
 	@Override
 	public void nullSafeMapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		final EntityInfo referencedEntity = getEntityInfo( enversService, referencedEntityName );
 
 		Object value;
 		try {
 			value = queryForReferencedEntity( versionsReader, referencedEntity, (Serializable) primaryKey, revision );
 		}
 		catch (NoResultException e) {
 			value = null;
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException(
 					"Many versions results for one-to-one relationship " + entityName +
 							"." + getPropertyData().getBeanName() + ".", e
 			);
 		}
 
 		setPropertyValue( obj, value );
 	}
 
 	/**
 	 * @param versionsReader Audit reader.
 	 * @param referencedEntity Referenced entity descriptor.
 	 * @param primaryKey Referenced entity identifier.
 	 * @param revision Revision number.
 	 *
 	 * @return Referenced object or proxy of one-to-one relation.
 	 */
 	protected abstract Object queryForReferencedEntity(
 			AuditReaderImplementor versionsReader, EntityInfo referencedEntity,
 			Serializable primaryKey, Number revision);
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put(
 					getPropertyData().getModifiedFlagPropertyName(),
 					collectionPropertyName.equals( getPropertyData().getName() )
 			);
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
index 965f7572dc..86576811d9 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
@@ -1,135 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Base class for property mappers that manage to-one relation.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractToOneMapper implements PropertyMapper {
+	private final ServiceRegistry serviceRegistry;
 	private final PropertyData propertyData;
 
-	protected AbstractToOneMapper(PropertyData propertyData) {
+	protected AbstractToOneMapper(ServiceRegistry serviceRegistry, PropertyData propertyData) {
+		this.serviceRegistry = serviceRegistry;
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		return false;
 	}
 
 	@Override
 	public void mapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		if ( obj != null ) {
 			nullSafeMapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			Serializable id) {
 		return null;
 	}
 
 	/**
 	 * @param enversService The EnversService
 	 * @param entityName Entity name.
 	 *
 	 * @return Entity class, name and information whether it is audited or not.
 	 */
 	protected EntityInfo getEntityInfo(EnversService enversService, String entityName) {
 		EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );
 		boolean isRelationAudited = true;
 		if ( entCfg == null ) {
 			// a relation marked as RelationTargetAuditMode.NOT_AUDITED
 			entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );
 			isRelationAudited = false;
 		}
 		final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );
 		return new EntityInfo( entityClass, entityName, isRelationAudited );
 	}
 
 	protected void setPropertyValue(Object targetObject, Object value) {
-		final Setter setter = ReflectionTools.getSetter( targetObject.getClass(), propertyData );
+		final Setter setter = ReflectionTools.getSetter( targetObject.getClass(), propertyData, serviceRegistry );
 		setter.set( targetObject, value, null );
 	}
 
 	/**
 	 * @return Bean property that represents the relation.
 	 */
 	protected PropertyData getPropertyData() {
 		return propertyData;
 	}
 
 	/**
 	 * Parameter {@code obj} is never {@code null}.
 	 */
 	public abstract void nullSafeMapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision);
 
 	/**
 	 * Simple descriptor of an entity.
 	 */
 	protected class EntityInfo {
 		private final Class entityClass;
 		private final String entityName;
 		private final boolean audited;
 
 		public EntityInfo(Class entityClass, String entityName, boolean audited) {
 			this.entityClass = entityClass;
 			this.entityName = entityName;
 			this.audited = audited;
 		}
 
 		public Class getEntityClass() {
 			return entityClass;
 		}
 
 		public String getEntityName() {
 			return entityName;
 		}
 
 		public boolean isAudited() {
 			return audited;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOneNotOwningMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOneNotOwningMapper.java
index 11d5215667..59ec3c92db 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOneNotOwningMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOneNotOwningMapper.java
@@ -1,48 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.AuditEntity;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Property mapper for not owning side of {@link javax.persistence.OneToOne} relation.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author HernпїЅn Chanfreau
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class OneToOneNotOwningMapper extends AbstractOneToOneMapper {
 	private final String owningReferencePropertyName;
 
 	public OneToOneNotOwningMapper(
 			String notOwningEntityName,
 			String owningEntityName,
 			String owningReferencePropertyName,
-			PropertyData propertyData) {
-		super( notOwningEntityName, owningEntityName, propertyData );
+			PropertyData propertyData,
+			ServiceRegistry serviceRegistry) {
+		super( notOwningEntityName, owningEntityName, propertyData, serviceRegistry );
 		this.owningReferencePropertyName = owningReferencePropertyName;
 	}
 
 	@Override
 	protected Object queryForReferencedEntity(
 			AuditReaderImplementor versionsReader,
 			EntityInfo referencedEntity,
 			Serializable primaryKey,
 			Number revision) {
 		return versionsReader.createQuery().forEntitiesAtRevision(
 				referencedEntity.getEntityClass(),
 				referencedEntity.getEntityName(), revision
 		)
 				.add( AuditEntity.relatedId( owningReferencePropertyName ).eq( primaryKey ) )
 				.getSingleResult();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOnePrimaryKeyJoinColumnMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOnePrimaryKeyJoinColumnMapper.java
index 2b63240606..040de7d932 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOnePrimaryKeyJoinColumnMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/OneToOnePrimaryKeyJoinColumnMapper.java
@@ -1,71 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.AuditEntity;
 import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Property mapper for {@link javax.persistence.OneToOne} with {@link javax.persistence.PrimaryKeyJoinColumn} relation.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class OneToOnePrimaryKeyJoinColumnMapper extends AbstractOneToOneMapper {
 	public OneToOnePrimaryKeyJoinColumnMapper(
 			String entityName,
 			String referencedEntityName,
-			PropertyData propertyData) {
-		super( entityName, referencedEntityName, propertyData );
+			PropertyData propertyData,
+			ServiceRegistry serviceRegistry) {
+		super( entityName, referencedEntityName, propertyData, serviceRegistry );
 	}
 
 	@Override
 	protected Object queryForReferencedEntity(
 			AuditReaderImplementor versionsReader, EntityInfo referencedEntity,
 			Serializable primaryKey, Number revision) {
 		if ( referencedEntity.isAudited() ) {
 			// Audited relation.
 			return versionsReader.createQuery().forEntitiesAtRevision(
 					referencedEntity.getEntityClass(),
 					referencedEntity.getEntityName(), revision
 			)
 					.add( AuditEntity.id().eq( primaryKey ) )
 					.getSingleResult();
 		}
 		else {
 			// Not audited relation.
 			return createNotAuditedEntityReference(
 					versionsReader, referencedEntity.getEntityClass(),
 					referencedEntity.getEntityName(), primaryKey
 			);
 		}
 	}
 
 	/**
 	 * Create Hibernate proxy or retrieve the complete object of referenced, not audited entity. According to
 	 * {@link org.hibernate.envers.Audited#targetAuditMode()}} documentation, reference shall point to current
 	 * (non-historical) version of an entity.
 	 */
 	private Object createNotAuditedEntityReference(
 			AuditReaderImplementor versionsReader, Class<?> entityClass,
 			String entityName, Serializable primaryKey) {
 		final EntityPersister entityPersister = versionsReader.getSessionImplementor().getFactory().getEntityPersister(
 				entityName
 		);
 		if ( entityPersister.hasProxy() ) {
 			// If possible create a proxy. Returning complete object may affect performance.
 			return versionsReader.getSession().load( entityClass, primaryKey );
 		}
 		else {
 			// If proxy is not allowed (e.g. @Proxy(lazy=false)) construct the original object.
 			return versionsReader.getSession().get( entityClass, primaryKey );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
index 46ef9574ff..d1c6d0836b 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
@@ -1,147 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.EntityTools;
 import org.hibernate.envers.internal.tools.query.Parameters;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author HernпїЅn Chanfreau
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class ToOneIdMapper extends AbstractToOneMapper {
 	private final IdMapper delegate;
 	private final String referencedEntityName;
 	private final boolean nonInsertableFake;
 
 	public ToOneIdMapper(
 			IdMapper delegate,
 			PropertyData propertyData,
 			String referencedEntityName,
 			boolean nonInsertableFake) {
-		super( propertyData );
+		super( delegate.getServiceRegistry(), propertyData );
 		this.delegate = delegate;
 		this.referencedEntityName = referencedEntityName;
 		this.nonInsertableFake = nonInsertableFake;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		final HashMap<String, Object> newData = new HashMap<String, Object>();
 
 		// If this property is originally non-insertable, but made insertable because it is in a many-to-one "fake"
 		// bi-directional relation, we always store the "old", unchaged data, to prevent storing changes made
 		// to this field. It is the responsibility of the collection to properly update it if it really changed.
 		delegate.mapToMapFromEntity( newData, nonInsertableFake ? oldObj : newObj );
 
 		for ( Map.Entry<String, Object> entry : newData.entrySet() ) {
 			data.put( entry.getKey(), entry.getValue() );
 		}
 
 		return checkModified( session, newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put( getPropertyData().getModifiedFlagPropertyName(), checkModified( session, newObj, oldObj ) );
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put(
 					getPropertyData().getModifiedFlagPropertyName(),
 					collectionPropertyName.equals( getPropertyData().getName() )
 			);
 		}
 	}
 
 	protected boolean checkModified(SessionImplementor session, Object newObj, Object oldObj) {
 		//noinspection SimplifiableConditionalExpression
 		return nonInsertableFake ? false : !EntityTools.entitiesEqual( session, referencedEntityName, newObj, oldObj );
 	}
 
 	@Override
 	public void nullSafeMapToEntityFromMap(
 			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		final Object entityId = delegate.mapToIdFromMap( data );
 		Object value = null;
 		if ( entityId != null ) {
 			if ( versionsReader.getFirstLevelCache().contains( referencedEntityName, revision, entityId ) ) {
 				value = versionsReader.getFirstLevelCache().get( referencedEntityName, revision, entityId );
 			}
 			else {
 				final EntityInfo referencedEntity = getEntityInfo( enversService, referencedEntityName );
 				boolean ignoreNotFound = false;
 				if ( !referencedEntity.isAudited() ) {
 					final String referencingEntityName = enversService.getEntitiesConfigurations().getEntityNameForVersionsEntityName( (String) data.get( "$type$" ) );
 					ignoreNotFound = enversService.getEntitiesConfigurations().getRelationDescription( referencingEntityName, getPropertyData().getName() ).isIgnoreNotFound();
 				}
 				if ( ignoreNotFound ) {
 					// Eagerly loading referenced entity to silence potential (in case of proxy)
 					// EntityNotFoundException or ObjectNotFoundException. Assigning null reference.
 					value = ToOneEntityLoader.loadImmediate(
 							versionsReader,
 							referencedEntity.getEntityClass(),
 							referencedEntityName,
 							entityId,
 							revision,
 							RevisionType.DEL.equals( data.get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() ) ),
 							enversService
 					);
 				}
 				else {
 					value = ToOneEntityLoader.createProxyOrLoadImmediate(
 							versionsReader,
 							referencedEntity.getEntityClass(),
 							referencedEntityName,
 							entityId,
 							revision,
 							RevisionType.DEL.equals( data.get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() ) ),
 							enversService
 					);
 				}
 			}
 		}
 
 		setPropertyValue( obj, value );
 	}
 
 	public void addMiddleEqualToQuery(
 			Parameters parameters,
 			String idPrefix1,
 			String prefix1,
 			String idPrefix2,
 			String prefix2) {
 		delegate.addIdsEqualToQuery( parameters, prefix1, delegate, prefix2 );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleMapKeyPropertyComponentMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleMapKeyPropertyComponentMapper.java
index 6733162a84..f14f8afd52 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleMapKeyPropertyComponentMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleMapKeyPropertyComponentMapper.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.entities.mapper.relation.component;
 
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.internal.entities.EntityInstantiator;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.query.Parameters;
 
 /**
  * A component mapper for the @MapKey mapping with the name parameter specified: the value of the map's key
  * is a property of the entity. This doesn't have an effect on the data stored in the versions tables,
  * so <code>mapToMapFromObject</code> is empty.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class MiddleMapKeyPropertyComponentMapper implements MiddleComponentMapper {
 	private final String propertyName;
 	private final String accessType;
 
 	public MiddleMapKeyPropertyComponentMapper(String propertyName, String accessType) {
 		this.propertyName = propertyName;
 		this.accessType = accessType;
 	}
 
 	@Override
 	public Object mapToObjectFromFullMap(
 			EntityInstantiator entityInstantiator, Map<String, Object> data,
 			Object dataObject, Number revision) {
 		// dataObject is not null, as this mapper can only be used in an index.
-		return ReflectionTools.getGetter( dataObject.getClass(), propertyName, accessType ).get( dataObject );
+		return ReflectionTools.getGetter( dataObject.getClass(), propertyName, accessType, entityInstantiator.getEnversService().getServiceRegistry() ).get( dataObject );
 	}
 
 	@Override
 	public void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object obj) {
 		// Doing nothing.
 	}
 
 	@Override
 	public void addMiddleEqualToQuery(
 			Parameters parameters,
 			String idPrefix1,
 			String prefix1,
 			String idPrefix2,
 			String prefix2) {
 		// Doing nothing.
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultRevisionInfoGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultRevisionInfoGenerator.java
index 32d66383bd..aa726239d2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultRevisionInfoGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultRevisionInfoGenerator.java
@@ -1,113 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.revisioninfo;
 
 import java.io.Serializable;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Date;
 
 import org.hibernate.MappingException;
 import org.hibernate.Session;
 import org.hibernate.envers.EntityTrackingRevisionListener;
 import org.hibernate.envers.RevisionListener;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.synchronization.SessionCacheCleaner;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class DefaultRevisionInfoGenerator implements RevisionInfoGenerator {
 	private final String revisionInfoEntityName;
 	private final RevisionListener listener;
 	private final Setter revisionTimestampSetter;
 	private final boolean timestampAsDate;
 	private final Class<?> revisionInfoClass;
 	private final SessionCacheCleaner sessionCacheCleaner;
 
 	public DefaultRevisionInfoGenerator(
-			String revisionInfoEntityName, Class<?> revisionInfoClass,
+			String revisionInfoEntityName,
+			Class<?> revisionInfoClass,
 			Class<? extends RevisionListener> listenerClass,
 			PropertyData revisionInfoTimestampData,
-			boolean timestampAsDate) {
+			boolean timestampAsDate,
+			ServiceRegistry serviceRegistry) {
 		this.revisionInfoEntityName = revisionInfoEntityName;
 		this.revisionInfoClass = revisionInfoClass;
 		this.timestampAsDate = timestampAsDate;
 
-		revisionTimestampSetter = ReflectionTools.getSetter( revisionInfoClass, revisionInfoTimestampData );
+		revisionTimestampSetter = ReflectionTools.getSetter( revisionInfoClass, revisionInfoTimestampData, serviceRegistry );
 
 		if ( !listenerClass.equals( RevisionListener.class ) ) {
 			// This is not the default value.
 			try {
 				listener = (RevisionListener) ReflectHelper.getDefaultConstructor( listenerClass ).newInstance();
 			}
 			catch (InstantiationException e) {
 				throw new MappingException( e );
 			}
 			catch (IllegalAccessException e) {
 				throw new MappingException( e );
 			}
 			catch (InvocationTargetException e) {
 				throw new MappingException( e );
 			}
 		}
 		else {
 			// Default listener - none
 			listener = null;
 		}
 
 		sessionCacheCleaner = new SessionCacheCleaner();
 	}
 
 	@Override
 	public void saveRevisionData(Session session, Object revisionData) {
 		session.save( revisionInfoEntityName, revisionData );
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, revisionData );
 	}
 
 	@Override
 	public Object generate() {
 		Object revisionInfo;
 		try {
 			revisionInfo = ReflectHelper.getDefaultConstructor( revisionInfoClass ).newInstance();
 		}
 		catch (Exception e) {
 			throw new RuntimeException( e );
 		}
 
 		final long timestamp = System.currentTimeMillis();
 		revisionTimestampSetter.set( revisionInfo, timestampAsDate ? new Date( timestamp ) : timestamp, null );
 
 		if ( listener != null ) {
 			listener.newRevision( revisionInfo );
 		}
 
 		return revisionInfo;
 	}
 
 	@Override
 	public void entityChanged(
 			Class entityClass,
 			String entityName,
 			Serializable entityId,
 			RevisionType revisionType,
 			Object revisionInfo) {
 		if ( listener instanceof EntityTrackingRevisionListener ) {
 			( (EntityTrackingRevisionListener) listener ).entityChanged(
 					entityClass,
 					entityName,
 					entityId,
 					revisionType,
 					revisionInfo
 			);
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultTrackingModifiedEntitiesRevisionInfoGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultTrackingModifiedEntitiesRevisionInfoGenerator.java
index c85f14d3bb..f44b91b4ab 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultTrackingModifiedEntitiesRevisionInfoGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/DefaultTrackingModifiedEntitiesRevisionInfoGenerator.java
@@ -1,58 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.revisioninfo;
 
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Set;
 
 import org.hibernate.envers.RevisionListener;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Automatically adds entity names, that have been changed during current revision, to revision entity.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  *
  * @see org.hibernate.envers.ModifiedEntityNames
  * @see org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity
  */
 public class DefaultTrackingModifiedEntitiesRevisionInfoGenerator extends DefaultRevisionInfoGenerator {
 	private final Setter modifiedEntityNamesSetter;
 	private final Getter modifiedEntityNamesGetter;
 
 	public DefaultTrackingModifiedEntitiesRevisionInfoGenerator(
-			String revisionInfoEntityName, Class<?> revisionInfoClass,
+			String revisionInfoEntityName,
+			Class<?> revisionInfoClass,
 			Class<? extends RevisionListener> listenerClass,
-			PropertyData revisionInfoTimestampData, boolean timestampAsDate,
-			PropertyData modifiedEntityNamesData) {
-		super( revisionInfoEntityName, revisionInfoClass, listenerClass, revisionInfoTimestampData, timestampAsDate );
-		modifiedEntityNamesSetter = ReflectionTools.getSetter( revisionInfoClass, modifiedEntityNamesData );
-		modifiedEntityNamesGetter = ReflectionTools.getGetter( revisionInfoClass, modifiedEntityNamesData );
+			PropertyData revisionInfoTimestampData,
+			boolean timestampAsDate,
+			PropertyData modifiedEntityNamesData,
+			ServiceRegistry serviceRegistry) {
+		super( revisionInfoEntityName, revisionInfoClass, listenerClass, revisionInfoTimestampData, timestampAsDate, serviceRegistry );
+		modifiedEntityNamesSetter = ReflectionTools.getSetter( revisionInfoClass, modifiedEntityNamesData, serviceRegistry );
+		modifiedEntityNamesGetter = ReflectionTools.getGetter( revisionInfoClass, modifiedEntityNamesData, serviceRegistry );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public void entityChanged(
 			Class entityClass,
 			String entityName,
 			Serializable entityId,
 			RevisionType revisionType,
 			Object revisionEntity) {
 		super.entityChanged( entityClass, entityName, entityId, revisionType, revisionEntity );
 		Set<String> modifiedEntityNames = (Set<String>) modifiedEntityNamesGetter.get( revisionEntity );
 		if ( modifiedEntityNames == null ) {
 			modifiedEntityNames = new HashSet<String>();
 			modifiedEntityNamesSetter.set( revisionEntity, modifiedEntityNames, null );
 		}
 		modifiedEntityNames.add( entityName );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/ModifiedEntityNamesReader.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/ModifiedEntityNamesReader.java
index b538c6c108..079ff62654 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/ModifiedEntityNamesReader.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/ModifiedEntityNamesReader.java
@@ -1,31 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.revisioninfo;
 
 import java.util.Set;
 
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Returns modified entity names from a persisted revision info entity.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class ModifiedEntityNamesReader {
 	private final Getter modifiedEntityNamesGetter;
 
-	public ModifiedEntityNamesReader(Class<?> revisionInfoClass, PropertyData modifiedEntityNamesData) {
-		modifiedEntityNamesGetter = ReflectionTools.getGetter( revisionInfoClass, modifiedEntityNamesData );
+	public ModifiedEntityNamesReader(
+			Class<?> revisionInfoClass,
+			PropertyData modifiedEntityNamesData,
+			ServiceRegistry serviceRegistry) {
+		modifiedEntityNamesGetter = ReflectionTools.getGetter( revisionInfoClass, modifiedEntityNamesData, serviceRegistry );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public Set<String> getModifiedEntityNames(Object revisionEntity) {
 		return (Set<String>) modifiedEntityNamesGetter.get( revisionEntity );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/RevisionInfoNumberReader.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/RevisionInfoNumberReader.java
index 5792215649..970f7e65d1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/RevisionInfoNumberReader.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/revisioninfo/RevisionInfoNumberReader.java
@@ -1,28 +1,29 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.revisioninfo;
 
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.tools.ReflectionTools;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * Gets a revision number from a persisted revision info entity.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class RevisionInfoNumberReader {
 	private final Getter revisionIdGetter;
 
-	public RevisionInfoNumberReader(Class<?> revisionInfoClass, PropertyData revisionInfoIdData) {
-		revisionIdGetter = ReflectionTools.getGetter( revisionInfoClass, revisionInfoIdData );
+	public RevisionInfoNumberReader(Class<?> revisionInfoClass, PropertyData revisionInfoIdData, ServiceRegistry serviceRegistry) {
+		revisionIdGetter = ReflectionTools.getGetter( revisionInfoClass, revisionInfoIdData, serviceRegistry );
 	}
 
 	public Number getRevisionNumber(Object revision) {
 		return (Number) revisionIdGetter.get( revision );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/ReflectionTools.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/ReflectionTools.java
index a330b2ef3b..fed2079789 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/ReflectionTools.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/ReflectionTools.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.tools;
 
 import java.util.Map;
 
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.tools.Pair;
 import org.hibernate.internal.util.collections.ConcurrentReferenceHashMap;
-import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.PropertyAccessStrategy;
+import org.hibernate.property.access.spi.PropertyAccessStrategyResolver;
+import org.hibernate.property.access.spi.Setter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class ReflectionTools {
 	private static final Map<Pair<Class, String>, Getter> GETTER_CACHE = new ConcurrentReferenceHashMap<Pair<Class, String>, Getter>(
 			10,
 			ConcurrentReferenceHashMap.ReferenceType.SOFT,
 			ConcurrentReferenceHashMap.ReferenceType.SOFT
 	);
 	private static final Map<Pair<Class, String>, Setter> SETTER_CACHE = new ConcurrentReferenceHashMap<Pair<Class, String>, Setter>(
 					10,
 					ConcurrentReferenceHashMap.ReferenceType.SOFT,
 					ConcurrentReferenceHashMap.ReferenceType.SOFT
 	);
 
-	private static PropertyAccessor getAccessor(String accessorType) {
-		return PropertyAccessorFactory.getPropertyAccessor( accessorType );
+	private static PropertyAccessStrategy getAccessStrategy(ServiceRegistry serviceRegistry, String accessorType) {
+		return serviceRegistry.getService( PropertyAccessStrategyResolver.class )
+				.resolvePropertyAccessStrategy( accessorType, null );
 	}
 
-	public static Getter getGetter(Class cls, PropertyData propertyData) {
-		return getGetter( cls, propertyData.getBeanName(), propertyData.getAccessType() );
+	public static Getter getGetter(Class cls, PropertyData propertyData, ServiceRegistry serviceRegistry) {
+		return getGetter( cls, propertyData.getBeanName(), propertyData.getAccessType(), serviceRegistry );
 	}
 
-	public static Getter getGetter(Class cls, String propertyName, String accessorType) {
+	public static Getter getGetter(Class cls, String propertyName, String accessorType, ServiceRegistry serviceRegistry) {
 		final Pair<Class, String> key = Pair.make( cls, propertyName );
 		Getter value = GETTER_CACHE.get( key );
 		if ( value == null ) {
-			value = getAccessor( accessorType ).getGetter( cls, propertyName );
+			value = getAccessStrategy( serviceRegistry, accessorType ).buildPropertyAccess( cls, propertyName ).getGetter();
 			// It's ok if two getters are generated concurrently
 			GETTER_CACHE.put( key, value );
 		}
 
 		return value;
 	}
 
-	public static Setter getSetter(Class cls, PropertyData propertyData) {
-		return getSetter( cls, propertyData.getBeanName(), propertyData.getAccessType() );
+	public static Setter getSetter(Class cls, PropertyData propertyData, ServiceRegistry serviceRegistry) {
+		return getSetter( cls, propertyData.getBeanName(), propertyData.getAccessType(), serviceRegistry );
 	}
 
-	public static Setter getSetter(Class cls, String propertyName, String accessorType) {
+	public static Setter getSetter(Class cls, String propertyName, String accessorType, ServiceRegistry serviceRegistry) {
 		final Pair<Class, String> key = Pair.make( cls, propertyName );
 		Setter value = SETTER_CACHE.get( key );
 		if ( value == null ) {
-			value = getAccessor( accessorType ).getSetter( cls, propertyName );
+			value = getAccessStrategy( serviceRegistry, accessorType ).buildPropertyAccess( cls, propertyName ).getSetter();
 			// It's ok if two setters are generated concurrently
 			SETTER_CACHE.put( key, value );
 		}
 
 		return value;
 	}
 
 	/**
 	 * @param clazz Source class.
 	 * @param propertyName Property name.
 	 *
 	 * @return Property object or {@code null} if none with expected name has been found.
 	 */
 	public static XProperty getProperty(XClass clazz, String propertyName) {
 		XProperty property = getProperty( clazz, propertyName, "field" );
 		if ( property == null ) {
 			property = getProperty( clazz, propertyName, "property" );
 		}
 		return property;
 	}
 
 	/**
 	 * @param clazz Source class.
 	 * @param propertyName Property name.
 	 * @param accessType Expected access type. Legal values are <i>field</i> and <i>property</i>.
 	 *
 	 * @return Property object or {@code null} if none with expected name and access type has been found.
 	 */
 	public static XProperty getProperty(XClass clazz, String propertyName, String accessType) {
 		for ( XProperty property : clazz.getDeclaredProperties( accessType ) ) {
 			if ( propertyName.equals( property.getName() ) ) {
 				return property;
 			}
 		}
 		return null;
 	}
 
 	/**
 	 * Locate class with a given name.
 	 *
 	 * @param name Fully qualified class name.
-	 * @param classLoaderService Class loading service. Passing {@code null} reference
-	 * in case of {@link AuditConfiguration#getFor(Configuration)} usage.
+	 * @param classLoaderService Class loading service. Passing {@code null} is "allowed", but will result in
+	 * TCCL usage.
 	 *
 	 * @return The cass reference.
 	 *
 	 * @throws ClassLoadingException Indicates the class could not be found.
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T> Class<T> loadClass(String name, ClassLoaderService classLoaderService)
 			throws ClassLoadingException {
 		try {
 			if ( classLoaderService != null ) {
 				return classLoaderService.classForName( name );
 			}
 			else {
 				return (Class<T>) Thread.currentThread().getContextClassLoader().loadClass( name );
 			}
 		}
 		catch (Exception e) {
 			throw new ClassLoadingException( "Unable to load class [" + name + "]", e );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
index 0c553729ab..e0a58f8a41 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
@@ -1,375 +1,375 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.strategy;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.LockOptions;
 import org.hibernate.Session;
 import org.hibernate.action.spi.BeforeTransactionCompletionProcess;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.synchronization.SessionCacheCleaner;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.jdbc.ReturningWork;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.entity.UnionSubclassEntityPersister;
-import org.hibernate.property.Getter;
+import org.hibernate.property.access.spi.Getter;
 import org.hibernate.sql.Update;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.Type;
 
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.MIDDLE_ENTITY_ALIAS;
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REVISION_PARAMETER;
 
 /**
  * Audit strategy which persists and retrieves audit information using a validity algorithm, based on the
  * start-revision and end-revision of a row in the audit tables.
  * <p>This algorithm works as follows:
  * <ul>
  * <li>For a <strong>new row</strong> that is persisted in an audit table, only the <strong>start-revision</strong> column of that row is set</li>
  * <li>At the same time the <strong>end-revision</strong> field of the <strong>previous</strong> audit row is set to this revision</li>
  * <li>Queries are retrieved using 'between start and end revision', instead of a subquery.</li>
  * </ul>
  * </p>
  * <p/>
  * <p>
  * This has a few important consequences that need to be judged against against each other:
  * <ul>
  * <li>Persisting audit information is a bit slower, because an extra row is updated</li>
  * <li>Retrieving audit information is a lot faster</li>
  * </ul>
  * </p>
  *
  * @author Stephanie Pau
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class ValidityAuditStrategy implements AuditStrategy {
 	/**
 	 * getter for the revision entity field annotated with @RevisionTimestamp
 	 */
 	private Getter revisionTimestampGetter = null;
 
 	private final SessionCacheCleaner sessionCacheCleaner;
 
 	public ValidityAuditStrategy() {
 		sessionCacheCleaner = new SessionCacheCleaner();
 	}
 
 	@Override
 	public void perform(
 			final Session session,
 			final String entityName,
 			final EnversService enversService,
 			final Serializable id,
 			final Object data,
 			final Object revision) {
 		final AuditEntitiesConfiguration audEntitiesCfg = enversService.getAuditEntitiesConfiguration();
 		final String auditedEntityName = audEntitiesCfg.getAuditEntityName( entityName );
 		final String revisionInfoEntityName = enversService.getAuditEntitiesConfiguration().getRevisionInfoEntityName();
 
 		// Save the audit data
 		session.save( auditedEntityName, data );
 
 		// Update the end date of the previous row.
 		//
 		// When application reuses identifiers of previously removed entities:
 		// The UPDATE statement will no-op if an entity with a given identifier has been
 		// inserted for the first time. But in case a deleted primary key value was
 		// reused, this guarantees correct strategy behavior: exactly one row with
 		// null end date exists for each identifier.
 		final boolean reuseEntityIdentifier = enversService.getGlobalConfiguration().isAllowIdentifierReuse();
 		if ( reuseEntityIdentifier || getRevisionType( enversService, data ) != RevisionType.ADD ) {
 			// Register transaction completion process to guarantee execution of UPDATE statement after INSERT.
 			( (EventSource) session ).getActionQueue().registerProcess( new BeforeTransactionCompletionProcess() {
 				@Override
 				public void doBeforeTransactionCompletion(final SessionImplementor sessionImplementor) {
 					final Queryable productionEntityQueryable = getQueryable( entityName, sessionImplementor );
 					final Queryable rootProductionEntityQueryable = getQueryable(
 							productionEntityQueryable.getRootEntityName(), sessionImplementor
 					);
 					final Queryable auditedEntityQueryable = getQueryable( auditedEntityName, sessionImplementor );
 					final Queryable rootAuditedEntityQueryable = getQueryable(
 							auditedEntityQueryable.getRootEntityName(), sessionImplementor
 					);
 
 					final String updateTableName;
 					if ( UnionSubclassEntityPersister.class.isInstance( rootProductionEntityQueryable ) ) {
 						// this is the condition causing all the problems in terms of the generated SQL UPDATE
 						// the problem being that we currently try to update the in-line view made up of the union query
 						//
 						// this is extremely hacky means to get the root table name for the union subclass style entities.
 						// hacky because it relies on internal behavior of UnionSubclassEntityPersister
 						// !!!!!! NOTICE - using subclass persister, not root !!!!!!
 						updateTableName = auditedEntityQueryable.getSubclassTableName( 0 );
 					}
 					else {
 						updateTableName = rootAuditedEntityQueryable.getTableName();
 					}
 
 					final Type revisionInfoIdType = sessionImplementor.getFactory().getEntityPersister( revisionInfoEntityName ).getIdentifierType();
 					final String revEndColumnName = rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName() )[0];
 
 					final boolean isRevisionEndTimestampEnabled = enversService.getAuditEntitiesConfiguration().isRevisionEndTimestampEnabled();
 
 					// update audit_ent set REVEND = ? [, REVEND_TSTMP = ?] where (prod_ent_id) = ? and REV <> ? and REVEND is null
 					final Update update = new Update( sessionImplementor.getFactory().getDialect() ).setTableName( updateTableName );
 					// set REVEND = ?
 					update.addColumn( revEndColumnName );
 					// set [, REVEND_TSTMP = ?]
 					if ( isRevisionEndTimestampEnabled ) {
 						update.addColumn(
 								rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName() )[0]
 						);
 					}
 
 					// where (prod_ent_id) = ?
 					update.addPrimaryKeyColumns( rootProductionEntityQueryable.getIdentifierColumnNames() );
 					// where REV <> ?
 					update.addWhereColumn(
 							rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionNumberPath() )[0], "<> ?"
 					);
 					// where REVEND is null
 					update.addWhereColumn( revEndColumnName, " is null" );
 
 					// Now lets execute the sql...
 					final String updateSql = update.toStatementString();
 
 					int rowCount = ( (Session) sessionImplementor ).doReturningWork(
 							new ReturningWork<Integer>() {
 								@Override
 								public Integer execute(Connection connection) throws SQLException {
 									PreparedStatement preparedStatement = sessionImplementor
 											.getJdbcCoordinator().getStatementPreparer().prepareStatement( updateSql );
 
 									try {
 										int index = 1;
 
 										// set REVEND = ?
 										final Number revisionNumber = enversService.getRevisionInfoNumberReader().getRevisionNumber(
 												revision
 										);
 										revisionInfoIdType.nullSafeSet(
 												preparedStatement, revisionNumber, index, sessionImplementor
 										);
 										index += revisionInfoIdType.getColumnSpan( sessionImplementor.getFactory() );
 
 										// set [, REVEND_TSTMP = ?]
 										if ( isRevisionEndTimestampEnabled ) {
 											final Object revEndTimestampObj = revisionTimestampGetter.get( revision );
 											final Date revisionEndTimestamp = convertRevEndTimestampToDate( revEndTimestampObj );
 											final Type revEndTsType = rootAuditedEntityQueryable.getPropertyType(
 													enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName()
 											);
 											revEndTsType.nullSafeSet(
 													preparedStatement, revisionEndTimestamp, index, sessionImplementor
 											);
 											index += revEndTsType.getColumnSpan( sessionImplementor.getFactory() );
 										}
 
 										// where (prod_ent_id) = ?
 										final Type idType = rootProductionEntityQueryable.getIdentifierType();
 										idType.nullSafeSet( preparedStatement, id, index, sessionImplementor );
 										index += idType.getColumnSpan( sessionImplementor.getFactory() );
 
 										// where REV <> ?
 										final Type revType = rootAuditedEntityQueryable.getPropertyType(
 												enversService.getAuditEntitiesConfiguration().getRevisionNumberPath()
 										);
 										revType.nullSafeSet( preparedStatement, revisionNumber, index, sessionImplementor );
 
 										// where REVEND is null
 										// 		nothing to bind....
 
 										return sessionImplementor
 												.getJdbcCoordinator().getResultSetReturn().executeUpdate( preparedStatement );
 									}
 									finally {
 										sessionImplementor.getJdbcCoordinator().getResourceRegistry().release(
 												preparedStatement
 										);
 										sessionImplementor.getJdbcCoordinator().afterStatementExecution();
 									}
 								}
 							}
 					);
 
 					if ( rowCount != 1 && ( !reuseEntityIdentifier || ( getRevisionType( enversService, data ) != RevisionType.ADD ) ) ) {
 						throw new RuntimeException(
 								"Cannot update previous revision for entity " + auditedEntityName + " and id " + id
 						);
 					}
 				}
 			});
 		}
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, data );
 	}
 
 	private Queryable getQueryable(String entityName, SessionImplementor sessionImplementor) {
 		return (Queryable) sessionImplementor.getFactory().getEntityPersister( entityName );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public void performCollectionChange(
 			Session session,
 			String entityName,
 			String propertyName,
 			EnversService enversService,
 			PersistentCollectionChangeData persistentCollectionChangeData, Object revision) {
 		final QueryBuilder qb = new QueryBuilder( persistentCollectionChangeData.getEntityName(), MIDDLE_ENTITY_ALIAS );
 
 		final String originalIdPropName = enversService.getAuditEntitiesConfiguration().getOriginalIdPropName();
 		final Map<String, Object> originalId = (Map<String, Object>) persistentCollectionChangeData.getData().get(
 				originalIdPropName
 		);
 		final String revisionFieldName = enversService.getAuditEntitiesConfiguration().getRevisionFieldName();
 		final String revisionTypePropName = enversService.getAuditEntitiesConfiguration().getRevisionTypePropName();
 
 		// Adding a parameter for each id component, except the rev number and type.
 		for ( Map.Entry<String, Object> originalIdEntry : originalId.entrySet() ) {
 			if ( !revisionFieldName.equals( originalIdEntry.getKey() ) && !revisionTypePropName.equals( originalIdEntry.getKey() ) ) {
 				qb.getRootParameters().addWhereWithParam(
 						originalIdPropName + "." + originalIdEntry.getKey(),
 						true, "=", originalIdEntry.getValue()
 				);
 			}
 		}
 
 		final SessionFactoryImplementor sessionFactory = ((SessionImplementor) session).getFactory();
 		final Type propertyType = sessionFactory.getEntityPersister( entityName ).getPropertyType( propertyName );
 		if ( propertyType.isCollectionType() ) {
 			CollectionType collectionPropertyType = (CollectionType) propertyType;
 			// Handling collection of components.
 			if ( collectionPropertyType.getElementType( sessionFactory ) instanceof ComponentType ) {
 				// Adding restrictions to compare data outside of primary key.
 				for ( Map.Entry<String, Object> dataEntry : persistentCollectionChangeData.getData().entrySet() ) {
 					if ( !originalIdPropName.equals( dataEntry.getKey() ) ) {
 						qb.getRootParameters().addWhereWithParam( dataEntry.getKey(), true, "=", dataEntry.getValue() );
 					}
 				}
 			}
 		}
 
 		addEndRevisionNullRestriction( enversService, qb.getRootParameters() );
 
 		final List<Object> l = qb.toQuery( session ).setLockOptions( LockOptions.UPGRADE ).list();
 
 		// Update the last revision if one exists.
 		// HHH-5967: with collections, the same element can be added and removed multiple times. So even if it's an
 		// ADD, we may need to update the last revision.
 		if ( l.size() > 0 ) {
 			updateLastRevision(
 					session, enversService, l, originalId, persistentCollectionChangeData.getEntityName(), revision
 			);
 		}
 
 		// Save the audit data
 		session.save( persistentCollectionChangeData.getEntityName(), persistentCollectionChangeData.getData() );
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, persistentCollectionChangeData.getData() );
 	}
 
 	private void addEndRevisionNullRestriction(EnversService enversService, Parameters rootParameters) {
 		rootParameters.addWhere( enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName(), true, "is", "null", false );
 	}
 
 	public void addEntityAtRevisionRestriction(
 			GlobalConfiguration globalCfg, QueryBuilder rootQueryBuilder,
 			Parameters parameters, String revisionProperty, String revisionEndProperty, boolean addAlias,
 			MiddleIdData idData, String revisionPropertyPath, String originalIdPropertyName,
 			String alias1, String alias2, boolean inclusive) {
 		addRevisionRestriction( parameters, revisionProperty, revisionEndProperty, addAlias, inclusive );
 	}
 
 	public void addAssociationAtRevisionRestriction(
 			QueryBuilder rootQueryBuilder, Parameters parameters, String revisionProperty,
 			String revisionEndProperty, boolean addAlias, MiddleIdData referencingIdData,
 			String versionsMiddleEntityName, String eeOriginalIdPropertyPath, String revisionPropertyPath,
 			String originalIdPropertyName, String alias1, boolean inclusive, MiddleComponentData... componentDatas) {
 		addRevisionRestriction( parameters, revisionProperty, revisionEndProperty, addAlias, inclusive );
 	}
 
 	public void setRevisionTimestampGetter(Getter revisionTimestampGetter) {
 		this.revisionTimestampGetter = revisionTimestampGetter;
 	}
 
 	private void addRevisionRestriction(
 			Parameters rootParameters, String revisionProperty, String revisionEndProperty,
 			boolean addAlias, boolean inclusive) {
 		// e.revision <= _revision and (e.endRevision > _revision or e.endRevision is null)
 		Parameters subParm = rootParameters.addSubParameters( "or" );
 		rootParameters.addWhereWithNamedParam( revisionProperty, addAlias, inclusive ? "<=" : "<", REVISION_PARAMETER );
 		subParm.addWhereWithNamedParam(
 				revisionEndProperty + ".id", addAlias, inclusive ? ">" : ">=", REVISION_PARAMETER
 		);
 		subParm.addWhere( revisionEndProperty, addAlias, "is", "null", false );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private RevisionType getRevisionType(EnversService enversService, Object data) {
 		return (RevisionType) ((Map<String, Object>) data).get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void updateLastRevision(
 			Session session,
 			EnversService enversService,
 			List<Object> l,
 			Object id,
 			String auditedEntityName,
 			Object revision) {
 		// There should be one entry
 		if ( l.size() == 1 ) {
 			// Setting the end revision to be the current rev
 			Object previousData = l.get( 0 );
 			String revisionEndFieldName = enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName();
 			((Map<String, Object>) previousData).put( revisionEndFieldName, revision );
 
 			if ( enversService.getAuditEntitiesConfiguration().isRevisionEndTimestampEnabled() ) {
 				// Determine the value of the revision property annotated with @RevisionTimestamp
 				String revEndTimestampFieldName = enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName();
 				Object revEndTimestampObj = this.revisionTimestampGetter.get( revision );
 				Date revisionEndTimestamp = convertRevEndTimestampToDate( revEndTimestampObj );
 
 				// Setting the end revision timestamp
 				((Map<String, Object>) previousData).put( revEndTimestampFieldName, revisionEndTimestamp );
 			}
 
 			// Saving the previous version
 			session.save( auditedEntityName, previousData );
 			sessionCacheCleaner.scheduleAuditDataRemoval( session, previousData );
 		}
 		else {
 			throw new RuntimeException( "Cannot find previous revision for entity " + auditedEntityName + " and id " + id );
 		}
 	}
 
 	private Date convertRevEndTimestampToDate(Object revEndTimestampObj) {
 		// convert to a java.util.Date
 		if ( revEndTimestampObj instanceof Date ) {
 			return (Date) revEndTimestampObj;
 		}
 		return new Date( (Long) revEndTimestampObj );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/internal/tools/MapProxyTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/internal/tools/MapProxyTest.java
index 63e0373532..761bcaf139 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/internal/tools/MapProxyTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/internal/tools/MapProxyTest.java
@@ -1,74 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.envers.internal.tools;
 
 import java.util.HashMap;
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.property.Getter;
-import org.hibernate.property.Setter;
+import org.hibernate.property.access.spi.Getter;
+import org.hibernate.property.access.spi.Setter;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import junit.framework.Assert;
 
 public class MapProxyTest {
 
+    private StandardServiceRegistry serviceRegistry;
+
+	@Before
+	public void prepare() {
+		serviceRegistry = new StandardServiceRegistryBuilder().build();
+	}
+
+	@After
+	public void release() {
+		StandardServiceRegistryBuilder.destroy( serviceRegistry );
+	}
+
     @Test
     public void shouldGenerateClassWithAppropriateGetter() throws Exception {
         //given
         Map<String, Object> map = new HashMap<String, Object>();
         int ageExpected = 14;
         map.put("age", ageExpected);
         Map<String, Class<?>> properties = new HashMap<String, Class<?>>();
         properties.put("age", Integer.class);
         //when
         Class testClass = MapProxyTool.classForName("TestClass1", properties, new ClassLoaderServiceImpl());
         Object testClassInstance = testClass.getConstructor(Map.class).newInstance(map);
 
         //then
-        Getter getter = ReflectionTools.getGetter(testClass, "age", "property");
+        Getter getter = ReflectionTools.getGetter( testClass, "age", "property", serviceRegistry );
         int age = (Integer) getter.get(testClassInstance);
         Assert.assertEquals(ageExpected, age);
     }
 
     @Test
     public void shouldGenerateClassWithAppropriateSetter() throws Exception {
         //given
         Map<String, Object> map = new HashMap<String, Object>();
         Map<String, Class<?>> properties = new HashMap<String, Class<?>>();
         properties.put("age", Integer.class);
 
         //when
         Class testClass = MapProxyTool.classForName("TestClass2", properties, new ClassLoaderServiceImpl());
         Object testClassInstance = testClass.getConstructor(Map.class).newInstance(map);
 
         //then
-        Setter setter = ReflectionTools.getSetter(testClass, "age", "property");
+        Setter setter = ReflectionTools.getSetter(testClass, "age", "property", serviceRegistry);
         int ageExpected = 14;
         setter.set(testClassInstance, ageExpected, null);
         Object age = map.get("age");
         Assert.assertEquals(ageExpected, age);
     }
 
     @Test
     public void shouldGenerateClassWithAppropriateAccessorsForBoolean() throws Exception {
         //given
         Map<String, Object> map = new HashMap<String, Object>();
         map.put("checkbox",true);
         Map<String, Class<?>> properties = new HashMap<String, Class<?>>();
         properties.put("checkbox", Boolean.class);
 
         //when
         Class testClass = MapProxyTool.classForName("TestClass3", properties, new ClassLoaderServiceImpl());
         Object testClassInstance = testClass.getConstructor(Map.class).newInstance(map);
 
         //then
-        Getter getter = ReflectionTools.getGetter(testClass, "checkbox", "property");
+        Getter getter = ReflectionTools.getGetter(testClass, "checkbox", "property", serviceRegistry);
         Assert.assertTrue((Boolean) getter.get(testClassInstance));
     }
 }
diff --git a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/InfinispanRegionFactory.java b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/InfinispanRegionFactory.java
index b88131817f..60563732dc 100644
--- a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/InfinispanRegionFactory.java
+++ b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/InfinispanRegionFactory.java
@@ -1,664 +1,684 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cache.infinispan;
 
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.spi.SessionFactoryOptions;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.infinispan.collection.CollectionRegionImpl;
 import org.hibernate.cache.infinispan.entity.EntityRegionImpl;
 import org.hibernate.cache.infinispan.impl.BaseRegion;
 import org.hibernate.cache.infinispan.naturalid.NaturalIdRegionImpl;
 import org.hibernate.cache.infinispan.query.QueryResultsRegionImpl;
 import org.hibernate.cache.infinispan.timestamp.ClusteredTimestampsRegionImpl;
 import org.hibernate.cache.infinispan.timestamp.TimestampTypeOverrides;
 import org.hibernate.cache.infinispan.timestamp.TimestampsRegionImpl;
 import org.hibernate.cache.infinispan.tm.HibernateTransactionManagerLookup;
 import org.hibernate.cache.infinispan.util.CacheCommandFactory;
 import org.hibernate.cache.infinispan.util.Caches;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.NaturalIdRegion;
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TimestampsRegion;
 import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.service.ServiceRegistry;
+
 import org.infinispan.AdvancedCache;
 import org.infinispan.commands.module.ModuleCommandFactory;
 import org.infinispan.commons.util.FileLookupFactory;
 import org.infinispan.configuration.cache.CacheMode;
 import org.infinispan.configuration.cache.Configuration;
 import org.infinispan.configuration.cache.ConfigurationBuilder;
 import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;
 import org.infinispan.configuration.parsing.ParserRegistry;
 import org.infinispan.factories.GlobalComponentRegistry;
 import org.infinispan.manager.DefaultCacheManager;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.transaction.TransactionMode;
 import org.infinispan.transaction.lookup.GenericTransactionManagerLookup;
 import org.infinispan.util.concurrent.IsolationLevel;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-
 /**
  * A {@link RegionFactory} for <a href="http://www.jboss.org/infinispan">Infinispan</a>-backed cache
  * regions.
  *
  * @author Chris Bredesen
  * @author Galder Zamarreño
  * @since 3.5
  */
 public class InfinispanRegionFactory implements RegionFactory {
-
 	private static final Log log = LogFactory.getLog( InfinispanRegionFactory.class );
 
 	private static final String PREFIX = "hibernate.cache.infinispan.";
 
 	private static final String CONFIG_SUFFIX = ".cfg";
 
 	private static final String STRATEGY_SUFFIX = ".eviction.strategy";
 
 	private static final String WAKE_UP_INTERVAL_SUFFIX = ".eviction.wake_up_interval";
 
 	private static final String MAX_ENTRIES_SUFFIX = ".eviction.max_entries";
 
 	private static final String LIFESPAN_SUFFIX = ".expiration.lifespan";
 
 	private static final String MAX_IDLE_SUFFIX = ".expiration.max_idle";
 
 //   private static final String STATISTICS_SUFFIX = ".statistics";
 
 	/**
 	 * Classpath or filesystem resource containing Infinispan configurations the factory should use.
 	 *
 	 * @see #DEF_INFINISPAN_CONFIG_RESOURCE
 	 */
 	public static final String INFINISPAN_CONFIG_RESOURCE_PROP = "hibernate.cache.infinispan.cfg";
 
    /**
     * Property name that controls whether Infinispan statistics are enabled.
     * The property value is expected to be a boolean true or false, and it
     * overrides statistic configuration in base Infinispan configuration,
     * if provided.
     */
 	public static final String INFINISPAN_GLOBAL_STATISTICS_PROP = "hibernate.cache.infinispan.statistics";
 
 	/**
 	 * Property that controls whether Infinispan should interact with the
 	 * transaction manager as a {@link javax.transaction.Synchronization} or as
 	 * an XA resource. If the property is set to true, it will be a
 	 * synchronization, otherwise an XA resource.
 	 *
 	 * @see #DEF_USE_SYNCHRONIZATION
 	 */
 	public static final String INFINISPAN_USE_SYNCHRONIZATION_PROP = "hibernate.cache.infinispan.use_synchronization";
 
 	private static final String NATURAL_ID_KEY = "naturalid";
 
 	/**
 	 * Name of the configuration that should be used for natural id caches.
 	 *
 	 * @see #DEF_ENTITY_RESOURCE
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public static final String NATURAL_ID_CACHE_RESOURCE_PROP = PREFIX + NATURAL_ID_KEY + CONFIG_SUFFIX;
 
 	private static final String ENTITY_KEY = "entity";
 
 	/**
 	 * Name of the configuration that should be used for entity caches.
 	 *
 	 * @see #DEF_ENTITY_RESOURCE
 	 */
 	public static final String ENTITY_CACHE_RESOURCE_PROP = PREFIX + ENTITY_KEY + CONFIG_SUFFIX;
 
 	private static final String IMMUTABLE_ENTITY_KEY = "immutable-entity";
 
 	/**
 	 * Name of the configuration that should be used for immutable entity caches.
 	 */
 	public static final String IMMUTABLE_ENTITY_CACHE_RESOURCE_PROP = PREFIX + IMMUTABLE_ENTITY_KEY + CONFIG_SUFFIX;
 
 	private static final String COLLECTION_KEY = "collection";
 
 	/**
 	 * Name of the configuration that should be used for collection caches.
 	 * No default value, as by default we try to use the same Infinispan cache
 	 * instance we use for entity caching.
 	 *
 	 * @see #ENTITY_CACHE_RESOURCE_PROP
 	 * @see #DEF_ENTITY_RESOURCE
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public static final String COLLECTION_CACHE_RESOURCE_PROP = PREFIX + COLLECTION_KEY + CONFIG_SUFFIX;
 
 	private static final String TIMESTAMPS_KEY = "timestamps";
 
 	/**
 	 * Name of the configuration that should be used for timestamp caches.
 	 *
 	 * @see #DEF_TIMESTAMPS_RESOURCE
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public static final String TIMESTAMPS_CACHE_RESOURCE_PROP = PREFIX + TIMESTAMPS_KEY + CONFIG_SUFFIX;
 
 	private static final String QUERY_KEY = "query";
 
 	/**
 	 * Name of the configuration that should be used for query caches.
 	 *
 	 * @see #DEF_QUERY_RESOURCE
 	 */
 	public static final String QUERY_CACHE_RESOURCE_PROP = PREFIX + QUERY_KEY + CONFIG_SUFFIX;
 
 	/**
 	 * Default value for {@link #INFINISPAN_CONFIG_RESOURCE_PROP}. Specifies the "infinispan-configs.xml" file in this package.
 	 */
 	public static final String DEF_INFINISPAN_CONFIG_RESOURCE = "org/hibernate/cache/infinispan/builder/infinispan-configs.xml";
 
 	/**
 	 * Default value for {@link #ENTITY_CACHE_RESOURCE_PROP}.
 	 */
 	public static final String DEF_ENTITY_RESOURCE = "entity";
 
 	/**
 	 * Default value for {@link #IMMUTABLE_ENTITY_CACHE_RESOURCE_PROP}.
 	 */
 	public static final String DEF_IMMUTABLE_ENTITY_RESOURCE = "immutable-entity";
 
 	/**
 	 * Default value for {@link #TIMESTAMPS_CACHE_RESOURCE_PROP}.
 	 */
 	public static final String DEF_TIMESTAMPS_RESOURCE = "timestamps";
 
 	/**
 	 * Default value for {@link #QUERY_CACHE_RESOURCE_PROP}.
 	 */
 	public static final String DEF_QUERY_RESOURCE = "local-query";
 
 	/**
 	 * Default value for {@link #INFINISPAN_USE_SYNCHRONIZATION_PROP}.
 	 */
 	public static final boolean DEF_USE_SYNCHRONIZATION = true;
 
 	/**
 	 * Name of the pending puts cache.
 	 */
 	public static final String PENDING_PUTS_CACHE_NAME = "pending-puts";
 
 	private EmbeddedCacheManager manager;
 
 	private final Map<String, TypeOverrides> typeOverrides = new HashMap<String, TypeOverrides>();
 
 	private final Set<String> definedConfigurations = new HashSet<String>();
 
 	private org.infinispan.transaction.lookup.TransactionManagerLookup transactionManagerlookup;
 
 	private List<String> regionNames = new ArrayList<String>();
 
 	/**
 	 * Create a new instance using the default configuration.
 	 */
 	public InfinispanRegionFactory() {
 	}
 
 	/**
 	 * Create a new instance using conifguration properties in <code>props</code>.
 	 *
 	 * @param props Environmental properties; currently unused.
 	 */
 	@SuppressWarnings("UnusedParameters")
 	public InfinispanRegionFactory(Properties props) {
 	}
 
 	@Override
 	public CollectionRegion buildCollectionRegion(
 			String regionName,
 			Properties properties,
 			CacheDataDescription metadata) throws CacheException {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Building collection cache region [" + regionName + "]" );
 		}
 		final AdvancedCache cache = getCache( regionName, COLLECTION_KEY, properties );
 		final CollectionRegionImpl region = new CollectionRegionImpl( cache, regionName, metadata, this );
 		startRegion( region, regionName );
 		return region;
 	}
 
 	@Override
 	public EntityRegion buildEntityRegion(String regionName, Properties properties, CacheDataDescription metadata)
 			throws CacheException {
 		if ( log.isDebugEnabled() ) {
-			log.debugf( "Building entity cache region [%s] (mutable=%s, versioned=%s)", regionName, metadata.isMutable(), metadata.isVersioned());
+			log.debugf(
+					"Building entity cache region [%s] (mutable=%s, versioned=%s)",
+					regionName,
+					metadata.isMutable(),
+					metadata.isVersioned()
+			);
 		}
 		final AdvancedCache cache = getCache( regionName, metadata.isMutable() ? ENTITY_KEY : IMMUTABLE_ENTITY_KEY, properties );
 		final EntityRegionImpl region = new EntityRegionImpl( cache, regionName, metadata, this );
 		startRegion( region, regionName );
 		return region;
 	}
 
 	@Override
 	public NaturalIdRegion buildNaturalIdRegion(String regionName, Properties properties, CacheDataDescription metadata)
 			throws CacheException {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Building natural id cache region [" + regionName + "]" );
 		}
 		final AdvancedCache cache = getCache( regionName, NATURAL_ID_KEY, properties );
 		final NaturalIdRegionImpl region = new NaturalIdRegionImpl( cache, regionName, metadata, this );
 		startRegion( region, regionName );
 		return region;
 	}
 
 	@Override
 	public QueryResultsRegion buildQueryResultsRegion(String regionName, Properties properties)
 			throws CacheException {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Building query results cache region [" + regionName + "]" );
 		}
 		String cacheName = typeOverrides.get( QUERY_KEY ).getCacheName();
 		// If region name is not default one, lookup a cache for that region name
 		if ( !regionName.equals( "org.hibernate.cache.internal.StandardQueryCache" ) ) {
 			cacheName = regionName;
 		}
 
 		final AdvancedCache cache = getCache( cacheName, QUERY_KEY, properties );
 		final QueryResultsRegionImpl region = new QueryResultsRegionImpl( cache, regionName, this );
 		startRegion( region, regionName );
 		return region;
 	}
 
 	@Override
 	public TimestampsRegion buildTimestampsRegion(String regionName, Properties properties)
 			throws CacheException {
 		if ( log.isDebugEnabled() ) {
 			log.debug( "Building timestamps cache region [" + regionName + "]" );
 		}
 		final AdvancedCache cache = getCache( regionName, TIMESTAMPS_KEY, properties );
 		final TimestampsRegionImpl region = createTimestampsRegion( cache, regionName );
 		startRegion( region, regionName );
 		return region;
 	}
 
 	protected TimestampsRegionImpl createTimestampsRegion(
 			AdvancedCache cache, String regionName) {
 		if ( Caches.isClustered( cache ) ) {
 			return new ClusteredTimestampsRegionImpl( cache, regionName, this );
 		}
 		else {
 			return new TimestampsRegionImpl( cache, regionName, this );
 		}
 	}
 
 	@Override
 	public boolean isMinimalPutsEnabledByDefault() {
 		return true;
 	}
 
 	@Override
 	public AccessType getDefaultAccessType() {
 		return AccessType.TRANSACTIONAL;
 	}
 
 	@Override
 	public long nextTimestamp() {
 		return System.currentTimeMillis() / 100;
 	}
 
 	public void setCacheManager(EmbeddedCacheManager manager) {
 		this.manager = manager;
 	}
 
 	public EmbeddedCacheManager getCacheManager() {
 		return manager;
 	}
 
 	@Override
 	public void start(SessionFactoryOptions settings, Properties properties) throws CacheException {
 		log.debug( "Starting Infinispan region factory" );
 		try {
 			transactionManagerlookup = createTransactionManagerLookup( settings, properties );
-			manager = createCacheManager( properties );
+			manager = createCacheManager( properties, settings.getServiceRegistry() );
 			initGenericDataTypeOverrides();
 			final Enumeration keys = properties.propertyNames();
 			while ( keys.hasMoreElements() ) {
 				final String key = (String) keys.nextElement();
 				int prefixLoc;
 				if ( (prefixLoc = key.indexOf( PREFIX )) != -1 ) {
 					dissectProperty( prefixLoc, key, properties );
 				}
 			}
 			defineGenericDataTypeCacheConfigurations( properties );
 			definePendingPutsCache();
 		}
 		catch (CacheException ce) {
 			throw ce;
 		}
 		catch (Throwable t) {
 			throw new CacheException( "Unable to start region factory", t );
 		}
 	}
 
 	private void definePendingPutsCache() {
 		final ConfigurationBuilder builder = new ConfigurationBuilder();
 		// A local, lightweight cache for pending puts, which is
 		// non-transactional and has aggressive expiration settings.
 		// Locking is still required since the putFromLoad validator
 		// code uses conditional operations (i.e. putIfAbsent).
 		builder.clustering().cacheMode( CacheMode.LOCAL )
 				.transaction().transactionMode( TransactionMode.NON_TRANSACTIONAL )
 				.expiration().maxIdle( TimeUnit.SECONDS.toMillis( 60 ) )
 				.storeAsBinary().enabled( false )
 				.locking().isolationLevel( IsolationLevel.READ_COMMITTED )
 				.jmxStatistics().disable();
 
 		manager.defineConfiguration( PENDING_PUTS_CACHE_NAME, builder.build() );
 	}
 
 	protected org.infinispan.transaction.lookup.TransactionManagerLookup createTransactionManagerLookup(
 			SessionFactoryOptions settings, Properties properties) {
 		return new HibernateTransactionManagerLookup( settings, properties );
 	}
 
 	@Override
 	public void stop() {
 		log.debug( "Stop region factory" );
 		stopCacheRegions();
 		stopCacheManager();
 	}
 
 	protected void stopCacheRegions() {
 		log.debug( "Clear region references" );
 		getCacheCommandFactory( manager.getCache().getAdvancedCache() )
 				.clearRegions( regionNames );
 		regionNames.clear();
 	}
 
 	protected void stopCacheManager() {
 		log.debug( "Stop cache manager" );
 		manager.stop();
 	}
 
 	/**
 	 * Returns an unmodifiable map containing configured entity/collection type configuration overrides.
 	 * This method should be used primarily for testing/checking purpouses.
 	 *
 	 * @return an unmodifiable map.
 	 */
 	public Map<String, TypeOverrides> getTypeOverrides() {
 		return Collections.unmodifiableMap( typeOverrides );
 	}
 
 	public Set<String> getDefinedConfigurations() {
 		return Collections.unmodifiableSet( definedConfigurations );
 	}
 
-	protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
-		try {
-			final String configLoc = ConfigurationHelper.getString(
-					INFINISPAN_CONFIG_RESOURCE_PROP, properties, DEF_INFINISPAN_CONFIG_RESOURCE
-			);
-			ClassLoader classLoader = ClassLoaderHelper.getContextClassLoader();
-			InputStream is;
-			try {
-				is = FileLookupFactory.newInstance().lookupFileStrict( configLoc, classLoader );
-			}
-			catch (FileNotFoundException e) {
-				// In some environments (ex: OSGi), hibernate-infinispan may not
-				// be in the app CL.  It's important to also try this CL.
-				classLoader = this.getClass().getClassLoader();
-				is = FileLookupFactory.newInstance().lookupFileStrict( configLoc, classLoader );
-			}
-			final ParserRegistry parserRegistry = new ParserRegistry( classLoader );
-			final ConfigurationBuilderHolder holder = parserRegistry.parse( is );
-
-			// Override global jmx statistics exposure
-			final String globalStats = extractProperty( INFINISPAN_GLOBAL_STATISTICS_PROP, properties );
-			if ( globalStats != null ) {
-				holder.getGlobalConfigurationBuilder().globalJmxStatistics()
-						.enabled( Boolean.parseBoolean( globalStats ) );
-			}
+	protected EmbeddedCacheManager createCacheManager(
+			final Properties properties,
+			final ServiceRegistry serviceRegistry) throws CacheException {
+		final String configLoc = ConfigurationHelper.getString(
+				INFINISPAN_CONFIG_RESOURCE_PROP,
+				properties,
+				DEF_INFINISPAN_CONFIG_RESOURCE
+		);
 
-			return createCacheManager( holder );
-		}
-		catch (IOException e) {
-			throw new CacheException( "Unable to create default cache manager", e );
-		}
+		return serviceRegistry.getService( ClassLoaderService.class ).workWithClassLoader(
+				new ClassLoaderService.Work<EmbeddedCacheManager>() {
+					@Override
+					public EmbeddedCacheManager doWork(ClassLoader classLoader) {
+						try {
+							InputStream is;
+							try {
+								is = FileLookupFactory.newInstance().lookupFileStrict( configLoc, classLoader );
+							}
+							catch (FileNotFoundException e) {
+								// In some environments (ex: OSGi), hibernate-infinispan may not
+								// be in the app CL.  It's important to also try this CL.
+								classLoader = this.getClass().getClassLoader();
+								is = FileLookupFactory.newInstance().lookupFileStrict( configLoc, classLoader );
+							}
+							final ParserRegistry parserRegistry = new ParserRegistry( classLoader );
+							final ConfigurationBuilderHolder holder = parserRegistry.parse( is );
+
+							// Override global jmx statistics exposure
+							final String globalStats = extractProperty(
+									INFINISPAN_GLOBAL_STATISTICS_PROP,
+									properties
+							);
+							if ( globalStats != null ) {
+								holder.getGlobalConfigurationBuilder()
+										.globalJmxStatistics()
+										.enabled( Boolean.parseBoolean( globalStats ) );
+							}
+
+							return createCacheManager( holder );
+						}
+						catch (IOException e) {
+							throw new CacheException( "Unable to create default cache manager", e );
+						}
+					}
+				}
+		);
 	}
 
-	protected EmbeddedCacheManager createCacheManager(
-			ConfigurationBuilderHolder holder) {
+	protected EmbeddedCacheManager createCacheManager(ConfigurationBuilderHolder holder) {
 		return new DefaultCacheManager( holder, true );
 	}
 
 	private void startRegion(BaseRegion region, String regionName) {
 		regionNames.add( regionName );
 		getCacheCommandFactory( region.getCache() ).addRegion( regionName, region );
 	}
 
 	private Map<String, TypeOverrides> initGenericDataTypeOverrides() {
 		final TypeOverrides entityOverrides = new TypeOverrides();
 		entityOverrides.setCacheName( DEF_ENTITY_RESOURCE );
 		typeOverrides.put( ENTITY_KEY, entityOverrides );
 		final TypeOverrides immutableEntityOverrides = new TypeOverrides();
 		immutableEntityOverrides.setCacheName( DEF_IMMUTABLE_ENTITY_RESOURCE );
 		typeOverrides.put( IMMUTABLE_ENTITY_KEY, immutableEntityOverrides );
 		final TypeOverrides collectionOverrides = new TypeOverrides();
 		collectionOverrides.setCacheName( DEF_ENTITY_RESOURCE );
 		typeOverrides.put( COLLECTION_KEY, collectionOverrides );
 		final TypeOverrides naturalIdOverrides = new TypeOverrides();
 		naturalIdOverrides.setCacheName( DEF_ENTITY_RESOURCE );
 		typeOverrides.put( NATURAL_ID_KEY, naturalIdOverrides );
 		final TypeOverrides timestampOverrides = new TimestampTypeOverrides();
 		timestampOverrides.setCacheName( DEF_TIMESTAMPS_RESOURCE );
 		typeOverrides.put( TIMESTAMPS_KEY, timestampOverrides );
 		final TypeOverrides queryOverrides = new TypeOverrides();
 		queryOverrides.setCacheName( DEF_QUERY_RESOURCE );
 		typeOverrides.put( QUERY_KEY, queryOverrides );
 		return typeOverrides;
 	}
 
 	private void dissectProperty(int prefixLoc, String key, Properties properties) {
 		final TypeOverrides cfgOverride;
 		int suffixLoc;
 		if ( !key.equals( INFINISPAN_CONFIG_RESOURCE_PROP ) && (suffixLoc = key.indexOf( CONFIG_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setCacheName( extractProperty( key, properties ) );
 		}
 		else if ( (suffixLoc = key.indexOf( STRATEGY_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setEvictionStrategy( extractProperty( key, properties ) );
 		}
 		else if ( (suffixLoc = key.indexOf( WAKE_UP_INTERVAL_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setEvictionWakeUpInterval( Long.parseLong( extractProperty( key, properties ) ) );
 		}
 		else if ( (suffixLoc = key.indexOf( MAX_ENTRIES_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setEvictionMaxEntries( Integer.parseInt( extractProperty( key, properties ) ) );
 		}
 		else if ( (suffixLoc = key.indexOf( LIFESPAN_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setExpirationLifespan( Long.parseLong( extractProperty( key, properties ) ) );
 		}
 		else if ( (suffixLoc = key.indexOf( MAX_IDLE_SUFFIX )) != -1 ) {
 			cfgOverride = getOrCreateConfig( prefixLoc, key, suffixLoc );
 			cfgOverride.setExpirationMaxIdle( Long.parseLong( extractProperty( key, properties ) ) );
 		}
 	}
 
 	private String extractProperty(String key, Properties properties) {
 		final String value = ConfigurationHelper.extractPropertyValue( key, properties );
 		log.debugf( "Configuration override via property %s: %s", key, value );
 		return value;
 	}
 
 	private TypeOverrides getOrCreateConfig(int prefixLoc, String key, int suffixLoc) {
 		final String name = key.substring( prefixLoc + PREFIX.length(), suffixLoc );
 		TypeOverrides cfgOverride = typeOverrides.get( name );
 		if ( cfgOverride == null ) {
 			cfgOverride = new TypeOverrides();
 			typeOverrides.put( name, cfgOverride );
 		}
 		return cfgOverride;
 	}
 
 	private void defineGenericDataTypeCacheConfigurations(Properties properties) {
 		final String[] defaultGenericDataTypes = new String[] {ENTITY_KEY, IMMUTABLE_ENTITY_KEY, COLLECTION_KEY, TIMESTAMPS_KEY, QUERY_KEY};
 		for ( String type : defaultGenericDataTypes ) {
 			final TypeOverrides override = overrideStatisticsIfPresent( typeOverrides.get( type ), properties );
 			final String cacheName = override.getCacheName();
 			final ConfigurationBuilder builder = new ConfigurationBuilder();
 			// Read base configuration
 			applyConfiguration( cacheName, builder );
 
 			// Apply overrides
 			override.applyTo( builder );
 			// Configure transaction manager
 			configureTransactionManager( builder, cacheName, properties );
 			// Define configuration, validate and then apply
 			final Configuration cfg = builder.build();
 			override.validateInfinispanConfiguration( cfg );
 			manager.defineConfiguration( cacheName, cfg );
 			definedConfigurations.add( cacheName );
 		}
 	}
 
 	private AdvancedCache getCache(String regionName, String typeKey, Properties properties) {
 		TypeOverrides regionOverride = typeOverrides.get( regionName );
 		if ( !definedConfigurations.contains( regionName ) ) {
 			final String templateCacheName;
 			final ConfigurationBuilder builder = new ConfigurationBuilder();
 			if ( regionOverride != null ) {
 				if ( log.isDebugEnabled() ) {
 					log.debug( "Cache region specific configuration exists: " + regionOverride );
 				}
 				final String cacheName = regionOverride.getCacheName();
 				if ( cacheName != null ) {
 					// Region specific override with a given cache name
 					templateCacheName = cacheName;
 				}
 				else {
 					// Region specific override without cache name, so template cache name is generic for data type.
 					templateCacheName = typeOverrides.get( typeKey ).getCacheName();
 				}
 
 				// Read template configuration
 				applyConfiguration( templateCacheName, builder );
 
 				regionOverride = overrideStatisticsIfPresent( regionOverride, properties );
 				regionOverride.applyTo( builder );
 
 			}
 			else {
 				// No region specific overrides, template cache name is generic for data type.
 				templateCacheName = typeOverrides.get( typeKey ).getCacheName();
 				// Read template configuration
 				builder.read( manager.getCacheConfiguration( templateCacheName ) );
 				// Apply overrides
 				typeOverrides.get( typeKey ).applyTo( builder );
 			}
 			// Configure transaction manager
 			configureTransactionManager( builder, templateCacheName, properties );
 			// Define configuration
 			manager.defineConfiguration( regionName, builder.build() );
 			definedConfigurations.add( regionName );
 		}
 		final AdvancedCache cache = manager.getCache( regionName ).getAdvancedCache();
 		if ( !cache.getStatus().allowInvocations() ) {
 			cache.start();
 		}
 		return createCacheWrapper( cache );
 	}
 
 	private void applyConfiguration(String cacheName, ConfigurationBuilder builder) {
 		final Configuration cfg = manager.getCacheConfiguration( cacheName );
 		if ( cfg != null ) {
 			builder.read( cfg );
 		}
 	}
 
 	private CacheCommandFactory getCacheCommandFactory(AdvancedCache cache) {
 		final GlobalComponentRegistry globalCr = cache.getComponentRegistry().getGlobalComponentRegistry();
 
 		final Map<Byte, ModuleCommandFactory> factories =
 				(Map<Byte, ModuleCommandFactory>) globalCr.getComponent( "org.infinispan.modules.command.factories" );
 
 		for ( ModuleCommandFactory factory : factories.values() ) {
 			if ( factory instanceof CacheCommandFactory ) {
 				return (CacheCommandFactory) factory;
 			}
 		}
 
 		throw new CacheException(
 				"Infinispan custom cache command factory not " +
 						"installed (possibly because the classloader where Infinispan " +
 						"lives couldn't find the Hibernate Infinispan cache provider)"
 		);
 	}
 
 	protected AdvancedCache createCacheWrapper(AdvancedCache cache) {
 		return cache;
 	}
 
 	private void configureTransactionManager(
 			ConfigurationBuilder builder,
 			String cacheName,
 			Properties properties) {
 		// Get existing configuration to verify whether a tm was configured or not.
 		final Configuration baseCfg = manager.getCacheConfiguration( cacheName );
 		if ( baseCfg != null && baseCfg.transaction().transactionMode().isTransactional() ) {
 			final String ispnTmLookupClassName = baseCfg.transaction().transactionManagerLookup().getClass().getName();
 			final String hbTmLookupClassName = org.hibernate.cache.infinispan.tm.HibernateTransactionManagerLookup.class.getName();
 			if ( GenericTransactionManagerLookup.class.getName().equals( ispnTmLookupClassName ) ) {
 				log.debug(
 						"Using default Infinispan transaction manager lookup " +
 								"instance (GenericTransactionManagerLookup), overriding it " +
 								"with Hibernate transaction manager lookup"
 				);
 				builder.transaction().transactionManagerLookup( transactionManagerlookup );
 			}
 			else if ( ispnTmLookupClassName != null && !ispnTmLookupClassName.equals( hbTmLookupClassName ) ) {
 				log.debug(
 						"Infinispan is configured [" + ispnTmLookupClassName + "] with a different transaction manager lookup " +
 								"class than Hibernate [" + hbTmLookupClassName + "]"
 				);
 			}
 			else {
 				// Infinispan TM lookup class null, so apply Hibernate one directly
 				builder.transaction().transactionManagerLookup( transactionManagerlookup );
 			}
 
 			final String useSyncProp = extractProperty( INFINISPAN_USE_SYNCHRONIZATION_PROP, properties );
 			final boolean useSync = useSyncProp == null ? DEF_USE_SYNCHRONIZATION : Boolean.parseBoolean( useSyncProp );
 			builder.transaction().useSynchronization( useSync );
 		}
 	}
 
 	private TypeOverrides overrideStatisticsIfPresent(TypeOverrides override, Properties properties) {
 		final String globalStats = extractProperty( INFINISPAN_GLOBAL_STATISTICS_PROP, properties );
 		if ( globalStats != null ) {
 			override.setExposeStatistics( Boolean.parseBoolean( globalStats ) );
 		}
 		return override;
 	}
 }
diff --git a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/JndiInfinispanRegionFactory.java b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/JndiInfinispanRegionFactory.java
index 2a67bb7703..a4ed1e5ac2 100644
--- a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/JndiInfinispanRegionFactory.java
+++ b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/JndiInfinispanRegionFactory.java
@@ -1,93 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.cache.infinispan;
 
 import java.util.Properties;
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.naming.NamingException;
 
 import org.hibernate.cache.CacheException;
+import org.hibernate.engine.jndi.spi.JndiService;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.internal.util.jndi.JndiHelper;
+import org.hibernate.service.ServiceRegistry;
 
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
 /**
  * A {@link org.hibernate.cache.spi.RegionFactory} for <a href="http://www.jboss.org/infinispan">Infinispan</a>-backed cache
  * regions that finds its cache manager in JNDI rather than creating one itself.
  *
  * @author Galder Zamarreño
  * @since 3.5
  */
 public class JndiInfinispanRegionFactory extends InfinispanRegionFactory {
 
 	private static final Log log = LogFactory.getLog( JndiInfinispanRegionFactory.class );
 
 	/**
 	 * Specifies the JNDI name under which the {@link EmbeddedCacheManager} to use is bound.
 	 * There is no default value -- the user must specify the property.
 	 */
 	public static final String CACHE_MANAGER_RESOURCE_PROP = "hibernate.cache.infinispan.cachemanager";
 
 	/**
 	 * Constructs a JndiInfinispanRegionFactory
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public JndiInfinispanRegionFactory() {
 		super();
 	}
 
 	/**
 	 * Constructs a JndiInfinispanRegionFactory
 	 *
 	 * @param props Any properties to apply (not used).
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public JndiInfinispanRegionFactory(Properties props) {
 		super( props );
 	}
 
 	@Override
-	protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
+	protected EmbeddedCacheManager createCacheManager(
+			Properties properties,
+			ServiceRegistry serviceRegistry) throws CacheException {
 		final String name = ConfigurationHelper.getString( CACHE_MANAGER_RESOURCE_PROP, properties, null );
 		if ( name == null ) {
 			throw new CacheException( "Configuration property " + CACHE_MANAGER_RESOURCE_PROP + " not set" );
 		}
 		return locateCacheManager( name, JndiHelper.extractJndiProperties( properties ) );
 	}
 
 	private EmbeddedCacheManager locateCacheManager(String jndiNamespace, Properties jndiProperties) {
 		Context ctx = null;
 		try {
 			ctx = new InitialContext( jndiProperties );
 			return (EmbeddedCacheManager) ctx.lookup( jndiNamespace );
 		}
 		catch (NamingException ne) {
 			final String msg = "Unable to retrieve CacheManager from JNDI [" + jndiNamespace + "]";
 			log.info( msg, ne );
 			throw new CacheException( msg );
 		}
 		finally {
 			if ( ctx != null ) {
 				try {
 					ctx.close();
 				}
 				catch (NamingException ne) {
 					log.info( "Unable to release initial context", ne );
 				}
 			}
 		}
 	}
 
 	@Override
 	public void stop() {
 		// Do not attempt to stop a cache manager because it wasn't created by this region factory.
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
index f58a4e0c37..be691cf975 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
@@ -1,594 +1,613 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.test.cache.infinispan;
 
+import java.util.Properties;
+import javax.transaction.TransactionManager;
+
+import org.hibernate.boot.internal.SessionFactoryBuilderImpl;
+import org.hibernate.boot.internal.SessionFactoryOptionsImpl;
 import org.hibernate.boot.spi.SessionFactoryOptions;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.collection.CollectionRegionImpl;
 import org.hibernate.cache.infinispan.entity.EntityRegionImpl;
 import org.hibernate.cache.infinispan.query.QueryResultsRegionImpl;
 import org.hibernate.cache.infinispan.timestamp.TimestampsRegionImpl;
 import org.hibernate.cache.infinispan.tm.HibernateTransactionManagerLookup;
 import org.hibernate.cache.internal.CacheDataDescriptionImpl;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform;
 import org.hibernate.engine.transaction.jta.platform.internal.JBossStandAloneJtaPlatform;
-import org.hibernate.test.cache.infinispan.functional.SingleNodeTestCase;
+import org.hibernate.service.ServiceRegistry;
+
 import org.hibernate.testing.ServiceRegistryBuilder;
+import org.hibernate.test.cache.infinispan.functional.SingleNodeTestCase;
+import org.hibernate.testing.boot.ServiceRegistryTestingImpl;
+import org.junit.Test;
+
 import org.infinispan.AdvancedCache;
 import org.infinispan.configuration.cache.CacheMode;
 import org.infinispan.configuration.cache.Configuration;
 import org.infinispan.configuration.cache.ConfigurationBuilder;
 import org.infinispan.configuration.global.GlobalConfigurationBuilder;
 import org.infinispan.eviction.EvictionStrategy;
 import org.infinispan.manager.DefaultCacheManager;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.test.TestingUtil;
 import org.infinispan.transaction.TransactionMode;
-import org.junit.Test;
-
-import javax.transaction.TransactionManager;
-import java.util.Properties;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * InfinispanRegionFactoryTestCase.
  * 
  * @author Galder Zamarreño
  * @since 3.5
  */
 public class InfinispanRegionFactoryTestCase  {
    private static CacheDataDescription MUTABLE_NON_VERSIONED = new CacheDataDescriptionImpl(true, false, null);
    private static CacheDataDescription IMMUTABLE_NON_VERSIONED = new CacheDataDescriptionImpl(false, false, null);
 
    @Test
    public void testConfigurationProcessing() {
       final String person = "com.acme.Person";
       final String addresses = "com.acme.Person.addresses";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.cfg", "person-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval", "2000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.max_entries", "5000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.cfg", "person-addresses-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.lifespan", "120000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.max_idle", "60000");
       p.setProperty("hibernate.cache.infinispan.query.cfg", "my-query-cache");
       p.setProperty("hibernate.cache.infinispan.query.eviction.strategy", "LIRS");
       p.setProperty("hibernate.cache.infinispan.query.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.query.eviction.max_entries", "10000");
 
       InfinispanRegionFactory factory = createRegionFactory(p);
 
       try {
          assertEquals("entity", factory.getTypeOverrides().get("entity").getCacheName());
          assertEquals("entity", factory.getTypeOverrides().get("collection").getCacheName());
          assertEquals("timestamps", factory.getTypeOverrides().get("timestamps").getCacheName());
 
          assertEquals("person-cache", factory.getTypeOverrides().get(person).getCacheName());
          assertEquals(EvictionStrategy.LRU, factory.getTypeOverrides().get(person).getEvictionStrategy());
          assertEquals(2000, factory.getTypeOverrides().get(person).getEvictionWakeUpInterval());
          assertEquals(5000, factory.getTypeOverrides().get(person).getEvictionMaxEntries());
          assertEquals(60000, factory.getTypeOverrides().get(person).getExpirationLifespan());
          assertEquals(30000, factory.getTypeOverrides().get(person).getExpirationMaxIdle());
 
          assertEquals("person-addresses-cache", factory.getTypeOverrides().get(addresses).getCacheName());
          assertEquals(120000, factory.getTypeOverrides().get(addresses).getExpirationLifespan());
          assertEquals(60000, factory.getTypeOverrides().get(addresses).getExpirationMaxIdle());
 
          assertEquals("my-query-cache", factory.getTypeOverrides().get("query").getCacheName());
          assertEquals(EvictionStrategy.LIRS, factory.getTypeOverrides().get("query").getEvictionStrategy());
          assertEquals(3000, factory.getTypeOverrides().get("query").getEvictionWakeUpInterval());
          assertEquals(10000, factory.getTypeOverrides().get("query").getEvictionMaxEntries());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildEntityCollectionRegionsPersonPlusEntityCollectionOverrides() {
       final String person = "com.acme.Person";
       final String address = "com.acme.Address";
       final String car = "com.acme.Car";
       final String addresses = "com.acme.Person.addresses";
       final String parts = "com.acme.Car.parts";
       Properties p = createProperties();
       // First option, cache defined for entity and overrides for generic entity data type and entity itself.
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.cfg", "person-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval", "2000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.max_entries", "5000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "LIRS");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "20000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.cfg", "addresses-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.strategy", "LIRS");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.wake_up_interval", "2500");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.max_entries", "5500");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.lifespan", "65000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.max_idle", "35000");
       p.setProperty("hibernate.cache.infinispan.collection.cfg", "mycollection-cache");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.wake_up_interval", "3500");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.max_entries", "25000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          EmbeddedCacheManager manager = factory.getCacheManager();
          assertFalse(manager.getCacheManagerConfiguration()
                .globalJmxStatistics().enabled());
          assertNotNull(factory.getTypeOverrides().get(person));
          assertFalse(factory.getDefinedConfigurations().contains(person));
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertFalse(factory.getDefinedConfigurations().contains(addresses));
          AdvancedCache cache;
 
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
          assertEquals(2000, cacheCfg.expiration().wakeUpInterval());
          assertEquals(5000, cacheCfg.eviction().maxEntries());
          assertEquals(60000, cacheCfg.expiration().lifespan());
          assertEquals(30000, cacheCfg.expiration().maxIdle());
          assertFalse(cacheCfg.jmxStatistics().enabled());
 
          region = (EntityRegionImpl) factory.buildEntityRegion(address, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
          assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
          assertEquals(20000, cacheCfg.eviction().maxEntries());
          assertFalse(cacheCfg.jmxStatistics().enabled());
 
          region = (EntityRegionImpl) factory.buildEntityRegion(car, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
          assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
          assertEquals(20000, cacheCfg.eviction().maxEntries());
          assertFalse(cacheCfg.jmxStatistics().enabled());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
                factory.buildCollectionRegion(addresses, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion .getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
          assertEquals(2500, cacheCfg.expiration().wakeUpInterval());
          assertEquals(5500, cacheCfg.eviction().maxEntries());
          assertEquals(65000, cacheCfg.expiration().lifespan());
          assertEquals(35000, cacheCfg.expiration().maxIdle());
          assertFalse(cacheCfg.jmxStatistics().enabled());
 
          collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion(parts, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(addresses));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion.getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
          assertEquals(3500, cacheCfg.expiration().wakeUpInterval());
          assertEquals(25000, cacheCfg.eviction().maxEntries());
          assertFalse(cacheCfg.jmxStatistics().enabled());
 
          collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion(parts, p, MUTABLE_NON_VERSIONED);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(addresses));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion.getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
          assertEquals(3500, cacheCfg.expiration().wakeUpInterval());
          assertEquals(25000, cacheCfg.eviction().maxEntries());
          assertFalse(cacheCfg.jmxStatistics().enabled());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildEntityCollectionRegionOverridesOnly() {
       AdvancedCache cache;
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "LIRS");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "30000");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.wake_up_interval", "3500");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.max_entries", "35000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          factory.getCacheManager();
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, MUTABLE_NON_VERSIONED);
          assertNull(factory.getTypeOverrides().get("com.acme.Address"));
          cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
          assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
          assertEquals(30000, cacheCfg.eviction().maxEntries());
          // Max idle value comes from base XML configuration
          assertEquals(100000, cacheCfg.expiration().maxIdle());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
                factory.buildCollectionRegion("com.acme.Person.addresses", p, MUTABLE_NON_VERSIONED);
          assertNull(factory.getTypeOverrides().get("com.acme.Person.addresses"));
          cache = collectionRegion.getCache();
          cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
          assertEquals(3500, cacheCfg.expiration().wakeUpInterval());
          assertEquals(35000, cacheCfg.eviction().maxEntries());
          assertEquals(100000, cacheCfg.expiration().maxIdle());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildEntityRegionPersonPlusEntityOverridesWithoutCfg() {
       final String person = "com.acme.Person";
       Properties p = createProperties();
       // Third option, no cache defined for entity and overrides for generic entity data type and entity itself.
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          factory.getCacheManager();
+         assertNotNull( factory.getTypeOverrides().get( person ) );
+         assertFalse( factory.getDefinedConfigurations().contains( person ) );
+         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion( person, p, MUTABLE_NON_VERSIONED );
          assertNotNull(factory.getTypeOverrides().get(person));
-         assertFalse(factory.getDefinedConfigurations().contains(person));
-         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, MUTABLE_NON_VERSIONED);
-         assertNotNull(factory.getTypeOverrides().get(person));
-         assertTrue(factory.getDefinedConfigurations().contains(person));
+         assertTrue( factory.getDefinedConfigurations().contains( person ) );
          AdvancedCache cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
          assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
          assertEquals(10000, cacheCfg.eviction().maxEntries());
          assertEquals(60000, cacheCfg.expiration().lifespan());
          assertEquals(30000, cacheCfg.expiration().maxIdle());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildImmutableEntityRegion() {
       AdvancedCache cache;
       Properties p = new Properties();
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          factory.getCacheManager();
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, IMMUTABLE_NON_VERSIONED);
-         assertNull(factory.getTypeOverrides().get("com.acme.Address"));
+         assertNull( factory.getTypeOverrides().get( "com.acme.Address" ) );
          cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals("Immutable entity should get non-transactional cache", TransactionMode.NON_TRANSACTIONAL, cacheCfg.transaction().transactionMode());
       } finally {
          factory.stop();
       }
    }
 
    @Test(expected = CacheException.class)
    public void testTimestampValidation() {
       Properties p = createProperties();
       final DefaultCacheManager manager = new DefaultCacheManager(GlobalConfigurationBuilder.defaultClusteredBuilder().build());
       try {
          InfinispanRegionFactory factory = createRegionFactory(manager, p);
          ConfigurationBuilder builder = new ConfigurationBuilder();
          builder.clustering().cacheMode(CacheMode.INVALIDATION_SYNC);
-         manager.defineConfiguration("timestamps", builder.build());
+         manager.defineConfiguration( "timestamps", builder.build() );
          factory.start(null, p);
-         fail("Should have failed saying that invalidation is not allowed for timestamp caches.");
+         fail( "Should have failed saying that invalidation is not allowed for timestamp caches." );
       } finally {
-         TestingUtil.killCacheManagers(manager);
+         TestingUtil.killCacheManagers( manager );
       }
    }
 
    @Test
    public void testBuildDefaultTimestampsRegion() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = createProperties();
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          assertTrue(factory.getDefinedConfigurations().contains("timestamps"));
          assertTrue(factory.getTypeOverrides().get("timestamps")
                .getCacheName().equals("timestamps"));
          TimestampsRegionImpl region = (TimestampsRegionImpl)
                factory.buildTimestampsRegion(timestamps, p);
          AdvancedCache cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
-         assertEquals(EvictionStrategy.NONE, cacheCfg.eviction().strategy());
-         assertEquals(CacheMode.REPL_ASYNC, cacheCfg.clustering().cacheMode());
-         assertFalse(cacheCfg.jmxStatistics().enabled());
+         assertEquals( EvictionStrategy.NONE, cacheCfg.eviction().strategy() );
+         assertEquals( CacheMode.REPL_ASYNC, cacheCfg.clustering().cacheMode() );
+         assertFalse( cacheCfg.jmxStatistics().enabled() );
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildDiffCacheNameTimestampsRegion() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "unrecommended-timestamps");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          EmbeddedCacheManager manager = factory.getCacheManager();
          assertFalse(factory.getDefinedConfigurations().contains("timestamp"));
          assertTrue(factory.getDefinedConfigurations().contains("unrecommended-timestamps"));
          assertTrue(factory.getTypeOverrides().get("timestamps").getCacheName().equals("unrecommended-timestamps"));
          ConfigurationBuilder builder = new ConfigurationBuilder();
          builder.clustering().stateTransfer().fetchInMemoryState(true);
-         builder.clustering().cacheMode(CacheMode.REPL_SYNC);
-         manager.defineConfiguration("unrecommended-timestamps", builder.build());
+         builder.clustering().cacheMode( CacheMode.REPL_SYNC );
+         manager.defineConfiguration( "unrecommended-timestamps", builder.build() );
          TimestampsRegionImpl region = (TimestampsRegionImpl) factory.buildTimestampsRegion(timestamps, p);
          AdvancedCache cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.NONE, cacheCfg.eviction().strategy());
          assertEquals(CacheMode.REPL_SYNC, cacheCfg.clustering().cacheMode());
-         assertFalse(cacheCfg.storeAsBinary().enabled());
+         assertFalse( cacheCfg.storeAsBinary().enabled() );
          assertFalse(cacheCfg.jmxStatistics().enabled());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildTimestamRegionWithCacheNameOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "mytimestamps-cache");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          factory.buildTimestampsRegion(timestamps, p);
          assertTrue(factory.getDefinedConfigurations().contains("mytimestamps-cache"));
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildTimestamRegionWithFifoEvictionOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "mytimestamps-cache");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = null;
       try {
          factory = createRegionFactory(p);
          factory.buildTimestampsRegion(timestamps, p);
-         assertTrue(factory.getDefinedConfigurations().contains("mytimestamps-cache"));
-         fail("Should fail cos no eviction configurations are allowed for timestamp caches");
+         assertTrue( factory.getDefinedConfigurations().contains( "mytimestamps-cache" ) );
+         fail( "Should fail cos no eviction configurations are allowed for timestamp caches" );
       } catch(CacheException ce) {
       } finally {
          if (factory != null) factory.stop();
       }
    }
 
    @Test
    public void testBuildTimestamRegionWithNoneEvictionOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "timestamps-none-eviction");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.strategy", "NONE");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.max_entries", "0");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
-         factory.buildTimestampsRegion(timestamps, p);
-         assertTrue(factory.getDefinedConfigurations().contains("timestamps-none-eviction"));
+         factory.buildTimestampsRegion( timestamps, p );
+         assertTrue( factory.getDefinedConfigurations().contains( "timestamps-none-eviction" ) );
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildQueryRegion() {
       final String query = "org.hibernate.cache.internal.StandardQueryCache";
       Properties p = createProperties();
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          assertTrue(factory.getDefinedConfigurations().contains("local-query"));
          QueryResultsRegionImpl region = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(query, p);
          AdvancedCache cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
-         assertEquals(CacheMode.LOCAL, cacheCfg.clustering().cacheMode());
-         assertFalse(cacheCfg.jmxStatistics().enabled());
+         assertEquals( CacheMode.LOCAL, cacheCfg.clustering().cacheMode() );
+         assertFalse( cacheCfg.jmxStatistics().enabled() );
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildQueryRegionWithCustomRegionName() {
       final String queryRegionName = "myquery";
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.myquery.cfg", "timestamps-none-eviction");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.strategy", "LIRS");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.wake_up_interval", "2222");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.max_entries", "11111");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          assertTrue(factory.getDefinedConfigurations().contains("local-query"));
          QueryResultsRegionImpl region = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(queryRegionName, p);
          assertNotNull(factory.getTypeOverrides().get(queryRegionName));
          assertTrue(factory.getDefinedConfigurations().contains(queryRegionName));
          AdvancedCache cache = region.getCache();
          Configuration cacheCfg = cache.getCacheConfiguration();
          assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
          assertEquals(2222, cacheCfg.expiration().wakeUpInterval());
-         assertEquals(11111, cacheCfg.eviction().maxEntries());
+         assertEquals( 11111, cacheCfg.eviction().maxEntries() );
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testEnableStatistics() {
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.statistics", "true");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          EmbeddedCacheManager manager = factory.getCacheManager();
          assertTrue(manager.getCacheManagerConfiguration().globalJmxStatistics().enabled());
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, MUTABLE_NON_VERSIONED);
          AdvancedCache cache = region.getCache();
          assertTrue(factory.getTypeOverrides().get("entity").isExposeStatistics());
          assertTrue(cache.getCacheConfiguration().jmxStatistics().enabled());
 
          region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Person", p, MUTABLE_NON_VERSIONED);
          cache = region.getCache();
          assertTrue(factory.getTypeOverrides().get("com.acme.Person").isExposeStatistics());
          assertTrue(cache.getCacheConfiguration().jmxStatistics().enabled());
 
          final String query = "org.hibernate.cache.internal.StandardQueryCache";
          QueryResultsRegionImpl queryRegion = (QueryResultsRegionImpl)
                factory.buildQueryResultsRegion(query, p);
          cache = queryRegion.getCache();
          assertTrue(factory.getTypeOverrides().get("query").isExposeStatistics());
          assertTrue(cache.getCacheConfiguration().jmxStatistics().enabled());
 
          final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
          ConfigurationBuilder builder = new ConfigurationBuilder();
          builder.clustering().stateTransfer().fetchInMemoryState(true);
          manager.defineConfiguration("timestamps", builder.build());
          TimestampsRegionImpl timestampsRegion = (TimestampsRegionImpl)
                factory.buildTimestampsRegion(timestamps, p);
          cache = timestampsRegion.getCache();
          assertTrue(factory.getTypeOverrides().get("timestamps").isExposeStatistics());
          assertTrue(cache.getCacheConfiguration().jmxStatistics().enabled());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
                factory.buildCollectionRegion("com.acme.Person.addresses", p, MUTABLE_NON_VERSIONED);
          cache = collectionRegion.getCache();
          assertTrue(factory.getTypeOverrides().get("collection").isExposeStatistics());
          assertTrue(cache.getCacheConfiguration().jmxStatistics().enabled());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testDisableStatistics() {
       Properties p = createProperties();
       p.setProperty("hibernate.cache.infinispan.statistics", "false");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, MUTABLE_NON_VERSIONED);
          AdvancedCache cache = region.getCache();
-         assertFalse(factory.getTypeOverrides().get("entity").isExposeStatistics());
-         assertFalse(cache.getCacheConfiguration().jmxStatistics().enabled());
+         assertFalse( factory.getTypeOverrides().get( "entity" ).isExposeStatistics() );
+         assertFalse( cache.getCacheConfiguration().jmxStatistics().enabled() );
 
          region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Person", p, MUTABLE_NON_VERSIONED);
          cache = region.getCache();
-         assertFalse(factory.getTypeOverrides().get("com.acme.Person").isExposeStatistics());
-         assertFalse(cache.getCacheConfiguration().jmxStatistics().enabled());
+         assertFalse( factory.getTypeOverrides().get( "com.acme.Person" ).isExposeStatistics() );
+         assertFalse( cache.getCacheConfiguration().jmxStatistics().enabled() );
 
          final String query = "org.hibernate.cache.internal.StandardQueryCache";
          QueryResultsRegionImpl queryRegion = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(query, p);
          cache = queryRegion.getCache();
-         assertFalse(factory.getTypeOverrides().get("query").isExposeStatistics());
-         assertFalse(cache.getCacheConfiguration().jmxStatistics().enabled());
+         assertFalse( factory.getTypeOverrides().get( "query" ).isExposeStatistics() );
+         assertFalse( cache.getCacheConfiguration().jmxStatistics().enabled() );
 
          final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
          ConfigurationBuilder builder = new ConfigurationBuilder();
          builder.clustering().stateTransfer().fetchInMemoryState(true);
-         factory.getCacheManager().defineConfiguration("timestamps", builder.build());
+         factory.getCacheManager().defineConfiguration( "timestamps", builder.build() );
          TimestampsRegionImpl timestampsRegion = (TimestampsRegionImpl)
                factory.buildTimestampsRegion(timestamps, p);
          cache = timestampsRegion.getCache();
-         assertFalse(factory.getTypeOverrides().get("timestamps").isExposeStatistics());
-         assertFalse(cache.getCacheConfiguration().jmxStatistics().enabled());
+         assertFalse( factory.getTypeOverrides().get( "timestamps" ).isExposeStatistics() );
+         assertFalse( cache.getCacheConfiguration().jmxStatistics().enabled() );
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
                factory.buildCollectionRegion("com.acme.Person.addresses", p, MUTABLE_NON_VERSIONED);
          cache = collectionRegion.getCache();
-         assertFalse(factory.getTypeOverrides().get("collection").isExposeStatistics());
-         assertFalse(cache.getCacheConfiguration().jmxStatistics().enabled());
+         assertFalse( factory.getTypeOverrides().get( "collection" ).isExposeStatistics() );
+         assertFalse( cache.getCacheConfiguration().jmxStatistics().enabled() );
       } finally {
          factory.stop();
       }
    }
 
    private InfinispanRegionFactory createRegionFactory(Properties p) {
       return createRegionFactory(null, p);
    }
 
    private InfinispanRegionFactory createRegionFactory(final EmbeddedCacheManager manager, Properties p) {
       final InfinispanRegionFactory factory = new SingleNodeTestCase.TestInfinispanRegionFactory() {
 
          @Override
          protected org.infinispan.transaction.lookup.TransactionManagerLookup createTransactionManagerLookup(SessionFactoryOptions settings, Properties properties) {
             return new HibernateTransactionManagerLookup(null, null) {
                @Override
                public TransactionManager getTransactionManager() throws Exception {
                   AbstractJtaPlatform jta = new JBossStandAloneJtaPlatform();
                   jta.injectServices(ServiceRegistryBuilder.buildServiceRegistry());
                   return jta.getTransactionManager();
                }
             };
          }
 
          @Override
-         protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
+         protected EmbeddedCacheManager createCacheManager(Properties properties, ServiceRegistry serviceRegistry) throws CacheException {
             if (manager != null)
                return manager;
             else
-               return super.createCacheManager(properties);
+               return super.createCacheManager( properties, serviceRegistry);
          }
 
       };
 
-      factory.start(null, p);
+      factory.start( sfOptionsForStart(), p );
       return factory;
    }
 
+   private SessionFactoryOptions sfOptionsForStart() {
+      return new SessionFactoryOptionsImpl(
+              new SessionFactoryBuilderImpl.SessionFactoryOptionsStateStandardImpl(
+                      ServiceRegistryTestingImpl.forUnitTesting()
+              )
+      );
+   }
+
    private static Properties createProperties() {
       final Properties properties = new Properties();
       // If configured in the environment, add configuration file name to properties.
       final String cfgFileName =
               (String) Environment.getProperties().get( InfinispanRegionFactory.INFINISPAN_CONFIG_RESOURCE_PROP );
       if ( cfgFileName != null ) {
          properties.put( InfinispanRegionFactory.INFINISPAN_CONFIG_RESOURCE_PROP, cfgFileName );
       }
       return properties;
    }
 }
diff --git a/hibernate-osgi/src/main/java/org/hibernate/osgi/HibernateBundleActivator.java b/hibernate-osgi/src/main/java/org/hibernate/osgi/HibernateBundleActivator.java
index 66bdcccefe..733f15e247 100644
--- a/hibernate-osgi/src/main/java/org/hibernate/osgi/HibernateBundleActivator.java
+++ b/hibernate-osgi/src/main/java/org/hibernate/osgi/HibernateBundleActivator.java
@@ -1,97 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.osgi;
 
 import java.util.Dictionary;
 import java.util.Hashtable;
 import javax.persistence.spi.PersistenceProvider;
 
-import org.hibernate.Session;
 import org.hibernate.SessionFactory;
-import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.jpa.HibernatePersistenceProvider;
 
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
-import org.osgi.framework.FrameworkUtil;
 import org.osgi.framework.ServiceRegistration;
 
 /**
  * This BundleActivator provides three different uses of Hibernate in OSGi
  * environments:
  * 
  * 1.) Enterprise OSGi JPA: The OSGi container/runtime is in charge of managing
  *     all of the client bundles' persistence units.  The container/runtime is
  *     also in charge of creating and managing the EntityManagerFactory through a
  *     registered PersistenceProvider (this).
  * 2.) Un-managed OSGI JPA: Same as #1, but the container does not manage
  *     the persistence units.  Client bundles identify a typical
  *     PersistenceProvider, registered by this activator.
  * 3.) Client bundles create and manage their own SessionFactory.  A
  *     SessionFactory is registered as an OSGi ServiceFactory -- each requesting
  *     bundle gets its own instance of a SessionFactory.  The use of services,
  *     rather than manual building of the SessionFactory, is necessary to shield users
  *     from ClassLoader issues.  See {@link OsgiSessionFactoryService} for more
  *     information.
  * 
  * @author Brett Meyer
  * @author Tim Ward
  */
 @SuppressWarnings("UnusedDeclaration")
 public class HibernateBundleActivator implements BundleActivator {
-	
-	private OsgiClassLoader osgiClassLoader;
 	private OsgiServiceUtil osgiServiceUtil;
 	
 	private ServiceRegistration<?> persistenceProviderService;
 	private ServiceRegistration<?> sessionFactoryService;
 	
 	@Override
 	@SuppressWarnings("unchecked")
 	public void start(BundleContext context) throws Exception {
-		// build a ClassLoader that uses all the necessary OSGi bundles, and place it into
-		// a well-known location so internals can access it
-		osgiClassLoader = new OsgiClassLoader();
-		osgiClassLoader.addBundle( FrameworkUtil.getBundle( Session.class ) );
-		osgiClassLoader.addBundle( FrameworkUtil.getBundle( HibernatePersistenceProvider.class ) );
-		ClassLoaderHelper.overridenClassLoader = osgiClassLoader;
-		
 		osgiServiceUtil = new OsgiServiceUtil( context );
 
 		// Build a JtaPlatform specific for this OSGi context
 		final OsgiJtaPlatform osgiJtaPlatform = new OsgiJtaPlatform( osgiServiceUtil );
 
 		final Dictionary properties = new Hashtable();
 		// In order to support existing persistence.xml files, register using the legacy provider name.
 		properties.put( "javax.persistence.provider", HibernatePersistenceProvider.class.getName() );
 		persistenceProviderService = context.registerService(
 				PersistenceProvider.class.getName(),
-				new OsgiPersistenceProviderService( osgiClassLoader, osgiJtaPlatform, osgiServiceUtil ),
+				new OsgiPersistenceProviderService( osgiJtaPlatform, osgiServiceUtil ),
 				properties
 		);
 		sessionFactoryService = context.registerService(
 				SessionFactory.class.getName(),
-				new OsgiSessionFactoryService( osgiClassLoader, osgiJtaPlatform, osgiServiceUtil ),
+				new OsgiSessionFactoryService( osgiJtaPlatform, osgiServiceUtil ),
 				new Hashtable()
 		);
 	}
 
 	@Override
 	public void stop(BundleContext context) throws Exception {
-		osgiClassLoader.stop();
-		osgiClassLoader = null;
 		osgiServiceUtil.stop();
 		osgiServiceUtil = null;
 		
 		persistenceProviderService.unregister();
 		persistenceProviderService = null;
 		sessionFactoryService.unregister();
 		sessionFactoryService = null;
-
-		ClassLoaderHelper.overridenClassLoader = null;
 	}
 }
diff --git a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProviderService.java b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProviderService.java
index 93282795ab..04c4911a5a 100644
--- a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProviderService.java
+++ b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProviderService.java
@@ -1,51 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.osgi;
 
 import org.osgi.framework.Bundle;
 import org.osgi.framework.ServiceFactory;
 import org.osgi.framework.ServiceRegistration;
 
 /**
  * See the description on {@link OsgiSessionFactoryService}.  This class is similar, providing an
  * PersistenceProvider as an OSGi Service.
  * 
  * @author Brett Meyer
  * @author Tim Ward
  */
 public class OsgiPersistenceProviderService implements ServiceFactory {
-	private OsgiClassLoader osgiClassLoader;
 	private OsgiJtaPlatform osgiJtaPlatform;
 	private OsgiServiceUtil osgiServiceUtil;
 
 	/**
 	 * Constructs a OsgiPersistenceProviderService
 	 *
-	 * @param osgiClassLoader The OSGi-specific ClassLoader created in HibernateBundleActivator
 	 * @param osgiJtaPlatform The OSGi-specific JtaPlatform created in HibernateBundleActivator
-	 * @param context The OSGi context
 	 */
 	public OsgiPersistenceProviderService(
-			OsgiClassLoader osgiClassLoader,
 			OsgiJtaPlatform osgiJtaPlatform,
 			OsgiServiceUtil osgiServiceUtil) {
-		this.osgiClassLoader = osgiClassLoader;
 		this.osgiJtaPlatform = osgiJtaPlatform;
 		this.osgiServiceUtil = osgiServiceUtil;
 	}
 
 	@Override
 	public Object getService(Bundle requestingBundle, ServiceRegistration registration) {
-		return new OsgiPersistenceProvider( osgiClassLoader, osgiJtaPlatform, osgiServiceUtil, requestingBundle );
+		final OsgiClassLoader osgiClassLoader = new OsgiClassLoader();
+		osgiClassLoader.addBundle( requestingBundle );
+
+		// Some "boot time" code does still rely on TCCL.  "run time" code should all be using
+		// ClassLoaderService now.
+
+		final ClassLoader originalTccl = Thread.currentThread().getContextClassLoader();
+		Thread.currentThread().setContextClassLoader( osgiClassLoader );
+		try {
+			return new OsgiPersistenceProvider( osgiClassLoader, osgiJtaPlatform, osgiServiceUtil, requestingBundle );
+		}
+		finally {
+			Thread.currentThread().setContextClassLoader( originalTccl );
+		}
 	}
 
 	@Override
 	public void ungetService(Bundle requestingBundle, ServiceRegistration registration, Object service) {
 		// ?
 	}
 
 }
diff --git a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
index 1e63511f89..0dfeceb771 100644
--- a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
+++ b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
@@ -1,127 +1,141 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.osgi;
 
 import java.util.Collection;
 
 import org.hibernate.SessionFactory;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
 
 import org.jboss.logging.Logger;
 
 import org.osgi.framework.Bundle;
 import org.osgi.framework.ServiceFactory;
 import org.osgi.framework.ServiceRegistration;
 import org.osgi.framework.wiring.BundleWiring;
 
 /**
  * Hibernate 4.2 and 4.3 still heavily rely on TCCL for ClassLoading.  Although
  * our ClassLoaderService removed some of the reliance, access to the proper ClassLoader
  * via TCCL is still required in a few cases where we call out to external libs.  An OSGi
  * bundle manually creating a SessionFactory would require numerous ClassLoader
  * tricks (or may be impossible altogether).
  * <p/>
  * In order to fully control the TCCL issues and shield users from the
  * knowledge, we're requiring that bundles use this OSGi ServiceFactory.  It
  * configures and provides a SessionFactory as an OSGi service.
  * <p/>
  * Note that an OSGi ServiceFactory differs from a Service.  The ServiceFactory
  * allows individual instances of Services to be created and provided to
  * multiple client Bundles.
  *
  * @author Brett Meyer
  * @author Tim Ward
  */
 public class OsgiSessionFactoryService implements ServiceFactory {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
 			OsgiSessionFactoryService.class.getName());
-	
-	private OsgiClassLoader osgiClassLoader;
+
 	private OsgiJtaPlatform osgiJtaPlatform;
 	private OsgiServiceUtil osgiServiceUtil;
 
 	/**
 	 * Constructs a OsgiSessionFactoryService
 	 *
-	 * @param osgiClassLoader The OSGi-specific ClassLoader created in HibernateBundleActivator
 	 * @param osgiJtaPlatform The OSGi-specific JtaPlatform created in HibernateBundleActivator
 	 * @param osgiServiceUtil Util object built in HibernateBundleActivator
 	 */
-	public OsgiSessionFactoryService(
-			OsgiClassLoader osgiClassLoader,
-			OsgiJtaPlatform osgiJtaPlatform,
-			OsgiServiceUtil osgiServiceUtil) {
-		this.osgiClassLoader = osgiClassLoader;
+	public OsgiSessionFactoryService(OsgiJtaPlatform osgiJtaPlatform, OsgiServiceUtil osgiServiceUtil) {
 		this.osgiJtaPlatform = osgiJtaPlatform;
 		this.osgiServiceUtil = osgiServiceUtil;
 	}
 
 	@Override
 	public Object getService(Bundle requestingBundle, ServiceRegistration registration) {
+		final OsgiClassLoader osgiClassLoader = new OsgiClassLoader();
 		osgiClassLoader.addBundle( requestingBundle );
 
+		// Some "boot time" code does still rely on TCCL.  "run time" code should all be using
+		// ClassLoaderService now.
+
+		final ClassLoader originalTccl = Thread.currentThread().getContextClassLoader();
+		Thread.currentThread().setContextClassLoader( osgiClassLoader );
+		try {
+			return buildSessionFactory( requestingBundle, osgiClassLoader );
+		}
+		finally {
+			Thread.currentThread().setContextClassLoader( originalTccl );
+		}
+	}
+
+	private Object buildSessionFactory(
+			Bundle requestingBundle,
+			OsgiClassLoader osgiClassLoader) {
 		final BootstrapServiceRegistryBuilder bsrBuilder = new BootstrapServiceRegistryBuilder();
 		bsrBuilder.applyClassLoaderService( new OSGiClassLoaderServiceImpl( osgiClassLoader, osgiServiceUtil ) );
 
 		final Integrator[] integrators = osgiServiceUtil.getServiceImpls( Integrator.class );
 		for ( Integrator integrator : integrators ) {
 			bsrBuilder.applyIntegrator( integrator );
 		}
 
 		final StrategyRegistrationProvider[] strategyRegistrationProviders
 				= osgiServiceUtil.getServiceImpls( StrategyRegistrationProvider.class );
 		for ( StrategyRegistrationProvider strategyRegistrationProvider : strategyRegistrationProviders ) {
-			bsrBuilder.withStrategySelectors( strategyRegistrationProvider );
+			bsrBuilder.applyStrategySelectors( strategyRegistrationProvider );
 		}
 
 		final BootstrapServiceRegistry bsr = bsrBuilder.build();
 		final StandardServiceRegistryBuilder ssrBuilder = new StandardServiceRegistryBuilder( bsr );
 
 		// Allow bundles to put the config file somewhere other than the root level.
 		final BundleWiring bundleWiring = (BundleWiring) requestingBundle.adapt( BundleWiring.class );
-		final Collection<String> cfgResources = bundleWiring.listResources( "/", "hibernate.cfg.xml",
-																			BundleWiring.LISTRESOURCES_RECURSE );
+		final Collection<String> cfgResources = bundleWiring.listResources(
+				"/",
+				"hibernate.cfg.xml",
+				BundleWiring.LISTRESOURCES_RECURSE
+		);
 		if (cfgResources.size() == 0) {
 			ssrBuilder.configure();
 		}
 		else {
 			if (cfgResources.size() > 1) {
 				LOG.warn( "Multiple hibernate.cfg.xml files found in the persistence bundle.  Using the first one discovered." );
 			}
 			String cfgResource = "/" + cfgResources.iterator().next();
 			ssrBuilder.configure( cfgResource );
 		}
 
 		ssrBuilder.applySetting( AvailableSettings.JTA_PLATFORM, osgiJtaPlatform );
 
 		final StandardServiceRegistry ssr = ssrBuilder.build();
 
 		final MetadataBuilder metadataBuilder = new MetadataSources( ssr ).getMetadataBuilder();
 		final TypeContributor[] typeContributors = osgiServiceUtil.getServiceImpls( TypeContributor.class );
 		for ( TypeContributor typeContributor : typeContributors ) {
 			metadataBuilder.applyTypes( typeContributor );
 		}
 
 		return metadataBuilder.build().buildSessionFactory();
 	}
 
 	@Override
 	public void ungetService(Bundle requestingBundle, ServiceRegistration registration, Object service) {
 		((SessionFactory) service).close();
 	}
 
 }
diff --git a/hibernate-proxool/src/main/java/org/hibernate/proxool/internal/ProxoolConnectionProvider.java b/hibernate-proxool/src/main/java/org/hibernate/proxool/internal/ProxoolConnectionProvider.java
index 8224031774..5479ca40c7 100644
--- a/hibernate-proxool/src/main/java/org/hibernate/proxool/internal/ProxoolConnectionProvider.java
+++ b/hibernate-proxool/src/main/java/org/hibernate/proxool/internal/ProxoolConnectionProvider.java
@@ -1,229 +1,257 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
 package org.hibernate.proxool.internal;
 
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.Map;
+import java.util.Properties;
 
 import org.hibernate.HibernateException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
 import org.hibernate.service.spi.Configurable;
+import org.hibernate.service.spi.ServiceRegistryAwareService;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 import org.jboss.logging.Logger;
 
 import org.logicalcobwebs.proxool.ProxoolException;
 import org.logicalcobwebs.proxool.ProxoolFacade;
 import org.logicalcobwebs.proxool.configuration.JAXPConfigurator;
 import org.logicalcobwebs.proxool.configuration.PropertyConfigurator;
 
 /**
  * A connection provider that uses a Proxool connection pool. Hibernate will use this by
  * default if the <tt>hibernate.proxool.*</tt> properties are set.
  *
  * @see ConnectionProvider
  */
-public class ProxoolConnectionProvider implements ConnectionProvider, Configurable, Stoppable {
+public class ProxoolConnectionProvider
+		implements ConnectionProvider, Configurable, Stoppable, ServiceRegistryAwareService {
 	private static final ProxoolMessageLogger LOG = Logger.getMessageLogger(
 			ProxoolMessageLogger.class,
 			ProxoolConnectionProvider.class.getName()
 	);
 
 	private static final String PROXOOL_JDBC_STEM = "proxool.";
 
 	private String proxoolAlias;
 
 	// TRUE if the pool is borrowed from the outside, FALSE if we used to create it
 	private boolean existingPool;
 
 	// Not null if the Isolation level has been specified in the configuration file.
 	// Otherwise, it is left to the Driver's default value.
 	private Integer isolation;
 
 	private boolean autocommit;
 
+	private ClassLoaderService classLoaderService;
+
 	@Override
 	public Connection getConnection() throws SQLException {
 		// get a connection from the pool (thru DriverManager, cfr. Proxool doc)
 		final Connection c = DriverManager.getConnection( proxoolAlias );
 
 		// set the Transaction Isolation if defined
 		if ( isolation != null ) {
 			c.setTransactionIsolation( isolation );
 		}
 
 		// toggle autoCommit to false if set
 		if ( c.getAutoCommit() != autocommit ) {
 			c.setAutoCommit( autocommit );
 		}
 
 		// return the connection
 		return c;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				ProxoolConnectionProvider.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				ProxoolConnectionProvider.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	@Override
 	public void closeConnection(Connection conn) throws SQLException {
 		conn.close();
 	}
 
 	@Override
+	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
+		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+	}
+
+	@Override
 	public void configure(Map props) {
 		// Get the configurator files (if available)
 		final String jaxpFile = (String) props.get( Environment.PROXOOL_XML );
 		final String propFile = (String) props.get( Environment.PROXOOL_PROPERTIES );
 		final String externalConfig = (String) props.get( Environment.PROXOOL_EXISTING_POOL );
 
 		// Default the Proxool alias setting
 		proxoolAlias = (String) props.get( Environment.PROXOOL_POOL_ALIAS );
 
 		// Configured outside of Hibernate (i.e. Servlet container, or Java Bean Container
 		// already has Proxool pools running, and this provider is to just borrow one of these
 		if ( "true".equals( externalConfig ) ) {
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
 				final String msg = LOG.unableToConfigureProxoolProviderToUseExistingInMemoryPool( Environment.PROXOOL_POOL_ALIAS );
 				LOG.error( msg );
 				throw new HibernateException( msg );
 			}
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
 
 			// Set the existing pool flag to true
 			existingPool = true;
 
 			LOG.configuringProxoolProviderUsingExistingPool( proxoolAlias );
 
 			// Configured using the JAXP Configurator
 		}
 		else if ( StringHelper.isNotEmpty( jaxpFile ) ) {
 			LOG.configuringProxoolProviderUsingJaxpConfigurator( jaxpFile );
 
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
 				final String msg = LOG.unableToConfigureProxoolProviderToUseJaxp( Environment.PROXOOL_POOL_ALIAS );
 				LOG.error( msg );
 				throw new HibernateException( msg );
 			}
 
 			try {
-				JAXPConfigurator.configure( ConfigHelper.getConfigStreamReader( jaxpFile ), false );
+				JAXPConfigurator.configure( getConfigStreamReader( jaxpFile ), false );
 			}
 			catch (ProxoolException e) {
 				final String msg = LOG.unableToLoadJaxpConfiguratorFile( jaxpFile );
 				LOG.error( msg, e );
 				throw new HibernateException( msg, e );
 			}
 
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
 			LOG.configuringProxoolProviderToUsePoolAlias( proxoolAlias );
 
 			// Configured using the Properties File Configurator
 		}
 		else if ( StringHelper.isNotEmpty( propFile ) ) {
 			LOG.configuringProxoolProviderUsingPropertiesFile( propFile );
 
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
 				final String msg = LOG.unableToConfigureProxoolProviderToUsePropertiesFile( Environment.PROXOOL_POOL_ALIAS );
 				LOG.error( msg );
 				throw new HibernateException( msg );
 			}
 
 			try {
-				PropertyConfigurator.configure( ConfigHelper.getConfigProperties( propFile ) );
+				PropertyConfigurator.configure( getConfigProperties( propFile ) );
 			}
 			catch (ProxoolException e) {
 				final String msg = LOG.unableToLoadPropertyConfiguratorFile( propFile );
 				LOG.error( msg, e );
 				throw new HibernateException( msg, e );
 			}
 
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
 			LOG.configuringProxoolProviderToUsePoolAlias( proxoolAlias );
 		}
 
 		// Remember Isolation level
 		isolation = ConfigurationHelper.getInteger( Environment.ISOLATION, props );
 		if ( isolation != null ) {
 			LOG.jdbcIsolationLevel( Environment.isolationLevelToString( isolation.intValue() ) );
 		}
 
 		autocommit = ConfigurationHelper.getBoolean( Environment.AUTOCOMMIT, props );
 		LOG.autoCommmitMode( autocommit );
 	}
 
+	private Reader getConfigStreamReader(String resource) {
+		return new InputStreamReader( classLoaderService.locateResourceStream( resource ) );
+	}
+
+	private Properties getConfigProperties(String resource) {
+		try {
+			Properties properties = new Properties();
+			properties.load( classLoaderService.locateResourceStream( resource ) );
+			return properties;
+		}
+		catch (IOException e) {
+			throw new HibernateException( "Unable to load properties from specified config file: " + resource, e );
+		}
+	}
+
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 
 	@Override
 	public void stop() {
 		// If the provider was leeching off an existing pool don't close it
 		if ( existingPool ) {
 			return;
 		}
 
 		// We have created the pool ourselves, so shut it down
 		try {
 			if ( ProxoolFacade.getAliases().length == 1 ) {
 				ProxoolFacade.shutdown( 0 );
 			}
 			else {
 				ProxoolFacade.removeConnectionPool( proxoolAlias.substring( PROXOOL_JDBC_STEM.length() ) );
 			}
 		}
 		catch (Exception e) {
 			// If you're closing down the ConnectionProvider chances are an
 			// is not a real big deal, just warn
 			final String msg = LOG.exceptionClosingProxoolPool();
 			LOG.warn( msg, e );
 			throw new HibernateException( msg, e );
 		}
 	}
 
 	/**
 	 * Release all resources held by this provider.
 	 *
 	 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 	 *
 	 * @deprecated Use {@link #stop} instead
 	 */
 	@Deprecated
 	public void close() throws HibernateException {
 		stop();
 	}
-
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/BasicTestingJdbcServiceImpl.java
similarity index 84%
rename from hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java
rename to hibernate-testing/src/main/java/org/hibernate/testing/boot/BasicTestingJdbcServiceImpl.java
index 697d2c5d05..beb328ba02 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/BasicTestingJdbcServiceImpl.java
@@ -1,110 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.test.common;
+package org.hibernate.testing.boot;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;
 import org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentImpl;
 import org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.jdbc.internal.ResultSetWrapperImpl;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.ResultSetWrapper;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
+import org.hibernate.service.ServiceRegistry;
+import org.hibernate.service.spi.ServiceRegistryAwareService;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 
 
 /**
- * Implementation of the {@link JdbcServices} contract for use by these
- * tests.
+ * Implementation of the {@link JdbcServices} contract for use by tests.
+ * <p/>
+ * An alternative approach is to build a {@link ServiceRegistryTestingImpl} and grab the {@link JdbcServices}
+ * from that.
  *
  * @author Steve Ebersole
  */
-public class BasicTestingJdbcServiceImpl implements JdbcServices {
+public class BasicTestingJdbcServiceImpl implements JdbcServices, ServiceRegistryAwareService {
 	private JdbcEnvironment jdbcEnvironment;
 	private ConnectionProvider connectionProvider;
 	private Dialect dialect;
 	private SqlStatementLogger sqlStatementLogger;
 
 	private JdbcConnectionAccess jdbcConnectionAccess;
+	private ServiceRegistry serviceRegistry;
 
 	public void start() {
 	}
 
 	public void stop() {
 		release();
 	}
 
 	public void prepare(boolean allowAggressiveRelease) throws SQLException {
 		dialect = ConnectionProviderBuilder.getCorrespondingDialect();
 		connectionProvider = ConnectionProviderBuilder.buildConnectionProvider( allowAggressiveRelease );
 		sqlStatementLogger = new SqlStatementLogger( true, false );
 
 		Connection jdbcConnection = connectionProvider.getConnection();
 		try {
 			jdbcEnvironment = new JdbcEnvironmentImpl( jdbcConnection.getMetaData(), dialect );
 		}
 		finally {
 			try {
 				connectionProvider.closeConnection( jdbcConnection );
 			}
 			catch (SQLException ignore) {
 			}
 		}
 
 		this.jdbcConnectionAccess = new JdbcConnectionAccessImpl( connectionProvider );
 	}
 
 	public void release() {
 		if ( connectionProvider instanceof Stoppable ) {
 			( (Stoppable) connectionProvider ).stop();
 		}
 	}
 
 	@Override
 	public JdbcEnvironment getJdbcEnvironment() {
 		return jdbcEnvironment;
 	}
 
 	@Override
 	public JdbcConnectionAccess getBootstrapJdbcConnectionAccess() {
 		return jdbcConnectionAccess;
 	}
 
 	public Dialect getDialect() {
 		return dialect;
 	}
 
 	public LobCreator getLobCreator(LobCreationContext lobCreationContext) {
 		return jdbcEnvironment.getLobCreatorBuilder().buildLobCreator( lobCreationContext );
 	}
 
 	public ResultSetWrapper getResultSetWrapper() {
-		return ResultSetWrapperImpl.INSTANCE;
+		return new ResultSetWrapperImpl( serviceRegistry );
 	}
 
 	public SqlStatementLogger getSqlStatementLogger() {
 		return sqlStatementLogger;
 	}
 
 	public SqlExceptionHelper getSqlExceptionHelper() {
 		return jdbcEnvironment.getSqlExceptionHelper();
 	}
 
 	public ExtractedDatabaseMetaData getExtractedMetaDataSupport() {
 		return jdbcEnvironment.getExtractedDatabaseMetaData();
 	}
+
+	@Override
+	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
+		this.serviceRegistry = serviceRegistry;
+	}
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderAccessTestingImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderAccessTestingImpl.java
new file mode 100644
index 0000000000..d50bdfb41f
--- /dev/null
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderAccessTestingImpl.java
@@ -0,0 +1,38 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.testing.boot;
+
+import java.net.URL;
+
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.ClassLoaderAccess;
+
+/**
+ * @author Steve Ebersole
+ */
+public class ClassLoaderAccessTestingImpl implements ClassLoaderAccess {
+	/**
+	 * Singleton access
+	 */
+	public static final ClassLoaderAccessTestingImpl INSTANCE = new ClassLoaderAccessTestingImpl();
+
+	@Override
+	@SuppressWarnings("unchecked")
+	public <T> Class<T> classForName(String name) {
+		try {
+			return (Class<T>) getClass().getClassLoader().loadClass( name );
+		}
+		catch (ClassNotFoundException e) {
+			throw new ClassLoadingException( "Could not load class by name : " + name, e );
+		}
+	}
+
+	@Override
+	public URL locateResource(String resourceName) {
+		return getClass().getClassLoader().getResource( resourceName );
+	}
+}
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderServiceTestingImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderServiceTestingImpl.java
new file mode 100644
index 0000000000..3e1f9932f3
--- /dev/null
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ClassLoaderServiceTestingImpl.java
@@ -0,0 +1,19 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.testing.boot;
+
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+
+/**
+ * @author Steve Ebersole
+ */
+public class ClassLoaderServiceTestingImpl extends ClassLoaderServiceImpl {
+	/**
+	 * Singleton access
+	 */
+	public static final ClassLoaderServiceTestingImpl INSTANCE = new ClassLoaderServiceTestingImpl();
+}
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/boot/DialectFactoryTestingImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/DialectFactoryTestingImpl.java
new file mode 100644
index 0000000000..dcd23c54c5
--- /dev/null
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/DialectFactoryTestingImpl.java
@@ -0,0 +1,35 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.testing.boot;
+
+import java.util.Map;
+
+import org.hibernate.dialect.Dialect;
+import org.hibernate.engine.jdbc.dialect.spi.DialectFactory;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfoSource;
+
+import org.hibernate.testing.env.ConnectionProviderBuilder;
+
+/**
+ * @author Steve Ebersole
+ */
+public class DialectFactoryTestingImpl implements DialectFactory {
+	private final Dialect dialect;
+
+	public DialectFactoryTestingImpl() {
+		this( ConnectionProviderBuilder.getCorrespondingDialect() );
+	}
+
+	public DialectFactoryTestingImpl(Dialect dialect) {
+		this.dialect = dialect;
+	}
+
+	@Override
+	public Dialect buildDialect(Map configValues, DialectResolutionInfoSource resolutionInfoSource) {
+		return dialect;
+	}
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/JdbcConnectionAccessImpl.java
similarity index 97%
rename from hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java
rename to hibernate-testing/src/main/java/org/hibernate/testing/boot/JdbcConnectionAccessImpl.java
index 5fe0361816..de1fb8ba35 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/JdbcConnectionAccessImpl.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.test.common;
+package org.hibernate.testing.boot;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class JdbcConnectionAccessImpl implements JdbcConnectionAccess {
 	private final ConnectionProvider connectionProvider;
 
 	public JdbcConnectionAccessImpl(ConnectionProvider connectionProvider) {
 		this.connectionProvider = connectionProvider;
 	}
 
 	public JdbcConnectionAccessImpl(ServiceRegistry serviceRegistry) {
 		this( serviceRegistry.getService( ConnectionProvider.class ) );
 	}
 
 	@Override
 	public Connection obtainConnection() throws SQLException {
 		return connectionProvider.getConnection();
 	}
 
 	@Override
 	public void releaseConnection(Connection connection) throws SQLException {
 		connectionProvider.closeConnection( connection );
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return connectionProvider.supportsAggressiveRelease();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/MetadataBuildingContextTestingImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/MetadataBuildingContextTestingImpl.java
similarity index 92%
rename from hibernate-core/src/test/java/org/hibernate/test/common/MetadataBuildingContextTestingImpl.java
rename to hibernate-testing/src/main/java/org/hibernate/testing/boot/MetadataBuildingContextTestingImpl.java
index 903c434cb2..86ab6525c6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/MetadataBuildingContextTestingImpl.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/MetadataBuildingContextTestingImpl.java
@@ -1,71 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
  */
-package org.hibernate.test.common;
+package org.hibernate.testing.boot;
 
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.internal.ClassLoaderAccessImpl;
 import org.hibernate.boot.internal.InFlightMetadataCollectorImpl;
 import org.hibernate.boot.internal.MetadataBuilderImpl;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.registry.StandardServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.boot.spi.InFlightMetadataCollector;
 import org.hibernate.boot.spi.MappingDefaults;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.type.TypeResolver;
 
 /**
 * @author Steve Ebersole
 */
 public class MetadataBuildingContextTestingImpl implements MetadataBuildingContext {
 	private final MetadataBuildingOptions buildingOptions;
 	private final MappingDefaults mappingDefaults;
 	private final InFlightMetadataCollector metadataCollector;
 	private final ClassLoaderAccessImpl classLoaderAccess;
 
 	private final ObjectNameNormalizer objectNameNormalizer;
 
+	public MetadataBuildingContextTestingImpl() {
+		this( new StandardServiceRegistryBuilder().build() );
+	}
+
 	public MetadataBuildingContextTestingImpl(StandardServiceRegistry serviceRegistry) {
 		buildingOptions = new MetadataBuilderImpl.MetadataBuildingOptionsImpl( serviceRegistry );
 		mappingDefaults = new MetadataBuilderImpl.MappingDefaultsImpl( serviceRegistry );
 		metadataCollector = new InFlightMetadataCollectorImpl( buildingOptions, new MetadataSources( serviceRegistry ), new TypeResolver() );
 		classLoaderAccess = new ClassLoaderAccessImpl( null, serviceRegistry );
 
 		objectNameNormalizer = new ObjectNameNormalizer() {
 			@Override
 			protected MetadataBuildingContext getBuildingContext() {
 				return MetadataBuildingContextTestingImpl.this;
 			}
 		};
 	}
 
 	@Override
 	public MetadataBuildingOptions getBuildingOptions() {
 		return buildingOptions;
 	}
 
 	@Override
 	public MappingDefaults getMappingDefaults() {
 		return mappingDefaults;
 	}
 
 	@Override
 	public InFlightMetadataCollector getMetadataCollector() {
 		return metadataCollector;
 	}
 
 	@Override
 	public ClassLoaderAccess getClassLoaderAccess() {
 		return classLoaderAccess;
 	}
 
 	@Override
 	public ObjectNameNormalizer getObjectNameNormalizer() {
 		return objectNameNormalizer;
 	}
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/boot/ServiceRegistryTestingImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ServiceRegistryTestingImpl.java
new file mode 100644
index 0000000000..6a99cf4107
--- /dev/null
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/boot/ServiceRegistryTestingImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
+ */
+package org.hibernate.testing.boot;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.dialect.spi.DialectFactory;
+import org.hibernate.service.StandardServiceInitiators;
+import org.hibernate.service.internal.ProvidedService;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
+
+import org.hibernate.testing.env.ConnectionProviderBuilder;
+
+/**
+ * ServiceRegistry useful in testing
+ *
+ * @author Steve Ebersole
+ */
+public class ServiceRegistryTestingImpl
+		extends StandardServiceRegistryImpl
+		implements ServiceRegistryImplementor {
+
+	public static ServiceRegistryTestingImpl forUnitTesting() {
+		return new ServiceRegistryTestingImpl(
+				true,
+				new BootstrapServiceRegistryBuilder().build(),
+				StandardServiceInitiators.LIST,
+				Arrays.asList(
+						dialectFactoryService(),
+						connectionProviderService()
+				),
+				Environment.getProperties()
+		);
+	}
+
+	private static ProvidedService dialectFactoryService() {
+		return new ProvidedService<DialectFactory>( DialectFactory.class, new DialectFactoryTestingImpl() );
+	}
+
+	private static ProvidedService connectionProviderService() {
+		return new ProvidedService<ConnectionProvider>(
+				ConnectionProvider.class,
+				ConnectionProviderBuilder.buildConnectionProvider( true )
+		);
+	}
+
+	public ServiceRegistryTestingImpl(
+			boolean autoCloseRegistry,
+			BootstrapServiceRegistry bootstrapServiceRegistry,
+			List<StandardServiceInitiator> serviceInitiators,
+			List<ProvidedService> providedServices,
+			Map<?, ?> configurationValues) {
+		super( autoCloseRegistry, bootstrapServiceRegistry, serviceInitiators, providedServices, configurationValues );
+	}
+}
diff --git a/working-5.0-migration-guide.md b/working-5.0-migration-guide.md
index 5f17fda800..12bc3fea81 100644
--- a/working-5.0-migration-guide.md
+++ b/working-5.0-migration-guide.md
@@ -1,81 +1,87 @@
 Working list of changes for 5.0
 ===================================
 
 * Switch from Configuration to ServiceRegistry+Metadata for SessionFactory building
 * `org.hibernate.hql.spi.MultiTableBulkIdStrategy#prepare` contract has been changed to account for Metadata
 * (proposed) `org.hibernate.persister.spi.PersisterFactory` contract, specifically building CollectionPersisters)
   has been changed to account for Metadata
 * extract `org.hibernate.engine.jdbc.env.spi.JdbcEnvironment` from `JdbcServices`; create
   `org.hibernate.engine.jdbc.env` package and moved a few contracts there.
 * Introduction of `org.hibernate.boot.model.relational.ExportableProducer` which will effect any
  `org.hibernate.id.PersistentIdentifierGenerator` implementations
-* Change to signature of `org.hibernate.id.Configurable` to accept `JdbcEnvironment` rather than just `Dialect`
+* Change to signature of `org.hibernate.id.Configurable` to accept `ServiceRegistry` rather than just `Dialect`
 * Removed deprecated `org.hibernate.id.TableGenerator` id-generator
 * Removed deprecated `org.hibernate.id.TableHiLoGenerator` (hilo) id-generator
 * Deprecated `org.hibernate.id.SequenceGenerator` and its subclasses
 * cfg.xml files are again fully parsed and integrated (events, security, etc)
 * Removed the deprecated `org.hibernate.cfg.AnnotationConfiguration`
 * `Integrator` contract
 * `Configuration` is  no longer `Serializable`
 * `org.hibernate.dialect.Dialect.getQuerySequencesString` expected to retrieve catalog, schema, and increment values as well
 * properties loaded from cfg.xml through EMF did not previously prefix names with "hibernate." this is now made consistent.
 * removed AuditConfiguration in preference for new `org.hibernate.envers.boot.internal.EnversService`
 * changed AuditStrategy method parameters from (removed) AuditConfiguration to (new) EnversService
 * Built-in `org.hibernate.type.descriptor.sql.SqlTypeDescriptor` implementations no longer auto-register themselves
     with `org.hibernate.type.descriptor.sql.SqlTypeDescriptorRegistry`.  Applications using custom SqlTypeDescriptor
     implementations extending the built-in ones and relying on that behavior should be updated to call
     `SqlTypeDescriptorRegistry#addDescriptor` themselves.
-* The JDBC type for "big_integer" (org.hibernate.type.BigIntegerType) properties has changed from     java.sql.Types,NUMERIC to java.sql.Types.BIGINT.
+* The JDBC type for "big_integer" (org.hibernate.type.BigIntegerType) properties has changed from 
+    java.sql.Types,NUMERIC to java.sql.Types.BIGINT.
 * Moving `org.hibernate.hql.spi.MultiTableBulkIdStrategy` and friends to new `org.hibernate.hql.spi.id` package
     and sub-packages
+* Changes to "property access" contracts, including 
+* Valid `hibernate.cache.default_cache_concurrency_strategy` setting values are now defined via
+    `org.hibernate.cache.spi.access.AccessType#getExternalName` rather than the `org.hibernate.cache.spi.access.AccessType`
+    enum names; this is more consistent with other Hibernate settings
 
 TODOs
 =====
 * Still need to go back and make all "persistent id generators" to properly implement ExportableProducer
 * Add a setting to "consistently apply" naming strategies.  E.g. use the "join column" methods from hbm.xml binding.
 * Along with this ^^ consistency setting, split the implicit naming strategy for join columns into multiple methods - one for each usage:
    * many-to-one
    * one-to-one
    * etc
 
 
 Blog items
 ==========
 * New bootstrapping API - better determinism, better integration
 * Java 8 Support (though still compatible with Java 6).
+* hibernate-spatial
 * Ability to handle additional Java types for id attributes marked as `GenerationType#AUTO`.  Built-in support
     for Number and UUID.  Expandable via new `org.hibernate.boot.model.IdGeneratorStrategyInterpreter` extension
 * Expanded support for AttributeConverters.
     * fully supported for non-`@Enumerated` enum values
     * applicable in conjunction with `@Nationalized` support
     * called to handle null values
     * settable in hbm.xml by using `type="converter:fully.qualified.AttributeConverterName"`
     * integrated with hibernate-envers
     * collection values, map keys
 * scanning support for non-JPA usage
 * naming strategy
+* OSGi improvements, Karaf feature file published
 
 
 Proposals for discussion
 ========================
 * Currently there is a "post-binding" hook to allow validation of the bound model (PersistentClass,
 Property, Value, etc).  However, the top-level entry points are currently the only possible place
 (per contract) to throw exceptions when a validation fails".  I'd like to instead consider a pattern
 where each level is asked to validate itself.  Given the current model, however, this is unfortunately
 not a win-win situation.  `org.hibernate.boot.model.source.internal.hbm.ModelBinder#createManyToOneAttribute`
 illustrates one such use case where this would be worthwhile, and also can illustrate how pushing the
 validation (and exception throwing down) can be less than stellar given the current model.  In the process
 of binding a many-to-one, we need to validate that any many-to-one that defines "delete-orphan" cascading
 is a "logical one-to-one".  There are 2 ways a many-to-one can be marked as a "logical one-to-one"; first
 is at the `<many-to-one/>` level; the other is through a singular `<column/>` that is marked as unique.
 Occasionally the binding of the column(s) of a many-to-one need to be delayed until a second pass, which
 means that sometimes we cannot perform this check immediately from the `#createManyToOneAttribute` method.
 What would be ideal would be to check this after all binding is complete.  In current code, this could be
 either an additional SecondPass or done in a `ManyToOne#isValid` override of `SimpleValue#isValid`.  The
 `ManyToOne#isValid` approach illustrates the conundrum... In the `ManyToOne#isValid` call we know the real
 reason the validation failed (non-unique many-to-one marked for orphan delete) but not the property name/path.
 Simply returning false from `ManyToOne#isValid` would instead lead to a misleading exception message, which
 would at least have the proper context to know the property name/path.
-* Should `org.hibernate.boot.MetadataBuilder` be folded into `org.hibernate.boot.MetadataSources`?
 * Consider an additional "naming strategy contract" specifically for logical naming.  This would be non-pluggable, and
 would be the thing that generates the names we use to cross-reference and locate tables, columns, etc.
