diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 7a4ae0b39..7e9346fad 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,401 +1,402 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Adrian Nistor
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alfred Theorin
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Eisenberg
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
 André-John Mas
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Anthony Wat
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arjan Veenstra
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Ben Gertzfield
 Benoit Moussaud
 Bernd Dutkowski
 Bernhard Rosenkraenzer
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Gysin
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Clive Brettingham-Moore
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
 Daniel Trebbien
 Danno Ferrin
 Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Devon C. Miller
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Barboni
 Eric Olsen
 Eric Pugh
 Erik Costlow
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frantisek Kucera
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Grégoire Vatry
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Isaac Shabtay
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jan Stolze
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jean-Louis Boudart
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Connor Arpe
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark A. Ziesemer
 Mark DeLaFranier
 Mark Hecker
 Mark R. Diggory
 Mark Salter
 Markus Kahl
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matt Wildig
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
 Matthias Bhend
 Michael Bayne
 Michael Clarke
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Mounir El Hajj
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Ondra Medek
 Omer Shapira
 Oystein Gisnas
 Patrick Altaie
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 riasol
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
 René Krell
 Richard Evans
 Richard Steele
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Power
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Sudheer Chigurupati
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
+Tim Boemker
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Tim Whittington
 Timoteo Ohara
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Uwe Schindler
 Valentino Miazzo
 Victor Toni
 Vimil Saju
 Vincent Legoll
 Volker Leidl
 Waldek Herka
 Wang Weijun
 Will Wang
 William Bernardet
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/WHATSNEW b/WHATSNEW
index 6720e8802..c41ace5dc 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1087 +1,1090 @@
 Changes from Ant 1.9.3 TO current
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the prefixValues attribute of <property> didn't work as expected
    when set to false (the default).
    It is quite likely existing build files relied on the wrong
    behavior and expect Ant to resolve the value side against the
    properties defined in the property file itself - these build files
    must now explicitly set the prefixValues attribute to true.
    Bugzilla Report 54769
 
  * when matching an entry of a zip/tarfileset against a pattern a
    leading slash will be stripped from the entry name.  Most archive
    don't contain paths with leading slashes anyway.
    This may cause include/exclude patterns that start with a / to stop
    matching anything.  Such patterns only used to work by accident and
    only on platforms with multiple file syste roots.
    Bugzilla Report 53949
 
 Fixed bugs:
 -----------
 
  * <import>/<include> failed when the importing file was loaded from an
    URI or a jar and it imported a file from the local file system via
    an absolute path.
    Bugzilla Report 50953
 
  * <import> could import the same resource twice when imported via
    different resource types.
    Bugzilla Report 55097
 
  * several calls to File#mkdirs could fall victim to a race condition
    where another thread already created the same directory.
    Bugzilla Report 55290
 
  * <manifestclasspath> created '/' rather than './' for the parent
    directory of the given jarfile.
    Bugzilla Report 55049
 
  * <concat>'s fixlastline="true" didn't work when using certain filter
    readers.
    Bugzilla Report 54672
 
  * several places where resources are read from jars will now
    explicitly disable caching to avoid problems with reloading jars.
    Bugzilla Report 54473
 
  * AntClassloader will now ignore files that are part of the classpath
    but not zip files when scanning for resources.  It used to throw an
    exception.
    Bugzilla Report 53964
 
  * <javadoc> caused a NullPointerException when no destdir was set.
    Bugzilla Report 55949
 
  * <jar filesetmanifest="mergewithoutmain"> would still include the
    Main section of the fileset manifests if there was no nested
    manifest or manifest attribute.
    Bugzilla Report 54171
 
  * reading of compiler args has become more defensive
    Bugzilla Report 53754
 
  * <copy> without force="true" would not only fail to overwrite a
    read-only file as expected but also remove the existing file.
    Bugzilla Report 53095
 
  * <delete removeNotFollowedSymlinks="true"> would remove symbolic
    links to not-included files.  It will still delete symlinks to
    directories that would have been followed even if they are not
    explicitly included.  exclude-Patterns can still be used to
    preserve symbolic links.
    Bugzilla Report 53959
 
 Other changes:
 --------------
 
  * <sshexec> can optionally pass System.in to the remote process
    Bugzilla Report 55393
 
  * <sshexec> now supports capturing error output of the executed
    process and setting a property from the return code.
    Bugzilla Report 48478
 
+ * <javadoc> now has an option to fail if javadoc issues warnings.
+   Bugzilla Report 55015
+
 Changes from Ant 1.9.2 TO Ant 1.9.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 
 Fixed bugs:
 -----------
 
  * <parallel> swallowed the status code of nested <fail> tasks.
    Bugzilla Report 55539.
 
  * a race condition could make <fixcrlf> tasks of parallel builds to
    interfere with each other.
    Bugzilla Report 54393.
 
  * <mail>'s mailport still didn't work properly when using smtps.
    Bugzilla Report 49267.
 
  * using attributes belonging to the if and unless namespaces
    made macrodef fail.
    Bugzilla Report 55885.
 
  * Ant 1.8 exec task changes have slowed exec to a crawl
    Bugzilla Report 54128.
 
  * Apt is not available under JDK 1.8
    Bugzilla Report 55922.
 
 
 Other changes:
 --------------
 
  * Documentation fix for if/unless attributes.  PR 55359.
 
  * tar entries with long link names are now handled the same way as
    entries with long names.
 
  * Addition of 'skipNonTests' attribute to <junit> and <batchtest>
    tasks to allow the tasks to skip classes that don't contain tests.
 
  * <filterset> now supports a nested <propertyset> to specify filters.
    Bugzilla Report 55794.
 
  * <xslt>'s params can now be typed.
    Bugzilla Report 21525.
 
  * build of Mac OS X pkg installer
    Bugzilla Report 55899.
 
 Changes from Ant 1.9.1 TO Ant 1.9.2
 ===================================
 
 Fixed bugs:
 -----------
 
  * Parsing of zip64 extra fields has become more lenient in order to
    be able to read archives created by DotNetZip and maybe other
    archivers as well.
 
  * TarInputStream should now properly read GNU longlink entries' names.
    Bugzilla Report 55040.
 
  * <java> and <exec> used to be too restrictive when evaluating
    whether a given set of options is compatible with spawning the new
    process.
    Bugzilla Report 55112.
 
 Other changes:
 --------------
 
  * <javadoc> will now post-process the generated in order to mitigate
    the frame injection attack possible in javadocs generated by Oracle
    JDKs prior to Java7 Update 25.  The vulnerability is known as
    CVE-2013-1571.
    There is an option to turn off the post-processing but it is only
    recommended you do so if all your builds use a JDK that's not
    vulnerable.
    Bugzilla Report 55132.
 
 Changes from Ant 1.9.0 TO Ant 1.9.1
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Users who have their own ProjectHelper implementation will need to change it because the import and include tasks
    will now default the targetPrefix to ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX.
    Users using the default ProjectHelper2 with ant need not worry about this change done to fix Bugzilla Report 54940.
 
 
 Fixed bugs:
 -----------
 
  * Corrected XSLTC error in <junitreport>.
    Bugzilla Report 54641.
 
  * Provide more control over Zip64 extensions created by <zip> and
    related tasks.  In particular no Zip64 extensions will be used at
    all by the <jar> task family by default - this is required for jars
    to be readably by Java5.
    Bugzilla Report 54762.
 
  * Fixed loading of external dependencies in JUnit task.
    Bugzilla Report 54835.
 
  * Target rewriting for nested "include" only works when "as" is specified.
    See also "Changes that could break older environments"
    Bugzilla Report 54940.
 
 
 Other changes:
 --------------
 
  * strict attribute added to <signjar>.
    Bugzilla Report 54889.
 
  * simplifying Execute.getEnvironmentVariables since we are only running on Java 1.5 or higher now
 
  * Added conditional attributes.
    Bugzilla Report 43362
 
  * Recommending to upgrade jsch to 0.1.50, particularly if you are using Java 1.7.
    jsch is the library behind the sshexec and scp Ant tasks.
    Versions of jsch older than 0.1.50 fail randomly under Java 1.7 with an error message "verify: false"
 
 Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Ant now requires at least Java 1.5 to compile and to run
 
  * FixCRLF used to treat the EOL value ASIS to convert to the system property
    line.separator. Specified was that ASIS would leave the EOL characters alone,
    the task now really leaves the EOL characters alone. This also implies that
    EOL ASIS will not insert a newline even if fixlast is set to true.
    Bugzilla report 53036
 
  * The CommandLauncher hierarchy that used to be a set of inner
    classes of Execute has been extracted to the
    org.apache.tools.ant.taskdefs.launcher package.
 
  * Any FileResource whose represented File has a parent also has a basedir.
 
  * Removing the Perforce Ant tasks replaced by tasks supplied by Perforce Inc.
 
  * Setting the default encoding of StringResource to UTF-8 instead of null
 
  * Upgrade JUnit 4 to JUnit 4.11
 
 Fixed bugs:
 -----------
 
  * Made VectorSet faster.
    Bugzilla Report 53622.
 
  * Incorrect URLs in Ant child POMs.
    Bugzilla Report 53617.
 
  * Subclasses of JUnitTask did not correctly find junit.jar.
    Bugzilla Report 53571.
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
    Bugzilla Reports 53215, 53291, 53202
    
  * Unable to override system properties. It was not possible not to override
    system properties from the command line (or from a property file).
    Bugzilla Report 51792
    
  * <javac> by default fails when run on JDK 8.
    Bugzilla Report 53347.
 
  * ExtensionPoint doesn't work with nested import/include
    Bugzilla Report 53405.
 
  * <packagemapper> failed to strip the non-matched parts with
    handledirsep="true".
    Bugzilla Report 53399.
 
  * <expandproperties> filter caused a NullPointerException when input
    was empty.
    Bugzilla Report 53626.
 
  * <get> now supports HTTP redirects using status code 307.
    Bugzilla Report 54374.
 
  * ssh tasks prompt for kerberos username/password under Java 7
    Bugzilla Report 53437.
 
  * Zip task on <mappedresources> that excludes certain files by way of the mapper resulted in a NullPointerException
    Bugzilla Report 54026
 
  * The ant launcher script should properly detect JAVA_HOME on
    MacOS X 10.7
    Bugzilla Report 52632
 
  * Depend task does not handle invokeDynamic constant pool entries - java.lang.ClassFormatError: Invalid Constant Pool entry Type 18
    Bugzilla Report 54090
 
  * Base64Converter not properly handling bytes with MSB set (not masking byte to int conversion)
    Bugzilla Report 54460
 
  * The size resource comparator would return wrong results if file
    sizes differed by more than 2 GB.
    Bugzilla Report 54623
 
  * Unable to encode properly into UTF-8 when the system property file.encoding is
    set to ANSI_X3.4-1968.
    Bugzilla Report 54606
 
  * JUnit4 tests marked @Ignore do not appear in XML output
    Bugzilla Report 43969
 
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlauncher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
  * add the possibility to suppress stdout in the sshexec task.
    Bugzilla Report 50270.
 
  * add an encoding attribute to the contains selector.
    This will be useful to use the contains selector if the encoding of the VM is different from the encoding
    of the files being selected.
 
  * support for GNU Classpath.
    Bugzilla report 54760.
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
    rather than extending ConditionBase. It also means that the use of
    namespaces for some of the selectors introduced in Ant 1.7.0 is no
    longer necessary.  Implementing this means that the DynamicElement
    work-around introduced in Ant 1.7.0 has been removed.
diff --git a/contributors.xml b/contributors.xml
index 55ddebda2..ea1dece85 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -456,1152 +456,1156 @@
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Costlow</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>František</first>
     <last>Kučera</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Grégoire</first>
     <last>Vatry</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Isaac</first>
     <last>Shabtay</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Cumps</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Stolze</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Connor</middle>
     <last>Arpe</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>DeLaFranier</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Markus</first>
     <last>Kahl</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Wildig</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Champlon</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Peltier</last>
   </name>
   <name>
     <first>Matthias</first>
     <last>Bhend</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Clarke</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Mounir</first>
     <last>El Hajj</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>Ondra</first>
     <last>Medek</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Altaie</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Paul</first>
     <last>King</last>
   </name>
   <name>
     <first>Paulo</first>
     <last>Gaspar</last>
   </name>
   <name>
     <first>Pavan</first>
     <last>Bayyapu</last>
   </name>
   <name>
     <first>Pavel</first>
     <last>Jisl</last>
   </name>
   <name>
     <first>Paweł</first>
     <last>Zuzelski</last>
   </name>
   <name>
     <first>Peter</first>
     <middle>B.</middle>
     <last>West</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Donald</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Doornbosch</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Hulst</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Janes</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Reilly</last>
   </name>
   <name>
     <first>Phil</first>
     <last>Hanna</last>
   </name>
   <name>
     <first>Philip</first>
     <last>Hourihane</last>
   </name>
   <name>
     <first>Phillip</first>
     <last>Wells</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Delisle</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Dittgen</last>
   </name>
   <name>
     <first>R</first>
     <last>Handerson</last>
   </name>
   <name>
     <first>Rami</first>
     <last>Ojares</last>
   </name>
   <name>
     <first>Randy</first>
     <last>Watler</last>
   </name>
   <name>
     <first>Raphael</first>
     <last>Pierquin</last>
   </name>
   <name>
     <first>Ray</first>
     <last>Waldin</last>
   </name>
   <name>
     <first>Remie</first>
     <last>Bolte</last>
   </name>
   <name>
     <first>René</first>
     <last>Krell</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Evans</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Steele</last>
   </name>
   <name>
     <first>Rick</first>
     <last>Beton</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Anderson</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Flaherty</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Shaw</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Streich</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Watkins</last>
   </name>
   <name>
     <first>Roberto</first>
     <last>Scaramuzzi</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Green</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Power</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Verduijn</last>
   </name>
   <name>
     <first>Rob</first>
     <last>Oxspring</last>
   </name>
   <name>
     <first>Rob</first>
     <last>van Oostrum</last>
   </name>
   <name>
     <first>Rodrigo</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Roger</first>
     <last>Vaughn</last>
   </name>
   <name>
     <first>Roman</first>
     <last>Ivashin</last>
   </name>
   <name>
     <first>Ronen</first>
     <last>Mashal</last>
   </name>
   <name>
     <first>Russell</first>
     <last>Gold</last>
   </name>
   <name>
     <first>Sam</first>
     <last>Ruby</last>
   </name>
   <name>
     <first>Sandra</first>
     <last>Metz</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Carlson</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Ellsworth</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Johnson</last>
   </name>
   <name>
     <first>Scott</first>
     <middle>M.</middle>
     <last>Stirling</last>
   </name>
   <name>
     <first>Sean</first>
     <last>Egan</last>
   </name>
   <name>
     <first>Sean</first>
     <middle>P.</middle>
     <last>Kane</last>
   </name>
   <name>
     <first>Sebastien</first>
     <last>Arod</last>
   </name>
   <name>
     <first>Shiraz</first>
     <last>Kanga</last>
   </name>
   <name>
     <first>Sebastian</first>
     <last>Kantha</last>
   </name>
   <name>
       <first>Simon</first>
       <last>Law</last>
   </name>
   <name>
     <first>Simone</first>
     <last>Bordet</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Bodewig</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Heimann</last>
   </name>
   <name>
     <first>Stefano</first>
     <last>Mazzocchi</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Strittmatter</last>
   </name>
   <name>
     <first>Stephane</first>
     <last>Bailliez</last>
   </name>
   <name>
     <last>stephan</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Michels</last>
   </name>
   <name>
     <first>Stephen</first>
     <last>Chin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Cohen</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Langley</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Loughran</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Morin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Wadsworth</last>
   </name>
   <name>
     <first>Steven</first>
     <middle>E.</middle>
     <last>Newton</last>
   </name>
   <name>
     <first>Sudheer</first>
     <last>Chigurupati</last>
   </name>
   <name>
     <first>Takashi</first>
     <last>Okamoto</last>
   </name>
   <name>
     <first>TAMURA</first>
     <last>Kent</last>
   </name>
   <name>
     <first>Taoufik</first>
     <last>Romdhane</last>
   </name>
   <name>
     <first>Tariq</first>
     <last>Master</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Aglassinger</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Butz</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christensen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Haas</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Quas</last>
   </name>
   <name>
     <first>Tim</first>
+    <last>Boemker</last>
+  </name>
+  <name>
+    <first>Tim</first>
     <last>Drury</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Fennell</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Whittington</last>
   </name>
   <name>
     <first>Timoteo</first>
     <last>Ohara</last>
   </name>
   <name>
     <first>Timothy</first>
     <middle>Gerard</middle>
     <last>Endres</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Stephenson</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Ball</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Cunningham</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Dimock</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Eugelink</last>
   </name>
   <name>
     <first>Tom</first>
     <last>May</last>
   </name>
   <name>
     <first>Tomasz</first>
     <last>Bech</last>
   </name>
   <name>
     <first>Trejkaz</first>
     <last>Xaoz</last>
   </name>
   <name>
     <first>Ulrich</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Uwe</first>
     <last>Schindler</last>
   </name>
   <name>
     <first>Valentino</first>
     <last>Miazzo</last>
   </name>
   <name>
     <first>Victor</first>
     <last>Toni</last>
   </name>
   <name>
     <first>Vincent</first>
     <last>Legoll</last>
   </name>
   <name>
     <first>Vimil</first>
     <last>Saju</last>
   </name>
   <name>
     <first>Volker</first>
     <last>Leidl</last>
   </name>
   <name>
     <first>Wang</first>
     <last>Weijun</last>
   </name>
   <name>
     <first>Will</first>
     <last>Wang</last>
   </name>
   <name>
     <first>William</first>
     <last>Bernardet</last>
   </name>
   <name>
     <first>William</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>William</first>
     <last>Webber</last>
   </name>
   <name>
     <first>Wolf</first>
     <last>Siberski</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Baer</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Frech</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Glas</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Werner</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Hanin</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Witdouck</last>
   </name>
   <name>
     <first>Yohann</first>
     <last>Roussel</last>
   </name>
   <name>
     <first>Yuji</first>
     <last>Yamano</last>
   </name>
   <name>
     <first>Yves</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Zach</first>
     <last>Garner</last>
   </name>
   <name>
     <first>Zdenek</first>
     <last>Wagner</last>
   </name>
   <name>
     <first/>
     <last>riasol</last>
   </name>
 </contributors>
diff --git a/manual/Tasks/javadoc.html b/manual/Tasks/javadoc.html
index 31f3f3e38..5ee8528d1 100644
--- a/manual/Tasks/javadoc.html
+++ b/manual/Tasks/javadoc.html
@@ -1,906 +1,914 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 
 <head>
 <meta http-equiv="Content-Language" content="en-us">
 <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
 <title>Javadoc Task</title>
 </head>
 
 <body>
 
 <h2><a name="javadoc">Javadoc/<i>Javadoc2</i></a></h2>
 <h3>Description</h3>
 <p>Generates code documentation using the javadoc tool.</p>
 <p>The source directory will be recursively scanned for Java source files to process
 but only those matching the inclusion rules, and not matching the exclusions rules
 will be passed to the javadoc tool. This
 allows wildcards to be used to choose between package names, reducing verbosity
 and management costs over time. This task, however, has no notion of
 &quot;changed&quot; files, unlike the <a href="javac.html">javac</a> task. This means
 all packages will be processed each time this task is run. In general, however,
 this task is used much less frequently.</p>
 <p>NOTE: since javadoc calls System.exit(), javadoc cannot be run inside the
 same VM as Apache Ant without breaking functionality. For this reason, this task
 always forks the VM. This overhead is not significant since javadoc is normally a heavy
 application and will be called infrequently.</p>
 <p>NOTE: the packagelist attribute allows you to specify the list of packages to
 document outside of the Ant file. It's a much better practice to include everything
 inside the <code>build.xml</code> file. This option was added in order to make it easier to
 migrate from regular makefiles, where you would use this option of javadoc.
 The packages listed in packagelist are not checked, so the task performs even
 if some packages are missing or broken. Use this option if you wish to convert from
 an existing makefile. Once things are running you should then switch to the regular
 notation. </p>
 
 <p><i><b>DEPRECATION:</b> the javadoc2 task simply points to the javadoc task and it's
 there for back compatibility reasons. Since this task will be removed in future
 versions, you are strongly encouraged to use <a href="javadoc.html">javadoc</a>
 instead.</i></p>
 
 <p>In the table below, 1.2 means available if your current Java VM is
 a 1.2 VM (but not 1.3 or later), 1.4+ for any VM of at least version 1.4, otherwise
 any VM of at least version 1.2 is acceptable. JDKs &lt;1.4 are no longer supported.
 If you specify the <code>executable</code> attribute it is up to you
 to ensure that this command supports the attributes you wish to use.</p>
 
 <p><b>Note:</b><br>When generating the JavaDocs for classes which contains annotations
 you maybe get a <tt>java.lang.ClassCastException: com.sun.tools.javadoc.ClassDocImpl</tt>.
 This is due <a href="https://bugs.openjdk.java.net/browse/JDK-6442982" target="_blank">bug-6442982</a>. The cause is that JavaDoc cannot find the implementations of used annotations.
 The workaround is providing the jars with these implementations (like JAXBs <tt>@XmlType</tt>, ...)
 to &lt;javadoc&gt; using <tt>classpath</tt>, <tt>classpathref</tt> attributes or nested
 &lt;classpath&gt; element.</p>
 
 <p><b>Note:</b> many problems with running javadoc stem from command
   lines that have become too long - even though the error message
   doesn't give the slightest hint this may be the problem.  If you
   encounter problems with the task, try to set
   the <code>useexternalfile</code> attribute to <code>true</code>
   first.</p>
 
 <p>If you use multiple ways to specify where javadoc should be looking
   for sources your result will be the union of all specified
   documentations.  If you, e.g., specify a sourcepath attribute and
   also a nested packageset both pointing at the same directory your
   excludepackagenames attribute won't have any effect unless it agrees
   with the exclude patterns of the packageset (and vice versa).</p>
 
 <h3>Parameters</h3>
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Availability</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">sourcepath</td>
     <td valign="top">Specify where to find source files</td>
     <td align="center" valign="top">all</td>
     <td align="center" rowspan="3">At least one of the three or nested
     <code>&lt;sourcepath&gt;</code>, <code>&lt;fileset&gt;</code> or
     <code>&lt;packageset&gt;</code></td>
   </tr>
   <tr>
     <td valign="top">sourcepathref</td>
     <td valign="top">Specify where to find source files by <a
       href="../using.html#references">reference</a> to a PATH defined elsewhere.</td>
     <td align="center" valign="top">all</td>
   </tr>
   <tr>
     <td valign="top">sourcefiles</td>
     <td valign="top">Comma separated list of source files -- see also
     the nested <code>source</code> element.</td>
     <td align="center" valign="top">all</td>
   </tr>
   <tr>
     <td valign="top">destdir</td>
     <td valign="top">Destination directory for output files</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">Yes, unless a doclet has been specified.</td>
   </tr>
   <tr>
     <td valign="top">maxmemory</td>
     <td valign="top">Max amount of memory to allocate to the javadoc VM</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">packagenames</td>
     <td valign="top">Comma separated list of package files (with terminating
       wildcard) -- see also the nested <code>package</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">packageList</td>
     <td valign="top">The name of a file containing the packages to process</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">classpath</td>
     <td valign="top">Specify where to find user class files</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Bootclasspath</td>
     <td valign="top">Override location of class files loaded by the bootstrap
       class loader</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">classpathref</td>
     <td valign="top">Specify where to find user class files by <a
       href="../using.html#references">reference</a> to a PATH defined elsewhere.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">bootclasspathref</td>
     <td valign="top">Override location of class files loaded by the
       bootstrap class loader by <a href="../using.html#references">reference</a> to a
       PATH defined elsewhere.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Extdirs</td>
     <td valign="top">Override location of installed extensions</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Overview</td>
     <td valign="top">Read overview documentation from HTML file</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">access</td>
     <td valign="top">Access mode: one of <code>public</code>, <code>protected</code>,
                      <code>package</code>, or <code>private</code></td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No (default <code>protected</code>)</td>
   </tr>
   <tr>
     <td valign="top">Public</td>
     <td valign="top">Show only public classes and members</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Protected</td>
     <td valign="top">Show protected/public classes and members (default)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Package</td>
     <td valign="top">Show package/protected/public classes and members</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Private</td>
     <td valign="top">Show all classes and members</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Old</td>
     <td valign="top">Generate output using JDK 1.1 emulating
       doclet.<br>
       <b>Note:</b> as of Ant 1.8.0 this attribute doesn't have any
       effect since the javadoc of Java 1.4 (required by Ant 1.8.0)
       doesn't support the -1.1 switch anymore.</td>
     <td align="center" valign="top">1.2</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Verbose</td>
     <td valign="top">Output messages about what Javadoc is doing</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Locale</td>
     <td valign="top">Locale to be used, e.g. en_US or en_US_WIN</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Encoding</td>
     <td valign="top">Source file encoding name</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Version</td>
     <td valign="top">Include @version paragraphs</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Use</td>
     <td valign="top">Create class and package usage pages</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Author</td>
     <td valign="top">Include @author paragraphs</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Splitindex</td>
     <td valign="top">Split index into one file per letter</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Windowtitle</td>
     <td valign="top">Browser window title for the documentation (text)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Doctitle</td>
     <td valign="top">Include title for the package index(first) page (html-code)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Header</td>
     <td valign="top">Include header text for each page (html-code)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">Footer</td>
     <td valign="top">Include footer text for each page (html-code)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">bottom</td>
     <td valign="top">Include bottom text for each page (html-code)</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">link</td>
     <td valign="top">Create links to javadoc output at the given URL
     -- see also the nested <code>link</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">linkoffline</td>
     <td valign="top">Link to docs at <code>&lt;url&gt;</code> using package list at
     <code>&lt;url2&gt;</code> - separate the URLs by using a space character -- see
     also the nested <code>link</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">group</td>
     <td valign="top">Group specified packages together in overview
     page.  The format is as described <a
     href="#groupattribute">below</a> -- see also the nested
     <code>group</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">nodeprecated</td>
     <td valign="top">Do not include @deprecated information</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">nodeprecatedlist</td>
     <td valign="top">Do not generate deprecated list</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">notree</td>
     <td valign="top">Do not generate class hierarchy</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">noindex</td>
     <td valign="top">Do not generate index</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">nohelp</td>
     <td valign="top">Do not generate help link</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">nonavbar</td>
     <td valign="top">Do not generate navigation bar</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">serialwarn</td>
     <td valign="top">Generate warning about @serial tag</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">helpfile</td>
     <td valign="top">Specifies the HTML help file to use</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">stylesheetfile</td>
     <td valign="top">Specifies the CSS stylesheet to use</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">charset</td>
     <td valign="top">Charset for cross-platform viewing of generated
       documentation</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">docencoding</td>
     <td valign="top">Output file encoding name</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">doclet</td>
     <td valign="top">Specifies the class file that starts the doclet
     used in generating the documentation -- see also the nested
     <code>doclet</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">docletpath</td>
     <td valign="top">Specifies the path to the doclet class file that is specified with the -doclet option.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">docletpathref</td>
     <td valign="top">Specifies the path to the doclet class file that
       is specified with the -doclet option by <a
       href="../using.html#references">reference</a> to a PATH defined elsewhere.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">additionalparam</td>
     <td valign="top">Lets you add additional parameters to the javadoc
     command line. Useful for doclets. Parameters containing spaces
     need to be quoted using &amp;quot; -- see also the nested
     <code>arg</code> element.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">failonerror</td>
     <td valign="top">Stop the buildprocess if the command exits with a
       returncode other than 0.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
+    <td valign="top">failonwarning</td>
+    <td valign="top">Stop the buildprocess if a warning is emitted -
+    i.e. if javadoc's output contains the word "warning".  <em>since
+    Ant 1.9.4</em></td>
+    <td align="center" valign="top">all</td>
+    <td align="center" valign="top">No</td>
+  </tr>
+  <tr>
     <td valign="top">excludepackagenames</td>
     <td valign="top">comma separated list of packages you don't want
       docs for -- see also the nested <code>excludepackage</code> element.</td>
     <td align="center" valign="top">all</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">defaultexcludes</td>
     <td valign="top">indicates whether default excludes should be used
       (<code>yes</code> | <code>no</code>); default excludes are used when omitted.</td>
     <td align="center" valign="top">all</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">useexternalfile</td>
     <td valign="top">indicates whether the sourcefile name specified
       in srcfiles or as nested source elements should be written to a
       temporary file to make the command line shorter. Also applies to
       the package names specified via the packagenames attribute or
       nested package elements.  <em>Since Ant 1.7.0</em>, also applies
       to all the other command line options.
       (<code>yes</code> | <code>no</code>). Default is no.</td>
     <td align="center" valign="top">all</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">source</td>
     <td valign="top">Necessary to enable javadoc to handle assertions
     present in J2SE v 1.4 source code. Set this to &quot;1.4&quot; to
     documents code that compiles using <code>&quot;javac -source
     1.4&quot;</code>.<br>
     A default value for this attribute can be provided using the magic
     <a
     href="../javacprops.html#source"><code>ant.build.javac.source</code></a>
     property.</td>
     <td align="center" valign="top">1.4+</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">linksource</td>
     <td valign="top">Generate hyperlinks to source files.
       <em>since Ant 1.6</em>.
       (<code>yes</code> | <code>no</code>). Default is no.</td>
     <td align="center" valign="top">1.4+</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">breakiterator</td>
     <td valign="top">Use the new breakiterator algorithm.
       <em>since Ant 1.6</em>.
       (<code>yes</code> | <code>no</code>). Default is no.</td>
     <td align="center" valign="top">1.4+</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">noqualifier</td>
     <td valign="top">Enables the <code>-noqualifier</code> argument -
       must be <code>all</code> or a colon separated list of packages.
       <em>since Ant 1.6</em>.</td>
     <td align="center" valign="top">1.4+</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includenosourcepackages</td>
     <td valign="top">If set to true, packages that don't contain Java
       source but a package.html will get documented as well.
       <em>since Ant 1.6.3</em>.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No (default is <code>false</code>)</td>
   </tr>
   <tr>
     <td valign="top">executable</td>
     <td valign="top">Specify a particular <code>javadoc</code> executable
       to use in place of the default binary (found in the same JDK as Ant is running in).
       <em>since Ant 1.6.3</em>.</td>
     <td align="center" valign="top">all</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">docfilessubdirs</td>
     <td valign="top">Enables deep-copying of <code>doc-files</code>
       subdirectories.  Defaults to false. <em>since Ant 1.8.0</em>.</td>
     <td align="center" valign="top">1.4</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">excludedocfilessubdir</td>
     <td valign="top">Colon-separated list of <code>doc-files</code>'
       subdirectories to exclude if <code>docfilessubdirs</code> is
       true. <em>since Ant 1.8.0</em>.</td>
     <td align="center" valign="top">1.4</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">postProcessGeneratedJavadocs</td>
     <td valign="top">Whether to post-process the generated javadocs in
     order to mitigate CVE-2013-1571.  Defaults to true.  <em>Since Ant
     1.9.2</em><br></td>
     There is a frame injection attack possible in javadocs generated by Oracle
     JDKs prior to Java7 Update 25 (<a href="http://www.oracle.com/technetwork/java/javase/7u25-relnotes-1955741.html#jpi-upt" target="_blank">details</a>).  When this flag is set to true, Ant
     will check whether the docs are vulnerable and will try to fix them.
     </td>
     <td align="center" valign="top">1.4</td>
     <td align="center" valign="top">No</td>
   </tr>
 </table>
 
 <h4><a name="groupattribute">Format of the group attribute</a></h4>
 <p>The arguments are comma-delimited. Each single argument is 2
 space-delimited strings, where the first one is the group's title and
 the second one a colon delimited list of packages.</p>
 <p>If you need to specify more than one group, or a group whose title
 contains a comma or a space character, using <a
 href="#groupelement">nested group elements</a> is highly
 recommended.</p>
 <p>E.g.:</p>
 <pre>    group=&quot;XSLT_Packages org.apache.xalan.xslt*,XPath_Packages org.apache.xalan.xpath*&quot;</pre>
 
 <h3>Parameters specified as nested elements</h3>
 
 <h4>packageset</h4>
 
 <p>A <a href="../Types/dirset.html">DirSet</a>.  All matched
 directories that contain Java source files will be passed to javadoc
 as package names.  Package names are created from the directory names
 by translating the directory separator into dots.  Ant assumes the
 base directory of the packageset points to the root of a package
 hierarchy.</p>
 
 <p>The <code>packagenames</code>, <code>excludepackagenames</code> and
 <code>defaultexcludes</code> attributes of the task have no effect on
 the nested <code>&lt;packageset&gt;</code> elements.</p>
 
 <h4>fileset</h4>
 
 <p>A <a href="../Types/fileset.html">FileSet</a>.  All matched
 files will be passed to javadoc as source files.  Ant will
 automatically add the include pattern <code>**/*.java</code> (and
 <code>**/package.html</code> if includenosourcepackages is true) to
 these filesets.</p>
 
 <p>Nested filesets can be used to document sources that are in the
 default package or if you want to exclude certain files from
 documentation.  If you want to document all source files and don't use
 the default package, packagesets should be used instead as this
 increases javadocs performance.</p>
 
 <p>The <code>packagenames</code>, <code>excludepackagenames</code> and
 <code>defaultexcludes</code> attributes of the task have no effect on
 the nested <code>&lt;fileset&gt;</code> elements.</p>
 
 <h4>sourcefiles</h4>
 
 <p>A container for arbitrary file system based <a
 href="../Types/resources.html#collection">resource
 collections</a>.  All files contained in any of the nested collections
 (this includes nested filesets, filelists or paths) will be passed to
 javadoc as source files.</p>
 
 <h4>package</h4>
 <p>Same as one entry in the list given by <code>packagenames</code>.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">name</td>
     <td valign="top">The package name (may be a wildcard)</td>
     <td align="center" valign="top">Yes</td>
   </tr>
 </table>
 
 <h4>excludepackage</h4>
 <p>Same as one entry in the list given by <code>excludepackagenames</code>.</p>
 
 <h5>Parameters</h5>
 Same as for <code>package</code>.
 
 <h4>source</h4>
 <p>Same as one entry in the list given by <code>sourcefiles</code>.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">file</td>
     <td valign="top">The source file to document</td>
     <td align="center" valign="top">Yes</td>
   </tr>
 </table>
 
 <h4>doctitle</h4>
 
 <p>Same as the <code>doctitle</code> attribute, but you can nest text
 inside the element this way.</p>
 
 <p>If the nested text contains line breaks, you must use the
   useexternalfile attribute and set it to true.</p>
 
 <h4>header</h4>
 
 <p>Similar to <code>&lt;doctitle&gt;</code>.</p>
 
 <h4>footer</h4>
 
 <p>Similar to <code>&lt;doctitle&gt;</code>.</p>
 
 <h4>bottom</h4>
 
 <p>Similar to <code>&lt;doctitle&gt;</code>.</p>
 
 <h4>link</h4>
 <p>Create link to javadoc output at the given URL. This performs the
 same role as the link and linkoffline attributes. You can use either
 syntax (or both at once), but with the nested elements you can easily
 specify multiple occurrences of the arguments.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">href</td>
     <td valign="top">The URL for the external documentation you wish
     to link to.  This can be an absolute URL, or a relative file
     name.</td>
     <td align="center" valign="top">Yes</td>
   </tr>
   <tr>
     <td valign="top">offline</td>
     <td valign="top">True if this link is not available online at the time of
                      generating the documentation</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">packagelistLoc</td>
     <td valign="top">The location to the directory containing the package-list file for
                      the external documentation</td>
     <td align="center" valign="top" rowspan="2">One of the two if the offline attribute is true</td>
   </tr>
   <tr>
     <td valign="top">packagelistURL</td>
     <td valign="top">The URL of the the directory containing the package-list file for
                      the external documentation</td>
   </tr>
   <tr>
     <td valign="top">resolveLink</td>
     <td valign="top">If the link attribute is a relative file name,
     Ant will first try to locate the file relative to the current
     project's basedir and if it finds a file there use an absolute URL
     for the link attribute, otherwise it will pass the file name
     verbatim to the javadoc command.</td>
     <td align="center" valign="top">No, default is false.</td>
   </tr>
 </table>
 
 <h4><a name="groupelement">group</a></h4>
 <p>Separates packages on the overview page into whatever groups you
 specify, one group per table. This performs the same role as the group
 attribute. You can use either syntax (or both at once), but with the
 nested elements you can easily specify multiple occurrences of the
 arguments.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">title</td>
     <td valign="top">Title of the group</td>
     <td align="center" valign="top">Yes, unless nested <code>&lt;title&gt;</code> given</td>
   </tr>
   <tr>
     <td valign="top">packages</td>
     <td valign="top">List of packages to include in that group. Multiple packages are separated with ':'.</td>
     <td align="center" valign="top">Yes, unless nested <code>&lt;package&gt;</code>s given</td>
   </tr>
 </table>
 
 <p>The title may be specified as a nested <code>&lt;title&gt;</code> element
 with text contents, and the packages may be listed with nested
 <code>&lt;package&gt;</code> elements as for the main task.</p>
 
 <h4>doclet</h4>
 <p>The doclet nested element is used to specify the
 <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/doclet/overview.html">doclet</a>
 that javadoc will use to process the input source files. A number of the standard javadoc arguments
 are actually arguments of the standard doclet. If these are specified in the javadoc
 task's attributes, they will be passed to the doclet specified in the
 <code>&lt;doclet&gt;</code> nested element. Such attributes should only be specified,
 therefore, if they can be interpreted by the doclet in use.</p>
 
 <p>If the doclet requires additional parameters, these can be specified with
 <code>&lt;param&gt;</code> elements within the <code>&lt;doclet&gt;</code>
 element. These parameters are restricted to simple strings. An example usage
 of the doclet element is shown below:</p>
 
 <pre>  &lt;javadoc ... &gt;
      &lt;doclet name=&quot;theDoclet&quot;
              path=&quot;path/to/theDoclet&quot;&gt;
         &lt;param name=&quot;-foo&quot; value=&quot;foovalue&quot;/&gt;
         &lt;param name=&quot;-bar&quot; value=&quot;barvalue&quot;/&gt;
      &lt;/doclet&gt;
   &lt;/javadoc&gt;
 </pre>
 
 <h4><a name="tagelement">tag</a></h4>
 
 <p>If you want to specify a standard tag using a nested tag element
 because you want to determine the order the tags are output, you must
 not set the description attribute for those tags.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">name</td>
     <td valign="top">Name of the tag (e.g. <code>todo</code>)</td>
     <td align="center" valign="top">Yes, unless the <code>dir</code> attribute is specified.</td>
   </tr>
   <tr>
     <td valign="top">description</td>
     <td valign="top">Description for tag (e.g. <code>To do:</code>)</td>
     <td align="center" valign="top">
       No, the javadoc executable will pick a default if this is not specified.
     </td>
   </tr>
   <tr>
     <td valign="top">enabled</td>
     <td valign="top">Whether or not the tag is enabled (defaults to <code>true</code>)</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">scope</td>
     <td valign="top">Scope for the tag - the elements in which it can be used. This
     is a comma separated list of some of the elements: <code>overview</code>,
     <code>packages</code>, <code>types</code>, <code>constructors</code>,
     <code>methods</code>, <code>fields</code> or the default, <code>all</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">dir</td>
     <td valign="top">If this attribute is specified, this element will behave as an implicit
     <a href="../Types/fileset.html">fileset</a>. The files included by this fileset should
     contain each tag definition on a separate line, as described in the
     <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#javadoctags">Javadoc reference guide</a>:
     <pre>ejb.bean:t:XDoclet EJB Tag
 todo:a:To Do</pre>
       <b>Note:</b> The  Javadoc reference quide has double quotes around
 the description part of the definition. This will not work when used in
 a file, as the definition is quoted again when given to
 the javadoc program.
     <br/>
       <b>Note:</b> If this attribute is specified, all the other attributes in this
     element will be ignored.
     </td>
     <td align="center" valign="top">No</td>
   </tr>
 </table>
 
 <h4><a name="tagletelement">taglet</a></h4>
 <p>The taglet nested element is used to specify custom
   <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/taglet/overview.html">taglets</a> beyond <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#javadoctags" target="_blank">the default taglets</a>.</p>
 
 <h5>Parameters</h5>
 <table width="90%" border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">name</td>
     <td valign="top">The name of the taglet class
               (e.g. <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/taglet/ToDoTaglet.java">
               <code>com.sun.tools.doclets.ToDoTaglet</code></a>)</td>
     <td align="center" valign="top">Yes</td>
   </tr>
   <tr>
     <td valign="top">path</td>
     <td valign="top">A path specifying the search path for the taglet class
             (e.g. <code>/home/taglets</code>).
             The path may also be specified by a nested <code>&lt;path&gt;</code> element</td>
     <td align="center" valign="top">No</td>
   </tr>
 </table>
 
 <h4>sourcepath, classpath and bootclasspath</h4>
 <p><code>Javadoc</code>'s <i>sourcepath</i>, <i>classpath</i> and
 <i>bootclasspath</i> attributes are <a href="../using.html#path">PATH like
 structure</a> and can also be set via nested <i>sourcepath</i>,
 <i>classpath</i> and <i>bootclasspath</i> elements
 respectively.</p>
 
 <h4>arg</h4>
 
 <p>Use nested <code>&lt;arg&gt;</code> to specify additional
 arguments.  See <a href="../using.html#arg">Command line
 arguments</a>. <em>Since Ant 1.6</em></p>
 
 <h3>Example</h3>
 <pre>  &lt;javadoc packagenames=&quot;com.dummy.test.*&quot;
            sourcepath=&quot;src&quot;
            excludepackagenames=&quot;com.dummy.test.doc-files.*&quot;
            defaultexcludes=&quot;yes&quot;
            destdir=&quot;docs/api&quot;
            author=&quot;true&quot;
            version=&quot;true&quot;
            use=&quot;true&quot;
            windowtitle=&quot;Test API&quot;&gt;
     &lt;doctitle&gt;&lt;![CDATA[&lt;h1&gt;Test&lt;/h1&gt;]]&gt;&lt;/doctitle&gt;
     &lt;bottom&gt;&lt;![CDATA[&lt;i&gt;Copyright &amp;#169; 2000 Dummy Corp. All Rights Reserved.&lt;/i&gt;]]&gt;&lt;/bottom&gt;
     &lt;tag name=&quot;todo&quot; scope=&quot;all&quot; description=&quot;To do:&quot;/&gt;
     &lt;group title=&quot;Group 1 Packages&quot; packages=&quot;com.dummy.test.a*&quot;/&gt;
     &lt;group title=&quot;Group 2 Packages&quot; packages=&quot;com.dummy.test.b*:com.dummy.test.c*&quot;/&gt;
     &lt;link offline=&quot;true&quot; href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot; packagelistLoc=&quot;C:\tmp&quot;/&gt;
     &lt;link href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot;/&gt;
   &lt/javadoc&gt;</pre>
 
 <p>is the same as</p>
 
 <pre>  &lt;javadoc
            destdir=&quot;docs/api&quot;
            author=&quot;true&quot;
            version=&quot;true&quot;
            use=&quot;true&quot;
            windowtitle=&quot;Test API&quot;&gt;
 
     &lt;packageset dir=&quot;src&quot; defaultexcludes=&quot;yes&quot;&gt;
       &lt;include name=&quot;com/dummy/test/**&quot;/&gt;
       &lt;exclude name=&quot;com/dummy/test/doc-files/**&quot;/&gt;
     &lt;/packageset&gt;
 
     &lt;doctitle&gt;&lt;![CDATA[&lt;h1&gt;Test&lt;/h1&gt;]]&gt;&lt;/doctitle&gt;
     &lt;bottom&gt;&lt;![CDATA[&lt;i&gt;Copyright &amp;#169; 2000 Dummy Corp. All Rights Reserved.&lt;/i&gt;]]&gt;&lt;/bottom&gt;
     &lt;tag name=&quot;todo&quot; scope=&quot;all&quot; description=&quot;To do:&quot;/&gt;
     &lt;group title=&quot;Group 1 Packages&quot; packages=&quot;com.dummy.test.a*&quot;/&gt;
     &lt;group title=&quot;Group 2 Packages&quot; packages=&quot;com.dummy.test.b*:com.dummy.test.c*&quot;/&gt;
     &lt;link offline=&quot;true&quot; href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot; packagelistLoc=&quot;C:\tmp&quot;/&gt;
     &lt;link href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot;/&gt;
   &lt/javadoc&gt;</pre>
 
 <p>or</p>
 
 <pre>  &lt;javadoc
            destdir=&quot;docs/api&quot;
            author=&quot;true&quot;
            version=&quot;true&quot;
            use=&quot;true&quot;
            windowtitle=&quot;Test API&quot;&gt;
 
     &lt;fileset dir=&quot;src&quot; defaultexcludes=&quot;yes&quot;&gt;
       &lt;include name=&quot;com/dummy/test/**&quot;/&gt;
       &lt;exclude name=&quot;com/dummy/test/doc-files/**&quot;/&gt;
     &lt;/fileset&gt;
 
     &lt;doctitle&gt;&lt;![CDATA[&lt;h1&gt;Test&lt;/h1&gt;]]&gt;&lt;/doctitle&gt;
     &lt;bottom&gt;&lt;![CDATA[&lt;i&gt;Copyright &amp;#169; 2000 Dummy Corp. All Rights Reserved.&lt;/i&gt;]]&gt;&lt;/bottom&gt;
     &lt;tag name=&quot;todo&quot; scope=&quot;all&quot; description=&quot;To do:&quot;/&gt;
     &lt;group title=&quot;Group 1 Packages&quot; packages=&quot;com.dummy.test.a*&quot;/&gt;
     &lt;group title=&quot;Group 2 Packages&quot; packages=&quot;com.dummy.test.b*:com.dummy.test.c*&quot;/&gt;
     &lt;link offline=&quot;true&quot; href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot; packagelistLoc=&quot;C:\tmp&quot;/&gt;
     &lt;link href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot;/&gt;
   &lt/javadoc&gt;</pre>
 
 
 
 </body>
 </html>
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
index 572720448..f0e7bb166 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
@@ -1,2589 +1,2618 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.DirSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.JavaEnvUtils;
 
 /**
  * Generates Javadoc documentation for a collection
  * of source code.
  *
  * <p>Current known limitations are:
  *
  * <p><ul>
  *    <li>patterns must be of the form "xxx.*", every other pattern doesn't
  *        work.
  *    <li>there is no control on arguments sanity since they are left
  *        to the Javadoc implementation.
  * </ul>
  *
  * <p>If no <code>doclet</code> is set, then the <code>version</code> and
  * <code>author</code> are by default <code>"yes"</code>.
  *
  * <p>Note: This task is run on another VM because the Javadoc code calls
  * <code>System.exit()</code> which would break Ant functionality.
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 public class Javadoc extends Task {
     // Whether *this VM* is 1.4+ (but also check executable != null).
 
     private static final boolean JAVADOC_5 =
         !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);
 
     private static final String LOAD_FRAME = "function loadFrames() {";
     private static final int LOAD_FRAME_LEN = LOAD_FRAME.length();
 
     /**
      * Inner class used to manage doclet parameters.
      */
     public class DocletParam {
         /** The parameter name */
         private String name;
 
         /** The parameter value */
         private String value;
 
         /**
          * Set the name of the parameter.
          *
          * @param name the name of the doclet parameter
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the parameter name.
          *
          * @return the parameter's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the parameter value.
          *
          * Note that only string values are supported. No resolution of file
          * paths is performed.
          *
          * @param value the parameter value.
          */
         public void setValue(String value) {
             this.value = value;
         }
 
         /**
          * Get the parameter value.
          *
          * @return the parameter value.
          */
         public String getValue() {
             return value;
         }
     }
 
     /**
      * A project aware class used for Javadoc extensions which take a name
      * and a path such as doclet and taglet arguments.
      *
      */
     public static class ExtensionInfo extends ProjectComponent {
         /** The name of the extension */
         private String name;
 
         /** The optional path to use to load the extension */
         private Path path;
 
         /**
          * Set the name of the extension
          *
          * @param name the extension's name.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the name of the extension.
          *
          * @return the extension's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the path to use when loading the component.
          *
          * @param path a Path instance containing the classpath to use.
          */
         public void setPath(Path path) {
             if (this.path == null) {
                 this.path = path;
             } else {
                 this.path.append(path);
             }
         }
 
         /**
          * Get the extension's path.
          *
          * @return the path to be used to load the extension.
          * May be <code>null</code>
          */
         public Path getPath() {
             return path;
         }
 
         /**
          * Create an empty nested path to be configured by Ant with the
          * classpath for the extension.
          *
          * @return a new Path instance to be configured.
          */
         public Path createPath() {
             if (path == null) {
                 path = new Path(getProject());
             }
             return path.createPath();
         }
 
         /**
          * Adds a reference to a CLASSPATH defined elsewhere.
          *
          * @param r the reference containing the path.
          */
         public void setPathRef(Reference r) {
             createPath().setRefid(r);
         }
     }
 
     /**
      * This class stores info about doclets.
      *
      */
     public class DocletInfo extends ExtensionInfo {
 
         /** Collection of doclet parameters. */
         private Vector<DocletParam> params = new Vector<DocletParam>();
 
         /**
          * Create a doclet parameter to be configured by Ant.
          *
          * @return a new DocletParam instance to be configured.
          */
         public DocletParam createParam() {
             DocletParam param = new DocletParam();
             params.addElement(param);
 
             return param;
         }
 
         /**
          * Get the doclet's parameters.
          *
          * @return an Enumeration of DocletParam instances.
          */
         public Enumeration<DocletParam> getParams() {
             return params.elements();
         }
     }
 
     /**
      * Used to track info about the packages to be javadoc'd
      */
     public static class PackageName {
         /** The package name */
         private String name;
 
         /**
          * Set the name of the package
          *
          * @param name the package name.
          */
         public void setName(String name) {
             this.name = name.trim();
         }
 
         /**
          * Get the package name.
          *
          * @return the package's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Return a string rep for this object.
          * @return the package name.
          */
         public String toString() {
             return getName();
         }
     }
 
     /**
      * This class is used to manage the source files to be processed.
      */
     public static class SourceFile {
         /** The source file */
         private File file;
 
         /**
          * Default constructor
          */
         public SourceFile() {
             //empty
         }
 
         /**
          * Constructor specifying the source file directly
          *
          * @param file the source file
          */
         public SourceFile(File file) {
             this.file = file;
         }
 
         /**
          * Set the source file.
          *
          * @param file the source file.
          */
         public void setFile(File file) {
             this.file = file;
         }
 
         /**
          * Get the source file.
          *
          * @return the source file.
          */
         public File getFile() {
             return file;
         }
     }
 
     /**
      * An HTML element in the Javadoc.
      *
      * This class is used for those Javadoc elements which contain HTML such as
      * footers, headers, etc.
      */
     public static class Html {
         /** The text for the element */
         private StringBuffer text = new StringBuffer();
 
         /**
          * Add text to the element.
          *
          * @param t the text to be added.
          */
         public void addText(String t) {
             text.append(t);
         }
 
         /**
          * Get the current text for the element.
          *
          * @return the current text.
          */
         public String getText() {
             return text.substring(0);
         }
     }
 
     /**
      * EnumeratedAttribute implementation supporting the Javadoc scoping
      * values.
      */
     public static class AccessType extends EnumeratedAttribute {
         /**
          * @return the allowed values for the access type.
          */
         public String[] getValues() {
             // Protected first so if any GUI tool offers a default
             // based on enum #0, it will be right.
             return new String[] {"protected", "public", "package", "private"};
         }
     }
 
     /**
      * Holds a collection of ResourceCollections.
      *
      * <p>A separate kind of container is needed since this task
      * contains special handling for FileSets that has to occur at
      * task runtime.</p>
      */
     public class ResourceCollectionContainer {
         private ArrayList<ResourceCollection> rcs = new ArrayList<ResourceCollection>();
         /**
          * Add a resource collection to the container.
          * @param rc the collection to add.
          */
         public void add(ResourceCollection rc) {
             rcs.add(rc);
         }
 
         /**
          * Get an iterator on the collection.
          * @return an iterator.
          */
         private Iterator<ResourceCollection> iterator() {
             return rcs.iterator();
         }
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** The command line built to execute Javadoc. */
     private Commandline cmd = new Commandline();
 
     /**
      * Utility method to add an argument to the command line conditionally
      * based on the given flag.
      *
      * @param b the flag which controls if the argument is added.
      * @param arg the argument value.
      */
     private void addArgIf(boolean b, String arg) {
         if (b) {
             cmd.createArgument().setValue(arg);
         }
     }
 
     /**
      * Utility method to add a Javadoc argument.
      *
      * @param key the argument name.
      * @param value the argument value.
      */
     private void addArgIfNotEmpty(String key, String value) {
         if (value != null && value.length() != 0) {
             cmd.createArgument().setValue(key);
             cmd.createArgument().setValue(value);
         } else {
             log("Warning: Leaving out empty argument '" + key + "'",
                 Project.MSG_WARN);
         }
     }
 
     /**
      * Flag which indicates if the task should fail if there is a
      * Javadoc error.
      */
     private boolean failOnError = false;
+    /**
+     * Flag which indicates if the task should fail if there is a
+     * Javadoc warning.
+     */
+    private boolean failOnWarning = false;
     private Path sourcePath = null;
     private File destDir = null;
     private Vector<SourceFile> sourceFiles = new Vector<SourceFile>();
     private Vector<PackageName> packageNames = new Vector<PackageName>();
     private Vector<PackageName> excludePackageNames = new Vector<PackageName>(1);
     private boolean author = true;
     private boolean version = true;
     private DocletInfo doclet = null;
     private Path classpath = null;
     private Path bootclasspath = null;
     private String group = null;
     private String packageList = null;
     private Vector<LinkArgument> links = new Vector<LinkArgument>();
     private Vector<GroupArgument> groups = new Vector<GroupArgument>();
     private Vector<Object> tags = new Vector<Object>();
     private boolean useDefaultExcludes = true;
     private Html doctitle = null;
     private Html header = null;
     private Html footer = null;
     private Html bottom = null;
     private boolean useExternalFile = false;
     private String source = null;
     private boolean linksource = false;
     private boolean breakiterator = false;
     private String noqualifier;
     private boolean includeNoSourcePackages = false;
     private String executable = null;
     private boolean docFilesSubDirs = false;
     private String excludeDocFilesSubDir = null;
     private String docEncoding = null;
     private boolean postProcessGeneratedJavadocs = true;
 
     private ResourceCollectionContainer nestedSourceFiles
         = new ResourceCollectionContainer();
     private Vector<DirSet> packageSets = new Vector<DirSet>();
 
     /**
      * Work around command line length limit by using an external file
      * for the sourcefiles.
      *
      * @param b true if an external file is to be used.
      */
     public void setUseExternalFile(boolean b) {
         useExternalFile = b;
     }
 
     /**
      * Sets whether default exclusions should be used or not.
      *
      * @param useDefaultExcludes "true"|"on"|"yes" when default exclusions
      *                           should be used, "false"|"off"|"no" when they
      *                           shouldn't be used.
      */
     public void setDefaultexcludes(boolean useDefaultExcludes) {
         this.useDefaultExcludes = useDefaultExcludes;
     }
 
     /**
      * Set the maximum memory to be used by the javadoc process
      *
      * @param max a string indicating the maximum memory according to the
      *        JVM conventions (e.g. 128m is 128 Megabytes)
      */
     public void setMaxmemory(String max) {
         cmd.createArgument().setValue("-J-Xmx" + max);
     }
 
     /**
      * Set an additional parameter on the command line
      *
      * @param add the additional command line parameter for the javadoc task.
      */
     public void setAdditionalparam(String add) {
         cmd.createArgument().setLine(add);
     }
 
     /**
      * Adds a command-line argument.
      * @return a command-line argument to configure
      * @since Ant 1.6
      */
     public Commandline.Argument createArg() {
         return cmd.createArgument();
     }
 
     /**
      * Specify where to find source file
      *
      * @param src a Path instance containing the various source directories.
      */
     public void setSourcepath(Path src) {
         if (sourcePath == null) {
             sourcePath = src;
         } else {
             sourcePath.append(src);
         }
     }
 
     /**
      * Create a path to be configured with the locations of the source
      * files.
      *
      * @return a new Path instance to be configured by the Ant core.
      */
     public Path createSourcepath() {
         if (sourcePath == null) {
             sourcePath = new Path(getProject());
         }
         return sourcePath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference containing the source path definition.
      */
     public void setSourcepathRef(Reference r) {
         createSourcepath().setRefid(r);
     }
 
     /**
      * Set the directory where the Javadoc output will be generated.
      *
      * @param dir the destination directory.
      */
     public void setDestdir(File dir) {
         destDir = dir;
         cmd.createArgument().setValue("-d");
         cmd.createArgument().setFile(destDir);
     }
 
     /**
      * Set the list of source files to process.
      *
      * @param src a comma separated list of source files.
      */
     public void setSourcefiles(String src) {
         StringTokenizer tok = new StringTokenizer(src, ",");
         while (tok.hasMoreTokens()) {
             String f = tok.nextToken();
             SourceFile sf = new SourceFile();
             sf.setFile(getProject().resolveFile(f.trim()));
             addSource(sf);
         }
     }
 
     /**
      * Add a single source file.
      *
      * @param sf the source file to be processed.
      */
     public void addSource(SourceFile sf) {
         sourceFiles.addElement(sf);
     }
 
     /**
      * Set the package names to be processed.
      *
      * @param packages a comma separated list of packages specs
      *        (may be wildcarded).
      *
      * @see #addPackage for wildcard information.
      */
     public void setPackagenames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addPackage(pn);
         }
     }
 
     /**
      * Add a single package to be processed.
      *
      * If the package name ends with &quot;.*&quot; the Javadoc task
      * will find and process all subpackages.
      *
      * @param pn the package name, possibly wildcarded.
      */
     public void addPackage(PackageName pn) {
         packageNames.addElement(pn);
     }
 
     /**
      * Set the list of packages to be excluded.
      *
      * @param packages a comma separated list of packages to be excluded.
      *        This may not include wildcards.
      */
     public void setExcludePackageNames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addExcludePackage(pn);
         }
     }
 
     /**
      * Add a package to be excluded from the Javadoc run.
      *
      * @param pn the name of the package (wildcards are not permitted).
      */
     public void addExcludePackage(PackageName pn) {
         excludePackageNames.addElement(pn);
     }
 
     /**
      * Specify the file containing the overview to be included in the generated
      * documentation.
      *
      * @param f the file containing the overview.
      */
     public void setOverview(File f) {
         cmd.createArgument().setValue("-overview");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Indicate whether only public classes and members are to be included in
      * the scope processed
      *
      * @param b true if scope is to be public.
      */
     public void setPublic(boolean b) {
         addArgIf(b, "-public");
     }
 
     /**
      * Indicate whether only protected and public classes and members are to
      * be included in the scope processed
      *
      * @param b true if scope is to be protected.
      */
     public void setProtected(boolean b) {
         addArgIf(b, "-protected");
     }
 
     /**
      * Indicate whether only package, protected and public classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be package level.
      */
     public void setPackage(boolean b) {
         addArgIf(b, "-package");
     }
 
     /**
      * Indicate whether all classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be private level.
      */
     public void setPrivate(boolean b) {
         addArgIf(b, "-private");
     }
 
     /**
      * Set the scope to be processed. This is an alternative to the
      * use of the setPublic, setPrivate, etc methods. It gives better build
      * file control over what scope is processed.
      *
      * @param at the scope to be processed.
      */
     public void setAccess(AccessType at) {
         cmd.createArgument().setValue("-" + at.getValue());
     }
 
     /**
      * Set the class that starts the doclet used in generating the
      * documentation.
      *
      * @param docletName the name of the doclet class.
      */
     public void setDoclet(String docletName) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setName(docletName);
     }
 
     /**
      * Set the classpath used to find the doclet class.
      *
      * @param docletPath the doclet classpath.
      */
     public void setDocletPath(Path docletPath) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setPath(docletPath);
     }
 
     /**
      * Set the classpath used to find the doclet class by reference.
      *
      * @param r the reference to the Path instance to use as the doclet
      *        classpath.
      */
     public void setDocletPathRef(Reference r) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.createPath().setRefid(r);
     }
 
     /**
      * Create a doclet to be used in the documentation generation.
      *
      * @return a new DocletInfo instance to be configured.
      */
     public DocletInfo createDoclet() {
         if (doclet == null) {
             doclet = new DocletInfo();
         }
         return doclet;
     }
 
     /**
      * Add a taglet
      *
      * @param tagletInfo information about the taglet.
      */
     public void addTaglet(ExtensionInfo tagletInfo) {
         tags.addElement(tagletInfo);
     }
 
     /**
      * Indicate whether Javadoc should produce old style (JDK 1.1)
      * documentation.
      *
      * This is not supported by JDK 1.1 and has been phased out in JDK 1.4
      *
      * @param b if true attempt to generate old style documentation.
      */
     public void setOld(boolean b) {
         log("Javadoc 1.4 doesn't support the -1.1 switch anymore",
             Project.MSG_WARN);
     }
 
     /**
      * Set the classpath to be used for this Javadoc run.
      *
      * @param path an Ant Path object containing the compilation
      *        classpath.
      */
     public void setClasspath(Path path) {
         if (classpath == null) {
             classpath = path;
         } else {
             classpath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the classpath to use
      *
      * @return a new Path instance to be configured with the classpath.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the boot classpath to use.
      *
      * @param path the boot classpath.
      */
     public void setBootclasspath(Path path) {
         if (bootclasspath == null) {
             bootclasspath = path;
         } else {
             bootclasspath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the boot classpath
      *
      * @return a new Path instance to be configured with the boot classpath.
      */
     public Path createBootclasspath() {
         if (bootclasspath == null) {
             bootclasspath = new Path(getProject());
         }
         return bootclasspath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the bootclasspath.
      */
     public void setBootClasspathRef(Reference r) {
         createBootclasspath().setRefid(r);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path the string version of the path.
      * @deprecated since 1.5.x.
      *             Use the {@link #setExtdirs(Path)} version.
      */
     public void setExtdirs(String path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setValue(path);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path a path containing the extension directories.
      */
     public void setExtdirs(Path path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setPath(path);
     }
 
     /**
      * Run javadoc in verbose mode
      *
      * @param b true if operation is to be verbose.
      */
     public void setVerbose(boolean b) {
         addArgIf(b, "-verbose");
     }
 
     /**
      * Set the local to use in documentation generation.
      *
      * @param locale the locale to use.
      */
     public void setLocale(String locale) {
         // createArgument(true) is necessary to make sure -locale
         // is the first argument (required in 1.3+).
         cmd.createArgument(true).setValue(locale);
         cmd.createArgument(true).setValue("-locale");
     }
 
     /**
      * Set the encoding name of the source files,
      *
      * @param enc the name of the encoding for the source files.
      */
     public void setEncoding(String enc) {
         cmd.createArgument().setValue("-encoding");
         cmd.createArgument().setValue(enc);
     }
 
     /**
      * Include the version tag in the generated documentation.
      *
      * @param b true if the version tag should be included.
      */
     public void setVersion(boolean b) {
         this.version = b;
     }
 
     /**
      * Generate the &quot;use&quot page for each package.
      *
      * @param b true if the use page should be generated.
      */
     public void setUse(boolean b) {
         addArgIf(b, "-use");
     }
 
 
     /**
      * Include the author tag in the generated documentation.
      *
      * @param b true if the author tag should be included.
      */
     public void setAuthor(boolean b) {
         author = b;
     }
 
     /**
      * Generate a split index
      *
      * @param b true if the index should be split into a file per letter.
      */
     public void setSplitindex(boolean b) {
         addArgIf(b, "-splitindex");
     }
 
     /**
      * Set the title to be placed in the HTML &lt;title&gt; tag of the
      * generated documentation.
      *
      * @param title the window title to use.
      */
     public void setWindowtitle(String title) {
         addArgIfNotEmpty("-windowtitle", title);
     }
 
     /**
      * Set the title of the generated overview page.
      *
      * @param doctitle the Document title.
      */
     public void setDoctitle(String doctitle) {
         Html h = new Html();
         h.addText(doctitle);
         addDoctitle(h);
     }
 
     /**
      * Add a document title to use for the overview page.
      *
      * @param text the HTML element containing the document title.
      */
     public void addDoctitle(Html text) {
         doctitle = text;
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param header the header text
      */
     public void setHeader(String header) {
         Html h = new Html();
         h.addText(header);
         addHeader(h);
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param text the header text
      */
     public void addHeader(Html text) {
         header = text;
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param footer the footer text.
      */
     public void setFooter(String footer) {
         Html h = new Html();
         h.addText(footer);
         addFooter(h);
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param text the footer text.
      */
     public void addFooter(Html text) {
         footer = text;
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param bottom the bottom text.
      */
     public void setBottom(String bottom) {
         Html h = new Html();
         h.addText(bottom);
         addBottom(h);
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param text the bottom text.
      */
     public void addBottom(Html text) {
         bottom = text;
     }
 
     /**
      * Link to docs at "url" using package list at "url2"
      * - separate the URLs by using a space character.
      *
      * @param src the offline link specification (url and package list)
      */
     public void setLinkoffline(String src) {
         LinkArgument le = createLink();
         le.setOffline(true);
         String linkOfflineError = "The linkoffline attribute must include"
             + " a URL and a package-list file location separated by a"
             + " space";
         if (src.trim().length() == 0) {
             throw new BuildException(linkOfflineError);
         }
         StringTokenizer tok = new StringTokenizer(src, " ", false);
         le.setHref(tok.nextToken());
 
         if (!tok.hasMoreTokens()) {
             throw new BuildException(linkOfflineError);
         }
         le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
     }
 
     /**
      * Group specified packages together in overview page.
      *
      * @param src the group packages - a command separated list of group specs,
      *        each one being a group name and package specification separated
      *        by a space.
      */
     public void setGroup(String src) {
         group = src;
     }
 
     /**
      * Create links to Javadoc output at the given URL.
      * @param src the URL to link to
      */
     public void setLink(String src) {
         createLink().setHref(src);
     }
 
     /**
      * Control deprecation information
      *
      * @param b If true, do not include deprecated information.
      */
     public void setNodeprecated(boolean b) {
         addArgIf(b, "-nodeprecated");
     }
 
     /**
      * Control deprecated list generation
      *
      * @param b if true, do not generate deprecated list.
      */
     public void setNodeprecatedlist(boolean b) {
         addArgIf(b, "-nodeprecatedlist");
     }
 
     /**
      * Control class tree generation.
      *
      * @param b if true, do not generate class hierarchy.
      */
     public void setNotree(boolean b) {
         addArgIf(b, "-notree");
     }
 
     /**
      * Control generation of index.
      *
      * @param b if true, do not generate index.
      */
     public void setNoindex(boolean b) {
         addArgIf(b, "-noindex");
     }
 
     /**
      * Control generation of help link.
      *
      * @param b if true, do not generate help link
      */
     public void setNohelp(boolean b) {
         addArgIf(b, "-nohelp");
     }
 
     /**
      * Control generation of the navigation bar.
      *
      * @param b if true, do not generate navigation bar.
      */
     public void setNonavbar(boolean b) {
         addArgIf(b, "-nonavbar");
     }
 
     /**
      * Control warnings about serial tag.
      *
      * @param b if true, generate warning about the serial tag.
      */
     public void setSerialwarn(boolean b) {
         addArgIf(b, "-serialwarn");
     }
 
     /**
      * Specifies the CSS stylesheet file to use.
      *
      * @param f the file with the CSS to use.
      */
     public void setStylesheetfile(File f) {
         cmd.createArgument().setValue("-stylesheetfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Specifies the HTML help file to use.
      *
      * @param f the file containing help content.
      */
     public void setHelpfile(File f) {
         cmd.createArgument().setValue("-helpfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Output file encoding name.
      *
      * @param enc name of the encoding to use.
      */
     public void setDocencoding(String enc) {
         cmd.createArgument().setValue("-docencoding");
         cmd.createArgument().setValue(enc);
         docEncoding = enc;
     }
 
     /**
      * The name of a file containing the packages to process.
      *
      * @param src the file containing the package list.
      */
     public void setPackageList(String src) {
         packageList = src;
     }
 
     /**
      * Create link to Javadoc output at the given URL.
      *
      * @return link argument to configure
      */
     public LinkArgument createLink() {
         LinkArgument la = new LinkArgument();
         links.addElement(la);
         return la;
     }
 
     /**
      * Represents a link triplet (href, whether link is offline,
      * location of the package list if off line)
      */
     public class LinkArgument {
         private String href;
         private boolean offline = false;
         private File packagelistLoc;
         private URL packagelistURL;
         private boolean resolveLink = false;
 
         /** Constructor for LinkArgument */
         public LinkArgument() {
             //empty
         }
 
         /**
          * Set the href attribute.
          * @param hr a <code>String</code> value
          */
         public void setHref(String hr) {
             href = hr;
         }
 
         /**
          * Get the href attribute.
          * @return the href attribute.
          */
         public String getHref() {
             return href;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src a <code>File</code> value
          */
         public void setPackagelistLoc(File src) {
             packagelistLoc = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public File getPackagelistLoc() {
             return packagelistLoc;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src an <code>URL</code> value
          */
         public void setPackagelistURL(URL src) {
             packagelistURL = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public URL getPackagelistURL() {
             return packagelistURL;
         }
 
         /**
          * Set the offline attribute.
          * @param offline a <code>boolean</code> value
          */
         public void setOffline(boolean offline) {
             this.offline = offline;
         }
 
         /**
          * Get the linkOffline attribute.
          * @return the linkOffline attribute.
          */
         public boolean isLinkOffline() {
             return offline;
         }
 
         /**
          * Sets whether Ant should resolve the link attribute relative
          * to the current basedir.
          * @param resolve a <code>boolean</code> value
          */
         public void setResolveLink(boolean resolve) {
             this.resolveLink = resolve;
         }
 
         /**
          * should Ant resolve the link attribute relative to the
          * current basedir?
          * @return the resolveLink attribute.
          */
         public boolean shouldResolveLink() {
             return resolveLink;
         }
 
     }
 
     /**
      * Creates and adds a -tag argument. This is used to specify
      * custom tags. This argument is only available for Javadoc 1.4,
      * and will generate a verbose message (and then be ignored)
      * when run on Java versions below 1.4.
      * @return tag argument to be configured
      */
     public TagArgument createTag() {
         TagArgument ta = new TagArgument();
         tags.addElement (ta);
         return ta;
     }
 
     /**
      * Scope element verbose names. (Defined here as fields
      * cannot be static in inner classes.) The first letter
      * from each element is used to build up the scope string.
      */
     static final String[] SCOPE_ELEMENTS = {
         "overview", "packages", "types", "constructors",
         "methods", "fields"
     };
 
     /**
      * Class representing a -tag argument.
      */
     public class TagArgument extends FileSet {
         /** Name of the tag. */
         private String name = null;
         /** Whether or not the tag is enabled. */
         private boolean enabled = true;
         /**
          * Scope string of the tag. This will form the middle
          * argument of the -tag parameter when the tag is enabled
          * (with an X prepended for and is parsed from human-readable form.
          */
         private String scope = "a";
 
         /** Sole constructor. */
         public TagArgument () {
             //empty
         }
 
         /**
          * Sets the name of the tag.
          *
          * @param name The name of the tag.
          *             Must not be <code>null</code> or empty.
          */
         public void setName (String name) {
             this.name = name;
         }
 
         /**
          * Sets the scope of the tag. This is in comma-separated
          * form, with each element being one of "all" (the default),
          * "overview", "packages", "types", "constructors", "methods",
          * "fields". The elements are treated in a case-insensitive
          * manner.
          *
          * @param verboseScope The scope of the tag.
          *                     Must not be <code>null</code>,
          *                     should not be empty.
          *
          * @exception BuildException if all is specified along with
          * other elements, if any elements are repeated, if no
          * elements are specified, or if any unrecognised elements are
          * specified.
          */
         public void setScope (String verboseScope) throws BuildException {
             verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);
 
             boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
 
             boolean gotAll = false;
             boolean gotNotAll = false;
 
             // Go through the tokens one at a time, updating the
             // elements array and issuing warnings where appropriate.
             StringTokenizer tok = new StringTokenizer (verboseScope, ",");
             while (tok.hasMoreTokens()) {
                 String next = tok.nextToken().trim();
                 if (next.equals("all")) {
                     if (gotAll) {
                         getProject().log ("Repeated tag scope element: all",
                                           Project.MSG_VERBOSE);
                     }
                     gotAll = true;
                 } else {
                     int i;
                     for (i = 0; i < SCOPE_ELEMENTS.length; i++) {
                         if (next.equals (SCOPE_ELEMENTS[i])) {
                             break;
                         }
                     }
                     if (i == SCOPE_ELEMENTS.length) {
                         throw new BuildException ("Unrecognised scope element: "
                                                   + next);
                     } else {
                         if (elements[i]) {
                             getProject().log ("Repeated tag scope element: "
                                               + next, Project.MSG_VERBOSE);
                         }
                         elements[i] = true;
                         gotNotAll = true;
                     }
                 }
             }
 
             if (gotNotAll && gotAll) {
                 throw new BuildException ("Mixture of \"all\" and other scope "
                                           + "elements in tag parameter.");
             }
             if (!gotNotAll && !gotAll) {
                 throw new BuildException ("No scope elements specified in tag "
                                           + "parameter.");
             }
             if (gotAll) {
                 this.scope = "a";
             } else {
                 StringBuffer buff = new StringBuffer (elements.length);
                 for (int i = 0; i < elements.length; i++) {
                     if (elements[i]) {
                         buff.append (SCOPE_ELEMENTS[i].charAt(0));
                     }
                 }
                 this.scope = buff.toString();
             }
         }
 
         /**
          * Sets whether or not the tag is enabled.
          *
          * @param enabled Whether or not this tag is enabled.
          */
         public void setEnabled (boolean enabled) {
             this.enabled = enabled;
         }
 
         /**
          * Returns the -tag parameter this argument represented.
          * @return the -tag parameter as a string
          * @exception BuildException if either the name or description
          *                           is <code>null</code> or empty.
          */
         public String getParameter() throws BuildException {
             if (name == null || name.equals("")) {
                 throw new BuildException ("No name specified for custom tag.");
             }
             if (getDescription() != null) {
                 return name + ":" + (enabled ? "" : "X")
                     + scope + ":" + getDescription();
             } else if (!enabled || !"a".equals(scope)) {
                 return name + ":" + (enabled ? "" : "X") + scope;
             } else {
                 return name;
             }
         }
     }
 
     /**
      * Separates packages on the overview page into whatever
      * groups you specify, one group per table.
      * @return a group argument to be configured
      */
     public GroupArgument createGroup() {
         GroupArgument ga = new GroupArgument();
         groups.addElement(ga);
         return ga;
     }
 
 
     /**
      * A class corresponding to the group nested element.
      */
     public class GroupArgument {
         private Html title;
         private Vector<PackageName> packages = new Vector<PackageName>();
 
         /** Constructor for GroupArgument */
         public GroupArgument() {
             //empty
         }
 
         /**
          * Set the title attribute using a string.
          * @param src a <code>String</code> value
          */
         public void setTitle(String src) {
             Html h = new Html();
             h.addText(src);
             addTitle(h);
         }
         /**
          * Set the title attribute using a nested Html value.
          * @param text a <code>Html</code> value
          */
         public void addTitle(Html text) {
             title = text;
         }
 
         /**
          * Get the title.
          * @return the title
          */
         public String getTitle() {
             return title != null ? title.getText() : null;
         }
 
         /**
          * Set the packages to Javadoc on.
          * @param src a comma separated list of packages
          */
         public void setPackages(String src) {
             StringTokenizer tok = new StringTokenizer(src, ",");
             while (tok.hasMoreTokens()) {
                 String p = tok.nextToken();
                 PackageName pn = new PackageName();
                 pn.setName(p);
                 addPackage(pn);
             }
         }
         /**
          * Add a package nested element.
          * @param pn a nested element specifying the package.
          */
         public void addPackage(PackageName pn) {
             packages.addElement(pn);
         }
 
         /**
          * Get the packages as a colon separated list.
          * @return the packages as a string
          */
         public String getPackages() {
             StringBuffer p = new StringBuffer();
             final int size = packages.size();
             for (int i = 0; i < size; i++) {
                 if (i > 0) {
                     p.append(":");
                 }
                 p.append(packages.elementAt(i).toString());
             }
             return p.toString();
         }
     }
 
     /**
      * Charset for cross-platform viewing of generated documentation.
      * @param src the name of the charset
      */
     public void setCharset(String src) {
         this.addArgIfNotEmpty("-charset", src);
     }
 
     /**
      * Should the build process fail if Javadoc fails (as indicated by
      * a non zero return code)?
      *
      * <p>Default is false.</p>
      * @param b a <code>boolean</code> value
      */
     public void setFailonerror(boolean b) {
         failOnError = b;
     }
 
     /**
+     * Should the build process fail if Javadoc warns (as indicated by
+     * the word "warning" on stdout)?
+     *
+     * <p>Default is false.</p>
+     * @param b a <code>boolean</code> value
+     * @since Ant 1.9.4
+     */
+    public void setFailonwarning(boolean b) {
+        failOnWarning = b;
+    }
+
+    /**
      * Enables the -source switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param source a <code>String</code> value
      * @since Ant 1.5
      */
     public void setSource(String source) {
         this.source = source;
     }
 
     /**
      * Sets the actual executable command to invoke, instead of the binary
      * <code>javadoc</code> found in Ant's JDK.
      * @param executable the command to invoke.
      * @since Ant 1.6.3
      */
     public void setExecutable(String executable) {
         this.executable = executable;
     }
 
     /**
      * Adds a packageset.
      *
      * <p>All included directories will be translated into package
      * names be converting the directory separator into dots.</p>
      * @param packageSet a directory set
      * @since 1.5
      */
     public void addPackageset(DirSet packageSet) {
         packageSets.addElement(packageSet);
     }
 
     /**
      * Adds a fileset.
      *
      * <p>All included files will be added as sourcefiles.  The task
      * will automatically add
      * <code>includes=&quot;**&#47;*.java&quot;</code> to the
      * fileset.</p>
      * @param fs a file set
      * @since 1.5
      */
     public void addFileset(FileSet fs) {
         createSourceFiles().add(fs);
     }
 
     /**
      * Adds a container for resource collections.
      *
      * <p>All included files will be added as sourcefiles.</p>
      * @return the source files to configure.
      * @since 1.7
      */
     public ResourceCollectionContainer createSourceFiles() {
         return nestedSourceFiles;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setLinksource(boolean b) {
         this.linksource = b;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setBreakiterator(boolean b) {
         this.breakiterator = b;
     }
 
     /**
      * Enables the -noqualifier switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param noqualifier the parameter to the -noqualifier switch
      * @since Ant 1.6
      */
     public void setNoqualifier(String noqualifier) {
         this.noqualifier = noqualifier;
     }
 
     /**
      * If set to true, Ant will also accept packages that only hold
      * package.html files but no Java sources.
      * @param b a <code>boolean</code> value.
      * @since Ant 1.6.3
      */
     public void setIncludeNoSourcePackages(boolean b) {
         this.includeNoSourcePackages = b;
     }
 
     /**
      * Enables deep-copying of <code>doc-files</code> directories.
      *
      * @since Ant 1.8.0
      */
     public void setDocFilesSubDirs(boolean b) {
         docFilesSubDirs = b;
     }
 
     /**
      * Colon-separated list of <code>doc-files</code> subdirectories
      * to skip if {@link #setDocFilesSubDirs docFilesSubDirs is true}.
      *
      * @since Ant 1.8.0
      */
     public void setExcludeDocFilesSubDir(String s) {
         excludeDocFilesSubDir = s;
     }
 
     /**
      * Whether to post-process the generated javadocs in order to mitigate CVE-2013-1571.
      * @since Ant 1.9.2
      */
     public void setPostProcessGeneratedJavadocs(boolean b) {
         postProcessGeneratedJavadocs = b;
     }
 
     /**
      * Execute the task.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         checkTaskName();
 
         Vector<String> packagesToDoc = new Vector<String>();
         Path sourceDirs = new Path(getProject());
 
         checkPackageAndSourcePath();
 
         if (sourcePath != null) {
             sourceDirs.addExisting(sourcePath);
         }
 
         parsePackages(packagesToDoc, sourceDirs);
         checkPackages(packagesToDoc, sourceDirs);
 
         @SuppressWarnings("unchecked")
         Vector<SourceFile> sourceFilesToDoc = (Vector<SourceFile>) sourceFiles.clone();
         addSourceFiles(sourceFilesToDoc);
 
         checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
 
         log("Generating Javadoc", Project.MSG_INFO);
 
         Commandline toExecute = (Commandline) cmd.clone();
         if (executable != null) {
             toExecute.setExecutable(executable);
         } else {
             toExecute.setExecutable(JavaEnvUtils.getJdkExecutable("javadoc"));
         }
 
         //  Javadoc arguments
         generalJavadocArguments(toExecute);  // general Javadoc arguments
         doSourcePath(toExecute, sourceDirs); // sourcepath
         doDoclet(toExecute);   // arguments for default doclet
         doBootPath(toExecute); // bootpath
         doLinks(toExecute);    // links arguments
         doGroup(toExecute);    // group attribute
         doGroups(toExecute);  // groups attribute
         doDocFilesSubDirs(toExecute); // docfilessubdir attribute
 
         doJava14(toExecute);
         if (breakiterator && (doclet == null || JAVADOC_5)) {
             toExecute.createArgument().setValue("-breakiterator");
         }
         // If using an external file, write the command line options to it
         if (useExternalFile) {
             writeExternalArgs(toExecute);
         }
 
         File tmpList = null;
         FileWriter wr = null;
         try {
             /**
              * Write sourcefiles and package names to a temporary file
              * if requested.
              */
             BufferedWriter srcListWriter = null;
             if (useExternalFile) {
                 tmpList = FILE_UTILS.createTempFile("javadoc", "", null, true, true);
                 toExecute.createArgument()
                     .setValue("@" + tmpList.getAbsolutePath());
                 wr = new FileWriter(tmpList.getAbsolutePath(), true);
                 srcListWriter = new BufferedWriter(wr);
             }
 
             doSourceAndPackageNames(
                 toExecute, packagesToDoc, sourceFilesToDoc,
                 useExternalFile, tmpList, srcListWriter);
 
             if (useExternalFile) {
                 srcListWriter.flush();
             }
         } catch (IOException e) {
             tmpList.delete();
             throw new BuildException("Error creating temporary file",
                                      e, getLocation());
         } finally {
             FileUtils.close(wr);
         }
 
         if (packageList != null) {
             toExecute.createArgument().setValue("@" + packageList);
         }
         log(toExecute.describeCommand(), Project.MSG_VERBOSE);
 
         log("Javadoc execution", Project.MSG_INFO);
 
         JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
         JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
         Execute exe = new Execute(new PumpStreamHandler(out, err));
         exe.setAntRun(getProject());
 
         /*
          * No reason to change the working directory as all filenames and
          * path components have been resolved already.
          *
          * Avoid problems with command line length in some environments.
          */
         exe.setWorkingDirectory(null);
         try {
             exe.setCommandline(toExecute.getCommandline());
             int ret = exe.execute();
             if (ret != 0 && failOnError) {
                 throw new BuildException("Javadoc returned " + ret,
                                          getLocation());
             }
+            if (out.sawWarnings() && failOnWarning) {
+                throw new BuildException("Javadoc issued warnings.",
+                                         getLocation());
+            }
             postProcessGeneratedJavadocs();
         } catch (IOException e) {
             throw new BuildException("Javadoc failed: " + e, e, getLocation());
         } finally {
             if (tmpList != null) {
                 tmpList.delete();
                 tmpList = null;
             }
 
             out.logFlush();
             err.logFlush();
             try {
                 out.close();
                 err.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 
     private void checkTaskName() {
         if ("javadoc2".equals(getTaskType())) {
             log("Warning: the task name <javadoc2> is deprecated."
                 + " Use <javadoc> instead.",
                 Project.MSG_WARN);
         }
     }
 
     private void checkPackageAndSourcePath() {
         if (packageList != null && sourcePath == null) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying packagelist.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackages(Vector<String> packagesToDoc, Path sourceDirs) {
         if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying package names.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackagesToDoc(
         Vector<String> packagesToDoc, Vector<SourceFile> sourceFilesToDoc) {
         if (packageList == null && packagesToDoc.size() == 0
             && sourceFilesToDoc.size() == 0) {
             throw new BuildException("No source files and no packages have "
                                      + "been specified.");
         }
     }
 
     private void doSourcePath(Commandline toExecute, Path sourceDirs) {
         if (sourceDirs.size() > 0) {
             toExecute.createArgument().setValue("-sourcepath");
             toExecute.createArgument().setPath(sourceDirs);
         }
     }
 
     private void generalJavadocArguments(Commandline toExecute) {
         if (doctitle != null) {
             toExecute.createArgument().setValue("-doctitle");
             toExecute.createArgument().setValue(expand(doctitle.getText()));
         }
         if (header != null) {
             toExecute.createArgument().setValue("-header");
             toExecute.createArgument().setValue(expand(header.getText()));
         }
         if (footer != null) {
             toExecute.createArgument().setValue("-footer");
             toExecute.createArgument().setValue(expand(footer.getText()));
         }
         if (bottom != null) {
             toExecute.createArgument().setValue("-bottom");
             toExecute.createArgument().setValue(expand(bottom.getText()));
         }
 
         if (classpath == null) {
             classpath = (new Path(getProject())).concatSystemClasspath("last");
         } else {
             classpath = classpath.concatSystemClasspath("ignore");
         }
 
         if (classpath.size() > 0) {
             toExecute.createArgument().setValue("-classpath");
             toExecute.createArgument().setPath(classpath);
         }
 
         if (version && doclet == null) {
             toExecute.createArgument().setValue("-version");
         }
         if (author && doclet == null) {
             toExecute.createArgument().setValue("-author");
         }
 
         if (doclet == null && destDir == null) {
             throw new BuildException("destdir attribute must be set!");
         }
     }
 
     private void doDoclet(Commandline toExecute) {
         if (doclet != null) {
             if (doclet.getName() == null) {
                 throw new BuildException("The doclet name must be "
                                          + "specified.", getLocation());
             } else {
                 toExecute.createArgument().setValue("-doclet");
                 toExecute.createArgument().setValue(doclet.getName());
                 if (doclet.getPath() != null) {
                     Path docletPath
                         = doclet.getPath().concatSystemClasspath("ignore");
                     if (docletPath.size() != 0) {
                         toExecute.createArgument().setValue("-docletpath");
                         toExecute.createArgument().setPath(docletPath);
                     }
                 }
                 for (Enumeration<DocletParam> e = doclet.getParams();
                      e.hasMoreElements();) {
                     DocletParam param = e.nextElement();
                     if (param.getName() == null) {
                         throw new BuildException("Doclet parameters must "
                                                  + "have a name");
                     }
 
                     toExecute.createArgument().setValue(param.getName());
                     if (param.getValue() != null) {
                         toExecute.createArgument()
                             .setValue(param.getValue());
                     }
                 }
             }
         }
     }
 
     private void writeExternalArgs(Commandline toExecute) {
         // If using an external file, write the command line options to it
         File optionsTmpFile = null;
         BufferedWriter optionsListWriter = null;
         try {
             optionsTmpFile = FILE_UTILS.createTempFile(
                 "javadocOptions", "", null, true, true);
             String[] listOpt = toExecute.getArguments();
             toExecute.clearArgs();
             toExecute.createArgument().setValue(
                 "@" + optionsTmpFile.getAbsolutePath());
             optionsListWriter = new BufferedWriter(
                 new FileWriter(optionsTmpFile.getAbsolutePath(), true));
             for (int i = 0; i < listOpt.length; i++) {
                 String string = listOpt[i];
                 if (string.startsWith("-J-")) {
                     toExecute.createArgument().setValue(string);
                 } else  {
                     if (string.startsWith("-")) {
                         optionsListWriter.write(string);
                         optionsListWriter.write(" ");
                     } else {
                         optionsListWriter.write(quoteString(string));
                         optionsListWriter.newLine();
                     }
                 }
             }
             optionsListWriter.close();
         } catch (IOException ex) {
             if (optionsTmpFile != null) {
                 optionsTmpFile.delete();
             }
             throw new BuildException(
                 "Error creating or writing temporary file for javadoc options",
                 ex, getLocation());
         } finally {
             FileUtils.close(optionsListWriter);
         }
     }
 
     private void doBootPath(Commandline toExecute) {
         Path bcp = new Path(getProject());
         if (bootclasspath != null) {
             bcp.append(bootclasspath);
         }
         bcp = bcp.concatSystemBootClasspath("ignore");
         if (bcp.size() > 0) {
             toExecute.createArgument().setValue("-bootclasspath");
             toExecute.createArgument().setPath(bcp);
         }
     }
 
     private void doLinks(Commandline toExecute) {
         if (links.size() != 0) {
             for (Enumeration<LinkArgument> e = links.elements(); e.hasMoreElements();) {
                 LinkArgument la = e.nextElement();
 
                 if (la.getHref() == null || la.getHref().length() == 0) {
                     log("No href was given for the link - skipping",
                         Project.MSG_VERBOSE);
                     continue;
                 }
                 String link = null;
                 if (la.shouldResolveLink()) {
                     File hrefAsFile =
                         getProject().resolveFile(la.getHref());
                     if (hrefAsFile.exists()) {
                         try {
                             link = FILE_UTILS.getFileURL(hrefAsFile)
                                 .toExternalForm();
                         } catch (MalformedURLException ex) {
                             // should be impossible
                             log("Warning: link location was invalid "
                                 + hrefAsFile, Project.MSG_WARN);
                         }
                     }
                 }
                 if (link == null) {
                     // is the href a valid URL
                     try {
                         URL base = new URL("file://.");
                         new URL(base, la.getHref());
                         link = la.getHref();
                     } catch (MalformedURLException mue) {
                         // ok - just skip
                         log("Link href \"" + la.getHref()
                             + "\" is not a valid url - skipping link",
                             Project.MSG_WARN);
                         continue;
                     }
                 }
 
                 if (la.isLinkOffline()) {
                     File packageListLocation = la.getPackagelistLoc();
                     URL packageListURL = la.getPackagelistURL();
                     if (packageListLocation == null
                         && packageListURL == null) {
                         throw new BuildException("The package list"
                                                  + " location for link "
                                                  + la.getHref()
                                                  + " must be provided "
                                                  + "because the link is "
                                                  + "offline");
                     }
                     if (packageListLocation != null) {
                         File packageListFile =
                             new File(packageListLocation, "package-list");
                         if (packageListFile.exists()) {
                             try {
                                 packageListURL =
                                     FILE_UTILS.getFileURL(packageListLocation);
                             } catch (MalformedURLException ex) {
                                 log("Warning: Package list location was "
                                     + "invalid " + packageListLocation,
                                     Project.MSG_WARN);
                             }
                         } else {
                             log("Warning: No package list was found at "
                                 + packageListLocation, Project.MSG_VERBOSE);
                         }
                     }
                     if (packageListURL != null) {
                         toExecute.createArgument().setValue("-linkoffline");
                         toExecute.createArgument().setValue(link);
                         toExecute.createArgument()
                             .setValue(packageListURL.toExternalForm());
                     }
                 } else {
                     toExecute.createArgument().setValue("-link");
                     toExecute.createArgument().setValue(link);
                 }
             }
         }
     }
 
     private void doGroup(Commandline toExecute) {
         // add the single group arguments
         // Javadoc 1.2 rules:
         //   Multiple -group args allowed.
         //   Each arg includes 3 strings: -group [name] [packagelist].
         //   Elements in [packagelist] are colon-delimited.
         //   An element in [packagelist] may end with the * wildcard.
 
         // Ant javadoc task rules for group attribute:
         //   Args are comma-delimited.
         //   Each arg is 2 space-delimited strings.
         //   E.g., group="XSLT_Packages org.apache.xalan.xslt*,
         //                XPath_Packages org.apache.xalan.xpath*"
         if (group != null) {
             StringTokenizer tok = new StringTokenizer(group, ",", false);
             while (tok.hasMoreTokens()) {
                 String grp = tok.nextToken().trim();
                 int space = grp.indexOf(" ");
                 if (space > 0) {
                     String name = grp.substring(0, space);
                     String pkgList = grp.substring(space + 1);
                     toExecute.createArgument().setValue("-group");
                     toExecute.createArgument().setValue(name);
                     toExecute.createArgument().setValue(pkgList);
                 }
             }
         }
     }
 
     // add the group arguments
     private void doGroups(Commandline toExecute) {
         if (groups.size() != 0) {
             for (Enumeration<GroupArgument> e = groups.elements(); e.hasMoreElements();) {
                 GroupArgument ga = e.nextElement();
                 String title = ga.getTitle();
                 String packages = ga.getPackages();
                 if (title == null || packages == null) {
                     throw new BuildException("The title and packages must "
                                              + "be specified for group "
                                              + "elements.");
                 }
                 toExecute.createArgument().setValue("-group");
                 toExecute.createArgument().setValue(expand(title));
                 toExecute.createArgument().setValue(packages);
             }
         }
     }
 
     // Do java1.4 arguments
     private void doJava14(Commandline toExecute) {
         for (Enumeration<Object> e = tags.elements(); e.hasMoreElements();) {
             Object element = e.nextElement();
             if (element instanceof TagArgument) {
                 TagArgument ta = (TagArgument) element;
                 File tagDir = ta.getDir(getProject());
                 if (tagDir == null) {
                     // The tag element is not used as a fileset,
                     // but specifies the tag directly.
                     toExecute.createArgument().setValue ("-tag");
                     toExecute.createArgument()
                         .setValue (ta.getParameter());
                 } else {
                     // The tag element is used as a
                     // fileset. Parse all the files and create
                     // -tag arguments.
                     DirectoryScanner tagDefScanner =
                         ta.getDirectoryScanner(getProject());
                     String[] files = tagDefScanner.getIncludedFiles();
                     for (int i = 0; i < files.length; i++) {
                         File tagDefFile = new File(tagDir, files[i]);
                         try {
                             BufferedReader in
                                 = new BufferedReader(
                                     new FileReader(tagDefFile)
                                                      );
                             String line = null;
                             while ((line = in.readLine()) != null) {
                                 toExecute.createArgument()
                                     .setValue("-tag");
                                 toExecute.createArgument()
                                     .setValue(line);
                             }
                             in.close();
                         } catch (IOException ioe) {
                             throw new BuildException(
                                 "Couldn't read "
                                 + " tag file from "
                                 + tagDefFile.getAbsolutePath(), ioe);
                         }
                     }
                 }
             } else {
                 ExtensionInfo tagletInfo = (ExtensionInfo) element;
                 toExecute.createArgument().setValue("-taglet");
                 toExecute.createArgument().setValue(tagletInfo
                                                     .getName());
                 if (tagletInfo.getPath() != null) {
                     Path tagletPath = tagletInfo.getPath()
                         .concatSystemClasspath("ignore");
                     if (tagletPath.size() != 0) {
                         toExecute.createArgument()
                             .setValue("-tagletpath");
                         toExecute.createArgument().setPath(tagletPath);
                     }
                 }
             }
         }
 
         String sourceArg = source != null ? source
             : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
         if (sourceArg != null) {
             toExecute.createArgument().setValue("-source");
             toExecute.createArgument().setValue(sourceArg);
         }
 
         if (linksource && doclet == null) {
             toExecute.createArgument().setValue("-linksource");
         }
         if (noqualifier != null && doclet == null) {
             toExecute.createArgument().setValue("-noqualifier");
             toExecute.createArgument().setValue(noqualifier);
         }
     }
 
     private void doDocFilesSubDirs(Commandline toExecute) {
         if (docFilesSubDirs) {
             toExecute.createArgument().setValue("-docfilessubdirs");
             if (excludeDocFilesSubDir != null
                 && excludeDocFilesSubDir.trim().length() > 0) {
                 toExecute.createArgument().setValue("-excludedocfilessubdir");
                 toExecute.createArgument().setValue(excludeDocFilesSubDir);
             }
         }
     }
 
     private void doSourceAndPackageNames(
         Commandline toExecute,
         Vector<String> packagesToDoc,
         Vector<SourceFile> sourceFilesToDoc,
         boolean useExternalFile,
         File    tmpList,
         BufferedWriter srcListWriter)
         throws IOException {
         for (String packageName : packagesToDoc) {
             if (useExternalFile) {
                 srcListWriter.write(packageName);
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(packageName);
             }
         }
 
         for (SourceFile sf : sourceFilesToDoc) {
             String sourceFileName = sf.getFile().getAbsolutePath();
             if (useExternalFile) {
                 // TODO what is the following doing?
                 //     should it run if !javadoc4 && executable != null?
                 if (sourceFileName.indexOf(" ") > -1) {
                     String name = sourceFileName;
                     if (File.separatorChar == '\\') {
                         name = sourceFileName.replace(File.separatorChar, '/');
                     }
                     srcListWriter.write("\"" + name + "\"");
                 } else {
                     srcListWriter.write(sourceFileName);
                 }
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(sourceFileName);
             }
         }
     }
 
     /**
      * Quote a string to place in a @ file.
      * @param str the string to quote
      * @return the quoted string, if there is no need to quote the string,
      *         return the original string.
      */
     private String quoteString(final String str) {
         if (!containsWhitespace(str)
             && str.indexOf('\'') == -1
             && str.indexOf('"') == -1) {
             return str;
         }
         if (str.indexOf('\'') == -1) {
             return quoteString(str, '\'');
         } else {
             return quoteString(str, '"');
         }
     }
 
     private boolean containsWhitespace(final String s) {
         final int len = s.length();
         for (int i = 0; i < len; i++) {
             if (Character.isWhitespace(s.charAt(i))) {
                 return true;
             }
         }
         return false;
     }
 
     private String quoteString(final String str, final char delim) {
         StringBuffer buf = new StringBuffer(str.length() * 2);
         buf.append(delim);
         final int len = str.length();
         boolean lastCharWasCR = false;
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             if (c == delim) { // can't put the non-constant delim into a case
                 buf.append('\\').append(c);
                 lastCharWasCR = false;
             } else {
                 switch (c) {
                 case '\\':
                     buf.append("\\\\");
                     lastCharWasCR = false;
                     break;
                 case '\r':
                     // insert a line continuation marker
                     buf.append("\\\r");
                     lastCharWasCR = true;
                     break;
                 case '\n':
                     // insert a line continuation marker unless this
                     // is a \r\n sequence in which case \r already has
                     // created the marker
                     if (!lastCharWasCR) {
                         buf.append("\\\n");
                     } else {
                         buf.append("\n");
                     }
                     lastCharWasCR = false;
                     break;
                 default:
                     buf.append(c);
                     lastCharWasCR = false;
                     break;
                 }
             }
         }
         buf.append(delim);
         return buf.toString();
     }
 
     /**
      * Add the files matched by the nested source files to the Vector
      * as SourceFile instances.
      *
      * @since 1.7
      */
     private void addSourceFiles(Vector<SourceFile> sf) {
         Iterator<ResourceCollection> e = nestedSourceFiles.iterator();
         while (e.hasNext()) {
             ResourceCollection rc = e.next();
             if (!rc.isFilesystemOnly()) {
                 throw new BuildException("only file system based resources are"
                                          + " supported by javadoc");
             }
             if (rc instanceof FileSet) {
                 FileSet fs = (FileSet) rc;
                 if (!fs.hasPatterns() && !fs.hasSelectors()) {
                     FileSet fs2 = (FileSet) fs.clone();
                     fs2.createInclude().setName("**/*.java");
                     if (includeNoSourcePackages) {
                         fs2.createInclude().setName("**/package.html");
                     }
                     rc = fs2;
                 }
             }
             for (Resource r : rc) {
                 sf.addElement(new SourceFile(r.as(FileProvider.class).getFile()));
             }
         }
     }
 
     /**
      * Add the directories matched by the nested dirsets to the Vector
      * and the base directories of the dirsets to the Path.  It also
      * handles the packages and excludepackages attributes and
      * elements.
      *
      * @since 1.5
      */
     private void parsePackages(Vector<String> pn, Path sp) {
         HashSet<String> addedPackages = new HashSet<String>();
         @SuppressWarnings("unchecked")
         Vector<DirSet> dirSets = (Vector<DirSet>) packageSets.clone();
 
         // for each sourcePath entry, add a directoryset with includes
         // taken from packagenames attribute and nested package
         // elements and excludes taken from excludepackages attribute
         // and nested excludepackage elements
         if (sourcePath != null) {
             PatternSet ps = new PatternSet();
             ps.setProject(getProject());
             if (packageNames.size() > 0) {
                 Enumeration<PackageName> e = packageNames.elements();
                 while (e.hasMoreElements()) {
                     PackageName p = e.nextElement();
                     String pkg = p.getName().replace('.', '/');
                     if (pkg.endsWith("*")) {
                         pkg += "*";
                     }
                     ps.createInclude().setName(pkg);
                 }
             } else {
                 ps.createInclude().setName("**");
             }
 
             Enumeration<PackageName> e = excludePackageNames.elements();
             while (e.hasMoreElements()) {
                 PackageName p = e.nextElement();
                 String pkg = p.getName().replace('.', '/');
                 if (pkg.endsWith("*")) {
                     pkg += "*";
                 }
                 ps.createExclude().setName(pkg);
             }
 
 
             String[] pathElements = sourcePath.list();
             for (int i = 0; i < pathElements.length; i++) {
                 File dir = new File(pathElements[i]);
                 if (dir.isDirectory()) {
                     DirSet ds = new DirSet();
                     ds.setProject(getProject());
                     ds.setDefaultexcludes(useDefaultExcludes);
                     ds.setDir(dir);
                     ds.createPatternSet().addConfiguredPatternset(ps);
                     dirSets.addElement(ds);
                 } else {
                     log("Skipping " + pathElements[i]
                         + " since it is no directory.", Project.MSG_WARN);
                 }
             }
         }
 
         Enumeration<DirSet> e = dirSets.elements();
         while (e.hasMoreElements()) {
             DirSet ds = e.nextElement();
             File baseDir = ds.getDir(getProject());
             log("scanning " + baseDir + " for packages.", Project.MSG_DEBUG);
             DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
             String[] dirs = dsc.getIncludedDirectories();
             boolean containsPackages = false;
             for (int i = 0; i < dirs.length; i++) {
                 // are there any java files in this directory?
                 File pd = new File(baseDir, dirs[i]);
                 String[] files = pd.list(new FilenameFilter () {
                         public boolean accept(File dir1, String name) {
                             return name.endsWith(".java")
                                 || (includeNoSourcePackages
                                     && name.equals("package.html"));
                         }
                     });
 
                 if (files.length > 0) {
                     if ("".equals(dirs[i])) {
                         log(baseDir
                             + " contains source files in the default package,"
                             + " you must specify them as source files"
                             + " not packages.",
                             Project.MSG_WARN);
                     } else {
                         containsPackages = true;
                         String packageName =
                             dirs[i].replace(File.separatorChar, '.');
                         if (!addedPackages.contains(packageName)) {
                             addedPackages.add(packageName);
                             pn.addElement(packageName);
                         }
                     }
                 }
             }
             if (containsPackages) {
                 // We don't need to care for duplicates here,
                 // Path.list does it for us.
                 sp.createPathElement().setLocation(baseDir);
             } else {
                 log(baseDir + " doesn\'t contain any packages, dropping it.",
                     Project.MSG_VERBOSE);
             }
         }
     }
 
     private void postProcessGeneratedJavadocs() throws IOException {
         if (!postProcessGeneratedJavadocs) {
             return;
         }
         if (destDir != null && !destDir.isDirectory()) {
             log("No javadoc created, no need to post-process anything",
                 Project.MSG_VERBOSE);
             return;
         }
         final String fixData;
         final InputStream in = getClass()
             .getResourceAsStream("javadoc-frame-injections-fix.txt");
         if (in == null) {
             throw new FileNotFoundException("Missing resource "
                                             + "'javadoc-frame-injections-fix.txt' in "
                                             + "classpath.");
         }
         try {
             fixData =
                 fixLineFeeds(FileUtils
                              .readFully(new InputStreamReader(in, "US-ASCII")))
                 .trim();
         } finally {
             FileUtils.close(in);
         }
 
         final DirectoryScanner ds = new DirectoryScanner();
         ds.setBasedir(destDir);
         ds.setCaseSensitive(false);
         ds.setIncludes(new String[] {
                 "**/index.html", "**/index.htm", "**/toc.html", "**/toc.htm"
             });
         ds.addDefaultExcludes();
         ds.scan();
         int patched = 0;
         for (String f : ds.getIncludedFiles()) {
             patched += postProcess(new File(destDir, f), fixData);
         }
         if (patched > 0) {
             log("Patched " + patched + " link injection vulnerable javadocs",
                 Project.MSG_INFO);
         }
     }
 
     private int postProcess(File file, String fixData) throws IOException {
         String enc = docEncoding != null ? docEncoding
             : FILE_UTILS.getDefaultEncoding();
         // we load the whole file as one String (toc/index files are
         // generally small, because they only contain frameset declaration):
         InputStream fin = new FileInputStream(file);
         String fileContents;
         try {
             fileContents =
                 fixLineFeeds(FileUtils
                              .safeReadFully(new InputStreamReader(fin, enc)));
         } finally {
             FileUtils.close(fin);
         }
 
         // check if file may be vulnerable because it was not
         // patched with "validURL(url)":
         if (fileContents.indexOf("function validURL(url) {") < 0) {
             // we need to patch the file!
             String patchedFileContents = patchContent(fileContents, fixData);
             if (!patchedFileContents.equals(fileContents)) {
                 FileOutputStream fos = new FileOutputStream(file);
                 try {
                     OutputStreamWriter w = new OutputStreamWriter(fos, enc);
                     w.write(patchedFileContents);
                     w.close();
                     return 1;
                 } finally {
                     FileUtils.close(fos);
                 }
             }
         }
         return 0;
     }
 
     private String fixLineFeeds(String orig) {
         return orig.replace("\r\n", "\n")
             .replace("\n", StringUtils.LINE_SEP);
     }
 
     private String patchContent(String fileContents, String fixData) {
         // using regexes here looks like overkill
         int start = fileContents.indexOf(LOAD_FRAME);
         if (start >= 0) {
             return fileContents.substring(0, start) + fixData
                 + fileContents.substring(start + LOAD_FRAME_LEN);
         }
         return fileContents;
     }
 
     private class JavadocOutputStream extends LogOutputStream {
         JavadocOutputStream(int level) {
             super(Javadoc.this, level);
         }
 
         //
         // Override the logging of output in order to filter out Generating
         // messages.  Generating messages are set to a priority of VERBOSE
         // unless they appear after what could be an informational message.
         //
         private String queuedLine = null;
+        private boolean sawWarnings = false;
         protected void processLine(String line, int messageLevel) {
+            if (line.contains("warning")) {
+                sawWarnings = true;
+            }
             if (messageLevel == Project.MSG_INFO
                 && line.startsWith("Generating ")) {
                 if (queuedLine != null) {
                     super.processLine(queuedLine, Project.MSG_VERBOSE);
                 }
                 queuedLine = line;
             } else {
                 if (queuedLine != null) {
                     if (line.startsWith("Building ")) {
                         super.processLine(queuedLine, Project.MSG_VERBOSE);
                     } else {
                         super.processLine(queuedLine, Project.MSG_INFO);
                     }
                     queuedLine = null;
                 }
                 super.processLine(line, messageLevel);
             }
         }
 
 
         protected void logFlush() {
             if (queuedLine != null) {
                 super.processLine(queuedLine, Project.MSG_VERBOSE);
                 queuedLine = null;
             }
         }
+        
+        public boolean sawWarnings() {
+            return sawWarnings;
+        }
     }
 
     /**
      * Convenience method to expand properties.
      * @param content the string to expand
      * @return the converted string
      */
     protected String expand(String content) {
         return getProject().replaceProperties(content);
     }
 
 }
