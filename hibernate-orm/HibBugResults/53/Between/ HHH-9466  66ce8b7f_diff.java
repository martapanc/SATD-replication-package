diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/OSGi.xml b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/OSGi.xml
index e9f87fe1cb..a2d4d1f479 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/OSGi.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/OSGi.xml
@@ -1,414 +1,414 @@
 <?xml version='1.0' encoding='utf-8'?>
 
 <chapter xmlns="http://docbook.org/ns/docbook"
          xmlns:xl="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude">
     <info>
         <title>OSGi</title>
         <abstract>
             <para>
                 The Open Services Gateway initiative (OSGi) specification describes a dynamic, modularized system.  "Bundles"
                 (components) can be installed, activated, deactivated, and uninstalled during runtime, without requiring
                 a system restart.  OSGi frameworks manage bundles' dependencies, packages, and classes.  The framework
                 is also in charge of ClassLoading, managing visibility of packages between bundles.  Further, service
                 registry and discovery is provided through a "whiteboard" pattern.
             </para>
             
             <para>
                 OSGi environments present numerous, unique challenges.  Most notably, the dynamic nature of available
                 bundles during runtime can require significant architectural considerations.  Also,
                 architectures must allow the OSGi-specific ClassLoading and service registration/discovery.
             </para>
         </abstract>
     </info>
 
     <section>
         <title>OSGi Specification and Environment</title>
 
         <para>
             Hibernate targets the OSGi 4.3 spec or later.  It was necessary to start with 4.3, over 4.2, due to our
             dependency on OSGi's <literal>BundleWiring</literal> for entity/mapping scanning.
         </para>
 
         <para>
         	Hibernate supports three types of configurations within OSGi.
         	
         	 <orderedlist>
 	            <listitem>
 	                <firstterm>Container-Managed JPA</firstterm>: <xref linkend="osgi-managed-jpa"/>
 	            </listitem>
 	            <listitem>
 	                <firstterm>Unmanaged JPA</firstterm>: <xref linkend="osgi-unmanaged-jpa"/>
 	            </listitem>
 	            <listitem>
 	                <firstterm>Unmanaged Native</firstterm>: <xref linkend="osgi-unmanaged-native"/>
 	            </listitem>
 	        </orderedlist>
         </para>
     </section>
 
     <section>
         <title>hibernate-osgi</title>
 
         <para>
             Rather than embed OSGi capabilities into hibernate-core, hibernate-entitymanager, and sub-modules,
             hibernate-osgi was created.  It's purposefully separated, isolating all OSGi dependencies.  It provides an
             OSGi-specific ClassLoader (aggregates the container's CL with core and entitymanager CLs), JPA persistence
             provider, SF/EMF bootstrapping, entities/mappings scanner, and service management.
         </para>
     </section>
 
     <section xml:id="osgi-managed-jpa">
         <title>Container-Managed JPA</title>
         
         <para>
             The Enterprise OSGi specification includes container-managed JPA.  The container is responsible for
             discovering persistence units and creating the <literal>EntityManagerFactory</literal> (one EMF per PU).
             It uses the JPA provider (hibernate-osgi) that has registered itself with the OSGi
             <literal>PersistenceProvider</literal> service.
         </para>
         
         <para>
         	Quickstart tutorial project, demonstrating a container-managed JPA client bundle:
         	<link xl:href="https://github.com/hibernate/hibernate-orm/tree/master/documentation/src/main/docbook/quickstart/tutorials/osgi/managed-jpa">managed-jpa</link>
         </para>
         
         <section>
         	<title>Client bundle imports</title>
         	<para>
         		Your client bundle's manifest will need to import, at a minimum,
         		<itemizedlist>
 		            <listitem>
 		                <literal>javax.persistence</literal>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.hibernate.proxy</literal> and <literal>javassist.util.proxy</literal>, due to
 		                    Hibernate's ability to return proxies for lazy initialization (Javassist enhancement
 		                    occurs on the entity's ClassLoader during runtime).
 		                </para>
 		            </listitem>
 		        </itemizedlist>
         	</para>
         </section>
         
         <section>
         	<title>JPA 2.1</title>
 
 				<para>
 					No Enterprise OSGi JPA container currently supports JPA 2.1 (the spec is not yet released). For
 					testing, the managed-jpa example makes use of
 					<link xl:href="https://github.com/brmeyer/aries/tree/jpa21">Brett's fork of Aries</link>. To work
 					with Hibernate 4.3, clone the fork and build Aries JPA.
 				</para>
         </section>
         
         <section>
         	<title>DataSource</title>
         	<para>
         		Typical Enterprise OSGi JPA usage includes a DataSource installed in the container.  The client
         		bundle's <literal>persistence.xml</literal> uses the DataSource through JNDI.  For an example,
         		see the QuickStart's DataSource:
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/datasource-h2.xml">datasource-h2.xml</link>
         		The DataSource is then called out in
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/managed-jpa/src/main/resources/META-INF/persistence.xml">
         		persistence.xml's</link> <literal>jta-data-source</literal>.
         	</para>
         </section>
         
         <section>
         	<title>Bundle Ordering</title>
         	<para>
         		Hibernate currently requires fairly specific bundle activation ordering.  See the managed-jpa
         		QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/managed-jpa/features.xml">features.xml</link>
         		for the best supported sequence.
         	</para>
         </section>
         
         <section>
         	<title>Obtaining an EntityManger</title>
         	<para>
         		The easiest, and most supported, method of obtaining an <literal>EntityManager</literal> utilizes OSGi's
         		<literal>blueprint.xml</literal>.  The container takes the name of your persistence unit, then injects
         		an <literal>EntityManager</literal> instance into your given bean attribute.  See the
         		<literal>dpService</literal> bean in the managed-jpa QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/managed-jpa/src/main/resources/OSGI-INF/blueprint/blueprint.xml">blueprint.xml</link>
         		for an example.
         	</para>
         </section>
     </section>
 
     <section xml:id="osgi-unmanaged-jpa">
         <title>Unmanaged JPA</title>
         
         <para>
             Hibernate also supports the use of JPA through hibernate-entitymanager, unmanaged by the OSGi
             container.  The client bundle is responsible for managing the EntityManagerFactory and EntityManagers.
         </para>
         
         <para>
         	Quickstart tutorial project, demonstrating an unmanaged JPA client bundle:
         	<link xl:href="https://github.com/hibernate/hibernate-orm/tree/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa">unmanaged-jpa</link>
         </para>
         
         <section>
         	<title>Client bundle imports</title>
         	<para>
         		Your client bundle's manifest will need to import, at a minimum,
         		<itemizedlist>
 		            <listitem>
 		                <literal>javax.persistence</literal>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.hibernate.proxy</literal> and <literal>javassist.util.proxy</literal>, due to
 		                    Hibernate's ability to return proxies for lazy initialization (Javassist enhancement
 		                    occurs on the entity's ClassLoader during runtime)
 		                </para>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    JDBC driver package (example: <literal>org.h2</literal>)
 		                </para>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.osgi.framework</literal>, necessary to discover the EMF (described below)
 		                </para>
 		            </listitem>
 		        </itemizedlist>
         	</para>
         </section>
         
         <section>
         	<title>Bundle Ordering</title>
         	<para>
         		Hibernate currently requires fairly specific bundle activation ordering.  See the unmanaged-jpa
         		QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/features.xml">features.xml</link>
         		for the best supported sequence.
         	</para>
         </section>
         
         <section>
         	<title>Obtaining an EntityMangerFactory</title>
         	<para>
         		hibernate-osgi registers an OSGi service, using the JPA <literal>PersistenceProvider</literal> interface
         		name, that bootstraps and creates an <literal>EntityManagerFactory</literal> specific for OSGi
         		environments.  It is VITAL that your EMF be obtained through the service, rather than creating it
         		manually.  The service handles the OSGi ClassLoader, discovered extension points, scanning, etc.  Manually
         		creating an <literal>EntityManagerFactory</literal> is guaranteed to NOT work during runtime!
         	</para>
         	<para>
         		For an example on how to discover and use the service, see the unmanaged-jpa
         		QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/src/main/java/org/hibernate/osgitest/HibernateUtil.java">HibernateUtil.java</link>.
         	</para>
         </section>
     </section>
 
     <section xml:id="osgi-unmanaged-native">
         <title>Unmanaged Native</title>
         
         <para>
             Native Hibernate use is also supported.  The client bundle is responsible for managing the
             SessionFactory and Sessions.
         </para>
         
         <para>
         	Quickstart tutorial project, demonstrating an unmanaged native client bundle:
         	<link xl:href="https://github.com/hibernate/hibernate-orm/tree/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native">unmanaged-native</link>
         </para>
         
         <section>
         	<title>Client bundle imports</title>
         	<para>
         		Your client bundle's manifest will need to import, at a minimum,
         		<itemizedlist>
 		            <listitem>
 		                <literal>javax.persistence</literal>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.hibernate.proxy</literal> and <literal>javassist.util.proxy</literal>, due to
 		                    Hibernate's ability to return proxies for lazy initialization (Javassist enhancement
 		                    occurs on the entity's ClassLoader during runtime)
 		                </para>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    JDBC driver package (example: <literal>org.h2</literal>)
 		                </para>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.osgi.framework</literal>, necessary to discover the SF (described below)
 		                </para>
 		            </listitem>
 		            <listitem>
 		                <para>
 		                    <literal>org.hibernate.*</literal> packages, as necessary (ex: cfg, criterion, service, etc.)
 		                </para>
 		            </listitem>
 		        </itemizedlist>
         	</para>
         </section>
         
         <section>
         	<title>Bundle Ordering</title>
         	<para>
         		Hibernate currently requires fairly specific bundle activation ordering.  See the unmanaged-native
         		QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/features.xml">features.xml</link>
         		for the best supported sequence.
         	</para>
         </section>
         
         <section>
         	<title>Obtaining an SessionFactory</title>
         	<para>
         		hibernate-osgi registers an OSGi service, using the <literal>SessionFactory</literal> interface
         		name, that bootstraps and creates an <literal>SessionFactory</literal> specific for OSGi
         		environments.  It is VITAL that your SF be obtained through the service, rather than creating it
         		manually.  The service handles the OSGi ClassLoader, discovered extension points, scanning, etc.  Manually
         		creating an <literal>SessionFactory</literal> is guaranteed to NOT work during runtime!
         	</para>
         	<para>
         		For an example on how to discover and use the service, see the unmanaged-native
         		QuickStart's
         		<link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/src/main/java/org/hibernate/osgitest/HibernateUtil.java">HibernateUtil.java</link>.
         	</para>
         </section>
     </section>
     
     <section>
     	<title>Optional Modules</title>
     	
     	<para>
     		The <link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native">unmanaged-native</link>
     		QuickStart project demonstrates the use of optional Hibernate modules.  Each module adds additional
     		dependency bundles that must first be activated
     		(see <link xl:href="https://github.com/hibernate/hibernate-orm/blob/master/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/features.xml">features.xml</link>).
     		As of ORM 4.2, Envers is fully supported.  Support for C3P0, Proxool, EhCache, and Infinispan were added in
     		4.3, however none of their 3rd party libraries currently work in OSGi (lots of ClassLoader problems, etc.).
     		We're tracking the issues in JIRA.
     	</para>
     </section>
     
     <section>
     	<title>Extension Points</title>
     	
     	<para>
     		Multiple contracts exist to allow applications to integrate with and extend Hibernate capabilities.  Most
     		apps utilize JDK services to provide their implementations.  hibernate-osgi supports the same
     		extensions through OSGi services.  Implement and register them in any of the three configurations.
     		hibernate-osgi will discover and integrate them during EMF/SF bootstrapping.  Supported extension points
     		are as follows.  The specified interface should be used during service registration.
     		
     		<itemizedlist>
 	            <listitem>
 	                <literal>org.hibernate.integrator.spi.Integrator</literal> (as of 4.2)
 	            </listitem>
 	            <listitem>
 	                <literal>org.hibernate.boot.registry.selector.StrategyRegistrationProvider</literal> (as of 4.3)
 	            </listitem>
 	            <listitem>
-	                <literal>org.hibernate.metamodel.spi.TypeContributor</literal> (as of 4.3)
+	                <literal>org.hibernate.boot.model.TypeContributor</literal> (as of 4.3)
 	            </listitem>
 	            <listitem>
 	                JTA's <literal>javax.transaction.TransactionManager</literal> and
 	                <literal>javax.transaction.UserTransaction</literal> (as of 4.2), however these are typically
 	                provided by the OSGi container.
 	            </listitem>
 	        </itemizedlist>
     	</para>
     	
     	<para>
     		The easiest way to register extension point implementations is through a <literal>blueprint.xml</literal>
     		file.  Add <literal>OSGI-INF/blueprint/blueprint.xml</literal> to your classpath.  Envers' blueprint
     		is a great example:
     	</para>
     	
     	<example>
             <title>Example extension point registrations in blueprint.xml</title>
             <programlisting role="XML"><xi:include href="extras/extension_point_blueprint.xml" parse="text"/></programlisting>
         </example>
         
         <para>
         	Extension points can also be registered programmatically with
         	<literal>BundleContext#registerService</literal>, typically within your
         	<literal>BundleActivator#start</literal>.
         </para>
     </section>
     
     <section>
     	<title>Caveats</title>
     	
     	<itemizedlist>
             <listitem>
                 <para>
                 	Technically, multiple persistence units are supported by Enterprise OSGi JPA and unmanaged
                 	Hibernate JPA use.  However, we cannot currently support this in OSGi.  In Hibernate 4, only one
                 	instance of the OSGi-specific ClassLoader is used per Hibernate bundle, mainly due to heavy use of
                 	static TCCL utilities.  We hope to support one OSGi ClassLoader per persistence unit in
                 	Hibernate 5.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	Scanning is supported to find non-explicitly listed entities and mappings.  However, they MUST be
                 	in the same bundle as your persistence unit (fairly typical anyway).  Our OSGi ClassLoader only
                 	considers the "requesting bundle" (hence the requirement on using services to create EMF/SF),
                 	rather than attempting to scan all available bundles.  This is primarily for versioning
                 	considerations, collision protections, etc.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	Some containers (ex: Aries) always return true for
                 	<literal>PersistenceUnitInfo#excludeUnlistedClasses</literal>,
                 	even if your persistence.xml explicitly has <literal>exclude-unlisted-classes</literal> set
                 	to <literal>false</literal>.  They claim it's to protect JPA providers from having to implement
                 	scanning ("we handle it for you"), even though we still want to support it in many cases.  The work
                 	around is to set <literal>hibernate.archive.autodetection</literal> to, for example,
                 	<literal>hbm,class</literal>.  This tells hibernate to ignore the excludeUnlistedClasses value and
                 	scan for <literal>*.hbm.xml</literal> and entities regardless.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	Scanning does not currently support annotated packages on <literal>package-info.java</literal>.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	Currently, Hibernate OSGi is primarily tested using Apache Karaf and Apache Aries JPA.  Additional
                 	testing is needed with Equinox, Gemini, and other container providers.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	Hibernate ORM has many dependencies that do not currently provide OSGi manifests.
                 	The QuickStart tutorials make heavy use of 3rd party bundles (SpringSource, ServiceMix) or the
                 	<literal>wrap:...</literal> operator.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	As previously mentioned, bundle activation is currently order specific.  See the QuickStart
                 	tutorials' <literal>features.xml</literal> for example sequences.
                 </para>
             </listitem>
             <listitem>
                 <para>
                 	No Enterprise OSGi JPA container currently supports JPA 2.1 (the spec is not yet released).  For
                 	testing, the managed-jpa example makes use of
                 	<link xl:href="https://github.com/brmeyer/aries/tree/jpa21">Brett's fork of Aries</link>.  To work
                 	with Hibernate 4.3, clone the fork and build Aries JPA.
                 </para>
             </listitem>
         </itemizedlist>
     </section>
 
 </chapter>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
index 944eedde9a..a263100e5b 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
@@ -1,11 +1,11 @@
 <blueprint default-activation="eager"
 	xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
 	<bean id="integrator" class="org.hibernate.envers.event.spi.EnversIntegrator" />
 	<service ref="integrator" interface="org.hibernate.integrator.spi.Integrator" />
 
 	<bean id="typeContributor"
 		class="org.hibernate.envers.internal.entities.TypeContributorImpl" />
-	<service ref="typeContributor" interface="org.hibernate.metamodel.spi.TypeContributor" />
+	<service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor" />
 
 </blueprint>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/src/main/resources/OSGI-INF/blueprint/blueprint.xml b/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/src/main/resources/OSGI-INF/blueprint/blueprint.xml
index 2dedb95870..5564e6eb01 100644
--- a/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/src/main/resources/OSGI-INF/blueprint/blueprint.xml
+++ b/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-jpa/src/main/resources/OSGI-INF/blueprint/blueprint.xml
@@ -1,61 +1,61 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
 
     Licensed to the Apache Software Foundation (ASF) under one or more
     contributor license agreements.  See the NOTICE file distributed with
     this work for additional information regarding copyright ownership.
     The ASF licenses this file to You under the Apache License, Version 2.0
     (the "License"); you may not use this file except in compliance with
     the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
 
 -->
 <blueprint  default-activation="eager" 
             xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
   <bean id="dpService" class="org.hibernate.osgitest.DataPointServiceImpl"/>
   <service ref="dpService" interface="org.hibernate.osgitest.DataPointService" />
   
   <!-- This demonstrates how to register your custom implementations of Hibernate extension points. -->
             
   <bean id="integrator" class="org.hibernate.osgitest.TestIntegrator"/>
   <service ref="integrator" interface="org.hibernate.integrator.spi.Integrator"/>
 
   <bean id="strategyRegistrationProvider" class="org.hibernate.osgitest.TestStrategyRegistrationProvider"/>
   <service ref="strategyRegistrationProvider" interface="org.hibernate.boot.registry.selector.StrategyRegistrationProvider"/>
             
   <bean id="typeContributor" class="org.hibernate.osgitest.TestTypeContributor"/>
-  <service ref="typeContributor" interface="org.hibernate.metamodel.spi.TypeContributor"/>
+  <service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor"/>
   
   <!-- This bundle makes use of Karaf commands to demonstrate core persistence operations.  Feel free to remove it. -->
   <command-bundle xmlns="http://karaf.apache.org/xmlns/shell/v1.1.0">
         <command name="dp:add">
             <action class="org.hibernate.osgitest.command.AddCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:update">
             <action class="org.hibernate.osgitest.command.UpdateCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:getAll">
             <action class="org.hibernate.osgitest.command.GetAllCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:deleteAll">
             <action class="org.hibernate.osgitest.command.DeleteAllCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
     </command-bundle>
 </blueprint>
diff --git a/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/src/main/resources/OSGI-INF/blueprint/blueprint.xml b/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/src/main/resources/OSGI-INF/blueprint/blueprint.xml
index 3f4b2b4d0f..0b974714a6 100644
--- a/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/src/main/resources/OSGI-INF/blueprint/blueprint.xml
+++ b/documentation/src/main/docbook/quickstart/tutorials/osgi/unmanaged-native/src/main/resources/OSGI-INF/blueprint/blueprint.xml
@@ -1,76 +1,76 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
 
     Licensed to the Apache Software Foundation (ASF) under one or more
     contributor license agreements.  See the NOTICE file distributed with
     this work for additional information regarding copyright ownership.
     The ASF licenses this file to You under the Apache License, Version 2.0
     (the "License"); you may not use this file except in compliance with
     the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
 
 -->
 <blueprint  default-activation="eager" 
             xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
   <bean id="dpService" class="org.hibernate.osgitest.DataPointServiceImpl"/>
   <service ref="dpService" interface="org.hibernate.osgitest.DataPointService" />
   
   <!-- This demonstrates how to register your custom implementations of Hibernate extension points. -->
             
   <bean id="integrator" class="org.hibernate.osgitest.TestIntegrator"/>
   <service ref="integrator" interface="org.hibernate.integrator.spi.Integrator"/>
 
   <bean id="strategyRegistrationProvider" class="org.hibernate.osgitest.TestStrategyRegistrationProvider"/>
   <service ref="strategyRegistrationProvider" interface="org.hibernate.boot.registry.selector.StrategyRegistrationProvider"/>
             
   <bean id="typeContributor" class="org.hibernate.osgitest.TestTypeContributor"/>
-  <service ref="typeContributor" interface="org.hibernate.metamodel.spi.TypeContributor"/>
+  <service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor"/>
   
   <!-- This bundle makes use of Karaf commands to demonstrate core persistence operations.  Feel free to remove it. -->
   <command-bundle xmlns="http://karaf.apache.org/xmlns/shell/v1.1.0">
         <command name="dp:add">
             <action class="org.hibernate.osgitest.command.AddCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:update">
             <action class="org.hibernate.osgitest.command.UpdateCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:get">
             <action class="org.hibernate.osgitest.command.GetCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:load">
             <action class="org.hibernate.osgitest.command.LoadCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:getAll">
             <action class="org.hibernate.osgitest.command.GetAllCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:getRevisions">
             <action class="org.hibernate.osgitest.command.GetRevisionsCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
         <command name="dp:deleteAll">
             <action class="org.hibernate.osgitest.command.DeleteAllCommand">
                 <property name="dpService" ref="dpService"/>
             </action>
         </command>
     </command-bundle>
 </blueprint>
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributions.java b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributions.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributions.java
rename to hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributions.java
index 630e63b4d0..ee5e2705b7 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributions.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributions.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.spi;
+package org.hibernate.boot.model;
 
 import org.hibernate.type.BasicType;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 /**
  * Defines the target contributing types, whether via dialects or {@link TypeContributor}
  *
  * @author Steve Ebersole
  */
 public interface TypeContributions {
 	public void contributeType(BasicType type);
 
 	public void contributeType(UserType type, String[] keys);
 
 	public void contributeType(CompositeUserType type, String[] keys);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributor.java b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributor.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributor.java
rename to hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributor.java
index 4a04173faa..025dfeb1de 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/spi/TypeContributor.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeContributor.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.spi;
+package org.hibernate.boot.model;
 
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * Contract for contributing types.
  *
  * @author Steve Ebersole
  * 
  * NOTE: Cherry-pick of HHH-7998 from metamodel.  For merging simplicity, just
  * keep it in the o.h.metamodel.spi package.
  */
 public interface TypeContributor {
 	/**
 	 * Contribute types
 	 *
 	 * @param typeContributions The callback for adding contributed types
 	 * @param serviceRegistry The service registry
 	 */
 	public void contribute(TypeContributions typeContributions, ServiceRegistry serviceRegistry);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/internal/CacheDataDescriptionImpl.java b/hibernate-core/src/main/java/org/hibernate/cache/internal/CacheDataDescriptionImpl.java
index e4917d1200..ea8e8bb3e6 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/internal/CacheDataDescriptionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/internal/CacheDataDescriptionImpl.java
@@ -1,146 +1,106 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.internal;
 
 import java.util.Comparator;
 
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.type.VersionType;
 
 /**
  * Standard CacheDataDescription implementation.
  *
  * @author Steve Ebersole
  */
 public class CacheDataDescriptionImpl implements CacheDataDescription {
 	private final boolean mutable;
 	private final boolean versioned;
 	private final Comparator versionComparator;
 
 	/**
 	 * Constructs a CacheDataDescriptionImpl instance.  Generally speaking, code should use one of the
 	 * overloaded {@link #decode} methods rather than direct instantiation.
 	 *
 	 * @param mutable Is the described data mutable?
 	 * @param versioned Is the described data versioned?
 	 * @param versionComparator The described data's version value comparator (if versioned).
 	 */
 	public CacheDataDescriptionImpl(boolean mutable, boolean versioned, Comparator versionComparator) {
 		this.mutable = mutable;
 		this.versioned = versioned;
 		this.versionComparator = versionComparator;
 	}
 
 	@Override
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	@Override
 	public boolean isVersioned() {
 		return versioned;
 	}
 
 	@Override
 	public Comparator getVersionComparator() {
 		return versionComparator;
 	}
 
 	/**
 	 * Builds a CacheDataDescriptionImpl from the mapping model of an entity class.
 	 *
 	 * @param model The mapping model.
 	 *
 	 * @return The constructed CacheDataDescriptionImpl
 	 */
 	public static CacheDataDescriptionImpl decode(PersistentClass model) {
 		return new CacheDataDescriptionImpl(
 				model.isMutable(),
 				model.isVersioned(),
 				model.isVersioned()
 						? ( (VersionType) model.getVersion().getType() ).getComparator()
 						: null
 		);
 	}
 
 	/**
-	 * Builds a CacheDataDescriptionImpl from the mapping model of an entity class (using the new metamodel code).
-	 *
-	 * @param model The mapping model.
-	 *
-	 * @return The constructed CacheDataDescriptionImpl
-	 */
-	public static CacheDataDescriptionImpl decode(EntityBinding model) {
-		return new CacheDataDescriptionImpl( model.isMutable(), model.isVersioned(), getVersionComparator( model ) );
-	}
-
-	/**
 	 * Builds a CacheDataDescriptionImpl from the mapping model of a collection
 	 *
 	 * @param model The mapping model.
 	 *
 	 * @return The constructed CacheDataDescriptionImpl
 	 */
 	public static CacheDataDescriptionImpl decode(Collection model) {
 		return new CacheDataDescriptionImpl(
 				model.isMutable(),
 				model.getOwner().isVersioned(),
 				model.getOwner().isVersioned()
 						? ( (VersionType) model.getOwner().getVersion().getType() ).getComparator()
 						: null
 		);
 	}
 
-	/**
-	 * Builds a CacheDataDescriptionImpl from the mapping model of a collection (using the new metamodel code).
-	 *
-	 * @param model The mapping model.
-	 *
-	 * @return The constructed CacheDataDescriptionImpl
-	 */
-	public static CacheDataDescriptionImpl decode(PluralAttributeBinding model) {
-		return new CacheDataDescriptionImpl(
-				model.isMutable(),
-				model.getContainer().seekEntityBinding().isVersioned(),
-				getVersionComparator( model.getContainer().seekEntityBinding() )
-		);
-	}
-
-	private static Comparator getVersionComparator(EntityBinding model ) {
-		if ( model.isVersioned() ) {
-			final VersionType versionType = (VersionType) model.getHierarchyDetails()
-					.getVersioningAttributeBinding()
-					.getHibernateTypeDescriptor()
-					.getResolvedTypeMapping();
-
-			return versionType.getComparator();
-		}
-
-		return null;
-	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/internal/CollectionCacheInvalidator.java b/hibernate-core/src/main/java/org/hibernate/cache/internal/CollectionCacheInvalidator.java
index 637776f2ef..eaea71ec7d 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/internal/CollectionCacheInvalidator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/internal/CollectionCacheInvalidator.java
@@ -1,167 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.internal;
 
 import java.io.Serializable;
 import java.util.Set;
 
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PostDeleteEvent;
 import org.hibernate.event.spi.PostDeleteEventListener;
 import org.hibernate.event.spi.PostInsertEvent;
 import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.event.spi.PostUpdateEvent;
 import org.hibernate.event.spi.PostUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * Allows the collection cache to be automatically evicted if an element is inserted/removed/updated *without* properly
  * managing both sides of the association (ie, the ManyToOne collection is changed w/o properly managing the OneToMany).
  * 
  * For this functionality to be used, {@link org.hibernate.cfg.AvailableSettings#AUTO_EVICT_COLLECTION_CACHE} must be
  * enabled.  For performance reasons, it's disabled by default.
  * 
  * @author Andreas Berger
  */
 public class CollectionCacheInvalidator implements Integrator, PostInsertEventListener, PostDeleteEventListener,
 		PostUpdateEventListener {
 	private static final Logger LOG = Logger.getLogger( CollectionCacheInvalidator.class.getName() );
 
 	@Override
 	public void integrate(Configuration configuration, SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		integrate( serviceRegistry, sessionFactory );
 	}
 
 	@Override
-	public void integrate(MetadataImplementor metadata, SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		integrate( serviceRegistry, sessionFactory );
-	}
-
-	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 	}
 
 	@Override
 	public void onPostInsert(PostInsertEvent event) {
 		evictCache( event.getEntity(), event.getPersister(), event.getSession(), null );
 	}
 
 	@Override
 	public boolean requiresPostCommitHanding(EntityPersister persister) {
 		return true;
 	}
 
 	@Override
 	public void onPostDelete(PostDeleteEvent event) {
 		evictCache( event.getEntity(), event.getPersister(), event.getSession(), null );
 	}
 
 	@Override
 	public void onPostUpdate(PostUpdateEvent event) {
 		evictCache( event.getEntity(), event.getPersister(), event.getSession(), event.getOldState() );
 	}
 
 	private void integrate(SessionFactoryServiceRegistry serviceRegistry, SessionFactoryImplementor sessionFactory) {
 		if ( !sessionFactory.getSettings().isAutoEvictCollectionCache() ) {
 			// feature is disabled
 			return;
 		}
 		if ( !sessionFactory.getSettings().isSecondLevelCacheEnabled() ) {
 			// Nothing to do, if caching is disabled
 			return;
 		}
 		EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		eventListenerRegistry.appendListeners( EventType.POST_INSERT, this );
 		eventListenerRegistry.appendListeners( EventType.POST_DELETE, this );
 		eventListenerRegistry.appendListeners( EventType.POST_UPDATE, this );
 	}
 
 	private void evictCache(Object entity, EntityPersister persister, EventSource session, Object[] oldState) {
 		try {
 			SessionFactoryImplementor factory = persister.getFactory();
 
 			Set<String> collectionRoles = factory.getCollectionRolesByEntityParticipant( persister.getEntityName() );
 			if ( collectionRoles == null || collectionRoles.isEmpty() ) {
 				return;
 			}
 			for ( String role : collectionRoles ) {
 				CollectionPersister collectionPersister = factory.getCollectionPersister( role );
 				if ( !collectionPersister.hasCache() ) {
 					// ignore collection if no caching is used
 					continue;
 				}
 				// this is the property this OneToMany relation is mapped by
 				String mappedBy = collectionPersister.getMappedByProperty();
 				if ( mappedBy != null ) {
 					int i = persister.getEntityMetamodel().getPropertyIndex( mappedBy );
 					Serializable oldId = null;
 					if ( oldState != null ) {
 						// in case of updating an entity we perhaps have to decache 2 entity collections, this is the
 						// old one
 						oldId = session.getIdentifier( oldState[i] );
 					}
 					Object ref = persister.getPropertyValue( entity, i );
 					Serializable id = null;
 					if ( ref != null ) {
 						id = session.getIdentifier( ref );
 					}
 					// only evict if the related entity has changed
 					if ( id != null && !id.equals( oldId ) ) {
 						evict( id, collectionPersister, session );
 						if ( oldId != null ) {
 							evict( oldId, collectionPersister, session );
 						}
 					}
 				}
 				else {
 					LOG.debug( "Evict CollectionRegion " + role );
 					collectionPersister.getCacheAccessStrategy().evictAll();
 				}
 			}
 		}
 		catch ( Exception e ) {
 			// don't let decaching influence other logic
 			LOG.error( "", e );
 		}
 	}
 
 	private void evict(Serializable id, CollectionPersister collectionPersister, EventSource session) {
 		LOG.debug( "Evict CollectionRegion " + collectionPersister.getRole() + " for id " + id );
 		CacheKey key = session.generateCacheKey( id, collectionPersister.getKeyType(), collectionPersister.getRole() );
 		collectionPersister.getCacheAccessStrategy().evict( key );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index 1989d92e9f..c7a2e7b5f8 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -1,1140 +1,1140 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.io.StringReader;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 import javax.persistence.AttributeConverter;
 import javax.persistence.Converter;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.MapsId;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.InvalidMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.common.reflection.MetadataProvider;
 import org.hibernate.annotations.common.reflection.MetadataProviderInjector;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.cfg.annotations.NamedEntityGraphDefinition;
 import org.hibernate.cfg.annotations.NamedProcedureCallDefinition;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.cfg.naming.LegacyNamingStrategyDelegator;
 import org.hibernate.cfg.naming.NamingStrategyDelegator;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentifierGeneratorAggregator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.internal.util.xml.ErrorLogger;
 import org.hibernate.internal.util.xml.MappingReader;
 import org.hibernate.internal.util.xml.Origin;
 import org.hibernate.internal.util.xml.OriginImpl;
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.internal.util.xml.XmlDocumentImpl;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Constraint;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.FetchProfile;
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.IdGenerator;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.Index;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.MappedSuperclass;
 import org.hibernate.mapping.MetadataSource;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.TypeDef;
 import org.hibernate.mapping.UniqueKey;
-import org.hibernate.metamodel.spi.TypeContributions;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributions;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.spi.GrantedPermission;
 import org.hibernate.secure.spi.JaccPermissionDeclarations;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
 import org.hibernate.tool.hbm2ddl.IndexMetadata;
 import org.hibernate.tool.hbm2ddl.SchemaUpdateScript;
 import org.hibernate.tool.hbm2ddl.TableMetadata;
 import org.hibernate.tool.hbm2ddl.UniqueConstraintSchemaUpdateStrategy;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Attribute;
 import org.dom4j.Document;
 import org.dom4j.DocumentException;
 import org.dom4j.Element;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 /**
  * An instance of <tt>Configuration</tt> allows the application
  * to specify properties and mapping documents to be used when
  * creating a <tt>SessionFactory</tt>. Usually an application will create
  * a single <tt>Configuration</tt>, build a single instance of
  * <tt>SessionFactory</tt> and then instantiate <tt>Session</tt>s in
  * threads servicing client requests. The <tt>Configuration</tt> is meant
  * only as an initialization-time object. <tt>SessionFactory</tt>s are
  * immutable and do not retain any association back to the
  * <tt>Configuration</tt>.<br>
  * <br>
  * A new <tt>Configuration</tt> will use the properties specified in
  * <tt>hibernate.properties</tt> by default.
  * <p/>
  * NOTE : This will be replaced by use of {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder} and
  * {@link org.hibernate.metamodel.MetadataSources} instead after the 4.0 release at which point this class will become
  * deprecated and scheduled for removal in 5.0.  See
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6183">HHH-6183</a>,
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-2578">HHH-2578</a> and
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6586">HHH-6586</a> for details
  *
  * @author Gavin King
  * @see org.hibernate.SessionFactory
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public class Configuration implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Configuration.class.getName());
 
 	public static final String DEFAULT_CACHE_CONCURRENCY_STRATEGY = AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 
 	public static final String USE_NEW_ID_GENERATOR_MAPPINGS = AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS;
 
 	public static final String ARTEFACT_PROCESSING_ORDER = "hibernate.mapping.precedence";
 
 	/**
 	 * Class name of the class needed to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_CLASS = "org.hibernate.search.event.EventListenerRegister";
 
 	/**
 	 * Method to call to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_METHOD = "enableHibernateSearch";
 
 	protected MetadataSourceQueue metadataSourceQueue;
 	private transient ReflectionManager reflectionManager;
 
 	protected Map<String, PersistentClass> classes;
 	protected Map<String, String> imports;
 	protected Map<String, Collection> collections;
 	protected Map<String, Table> tables;
 	protected List<AuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
 
 	protected Map<String, NamedQueryDefinition> namedQueries;
 	protected Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	protected Map<String, NamedProcedureCallDefinition> namedProcedureCallMap;
 	protected Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 	protected Map<String, NamedEntityGraphDefinition> namedEntityGraphMap;
 
 	protected Map<String, TypeDef> typeDefs;
 	protected Map<String, FilterDefinition> filterDefinitions;
 	protected Map<String, FetchProfile> fetchProfiles;
 
 	protected Map tableNameBinding;
 	protected Map columnNameBindingPerTable;
 
 	protected List<SecondPass> secondPasses;
 	protected List<Mappings.PropertyReference> propertyReferences;
 	protected Map<ExtendsQueueEntry, ?> extendsQueue;
 
 	protected Map<String, SQLFunction> sqlFunctions;
 	
 	private TypeResolver typeResolver = new TypeResolver();
 	private List<TypeContributor> typeContributorRegistrations = new ArrayList<TypeContributor>();
 
 	private EntityTuplizerFactory entityTuplizerFactory;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 
 	private Interceptor interceptor;
 	private Properties properties;
 	private EntityResolver entityResolver;
 	private EntityNotFoundDelegate entityNotFoundDelegate;
 
 	protected transient XMLHelper xmlHelper;
 	private NamingStrategyDelegator namingStrategyDelegator;
 	private SessionFactoryObserver sessionFactoryObserver;
 
 	protected final SettingsFactory settingsFactory;
 
 	private transient Mapping mapping = buildMapping();
 
 	private MutableIdentifierGeneratorFactory identifierGeneratorFactory;
 
 	private Map<Class<?>, org.hibernate.mapping.MappedSuperclass> mappedSuperClasses;
 
 	private Map<String, IdGenerator> namedGenerators;
 	private Map<String, Map<String, Join>> joins;
 	private Map<String, AnnotatedClassType> classTypes;
 	private Set<String> defaultNamedQueryNames;
 	private Set<String> defaultNamedNativeQueryNames;
 	private Set<String> defaultSqlResultSetMappingNames;
 	private Set<String> defaultNamedProcedure;
 
 	private Set<String> defaultNamedGenerators;
 	private Map<String, Properties> generatorTables;
 	private Map<Table, List<UniqueConstraintHolder>> uniqueConstraintHoldersByTable;
 	private Map<Table, List<JPAIndexHolder>> jpaIndexHoldersByTable;
 	private Map<String, String> mappedByResolver;
 	private Map<String, String> propertyRefResolver;
 	private Map<String, AnyMetaDef> anyMetaDefs;
 	private List<CacheHolder> caches;
 	private boolean inSecondPass = false;
 	private boolean isDefaultProcessed = false;
 	private boolean isValidatorNotPresentLogged;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithMapsId;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithIdAndToOne;
 	private CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 	private boolean specjProprietarySyntaxEnabled;
 
 	private ConcurrentHashMap<Class,AttributeConverterDefinition> attributeConverterDefinitionsByClass;
 
 	protected Configuration(SettingsFactory settingsFactory) {
 		this.settingsFactory = settingsFactory;
 		reset();
 	}
 
 	public Configuration() {
 		this( new SettingsFactory() );
 	}
 
 	protected void reset() {
 		metadataSourceQueue = new MetadataSourceQueue();
 		createReflectionManager();
 
 		classes = new HashMap<String,PersistentClass>();
 		imports = new HashMap<String,String>();
 		collections = new HashMap<String,Collection>();
 		tables = new TreeMap<String,Table>();
 
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		namedSqlQueries = new HashMap<String,NamedSQLQueryDefinition>();
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 		namedEntityGraphMap = new HashMap<String, NamedEntityGraphDefinition>();
 		namedProcedureCallMap = new HashMap<String, NamedProcedureCallDefinition>(  );
 		typeDefs = new HashMap<String,TypeDef>();
 		filterDefinitions = new HashMap<String, FilterDefinition>();
 		fetchProfiles = new HashMap<String, FetchProfile>();
 		auxiliaryDatabaseObjects = new ArrayList<AuxiliaryDatabaseObject>();
 
 		tableNameBinding = new HashMap();
 		columnNameBindingPerTable = new HashMap();
 
 		secondPasses = new ArrayList<SecondPass>();
 		propertyReferences = new ArrayList<Mappings.PropertyReference>();
 		extendsQueue = new HashMap<ExtendsQueueEntry, String>();
 
 		xmlHelper = new XMLHelper();
 		interceptor = EmptyInterceptor.INSTANCE;
 		properties = Environment.getProperties();
 		entityResolver = XMLHelper.DEFAULT_DTD_RESOLVER;
 
 		sqlFunctions = new HashMap<String, SQLFunction>();
 
 		entityTuplizerFactory = new EntityTuplizerFactory();
 //		componentTuplizerFactory = new ComponentTuplizerFactory();
 
 		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
 
 		mappedSuperClasses = new HashMap<Class<?>, MappedSuperclass>();
 
 		metadataSourcePrecedence = Collections.emptyList();
 
 		namedGenerators = new HashMap<String, IdGenerator>();
 		joins = new HashMap<String, Map<String, Join>>();
 		classTypes = new HashMap<String, AnnotatedClassType>();
 		generatorTables = new HashMap<String, Properties>();
 		defaultNamedQueryNames = new HashSet<String>();
 		defaultNamedNativeQueryNames = new HashSet<String>();
 		defaultSqlResultSetMappingNames = new HashSet<String>();
 		defaultNamedProcedure =  new HashSet<String>(  );
 		defaultNamedGenerators = new HashSet<String>();
 		uniqueConstraintHoldersByTable = new HashMap<Table, List<UniqueConstraintHolder>>();
 		jpaIndexHoldersByTable = new HashMap<Table,List<JPAIndexHolder>>(  );
 		mappedByResolver = new HashMap<String, String>();
 		propertyRefResolver = new HashMap<String, String>();
 		caches = new ArrayList<CacheHolder>();
 		namingStrategyDelegator = LegacyNamingStrategyDelegator.DEFAULT_INSTANCE;
 		setEntityResolver( new EJB3DTDEntityResolver() );
 		anyMetaDefs = new HashMap<String, AnyMetaDef>();
 		propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		propertiesAnnotatedWithIdAndToOne = new HashMap<XClass, Map<String, PropertyData>>();
 		specjProprietarySyntaxEnabled = System.getProperty( "hibernate.enable_specj_proprietary_syntax" ) != null;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 	public ReflectionManager getReflectionManager() {
 		return reflectionManager;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	/**
 	 * Iterate the entity mappings
 	 *
 	 * @return Iterator of the entity mappings currently contained in the configuration.
 	 */
 	public Iterator<PersistentClass> getClassMappings() {
 		return classes.values().iterator();
 	}
 
 	/**
 	 * Iterate the collection mappings
 	 *
 	 * @return Iterator of the collection mappings currently contained in the configuration.
 	 */
 	public Iterator getCollectionMappings() {
 		return collections.values().iterator();
 	}
 
 	/**
 	 * Iterate the table mappings
 	 *
 	 * @return Iterator of the table mappings currently contained in the configuration.
 	 */
 	public Iterator<Table> getTableMappings() {
 		return tables.values().iterator();
 	}
 
 	/**
 	 * Iterate the mapped super class mappings
 	 * EXPERIMENTAL Consider this API as PRIVATE
 	 *
 	 * @return iterator over the MappedSuperclass mapping currently contained in the configuration.
 	 */
 	public Iterator<MappedSuperclass> getMappedSuperclassMappings() {
 		return mappedSuperClasses.values().iterator();
 	}
 
 	/**
 	 * Get a copy of all known MappedSuperclasses
 	 * <p/>
 	 * EXPERIMENTAL Consider this API as PRIVATE
 	 *
 	 * @return Set of all known MappedSuperclasses
 	 */
 	public java.util.Set<MappedSuperclass> getMappedSuperclassMappingsCopy() {
 		return new HashSet<MappedSuperclass>( mappedSuperClasses.values() );
 	}
 
 	/**
 	 * Get the mapping for a particular entity
 	 *
 	 * @param entityName An entity name.
 	 * @return the entity mapping information
 	 */
 	public PersistentClass getClassMapping(String entityName) {
 		return classes.get( entityName );
 	}
 
 	/**
 	 * Get the mapping for a particular collection role
 	 *
 	 * @param role a collection role
 	 * @return The collection mapping information
 	 */
 	public Collection getCollectionMapping(String role) {
 		return collections.get( role );
 	}
 
 	/**
 	 * Set a custom entity resolver. This entity resolver must be
 	 * set before addXXX(misc) call.
 	 * Default value is {@link org.hibernate.internal.util.xml.DTDEntityResolver}
 	 *
 	 * @param entityResolver entity resolver to use
 	 */
 	public void setEntityResolver(EntityResolver entityResolver) {
 		this.entityResolver = entityResolver;
 	}
 
 	public EntityResolver getEntityResolver() {
 		return entityResolver;
 	}
 
 	/**
 	 * Retrieve the user-supplied delegate to handle non-existent entity
 	 * scenarios.  May be null.
 	 *
 	 * @return The user-supplied delegate
 	 */
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	/**
 	 * Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
 	 * located by specified id.  This is mainly intended for EJB3 implementations to be able to
 	 * control how proxy initialization errors should be handled...
 	 *
 	 * @param entityNotFoundDelegate The delegate to use
 	 */
 	public void setEntityNotFoundDelegate(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates inability to locate or parse
 	 * the specified mapping file.
 	 * @see #addFile(java.io.File)
 	 */
 	public Configuration addFile(String xmlFile) throws MappingException {
 		return addFile( new File( xmlFile ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates inability to locate the specified mapping file.  Historically this could
 	 * have indicated a problem parsing the XML document, but that is now delayed until after {@link #buildMappings}
 	 */
 	public Configuration addFile(final File xmlFile) throws MappingException {
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		final String name =  xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 		add( inputSource, "file", name );
 		return this;
 	}
 
 	private XmlDocument add(InputSource inputSource, String originType, String originName) {
 		return add( inputSource, new OriginImpl( originType, originName ) );
 	}
 
 	private XmlDocument add(InputSource inputSource, Origin origin) {
 		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );
 		add( metadataXml );
 		return metadataXml;
 	}
 
 	public void add(XmlDocument metadataXml) {
 		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
 			metadataSourceQueue.add( metadataXml );
 		}
 		else {
 			final MetadataProvider metadataProvider = ( (MetadataProviderInjector) reflectionManager ).getMetadataProvider();
 			JPAMetadataProvider jpaMetadataProvider = ( JPAMetadataProvider ) metadataProvider;
 			List<String> classNames = jpaMetadataProvider.getXMLContext().addDocument( metadataXml.getDocumentTree() );
 			for ( String className : classNames ) {
 				try {
 					metadataSourceQueue.add( reflectionManager.classForName( className, this.getClass() ) );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new AnnotationException( "Unable to load class defined in XML: " + className, e );
 				}
 			}
 			jpaMetadataProvider.getXMLContext().applyDiscoveredAttributeConverters( this );
 		}
 	}
 
 	private static boolean isOrmXml(XmlDocument xmlDocument) {
 		return "entity-mappings".equals( xmlDocument.getDocumentTree().getRootElement().getName() );
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation
 	 * of the DOM structure of a particular mapping.  It is saved from a previous
 	 * call as a file with the name <tt>xmlFile + ".bin"</tt> where xmlFile is
 	 * the name of the original mapping file.
 	 * </p>
 	 * If a cached <tt>xmlFile + ".bin"</tt> exists and is newer than
 	 * <tt>xmlFile</tt> the <tt>".bin"</tt> file will be read directly. Otherwise
 	 * xmlFile is read and then serialized to <tt>xmlFile + ".bin"</tt> for use
 	 * the next time.
 	 *
 	 * @param xmlFile The cacheable mapping file to be added.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 */
 	public Configuration addCacheableFile(File xmlFile) throws MappingException {
 		File cachedFile = determineCachedDomFile( xmlFile );
 
 		try {
 			return addCacheableFileStrictly( xmlFile );
 		}
 		catch ( SerializationException e ) {
 			LOG.unableToDeserializeCache( cachedFile.getPath(), e );
 		}
 		catch ( FileNotFoundException e ) {
 			LOG.cachedFileNotFound( cachedFile.getPath(), e );
 		}
 
 		final String name = xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		XmlDocument metadataXml = add( inputSource, "file", name );
 
 		try {
 			LOG.debugf( "Writing cache file for: %s to: %s", xmlFile, cachedFile );
 			SerializationHelper.serialize( ( Serializable ) metadataXml.getDocumentTree(), new FileOutputStream( cachedFile ) );
 		}
 		catch ( Exception e ) {
 			LOG.unableToWriteCachedFile( cachedFile.getPath(), e.getMessage() );
 		}
 
 		return this;
 	}
 
 	private File determineCachedDomFile(File xmlFile) {
 		return new File( xmlFile.getAbsolutePath() + ".bin" );
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param xmlFile The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public Configuration addCacheableFileStrictly(File xmlFile) throws SerializationException, FileNotFoundException {
 		final File cachedFile = determineCachedDomFile( xmlFile );
 
 		final boolean useCachedFile = xmlFile.exists()
 				&& cachedFile.exists()
 				&& xmlFile.lastModified() < cachedFile.lastModified();
 
 		if ( ! useCachedFile ) {
 			throw new FileNotFoundException( "Cached file could not be found or could not be used" );
 		}
 
 		LOG.readingCachedMappings( cachedFile );
 		Document document = ( Document ) SerializationHelper.deserialize( new FileInputStream( cachedFile ) );
 		add( new XmlDocumentImpl( document, "file", xmlFile.getAbsolutePath() ) );
 		return this;
 	}
 
 	/**
 	 * Add a cacheable mapping file.
 	 *
 	 * @param xmlFile The name of the file to be added.  This must be in a form
 	 * useable to simply construct a {@link java.io.File} instance.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public Configuration addCacheableFile(String xmlFile) throws MappingException {
 		return addCacheableFile( new File( xmlFile ) );
 	}
 
 
 	/**
 	 * Read mappings from a <tt>String</tt>
 	 *
 	 * @param xml an XML string
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates problems parsing the
 	 * given XML string
 	 */
 	public Configuration addXML(String xml) throws MappingException {
 		LOG.debugf( "Mapping XML:\n%s", xml );
 		final InputSource inputSource = new InputSource( new StringReader( xml ) );
 		add( inputSource, "string", "XML String" );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a <tt>URL</tt>
 	 *
 	 * @param url The url for the mapping document to be read.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the URL or processing
 	 * the mapping document.
 	 */
 	public Configuration addURL(URL url) throws MappingException {
 		final String urlExternalForm = url.toExternalForm();
 
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		try {
 			add( url.openStream(), "URL", urlExternalForm );
 		}
 		catch ( IOException e ) {
 			throw new InvalidMappingException( "Unable to open url stream [" + urlExternalForm + "]", "URL", urlExternalForm, e );
 		}
 		return this;
 	}
 
 	private XmlDocument add(InputStream inputStream, final String type, final String name) {
 		final InputSource inputSource = new InputSource( inputStream );
 		try {
 			return add( inputSource, type, name );
 		}
 		finally {
 			try {
 				inputStream.close();
 			}
 			catch ( IOException ignore ) {
 				LOG.trace( "Was unable to close input stream");
 			}
 		}
 	}
 
 	/**
 	 * Read mappings from a DOM <tt>Document</tt>
 	 *
 	 * @param doc The DOM document
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the DOM or processing
 	 * the mapping document.
 	 */
 	public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
 		LOG.debugf( "Mapping Document:\n%s", doc );
 
 		final Document document = xmlHelper.createDOMReader().read( doc );
 		add( new XmlDocumentImpl( document, "unknown", null ) );
 
 		return this;
 	}
 
 	/**
 	 * Read mappings from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the stream, or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addInputStream(InputStream xmlInputStream) throws MappingException {
 		add( xmlInputStream, "input stream", null );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resource (i.e. classpath lookup).
 	 *
 	 * @param resourceName The resource name
 	 * @param classLoader The class loader to use.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName, ClassLoader classLoader) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		InputStream resourceInputStream = classLoader.getResourceAsStream( resourceName );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup)
 	 * trying different class loaders.
 	 *
 	 * @param resourceName The resource name
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		ClassLoader contextClassLoader = ClassLoaderHelper.getContextClassLoader();
 		InputStream resourceInputStream = null;
 		if ( contextClassLoader != null ) {
 			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			resourceInputStream = Environment.class.getClassLoader().getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class
 	 * named <tt>foo.bar.Foo</tt> is mapped by a file <tt>foo/bar/Foo.hbm.xml</tt>
 	 * which can be resolved as a classpath resource.
 	 *
 	 * @param persistentClass The mapped class
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addClass(Class persistentClass) throws MappingException {
 		String mappingResourceName = persistentClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		LOG.readingMappingsFromResource( mappingResourceName );
 		return addResource( mappingResourceName, persistentClass.getClassLoader() );
 	}
 
 	/**
 	 * Read metadata from the annotations associated with this class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Configuration addAnnotatedClass(Class annotatedClass) {
 		XClass xClass = reflectionManager.toXClass( annotatedClass );
 		metadataSourceQueue.add( xClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name
 	 *
 	 * @return this (for method chaining)
 	 *
 	 * @throws MappingException in case there is an error in the mapping data
 	 */
 	public Configuration addPackage(String packageName) throws MappingException {
 		LOG.debugf( "Mapping Package %s", packageName );
 		try {
 			AnnotationBinder.bindPackage( packageName, createMappings() );
 			return this;
 		}
 		catch ( MappingException me ) {
 			LOG.unableToParseMetadata( packageName );
 			throw me;
 		}
 	}
 
 	/**
 	 * Read all mappings from a jar file
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addJar(File jar) throws MappingException {
 		LOG.searchingForMappingDocuments( jar.getName() );
 		JarFile jarFile = null;
 		try {
 			try {
 				jarFile = new JarFile( jar );
 			}
 			catch (IOException ioe) {
 				throw new InvalidMappingException(
 						"Could not read mapping documents from jar: " + jar.getName(), "jar", jar.getName(),
 						ioe
 				);
 			}
 			Enumeration jarEntries = jarFile.entries();
 			while ( jarEntries.hasMoreElements() ) {
 				ZipEntry ze = (ZipEntry) jarEntries.nextElement();
 				if ( ze.getName().endsWith( ".hbm.xml" ) ) {
 					LOG.foundMappingDocument( ze.getName() );
 					try {
 						addInputStream( jarFile.getInputStream( ze ) );
 					}
 					catch (Exception e) {
 						throw new InvalidMappingException(
 								"Could not read mapping documents from jar: " + jar.getName(),
 								"jar",
 								jar.getName(),
 								e
 						);
 					}
 				}
 			}
 		}
 		finally {
 			try {
 				if ( jarFile != null ) {
 					jarFile.close();
 				}
 			}
 			catch (IOException ioe) {
 				LOG.unableToCloseJar( ioe.getMessage() );
 			}
 		}
 
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		File[] files = dir.listFiles();
 		if ( files != null ) {
 			for ( File file : files ) {
 				if ( file.isDirectory() ) {
 					addDirectory( file );
 				}
 				else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 					addFile( file );
 				}
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Create a new <tt>Mappings</tt> to add class and collection mappings to.
 	 *
 	 * @return The created mappings
 	 */
 	public Mappings createMappings() {
 		return new MappingsImpl();
 	}
 
 
 	@SuppressWarnings({ "unchecked" })
 	public Iterator<IdentifierGenerator> iterateGenerators(Dialect dialect) throws MappingException {
 
 		TreeMap generators = new TreeMap();
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		for ( PersistentClass pc : classes.values() ) {
 			if ( !pc.isInherited() ) {
 				IdentifierGenerator ig = pc.getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						(RootClass) pc
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 				else if ( ig instanceof IdentifierGeneratorAggregator ) {
 					( (IdentifierGeneratorAggregator) ig ).registerPersistentGenerators( generators );
 				}
 			}
 		}
 
 		for ( Collection collection : collections.values() ) {
 			if ( collection.isIdentified() ) {
 				IdentifierGenerator ig = ( ( IdentifierCollection ) collection ).getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						null
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 			}
 		}
 
 		return generators.values().iterator();
 	}
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		// drop them in reverse order in case db needs it done that way...
 		{
 			ListIterator itr = auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 			while ( itr.hasPrevious() ) {
 				AuxiliaryDatabaseObject object = (AuxiliaryDatabaseObject) itr.previous();
 				if ( object.appliesToDialect( dialect ) ) {
 					script.add( object.sqlDropString( dialect, defaultCatalog, defaultSchema ) );
 				}
 			}
 		}
 
 		if ( dialect.dropConstraints() ) {
 			Iterator itr = getTableMappings();
 			while ( itr.hasNext() ) {
 				Table table = (Table) itr.next();
 				if ( table.isPhysicalTable() ) {
 					Iterator subItr = table.getForeignKeyIterator();
 					while ( subItr.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subItr.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlDropString(
 											dialect,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 			}
 		}
 
 
 		Iterator itr = getTableMappings();
 		while ( itr.hasNext() ) {
 
 			Table table = (Table) itr.next();
 			if ( table.isPhysicalTable() ) {
 
 				/*Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					if ( !index.isForeignKey() || !dialect.hasImplicitIndexForForeignKey() ) {
 						script.add( index.sqlDropString(dialect) );
 					}
 				}*/
 
 				script.add(
 						table.sqlDropString(
 								dialect,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 
 			}
 
 		}
 
 		itr = iterateGenerators( dialect );
 		while ( itr.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) itr.next() ).sqlDropStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				script.add(
 						table.sqlCreateString(
 								dialect,
 								mapping,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				Iterator subIter = table.getUniqueKeyIterator();
 				while ( subIter.hasNext() ) {
 					UniqueKey uk = (UniqueKey) subIter.next();
 					String constraintString = uk.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema );
 					if (constraintString != null) script.add( constraintString );
 				}
 
 
 				subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 			}
 		}
 
 		// Foreign keys must be created *after* unique keys for numerous DBs.  See HH-8390.
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				if ( dialect.hasAlterTable() ) {
 					Iterator subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlCreateString(
 											dialect, mapping,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
index 5ca1b6b5ca..7269b7ff16 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
@@ -1,217 +1,207 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Steve Ebersole
  */
 public class BeanValidationIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			BeanValidationIntegrator.class.getName()
 	);
 
 	public static final String APPLY_CONSTRAINTS = "hibernate.validator.apply_to_ddl";
 
 	public static final String BV_CHECK_CLASS = "javax.validation.Validation";
 
 	public static final String MODE_PROPERTY = "javax.persistence.validation.mode";
 
 	private static final String ACTIVATOR_CLASS_NAME = "org.hibernate.cfg.beanvalidation.TypeSafeActivator";
 	private static final String VALIDATE_SUPPLIED_FACTORY_METHOD_NAME = "validateSuppliedFactory";
 	private static final String ACTIVATE_METHOD_NAME = "activate";
 
 	/**
 	 * Used to validate the type of an explicitly passed ValidatorFactory instance
 	 *
 	 * @param object The supposed ValidatorFactory instance
 	 */
 	@SuppressWarnings("unchecked")
 	public static void validateFactory(Object object) {
 		try {
 			// this direct usage of ClassLoader should be fine since the classes exist in the same jar
 			final Class activatorClass = BeanValidationIntegrator.class.getClassLoader().loadClass( ACTIVATOR_CLASS_NAME );
 			try {
 				final Method validateMethod = activatorClass.getMethod( VALIDATE_SUPPLIED_FACTORY_METHOD_NAME, Object.class );
 				validateMethod.setAccessible( true );
 				try {
 					validateMethod.invoke( null, object );
 				}
 				catch (InvocationTargetException e) {
 					if ( e.getTargetException() instanceof HibernateException ) {
 						throw (HibernateException) e.getTargetException();
 					}
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 				catch (IllegalAccessException e) {
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Could not locate method needed for ValidatorFactory validation", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not locate TypeSafeActivator class", e );
 		}
 	}
 
 	@Override
 	public void integrate(
 			final Configuration configuration,
 			final SessionFactoryImplementor sessionFactory,
 			final SessionFactoryServiceRegistry serviceRegistry) {
 		// IMPL NOTE : see the comments on ActivationContext.getValidationModes() as to why this is multi-valued...
 		final Set<ValidationMode> modes = ValidationMode.getModes( configuration.getProperties().get( MODE_PROPERTY ) );
 		if ( modes.size() > 1 ) {
 			LOG.multipleValidationModes( ValidationMode.loggable( modes ) );
 		}
 		if ( modes.size() == 1 && modes.contains( ValidationMode.NONE ) ) {
 			// we have nothing to do; just return
 			return;
 		}
 
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		// see if the Bean Validation API is available on the classpath
 		if ( isBeanValidationApiAvailable( classLoaderService ) ) {
 			// and if so, call out to the TypeSafeActivator
 			try {
 				final Class typeSafeActivatorClass = loadTypeSafeActivatorClass( classLoaderService );
 				@SuppressWarnings("unchecked")
 				final Method activateMethod = typeSafeActivatorClass.getMethod( ACTIVATE_METHOD_NAME, ActivationContext.class );
 				final ActivationContext activationContext = new ActivationContext() {
 					@Override
 					public Set<ValidationMode> getValidationModes() {
 						return modes;
 					}
 
 					@Override
 					public Configuration getConfiguration() {
 						return configuration;
 					}
 
 					@Override
 					public SessionFactoryImplementor getSessionFactory() {
 						return sessionFactory;
 					}
 
 					@Override
 					public SessionFactoryServiceRegistry getServiceRegistry() {
 						return serviceRegistry;
 					}
 				};
 
 				try {
 					activateMethod.invoke( null, activationContext );
 				}
 				catch (InvocationTargetException e) {
 					if ( HibernateException.class.isInstance( e.getTargetException() ) ) {
 						throw ( (HibernateException) e.getTargetException() );
 					}
 					throw new IntegrationException( "Error activating Bean Validation integration", e.getTargetException() );
 				}
 				catch (Exception e) {
 					throw new IntegrationException( "Error activating Bean Validation integration", e );
 				}
 			}
 			catch (NoSuchMethodException e) {
 				throw new HibernateException( "Unable to locate TypeSafeActivator#activate method", e );
 			}
 		}
 		else {
 			// otherwise check the validation modes
 			// todo : in many ways this duplicates thew checks done on the TypeSafeActivator when a ValidatorFactory could not be obtained
 			validateMissingBeanValidationApi( modes );
 		}
 	}
 
 	private boolean isBeanValidationApiAvailable(ClassLoaderService classLoaderService) {
 		try {
 			classLoaderService.classForName( BV_CHECK_CLASS );
 			return true;
 		}
 		catch (Exception e) {
 			return false;
 		}
 	}
 
 	/**
 	 * Used to validate the case when the Bean Validation API is not available.
 	 *
 	 * @param modes The requested validation modes.
 	 */
 	private void validateMissingBeanValidationApi(Set<ValidationMode> modes) {
 		if ( modes.contains( ValidationMode.CALLBACK ) ) {
 			throw new IntegrationException( "Bean Validation API was not available, but 'callback' validation was requested" );
 		}
 		if ( modes.contains( ValidationMode.DDL ) ) {
 			throw new IntegrationException( "Bean Validation API was not available, but 'ddl' validation was requested" );
 		}
 	}
 
 	private Class loadTypeSafeActivatorClass(ClassLoaderService classLoaderService) {
 		try {
 			return classLoaderService.classForName( ACTIVATOR_CLASS_NAME );
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Unable to load TypeSafeActivator class", e );
 		}
 	}
 
-
-
-	@Override
-	public void integrate(
-			MetadataImplementor metadata,
-			SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry ) {
-	}
-
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do here afaik
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java b/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java
index 4a1787d150..d29193a8d5 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java
@@ -1,1082 +1,1082 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect;
 
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.sql.Blob;
 import java.sql.CallableStatement;
 import java.sql.Clob;
 import java.sql.NClob;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.NullPrecedence;
 import org.hibernate.ScrollMode;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.function.CastFunction;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.dialect.function.SQLFunctionTemplate;
 import org.hibernate.dialect.function.StandardAnsiSqlAggregationFunctions;
 import org.hibernate.dialect.function.StandardSQLFunction;
 import org.hibernate.dialect.lock.LockingStrategy;
 import org.hibernate.dialect.lock.OptimisticForceIncrementLockingStrategy;
 import org.hibernate.dialect.lock.OptimisticLockingStrategy;
 import org.hibernate.dialect.lock.PessimisticForceIncrementLockingStrategy;
 import org.hibernate.dialect.lock.PessimisticReadSelectLockingStrategy;
 import org.hibernate.dialect.lock.PessimisticWriteSelectLockingStrategy;
 import org.hibernate.dialect.lock.SelectLockingStrategy;
 import org.hibernate.dialect.pagination.LegacyLimitHandler;
 import org.hibernate.dialect.pagination.LimitHandler;
 import org.hibernate.dialect.unique.DefaultUniqueDelegate;
 import org.hibernate.dialect.unique.UniqueDelegate;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.exception.spi.ConversionContext;
 import org.hibernate.exception.spi.SQLExceptionConversionDelegate;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.exception.spi.ViolatedConstraintNameExtracter;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.id.SequenceGenerator;
 import org.hibernate.id.TableHiLoGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.io.StreamCopier;
 import org.hibernate.mapping.Column;
-import org.hibernate.metamodel.spi.TypeContributions;
+import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.procedure.internal.StandardCallableStatementSupport;
 import org.hibernate.procedure.spi.CallableStatementSupport;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.sql.ANSICaseFragment;
 import org.hibernate.sql.ANSIJoinFragment;
 import org.hibernate.sql.CaseFragment;
 import org.hibernate.sql.ForUpdateFragment;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.descriptor.sql.ClobTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 
 import org.jboss.logging.Logger;
 
 /**
  * Represents a dialect of SQL implemented by a particular RDBMS.  Subclasses implement Hibernate compatibility
  * with different systems.  Subclasses should provide a public default constructor that register a set of type
  * mappings and default Hibernate properties.  Subclasses should be immutable.
  *
  * @author Gavin King, David Channon
  */
 @SuppressWarnings("deprecation")
 public abstract class Dialect implements ConversionContext {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			Dialect.class.getName()
 	);
 
 	/**
 	 * Defines a default batch size constant
 	 */
 	public static final String DEFAULT_BATCH_SIZE = "15";
 
 	/**
 	 * Defines a "no batching" batch size constant
 	 */
 	public static final String NO_BATCH = "0";
 
 	/**
 	 * Characters used as opening for quoting SQL identifiers
 	 */
 	public static final String QUOTE = "`\"[";
 
 	/**
 	 * Characters used as closing for quoting SQL identifiers
 	 */
 	public static final String CLOSED_QUOTE = "`\"]";
 
 	private final TypeNames typeNames = new TypeNames();
 	private final TypeNames hibernateTypeNames = new TypeNames();
 
 	private final Properties properties = new Properties();
 	private final Map<String, SQLFunction> sqlFunctions = new HashMap<String, SQLFunction>();
 	private final Set<String> sqlKeywords = new HashSet<String>();
 
 	private final UniqueDelegate uniqueDelegate;
 
 
 	// constructors and factory methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	protected Dialect() {
 		LOG.usingDialect( this );
 		StandardAnsiSqlAggregationFunctions.primeFunctionMap( sqlFunctions );
 
 		// standard sql92 functions (can be overridden by subclasses)
 		registerFunction( "substring", new SQLFunctionTemplate( StandardBasicTypes.STRING, "substring(?1, ?2, ?3)" ) );
 		registerFunction( "locate", new SQLFunctionTemplate( StandardBasicTypes.INTEGER, "locate(?1, ?2, ?3)" ) );
 		registerFunction( "trim", new SQLFunctionTemplate( StandardBasicTypes.STRING, "trim(?1 ?2 ?3 ?4)" ) );
 		registerFunction( "length", new StandardSQLFunction( "length", StandardBasicTypes.INTEGER ) );
 		registerFunction( "bit_length", new StandardSQLFunction( "bit_length", StandardBasicTypes.INTEGER ) );
 		registerFunction( "coalesce", new StandardSQLFunction( "coalesce" ) );
 		registerFunction( "nullif", new StandardSQLFunction( "nullif" ) );
 		registerFunction( "abs", new StandardSQLFunction( "abs" ) );
 		registerFunction( "mod", new StandardSQLFunction( "mod", StandardBasicTypes.INTEGER) );
 		registerFunction( "sqrt", new StandardSQLFunction( "sqrt", StandardBasicTypes.DOUBLE) );
 		registerFunction( "upper", new StandardSQLFunction("upper") );
 		registerFunction( "lower", new StandardSQLFunction("lower") );
 		registerFunction( "cast", new CastFunction() );
 		registerFunction( "extract", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(?1 ?2 ?3)") );
 
 		//map second/minute/hour/day/month/year to ANSI extract(), override on subclasses
 		registerFunction( "second", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(second from ?1)") );
 		registerFunction( "minute", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(minute from ?1)") );
 		registerFunction( "hour", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(hour from ?1)") );
 		registerFunction( "day", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(day from ?1)") );
 		registerFunction( "month", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(month from ?1)") );
 		registerFunction( "year", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "extract(year from ?1)") );
 
 		registerFunction( "str", new SQLFunctionTemplate(StandardBasicTypes.STRING, "cast(?1 as char)") );
 
 		registerColumnType( Types.BIT, "bit" );
 		registerColumnType( Types.BOOLEAN, "boolean" );
 		registerColumnType( Types.TINYINT, "tinyint" );
 		registerColumnType( Types.SMALLINT, "smallint" );
 		registerColumnType( Types.INTEGER, "integer" );
 		registerColumnType( Types.BIGINT, "bigint" );
 		registerColumnType( Types.FLOAT, "float($p)" );
 		registerColumnType( Types.DOUBLE, "double precision" );
 		registerColumnType( Types.NUMERIC, "numeric($p,$s)" );
 		registerColumnType( Types.REAL, "real" );
 
 		registerColumnType( Types.DATE, "date" );
 		registerColumnType( Types.TIME, "time" );
 		registerColumnType( Types.TIMESTAMP, "timestamp" );
 
 		registerColumnType( Types.VARBINARY, "bit varying($l)" );
 		registerColumnType( Types.LONGVARBINARY, "bit varying($l)" );
 		registerColumnType( Types.BLOB, "blob" );
 
 		registerColumnType( Types.CHAR, "char($l)" );
 		registerColumnType( Types.VARCHAR, "varchar($l)" );
 		registerColumnType( Types.LONGVARCHAR, "varchar($l)" );
 		registerColumnType( Types.CLOB, "clob" );
 
 		registerColumnType( Types.NCHAR, "nchar($l)" );
 		registerColumnType( Types.NVARCHAR, "nvarchar($l)" );
 		registerColumnType( Types.LONGNVARCHAR, "nvarchar($l)" );
 		registerColumnType( Types.NCLOB, "nclob" );
 
 		// register hibernate types for default use in scalar sqlquery type auto detection
 		registerHibernateType( Types.BIGINT, StandardBasicTypes.BIG_INTEGER.getName() );
 		registerHibernateType( Types.BINARY, StandardBasicTypes.BINARY.getName() );
 		registerHibernateType( Types.BIT, StandardBasicTypes.BOOLEAN.getName() );
 		registerHibernateType( Types.BOOLEAN, StandardBasicTypes.BOOLEAN.getName() );
 		registerHibernateType( Types.CHAR, StandardBasicTypes.CHARACTER.getName() );
 		registerHibernateType( Types.CHAR, 1, StandardBasicTypes.CHARACTER.getName() );
 		registerHibernateType( Types.CHAR, 255, StandardBasicTypes.STRING.getName() );
 		registerHibernateType( Types.DATE, StandardBasicTypes.DATE.getName() );
 		registerHibernateType( Types.DOUBLE, StandardBasicTypes.DOUBLE.getName() );
 		registerHibernateType( Types.FLOAT, StandardBasicTypes.FLOAT.getName() );
 		registerHibernateType( Types.INTEGER, StandardBasicTypes.INTEGER.getName() );
 		registerHibernateType( Types.SMALLINT, StandardBasicTypes.SHORT.getName() );
 		registerHibernateType( Types.TINYINT, StandardBasicTypes.BYTE.getName() );
 		registerHibernateType( Types.TIME, StandardBasicTypes.TIME.getName() );
 		registerHibernateType( Types.TIMESTAMP, StandardBasicTypes.TIMESTAMP.getName() );
 		registerHibernateType( Types.VARCHAR, StandardBasicTypes.STRING.getName() );
 		registerHibernateType( Types.VARBINARY, StandardBasicTypes.BINARY.getName() );
 		registerHibernateType( Types.LONGVARCHAR, StandardBasicTypes.TEXT.getName() );
 		registerHibernateType( Types.LONGVARBINARY, StandardBasicTypes.IMAGE.getName() );
 		registerHibernateType( Types.NUMERIC, StandardBasicTypes.BIG_DECIMAL.getName() );
 		registerHibernateType( Types.DECIMAL, StandardBasicTypes.BIG_DECIMAL.getName() );
 		registerHibernateType( Types.BLOB, StandardBasicTypes.BLOB.getName() );
 		registerHibernateType( Types.CLOB, StandardBasicTypes.CLOB.getName() );
 		registerHibernateType( Types.REAL, StandardBasicTypes.FLOAT.getName() );
 
 		uniqueDelegate = new DefaultUniqueDelegate( this );
 	}
 
 	/**
 	 * Get an instance of the dialect specified by the current <tt>System</tt> properties.
 	 *
 	 * @return The specified Dialect
 	 * @throws HibernateException If no dialect was specified, or if it could not be instantiated.
 	 */
 	public static Dialect getDialect() throws HibernateException {
 		return instantiateDialect( Environment.getProperties().getProperty( Environment.DIALECT ) );
 	}
 
 
 	/**
 	 * Get an instance of the dialect specified by the given properties or by
 	 * the current <tt>System</tt> properties.
 	 *
 	 * @param props The properties to use for finding the dialect class to use.
 	 * @return The specified Dialect
 	 * @throws HibernateException If no dialect was specified, or if it could not be instantiated.
 	 */
 	public static Dialect getDialect(Properties props) throws HibernateException {
 		final String dialectName = props.getProperty( Environment.DIALECT );
 		if ( dialectName == null ) {
 			return getDialect();
 		}
 		return instantiateDialect( dialectName );
 	}
 
 	private static Dialect instantiateDialect(String dialectName) throws HibernateException {
 		if ( dialectName == null ) {
 			throw new HibernateException( "The dialect was not set. Set the property hibernate.dialect." );
 		}
 		try {
 			return (Dialect) ReflectHelper.classForName( dialectName ).newInstance();
 		}
 		catch ( ClassNotFoundException cnfe ) {
 			throw new HibernateException( "Dialect class not found: " + dialectName );
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Could not instantiate given dialect class: " + dialectName, e );
 		}
 	}
 
 	/**
 	 * Retrieve a set of default Hibernate properties for this database.
 	 *
 	 * @return a set of Hibernate properties
 	 */
 	public final Properties getDefaultProperties() {
 		return properties;
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName();
 	}
 
 
 	// database type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Allows the Dialect to contribute additional types
 	 *
 	 * @param typeContributions Callback to contribute the types
 	 * @param serviceRegistry The service registry
 	 */
 	public void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {
 		// by default, nothing to do
 	}
 
 	/**
 	 * Get the name of the database type associated with the given
 	 * {@link java.sql.Types} typecode.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @return the database type name
 	 * @throws HibernateException If no mapping was specified for that type.
 	 */
 	public String getTypeName(int code) throws HibernateException {
 		final String result = typeNames.get( code );
 		if ( result == null ) {
 			throw new HibernateException( "No default type mapping for (java.sql.Types) " + code );
 		}
 		return result;
 	}
 
 	/**
 	 * Get the name of the database type associated with the given
 	 * {@link java.sql.Types} typecode with the given storage specification
 	 * parameters.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param length The datatype length
 	 * @param precision The datatype precision
 	 * @param scale The datatype scale
 	 * @return the database type name
 	 * @throws HibernateException If no mapping was specified for that type.
 	 */
 	public String getTypeName(int code, long length, int precision, int scale) throws HibernateException {
 		final String result = typeNames.get( code, length, precision, scale );
 		if ( result == null ) {
 			throw new HibernateException(
 					String.format( "No type mapping for java.sql.Types code: %s, length: %s", code, length )
 			);
 		}
 		return result;
 	}
 
 	/**
 	 * Get the name of the database type appropriate for casting operations
 	 * (via the CAST() SQL function) for the given {@link java.sql.Types} typecode.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @return The database type name
 	 */
 	public String getCastTypeName(int code) {
 		return getTypeName( code, Column.DEFAULT_LENGTH, Column.DEFAULT_PRECISION, Column.DEFAULT_SCALE );
 	}
 
 	/**
 	 * Return an expression casting the value to the specified type
 	 *
 	 * @param value The value to cast
 	 * @param jdbcTypeCode The JDBC type code to cast to
 	 * @param length The type length
 	 * @param precision The type precision
 	 * @param scale The type scale
 	 *
 	 * @return The cast expression
 	 */
 	public String cast(String value, int jdbcTypeCode, int length, int precision, int scale) {
 		if ( jdbcTypeCode == Types.CHAR ) {
 			return "cast(" + value + " as char(" + length + "))";
 		}
 		else {
 			return "cast(" + value + "as " + getTypeName( jdbcTypeCode, length, precision, scale ) + ")";
 		}
 	}
 
 	/**
 	 * Return an expression casting the value to the specified type.  Simply calls
 	 * {@link #cast(String, int, int, int, int)} passing {@link Column#DEFAULT_PRECISION} and
 	 * {@link Column#DEFAULT_SCALE} as the precision/scale.
 	 *
 	 * @param value The value to cast
 	 * @param jdbcTypeCode The JDBC type code to cast to
 	 * @param length The type length
 	 *
 	 * @return The cast expression
 	 */
 	public String cast(String value, int jdbcTypeCode, int length) {
 		return cast( value, jdbcTypeCode, length, Column.DEFAULT_PRECISION, Column.DEFAULT_SCALE );
 	}
 
 	/**
 	 * Return an expression casting the value to the specified type.  Simply calls
 	 * {@link #cast(String, int, int, int, int)} passing {@link Column#DEFAULT_LENGTH} as the length
 	 *
 	 * @param value The value to cast
 	 * @param jdbcTypeCode The JDBC type code to cast to
 	 * @param precision The type precision
 	 * @param scale The type scale
 	 *
 	 * @return The cast expression
 	 */
 	public String cast(String value, int jdbcTypeCode, int precision, int scale) {
 		return cast( value, jdbcTypeCode, Column.DEFAULT_LENGTH, precision, scale );
 	}
 
 	/**
 	 * Subclasses register a type name for the given type code and maximum
 	 * column length. <tt>$l</tt> in the type name with be replaced by the
 	 * column length (if appropriate).
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param capacity The maximum length of database type
 	 * @param name The database type name
 	 */
 	protected void registerColumnType(int code, long capacity, String name) {
 		typeNames.put( code, capacity, name );
 	}
 
 	/**
 	 * Subclasses register a type name for the given type code. <tt>$l</tt> in
 	 * the type name with be replaced by the column length (if appropriate).
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param name The database type name
 	 */
 	protected void registerColumnType(int code, String name) {
 		typeNames.put( code, name );
 	}
 
 	/**
 	 * Allows the dialect to override a {@link SqlTypeDescriptor}.
 	 * <p/>
 	 * If the passed {@code sqlTypeDescriptor} allows itself to be remapped (per
 	 * {@link org.hibernate.type.descriptor.sql.SqlTypeDescriptor#canBeRemapped()}), then this method uses
 	 * {@link #getSqlTypeDescriptorOverride}  to get an optional override based on the SQL code returned by
 	 * {@link SqlTypeDescriptor#getSqlType()}.
 	 * <p/>
 	 * If this dialect does not provide an override or if the {@code sqlTypeDescriptor} doe not allow itself to be
 	 * remapped, then this method simply returns the original passed {@code sqlTypeDescriptor}
 	 *
 	 * @param sqlTypeDescriptor The {@link SqlTypeDescriptor} to override
 	 * @return The {@link SqlTypeDescriptor} that should be used for this dialect;
 	 *         if there is no override, then original {@code sqlTypeDescriptor} is returned.
 	 * @throws IllegalArgumentException if {@code sqlTypeDescriptor} is null.
 	 *
 	 * @see #getSqlTypeDescriptorOverride
 	 */
 	public SqlTypeDescriptor remapSqlTypeDescriptor(SqlTypeDescriptor sqlTypeDescriptor) {
 		if ( sqlTypeDescriptor == null ) {
 			throw new IllegalArgumentException( "sqlTypeDescriptor is null" );
 		}
 		if ( ! sqlTypeDescriptor.canBeRemapped() ) {
 			return sqlTypeDescriptor;
 		}
 
 		final SqlTypeDescriptor overridden = getSqlTypeDescriptorOverride( sqlTypeDescriptor.getSqlType() );
 		return overridden == null ? sqlTypeDescriptor : overridden;
 	}
 
 	/**
 	 * Returns the {@link SqlTypeDescriptor} that should be used to handle the given JDBC type code.  Returns
 	 * {@code null} if there is no override.
 	 *
 	 * @param sqlCode A {@link Types} constant indicating the SQL column type
 	 * @return The {@link SqlTypeDescriptor} to use as an override, or {@code null} if there is no override.
 	 */
 	protected SqlTypeDescriptor getSqlTypeDescriptorOverride(int sqlCode) {
 		SqlTypeDescriptor descriptor;
 		switch ( sqlCode ) {
 			case Types.CLOB: {
 				descriptor = useInputStreamToInsertBlob() ? ClobTypeDescriptor.STREAM_BINDING : null;
 				break;
 			}
 			default: {
 				descriptor = null;
 				break;
 			}
 		}
 		return descriptor;
 	}
 
 	/**
 	 * The legacy behavior of Hibernate.  LOBs are not processed by merge
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected static final LobMergeStrategy LEGACY_LOB_MERGE_STRATEGY = new LobMergeStrategy() {
 		@Override
 		public Blob mergeBlob(Blob original, Blob target, SessionImplementor session) {
 			return target;
 		}
 
 		@Override
 		public Clob mergeClob(Clob original, Clob target, SessionImplementor session) {
 			return target;
 		}
 
 		@Override
 		public NClob mergeNClob(NClob original, NClob target, SessionImplementor session) {
 			return target;
 		}
 	};
 
 	/**
 	 * Merge strategy based on transferring contents based on streams.
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected static final LobMergeStrategy STREAM_XFER_LOB_MERGE_STRATEGY = new LobMergeStrategy() {
 		@Override
 		public Blob mergeBlob(Blob original, Blob target, SessionImplementor session) {
 			if ( original != target ) {
 				try {
 					// the BLOB just read during the load phase of merge
 					final OutputStream connectedStream = target.setBinaryStream( 1L );
 					// the BLOB from the detached state
 					final InputStream detachedStream = original.getBinaryStream();
 					StreamCopier.copy( detachedStream, connectedStream );
 					return target;
 				}
 				catch (SQLException e ) {
 					throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge BLOB data" );
 				}
 			}
 			else {
 				return NEW_LOCATOR_LOB_MERGE_STRATEGY.mergeBlob( original, target, session );
 			}
 		}
 
 		@Override
 		public Clob mergeClob(Clob original, Clob target, SessionImplementor session) {
 			if ( original != target ) {
 				try {
 					// the CLOB just read during the load phase of merge
 					final OutputStream connectedStream = target.setAsciiStream( 1L );
 					// the CLOB from the detached state
 					final InputStream detachedStream = original.getAsciiStream();
 					StreamCopier.copy( detachedStream, connectedStream );
 					return target;
 				}
 				catch (SQLException e ) {
 					throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge CLOB data" );
 				}
 			}
 			else {
 				return NEW_LOCATOR_LOB_MERGE_STRATEGY.mergeClob( original, target, session );
 			}
 		}
 
 		@Override
 		public NClob mergeNClob(NClob original, NClob target, SessionImplementor session) {
 			if ( original != target ) {
 				try {
 					// the NCLOB just read during the load phase of merge
 					final OutputStream connectedStream = target.setAsciiStream( 1L );
 					// the NCLOB from the detached state
 					final InputStream detachedStream = original.getAsciiStream();
 					StreamCopier.copy( detachedStream, connectedStream );
 					return target;
 				}
 				catch (SQLException e ) {
 					throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge NCLOB data" );
 				}
 			}
 			else {
 				return NEW_LOCATOR_LOB_MERGE_STRATEGY.mergeNClob( original, target, session );
 			}
 		}
 	};
 
 	/**
 	 * Merge strategy based on creating a new LOB locator.
 	 */
 	protected static final LobMergeStrategy NEW_LOCATOR_LOB_MERGE_STRATEGY = new LobMergeStrategy() {
 		@Override
 		public Blob mergeBlob(Blob original, Blob target, SessionImplementor session) {
 			if ( original == null && target == null ) {
 				return null;
 			}
 			try {
 				final LobCreator lobCreator = session.getFactory().getJdbcServices().getLobCreator( session );
 				return original == null
 						? lobCreator.createBlob( ArrayHelper.EMPTY_BYTE_ARRAY )
 						: lobCreator.createBlob( original.getBinaryStream(), original.length() );
 			}
 			catch (SQLException e) {
 				throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge BLOB data" );
 			}
 		}
 
 		@Override
 		public Clob mergeClob(Clob original, Clob target, SessionImplementor session) {
 			if ( original == null && target == null ) {
 				return null;
 			}
 			try {
 				final LobCreator lobCreator = session.getFactory().getJdbcServices().getLobCreator( session );
 				return original == null
 						? lobCreator.createClob( "" )
 						: lobCreator.createClob( original.getCharacterStream(), original.length() );
 			}
 			catch (SQLException e) {
 				throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge CLOB data" );
 			}
 		}
 
 		@Override
 		public NClob mergeNClob(NClob original, NClob target, SessionImplementor session) {
 			if ( original == null && target == null ) {
 				return null;
 			}
 			try {
 				final LobCreator lobCreator = session.getFactory().getJdbcServices().getLobCreator( session );
 				return original == null
 						? lobCreator.createNClob( "" )
 						: lobCreator.createNClob( original.getCharacterStream(), original.length() );
 			}
 			catch (SQLException e) {
 				throw session.getFactory().getSQLExceptionHelper().convert( e, "unable to merge NCLOB data" );
 			}
 		}
 	};
 
 	public LobMergeStrategy getLobMergeStrategy() {
 		return NEW_LOCATOR_LOB_MERGE_STRATEGY;
 	}
 
 
 	// hibernate type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Get the name of the Hibernate {@link org.hibernate.type.Type} associated with the given
 	 * {@link java.sql.Types} type code.
 	 *
 	 * @param code The {@link java.sql.Types} type code
 	 * @return The Hibernate {@link org.hibernate.type.Type} name.
 	 * @throws HibernateException If no mapping was specified for that type.
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public String getHibernateTypeName(int code) throws HibernateException {
 		final String result = hibernateTypeNames.get( code );
 		if ( result == null ) {
 			throw new HibernateException( "No Hibernate type mapping for java.sql.Types code: " + code );
 		}
 		return result;
 	}
 
 	/**
 	 * Get the name of the Hibernate {@link org.hibernate.type.Type} associated
 	 * with the given {@link java.sql.Types} typecode with the given storage
 	 * specification parameters.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param length The datatype length
 	 * @param precision The datatype precision
 	 * @param scale The datatype scale
 	 * @return The Hibernate {@link org.hibernate.type.Type} name.
 	 * @throws HibernateException If no mapping was specified for that type.
 	 */
 	public String getHibernateTypeName(int code, int length, int precision, int scale) throws HibernateException {
 		final String result = hibernateTypeNames.get( code, length, precision, scale );
 		if ( result == null ) {
 			throw new HibernateException(
 					String.format(
 							"No Hibernate type mapping for type [code=%s, length=%s]",
 							code,
 							length
 					)
 			);
 		}
 		return result;
 	}
 
 	/**
 	 * Registers a Hibernate {@link org.hibernate.type.Type} name for the given
 	 * {@link java.sql.Types} type code and maximum column length.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param capacity The maximum length of database type
 	 * @param name The Hibernate {@link org.hibernate.type.Type} name
 	 */
 	protected void registerHibernateType(int code, long capacity, String name) {
 		hibernateTypeNames.put( code, capacity, name);
 	}
 
 	/**
 	 * Registers a Hibernate {@link org.hibernate.type.Type} name for the given
 	 * {@link java.sql.Types} type code.
 	 *
 	 * @param code The {@link java.sql.Types} typecode
 	 * @param name The Hibernate {@link org.hibernate.type.Type} name
 	 */
 	protected void registerHibernateType(int code, String name) {
 		hibernateTypeNames.put( code, name);
 	}
 
 
 	// function support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	protected void registerFunction(String name, SQLFunction function) {
 		// HHH-7721: SQLFunctionRegistry expects all lowercase.  Enforce,
 		// just in case a user's customer dialect uses mixed cases.
 		sqlFunctions.put( name.toLowerCase(), function );
 	}
 
 	/**
 	 * Retrieves a map of the dialect's registered functions
 	 * (functionName => {@link org.hibernate.dialect.function.SQLFunction}).
 	 *
 	 * @return The map of registered functions.
 	 */
 	public final Map<String, SQLFunction> getFunctions() {
 		return sqlFunctions;
 	}
 
 
 	// keyword support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	protected void registerKeyword(String word) {
 		sqlKeywords.add( word );
 	}
 
 	public Set<String> getKeywords() {
 		return sqlKeywords;
 	}
 
 
 	// native identifier generation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * The class (which implements {@link org.hibernate.id.IdentifierGenerator})
 	 * which acts as this dialects native generation strategy.
 	 * <p/>
 	 * Comes into play whenever the user specifies the native generator.
 	 *
 	 * @return The native generator class.
 	 */
 	public Class getNativeIdentifierGeneratorClass() {
 		if ( supportsIdentityColumns() ) {
 			return IdentityGenerator.class;
 		}
 		else if ( supportsSequences() ) {
 			return SequenceGenerator.class;
 		}
 		else {
 			return TableHiLoGenerator.class;
 		}
 	}
 
 
 	// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Does this dialect support identity column key generation?
 	 *
 	 * @return True if IDENTITY columns are supported; false otherwise.
 	 */
 	public boolean supportsIdentityColumns() {
 		return false;
 	}
 
 	/**
 	 * Does the dialect support some form of inserting and selecting
 	 * the generated IDENTITY value all in the same statement.
 	 *
 	 * @return True if the dialect supports selecting the just
 	 * generated IDENTITY in the insert statement.
 	 */
 	public boolean supportsInsertSelectIdentity() {
 		return false;
 	}
 
 	/**
 	 * Whether this dialect have an Identity clause added to the data type or a
 	 * completely separate identity data type
 	 *
 	 * @return boolean
 	 */
 	public boolean hasDataTypeInIdentityColumn() {
 		return true;
 	}
 
 	/**
 	 * Provided we {@link #supportsInsertSelectIdentity}, then attach the
 	 * "select identity" clause to the  insert statement.
 	 *  <p/>
 	 * Note, if {@link #supportsInsertSelectIdentity} == false then
 	 * the insert-string should be returned without modification.
 	 *
 	 * @param insertString The insert command
 	 * @return The insert command with any necessary identity select
 	 * clause attached.
 	 */
 	public String appendIdentitySelectToInsert(String insertString) {
 		return insertString;
 	}
 
 	/**
 	 * Get the select command to use to retrieve the last generated IDENTITY
 	 * value for a particular table
 	 *
 	 * @param table The table into which the insert was done
 	 * @param column The PK column.
 	 * @param type The {@link java.sql.Types} type code.
 	 * @return The appropriate select command
 	 * @throws MappingException If IDENTITY generation is not supported.
 	 */
 	public String getIdentitySelectString(String table, String column, int type) throws MappingException {
 		return getIdentitySelectString();
 	}
 
 	/**
 	 * Get the select command to use to retrieve the last generated IDENTITY
 	 * value.
 	 *
 	 * @return The appropriate select command
 	 * @throws MappingException If IDENTITY generation is not supported.
 	 */
 	protected String getIdentitySelectString() throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support identity key generation" );
 	}
 
 	/**
 	 * The syntax used during DDL to define a column as being an IDENTITY of
 	 * a particular type.
 	 *
 	 * @param type The {@link java.sql.Types} type code.
 	 * @return The appropriate DDL fragment.
 	 * @throws MappingException If IDENTITY generation is not supported.
 	 */
 	public String getIdentityColumnString(int type) throws MappingException {
 		return getIdentityColumnString();
 	}
 
 	/**
 	 * The syntax used during DDL to define a column as being an IDENTITY.
 	 *
 	 * @return The appropriate DDL fragment.
 	 * @throws MappingException If IDENTITY generation is not supported.
 	 */
 	protected String getIdentityColumnString() throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support identity key generation" );
 	}
 
 	/**
 	 * The keyword used to insert a generated value into an identity column (or null).
 	 * Need if the dialect does not support inserts that specify no column values.
 	 *
 	 * @return The appropriate keyword.
 	 */
 	public String getIdentityInsertString() {
 		return null;
 	}
 
 
 	// SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Does this dialect support sequences?
 	 *
 	 * @return True if sequences supported; false otherwise.
 	 */
 	public boolean supportsSequences() {
 		return false;
 	}
 
 	/**
 	 * Does this dialect support "pooled" sequences.  Not aware of a better
 	 * name for this.  Essentially can we specify the initial and increment values?
 	 *
 	 * @return True if such "pooled" sequences are supported; false otherwise.
 	 * @see #getCreateSequenceStrings(String, int, int)
 	 * @see #getCreateSequenceString(String, int, int)
 	 */
 	public boolean supportsPooledSequences() {
 		return false;
 	}
 
 	/**
 	 * Generate the appropriate select statement to to retrieve the next value
 	 * of a sequence.
 	 * <p/>
 	 * This should be a "stand alone" select statement.
 	 *
 	 * @param sequenceName the name of the sequence
 	 * @return String The "nextval" select string.
 	 * @throws MappingException If sequences are not supported.
 	 */
 	public String getSequenceNextValString(String sequenceName) throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support sequences" );
 	}
 
 	/**
 	 * Generate the select expression fragment that will retrieve the next
 	 * value of a sequence as part of another (typically DML) statement.
 	 * <p/>
 	 * This differs from {@link #getSequenceNextValString(String)} in that this
 	 * should return an expression usable within another statement.
 	 *
 	 * @param sequenceName the name of the sequence
 	 * @return The "nextval" fragment.
 	 * @throws MappingException If sequences are not supported.
 	 */
 	public String getSelectSequenceNextValString(String sequenceName) throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support sequences" );
 	}
 
 	/**
 	 * The multiline script used to create a sequence.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @return The sequence creation commands
 	 * @throws MappingException If sequences are not supported.
 	 * @deprecated Use {@link #getCreateSequenceString(String, int, int)} instead
 	 */
 	@Deprecated
 	public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
 		return new String[] { getCreateSequenceString( sequenceName ) };
 	}
 
 	/**
 	 * An optional multi-line form for databases which {@link #supportsPooledSequences()}.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @param initialValue The initial value to apply to 'create sequence' statement
 	 * @param incrementSize The increment value to apply to 'create sequence' statement
 	 * @return The sequence creation commands
 	 * @throws MappingException If sequences are not supported.
 	 */
 	public String[] getCreateSequenceStrings(String sequenceName, int initialValue, int incrementSize) throws MappingException {
 		return new String[] { getCreateSequenceString( sequenceName, initialValue, incrementSize ) };
 	}
 
 	/**
 	 * Typically dialects which support sequences can create a sequence
 	 * with a single command.  This is convenience form of
 	 * {@link #getCreateSequenceStrings} to help facilitate that.
 	 * <p/>
 	 * Dialects which support sequences and can create a sequence in a
 	 * single command need *only* override this method.  Dialects
 	 * which support sequences but require multiple commands to create
 	 * a sequence should instead override {@link #getCreateSequenceStrings}.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @return The sequence creation command
 	 * @throws MappingException If sequences are not supported.
 	 */
 	protected String getCreateSequenceString(String sequenceName) throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support sequences" );
 	}
 
 	/**
 	 * Overloaded form of {@link #getCreateSequenceString(String)}, additionally
 	 * taking the initial value and increment size to be applied to the sequence
 	 * definition.
 	 * </p>
 	 * The default definition is to suffix {@link #getCreateSequenceString(String)}
 	 * with the string: " start with {initialValue} increment by {incrementSize}" where
 	 * {initialValue} and {incrementSize} are replacement placeholders.  Generally
 	 * dialects should only need to override this method if different key phrases
 	 * are used to apply the allocation information.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @param initialValue The initial value to apply to 'create sequence' statement
 	 * @param incrementSize The increment value to apply to 'create sequence' statement
 	 * @return The sequence creation command
 	 * @throws MappingException If sequences are not supported.
 	 */
 	protected String getCreateSequenceString(String sequenceName, int initialValue, int incrementSize) throws MappingException {
 		if ( supportsPooledSequences() ) {
 			return getCreateSequenceString( sequenceName ) + " start with " + initialValue + " increment by " + incrementSize;
 		}
 		throw new MappingException( getClass().getName() + " does not support pooled sequences" );
 	}
 
 	/**
 	 * The multiline script used to drop a sequence.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @return The sequence drop commands
 	 * @throws MappingException If sequences are not supported.
 	 */
 	public String[] getDropSequenceStrings(String sequenceName) throws MappingException {
 		return new String[]{getDropSequenceString( sequenceName )};
 	}
 
 	/**
 	 * Typically dialects which support sequences can drop a sequence
 	 * with a single command.  This is convenience form of
 	 * {@link #getDropSequenceStrings} to help facilitate that.
 	 * <p/>
 	 * Dialects which support sequences and can drop a sequence in a
 	 * single command need *only* override this method.  Dialects
 	 * which support sequences but require multiple commands to drop
 	 * a sequence should instead override {@link #getDropSequenceStrings}.
 	 *
 	 * @param sequenceName The name of the sequence
 	 * @return The sequence drop commands
 	 * @throws MappingException If sequences are not supported.
 	 */
 	protected String getDropSequenceString(String sequenceName) throws MappingException {
 		throw new MappingException( getClass().getName() + " does not support sequences" );
 	}
 
 	/**
 	 * Get the select command used retrieve the names of all sequences.
 	 *
 	 * @return The select command; or null if sequences are not supported.
 	 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 	 */
 	public String getQuerySequencesString() {
 		return null;
 	}
 
 
 	// GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Get the command used to select a GUID from the underlying database.
 	 * <p/>
 	 * Optional operation.
 	 *
 	 * @return The appropriate command.
 	 */
 	public String getSelectGUIDString() {
 		throw new UnsupportedOperationException( getClass().getName() + " does not support GUIDs" );
 	}
 
 
 	// limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Does this dialect support some form of limiting query results
 	 * via a SQL clause?
 	 *
 	 * @return True if this dialect supports some form of LIMIT.
 	 * @deprecated {@link #buildLimitHandler(String, RowSelection)} should be overridden instead.
 	 */
 	@Deprecated
 	public boolean supportsLimit() {
 		return false;
 	}
 
 	/**
 	 * Does this dialect's LIMIT support (if any) additionally
 	 * support specifying an offset?
 	 *
 	 * @return True if the dialect supports an offset within the limit support.
 	 * @deprecated {@link #buildLimitHandler(String, RowSelection)} should be overridden instead.
 	 */
 	@Deprecated
 	public boolean supportsLimitOffset() {
 		return supportsLimit();
 	}
 
 	/**
 	 * Does this dialect support bind variables (i.e., prepared statement
 	 * parameters) for its limit/offset?
 	 *
 	 * @return True if bind variables can be used; false otherwise.
 	 * @deprecated {@link #buildLimitHandler(String, RowSelection)} should be overridden instead.
 	 */
 	@Deprecated
 	public boolean supportsVariableLimit() {
 		return supportsLimit();
 	}
 
 	/**
 	 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit.
 	 * Does this dialect require us to bind the parameters in reverse order?
 	 *
 	 * @return true if the correct order is limit, offset
 	 * @deprecated {@link #buildLimitHandler(String, RowSelection)} should be overridden instead.
 	 */
 	@Deprecated
 	public boolean bindLimitParametersInReverseOrder() {
 		return false;
 	}
 
 	/**
 	 * Does the <tt>LIMIT</tt> clause come at the start of the
 	 * <tt>SELECT</tt> statement, rather than at the end?
 	 *
 	 * @return true if limit parameters should come before other parameters
 	 * @deprecated {@link #buildLimitHandler(String, RowSelection)} should be overridden instead.
 	 */
 	@Deprecated
 	public boolean bindLimitParametersFirst() {
 		return false;
 	}
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/unique/DB2UniqueDelegate.java b/hibernate-core/src/main/java/org/hibernate/dialect/unique/DB2UniqueDelegate.java
index 920e885a5e..b15ddbfa37 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/unique/DB2UniqueDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/unique/DB2UniqueDelegate.java
@@ -1,133 +1,95 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.dialect.unique;
 
 import java.util.Iterator;
 
 import org.hibernate.dialect.Dialect;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Index;
-import org.hibernate.metamodel.relational.UniqueKey;
 
 /**
  * DB2 does not allow unique constraints on nullable columns.  Rather than
  * forcing "not null", use unique *indexes* instead.
  * 
  * @author Brett Meyer
  */
 public class DB2UniqueDelegate extends DefaultUniqueDelegate {
 	/**
 	 * Constructs a DB2UniqueDelegate
 	 *
 	 * @param dialect The dialect
 	 */
 	public DB2UniqueDelegate( Dialect dialect ) {
 		super( dialect );
 	}
 
 	@Override
 	public String getAlterTableToAddUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema) {
 		if ( hasNullable( uniqueKey ) ) {
 			return org.hibernate.mapping.Index.buildSqlCreateIndexString(
 					dialect,
 					uniqueKey.getName(),
 					uniqueKey.getTable(),
 					uniqueKey.columnIterator(),
 					uniqueKey.getColumnOrderMap(),
 					true,
 					defaultCatalog,
 					defaultSchema
 			);
 		}
 		else {
 			return super.getAlterTableToAddUniqueKeyCommand( uniqueKey, defaultCatalog, defaultSchema );
 		}
 	}
 	
 	@Override
-	public String getAlterTableToAddUniqueKeyCommand(UniqueKey uniqueKey) {
-		if ( hasNullable( uniqueKey ) ) {
-			return Index.buildSqlCreateIndexString(
-					dialect,
-					uniqueKey.getName(),
-					uniqueKey.getTable(),
-					uniqueKey.getColumns(),
-					true
-			);
-		}
-		else {
-			return super.getAlterTableToAddUniqueKeyCommand( uniqueKey );
-		}
-	}
-	
-	@Override
 	public String getAlterTableToDropUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema) {
 		if ( hasNullable( uniqueKey ) ) {
 			return org.hibernate.mapping.Index.buildSqlDropIndexString(
 					dialect,
 					uniqueKey.getTable(),
 					uniqueKey.getName(),
 					defaultCatalog,
 					defaultSchema
 			);
 		}
 		else {
 			return super.getAlterTableToDropUniqueKeyCommand(
 					uniqueKey, defaultCatalog, defaultSchema
 			);
 		}
 	}
 	
-	@Override
-	public String getAlterTableToDropUniqueKeyCommand(UniqueKey uniqueKey) {
-		if ( hasNullable( uniqueKey ) ) {
-			return Index.buildSqlDropIndexString( dialect, uniqueKey.getTable(), uniqueKey.getName() );
-		}
-		else {
-			return super.getAlterTableToDropUniqueKeyCommand( uniqueKey );
-		}
-	}
-	
 	private boolean hasNullable(org.hibernate.mapping.UniqueKey uniqueKey) {
 		final Iterator<org.hibernate.mapping.Column> iter = uniqueKey.columnIterator();
 		while ( iter.hasNext() ) {
 			if ( iter.next().isNullable() ) {
 				return true;
 			}
 		}
 		return false;
 	}
-
-	private boolean hasNullable(UniqueKey uniqueKey) {
-		for ( Column column : uniqueKey.getColumns() ) {
-			if ( column.isNullable() ) {
-				return true;
-			}
-		}
-		return false;
-	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/unique/DefaultUniqueDelegate.java b/hibernate-core/src/main/java/org/hibernate/dialect/unique/DefaultUniqueDelegate.java
index b65fa4e9bd..5cefa22c82 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/unique/DefaultUniqueDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/unique/DefaultUniqueDelegate.java
@@ -1,159 +1,107 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.dialect.unique;
 
 import java.util.Iterator;
 
 import org.hibernate.dialect.Dialect;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.relational.UniqueKey;
 
 /**
  * The default UniqueDelegate implementation for most dialects.  Uses
  * separate create/alter statements to apply uniqueness to a column.
  * 
  * @author Brett Meyer
  */
 public class DefaultUniqueDelegate implements UniqueDelegate {
 	protected final Dialect dialect;
 
 	/**
 	 * Constructs DefaultUniqueDelegate
 	 *
 	 * @param dialect The dialect for which we are handling unique constraints
 	 */
 	public DefaultUniqueDelegate( Dialect dialect ) {
 		this.dialect = dialect;
 	}
 
 	// legacy model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public String getColumnDefinitionUniquenessFragment(org.hibernate.mapping.Column column) {
 		return "";
 	}
 
 	@Override
 	public String getTableCreationUniqueConstraintsFragment(org.hibernate.mapping.Table table) {
 		return "";
 	}
 
 	@Override
 	public String getAlterTableToAddUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema) {
 		// Do this here, rather than allowing UniqueKey/Constraint to do it.
 		// We need full, simplified control over whether or not it happens.
 		final String tableName = uniqueKey.getTable().getQualifiedName( dialect, defaultCatalog, defaultSchema );
 		final String constraintName = dialect.quote( uniqueKey.getName() );
 		return "alter table " + tableName + " add constraint " + constraintName + " " + uniqueConstraintSql( uniqueKey );
 	}
 
 	protected String uniqueConstraintSql( org.hibernate.mapping.UniqueKey uniqueKey ) {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( " unique (" );
 		final Iterator<org.hibernate.mapping.Column> columnIterator = uniqueKey.columnIterator();
 		while ( columnIterator.hasNext() ) {
 			final org.hibernate.mapping.Column column = columnIterator.next();
 			sb.append( column.getQuotedName( dialect ) );
 			if ( uniqueKey.getColumnOrderMap().containsKey( column ) ) {
 				sb.append( " " ).append( uniqueKey.getColumnOrderMap().get( column ) );
 			}
 			if ( columnIterator.hasNext() ) {
 				sb.append( ", " );
 			}
 		}
 
 		return sb.append( ')' ).toString();
 	}
 
 	@Override
 	public String getAlterTableToDropUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema) {
 		// Do this here, rather than allowing UniqueKey/Constraint to do it.
 		// We need full, simplified control over whether or not it happens.
 		final StringBuilder buf = new StringBuilder( "alter table " );
 		buf.append( uniqueKey.getTable().getQualifiedName( dialect, defaultCatalog, defaultSchema ) );
 		buf.append(" drop constraint " );
 		if ( dialect.supportsIfExistsBeforeConstraintName() ) {
 			buf.append( "if exists " );
 		}
 		buf.append( dialect.quote( uniqueKey.getName() ) );
 		if ( dialect.supportsIfExistsAfterConstraintName() ) {
 			buf.append( " if exists" );
 		}
 		return buf.toString();
 	}
 
-
-	// new model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	@Override
-	public String getColumnDefinitionUniquenessFragment(Column column) {
-		return "";
-	}
-
-	@Override
-	public String getTableCreationUniqueConstraintsFragment(Table table) {
-		return "";
-	}
-	
-
-	@Override
-	public String getAlterTableToAddUniqueKeyCommand(UniqueKey uniqueKey) {
-		// Do this here, rather than allowing UniqueKey/Constraint to do it.
-		// We need full, simplified control over whether or not it happens.
-		final String tableName = uniqueKey.getTable().getQualifiedName( dialect );
-		final String constraintName = dialect.quote( uniqueKey.getName() );
-
-		return "alter table " + tableName + " add constraint " + constraintName + uniqueConstraintSql( uniqueKey );
-	}
-
-	protected String uniqueConstraintSql( UniqueKey uniqueKey ) {
-		final StringBuilder sb = new StringBuilder( " unique (" );
-		final Iterator columnIterator = uniqueKey.getColumns().iterator();
-		while ( columnIterator.hasNext() ) {
-			final org.hibernate.mapping.Column column = (org.hibernate.mapping.Column) columnIterator.next();
-			sb.append( column.getQuotedName( dialect ) );
-			if ( columnIterator.hasNext() ) {
-				sb.append( ", " );
-			}
-		}
-
-		return sb.append( ')' ).toString();
-	}
-
-	@Override
-	public String getAlterTableToDropUniqueKeyCommand(UniqueKey uniqueKey) {
-		// Do this here, rather than allowing UniqueKey/Constraint to do it.
-		// We need full, simplified control over whether or not it happens.
-		final String tableName = uniqueKey.getTable().getQualifiedName( dialect );
-		final String constraintName = dialect.quote( uniqueKey.getName() );
-
-		return "alter table " + tableName + " drop constraint " + constraintName;
-	}
-
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/unique/InformixUniqueDelegate.java b/hibernate-core/src/main/java/org/hibernate/dialect/unique/InformixUniqueDelegate.java
index 8a00c411dd..42dd4270f5 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/unique/InformixUniqueDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/unique/InformixUniqueDelegate.java
@@ -1,62 +1,50 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.dialect.unique;
 
 import org.hibernate.dialect.Dialect;
-import org.hibernate.metamodel.relational.UniqueKey;
 
 /**
  * Informix requires the constraint name to come last on the alter table.
  * 
  * @author Brett Meyer
  */
 public class InformixUniqueDelegate extends DefaultUniqueDelegate {
 	
 	public InformixUniqueDelegate( Dialect dialect ) {
 		super( dialect );
 	}
 
 	// legacy model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public String getAlterTableToAddUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema) {
 		// Do this here, rather than allowing UniqueKey/Constraint to do it.
 		// We need full, simplified control over whether or not it happens.
 		final String tableName = uniqueKey.getTable().getQualifiedName( dialect, defaultCatalog, defaultSchema );
 		final String constraintName = dialect.quote( uniqueKey.getName() );
 		return "alter table " + tableName + " add constraint " + uniqueConstraintSql( uniqueKey ) + " constraint " + constraintName;
 	}
 
-	// new model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	@Override
-	public String getAlterTableToAddUniqueKeyCommand(UniqueKey uniqueKey) {
-		// Do this here, rather than allowing UniqueKey/Constraint to do it.
-		// We need full, simplified control over whether or not it happens.
-		final String tableName = uniqueKey.getTable().getQualifiedName( dialect );
-		final String constraintName = dialect.quote( uniqueKey.getName() );
-
-		return "alter table " + tableName + " add constraint " + uniqueConstraintSql( uniqueKey ) + " constraint " + constraintName;
-	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/unique/UniqueDelegate.java b/hibernate-core/src/main/java/org/hibernate/dialect/unique/UniqueDelegate.java
index 156ee17144..38ed94e0c2 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/unique/UniqueDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/unique/UniqueDelegate.java
@@ -1,150 +1,100 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.dialect.unique;
 
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.relational.UniqueKey;
-
 /**
  * Dialect-level delegate in charge of applying "uniqueness" to a column.  Uniqueness can be defined
  * in 1 of 3 ways:<ol>
  *     <li>
  *         Add a unique constraint via separate alter table statements.  See {@link #getAlterTableToAddUniqueKeyCommand}.
  *         Also, see {@link #getAlterTableToDropUniqueKeyCommand}
  *     </li>
  *     <li>
  *			Add a unique constraint via dialect-specific syntax in table create statement.  See
  *			{@link #getTableCreationUniqueConstraintsFragment}
  *     </li>
  *     <li>
  *         Add "unique" syntax to the column itself.  See {@link #getColumnDefinitionUniquenessFragment}
  *     </li>
  * </ol>
  *
  * #1 & #2 are preferred, if possible; #3 should be solely a fall-back.
  * 
  * See HHH-7797.
  * 
  * @author Brett Meyer
  */
 public interface UniqueDelegate {
 	/**
 	 * Get the fragment that can be used to make a column unique as part of its column definition.
 	 * <p/>
 	 * This is intended for dialects which do not support unique constraints
 	 * 
 	 * @param column The column to which to apply the unique
 	 *
 	 * @return The fragment (usually "unique"), empty string indicates the uniqueness will be indicated using a
 	 * different approach
 	 */
 	public String getColumnDefinitionUniquenessFragment(org.hibernate.mapping.Column column);
 
 	/**
-	 * Get the fragment that can be used to make a column unique as part of its column definition.
-	 * <p/>
-	 * This is intended for dialects which do not support unique constraints
-	 *
-	 * @param column The column to which to apply the unique
-	 *
-	 * @return The fragment (usually "unique"), empty string indicates the uniqueness will be indicated using a
-	 * different approach
-	 */
-	public String getColumnDefinitionUniquenessFragment(Column column);
-
-	/**
 	 * Get the fragment that can be used to apply unique constraints as part of table creation.  The implementation
 	 * should iterate over the {@link org.hibernate.mapping.UniqueKey} instances for the given table (see
 	 * {@link org.hibernate.mapping.Table#getUniqueKeyIterator()} and generate the whole fragment for all
 	 * unique keys
 	 * <p/>
 	 * Intended for Dialects which support unique constraint definitions, but just not in separate ALTER statements.
 	 *
 	 * @param table The table for which to generate the unique constraints fragment
 	 *
 	 * @return The fragment, typically in the form {@code ", unique(col1, col2), unique( col20)"}.  NOTE: The leading
 	 * comma is important!
 	 */
 	public String getTableCreationUniqueConstraintsFragment(org.hibernate.mapping.Table table);
-	
-	/**
-	 * Get the fragment that can be used to apply unique constraints as part of table creation.  The implementation
-	 * should iterate over the {@link org.hibernate.mapping.UniqueKey} instances for the given table (see
-	 * {@link org.hibernate.mapping.Table#getUniqueKeyIterator()} and generate the whole fragment for all
-	 * unique keys
-	 * <p/>
-	 * Intended for Dialects which support unique constraint definitions, but just not in separate ALTER statements.
-	 *
-	 * @param table The table for which to generate the unique constraints fragment
-	 *
-	 * @return The fragment, typically in the form {@code ", unique(col1, col2), unique( col20)"}.  NOTE: The leading
-	 * comma is important!
-	 */
-	public String getTableCreationUniqueConstraintsFragment(Table table);
 
 	/**
 	 * Get the SQL ALTER TABLE command to be used to create the given UniqueKey.
 	 *
 	 * @param uniqueKey The UniqueKey instance.  Contains all information about the columns
 	 * @param defaultCatalog The default catalog
 	 * @param defaultSchema The default schema
 	 *
 	 * @return The ALTER TABLE command
 	 */
 	public String getAlterTableToAddUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog,
 			String defaultSchema);
 
 	/**
-	 * Get the SQL ALTER TABLE command to be used to create the given UniqueKey.
-	 *
-	 * @param uniqueKey The UniqueKey instance.  Contains all information about the columns, as well as
-	 * schema/catalog
-	 *
-	 * @return The ALTER TABLE command
-	 */
-	public String getAlterTableToAddUniqueKeyCommand(UniqueKey uniqueKey);
-
-	/**
 	 * Get the SQL ALTER TABLE command to be used to drop the given UniqueKey.
 	 *
 	 * @param uniqueKey The UniqueKey instance.  Contains all information about the columns
 	 * @param defaultCatalog The default catalog
 	 * @param defaultSchema The default schema
 	 *
 	 * @return The ALTER TABLE command
 	 */
 	public String getAlterTableToDropUniqueKeyCommand(
 			org.hibernate.mapping.UniqueKey uniqueKey,
 			String defaultCatalog, String defaultSchema);
 
-	/**
-	 * Get the SQL ALTER TABLE command to be used to drop the given UniqueKey.
-	 *
-	 * @param uniqueKey The UniqueKey instance.  Contains all information about the columns, as well as
-	 * schema/catalog
-	 *
-	 * @return The ALTER TABLE command
-	 */
-	public String getAlterTableToDropUniqueKeyCommand(UniqueKey uniqueKey);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Size.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/Size.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/relational/Size.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/Size.java
index 731d05af78..bf89c40280 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Size.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/Size.java
@@ -1,135 +1,135 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.relational;
+package org.hibernate.engine.jdbc;
 
 import java.io.Serializable;
 
 /**
  * Models size restrictions/requirements on a column's datatype.
  * <p/>
  * IMPL NOTE: since we do not necessarily know the datatype up front, and therefore do not necessarily know
  * whether length or precision/scale sizing is needed, we simply account for both here.  Additionally LOB
  * definitions, by standard, are allowed a "multiplier" consisting of 'K' (Kb), 'M' (Mb) or 'G' (Gb).
  *
  * @author Steve Ebersole
  */
 public class Size implements Serializable {
 	public static enum LobMultiplier {
 		NONE( 1 ),
 		K( NONE.factor * 1024 ),
 		M( K.factor * 1024 ),
 		G( M.factor * 1024 );
 
 		private long factor;
 
 		private LobMultiplier(long factor) {
 			this.factor = factor;
 		}
 
 		public long getFactor() {
 			return factor;
 		}
 	}
 
 	public static final int DEFAULT_LENGTH = 255;
 	public static final int DEFAULT_PRECISION = 19;
 	public static final int DEFAULT_SCALE = 2;
 
 	private long length = DEFAULT_LENGTH;
 	private int precision = DEFAULT_PRECISION;
 	private int scale = DEFAULT_SCALE;
 	private LobMultiplier lobMultiplier = LobMultiplier.NONE;
 
 	public Size() {
 	}
 
 	/**
 	 * Complete constructor.
 	 *
 	 * @param precision numeric precision
 	 * @param scale numeric scale
 	 * @param length type length
 	 * @param lobMultiplier LOB length multiplier
 	 */
 	public Size(int precision, int scale, long length, LobMultiplier lobMultiplier) {
 		this.precision = precision;
 		this.scale = scale;
 		this.length = length;
 		this.lobMultiplier = lobMultiplier;
 	}
 
 	public static Size precision(int precision) {
 		return new Size( precision, -1, -1, null );
 	}
 
 	public static Size precision(int precision, int scale) {
 		return new Size( precision, scale, -1, null );
 	}
 
 	public static Size length(long length) {
 		return new Size( -1, -1, length, null );
 	}
 
 	public static Size length(long length, LobMultiplier lobMultiplier) {
 		return new Size( -1, -1, length, lobMultiplier );
 	}
 
 	public int getPrecision() {
 		return precision;
 	}
 
 	public int getScale() {
 		return scale;
 	}
 
 	public long getLength() {
 		return length;
 	}
 
 	public LobMultiplier getLobMultiplier() {
 		return lobMultiplier;
 	}
 
 	public void initialize(Size size) {
 		this.precision = size.precision;
 		this.scale =  size.scale;
 		this.length = size.length;
 	}
 
 	public void setPrecision(int precision) {
 		this.precision = precision;
 	}
 
 	public void setScale(int scale) {
 		this.scale = scale;
 	}
 
 	public void setLength(long length) {
 		this.length = length;
 	}
 
 	public void setLobMultiplier(LobMultiplier lobMultiplier) {
 		this.lobMultiplier = lobMultiplier;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeQueryInterpreterInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeQueryInterpreterInitiator.java
index 66d0a7c999..69c7026c46 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeQueryInterpreterInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/NativeQueryInterpreterInitiator.java
@@ -1,62 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.query.internal.NativeQueryInterpreterStandardImpl;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 
 /**
  * @author Steve Ebersole
  */
 public class NativeQueryInterpreterInitiator implements SessionFactoryServiceInitiator<NativeQueryInterpreter> {
 	/**
 	 * Singleton access
 	 */
 	public static final NativeQueryInterpreterInitiator INSTANCE = new NativeQueryInterpreterInitiator();
 
 	@Override
 	public NativeQueryInterpreter initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		return NativeQueryInterpreterStandardImpl.INSTANCE;
 	}
 
 	@Override
-	public NativeQueryInterpreter initiateService(
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata,
-			ServiceRegistryImplementor registry) {
-		return NativeQueryInterpreterStandardImpl.INSTANCE;
-	}
-
-	@Override
 	public Class<NativeQueryInterpreter> getServiceInitiated() {
 		return NativeQueryInterpreter.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/CacheInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/CacheInitiator.java
index b143a5fdff..77cb5bb539 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/CacheInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/CacheInitiator.java
@@ -1,52 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.internal.CacheImpl;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 
 /**
  * @author Strong Liu <stliu@hibernate.org>
  */
 public class CacheInitiator implements SessionFactoryServiceInitiator<CacheImplementor> {
 	public static final CacheInitiator INSTANCE = new CacheInitiator();
 
 	@Override
 	public CacheImplementor initiateService(SessionFactoryImplementor sessionFactory, Configuration configuration, ServiceRegistryImplementor registry) {
 		return new CacheImpl( sessionFactory );
 	}
 
 	@Override
-	public CacheImplementor initiateService(SessionFactoryImplementor sessionFactory, MetadataImplementor metadata, ServiceRegistryImplementor registry) {
-		return new CacheImpl( sessionFactory );
-	}
-
-	@Override
 	public Class<CacheImplementor> getServiceInitiated() {
 		return CacheImplementor.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
index 76493f43d5..63d13f5b8b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
@@ -1,61 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 
 /**
  * Service initiator for {@link EventListenerRegistry}
  *
  * @author Steve Ebersole
  */
 public class EventListenerServiceInitiator implements SessionFactoryServiceInitiator<EventListenerRegistry> {
 	public static final EventListenerServiceInitiator INSTANCE = new EventListenerServiceInitiator();
 
 	@Override
 	public Class<EventListenerRegistry> getServiceInitiated() {
 		return EventListenerRegistry.class;
 	}
 
 	@Override
 	public EventListenerRegistry initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		return new EventListenerRegistryImpl();
 	}
-
-	@Override
-	public EventListenerRegistry initiateService(
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata,
-			ServiceRegistryImplementor registry) {
-		return new EventListenerRegistryImpl();
-	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/integrator/spi/Integrator.java b/hibernate-core/src/main/java/org/hibernate/integrator/spi/Integrator.java
index 8b748c78f4..195b93bc6c 100644
--- a/hibernate-core/src/main/java/org/hibernate/integrator/spi/Integrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/integrator/spi/Integrator.java
@@ -1,81 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.integrator.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Contract for stuff that integrates with Hibernate.
  * <p/>
  * IMPL NOTE: called during session factory initialization (constructor), so not all parts of the passed session factory
  * will be available.
  * <p/>
  * For more information, see the following jiras:<ul>
  *     <li><a href="https://hibernate.onjira.com/browse/HHH-5562">HHH-5562</a></li>
  *     <li><a href="https://hibernate.onjira.com/browse/HHH-6081">HHH-6081</a></li>
  * </ul>
  *
  * @author Steve Ebersole
  * @since 4.0
  *
  * @todo : the signature here *will* change, guaranteed
  * @todo : better name ?
  */
 public interface Integrator {
 
 	/**
 	 * Perform integration.
 	 *
 	 * @param configuration The configuration used to create the session factory
 	 * @param sessionFactory The session factory being created
 	 * @param serviceRegistry The session factory's service registry
 	 */
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry);
 
 	/**
-     * Perform integration.
-     *
-     * @param metadata The metadata used to create the session factory
-     * @param sessionFactory The session factory being created
-     * @param serviceRegistry The session factory's service registry
-     */
-    public void integrate( MetadataImplementor metadata,
-                           SessionFactoryImplementor sessionFactory,
-                           SessionFactoryServiceRegistry serviceRegistry );
-
-	/**
 	 * Tongue-in-cheek name for a shutdown callback.
 	 *
 	 * @param sessionFactory The session factory being closed.
 	 * @param serviceRegistry That session factory's service registry
 	 */
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry);
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
index b265bdf8ec..6718547054 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
@@ -1,1813 +1,1496 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.CustomEntityDirtinessStrategy;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.Session;
 import org.hibernate.SessionBuilder;
 import org.hibernate.SessionEventListener;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.TypeHelper;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cache.internal.CacheDataDescriptionImpl;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.NaturalIdRegion;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.access.RegionAccessStrategy;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
 import org.hibernate.cfg.SettingsFactory;
 import org.hibernate.cfg.annotations.NamedProcedureCallDefinition;
 import org.hibernate.context.internal.JTASessionContext;
 import org.hibernate.context.internal.ManagedSessionContext;
 import org.hibernate.context.internal.ThreadLocalSessionContext;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jndi.spi.JndiService;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.engine.query.spi.ReturnMetadata;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.CacheImplementor;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.SessionBuilderImplementor;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionOwner;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.procedure.ProcedureCallMemento;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.spi.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.jboss.logging.Logger;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
  * @see org.hibernate.engine.jdbc.connections.spi.ConnectionProvider
  * @see org.hibernate.Session
  * @see org.hibernate.hql.spi.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
 public final class SessionFactoryImpl
 		implements SessionFactoryImplementor {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionFactoryImpl.class.getName());
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map<String,EntityPersister> entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map<String,CollectionPersister> collectionPersisters;
 	private final transient Map<String,CollectionMetadata> collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map<String,IdentifierGenerator> identifierGenerators;
 	private final transient NamedQueryRepository namedQueryRepository;
 	private final transient Map<String, FilterDefinition> filters;
 	private final transient Map<String, FetchProfile> fetchProfiles;
 	private final transient Map<String,String> imports;
 	private final transient SessionFactoryServiceRegistry serviceRegistry;
 	private final transient JdbcServices jdbcServices;
 	private final transient Dialect dialect;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserverChain observer = new SessionFactoryObserverChain();
 	private final transient ConcurrentHashMap<EntityNameResolver,Object> entityNameResolvers = new ConcurrentHashMap<EntityNameResolver, Object>();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient CacheImplementor cacheAccess;
 	private transient boolean isClosed;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
 	private final transient TransactionEnvironment transactionEnvironment;
 	private final transient SessionFactoryOptions sessionFactoryOptions;
 	private final transient CustomEntityDirtinessStrategy customEntityDirtinessStrategy;
 	private final transient CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 
 	@SuppressWarnings( {"unchecked", "ThrowableResultOfMethodCallIgnored"})
 	public SessionFactoryImpl(
 			final Configuration cfg,
 			Mapping mapping,
 			final ServiceRegistry serviceRegistry,
 			Settings settings,
 			SessionFactoryObserver observer) throws HibernateException {
 			LOG.debug( "Building session factory" );
 
 		sessionFactoryOptions = new SessionFactoryOptions() {
 			private EntityNotFoundDelegate entityNotFoundDelegate;
 
 			@Override
 			public StandardServiceRegistry getServiceRegistry() {
 				return (StandardServiceRegistry) serviceRegistry;
 			}
 
 			@Override
 			public Interceptor getInterceptor() {
 				return cfg.getInterceptor();
 			}
 
 			@Override
 			public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 				if ( entityNotFoundDelegate == null ) {
 					if ( cfg.getEntityNotFoundDelegate() != null ) {
 						entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 					}
 					else {
 						entityNotFoundDelegate = new EntityNotFoundDelegate() {
 							public void handleEntityNotFound(String entityName, Serializable id) {
 								throw new ObjectNotFoundException( id, entityName );
 							}
 						};
 					}
 				}
 				return entityNotFoundDelegate;
 			}
 		};
 
 		this.settings = settings;
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 
 		this.serviceRegistry = serviceRegistry.getService( SessionFactoryServiceRegistryFactory.class ).buildServiceRegistry(
 				this,
 				cfg
 		);
         this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
         this.dialect = this.jdbcServices.getDialect();
 		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap<String, FilterDefinition>();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
 		LOG.debugf( "Session factory constructed with filter configurations : %s", filters );
 		LOG.debugf( "Instantiating session factory with properties: %s", properties );
 
 
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		// todo : everything above here consider implementing as standard SF service.  specifically: stats, caches, types, function-reg
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
                 integrators.clear();
 			}
 		}
 
 		final IntegratorObserver integratorObserver = new IntegratorObserver();
 		this.observer.addObserver( integratorObserver );
 		for ( Integrator integrator : serviceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			integrator.integrate( cfg, this, this.serviceRegistry );
 			integratorObserver.integrators.add( integrator );
 		}
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 		imports = new HashMap<String,String>( cfg.getImports() );
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final RegionFactory regionFactory = cacheAccess.getRegionFactory();
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 		final PersisterFactory persisterFactory = serviceRegistry.getService( PersisterFactory.class );
 
 		// todo : consider removing this silliness and just have EntityPersister directly implement ClassMetadata
 		//		EntityPersister.getClassMetadata() for the internal impls simply "return this";
 		//		collapsing those would allow us to remove this "extra" Map
 		//
 		// todo : similar for CollectionPersister/CollectionMetadata
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
 					LOG.tracef( "Building shared cache region for entity data [%s]", model.getEntityName() );
 					EntityRegion entityRegion = regionFactory.buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					cacheAccess.addCacheRegion( cacheRegionName, entityRegion );
 				}
 			}
 
 			NaturalIdRegionAccessStrategy naturalIdAccessStrategy = null;
 			if ( model.hasNaturalId() && model.getNaturalIdCacheRegionName() != null ) {
 				final String naturalIdCacheRegionName = cacheRegionPrefix + model.getNaturalIdCacheRegionName();
 				naturalIdAccessStrategy = ( NaturalIdRegionAccessStrategy ) entityAccessStrategies.get( naturalIdCacheRegionName );
 
 				if ( naturalIdAccessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 					final CacheDataDescriptionImpl cacheDataDescription = CacheDataDescriptionImpl.decode( model );
 
 					NaturalIdRegion naturalIdRegion = null;
 					try {
 						naturalIdRegion = regionFactory.buildNaturalIdRegion( naturalIdCacheRegionName, properties,
 								cacheDataDescription );
 					}
 					catch ( UnsupportedOperationException e ) {
 						LOG.warnf(
 								"Shared cache region factory [%s] does not support natural id caching; " +
 										"shared NaturalId caching will be disabled for not be enabled for %s",
 								regionFactory.getClass().getName(),
 								model.getEntityName()
 						);
 					}
 
 					if (naturalIdRegion != null) {
 						naturalIdAccessStrategy = naturalIdRegion.buildAccessStrategy( regionFactory.getDefaultAccessType() );
 						entityAccessStrategies.put( naturalIdCacheRegionName, naturalIdAccessStrategy );
 						cacheAccess.addCacheRegion(  naturalIdCacheRegionName, naturalIdRegion );
 					}
 				}
 			}
 
 			EntityPersister cp = persisterFactory.createEntityPersister(
 					model,
 					accessStrategy,
 					naturalIdAccessStrategy,
 					this,
 					mapping
 			);
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap<String,CollectionPersister>();
 		Map<String,CollectionMetadata> tmpCollectionMetadata = new HashMap<String,CollectionMetadata>();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
 				LOG.tracev( "Building shared cache region for collection data [{0}]", model.getRole() );
 				CollectionRegion collectionRegion = regionFactory.buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
 						.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				cacheAccess.addCacheRegion( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = persisterFactory.createCollectionPersister(
 					cfg,
 					model,
 					accessStrategy,
 					this
 			) ;
 			collectionPersisters.put( model.getRole(), persister );
 			tmpCollectionMetadata.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap( tmpCollectionMetadata );
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		this.namedQueryRepository = new NamedQueryRepository(
 				cfg.getNamedQueries().values(),
 				cfg.getNamedSQLQueries().values(),
 				cfg.getSqlResultSetMappings().values(),
 				toProcedureCallMementos( cfg.getNamedProcedureCallMap(), cfg.getSqlResultSetMappings() )
 		);
 
 		// after *all* persisters and named queries are registered
 		for ( EntityPersister persister : entityPersisters.values() ) {
 			persister.generateEntityDefinition();
 		}
 
 		for ( EntityPersister persister : entityPersisters.values() ) {
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 		}
 		for ( CollectionPersister persister : collectionPersisters.values() ) {
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryRegistry.INSTANCE.addSessionFactory(
 				uuid,
 				name,
 				settings.isSessionFactoryNameAlsoJndiName(),
 				this,
 				serviceRegistry.getService( JndiService.class )
 		);
 
 		LOG.debug( "Instantiated session factory" );
 
 		settings.getMultiTableBulkIdStrategy().prepare(
 				jdbcServices,
 				buildLocalConnectionAccess(),
 				cfg.createMappings(),
 				cfg.buildMapping(),
 				properties
 		);
 
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( serviceRegistry, cfg )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
 					.create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( serviceRegistry, cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( serviceRegistry, cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( serviceRegistry, cfg )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			final Map<String,HibernateException> errors = checkNamedQueries();
 			if ( ! errors.isEmpty() ) {
 				StringBuilder failingQueries = new StringBuilder( "Errors in named queries: " );
 				String sep = "";
 				for ( Map.Entry<String,HibernateException> entry : errors.entrySet() ) {
 					LOG.namedQueryError( entry.getKey(), entry.getValue() );
 					failingQueries.append( sep ).append( entry.getKey() );
 					sep = ", ";
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			for ( org.hibernate.mapping.FetchProfile.Fetch mappingFetch : mappingProfile.getFetches() ) {
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = entityName == null
 						? null
 						: entityPersisters.get( entityName );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				((Loadable) owner).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.customEntityDirtinessStrategy = determineCustomEntityDirtinessStrategy();
 		this.currentTenantIdentifierResolver = determineCurrentTenantIdentifierResolver( cfg.getCurrentTenantIdentifierResolver() );
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	private Map<String, ProcedureCallMemento> toProcedureCallMementos(
 			Map<String, NamedProcedureCallDefinition> definitions,
 			Map<String, ResultSetMappingDefinition> resultSetMappingMap) {
 		final Map<String, ProcedureCallMemento> rtn = new HashMap<String, ProcedureCallMemento>();
 		if ( definitions != null ) {
 			for (String name : definitions.keySet()){
 				rtn.put( name,  definitions.get( name ).toMemento( this, resultSetMappingMap ));
 			}
 		}
 		return rtn;
 	}
 
 	private JdbcConnectionAccess buildLocalConnectionAccess() {
 		return new JdbcConnectionAccess() {
 			@Override
 			public Connection obtainConnection() throws SQLException {
 				return settings.getMultiTenancyStrategy() == MultiTenancyStrategy.NONE
 						? serviceRegistry.getService( ConnectionProvider.class ).getConnection()
 						: serviceRegistry.getService( MultiTenantConnectionProvider.class ).getAnyConnection();
 			}
 
 			@Override
 			public void releaseConnection(Connection connection) throws SQLException {
 				if ( settings.getMultiTenancyStrategy() == MultiTenancyStrategy.NONE ) {
 					serviceRegistry.getService( ConnectionProvider.class ).closeConnection( connection );
 				}
 				else {
 					serviceRegistry.getService( MultiTenantConnectionProvider.class ).releaseAnyConnection( connection );
 				}
 			}
 
 			@Override
 			public boolean supportsAggressiveRelease() {
 				return false;
 			}
 		};
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private CustomEntityDirtinessStrategy determineCustomEntityDirtinessStrategy() {
 		CustomEntityDirtinessStrategy defaultValue = new CustomEntityDirtinessStrategy() {
 			@Override
 			public boolean canDirtyCheck(Object entity, EntityPersister persister, Session session) {
 				return false;
 			}
 
 			@Override
 			public boolean isDirty(Object entity, EntityPersister persister, Session session) {
 				return false;
 			}
 
 			@Override
 			public void resetDirty(Object entity, EntityPersister persister, Session session) {
 			}
 
 			@Override
 			public void findDirty(
 					Object entity,
 					EntityPersister persister,
 					Session session,
 					DirtyCheckContext dirtyCheckContext) {
 				// todo : implement proper method body
 			}
 		};
 		return serviceRegistry.getService( ConfigurationService.class ).getSetting(
 				AvailableSettings.CUSTOM_ENTITY_DIRTINESS_STRATEGY,
 				CustomEntityDirtinessStrategy.class,
 				defaultValue
 		);
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private CurrentTenantIdentifierResolver determineCurrentTenantIdentifierResolver(
 			CurrentTenantIdentifierResolver explicitResolver) {
 		if ( explicitResolver != null ) {
 			return explicitResolver;
 		}
 		return serviceRegistry.getService( ConfigurationService.class )
 				.getSetting(
 						AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER,
 						CurrentTenantIdentifierResolver.class,
 						null
 				);
 
 	}
 
-	@SuppressWarnings( {"ThrowableResultOfMethodCallIgnored"})
-	public SessionFactoryImpl(
-			MetadataImplementor metadata,
-			SessionFactoryOptions sessionFactoryOptions,
-			SessionFactoryObserver observer) throws HibernateException {
-
-		final boolean traceEnabled = LOG.isTraceEnabled();
-		final boolean debugEnabled = traceEnabled || LOG.isDebugEnabled();
-		if ( debugEnabled ) {
-			LOG.debug( "Building session factory" );
-		}
-
-		this.sessionFactoryOptions = sessionFactoryOptions;
-
-		this.properties = createPropertiesFromMap(
-				metadata.getServiceRegistry().getService( ConfigurationService.class ).getSettings()
-		);
-
-		// TODO: these should be moved into SessionFactoryOptions
-		this.settings = new SettingsFactory().buildSettings(
-				properties,
-				metadata.getServiceRegistry()
-		);
-
-		this.serviceRegistry =
-				sessionFactoryOptions.getServiceRegistry()
-						.getService( SessionFactoryServiceRegistryFactory.class )
-						.buildServiceRegistry( this, metadata );
-
-		this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
-		this.dialect = this.jdbcServices.getDialect();
-		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
-
-		// TODO: get SQL functions from JdbcServices (HHH-6559)
-		//this.sqlFunctionRegistry = new SQLFunctionRegistry( this.jdbcServices.getSqlFunctions() );
-		this.sqlFunctionRegistry = new SQLFunctionRegistry( this.dialect, new HashMap<String, SQLFunction>() );
-
-		// TODO: get SQL functions from a new service
-		// this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
-
-		if ( observer != null ) {
-			this.observer.addObserver( observer );
-		}
-
-		this.typeResolver = metadata.getTypeResolver().scope( this );
-		this.typeHelper = new TypeLocatorImpl( typeResolver );
-
-		this.filters = new HashMap<String, FilterDefinition>();
-		for ( FilterDefinition filterDefinition : metadata.getFilterDefinitions() ) {
-			filters.put( filterDefinition.getFilterName(), filterDefinition );
-		}
-
-		if ( debugEnabled ) {
-			LOG.debugf( "Session factory constructed with filter configurations : %s", filters );
-			LOG.debugf( "Instantiating session factory with properties: %s", properties );
-		}
-		this.queryPlanCache = new QueryPlanCache( this );
-
-		class IntegratorObserver implements SessionFactoryObserver {
-			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
-
-			@Override
-			public void sessionFactoryCreated(SessionFactory factory) {
-			}
-
-			@Override
-			public void sessionFactoryClosed(SessionFactory factory) {
-				for ( Integrator integrator : integrators ) {
-					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
-				}
-                integrators.clear();
-			}
-		}
-
-        final IntegratorObserver integratorObserver = new IntegratorObserver();
-        this.observer.addObserver(integratorObserver);
-        for (Integrator integrator : serviceRegistry.getService(IntegratorService.class).getIntegrators()) {
-            integrator.integrate(metadata, this, this.serviceRegistry);
-            integratorObserver.integrators.add(integrator);
-        }
-
-
-		//Generators:
-
-		identifierGenerators = new HashMap<String,IdentifierGenerator>();
-		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
-			if ( entityBinding.isRoot() ) {
-				identifierGenerators.put(
-						entityBinding.getEntity().getName(),
-						entityBinding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator()
-				);
-			}
-		}
-
-		///////////////////////////////////////////////////////////////////////
-		// Prepare persisters and link them up with their cache
-		// region/access-strategy
-
-		StringBuilder stringBuilder = new StringBuilder();
-		if ( settings.getCacheRegionPrefix() != null) {
-			stringBuilder
-					.append( settings.getCacheRegionPrefix() )
-					.append( '.' );
-		}
-		final String cacheRegionPrefix = stringBuilder.toString();
-
-		entityPersisters = new HashMap<String,EntityPersister>();
-		Map<String, RegionAccessStrategy> entityAccessStrategies = new HashMap<String, RegionAccessStrategy>();
-		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
-		for ( EntityBinding model : metadata.getEntityBindings() ) {
-			// TODO: should temp table prep happen when metadata is being built?
-			//model.prepareTemporaryTables( metadata, getDialect() );
-			// cache region is defined by the root-class in the hierarchy...
-			EntityBinding rootEntityBinding = metadata.getRootEntityBinding( model.getEntity().getName() );
-			EntityRegionAccessStrategy accessStrategy = null;
-			if ( settings.isSecondLevelCacheEnabled() &&
-					rootEntityBinding.getHierarchyDetails().getCaching() != null &&
-					model.getHierarchyDetails().getCaching() != null &&
-					model.getHierarchyDetails().getCaching().getAccessType() != null ) {
-				final String cacheRegionName = cacheRegionPrefix + rootEntityBinding.getHierarchyDetails().getCaching().getRegion();
-				accessStrategy = EntityRegionAccessStrategy.class.cast( entityAccessStrategies.get( cacheRegionName ) );
-				if ( accessStrategy == null ) {
-					final AccessType accessType = model.getHierarchyDetails().getCaching().getAccessType();
-					if ( traceEnabled ) {
-						LOG.tracev( "Building cache for entity data [{0}]", model.getEntity().getName() );
-					}
-					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion(
-							cacheRegionName, properties, CacheDataDescriptionImpl.decode( model )
-					);
-					accessStrategy = entityRegion.buildAccessStrategy( accessType );
-					entityAccessStrategies.put( cacheRegionName, accessStrategy );
-					cacheAccess.addCacheRegion( cacheRegionName, entityRegion );
-				}
-			}
-			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
-					model, accessStrategy, this, metadata
-			);
-			entityPersisters.put( model.getEntity().getName(), cp );
-			classMeta.put( model.getEntity().getName(), cp.getClassMetadata() );
-		}
-		this.classMetadata = Collections.unmodifiableMap(classMeta);
-
-		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
-		collectionPersisters = new HashMap<String,CollectionPersister>();
-		Map<String, CollectionMetadata> tmpCollectionMetadata = new HashMap<String, CollectionMetadata>();
-		for ( PluralAttributeBinding model : metadata.getCollectionBindings() ) {
-			if ( model.getAttribute() == null ) {
-				throw new IllegalStateException( "No attribute defined for a AbstractPluralAttributeBinding: " +  model );
-			}
-			if ( model.getAttribute().isSingular() ) {
-				throw new IllegalStateException(
-						"AbstractPluralAttributeBinding has a Singular attribute defined: " + model.getAttribute().getName()
-				);
-			}
-			final String cacheRegionName = cacheRegionPrefix + model.getCaching().getRegion();
-			final AccessType accessType = model.getCaching().getAccessType();
-			CollectionRegionAccessStrategy accessStrategy = null;
-			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
-				if ( traceEnabled ) {
-					LOG.tracev( "Building cache for collection data [{0}]", model.getAttribute().getRole() );
-				}
-				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion(
-						cacheRegionName, properties, CacheDataDescriptionImpl.decode( model )
-				);
-				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
-				entityAccessStrategies.put( cacheRegionName, accessStrategy );
-				cacheAccess.addCacheRegion(  cacheRegionName, collectionRegion );
-			}
-			CollectionPersister persister = serviceRegistry
-					.getService( PersisterFactory.class )
-					.createCollectionPersister( metadata, model, accessStrategy, this );
-			collectionPersisters.put( model.getAttribute().getRole(), persister );
-			tmpCollectionMetadata.put( model.getAttribute().getRole(), persister.getCollectionMetadata() );
-			Type indexType = persister.getIndexType();
-			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
-				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
-				Set<String> roles = tmpEntityToCollectionRoleMap.get( entityName );
-				if ( roles == null ) {
-					roles = new HashSet<String>();
-					tmpEntityToCollectionRoleMap.put( entityName, roles );
-				}
-				roles.add( persister.getRole() );
-			}
-			Type elementType = persister.getElementType();
-			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
-				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
-				Set<String> roles = tmpEntityToCollectionRoleMap.get( entityName );
-				if ( roles == null ) {
-					roles = new HashSet<String>();
-					tmpEntityToCollectionRoleMap.put( entityName, roles );
-				}
-				roles.add( persister.getRole() );
-			}
-		}
-		collectionMetadata = Collections.unmodifiableMap( tmpCollectionMetadata );
-		for ( Map.Entry<String, Set<String>> entry : tmpEntityToCollectionRoleMap.entrySet() ) {
-			entry.setValue( Collections.unmodifiableSet( entry.getValue() ) );
-		}
-		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
-
-
-		//Named Queries:
-		namedQueryRepository = new NamedQueryRepository(
-				metadata.getNamedQueryDefinitions(),
-				metadata.getNamedNativeQueryDefinitions(),
-				metadata.getResultSetMappingDefinitions(),
-				new HashMap<String, ProcedureCallMemento>(  )
-		);
-
-		imports = new HashMap<String,String>();
-		for ( Map.Entry<String,String> importEntry : metadata.getImports() ) {
-			imports.put( importEntry.getKey(), importEntry.getValue() );
-		}
-
-		// after *all* persisters and named queries are registered
-		Iterator iter = entityPersisters.values().iterator();
-		while ( iter.hasNext() ) {
-			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
-			persister.postInstantiate();
-			registerEntityNameResolvers( persister );
-
-		}
-		iter = collectionPersisters.values().iterator();
-		while ( iter.hasNext() ) {
-			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
-			persister.postInstantiate();
-		}
-
-		//JNDI + Serialization:
-
-		name = settings.getSessionFactoryName();
-		try {
-			uuid = (String) UUID_GENERATOR.generate(null, null);
-		}
-		catch (Exception e) {
-			throw new AssertionFailure("Could not generate UUID");
-		}
-		SessionFactoryRegistry.INSTANCE.addSessionFactory(
-				uuid, 
-				name,
-				settings.isSessionFactoryNameAlsoJndiName(),
-				this,
-				serviceRegistry.getService( JndiService.class )
-		);
-
-		if ( debugEnabled ) {
-			LOG.debug("Instantiated session factory");
-		}
-
-		if ( settings.isAutoCreateSchema() ) {
-			new SchemaExport( metadata )
-					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
-					.create( false, true );
-		}
-
-		if ( settings.isAutoDropSchema() ) {
-			schemaExport = new SchemaExport( metadata )
-					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
-		}
-
-		currentSessionContext = buildCurrentSessionContext();
-
-		//checking for named queries
-		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
-			final Map<String,HibernateException> errors = checkNamedQueries();
-			if ( ! errors.isEmpty() ) {
-				StringBuilder failingQueries = new StringBuilder( "Errors in named queries: " );
-				String sep = "";
-				for ( Map.Entry<String,HibernateException> entry : errors.entrySet() ) {
-					LOG.namedQueryError( entry.getKey(), entry.getValue() );
-					failingQueries.append( entry.getKey() ).append( sep );
-					sep = ", ";
-				}
-				throw new HibernateException( failingQueries.toString() );
-			}
-		}
-
-		// this needs to happen after persisters are all ready to go...
-		this.fetchProfiles = new HashMap<String,FetchProfile>();
-		for ( org.hibernate.metamodel.binding.FetchProfile mappingProfile : metadata.getFetchProfiles() ) {
-			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
-			for ( org.hibernate.metamodel.binding.FetchProfile.Fetch mappingFetch : mappingProfile.getFetches() ) {
-				// resolve the persister owning the fetch
-				final String entityName = getImportedClassName( mappingFetch.getEntity() );
-				final EntityPersister owner = entityName == null ? null : entityPersisters.get( entityName );
-				if ( owner == null ) {
-					throw new HibernateException(
-							"Unable to resolve entity reference [" + mappingFetch.getEntity()
-									+ "] in fetch profile [" + fetchProfile.getName() + "]"
-					);
-				}
-
-				// validate the specified association fetch
-				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
-				if ( associationType == null || ! associationType.isAssociationType() ) {
-					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
-				}
-
-				// resolve the style
-				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
-
-				// then construct the fetch instance...
-				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
-				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
-			}
-			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
-		}
-
-		this.customEntityDirtinessStrategy = determineCustomEntityDirtinessStrategy();
-		this.currentTenantIdentifierResolver = determineCurrentTenantIdentifierResolver( null );
-		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
-		this.observer.sessionFactoryCreated( this );
-	}
-
 	@SuppressWarnings( {"unchecked"} )
 	private static Properties createPropertiesFromMap(Map map) {
 		Properties properties = new Properties();
 		properties.putAll( map );
 		return properties;
 	}
 
 	public Session openSession() throws HibernateException {
 		return withOptions().openSession();
 	}
 
 	public Session openTemporarySession() throws HibernateException {
 		return withOptions()
 				.autoClose( false )
 				.flushBeforeCompletion( false )
 				.connectionReleaseMode( ConnectionReleaseMode.AFTER_STATEMENT )
 				.openSession();
 	}
 
 	public Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	@Override
 	public SessionBuilderImplementor withOptions() {
 		return new SessionBuilderImpl( this );
 	}
 
 	@Override
 	public StatelessSessionBuilder withStatelessOptions() {
 		return new StatelessSessionBuilderImpl( this );
 	}
 
 	public StatelessSession openStatelessSession() {
 		return withStatelessOptions().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return withStatelessOptions().connection( connection ).openStatelessSession();
 	}
 
 	@Override
 	public void addObserver(SessionFactoryObserver observer) {
 		this.observer.addObserver( observer );
 	}
 
 	public TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizer() == null ) {
 			return;
 		}
 		registerEntityNameResolvers( persister.getEntityMetamodel().getTuplizer() );
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( EntityNameResolver resolver : resolvers ) {
 			registerEntityNameResolver( resolver );
 		}
 	}
 
 	private static final Object ENTITY_NAME_RESOLVER_MAP_VALUE = new Object();
 
 	public void registerEntityNameResolver(EntityNameResolver resolver) {
 		entityNameResolvers.put( resolver, ENTITY_NAME_RESOLVER_MAP_VALUE );
 	}
 
 	@Override
 	public Iterable<EntityNameResolver> iterateEntityNameResolvers() {
 		return entityNameResolvers.keySet();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	private Map<String,HibernateException> checkNamedQueries() throws HibernateException {
 		return namedQueryRepository.checkNamedQueries( queryPlanCache );
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = entityPersisters.get(entityName);
 		if ( result == null ) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	@Override
 	public Map<String, CollectionPersister> getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	@Override
 	public Map<String, EntityPersister> getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = collectionPersisters.get(role);
 		if ( result == null ) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	@Override
 	public SessionFactoryOptions getSessionFactoryOptions() {
 		return sessionFactoryOptions;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return jdbcServices;
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return dialect;
 	}
 
 	public Interceptor getInterceptor() {
 		return sessionFactoryOptions.getInterceptor();
 	}
 
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SqlExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	@Override
 	public Reference getReference() {
 		// from javax.naming.Referenceable
         LOG.debug( "Returning a Reference to the SessionFactory" );
 		return new Reference(
 				SessionFactoryImpl.class.getName(),
 				new StringRefAddr("uuid", uuid),
 				SessionFactoryRegistry.ObjectFactoryImpl.class.getName(),
 				null
 		);
 	}
 
 	@Override
 	public NamedQueryRepository getNamedQueryRepository() {
 		return namedQueryRepository;
 	}
 
 	public void registerNamedQueryDefinition(String name, NamedQueryDefinition definition) {
 		namedQueryRepository.registerNamedQueryDefinition( name, definition );
 	}
 
 	public NamedQueryDefinition getNamedQuery(String queryName) {
 		return namedQueryRepository.getNamedQueryDefinition( queryName );
 	}
 
 	public void registerNamedSQLQueryDefinition(String name, NamedSQLQueryDefinition definition) {
 		namedQueryRepository.registerNamedSQLQueryDefinition( name, definition );
 	}
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName) {
 		return namedQueryRepository.getNamedSQLQueryDefinition( queryName );
 	}
 
 	public ResultSetMappingDefinition getResultSetMapping(String mappingName) {
 		return namedQueryRepository.getResultSetMappingDefinition( mappingName );
 	}
 
 	public Type getIdentifierType(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierType();
 	}
 	public String getIdentifierPropertyName(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierPropertyName();
 	}
 
 	public Type[] getReturnTypes(String queryString) throws HibernateException {
 		final ReturnMetadata metadata = queryPlanCache.getHQLQueryPlan( queryString, false, Collections.EMPTY_MAP )
 				.getReturnMetadata();
 		return metadata == null ? null : metadata.getReturnTypes();
 	}
 
 	public String[] getReturnAliases(String queryString) throws HibernateException {
 		final ReturnMetadata metadata = queryPlanCache.getHQLQueryPlan( queryString, false, Collections.EMPTY_MAP )
 				.getReturnMetadata();
 		return metadata == null ? null : metadata.getReturnAliases();
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getClassMetadata( persistentClass.getName() );
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return collectionMetadata.get(roleName);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName) throws HibernateException {
 		return classMetadata.get( entityName );
 	}
 
 	/**
 	 * Given the name of an entity class, determine all the class and interface names by which it can be
 	 * referenced in an HQL query.
 	 *
      * @param className The name of the entity class
 	 *
 	 * @return the names of all persistent (mapped) classes that extend or implement the
 	 *     given class or interface, accounting for implicit/explicit polymorphism settings
 	 *     and excluding mapped subclasses/joined-subclasses of other classes in the result.
 	 * @throws MappingException
 	 */
 	public String[] getImplementors(String className) throws MappingException {
 
 		final Class clazz;
 		try {
 			clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( className );
 		}
 		catch (ClassLoadingException cnfe) {
 			return new String[] { className }; //for a dynamic-class
 		}
 
 		ArrayList<String> results = new ArrayList<String>();
 		for ( EntityPersister checkPersister : entityPersisters.values() ) {
 			if ( ! Queryable.class.isInstance( checkPersister ) ) {
 				continue;
 			}
 			final Queryable checkQueryable = Queryable.class.cast( checkPersister );
 			final String checkQueryableEntityName = checkQueryable.getEntityName();
 			final boolean isMappedClass = className.equals( checkQueryableEntityName );
 			if ( checkQueryable.isExplicitPolymorphism() ) {
 				if ( isMappedClass ) {
 					return new String[] { className }; //NOTE EARLY EXIT
 				}
 			}
 			else {
 				if ( isMappedClass ) {
 					results.add( checkQueryableEntityName );
 				}
 				else {
 					final Class mappedClass = checkQueryable.getMappedClass();
 					if ( mappedClass != null && clazz.isAssignableFrom( mappedClass ) ) {
 						final boolean assignableSuperclass;
 						if ( checkQueryable.isInherited() ) {
 							Class mappedSuperclass = getEntityPersister( checkQueryable.getMappedSuperclass() ).getMappedClass();
 							assignableSuperclass = clazz.isAssignableFrom( mappedSuperclass );
 						}
 						else {
 							assignableSuperclass = false;
 						}
 						if ( !assignableSuperclass ) {
 							results.add( checkQueryableEntityName );
 						}
 					}
 				}
 			}
 		}
 		return results.toArray( new String[results.size()] );
 	}
 
 	@Override
 	public String getImportedClassName(String className) {
 		String result = imports.get( className );
 		if ( result == null ) {
 			try {
 				serviceRegistry.getService( ClassLoaderService.class ).classForName( className );
 				imports.put( className, className );
 				return className;
 			}
 			catch ( ClassLoadingException cnfe ) {
 				return null;
 			}
 		}
 		else {
 			return result;
 		}
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return classMetadata;
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return collectionMetadata;
 	}
 
 	public Type getReferencedPropertyType(String className, String propertyName)
 		throws MappingException {
 		return getEntityPersister( className ).getPropertyType( propertyName );
 	}
 
 	public ConnectionProvider getConnectionProvider() {
 		return jdbcServices.getConnectionProvider();
 	}
 
 	/**
 	 * Closes the session factory, releasing all held resources.
 	 *
 	 * <ol>
 	 * <li>cleans up used cache regions and "stops" the cache provider.
 	 * <li>close the JDBC connection
 	 * <li>remove the JNDI binding
 	 * </ol>
 	 *
 	 * Note: Be aware that the sessionFactory instance still can
 	 * be a "heavy" object memory wise after close() has been called.  Thus
 	 * it is important to not keep referencing the instance to let the garbage
 	 * collector release the memory.
 	 * @throws HibernateException
 	 */
 	public void close() throws HibernateException {
 
 		if ( isClosed ) {
 			LOG.trace( "Already closed" );
 			return;
 		}
 
 		LOG.closing();
 
 		isClosed = true;
 
 		settings.getMultiTableBulkIdStrategy().release( jdbcServices, buildLocalConnectionAccess() );
 
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			EntityPersister p = (EntityPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = (CollectionPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		cacheAccess.close();
 
 		queryPlanCache.cleanup();
 
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport.drop( false, true );
 		}
 
 		SessionFactoryRegistry.INSTANCE.removeSessionFactory(
 				uuid,
 				name,
 				settings.isSessionFactoryNameAlsoJndiName(),
 				serviceRegistry.getService( JndiService.class )
 		);
 
 		observer.sessionFactoryClosed( this );
 		serviceRegistry.destroy();
 	}
 
 	public Cache getCache() {
 		return cacheAccess;
 	}
 
 	public void evictEntity(String entityName, Serializable id) throws HibernateException {
 		getCache().evictEntity( entityName, id );
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getCache().evictEntityRegion( entityName );
 	}
 
 	public void evict(Class persistentClass, Serializable id) throws HibernateException {
 		getCache().evictEntity( persistentClass, id );
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getCache().evictEntityRegion( persistentClass );
 	}
 
 	public void evictCollection(String roleName, Serializable id) throws HibernateException {
 		getCache().evictCollection( roleName, id );
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getCache().evictCollectionRegion( roleName );
 	}
 
 	public void evictQueries() throws HibernateException {
 		cacheAccess.evictQueries();
 	}
 
 	public void evictQueries(String regionName) throws HibernateException {
 		getCache().evictQueryRegion( regionName );
 	}
 
 	public UpdateTimestampsCache getUpdateTimestampsCache() {
 		return cacheAccess.getUpdateTimestampsCache();
 	}
 
 	public QueryCache getQueryCache() {
 		return cacheAccess.getQueryCache();
 	}
 
 	public QueryCache getQueryCache(String regionName) throws HibernateException {
 		return cacheAccess.getQueryCache( regionName );
 	}
 
 	public Region getSecondLevelCacheRegion(String regionName) {
 		return cacheAccess.getSecondLevelCacheRegion( regionName );
 	}
 
 	public Region getNaturalIdCacheRegion(String regionName) {
 		return cacheAccess.getNaturalIdCacheRegion( regionName );
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public Map getAllSecondLevelCacheRegions() {
 		return cacheAccess.getAllSecondLevelCacheRegions();
 	}
 
 	public boolean isClosed() {
 		return isClosed;
 	}
 
 	public Statistics getStatistics() {
 		return getStatisticsImplementor();
 	}
 
 	public StatisticsImplementor getStatisticsImplementor() {
 		return serviceRegistry.getService( StatisticsImplementor.class );
 	}
 
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException {
 		FilterDefinition def = filters.get( filterName );
 		if ( def == null ) {
 			throw new HibernateException( "No such filter configured [" + filterName + "]" );
 		}
 		return def;
 	}
 
 	public boolean containsFetchProfileDefinition(String name) {
 		return fetchProfiles.containsKey( name );
 	}
 
 	public Set getDefinedFilterNames() {
 		return filters.keySet();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {
 		return identifierGenerators.get(rootEntityName);
 	}
 
 	private TransactionFactory transactionFactory() {
 		return serviceRegistry.getService( TransactionFactory.class );
 	}
 
 	private boolean canAccessTransactionManager() {
 		try {
 			return serviceRegistry.getService( JtaPlatform.class ).retrieveTransactionManager() != null;
 		}
 		catch (Exception e) {
 			return false;
 		}
 	}
 
 	private CurrentSessionContext buildCurrentSessionContext() {
 		String impl = properties.getProperty( Environment.CURRENT_SESSION_CONTEXT_CLASS );
 		// for backward-compatibility
 		if ( impl == null ) {
 			if ( canAccessTransactionManager() ) {
 				impl = "jta";
 			}
 			else {
 				return null;
 			}
 		}
 
 		if ( "jta".equals( impl ) ) {
 			if ( ! transactionFactory().compatibleWithJtaSynchronization() ) {
 				LOG.autoFlushWillNotWork();
 			}
 			return new JTASessionContext( this );
 		}
 		else if ( "thread".equals( impl ) ) {
 			return new ThreadLocalSessionContext( this );
 		}
 		else if ( "managed".equals( impl ) ) {
 			return new ManagedSessionContext( this );
 		}
 		else {
 			try {
 				Class implClass = serviceRegistry.getService( ClassLoaderService.class ).classForName( impl );
 				return ( CurrentSessionContext ) implClass
 						.getConstructor( new Class[] { SessionFactoryImplementor.class } )
 						.newInstance( this );
 			}
 			catch( Throwable t ) {
 				LOG.unableToConstructCurrentSessionContext( impl, t );
 				return null;
 			}
 		}
 	}
 
 	@Override
 	public ServiceRegistryImplementor getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Override
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return sessionFactoryOptions.getEntityNotFoundDelegate();
 	}
 
 	public SQLFunctionRegistry getSqlFunctionRegistry() {
 		return sqlFunctionRegistry;
 	}
 
 	public FetchProfile getFetchProfile(String name) {
 		return fetchProfiles.get( name );
 	}
 
 	public TypeHelper getTypeHelper() {
 		return typeHelper;
 	}
 
 	static class SessionBuilderImpl implements SessionBuilderImplementor {
 		private static final Logger log = CoreLogging.logger( SessionBuilderImpl.class );
 
 		private final SessionFactoryImpl sessionFactory;
 		private SessionOwner sessionOwner;
 		private Interceptor interceptor;
 		private Connection connection;
 		private ConnectionReleaseMode connectionReleaseMode;
 		private boolean autoClose;
 		private boolean autoJoinTransactions = true;
 		private boolean flushBeforeCompletion;
 		private String tenantIdentifier;
 		private List<SessionEventListener> listeners;
 
 		SessionBuilderImpl(SessionFactoryImpl sessionFactory) {
 			this.sessionFactory = sessionFactory;
 			this.sessionOwner = null;
 			final Settings settings = sessionFactory.settings;
 
 			// set up default builder values...
 			this.interceptor = sessionFactory.getInterceptor();
 			this.connectionReleaseMode = settings.getConnectionReleaseMode();
 			this.autoClose = settings.isAutoCloseSessionEnabled();
 			this.flushBeforeCompletion = settings.isFlushBeforeCompletionEnabled();
 
 			if ( sessionFactory.getCurrentTenantIdentifierResolver() != null ) {
 				tenantIdentifier = sessionFactory.getCurrentTenantIdentifierResolver().resolveCurrentTenantIdentifier();
 			}
 
 			listeners = settings.getBaselineSessionEventsListenerBuilder().buildBaselineList();
 		}
 
 		protected TransactionCoordinatorImpl getTransactionCoordinator() {
 			return null;
 		}
 
 		protected ActionQueue.TransactionCompletionProcesses getTransactionCompletionProcesses() {
 			return null;
 		}
 
 		@Override
 		public Session openSession() {
 			log.tracef( "Opening Hibernate Session.  tenant=%s, owner=%s", tenantIdentifier, sessionOwner );
 			final SessionImpl session = new SessionImpl(
 					connection,
 					sessionFactory,
 					sessionOwner,
 					getTransactionCoordinator(),
 					getTransactionCompletionProcesses(),
 					autoJoinTransactions,
 					sessionFactory.settings.getRegionFactory().nextTimestamp(),
 					interceptor,
 					flushBeforeCompletion,
 					autoClose,
 					connectionReleaseMode,
 					tenantIdentifier
 			);
 
 			for ( SessionEventListener listener : listeners ) {
 				session.getEventListenerManager().addListener( listener );
 			}
 
 			return session;
 		}
 
 		@Override
 		public SessionBuilder owner(SessionOwner sessionOwner) {
 			this.sessionOwner = sessionOwner;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder interceptor(Interceptor interceptor) {
 			this.interceptor = interceptor;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder noInterceptor() {
 			this.interceptor = EmptyInterceptor.INSTANCE;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder connection(Connection connection) {
 			this.connection = connection;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder connectionReleaseMode(ConnectionReleaseMode connectionReleaseMode) {
 			this.connectionReleaseMode = connectionReleaseMode;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder autoJoinTransactions(boolean autoJoinTransactions) {
 			this.autoJoinTransactions = autoJoinTransactions;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder autoClose(boolean autoClose) {
 			this.autoClose = autoClose;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder flushBeforeCompletion(boolean flushBeforeCompletion) {
 			this.flushBeforeCompletion = flushBeforeCompletion;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder tenantIdentifier(String tenantIdentifier) {
 			this.tenantIdentifier = tenantIdentifier;
 			return this;
 		}
 
 		@Override
 		public SessionBuilder eventListeners(SessionEventListener... listeners) {
 			Collections.addAll( this.listeners, listeners );
 			return this;
 		}
 
 		@Override
 		public SessionBuilder clearEventListeners() {
 			listeners.clear();
 			return this;
 		}
 	}
 
 	public static class StatelessSessionBuilderImpl implements StatelessSessionBuilder {
 		private final SessionFactoryImpl sessionFactory;
 		private Connection connection;
 		private String tenantIdentifier;
 
 		public StatelessSessionBuilderImpl(SessionFactoryImpl sessionFactory) {
 			this.sessionFactory = sessionFactory;
 
 			if ( sessionFactory.getCurrentTenantIdentifierResolver() != null ) {
 				tenantIdentifier = sessionFactory.getCurrentTenantIdentifierResolver().resolveCurrentTenantIdentifier();
 			}
 		}
 
 		@Override
 		public StatelessSession openStatelessSession() {
 			return new StatelessSessionImpl( connection, tenantIdentifier, sessionFactory,
 					sessionFactory.settings.getRegionFactory().nextTimestamp() );
 		}
 
 		@Override
 		public StatelessSessionBuilder connection(Connection connection) {
 			this.connection = connection;
 			return this;
 		}
 
 		@Override
 		public StatelessSessionBuilder tenantIdentifier(String tenantIdentifier) {
 			this.tenantIdentifier = tenantIdentifier;
 			return this;
 		}
 	}
 
 	@Override
 	public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy() {
 		return customEntityDirtinessStrategy;
 	}
 
 	@Override
 	public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver() {
 		return currentTenantIdentifierResolver;
 	}
 
 
 	// Serialization handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Custom serialization hook defined by Java spec.  Used when the factory is directly serialized
 	 *
 	 * @param out The stream into which the object is being serialized.
 	 *
 	 * @throws IOException Can be thrown by the stream
 	 */
 	private void writeObject(ObjectOutputStream out) throws IOException {
 		LOG.debugf( "Serializing: %s", uuid );
 		out.defaultWriteObject();
 		LOG.trace( "Serialized" );
 	}
 
 	/**
 	 * Custom serialization hook defined by Java spec.  Used when the factory is directly deserialized
 	 *
 	 * @param in The stream from which the object is being deserialized.
 	 *
 	 * @throws IOException Can be thrown by the stream
 	 * @throws ClassNotFoundException Again, can be thrown by the stream
 	 */
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 		LOG.trace( "Deserializing" );
 		in.defaultReadObject();
 		LOG.debugf( "Deserialized: %s", uuid );
 	}
 
 	/**
 	 * Custom serialization hook defined by Java spec.  Used when the factory is directly deserialized.
 	 * Here we resolve the uuid/name read from the stream previously to resolve the SessionFactory
 	 * instance to use based on the registrations with the {@link SessionFactoryRegistry}
 	 *
 	 * @return The resolved factory to use.
 	 *
 	 * @throws InvalidObjectException Thrown if we could not resolve the factory by uuid/name.
 	 */
 	private Object readResolve() throws InvalidObjectException {
 		LOG.trace( "Resolving serialized SessionFactory" );
 		return locateSessionFactoryOnDeserialization( uuid, name );
 	}
 
 	private static SessionFactory locateSessionFactoryOnDeserialization(String uuid, String name) throws InvalidObjectException{
 		final SessionFactory uuidResult = SessionFactoryRegistry.INSTANCE.getSessionFactory( uuid );
 		if ( uuidResult != null ) {
 			LOG.debugf( "Resolved SessionFactory by UUID [%s]", uuid );
 			return uuidResult;
 		}
 
 		// in case we were deserialized in a different JVM, look for an instance with the same name
 		// (provided we were given a name)
 		if ( name != null ) {
 			final SessionFactory namedResult = SessionFactoryRegistry.INSTANCE.getNamedSessionFactory( name );
 			if ( namedResult != null ) {
 				LOG.debugf( "Resolved SessionFactory by name [%s]", name );
 				return namedResult;
 			}
 		}
 
 		throw new InvalidObjectException( "Could not find a SessionFactory [uuid=" + uuid + ",name=" + name + "]" );
 	}
 
 	/**
 	 * Custom serialization hook used during Session serialization.
 	 *
 	 * @param oos The stream to which to write the factory
 	 * @throws IOException Indicates problems writing out the serial data stream
 	 */
 	void serialize(ObjectOutputStream oos) throws IOException {
 		oos.writeUTF( uuid );
 		oos.writeBoolean( name != null );
 		if ( name != null ) {
 			oos.writeUTF( name );
 		}
 	}
 
 	/**
 	 * Custom deserialization hook used during Session deserialization.
 	 *
 	 * @param ois The stream from which to "read" the factory
 	 * @return The deserialized factory
 	 * @throws IOException indicates problems reading back serial data stream
 	 * @throws ClassNotFoundException indicates problems reading back serial data stream
 	 */
 	static SessionFactoryImpl deserialize(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		LOG.trace( "Deserializing SessionFactory from Session" );
 		final String uuid = ois.readUTF();
 		boolean isNamed = ois.readBoolean();
 		final String name = isNamed ? ois.readUTF() : null;
 		return (SessionFactoryImpl) locateSessionFactoryOnDeserialization( uuid, name );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XsdException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java
rename to hibernate-core/src/main/java/org/hibernate/internal/util/xml/XsdException.java
index fac0104bf9..57dab8a019 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/xml/XsdException.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.source;
+package org.hibernate.internal.util.xml;
 
 import org.hibernate.HibernateException;
 
 /**
  * Indicates an issue finding or loading an XSD schema.
  * 
  * @author Steve Ebersole
  */
 public class XsdException extends HibernateException {
 	private final String xsdName;
 
 	public XsdException(String message, String xsdName) {
 		super( message );
 		this.xsdName = xsdName;
 	}
 
 	public XsdException(String message, Throwable root, String xsdName) {
 		super( message, root );
 		this.xsdName = xsdName;
 	}
 
 	public String getXsdName() {
 		return xsdName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/Metadata.java b/hibernate-core/src/main/java/org/hibernate/metamodel/Metadata.java
deleted file mode 100644
index ce58902d7d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/Metadata.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel;
-
-import java.util.Map;
-import javax.persistence.SharedCacheMode;
-
-import org.hibernate.SessionFactory;
-import org.hibernate.boot.registry.StandardServiceRegistry;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.engine.ResultSetMappingDefinition;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.engine.spi.NamedQueryDefinition;
-import org.hibernate.engine.spi.NamedSQLQueryDefinition;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.binding.TypeDef;
-
-/**
- * @author Steve Ebersole
- */
-public interface Metadata {
-	/**
-	 * Exposes the options used to produce a {@link Metadata} instance.
-	 */
-	public static interface Options {
-		public StandardServiceRegistry getServiceRegistry();
-
-		public MetadataSourceProcessingOrder getMetadataSourceProcessingOrder();
-		public NamingStrategy getNamingStrategy();
-		public SharedCacheMode getSharedCacheMode();
-		public AccessType getDefaultAccessType();
-		public boolean useNewIdentifierGenerators();
-        public boolean isGloballyQuotedIdentifiers();
-		public String getDefaultSchemaName();
-		public String getDefaultCatalogName();
-	}
-
-	public Options getOptions();
-
-	public SessionFactoryBuilder getSessionFactoryBuilder();
-
-	public SessionFactory buildSessionFactory();
-
-	public Iterable<EntityBinding> getEntityBindings();
-
-	public EntityBinding getEntityBinding(String entityName);
-
-	/**
-	 * Get the "root" entity binding
-	 * @param entityName
-	 * @return the "root entity binding; simply returns entityBinding if it is the root entity binding
-	 */
-	public EntityBinding getRootEntityBinding(String entityName);
-
-	public Iterable<PluralAttributeBinding> getCollectionBindings();
-
-	public TypeDef getTypeDefinition(String name);
-
-	public Iterable<TypeDef> getTypeDefinitions();
-
-	public Iterable<FilterDefinition> getFilterDefinitions();
-
-	public Iterable<NamedQueryDefinition> getNamedQueryDefinitions();
-
-	public Iterable<NamedSQLQueryDefinition> getNamedNativeQueryDefinitions();
-
-	public Iterable<ResultSetMappingDefinition> getResultSetMappingDefinitions();
-
-	public Iterable<Map.Entry<String, String>> getImports();
-
-	public Iterable<FetchProfile> getFetchProfiles();
-
-	public IdGenerator getIdGenerator(String name);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataBuilder.java
deleted file mode 100644
index 1295a80923..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataBuilder.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel;
-
-import javax.persistence.SharedCacheMode;
-
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.cfg.NamingStrategy;
-
-/**
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public interface MetadataBuilder {
-	public MetadataBuilder with(NamingStrategy namingStrategy);
-
-	public MetadataBuilder with(MetadataSourceProcessingOrder metadataSourceProcessingOrder);
-
-	public MetadataBuilder with(SharedCacheMode cacheMode);
-
-	public MetadataBuilder with(AccessType accessType);
-
-	public MetadataBuilder withNewIdentifierGeneratorsEnabled(boolean enabled);
-
-	public Metadata build();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSourceProcessingOrder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSourceProcessingOrder.java
deleted file mode 100644
index 5a099c6f05..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSourceProcessingOrder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel;
-
-/**
- * Enumeration of the possible orders for processing metadata sources.  The implication is in terms of precedence;
- * for duplicate information in different sources, whichever is processed first has precedence.
- *
- * @author Steve Ebersole
- */
-public enum MetadataSourceProcessingOrder {
-	ANNOTATIONS_FIRST,
-	HBM_FIRST
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
deleted file mode 100644
index 01c2dbd63f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
+++ /dev/null
@@ -1,425 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.jar.JarFile;
-import java.util.zip.ZipEntry;
-
-import org.hibernate.boot.registry.BootstrapServiceRegistry;
-import org.hibernate.boot.registry.StandardServiceRegistry;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.EJB3DTDEntityResolver;
-import org.hibernate.cfg.EJB3NamingStrategy;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.SourceType;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.MappingNotFoundException;
-import org.hibernate.metamodel.source.internal.JaxbHelper;
-import org.hibernate.metamodel.source.internal.MetadataBuilderImpl;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.logging.Logger;
-
-import org.w3c.dom.Document;
-import org.xml.sax.EntityResolver;
-
-/**
- * @author Steve Ebersole
- */
-public class MetadataSources {
-	private static final Logger LOG = Logger.getLogger( MetadataSources.class );
-
-	private final ServiceRegistry serviceRegistry;
-	
-	private List<JaxbRoot> jaxbRootList = new ArrayList<JaxbRoot>();
-	private LinkedHashSet<Class<?>> annotatedClasses = new LinkedHashSet<Class<?>>();
-	private LinkedHashSet<String> annotatedPackages = new LinkedHashSet<String>();
-
-	private final JaxbHelper jaxbHelper;
-
-	private final EntityResolver entityResolver;
-	private final NamingStrategy namingStrategy;
-
-	private final MetadataBuilderImpl metadataBuilder;
-
-	public MetadataSources(ServiceRegistry serviceRegistry) {
-		this( serviceRegistry, EJB3DTDEntityResolver.INSTANCE, EJB3NamingStrategy.INSTANCE );
-	}
-
-	public MetadataSources(ServiceRegistry serviceRegistry, EntityResolver entityResolver, NamingStrategy namingStrategy) {
-		this.serviceRegistry = serviceRegistry;
-		this.entityResolver = entityResolver;
-		this.namingStrategy = namingStrategy;
-
-		this.jaxbHelper = new JaxbHelper( this );
-		this.metadataBuilder = new MetadataBuilderImpl( this );
-		
-		// service registry really should be either BootstrapServiceRegistry or StandardServiceRegistry type...
-		if ( ! isExpectedServiceRegistryType( serviceRegistry ) ) {
-			LOG.debugf(
-					"Unexpected ServiceRegistry type [%s] encountered during building of MetadataSources; may cause " +
-							"problems later attempting to construct MetadataBuilder",
-					serviceRegistry.getClass().getName()
-			);
-		}
-	}
-
-	protected static boolean isExpectedServiceRegistryType(ServiceRegistry serviceRegistry) {
-		return BootstrapServiceRegistry.class.isInstance( serviceRegistry )
-				|| StandardServiceRegistry.class.isInstance( serviceRegistry );
-	}
-
-	public List<JaxbRoot> getJaxbRootList() {
-		return jaxbRootList;
-	}
-
-	public Iterable<String> getAnnotatedPackages() {
-		return annotatedPackages;
-	}
-
-	public Iterable<Class<?>> getAnnotatedClasses() {
-		return annotatedClasses;
-	}
-
-	public ServiceRegistry getServiceRegistry() {
-		return serviceRegistry;
-	}
-
-	public NamingStrategy getNamingStrategy() {
-		return namingStrategy;
-	}
-
-	/**
-	 * Get a builder for metadata where non-default options can be specified.
-	 *
-	 * @return The built metadata.
-	 */
-	public MetadataBuilder getMetadataBuilder() {
-		return new MetadataBuilderImpl( this );
-	}
-
-	/**
-	 * Get a builder for metadata where non-default options can be specified.
-	 *
-	 * @return The built metadata.
-	 */
-	public MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) {
-		return new MetadataBuilderImpl( this, serviceRegistry );
-	}
-
-	/**
-	 * Short-hand form of calling {@link #getMetadataBuilder()} and using its
-	 * {@link org.hibernate.metamodel.MetadataBuilder#build()} method in cases where the application wants
-	 * to accept the defaults.
-	 *
-	 * @return The built metadata.
-	 */
-	public Metadata buildMetadata() {
-		return getMetadataBuilder().build();
-	}
-
-	public Metadata buildMetadata(StandardServiceRegistry serviceRegistry) {
-		return getMetadataBuilder( serviceRegistry ).build();
-	}
-
-	/**
-	 * Read metadata from the annotations attached to the given class.
-	 *
-	 * @param annotatedClass The class containing annotations
-	 *
-	 * @return this (for method chaining)
-	 */
-	public MetadataSources addAnnotatedClass(Class annotatedClass) {
-		annotatedClasses.add( annotatedClass );
-		return this;
-	}
-
-	/**
-	 * Read package-level metadata.
-	 *
-	 * @param packageName java package name without trailing '.', cannot be {@code null}
-	 *
-	 * @return this (for method chaining)
-	 */
-	public MetadataSources addPackage(String packageName) {
-		if ( packageName == null ) {
-			throw new IllegalArgumentException( "The specified package name cannot be null" );
-		}
-		if ( packageName.endsWith( "." ) ) {
-			packageName = packageName.substring( 0, packageName.length() - 1 );
-		}
-		annotatedPackages.add( packageName );
-		return this;
-	}
-
-	/**
-	 * Read mappings as a application resourceName (i.e. classpath lookup).
-	 *
-	 * @param name The resource name
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addResource(String name) {
-		LOG.tracef( "reading mappings from resource : %s", name );
-
-		final Origin origin = new Origin( SourceType.RESOURCE, name );
-		InputStream resourceInputStream = classLoaderService().locateResourceStream( name );
-		if ( resourceInputStream == null ) {
-			throw new MappingNotFoundException( origin );
-		}
-		add( resourceInputStream, origin, true );
-
-		return this;
-	}
-
-	private ClassLoaderService classLoaderService() {
-		return serviceRegistry.getService( ClassLoaderService.class );
-	}
-
-	private JaxbRoot add(InputStream inputStream, Origin origin, boolean close) {
-		try {
-			JaxbRoot jaxbRoot = jaxbHelper.unmarshal( inputStream, origin );
-			jaxbRootList.add( jaxbRoot );
-			return jaxbRoot;
-		}
-		finally {
-			if ( close ) {
-				try {
-					inputStream.close();
-				}
-				catch ( IOException ignore ) {
-					LOG.trace( "Was unable to close input stream" );
-				}
-			}
-		}
-	}
-
-	/**
-	 * Read a mapping as an application resource using the convention that a class named {@code foo.bar.Foo} is
-	 * mapped by a file named {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
-	 *
-	 * @param entityClass The mapped class. Cannot be {@code null} null.
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addClass(Class entityClass) {
-		if ( entityClass == null ) {
-			throw new IllegalArgumentException( "The specified class cannot be null" );
-		}
-		LOG.debugf( "adding resource mappings from class convention : %s", entityClass.getName() );
-		final String mappingResourceName = entityClass.getName().replace( '.', '/' ) + ".hbm.xml";
-		addResource( mappingResourceName );
-		return this;
-	}
-
-	/**
-	 * Read mappings from a particular XML file
-	 *
-	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
-	 *
-	 * @return this (for method chaining purposes)
-	 *
-	 * @see #addFile(java.io.File)
-	 */
-	public MetadataSources addFile(String path) {
-		return addFile( new File( path ) );
-	}
-
-	/**
-	 * Read mappings from a particular XML file
-	 *
-	 * @param file The reference to the XML file
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addFile(File file) {
-		final String name = file.getAbsolutePath();
-		LOG.tracef( "reading mappings from file : %s", name );
-		final Origin origin = new Origin( SourceType.FILE, name );
-		try {
-			add( new FileInputStream( file ), origin, true );
-		}
-		catch ( FileNotFoundException e ) {
-			throw new MappingNotFoundException( e, origin );
-		}
-		return this;
-	}
-
-	/**
-	 * See {@link #addCacheableFile(java.io.File)} for description
-	 *
-	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
-	 *
-	 * @return this (for method chaining purposes)
-	 *
-	 * @see #addCacheableFile(java.io.File)
-	 */
-	public MetadataSources addCacheableFile(String path) {
-		return this; // todo : implement method body
-	}
-
-	/**
-	 * Add a cached mapping file.  A cached file is a serialized representation of the DOM structure of a
-	 * particular mapping.  It is saved from a previous call as a file with the name {@code {xmlFile}.bin}
-	 * where {@code {xmlFile}} is the name of the original mapping file.
-	 * </p>
-	 * If a cached {@code {xmlFile}.bin} exists and is newer than {@code {xmlFile}}, the {@code {xmlFile}.bin}
-	 * file will be read directly. Otherwise {@code {xmlFile}} is read and then serialized to {@code {xmlFile}.bin} for
-	 * use the next time.
-	 *
-	 * @param file The cacheable mapping file to be added, {@code {xmlFile}} in above discussion.
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addCacheableFile(File file) {
-		return this; // todo : implement method body
-	}
-
-	/**
-	 * Read metadata from an {@link InputStream}.
-	 *
-	 * @param xmlInputStream The input stream containing a DOM.
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addInputStream(InputStream xmlInputStream) {
-		add( xmlInputStream, new Origin( SourceType.INPUT_STREAM, "<unknown>" ), false );
-		return this;
-	}
-
-	/**
-	 * Read mappings from a {@link URL}
-	 *
-	 * @param url The url for the mapping document to be read.
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addURL(URL url) {
-		final String urlExternalForm = url.toExternalForm();
-		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
-
-		final Origin origin = new Origin( SourceType.URL, urlExternalForm );
-		try {
-			add( url.openStream(), origin, true );
-		}
-		catch ( IOException e ) {
-			throw new MappingNotFoundException( "Unable to open url stream [" + urlExternalForm + "]", e, origin );
-		}
-		return this;
-	}
-
-	/**
-	 * Read mappings from a DOM {@link Document}
-	 *
-	 * @param document The DOM document
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addDocument(Document document) {
-		final Origin origin = new Origin( SourceType.DOM, "<unknown>" );
-		JaxbRoot jaxbRoot = jaxbHelper.unmarshal( document, origin );
-		jaxbRootList.add( jaxbRoot );
-		return this;
-	}
-
-	/**
-	 * Read all mappings from a jar file.
-	 * <p/>
-	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
-	 *
-	 * @param jar a jar file
-	 *
-	 * @return this (for method chaining purposes)
-	 */
-	public MetadataSources addJar(File jar) {
-		LOG.debugf( "Seeking mapping documents in jar file : %s", jar.getName() );
-		final Origin origin = new Origin( SourceType.JAR, jar.getAbsolutePath() );
-		try {
-			JarFile jarFile = new JarFile( jar );
-			try {
-				Enumeration jarEntries = jarFile.entries();
-				while ( jarEntries.hasMoreElements() ) {
-					final ZipEntry zipEntry = (ZipEntry) jarEntries.nextElement();
-					if ( zipEntry.getName().endsWith( ".hbm.xml" ) ) {
-						LOG.tracef( "found mapping document : %s", zipEntry.getName() );
-						try {
-							add( jarFile.getInputStream( zipEntry ), origin, true );
-						}
-						catch ( Exception e ) {
-							throw new MappingException( "could not read mapping documents", e, origin );
-						}
-					}
-				}
-			}
-			finally {
-				try {
-					jarFile.close();
-				}
-				catch ( Exception ignore ) {
-				}
-			}
-		}
-		catch ( IOException e ) {
-			throw new MappingNotFoundException( e, origin );
-		}
-		return this;
-	}
-
-	/**
-	 * Read all mapping documents from a directory tree.
-	 * <p/>
-	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
-	 *
-	 * @param dir The directory
-	 *
-	 * @return this (for method chaining purposes)
-	 *
-	 * @throws org.hibernate.MappingException Indicates problems reading the jar file or
-	 * processing the contained mapping documents.
-	 */
-	public MetadataSources addDirectory(File dir) {
-		File[] files = dir.listFiles();
-		for ( File file : files ) {
-			if ( file.isDirectory() ) {
-				addDirectory( file );
-			}
-			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
-				addFile( file );
-			}
-		}
-		return this;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/SessionFactoryBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/SessionFactoryBuilder.java
deleted file mode 100644
index c3cb204e36..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/SessionFactoryBuilder.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel;
-
-import org.hibernate.Interceptor;
-import org.hibernate.SessionFactory;
-import org.hibernate.proxy.EntityNotFoundDelegate;
-
-/**
- * @author Gail Badner
- */
-public interface SessionFactoryBuilder {
-	public SessionFactoryBuilder with(Interceptor interceptor);
-
-	public SessionFactoryBuilder with(EntityNotFoundDelegate entityNotFoundDelegate);
-
-	/**
-	 * After all options have been set, build the SessionFactory.
-	 *
-	 * @return The built SessionFactory.
-	 */
-	public SessionFactory build();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/ValidationException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/ValidationException.java
deleted file mode 100644
index e391706562..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/ValidationException.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel;
-
-import org.hibernate.HibernateException;
-
-/**
- * Indicates a problem validating the metamodel.
- *
- * @author Steve Ebersole
- */
-public class ValidationException extends HibernateException {
-	public ValidationException(String s) {
-		super( s );
-	}
-
-	public ValidationException(String string, Throwable root) {
-		super( string, root );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java
deleted file mode 100644
index 4ae33f270a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.hibernate.metamodel.domain.Attribute;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * Basic support for {@link AttributeBinding} implementors
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractAttributeBinding implements AttributeBinding {
-	private final AttributeBindingContainer container;
-	private final Attribute attribute;
-
-	private final HibernateTypeDescriptor hibernateTypeDescriptor = new HibernateTypeDescriptor();
-	private final Set<SingularAssociationAttributeBinding> entityReferencingAttributeBindings = new HashSet<SingularAssociationAttributeBinding>();
-
-	private boolean includedInOptimisticLocking;
-
-	private boolean isLazy;
-	private String propertyAccessorName;
-	private boolean isAlternateUniqueKey;
-
-	private MetaAttributeContext metaAttributeContext;
-
-	protected AbstractAttributeBinding(AttributeBindingContainer container, Attribute attribute) {
-		this.container = container;
-		this.attribute = attribute;
-	}
-
-	@Override
-	public AttributeBindingContainer getContainer() {
-		return container;
-	}
-
-	@Override
-	public Attribute getAttribute() {
-		return attribute;
-	}
-
-	@Override
-	public HibernateTypeDescriptor getHibernateTypeDescriptor() {
-		return hibernateTypeDescriptor;
-	}
-
-	@Override
-	public boolean isBasicPropertyAccessor() {
-		return propertyAccessorName == null || "property".equals( propertyAccessorName );
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return propertyAccessorName;
-	}
-
-	public void setPropertyAccessorName(String propertyAccessorName) {
-		this.propertyAccessorName = propertyAccessorName;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return includedInOptimisticLocking;
-	}
-
-	public void setIncludedInOptimisticLocking(boolean includedInOptimisticLocking) {
-		this.includedInOptimisticLocking = includedInOptimisticLocking;
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		return metaAttributeContext;
-	}
-
-	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
-		this.metaAttributeContext = metaAttributeContext;
-	}
-
-	@Override
-	public boolean isAlternateUniqueKey() {
-		return isAlternateUniqueKey;
-	}
-
-	public void setAlternateUniqueKey(boolean alternateUniqueKey) {
-		this.isAlternateUniqueKey = alternateUniqueKey;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return isLazy;
-	}
-
-	public void setLazy(boolean isLazy) {
-		this.isLazy = isLazy;
-	}
-
-	public void addEntityReferencingAttributeBinding(SingularAssociationAttributeBinding referencingAttributeBinding) {
-		entityReferencingAttributeBindings.add( referencingAttributeBinding );
-	}
-
-	public Set<SingularAssociationAttributeBinding> getEntityReferencingAttributeBindings() {
-		return Collections.unmodifiableSet( entityReferencingAttributeBindings );
-	}
-
-	public void validate() {
-		if ( !entityReferencingAttributeBindings.isEmpty() ) {
-			// TODO; validate that this AttributeBinding can be a target of an entity reference
-			// (e.g., this attribute is the primary key or there is a unique-key)
-			// can a unique attribute be used as a target? if so, does it need to be non-null?
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractCollectionElement.java
deleted file mode 100644
index 1b922133cf..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractCollectionElement.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.relational.Value;
-
-/**
- * Basic contract describing the commonality between the various types of collection element mappings.
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractCollectionElement {
-	private final AbstractPluralAttributeBinding collectionBinding;
-
-	private Value elementValue;
-
-	AbstractCollectionElement(AbstractPluralAttributeBinding collectionBinding) {
-		this.collectionBinding = collectionBinding;
-	}
-
-	public abstract CollectionElementNature getCollectionElementNature();
-
-	public AbstractPluralAttributeBinding getCollectionBinding() {
-		return collectionBinding;
-	}
-
-	public Value getElementValue() {
-		return elementValue;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractPluralAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractPluralAttributeBinding.java
deleted file mode 100644
index b80066a8a0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractPluralAttributeBinding.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.relational.TableSpecification;
-import org.hibernate.persister.collection.CollectionPersister;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractPluralAttributeBinding extends AbstractAttributeBinding implements PluralAttributeBinding {
-	private final CollectionKey collectionKey;
-	private final AbstractCollectionElement collectionElement;
-
-	private Table collectionTable;
-
-	private FetchTiming fetchTiming;
-	private FetchStyle fetchStyle;
-	private int batchSize = -1;
-
-	private CascadeStyle cascadeStyle;
-	private boolean orphanDelete;
-
-	private Caching caching;
-
-	private boolean inverse;
-	private boolean mutable = true;
-
-	private Class<? extends CollectionPersister> collectionPersisterClass;
-
-	private String where;
-	private String orderBy;
-	private boolean sorted;
-	private Comparator comparator;
-	private String comparatorClassName;
-
-	private String customLoaderName;
-	private CustomSQL customSqlInsert;
-	private CustomSQL customSqlUpdate;
-	private CustomSQL customSqlDelete;
-	private CustomSQL customSqlDeleteAll;
-
-	private String referencedPropertyName;
-
-	private final java.util.Map filters = new HashMap();
-	private final java.util.Set<String> synchronizedTables = new HashSet<String>();
-
-	protected AbstractPluralAttributeBinding(
-			AttributeBindingContainer container,
-			PluralAttribute attribute,
-			CollectionElementNature collectionElementNature) {
-		super( container, attribute );
-		this.collectionKey = new CollectionKey( this );
-		this.collectionElement = interpretNature( collectionElementNature );
-	}
-
-	private AbstractCollectionElement interpretNature(CollectionElementNature collectionElementNature) {
-		switch ( collectionElementNature ) {
-			case BASIC: {
-				return new BasicCollectionElement( this );
-			}
-			case COMPOSITE: {
-				return new CompositeCollectionElement( this );
-			}
-			case ONE_TO_MANY: {
-				return new OneToManyCollectionElement( this );
-			}
-			case MANY_TO_MANY: {
-				return new ManyToManyCollectionElement( this );
-			}
-			case MANY_TO_ANY: {
-				return new ManyToAnyCollectionElement( this );
-			}
-			default: {
-				throw new AssertionFailure( "Unknown collection element nature : " + collectionElementNature );
-			}
-		}
-	}
-
-//	protected void initializeBinding(PluralAttributeBindingState state) {
-//		super.initialize( state );
-//		fetchMode = state.getFetchMode();
-//		extraLazy = state.isExtraLazy();
-//		collectionElement.setNodeName( state.getElementNodeName() );
-//		collectionElement.setTypeName( state.getElementTypeName() );
-//		inverse = state.isInverse();
-//		mutable = state.isMutable();
-//		subselectLoadable = state.isSubselectLoadable();
-//		if ( isSubselectLoadable() ) {
-//			getEntityBinding().setSubselectLoadableCollections( true );
-//		}
-//		cacheConcurrencyStrategy = state.getCacheConcurrencyStrategy();
-//		cacheRegionName = state.getCacheRegionName();
-//		orderBy = state.getOrderBy();
-//		where = state.getWhere();
-//		referencedPropertyName = state.getReferencedPropertyName();
-//		sorted = state.isSorted();
-//		comparator = state.getComparator();
-//		comparatorClassName = state.getComparatorClassName();
-//		orphanDelete = state.isOrphanDelete();
-//		batchSize = state.getBatchSize();
-//		embedded = state.isEmbedded();
-//		optimisticLocked = state.isOptimisticLocked();
-//		collectionPersisterClass = state.getCollectionPersisterClass();
-//		filters.putAll( state.getFilters() );
-//		synchronizedTables.addAll( state.getSynchronizedTables() );
-//		customSQLInsert = state.getCustomSQLInsert();
-//		customSQLUpdate = state.getCustomSQLUpdate();
-//		customSQLDelete = state.getCustomSQLDelete();
-//		customSQLDeleteAll = state.getCustomSQLDeleteAll();
-//		loaderName = state.getLoaderName();
-//	}
-
-	@Override
-	public PluralAttribute getAttribute() {
-		return (PluralAttribute) super.getAttribute();
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return collectionElement.getCollectionElementNature() == CollectionElementNature.MANY_TO_ANY
-				|| collectionElement.getCollectionElementNature() == CollectionElementNature.MANY_TO_MANY
-				|| collectionElement.getCollectionElementNature() == CollectionElementNature.ONE_TO_MANY;
-	}
-
-	@Override
-	public TableSpecification getCollectionTable() {
-		return collectionTable;
-	}
-
-	public void setCollectionTable(Table collectionTable) {
-		this.collectionTable = collectionTable;
-	}
-
-	@Override
-	public CollectionKey getCollectionKey() {
-		return collectionKey;
-	}
-
-	@Override
-	public AbstractCollectionElement getCollectionElement() {
-		return collectionElement;
-	}
-
-	@Override
-	public CascadeStyle getCascadeStyle() {
-		return cascadeStyle;
-	}
-
-	@Override
-	public void setCascadeStyles(Iterable<CascadeStyle> cascadeStyles) {
-		List<CascadeStyle> cascadeStyleList = new ArrayList<CascadeStyle>();
-		for ( CascadeStyle style : cascadeStyles ) {
-			if ( style != CascadeStyles.NONE ) {
-				cascadeStyleList.add( style );
-			}
-			if ( style == CascadeStyles.DELETE_ORPHAN ||
-					style == CascadeStyles.ALL_DELETE_ORPHAN ) {
-				orphanDelete = true;
-			}
-		}
-
-		if ( cascadeStyleList.isEmpty() ) {
-			cascadeStyle = CascadeStyles.NONE;
-		}
-		else if ( cascadeStyleList.size() == 1 ) {
-			cascadeStyle = cascadeStyleList.get( 0 );
-		}
-		else {
-			cascadeStyle = new CascadeStyles.MultipleCascadeStyle(
-					cascadeStyleList.toArray( new CascadeStyle[ cascadeStyleList.size() ] )
-			);
-		}
-	}
-
-	@Override
-	public boolean isOrphanDelete() {
-		return orphanDelete;
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		if ( getFetchStyle() == FetchStyle.JOIN ) {
-			return FetchMode.JOIN;
-		}
-		else {
-			return FetchMode.SELECT;
-		}
-	}
-
-	@Override
-	public FetchTiming getFetchTiming() {
-		return fetchTiming;
-	}
-
-	@Override
-	public void setFetchTiming(FetchTiming fetchTiming) {
-		this.fetchTiming = fetchTiming;
-	}
-
-	@Override
-	public FetchStyle getFetchStyle() {
-		return fetchStyle;
-	}
-
-	@Override
-	public void setFetchStyle(FetchStyle fetchStyle) {
-		this.fetchStyle = fetchStyle;
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return customLoaderName;
-	}
-
-	public void setCustomLoaderName(String customLoaderName) {
-		this.customLoaderName = customLoaderName;
-	}
-
-	@Override
-	public CustomSQL getCustomSqlInsert() {
-		return customSqlInsert;
-	}
-
-	public void setCustomSqlInsert(CustomSQL customSqlInsert) {
-		this.customSqlInsert = customSqlInsert;
-	}
-
-	@Override
-	public CustomSQL getCustomSqlUpdate() {
-		return customSqlUpdate;
-	}
-
-	public void setCustomSqlUpdate(CustomSQL customSqlUpdate) {
-		this.customSqlUpdate = customSqlUpdate;
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDelete() {
-		return customSqlDelete;
-	}
-
-	public void setCustomSqlDelete(CustomSQL customSqlDelete) {
-		this.customSqlDelete = customSqlDelete;
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDeleteAll() {
-		return customSqlDeleteAll;
-	}
-
-	public void setCustomSqlDeleteAll(CustomSQL customSqlDeleteAll) {
-		this.customSqlDeleteAll = customSqlDeleteAll;
-	}
-
-	public Class<? extends CollectionPersister> getCollectionPersisterClass() {
-		return collectionPersisterClass;
-	}
-
-	public void setCollectionPersisterClass(Class<? extends CollectionPersister> collectionPersisterClass) {
-		this.collectionPersisterClass = collectionPersisterClass;
-	}
-
-	public Caching getCaching() {
-		return caching;
-	}
-
-	public void setCaching(Caching caching) {
-		this.caching = caching;
-	}
-
-	@Override
-	public String getOrderBy() {
-		return orderBy;
-	}
-
-	public void setOrderBy(String orderBy) {
-		this.orderBy = orderBy;
-	}
-
-	@Override
-	public String getWhere() {
-		return where;
-	}
-
-	public void setWhere(String where) {
-		this.where = where;
-	}
-
-	@Override
-	public boolean isInverse() {
-		return inverse;
-	}
-
-	public void setInverse(boolean inverse) {
-		this.inverse = inverse;
-	}
-
-	@Override
-	public boolean isMutable() {
-		return mutable;
-	}
-
-	public void setMutable(boolean mutable) {
-		this.mutable = mutable;
-	}
-
-	@Override
-	public int getBatchSize() {
-		return batchSize;
-	}
-
-	public void setBatchSize(int batchSize) {
-		this.batchSize = batchSize;
-	}
-
-
-
-
-
-
-
-
-
-
-
-	public String getReferencedPropertyName() {
-		return referencedPropertyName;
-	}
-
-	@Override
-	public boolean isSorted() {
-		return sorted;
-	}
-
-	@Override
-	public Comparator getComparator() {
-		return comparator;
-	}
-
-	public void setComparator(Comparator comparator) {
-		this.comparator = comparator;
-	}
-
-	public String getComparatorClassName() {
-		return comparatorClassName;
-	}
-
-	public void addFilter(String name, String condition) {
-		filters.put( name, condition );
-	}
-
-	@Override
-	public java.util.Map getFilterMap() {
-		return filters;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractSingularAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractSingularAttributeBinding.java
deleted file mode 100644
index ef7fb1fded..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractSingularAttributeBinding.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.Tuple;
-import org.hibernate.metamodel.relational.Value;
-
-/**
- * @author Steve Ebersole
- */
-public abstract class AbstractSingularAttributeBinding
-		extends AbstractAttributeBinding
-		implements SingularAttributeBinding {
-
-	private Value value;
-	private List<SimpleValueBinding> simpleValueBindings = new ArrayList<SimpleValueBinding>();
-
-	private boolean hasDerivedValue;
-	private boolean isNullable = true;
-
-	protected AbstractSingularAttributeBinding(AttributeBindingContainer container, SingularAttribute attribute) {
-		super( container, attribute );
-	}
-
-	@Override
-	public SingularAttribute getAttribute() {
-		return (SingularAttribute) super.getAttribute();
-	}
-
-	public Value getValue() {
-		return value;
-	}
-
-	public void setSimpleValueBindings(Iterable<SimpleValueBinding> simpleValueBindings) {
-		List<SimpleValue> values = new ArrayList<SimpleValue>();
-		for ( SimpleValueBinding simpleValueBinding : simpleValueBindings ) {
-			this.simpleValueBindings.add( simpleValueBinding );
-			values.add( simpleValueBinding.getSimpleValue() );
-			this.hasDerivedValue = this.hasDerivedValue || simpleValueBinding.isDerived();
-			this.isNullable = this.isNullable && simpleValueBinding.isNullable();
-		}
-		if ( values.size() == 1 ) {
-			this.value = values.get( 0 );
-		}
-		else {
-			final Tuple tuple = values.get( 0 ).getTable().createTuple( getRole() );
-			for ( SimpleValue value : values ) {
-				tuple.addValue( value );
-			}
-			this.value = tuple;
-		}
-	}
-
-	private String getRole() {
-		return getContainer().getPathBase() + '.' + getAttribute().getName();
-	}
-
-	@Override
-	public int getSimpleValueSpan() {
-		checkValueBinding();
-		return simpleValueBindings.size();
-	}
-
-	protected void checkValueBinding() {
-		if ( value == null ) {
-			throw new AssertionFailure( "No values yet bound!" );
-		}
-	}
-
-	@Override
-	public Iterable<SimpleValueBinding> getSimpleValueBindings() {
-		return simpleValueBindings;
-	}
-
-	@Override
-	public boolean hasDerivedValue() {
-		checkValueBinding();
-		return hasDerivedValue;
-	}
-
-	@Override
-	public boolean isNullable() {
-		checkValueBinding();
-		return isNullable;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AssociationAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AssociationAttributeBinding.java
deleted file mode 100644
index 3224be343e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AssociationAttributeBinding.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-
-/**
- * Contract describing a binding for attributes which model associations.
- *
- * @author Steve Ebersole
- */
-public interface AssociationAttributeBinding extends AttributeBinding {
-	/**
-	 * Obtain the cascade style in effect for this association.
-	 *
-	 * @return The (potentially aggregated) cascade style.
-	 */
-	public CascadeStyle getCascadeStyle();
-
-	/**
-	 * Set the cascade styles in effect for this association.
-	 *
-	 * @param cascadeStyles The cascade styles.
-	 */
-	public void setCascadeStyles(Iterable<CascadeStyle> cascadeStyles);
-
-	public FetchTiming getFetchTiming();
-	public void setFetchTiming(FetchTiming fetchTiming);
-
-	public FetchStyle getFetchStyle();
-	public void setFetchStyle(FetchStyle fetchStyle);
-
-
-	/**
-	 * Temporary.  Needed for integration with legacy org.hibernate.mapping configuration of persisters.
-	 *
-	 * @deprecated
-	 */
-	@Deprecated
-	@SuppressWarnings( {"JavaDoc"})
-	public FetchMode getFetchMode();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java
deleted file mode 100644
index 5d317cc01e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Set;
-
-import org.hibernate.metamodel.domain.Attribute;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * The basic contract for binding a {@link #getAttribute() attribute} from the domain model to the relational model.
- *
- * @author Steve Ebersole
- */
-public interface AttributeBinding {
-	/**
-	 * Obtain the entity binding to which this attribute binding exists.
-	 *
-	 * @return The entity binding.
-	 */
-	public AttributeBindingContainer getContainer();
-
-	/**
-	 * Obtain the attribute bound.
-	 *
-	 * @return The attribute.
-	 */
-	public Attribute getAttribute();
-
-	/**
-	 * Obtain the descriptor for the Hibernate {@link org.hibernate.type.Type} for this binding.
-	 * <p/>
-	 * For information about the Java type, query the {@link Attribute} obtained from {@link #getAttribute()}
-	 * instead.
-	 *
-	 * @return The type descriptor
-	 */
-	public HibernateTypeDescriptor getHibernateTypeDescriptor();
-
-	public boolean isAssociation();
-
-	public boolean isBasicPropertyAccessor();
-
-	public String getPropertyAccessorName();
-
-	public void setPropertyAccessorName(String propertyAccessorName);
-
-	public boolean isIncludedInOptimisticLocking();
-
-	public void setIncludedInOptimisticLocking(boolean includedInOptimisticLocking);
-
-	/**
-	 * Obtain the meta attributes associated with this binding
-	 *
-	 * @return The meta attributes
-	 */
-	public MetaAttributeContext getMetaAttributeContext();
-
-	public boolean isAlternateUniqueKey();
-
-	public boolean isLazy();
-
-	public void addEntityReferencingAttributeBinding(SingularAssociationAttributeBinding attributeBinding);
-
-	public Set<SingularAssociationAttributeBinding> getEntityReferencingAttributeBindings();
-
-	public void validate();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBindingContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBindingContainer.java
deleted file mode 100644
index c208c3911c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBindingContainer.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.domain.AttributeContainer;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * Common contract for {@link EntityBinding} and {@link ComponentAttributeBinding} in so far as they are both
- * containers for {@link AttributeBinding} descriptors
- *
- * @author Steve Ebersole
- */
-public interface AttributeBindingContainer {
-	/**
-	 * Obtain the path base of this container.  Intended to help uniquely identify each attribute binding.
-	 *
-	 * @return The path base for this container.
-	 */
-	public String getPathBase();
-
-	/**
-	 * Obtain the underlying domain attribute container.
-	 *
-	 * @return The attribute container
-	 */
-	public AttributeContainer getAttributeContainer();
-
-	/**
-	 * Obtain all attribute bindings
-	 *
-	 * @return All attribute bindings
-	 */
-	public Iterable<AttributeBinding> attributeBindings();
-
-	/**
-	 * Locate a specific attribute binding, by its local name.
-	 *
-	 * @param name The name of the attribute, local to this container.
-	 *
-	 * @return The attribute binding.
-	 */
-	public AttributeBinding locateAttributeBinding(String name);
-
-	/**
-	 * Factory method for basic attribute bindings.
-	 *
-	 * @param attribute The attribute for which to make a binding.
-	 *
-	 * @return The attribute binding instance.
-	 */
-	public BasicAttributeBinding makeBasicAttributeBinding(SingularAttribute attribute);
-
-	/**
-	 * Factory method for component attribute bindings.
-	 *
-	 * @param attribute The attribute for which to make a binding.
-	 *
-	 * @return The attribute binding instance.
-	 */
-	public ComponentAttributeBinding makeComponentAttributeBinding(SingularAttribute attribute);
-
-	/**
-	 * Factory method for many-to-one attribute bindings.
-	 *
-	 * @param attribute The attribute for which to make a binding.
-	 *
-	 * @return The attribute binding instance.
-	 */
-	public ManyToOneAttributeBinding makeManyToOneAttributeBinding(SingularAttribute attribute);
-
-	/**
-	 * Factory method for bag attribute bindings.
-	 *
-	 * @param attribute The attribute for which to make a binding.
-	 * @param nature The nature of the collection elements.
-	 *
-	 * @return The attribute binding instance.
-	 */
-	public BagBinding makeBagAttributeBinding(PluralAttribute attribute, CollectionElementNature nature);
-
-	/**
-	 * Factory method for bag attribute bindings.
-	 *
-	 * @param attribute The attribute for which to make a binding.
-	 * @param nature The nature of the collection elements.
-	 *
-	 * @return The attribute binding instance.
-	 */
-	public SetBinding makeSetAttributeBinding(PluralAttribute attribute, CollectionElementNature nature);
-
-	/**
-	 * Seeks out the entity binding that is the root of this component path.
-	 *
-	 * @return The entity binding
-	 */
-	public EntityBinding seekEntityBinding();
-
-	/**
-	 * Obtain the {@link Class} reference for this attribute container.  Generally this is used to perform reflection
-	 * on the attributes.
-	 *
-	 * @return The {@link Class} reference
-	 */
-	public Class<?> getClassReference();
-
-	/**
-	 * Obtain the meta-attribute context for this container.
-	 *
-	 * @return The meta-attribute context.
-	 */
-	public MetaAttributeContext getMetaAttributeContext();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BagBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BagBinding.java
deleted file mode 100644
index 099fb5110c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BagBinding.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.domain.PluralAttribute;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public class BagBinding extends AbstractPluralAttributeBinding {
-	protected BagBinding(AttributeBindingContainer container, PluralAttribute attribute, CollectionElementNature nature) {
-		super( container, attribute, nature );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicAttributeBinding.java
deleted file mode 100644
index c867c7b494..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicAttributeBinding.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Properties;
-
-import org.hibernate.MappingException;
-import org.hibernate.id.IdentifierGenerator;
-import org.hibernate.id.PersistentIdentifierGenerator;
-import org.hibernate.id.factory.IdentifierGeneratorFactory;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Schema;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public class BasicAttributeBinding
-		extends AbstractSingularAttributeBinding
-		implements  KeyValueBinding {
-
-	private String unsavedValue;
-	private PropertyGeneration generation;
-	private boolean includedInOptimisticLocking;
-
-	private boolean forceNonNullable;
-	private boolean forceUnique;
-	private boolean keyCascadeDeleteEnabled;
-
-	private MetaAttributeContext metaAttributeContext;
-
-	BasicAttributeBinding(
-			AttributeBindingContainer container,
-			SingularAttribute attribute,
-			boolean forceNonNullable,
-			boolean forceUnique) {
-		super( container, attribute );
-		this.forceNonNullable = forceNonNullable;
-		this.forceUnique = forceUnique;
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return false;
-	}
-
-	@Override
-	public String getUnsavedValue() {
-		return unsavedValue;
-	}
-
-	public void setUnsavedValue(String unsavedValue) {
-		this.unsavedValue = unsavedValue;
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return generation;
-	}
-
-	public void setGeneration(PropertyGeneration generation) {
-		this.generation = generation;
-	}
-
-	public boolean isIncludedInOptimisticLocking() {
-		return includedInOptimisticLocking;
-	}
-
-	public void setIncludedInOptimisticLocking(boolean includedInOptimisticLocking) {
-		this.includedInOptimisticLocking = includedInOptimisticLocking;
-	}
-
-	@Override
-	public boolean isKeyCascadeDeleteEnabled() {
-		return keyCascadeDeleteEnabled;
-	}
-
-	public void setKeyCascadeDeleteEnabled(boolean keyCascadeDeleteEnabled) {
-		this.keyCascadeDeleteEnabled = keyCascadeDeleteEnabled;
-	}
-
-	public boolean forceNonNullable() {
-		return forceNonNullable;
-	}
-
-	public boolean forceUnique() {
-		return forceUnique;
-	}
-
-	public MetaAttributeContext getMetaAttributeContext() {
-		return metaAttributeContext;
-	}
-
-	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
-		this.metaAttributeContext = metaAttributeContext;
-	}
-
-	IdentifierGenerator createIdentifierGenerator(
-			IdGenerator idGenerator,
-			IdentifierGeneratorFactory identifierGeneratorFactory,
-			Properties properties) {
-		Properties params = new Properties();
-		params.putAll( properties );
-
-		// use the schema/catalog specified by getValue().getTable() - but note that
-		// if the schema/catalog were specified as params, they will already be initialized and
-		//will override the values set here (they are in idGenerator.getParameters().)
-		Schema schema = getValue().getTable().getSchema();
-		if ( schema != null ) {
-			if ( schema.getName().getSchema() != null ) {
-				params.setProperty( PersistentIdentifierGenerator.SCHEMA, schema.getName().getSchema().getName() );
-			}
-			if ( schema.getName().getCatalog() != null ) {
-				params.setProperty( PersistentIdentifierGenerator.CATALOG, schema.getName().getCatalog().getName() );
-			}
-		}
-
-		// TODO: not sure how this works for collection IDs...
-		//pass the entity-name, if not a collection-id
-		//if ( rootClass!=null) {
-			params.setProperty( IdentifierGenerator.ENTITY_NAME, getContainer().seekEntityBinding().getEntity().getName() );
-		//}
-
-		//init the table here instead of earlier, so that we can get a quoted table name
-		//TODO: would it be better to simply pass the qualified table name, instead of
-		//      splitting it up into schema/catalog/table names
-		String tableName = getValue().getTable().getQualifiedName( identifierGeneratorFactory.getDialect() );
-		params.setProperty( PersistentIdentifierGenerator.TABLE, tableName );
-
-		//pass the column name (a generated id almost always has a single column)
-		if ( getSimpleValueSpan() > 1 ) {
-			throw new MappingException(
-					"A SimpleAttributeBinding used for an identifier has more than 1 Value: " + getAttribute().getName()
-			);
-		}
-		SimpleValue simpleValue = (SimpleValue) getValue();
-		if ( !Column.class.isInstance( simpleValue ) ) {
-			throw new MappingException(
-					"Cannot create an IdentifierGenerator because the value is not a column: " +
-							simpleValue.toLoggableString()
-			);
-		}
-		params.setProperty(
-				PersistentIdentifierGenerator.PK,
-				( (Column) simpleValue ).getColumnName().encloseInQuotesIfQuoted(
-						identifierGeneratorFactory.getDialect()
-				)
-		);
-
-		// TODO: is this stuff necessary for SimpleValue???
-		//if (rootClass!=null) {
-		//	StringBuffer tables = new StringBuffer();
-		//	Iterator iter = rootClass.getIdentityTables().iterator();
-		//	while ( iter.hasNext() ) {
-		//		Table table= (Table) iter.next();
-		//		tables.append( table.getQuotedName(dialect) );
-		//		if ( iter.hasNext() ) tables.append(", ");
-		//	}
-		//	params.setProperty( PersistentIdentifierGenerator.TABLES, tables.toString() );
-		//}
-		//else {
-		params.setProperty( PersistentIdentifierGenerator.TABLES, tableName );
-		//}
-
-		params.putAll( idGenerator.getParameters() );
-
-		return identifierGeneratorFactory.createIdentifierGenerator(
-				idGenerator.getStrategy(), getHibernateTypeDescriptor().getResolvedTypeMapping(), params
-		);
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicCollectionElement.java
deleted file mode 100644
index 5d0f84c216..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/BasicCollectionElement.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class BasicCollectionElement extends AbstractCollectionElement {
-	private final HibernateTypeDescriptor hibernateTypeDescriptor = new HibernateTypeDescriptor();
-
-	public BasicCollectionElement(AbstractPluralAttributeBinding binding) {
-		super( binding );
-	}
-
-	public CollectionElementNature getCollectionElementNature() {
-		return CollectionElementNature.BASIC;
-	}
-
-	public HibernateTypeDescriptor getHibernateTypeDescriptor() {
-		return hibernateTypeDescriptor;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Caching.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Caching.java
deleted file mode 100644
index e4a9e0ed12..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Caching.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.cache.spi.access.AccessType;
-
-/**
- * Defines the caching settings for an entity.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class Caching {
-	private String region;
-	private AccessType accessType;
-	private boolean cacheLazyProperties;
-
-	public Caching() {
-	}
-
-	public Caching(String region, AccessType accessType, boolean cacheLazyProperties) {
-		this.region = region;
-		this.accessType = accessType;
-		this.cacheLazyProperties = cacheLazyProperties;
-	}
-
-	public String getRegion() {
-		return region;
-	}
-
-	public void setRegion(String region) {
-		this.region = region;
-	}
-
-	public AccessType getAccessType() {
-		return accessType;
-	}
-
-	public void setAccessType(AccessType accessType) {
-		this.accessType = accessType;
-	}
-
-	public boolean isCacheLazyProperties() {
-		return cacheLazyProperties;
-	}
-
-	public void setCacheLazyProperties(boolean cacheLazyProperties) {
-		this.cacheLazyProperties = cacheLazyProperties;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "Caching" );
-		sb.append( "{region='" ).append( region ).append( '\'' );
-		sb.append( ", accessType=" ).append( accessType );
-		sb.append( ", cacheLazyProperties=" ).append( cacheLazyProperties );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CascadeType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CascadeType.java
deleted file mode 100644
index 14a4f2aa0a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CascadeType.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.MappingException;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
-
-
-/**
- * @author Hardy Ferentschik
- * @todo integrate this w/ org.hibernate.engine.spi.CascadeStyle
- */
-public enum CascadeType {
-	/**
-	 * Cascades save, delete, update, evict, lock, replicate, merge, persist
-	 */
-	ALL,
-
-	/**
-	 * Cascades save, delete, update, evict, lock, replicate, merge, persist + delete orphans
-	 */
-	ALL_DELETE_ORPHAN,
-
-	/**
-	 * Cascades save and update
-	 */
-	UPDATE,
-
-	/**
-	 * Cascades persist
-	 */
-	PERSIST,
-
-	/**
-	 * Cascades merge
-	 */
-	MERGE,
-
-	/**
-	 * Cascades lock
-	 */
-	LOCK,
-
-	/**
-	 * Cascades refresh
-	 */
-	REFRESH,
-
-	/**
-	 * Cascades replicate
-	 */
-	REPLICATE,
-
-	/**
-	 * Cascades evict
-	 */
-	EVICT,
-
-	/**
-	 * Cascade delete
-	 */
-	DELETE,
-
-	/**
-	 * Cascade delete + delete orphans
-	 */
-	DELETE_ORPHAN,
-
-	/**
-	 * No cascading
-	 */
-	NONE;
-
-	private static final Map<String, CascadeType> hbmOptionToCascadeType = new HashMap<String, CascadeType>();
-
-	static {
-		hbmOptionToCascadeType.put( "all", ALL );
-		hbmOptionToCascadeType.put( "all-delete-orphan", ALL_DELETE_ORPHAN );
-		hbmOptionToCascadeType.put( "save-update", UPDATE );
-		hbmOptionToCascadeType.put( "persist", PERSIST );
-		hbmOptionToCascadeType.put( "merge", MERGE );
-		hbmOptionToCascadeType.put( "lock", LOCK );
-		hbmOptionToCascadeType.put( "refresh", REFRESH );
-		hbmOptionToCascadeType.put( "replicate", REPLICATE );
-		hbmOptionToCascadeType.put( "evict", EVICT );
-		hbmOptionToCascadeType.put( "delete", DELETE );
-		hbmOptionToCascadeType.put( "remove", DELETE ); // adds remove as a sort-of alias for delete...
-		hbmOptionToCascadeType.put( "delete-orphan", DELETE_ORPHAN );
-		hbmOptionToCascadeType.put( "none", NONE );
-	}
-
-	private static final Map<javax.persistence.CascadeType, CascadeType> jpaCascadeTypeToHibernateCascadeType = new HashMap<javax.persistence.CascadeType, CascadeType>();
-
-	static {
-		jpaCascadeTypeToHibernateCascadeType.put( javax.persistence.CascadeType.ALL, ALL );
-		jpaCascadeTypeToHibernateCascadeType.put( javax.persistence.CascadeType.PERSIST, PERSIST );
-		jpaCascadeTypeToHibernateCascadeType.put( javax.persistence.CascadeType.MERGE, MERGE );
-		jpaCascadeTypeToHibernateCascadeType.put( javax.persistence.CascadeType.REFRESH, REFRESH );
-		jpaCascadeTypeToHibernateCascadeType.put( javax.persistence.CascadeType.DETACH, EVICT );
-	}
-
-	private static final Map<CascadeType, CascadeStyle> cascadeTypeToCascadeStyle = new HashMap<CascadeType, CascadeStyle>();
-	static {
-		cascadeTypeToCascadeStyle.put( ALL, CascadeStyles.ALL );
-		cascadeTypeToCascadeStyle.put( ALL_DELETE_ORPHAN, CascadeStyles.ALL_DELETE_ORPHAN );
-		cascadeTypeToCascadeStyle.put( UPDATE, CascadeStyles.UPDATE );
-		cascadeTypeToCascadeStyle.put( PERSIST, CascadeStyles.PERSIST );
-		cascadeTypeToCascadeStyle.put( MERGE, CascadeStyles.MERGE );
-		cascadeTypeToCascadeStyle.put( LOCK, CascadeStyles.LOCK );
-		cascadeTypeToCascadeStyle.put( REFRESH, CascadeStyles.REFRESH );
-		cascadeTypeToCascadeStyle.put( REPLICATE, CascadeStyles.REPLICATE );
-		cascadeTypeToCascadeStyle.put( EVICT, CascadeStyles.EVICT );
-		cascadeTypeToCascadeStyle.put( DELETE, CascadeStyles.DELETE );
-		cascadeTypeToCascadeStyle.put( DELETE_ORPHAN, CascadeStyles.DELETE_ORPHAN );
-		cascadeTypeToCascadeStyle.put( NONE, CascadeStyles.NONE );
-	}
-
-	/**
-	 * @param hbmOptionName the cascading option as specified in the hbm mapping file
-	 *
-	 * @return Returns the {@code CascadeType} for a given hbm cascading option
-	 */
-	public static CascadeType getCascadeType(String hbmOptionName) {
-		return hbmOptionToCascadeType.get( hbmOptionName );
-	}
-
-	/**
-	 * @param jpaCascade the jpa cascade type
-	 *
-	 * @return Returns the Hibernate {@code CascadeType} for a given jpa cascade type
-	 */
-	public static CascadeType getCascadeType(javax.persistence.CascadeType jpaCascade) {
-		return jpaCascadeTypeToHibernateCascadeType.get( jpaCascade );
-	}
-
-	/**
-	 * @return Returns the {@code CascadeStyle} that corresponds to this {@code CascadeType}
-	 *
-	 * @throws MappingException if there is not corresponding {@code CascadeStyle}
-	 */
-	public CascadeStyle toCascadeStyle() {
-		CascadeStyle cascadeStyle = cascadeTypeToCascadeStyle.get( this );
-		if ( cascadeStyle == null ) {
-			throw new MappingException( "No CascadeStyle that corresponds with CascadeType=" + this.name() );
-		}
-		return cascadeStyle;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionElementNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionElementNature.java
deleted file mode 100644
index 69fc83a7a7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionElementNature.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * Describes the nature of persistent collection elements.
- *
- * @author Steve Ebersole
- * @author Gail Badner
- *
- * @todo Merge with {@link org.hibernate.metamodel.source.binder.PluralAttributeNature} ?  package separation kept me from doing that initially
- */
-public enum CollectionElementNature {
-	BASIC,
-	COMPOSITE,
-	ONE_TO_MANY,
-	MANY_TO_MANY,
-	MANY_TO_ANY
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionKey.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionKey.java
deleted file mode 100644
index 81661e8e23..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionKey.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.relational.ForeignKey;
-import org.hibernate.metamodel.relational.TableSpecification;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public class CollectionKey {
-	private final AbstractPluralAttributeBinding pluralAttributeBinding;
-
-	private ForeignKey foreignKey;
-	private boolean inverse;
-	private HibernateTypeDescriptor hibernateTypeDescriptor;
-
-// todo : this would be nice to have but we do not always know it, especially in HBM case.
-//	private BasicAttributeBinding otherSide;
-
-	public CollectionKey(AbstractPluralAttributeBinding pluralAttributeBinding) {
-		this.pluralAttributeBinding = pluralAttributeBinding;
-	}
-
-	public AbstractPluralAttributeBinding getPluralAttributeBinding() {
-		return pluralAttributeBinding;
-	}
-
-	public void prepareForeignKey(String foreignKeyName, String targetTableName) {
-		if ( foreignKey != null ) {
-			throw new AssertionFailure( "Foreign key already initialized" );
-		}
-		final TableSpecification collectionTable = pluralAttributeBinding.getCollectionTable();
-		if ( collectionTable == null ) {
-			throw new AssertionFailure( "Collection table not yet bound" );
-		}
-
-		final TableSpecification targetTable = pluralAttributeBinding.getContainer()
-				.seekEntityBinding()
-				.locateTable( targetTableName );
-
-		// todo : handle implicit fk names...
-
-		foreignKey = collectionTable.createForeignKey( targetTable, foreignKeyName );
-	}
-
-	public ForeignKey getForeignKey() {
-		return foreignKey;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionLaziness.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionLaziness.java
deleted file mode 100644
index 72240474c9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CollectionLaziness.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * @author Steve Ebersole
- */
-public enum CollectionLaziness {
-	LAZY,
-	NOT,
-	EXTRA
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ComponentAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ComponentAttributeBinding.java
deleted file mode 100644
index b64b79eabe..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ComponentAttributeBinding.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.domain.AttributeContainer;
-import org.hibernate.metamodel.domain.Component;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.domain.PluralAttributeNature;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * @author Steve Ebersole
- */
-public class ComponentAttributeBinding extends AbstractSingularAttributeBinding implements AttributeBindingContainer {
-	private final String path;
-	private Map<String, AttributeBinding> attributeBindingMap = new HashMap<String, AttributeBinding>();
-	private SingularAttribute parentReference;
-	private MetaAttributeContext metaAttributeContext;
-
-	public ComponentAttributeBinding(AttributeBindingContainer container, SingularAttribute attribute) {
-		super( container, attribute );
-		this.path = container.getPathBase() + '.' + attribute.getName();
-	}
-
-	@Override
-	public EntityBinding seekEntityBinding() {
-		return getContainer().seekEntityBinding();
-	}
-
-	@Override
-	public String getPathBase() {
-		return path;
-	}
-
-	@Override
-	public AttributeContainer getAttributeContainer() {
-		return getComponent();
-	}
-
-	public Component getComponent() {
-		return (Component) getAttribute().getSingularAttributeType();
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return false;
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		return metaAttributeContext;
-	}
-
-	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
-		this.metaAttributeContext = metaAttributeContext;
-	}
-
-	@Override
-	public AttributeBinding locateAttributeBinding(String name) {
-		return attributeBindingMap.get( name );
-	}
-
-	@Override
-	public Iterable<AttributeBinding> attributeBindings() {
-		return attributeBindingMap.values();
-	}
-
-	@Override
-	protected void checkValueBinding() {
-		// do nothing here...
-	}
-
-	@Override
-	public BasicAttributeBinding makeBasicAttributeBinding(SingularAttribute attribute) {
-		final BasicAttributeBinding binding = new BasicAttributeBinding(
-				this,
-				attribute,
-				isNullable(),
-				isAlternateUniqueKey() // todo : is this accurate?
-		);
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	protected void registerAttributeBinding(String name, AttributeBinding attributeBinding) {
-		// todo : hook this into the EntityBinding notion of "entity referencing attribute bindings"
-		attributeBindingMap.put( name, attributeBinding );
-	}
-
-	@Override
-	public ComponentAttributeBinding makeComponentAttributeBinding(SingularAttribute attribute) {
-		final ComponentAttributeBinding binding = new ComponentAttributeBinding( this, attribute );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public ManyToOneAttributeBinding makeManyToOneAttributeBinding(SingularAttribute attribute) {
-		final ManyToOneAttributeBinding binding = new ManyToOneAttributeBinding( this, attribute );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public BagBinding makeBagAttributeBinding(PluralAttribute attribute, CollectionElementNature nature) {
-		Helper.checkPluralAttributeNature( attribute, PluralAttributeNature.BAG );
-		final BagBinding binding = new BagBinding( this, attribute, nature );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public SetBinding makeSetAttributeBinding(PluralAttribute attribute, CollectionElementNature nature) {
-		Helper.checkPluralAttributeNature( attribute, PluralAttributeNature.SET );
-		final SetBinding binding = new SetBinding( this, attribute, nature );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public Class<?> getClassReference() {
-		return getComponent().getClassReference();
-	}
-
-	public SingularAttribute getParentReference() {
-		return parentReference;
-	}
-
-	public void setParentReference(SingularAttribute parentReference) {
-		this.parentReference = parentReference;
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		// todo : not sure the correct thing to return here since it essentially relies on the simple sub-attributes.
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CompositeCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CompositeCollectionElement.java
deleted file mode 100644
index e39886d055..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CompositeCollectionElement.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class CompositeCollectionElement extends AbstractCollectionElement {
-	public CompositeCollectionElement(AbstractPluralAttributeBinding binding) {
-		super( binding );
-	}
-
-	@Override
-	public CollectionElementNature getCollectionElementNature() {
-		return CollectionElementNature.COMPOSITE;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CustomSQL.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CustomSQL.java
deleted file mode 100644
index 17cc349364..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/CustomSQL.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-
-/**
- * Wraps the information for custom SQL execution
- *
- * @author Steve Ebersole
- */
-public class CustomSQL {
-	private final String sql;
-	private final boolean isCallable;
-	private final ExecuteUpdateResultCheckStyle checkStyle;
-
-	public CustomSQL(String sql, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
-		this.sql = sql;
-		isCallable = callable;
-		this.checkStyle = checkStyle;
-	}
-
-	public String getSql() {
-		return sql;
-	}
-
-	public boolean isCallable() {
-		return isCallable;
-	}
-
-	public ExecuteUpdateResultCheckStyle getCheckStyle() {
-		return checkStyle;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java
deleted file mode 100644
index 967e2a627a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java
+++ /dev/null
@@ -1,605 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.EntityMode;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.internal.util.collections.JoinedIterable;
-import org.hibernate.metamodel.domain.AttributeContainer;
-import org.hibernate.metamodel.domain.Entity;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.domain.PluralAttributeNature;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.TableSpecification;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.tuple.entity.EntityTuplizer;
-
-/**
- * Provides the link between the domain and the relational model for an entity.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- * @author Gail Badner
- */
-public class EntityBinding implements AttributeBindingContainer {
-	private static final String NULL_DISCRIMINATOR_MATCH_VALUE = "null";
-	private static final String NOT_NULL_DISCRIMINATOR_MATCH_VALUE = "not null";
-
-	private final EntityBinding superEntityBinding;
-	private final List<EntityBinding> subEntityBindings = new ArrayList<EntityBinding>();
-	private final HierarchyDetails hierarchyDetails;
-
-	private Entity entity;
-	private TableSpecification primaryTable;
-    private String primaryTableName;
-	private Map<String, TableSpecification> secondaryTables = new HashMap<String, TableSpecification>();
-
-	private ValueHolder<Class<?>> proxyInterfaceType;
-
-	private String jpaEntityName;
-
-	private Class<? extends EntityPersister> customEntityPersisterClass;
-	private Class<? extends EntityTuplizer> customEntityTuplizerClass;
-
-	private String discriminatorMatchValue;
-
-	private Set<FilterDefinition> filterDefinitions = new HashSet<FilterDefinition>();
-	private Set<SingularAssociationAttributeBinding> entityReferencingAttributeBindings = new HashSet<SingularAssociationAttributeBinding>();
-
-	private MetaAttributeContext metaAttributeContext;
-
-	private boolean lazy;
-	private boolean mutable;
-	private String whereFilter;
-	private String rowId;
-
-	private boolean dynamicUpdate;
-	private boolean dynamicInsert;
-
-	private int batchSize;
-	private boolean selectBeforeUpdate;
-	private boolean hasSubselectLoadableCollections;
-
-	private Boolean isAbstract;
-
-	private String customLoaderName;
-	private CustomSQL customInsert;
-	private CustomSQL customUpdate;
-	private CustomSQL customDelete;
-
-	private Set<String> synchronizedTableNames = new HashSet<String>();
-	private Map<String, AttributeBinding> attributeBindingMap = new HashMap<String, AttributeBinding>();
-
-    private List<JpaCallbackClass> jpaCallbackClasses = new ArrayList<JpaCallbackClass>();
-
-	/**
-	 * Used to instantiate the EntityBinding for an entity that is the root of an inheritance hierarchy
-	 *
-	 * @param inheritanceType The inheritance type for the hierarchy
-	 * @param entityMode The entity mode used in this hierarchy.
-	 */
-	public EntityBinding(InheritanceType inheritanceType, EntityMode entityMode) {
-		this.superEntityBinding = null;
-		this.hierarchyDetails = new HierarchyDetails( this, inheritanceType, entityMode );
-	}
-
-	/**
-	 * Used to instantiate the EntityBinding for an entity that is a subclass (sub-entity) in an inheritance hierarchy
-	 *
-	 * @param superEntityBinding The entity binding of this binding's super
-	 */
-	public EntityBinding(EntityBinding superEntityBinding) {
-		this.superEntityBinding = superEntityBinding;
-		this.superEntityBinding.subEntityBindings.add( this );
-		this.hierarchyDetails = superEntityBinding.getHierarchyDetails();
-	}
-
-	public HierarchyDetails getHierarchyDetails() {
-		return hierarchyDetails;
-	}
-
-	public EntityBinding getSuperEntityBinding() {
-		return superEntityBinding;
-	}
-
-	public boolean isRoot() {
-		return superEntityBinding == null;
-	}
-
-	public boolean isPolymorphic() {
-		return  superEntityBinding != null ||
-				hierarchyDetails.getEntityDiscriminator() != null ||
-				! subEntityBindings.isEmpty();
-	}
-
-	public boolean hasSubEntityBindings() {
-		return subEntityBindings.size() > 0;
-	}
-
-	public int getSubEntityBindingClosureSpan() {
-		int n = subEntityBindings.size();
-		for ( EntityBinding subEntityBinding : subEntityBindings ) {
-			n += subEntityBinding.getSubEntityBindingClosureSpan();
-		}
-		return n;
-	}
-
-	/* used for testing */
-	public Iterable<EntityBinding> getDirectSubEntityBindings() {
-		return subEntityBindings;
-	}
-
-	/**
-	 * Returns sub-EntityBinding objects in a special 'order', most derived subclasses
-	 * first. Specifically, the sub-entity bindings follow a depth-first,
-	 * post-order traversal
-	 *
-	 * Note that the returned value excludes this entity binding.
-	 *
-	 * @return sub-entity bindings ordered by those entity bindings that are most derived.
-	 */
-	public Iterable<EntityBinding> getPostOrderSubEntityBindingClosure() {
-		// TODO: why this order?
-		List<Iterable<EntityBinding>> subclassIterables = new ArrayList<Iterable<EntityBinding>>( subEntityBindings.size() + 1 );
-		for ( EntityBinding subEntityBinding : subEntityBindings ) {
-			Iterable<EntityBinding> subSubEntityBindings = subEntityBinding.getPostOrderSubEntityBindingClosure();
-			if ( subSubEntityBindings.iterator().hasNext() ) {
-				subclassIterables.add( subSubEntityBindings );
-			}
-		}
-		if ( ! subEntityBindings.isEmpty() ) {
-			subclassIterables.add( subEntityBindings );
-		}
-		return new JoinedIterable<EntityBinding>( subclassIterables );
-	}
-
-	/**
-	 * Returns sub-EntityBinding ordered as a depth-first,
-	 * pre-order traversal (a subclass precedes its own subclasses).
-	 *
-	 * Note that the returned value specifically excludes this entity binding.
-	 *
-	 * @return sub-entity bindings ordered as a depth-first,
-	 * pre-order traversal
-	 */
-	public Iterable<EntityBinding> getPreOrderSubEntityBindingClosure() {
-		return getPreOrderSubEntityBindingClosure( false );
-	}
-
-	private Iterable<EntityBinding> getPreOrderSubEntityBindingClosure(boolean includeThis) {
-		List<Iterable<EntityBinding>> iterables = new ArrayList<Iterable<EntityBinding>>();
-		if ( includeThis ) {
-			iterables.add( java.util.Collections.singletonList( this ) );
-		}
-		for ( EntityBinding subEntityBinding : subEntityBindings ) {
-			Iterable<EntityBinding> subSubEntityBindingClosure =  subEntityBinding.getPreOrderSubEntityBindingClosure( true );
-			if ( subSubEntityBindingClosure.iterator().hasNext() ) {
-				iterables.add( subSubEntityBindingClosure );
-			}
-		}
-		return new JoinedIterable<EntityBinding>( iterables );
-	}
-
-	public Entity getEntity() {
-		return entity;
-	}
-
-	public void setEntity(Entity entity) {
-		this.entity = entity;
-	}
-
-	public TableSpecification getPrimaryTable() {
-		return primaryTable;
-	}
-
-	public void setPrimaryTable(TableSpecification primaryTable) {
-		this.primaryTable = primaryTable;
-	}
-
-    public TableSpecification locateTable(String tableName) {
-        if ( tableName == null || tableName.equals( getPrimaryTableName() ) ) {
-            return primaryTable;
-        }
-        TableSpecification tableSpec = secondaryTables.get( tableName );
-        if ( tableSpec == null ) {
-            throw new AssertionFailure(
-                    String.format(
-                            "Unable to find table %s amongst tables %s",
-                            tableName,
-                            secondaryTables.keySet()
-                    )
-            );
-        }
-        return tableSpec;
-    }
-    public String getPrimaryTableName() {
-        return primaryTableName;
-    }
-
-    public void setPrimaryTableName(String primaryTableName) {
-        this.primaryTableName = primaryTableName;
-    }
-
-	public void addSecondaryTable(String tableName, TableSpecification table) {
-		secondaryTables.put( tableName, table );
-	}
-
-	public boolean isVersioned() {
-		return getHierarchyDetails().getVersioningAttributeBinding() != null;
-	}
-
-	public boolean isDiscriminatorMatchValueNull() {
-		return NULL_DISCRIMINATOR_MATCH_VALUE.equals( discriminatorMatchValue );
-	}
-
-	public boolean isDiscriminatorMatchValueNotNull() {
-		return NOT_NULL_DISCRIMINATOR_MATCH_VALUE.equals( discriminatorMatchValue );
-	}
-
-	public String getDiscriminatorMatchValue() {
-		return discriminatorMatchValue;
-	}
-
-	public void setDiscriminatorMatchValue(String discriminatorMatchValue) {
-		this.discriminatorMatchValue = discriminatorMatchValue;
-	}
-
-	public Iterable<FilterDefinition> getFilterDefinitions() {
-		return filterDefinitions;
-	}
-
-	public void addFilterDefinition(FilterDefinition filterDefinition) {
-		filterDefinitions.add( filterDefinition );
-	}
-
-	public Iterable<SingularAssociationAttributeBinding> getEntityReferencingAttributeBindings() {
-		return entityReferencingAttributeBindings;
-	}
-
-	@Override
-	public EntityBinding seekEntityBinding() {
-		return this;
-	}
-
-	@Override
-	public String getPathBase() {
-		return getEntity().getName();
-	}
-
-	@Override
-	public Class<?> getClassReference() {
-		return getEntity().getClassReference();
-	}
-
-	@Override
-	public AttributeContainer getAttributeContainer() {
-		return getEntity();
-	}
-
-	protected void registerAttributeBinding(String name, AttributeBinding attributeBinding) {
-		if ( SingularAssociationAttributeBinding.class.isInstance( attributeBinding ) ) {
-			entityReferencingAttributeBindings.add( (SingularAssociationAttributeBinding) attributeBinding );
-		}
-		attributeBindingMap.put( name, attributeBinding );
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		return metaAttributeContext;
-	}
-
-	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
-		this.metaAttributeContext = metaAttributeContext;
-	}
-
-	public boolean isMutable() {
-		return mutable;
-	}
-
-	public void setMutable(boolean mutable) {
-		this.mutable = mutable;
-	}
-
-	public boolean isLazy() {
-		return lazy;
-	}
-
-	public void setLazy(boolean lazy) {
-		this.lazy = lazy;
-	}
-
-	public ValueHolder<Class<?>> getProxyInterfaceType() {
-		return proxyInterfaceType;
-	}
-
-	public void setProxyInterfaceType(ValueHolder<Class<?>> proxyInterfaceType) {
-		this.proxyInterfaceType = proxyInterfaceType;
-	}
-
-	public String getWhereFilter() {
-		return whereFilter;
-	}
-
-	public void setWhereFilter(String whereFilter) {
-		this.whereFilter = whereFilter;
-	}
-
-	public String getRowId() {
-		return rowId;
-	}
-
-	public void setRowId(String rowId) {
-		this.rowId = rowId;
-	}
-
-	public boolean isDynamicUpdate() {
-		return dynamicUpdate;
-	}
-
-	public void setDynamicUpdate(boolean dynamicUpdate) {
-		this.dynamicUpdate = dynamicUpdate;
-	}
-
-	public boolean isDynamicInsert() {
-		return dynamicInsert;
-	}
-
-	public void setDynamicInsert(boolean dynamicInsert) {
-		this.dynamicInsert = dynamicInsert;
-	}
-
-	public int getBatchSize() {
-		return batchSize;
-	}
-
-	public void setBatchSize(int batchSize) {
-		this.batchSize = batchSize;
-	}
-
-	public boolean isSelectBeforeUpdate() {
-		return selectBeforeUpdate;
-	}
-
-	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
-		this.selectBeforeUpdate = selectBeforeUpdate;
-	}
-
-	public boolean hasSubselectLoadableCollections() {
-		return hasSubselectLoadableCollections;
-	}
-
-	/* package-protected */
-	void setSubselectLoadableCollections(boolean hasSubselectLoadableCollections) {
-		this.hasSubselectLoadableCollections = hasSubselectLoadableCollections;
-	}
-
-	public Class<? extends EntityPersister> getCustomEntityPersisterClass() {
-		return customEntityPersisterClass;
-	}
-
-	public void setCustomEntityPersisterClass(Class<? extends EntityPersister> customEntityPersisterClass) {
-		this.customEntityPersisterClass = customEntityPersisterClass;
-	}
-
-	public Class<? extends EntityTuplizer> getCustomEntityTuplizerClass() {
-		return customEntityTuplizerClass;
-	}
-
-	public void setCustomEntityTuplizerClass(Class<? extends EntityTuplizer> customEntityTuplizerClass) {
-		this.customEntityTuplizerClass = customEntityTuplizerClass;
-	}
-
-	public Boolean isAbstract() {
-		return isAbstract;
-	}
-
-	public void setAbstract(Boolean isAbstract) {
-		this.isAbstract = isAbstract;
-	}
-
-	public Set<String> getSynchronizedTableNames() {
-		return synchronizedTableNames;
-	}
-
-	public void addSynchronizedTableNames(java.util.Collection<String> synchronizedTableNames) {
-		this.synchronizedTableNames.addAll( synchronizedTableNames );
-	}
-
-	public String getJpaEntityName() {
-		return jpaEntityName;
-	}
-
-	public void setJpaEntityName(String jpaEntityName) {
-		this.jpaEntityName = jpaEntityName;
-	}
-
-	public String getCustomLoaderName() {
-		return customLoaderName;
-	}
-
-	public void setCustomLoaderName(String customLoaderName) {
-		this.customLoaderName = customLoaderName;
-	}
-
-	public CustomSQL getCustomInsert() {
-		return customInsert;
-	}
-
-	public void setCustomInsert(CustomSQL customInsert) {
-		this.customInsert = customInsert;
-	}
-
-	public CustomSQL getCustomUpdate() {
-		return customUpdate;
-	}
-
-	public void setCustomUpdate(CustomSQL customUpdate) {
-		this.customUpdate = customUpdate;
-	}
-
-	public CustomSQL getCustomDelete() {
-		return customDelete;
-	}
-
-	public void setCustomDelete(CustomSQL customDelete) {
-		this.customDelete = customDelete;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "EntityBinding" );
-		sb.append( "{entity=" ).append( entity != null ? entity.getName() : "not set" );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	@Override
-	public BasicAttributeBinding makeBasicAttributeBinding(SingularAttribute attribute) {
-		return makeSimpleAttributeBinding( attribute, false, false );
-	}
-
-	private BasicAttributeBinding makeSimpleAttributeBinding(SingularAttribute attribute, boolean forceNonNullable, boolean forceUnique) {
-		final BasicAttributeBinding binding = new BasicAttributeBinding(
-				this,
-				attribute,
-				forceNonNullable,
-				forceUnique
-		);
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public ComponentAttributeBinding makeComponentAttributeBinding(SingularAttribute attribute) {
-		final ComponentAttributeBinding binding = new ComponentAttributeBinding( this, attribute );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public ManyToOneAttributeBinding makeManyToOneAttributeBinding(SingularAttribute attribute) {
-		final ManyToOneAttributeBinding binding = new ManyToOneAttributeBinding( this, attribute );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public BagBinding makeBagAttributeBinding(PluralAttribute attribute, CollectionElementNature nature) {
-		Helper.checkPluralAttributeNature( attribute, PluralAttributeNature.BAG );
-		final BagBinding binding = new BagBinding( this, attribute, nature );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public SetBinding makeSetAttributeBinding(PluralAttribute attribute, CollectionElementNature nature) {
-		Helper.checkPluralAttributeNature( attribute, PluralAttributeNature.SET );
-		final SetBinding binding = new SetBinding( this, attribute, nature );
-		registerAttributeBinding( attribute.getName(), binding );
-		return binding;
-	}
-
-	@Override
-	public AttributeBinding locateAttributeBinding(String name) {
-		return attributeBindingMap.get( name );
-	}
-
-	@Override
-	public Iterable<AttributeBinding> attributeBindings() {
-		return attributeBindingMap.values();
-	}
-
-	/**
-	 * Gets the number of attribute bindings defined on this class, including the
-	 * identifier attribute binding and attribute bindings defined
-	 * as part of a join.
-	 *
-	 * @return The number of attribute bindings
-	 */
-	public int getAttributeBindingClosureSpan() {
-		// TODO: update account for join attribute bindings
-		return superEntityBinding != null ?
-				superEntityBinding.getAttributeBindingClosureSpan() + attributeBindingMap.size() :
-				attributeBindingMap.size();
-	}
-
-	/**
-	 * Gets the attribute bindings defined on this class, including the
-	 * identifier attribute binding and attribute bindings defined
-	 * as part of a join.
-	 *
-	 * @return The attribute bindings.
-	 */
-	public Iterable<AttributeBinding> getAttributeBindingClosure() {
-		// TODO: update size to account for joins
-		Iterable<AttributeBinding> iterable;
-		if ( superEntityBinding != null ) {
-			List<Iterable<AttributeBinding>> iterables = new ArrayList<Iterable<AttributeBinding>>( 2 );
-			iterables.add( superEntityBinding.getAttributeBindingClosure() );
-			iterables.add( attributeBindings() );
-			iterable = new JoinedIterable<AttributeBinding>( iterables );
-		}
-		else {
-			iterable = attributeBindings();
-		}
-		return iterable;
-	}
-
-	/**
-	 * Gets the attribute bindings for this EntityBinding and all of its
-	 * sub-EntityBinding, starting from the root of the hierarchy; includes
-	 * the identifier and attribute bindings defined as part of a join.
-	 * @return
-	 */
-	public Iterable<AttributeBinding> getSubEntityAttributeBindingClosure() {
-		List<Iterable<AttributeBinding>> iterables = new ArrayList<Iterable<AttributeBinding>>();
-		iterables.add( getAttributeBindingClosure() );
-		for ( EntityBinding subEntityBinding : getPreOrderSubEntityBindingClosure() ) {
-			// only add attribute bindings declared for the subEntityBinding
-			iterables.add( subEntityBinding.attributeBindings() );
-			// TODO: if EntityBinding.attributeBindings() excludes joined attributes, then they need to be added here
-		}
-		return new JoinedIterable<AttributeBinding>( iterables );
-	}
-
-	public void setJpaCallbackClasses( List<JpaCallbackClass> jpaCallbackClasses ) {
-	    this.jpaCallbackClasses = jpaCallbackClasses;
-	}
-
-    public Iterable<JpaCallbackClass> getJpaCallbackClasses() {
-        return jpaCallbackClasses;
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityDiscriminator.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityDiscriminator.java
deleted file mode 100644
index 724d194d8f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityDiscriminator.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.relational.SimpleValue;
-
-/**
- * Binding of the discriminator in a entity hierarchy
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class EntityDiscriminator {
-	private final HibernateTypeDescriptor explicitHibernateTypeDescriptor = new HibernateTypeDescriptor();
-
-	private SimpleValue boundValue;
-	private boolean forced;
-	private boolean inserted = true;
-
-	public EntityDiscriminator() {
-	}
-
-	public SimpleValue getBoundValue() {
-		return boundValue;
-	}
-
-	public void setBoundValue(SimpleValue boundValue) {
-		this.boundValue = boundValue;
-	}
-
-	public HibernateTypeDescriptor getExplicitHibernateTypeDescriptor() {
-		return explicitHibernateTypeDescriptor;
-	}
-
-	public boolean isForced() {
-		return forced;
-	}
-
-	public void setForced(boolean forced) {
-		this.forced = forced;
-	}
-
-	public boolean isInserted() {
-		return inserted;
-	}
-
-	public void setInserted(boolean inserted) {
-		this.inserted = inserted;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "EntityDiscriminator" );
-		sb.append( "{boundValue=" ).append( boundValue );
-		sb.append( ", forced=" ).append( forced );
-		sb.append( ", inserted=" ).append( inserted );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityIdentifier.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityIdentifier.java
deleted file mode 100644
index fba5b3c6c4..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityIdentifier.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Properties;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.id.IdentifierGenerator;
-import org.hibernate.id.factory.IdentifierGeneratorFactory;
-
-/**
- * Binds the entity identifier.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class EntityIdentifier {
-	private final EntityBinding entityBinding;
-	private BasicAttributeBinding attributeBinding;
-	private IdentifierGenerator identifierGenerator;
-	private IdGenerator idGenerator;
-	private boolean isIdentifierMapper = false;
-	// todo : mappers, etc
-
-	/**
-	 * Create an identifier
-	 *
-	 * @param entityBinding the entity binding for which this instance is the id
-	 */
-	public EntityIdentifier(EntityBinding entityBinding) {
-		this.entityBinding = entityBinding;
-	}
-
-	public BasicAttributeBinding getValueBinding() {
-		return attributeBinding;
-	}
-
-	public void setValueBinding(BasicAttributeBinding attributeBinding) {
-		if ( this.attributeBinding != null ) {
-			throw new AssertionFailure(
-					String.format(
-							"Identifier value binding already existed for %s",
-							entityBinding.getEntity().getName()
-					)
-			);
-		}
-		this.attributeBinding = attributeBinding;
-	}
-
-	public void setIdGenerator(IdGenerator idGenerator) {
-		this.idGenerator = idGenerator;
-	}
-
-	public boolean isEmbedded() {
-		return attributeBinding.getSimpleValueSpan() > 1;
-	}
-
-	public boolean isIdentifierMapper() {
-		return isIdentifierMapper;
-	}
-
-	// todo do we really need this createIdentifierGenerator and how do we make sure the getter is not called too early
-	// maybe some sort of visitor pattern here!? (HF)
-	public IdentifierGenerator createIdentifierGenerator(IdentifierGeneratorFactory factory, Properties properties) {
-		if ( idGenerator != null ) {
-			identifierGenerator = attributeBinding.createIdentifierGenerator( idGenerator, factory, properties );
-		}
-		return identifierGenerator;
-	}
-
-	public IdentifierGenerator getIdentifierGenerator() {
-		return identifierGenerator;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/FetchProfile.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/FetchProfile.java
deleted file mode 100644
index 31b6d5dbc5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/FetchProfile.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Collections;
-import java.util.Set;
-
-/**
- * A fetch profile allows a user to dynamically modify the fetching strategy used for particular associations at runtime, whereas
- * that information was historically only statically defined in the metadata.
- * <p/>
- * This class represent the data as it is defined in their metadata.
- *
- * @author Steve Ebersole
- * @see org.hibernate.engine.profile.FetchProfile
- */
-public class FetchProfile {
-
-    private final String name;
-    private final Set<Fetch> fetches;
-
-    /**
-     * Create a fetch profile representation.
-     *
-     * @param name The name of the fetch profile.
-     * @param fetches
-     */
-    public FetchProfile( String name,
-                         Set<Fetch> fetches ) {
-        this.name = name;
-        this.fetches = fetches;
-    }
-
-    /**
-     * Retrieve the name of the fetch profile.
-     *
-     * @return The profile name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Retrieve the fetches associated with this profile
-     *
-     * @return The fetches associated with this profile.
-     */
-    public Set<Fetch> getFetches() {
-        return Collections.unmodifiableSet(fetches);
-    }
-
-    /**
-     * Adds a fetch to this profile.
-     *
-     * @param entity The entity which contains the association to be fetched
-     * @param association The association to fetch
-     * @param style The style of fetch t apply
-     */
-    public void addFetch( String entity,
-                          String association,
-                          String style ) {
-        fetches.add(new Fetch(entity, association, style));
-    }
-
-    /**
-     * Defines an individual association fetch within the given profile.
-     */
-    public static class Fetch {
-        private final String entity;
-        private final String association;
-        private final String style;
-
-        public Fetch( String entity,
-                      String association,
-                      String style ) {
-            this.entity = entity;
-            this.association = association;
-            this.style = style;
-        }
-
-        public String getEntity() {
-            return entity;
-        }
-
-        public String getAssociation() {
-            return association;
-        }
-
-        public String getStyle() {
-            return style;
-        }
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Helper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Helper.java
deleted file mode 100644
index 1bd2427d81..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/Helper.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.domain.PluralAttributeNature;
-
-/**
- * Helper utilities specific to the binding package.
- *
- * @author Steve Ebersole
- */
-public class Helper {
-	public static void checkPluralAttributeNature(PluralAttribute attribute, PluralAttributeNature expected) {
-		if ( attribute.getNature() != expected ) {
-			throw new AssertionFailure(
-					String.format(
-							"Mismatched collection natures; expecting %s, but found %s",
-							expected.getName(),
-							attribute.getNature().getName()
-					)
-			);
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HibernateTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HibernateTypeDescriptor.java
deleted file mode 100644
index 6629783f50..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HibernateTypeDescriptor.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.type.Type;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public class HibernateTypeDescriptor {
-	private String explicitTypeName;
-	private String javaTypeName;
-	private boolean isToOne;
-	private Map<String, String> typeParameters = new HashMap<String, String>(  );
-
-	private Type resolvedTypeMapping;
-
-	public String getExplicitTypeName() {
-		return explicitTypeName;
-	}
-
-	public void setExplicitTypeName(String explicitTypeName) {
-		this.explicitTypeName = explicitTypeName;
-	}
-
-	public String getJavaTypeName() {
-		return javaTypeName;
-	}
-
-	public void setJavaTypeName(String javaTypeName) {
-		this.javaTypeName = javaTypeName;
-	}
-
-	public boolean isToOne() {
-		return isToOne;
-	}
-
-	public void setToOne(boolean toOne) {
-		isToOne = toOne;
-	}
-
-	public Map<String, String> getTypeParameters() {
-		return typeParameters;
-	}
-
-	public void setTypeParameters(Map<String, String> typeParameters) {
-		this.typeParameters = typeParameters;
-	}
-
-	public Type getResolvedTypeMapping() {
-		return resolvedTypeMapping;
-	}
-
-	public void setResolvedTypeMapping(Type resolvedTypeMapping) {
-		this.resolvedTypeMapping = resolvedTypeMapping;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HierarchyDetails.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HierarchyDetails.java
deleted file mode 100644
index 3b31495472..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/HierarchyDetails.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.EntityMode;
-import org.hibernate.engine.OptimisticLockStyle;
-
-/**
- * @author Steve Ebersole
- */
-public class HierarchyDetails {
-	private final EntityBinding rootEntityBinding;
-	private final InheritanceType inheritanceType;
-	private final EntityMode entityMode;
-
-	private final EntityIdentifier entityIdentifier;
-
-	private EntityDiscriminator entityDiscriminator;
-
-	private OptimisticLockStyle optimisticLockStyle;
-	private BasicAttributeBinding versioningAttributeBinding;
-
-	private Caching caching;
-
-	private boolean explicitPolymorphism;
-
-	public HierarchyDetails(EntityBinding rootEntityBinding, InheritanceType inheritanceType, EntityMode entityMode) {
-		this.rootEntityBinding = rootEntityBinding;
-		this.inheritanceType = inheritanceType;
-		this.entityMode = entityMode;
-		this.entityIdentifier = new EntityIdentifier( rootEntityBinding );
-	}
-
-	public EntityBinding getRootEntityBinding() {
-		return rootEntityBinding;
-	}
-
-	public InheritanceType getInheritanceType() {
-		return inheritanceType;
-	}
-
-	public EntityMode getEntityMode() {
-		return entityMode;
-	}
-
-	public EntityIdentifier getEntityIdentifier() {
-		return entityIdentifier;
-	}
-
-	public EntityDiscriminator getEntityDiscriminator() {
-		return entityDiscriminator;
-	}
-
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		return optimisticLockStyle;
-	}
-
-	public void setOptimisticLockStyle(OptimisticLockStyle optimisticLockStyle) {
-		this.optimisticLockStyle = optimisticLockStyle;
-	}
-
-	public void setEntityDiscriminator(EntityDiscriminator entityDiscriminator) {
-		this.entityDiscriminator = entityDiscriminator;
-	}
-
-	public BasicAttributeBinding getVersioningAttributeBinding() {
-		return versioningAttributeBinding;
-	}
-
-	public void setVersioningAttributeBinding(BasicAttributeBinding versioningAttributeBinding) {
-		this.versioningAttributeBinding = versioningAttributeBinding;
-	}
-
-	public Caching getCaching() {
-		return caching;
-	}
-
-	public void setCaching(Caching caching) {
-		this.caching = caching;
-	}
-
-	public boolean isExplicitPolymorphism() {
-		return explicitPolymorphism;
-	}
-
-	public void setExplicitPolymorphism(boolean explicitPolymorphism) {
-		this.explicitPolymorphism = explicitPolymorphism;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/IdGenerator.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/IdGenerator.java
deleted file mode 100644
index 007b3b305a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/IdGenerator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.io.Serializable;
-import java.util.Collections;
-import java.util.Map;
-
-import org.hibernate.internal.util.collections.CollectionHelper;
-
-/**
- * Identifier generator container, Useful to keep named generator in annotations
- *
- * @author Emmanuel Bernard
- */
-public class IdGenerator implements Serializable {
-    private final String name;
-    private final String strategy;
-    private final Map<String, String> parameters;
-
-    public IdGenerator( String name,
-                        String strategy,
-                        Map<String, String> parameters ) {
-        this.name = name;
-        this.strategy = strategy;
-        if ( CollectionHelper.isEmpty( parameters ) ) {
-            this.parameters = Collections.emptyMap();
-        }
-        else {
-            this.parameters = Collections.unmodifiableMap( parameters );
-        }
-    }
-
-    /**
-     * @return identifier generator strategy
-     */
-    public String getStrategy() {
-        return strategy;
-    }
-
-    /**
-     * @return generator name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * @return generator configuration parameters
-     */
-    public Map<String, String> getParameters() {
-		return parameters;
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/InheritanceType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/InheritanceType.java
deleted file mode 100644
index 9bcd4792cd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/InheritanceType.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.MappingException;
-
-/**
- * The inheritance type for a given entity.
- * <p>
- * Note, we are not using the JPA enum, because we need the ability to extend the types if we need to.
- *
- * @author Hardy Ferentschik
- */
-public enum InheritanceType {
-	JOINED,
-	SINGLE_TABLE,
-	TABLE_PER_CLASS,
-	NO_INHERITANCE;
-
-	/**
-	 * @param jpaType The JPA inheritance type
-	 *
-	 * @return The inheritance type of this class.
-	 */
-	public static InheritanceType get(javax.persistence.InheritanceType jpaType) {
-		switch ( jpaType ) {
-			case SINGLE_TABLE: {
-				return InheritanceType.SINGLE_TABLE;
-			}
-			case JOINED: {
-				return InheritanceType.JOINED;
-			}
-			case TABLE_PER_CLASS: {
-				return InheritanceType.TABLE_PER_CLASS;
-			}
-			default: {
-				throw new MappingException( "Unknown jpa inheritance type:" + jpaType.name() );
-			}
-		}
-	}
-}
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/KeyValueBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/KeyValueBinding.java
deleted file mode 100644
index cc48595d02..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/KeyValueBinding.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public interface KeyValueBinding extends AttributeBinding {
-	public boolean isKeyCascadeDeleteEnabled();
-
-	public String getUnsavedValue();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToAnyCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToAnyCollectionElement.java
deleted file mode 100644
index 50e5edd443..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToAnyCollectionElement.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class ManyToAnyCollectionElement extends AbstractCollectionElement {
-	ManyToAnyCollectionElement(AbstractPluralAttributeBinding binding) {
-		super( binding );
-	}
-
-	@Override
-	public CollectionElementNature getCollectionElementNature() {
-		return CollectionElementNature.MANY_TO_ANY;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToManyCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToManyCollectionElement.java
deleted file mode 100644
index ee5b93464a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToManyCollectionElement.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.HashMap;
-
-import org.dom4j.Element;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class ManyToManyCollectionElement extends AbstractCollectionElement {
-
-	private final java.util.Map manyToManyFilters = new HashMap();
-	private String manyToManyWhere;
-	private String manyToManyOrderBy;
-
-
-	ManyToManyCollectionElement(AbstractPluralAttributeBinding binding) {
-		super( binding );
-	}
-
-	@Override
-	public CollectionElementNature getCollectionElementNature() {
-		return CollectionElementNature.MANY_TO_MANY;
-	}
-
-	public void fromHbmXml(Element node){
-	/*
-    <!ELEMENT many-to-many (meta*,(column|formula)*,filter*)>
-   	<!ATTLIST many-to-many class CDATA #IMPLIED>
-	<!ATTLIST many-to-many node CDATA #IMPLIED>
-	<!ATTLIST many-to-many embed-xml (true|false) "true">
-	<!ATTLIST many-to-many entity-name CDATA #IMPLIED>
-	<!ATTLIST many-to-many column CDATA #IMPLIED>
-	<!ATTLIST many-to-many formula CDATA #IMPLIED>
-	<!ATTLIST many-to-many not-found (exception|ignore) "exception">
-	<!ATTLIST many-to-many outer-join (true|false|auto) #IMPLIED>
-	<!ATTLIST many-to-many fetch (join|select) #IMPLIED>
-	<!ATTLIST many-to-many lazy (false|proxy) #IMPLIED>
-	<!ATTLIST many-to-many foreign-key CDATA #IMPLIED>
-	<!ATTLIST many-to-many unique (true|false) "false">
-	<!ATTLIST many-to-many where CDATA #IMPLIED>
-	<!ATTLIST many-to-many order-by CDATA #IMPLIED>
-	<!ATTLIST many-to-many property-ref CDATA #IMPLIED>
-    */
-	}
-
-	public String getManyToManyWhere() {
-		return manyToManyWhere;
-	}
-
-	public void setManyToManyWhere(String manyToManyWhere) {
-		this.manyToManyWhere = manyToManyWhere;
-	}
-
-	public String getManyToManyOrderBy() {
-		return manyToManyOrderBy;
-	}
-
-	public void setManyToManyOrderBy(String manyToManyOrderBy) {
-		this.manyToManyOrderBy = manyToManyOrderBy;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java
deleted file mode 100644
index 66a9f5376b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
-import org.hibernate.metamodel.domain.SingularAttribute;
-
-/**
- * TODO : javadoc
- *
- * @author Gail Badner
- * @author Steve Ebersole
- */
-public class ManyToOneAttributeBinding extends BasicAttributeBinding implements SingularAssociationAttributeBinding {
-	private String referencedEntityName;
-	private String referencedAttributeName;
-	private AttributeBinding referencedAttributeBinding;
-
-	private boolean isLogicalOneToOne;
-	private String foreignKeyName;
-
-	private CascadeStyle cascadeStyle;
-	private FetchTiming fetchTiming;
-	private FetchStyle fetchStyle;
-
-	ManyToOneAttributeBinding(AttributeBindingContainer container, SingularAttribute attribute) {
-		super( container, attribute, false, false );
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return true;
-	}
-
-	@Override
-	public final boolean isPropertyReference() {
-		return referencedAttributeName != null;
-	}
-
-	@Override
-	public final String getReferencedEntityName() {
-		return referencedEntityName;
-	}
-
-	@Override
-	public void setReferencedEntityName(String referencedEntityName) {
-		this.referencedEntityName = referencedEntityName;
-	}
-
-	@Override
-	public final String getReferencedAttributeName() {
-		return referencedAttributeName;
-	}
-
-	@Override
-	public void setReferencedAttributeName(String referencedEntityAttributeName) {
-		this.referencedAttributeName = referencedEntityAttributeName;
-	}
-
-	@Override
-	public CascadeStyle getCascadeStyle() {
-		return cascadeStyle;
-	}
-
-	@Override
-	public void setCascadeStyles(Iterable<CascadeStyle> cascadeStyles) {
-		List<CascadeStyle> cascadeStyleList = new ArrayList<CascadeStyle>();
-		for ( CascadeStyle style : cascadeStyles ) {
-			if ( style != CascadeStyles.NONE ) {
-				cascadeStyleList.add( style );
-			}
-		}
-		if ( cascadeStyleList.isEmpty() ) {
-			cascadeStyle = CascadeStyles.NONE;
-		}
-		else if ( cascadeStyleList.size() == 1 ) {
-			cascadeStyle = cascadeStyleList.get( 0 );
-		}
-		else {
-			cascadeStyle = new CascadeStyles.MultipleCascadeStyle(
-					cascadeStyleList.toArray( new CascadeStyle[ cascadeStyleList.size() ] )
-			);
-		}
-	}
-
-	@Override
-	public FetchTiming getFetchTiming() {
-		return fetchTiming;
-	}
-
-	@Override
-	public void setFetchTiming(FetchTiming fetchTiming) {
-		this.fetchTiming = fetchTiming;
-	}
-
-	@Override
-	public FetchStyle getFetchStyle() {
-		return fetchStyle;
-	}
-
-	@Override
-	public void setFetchStyle(FetchStyle fetchStyle) {
-		if ( fetchStyle == FetchStyle.SUBSELECT ) {
-			throw new AssertionFailure( "Subselect fetching not yet supported for singular associations" );
-		}
-		this.fetchStyle = fetchStyle;
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		if ( fetchStyle == FetchStyle.JOIN ) {
-			return FetchMode.JOIN;
-		}
-		else if ( fetchStyle == FetchStyle.SELECT ) {
-			return FetchMode.SELECT;
-		}
-		else if ( fetchStyle == FetchStyle.BATCH ) {
-			// we need the subsequent select...
-			return FetchMode.SELECT;
-		}
-
-		throw new AssertionFailure( "Unexpected fetch style : " + fetchStyle.name() );
-	}
-
-	@Override
-	public final boolean isReferenceResolved() {
-		return referencedAttributeBinding != null;
-	}
-
-	@Override
-	public final void resolveReference(AttributeBinding referencedAttributeBinding) {
-		if ( ! EntityBinding.class.isInstance( referencedAttributeBinding.getContainer() ) ) {
-			throw new AssertionFailure( "Illegal attempt to resolve many-to-one reference based on non-entity attribute" );
-		}
-		final EntityBinding entityBinding = (EntityBinding) referencedAttributeBinding.getContainer();
-		if ( !referencedEntityName.equals( entityBinding.getEntity().getName() ) ) {
-			throw new IllegalStateException(
-					"attempt to set EntityBinding with name: [" +
-							entityBinding.getEntity().getName() +
-							"; entity name should be: " + referencedEntityName
-			);
-		}
-		if ( referencedAttributeName == null ) {
-			referencedAttributeName = referencedAttributeBinding.getAttribute().getName();
-		}
-		else if ( !referencedAttributeName.equals( referencedAttributeBinding.getAttribute().getName() ) ) {
-			throw new IllegalStateException(
-					"Inconsistent attribute name; expected: " + referencedAttributeName +
-							"actual: " + referencedAttributeBinding.getAttribute().getName()
-			);
-		}
-		this.referencedAttributeBinding = referencedAttributeBinding;
-//		buildForeignKey();
-	}
-
-	@Override
-	public AttributeBinding getReferencedAttributeBinding() {
-		if ( !isReferenceResolved() ) {
-			throw new IllegalStateException( "Referenced AttributeBiding has not been resolved." );
-		}
-		return referencedAttributeBinding;
-	}
-
-	@Override
-	public final EntityBinding getReferencedEntityBinding() {
-		return (EntityBinding) referencedAttributeBinding.getContainer();
-	}
-
-//	private void buildForeignKey() {
-//		// TODO: move this stuff to relational model
-//		ForeignKey foreignKey = getValue().getTable()
-//				.createForeignKey( referencedAttributeBinding.getValue().getTable(), foreignKeyName );
-//		Iterator<SimpleValue> referencingValueIterator = getSimpleValues().iterator();
-//		Iterator<SimpleValue> targetValueIterator = referencedAttributeBinding.getSimpleValues().iterator();
-//		while ( referencingValueIterator.hasNext() ) {
-//			if ( !targetValueIterator.hasNext() ) {
-//				// TODO: improve this message
-//				throw new MappingException(
-//						"number of values in many-to-one reference is greater than number of values in target"
-//				);
-//			}
-//			SimpleValue referencingValue = referencingValueIterator.next();
-//			SimpleValue targetValue = targetValueIterator.next();
-//			if ( Column.class.isInstance( referencingValue ) ) {
-//				if ( !Column.class.isInstance( targetValue ) ) {
-//					// TODO improve this message
-//					throw new MappingException( "referencing value is a column, but target is not a column" );
-//				}
-//				foreignKey.addColumnMapping( Column.class.cast( referencingValue ), Column.class.cast( targetValue ) );
-//			}
-//			else if ( Column.class.isInstance( targetValue ) ) {
-//				// TODO: improve this message
-//				throw new MappingException( "referencing value is not a column, but target is a column." );
-//			}
-//		}
-//		if ( targetValueIterator.hasNext() ) {
-//			throw new MappingException( "target value has more simple values than referencing value" );
-//		}
-//	}
-//
-//	public void validate() {
-//		// can't check this until both the domain and relational states are initialized...
-//		if ( getCascadeTypes().contains( CascadeType.DELETE_ORPHAN ) ) {
-//			if ( !isLogicalOneToOne ) {
-//				throw new MappingException(
-//						"many-to-one attribute [" + locateAttribute().getName() + "] does not support orphan delete as it is not unique"
-//				);
-//			}
-//		}
-//		//TODO: validate that the entity reference is resolved
-//	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/MetaAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/MetaAttribute.java
deleted file mode 100644
index 18babda0e3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/MetaAttribute.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A meta attribute is a named value or values.
- * 
- * @author Gavin King
- */
-public class MetaAttribute implements Serializable {
-	private final String name;
-	private List<String> values = new ArrayList<String>();
-
-	public MetaAttribute(String name) {
-		this.name = name;
-	}
-	
-	public String getName() {
-		return name;
-	}	
-
-	public List<String> getValues() {
-		return Collections.unmodifiableList(values);
-	}
-
-	public void addValue(String value) {
-		values.add( value );
-	}
-
-	public String getValue() {
-		if ( values.size() != 1 ) {
-			throw new IllegalStateException( "no unique value" );
-		}
-		return values.get( 0 );
-	}
-
-	public boolean isMultiValued() {
-		return values.size()>1;
-	}
-
-	public String toString() {
-		return "[" + name + "=" + values + "]";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/OneToManyCollectionElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/OneToManyCollectionElement.java
deleted file mode 100644
index a2b38037fd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/OneToManyCollectionElement.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class OneToManyCollectionElement extends AbstractCollectionElement {
-
-	OneToManyCollectionElement(AbstractPluralAttributeBinding binding) {
-		super( binding );
-	}
-
-	@Override
-	public CollectionElementNature getCollectionElementNature() {
-		return CollectionElementNature.ONE_TO_MANY;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/PluralAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/PluralAttributeBinding.java
deleted file mode 100644
index df48c1e229..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/PluralAttributeBinding.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Comparator;
-
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.relational.TableSpecification;
-import org.hibernate.persister.collection.CollectionPersister;
-
-/**
- * @author Steve Ebersole
- */
-public interface PluralAttributeBinding extends  AssociationAttributeBinding {
-	// todo : really it is the element (and/or index) that can be associative not the collection itself...
-
-	@Override
-	public PluralAttribute getAttribute();
-
-	public CollectionKey getCollectionKey();
-
-	public AbstractCollectionElement getCollectionElement();
-
-	public TableSpecification getCollectionTable();
-
-	public boolean isMutable();
-
-	public Caching getCaching();
-
-	public Class<? extends CollectionPersister> getCollectionPersisterClass();
-
-	public String getCustomLoaderName();
-
-	public CustomSQL getCustomSqlInsert();
-
-	public CustomSQL getCustomSqlUpdate();
-
-	public CustomSQL getCustomSqlDelete();
-
-	public CustomSQL getCustomSqlDeleteAll();
-
-	public boolean isOrphanDelete();
-
-	String getWhere();
-
-	boolean isSorted();
-
-	Comparator getComparator();
-
-	int getBatchSize();
-
-	java.util.Map getFilterMap();
-
-	boolean isInverse();
-
-	String getOrderBy();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SetBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SetBinding.java
deleted file mode 100644
index 98a0b05d02..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SetBinding.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.Comparator;
-
-import org.hibernate.metamodel.domain.PluralAttribute;
-
-/**
- * @author Steve Ebersole
- */
-public class SetBinding extends AbstractPluralAttributeBinding {
-	private Comparator comparator;
-
-	protected SetBinding(
-			AttributeBindingContainer container,
-			PluralAttribute attribute,
-			CollectionElementNature collectionElementNature) {
-		super( container, attribute, collectionElementNature );
-	}
-
-	public Comparator getComparator() {
-		return comparator;
-	}
-
-	public void setComparator(Comparator comparator) {
-		this.comparator = comparator;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleValueBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleValueBinding.java
deleted file mode 100644
index 0a8dd1afc3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleValueBinding.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.DerivedValue;
-import org.hibernate.metamodel.relational.SimpleValue;
-
-/**
- * @author Steve Ebersole
- */
-public class SimpleValueBinding {
-	private SimpleValue simpleValue;
-	private boolean includeInInsert;
-	private boolean includeInUpdate;
-
-	public SimpleValueBinding() {
-		this( true, true );
-	}
-
-	public SimpleValueBinding(SimpleValue simpleValue) {
-		this();
-		setSimpleValue( simpleValue );
-	}
-
-	public SimpleValueBinding(SimpleValue simpleValue, boolean includeInInsert, boolean includeInUpdate) {
-		this( includeInInsert, includeInUpdate );
-		setSimpleValue( simpleValue );
-	}
-
-	public SimpleValueBinding(boolean includeInInsert, boolean includeInUpdate) {
-		this.includeInInsert = includeInInsert;
-		this.includeInUpdate = includeInUpdate;
-	}
-
-	public SimpleValue getSimpleValue() {
-		return simpleValue;
-	}
-
-	public void setSimpleValue(SimpleValue simpleValue) {
-		this.simpleValue = simpleValue;
-		if ( DerivedValue.class.isInstance( simpleValue ) ) {
-			includeInInsert = false;
-			includeInUpdate = false;
-		}
-	}
-
-	public boolean isDerived() {
-		return DerivedValue.class.isInstance( simpleValue );
-	}
-
-	public boolean isNullable() {
-		return isDerived() || Column.class.cast( simpleValue ).isNullable();
-	}
-
-	/**
-	 * Is the value to be inserted as part of its binding here?
-	 * <p/>
-	 * <b>NOTE</b> that a column may be bound to multiple attributes.  The purpose of this value is to track this
-	 * notion of "insertability" for this particular binding.
-	 *
-	 * @return {@code true} indicates the value should be included; {@code false} indicates it should not
-	 */
-	public boolean isIncludeInInsert() {
-		return includeInInsert;
-	}
-
-	public void setIncludeInInsert(boolean includeInInsert) {
-		this.includeInInsert = includeInInsert;
-	}
-
-	public boolean isIncludeInUpdate() {
-		return includeInUpdate;
-	}
-
-	public void setIncludeInUpdate(boolean includeInUpdate) {
-		this.includeInUpdate = includeInUpdate;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java
deleted file mode 100644
index eb1e60c88d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-/**
- * Contract describing the attribute binding for singular associations ({@code many-to-one}, {@code one-to-one}).
- *
- * @author Gail Badner
- * @author Steve Ebersole
- */
-@SuppressWarnings( {"JavaDoc", "UnusedDeclaration"})
-public interface SingularAssociationAttributeBinding extends SingularAttributeBinding, AssociationAttributeBinding {
-	/**
-	 * Is this association based on a property reference (non PK column(s) as target of FK)?
-	 * <p/>
-	 * Convenience form of checking {@link #getReferencedAttributeName()} for {@code null}.
-	 * 
-	 * @return
-	 */
-	public boolean isPropertyReference();
-
-	/**
-	 * Obtain the name of the referenced entity.
-	 *
-	 * @return The referenced entity name
-	 */
-	public String getReferencedEntityName();
-
-	/**
-	 * Set the name of the
-	 * @param referencedEntityName
-	 */
-	public void setReferencedEntityName(String referencedEntityName);
-
-	public String getReferencedAttributeName();
-	public void setReferencedAttributeName(String referencedAttributeName);
-
-
-	// "resolvable"
-	public void resolveReference(AttributeBinding attributeBinding);
-	public boolean isReferenceResolved();
-	public EntityBinding getReferencedEntityBinding();
-	public AttributeBinding getReferencedAttributeBinding();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAttributeBinding.java
deleted file mode 100644
index 6baf951010..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAttributeBinding.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.relational.Value;
-
-/**
- * Specialized binding contract for singular (non-collection) attributes
- *
- * @author Steve Ebersole
- */
-public interface SingularAttributeBinding extends AttributeBinding {
-	/**
-	 * Obtain the value bound here.  This could potentially be a {@link org.hibernate.metamodel.relational.Tuple}
-	 * indicating multiple database values are bound, in which case access to the individual values can be achieved by
-	 * either casting this return to {@link org.hibernate.metamodel.relational.Tuple} and using its
-	 * {@link org.hibernate.metamodel.relational.Tuple#values()} method or using the {@link #getSimpleValueBindings()}
-	 * method here and accessing each bindings {@link SimpleValueBinding#getSimpleValue simple value}
-	 *
-	 * @return The bound value
-	 */
-	public Value getValue();
-
-	/**
-	 * Returns the number of {@link SimpleValueBinding} objects that will be returned by
-	 * {@link #getSimpleValueBindings()}
-	 *
-	 * @return the number of {@link SimpleValueBinding simple value bindings}
-	 *
-	 * @see #getSimpleValueBindings()
-	 */
-	public int getSimpleValueSpan();
-
-	public Iterable<SimpleValueBinding> getSimpleValueBindings();
-
-	public void setSimpleValueBindings(Iterable<SimpleValueBinding> simpleValueBindings);
-
-	/**
-	 * Convenience method to determine if any {@link SimpleValueBinding simple value bindings} are derived values
-	 * (formula mappings).
-	 *
-	 * @return {@code true} indicates that the binding contains a derived value; {@code false} indicates it does not.
-	 */
-	public boolean hasDerivedValue();
-
-	/**
-	 * Convenience method to determine if all {@link SimpleValueBinding simple value bindings} allow nulls.
-	 *
-	 * @return {@code true} indicates that all values allow {@code null}; {@code false} indicates one or more do not
-	 */
-	public boolean isNullable();
-
-	/**
-	 * Obtain the generation strategy for this attribute/value.
-	 *
-	 * @return The generation strategy
-	 */
-	public PropertyGeneration getGeneration();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/TypeDef.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/TypeDef.java
deleted file mode 100644
index a272eec5ad..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/TypeDef.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.io.Serializable;
-import java.util.Collections;
-import java.util.Map;
-
-/**
- * Represents the metamodel view of a typedef (type definition).
- *
- * @author John Verhaeg
- */
-public class TypeDef implements Serializable {
-	private final String name;
-    private final String typeClass;
-    private final Map<String, String> parameters;
-
-	public TypeDef(String name, String typeClass, Map<String, String> parameters) {
-		this.name = name;
-		this.typeClass = typeClass;
-		this.parameters = parameters;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String getTypeClass() {
-        return typeClass;
-    }
-
-    public Map<String, String> getParameters() {
-        return Collections.unmodifiableMap(parameters);
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
deleted file mode 100644
index 3258f7de70..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Convenient base class for {@link AttributeContainer}.  Because in our model all
- * {@link AttributeContainer AttributeContainers} are also {@link Hierarchical} we also implement that here
- * as well.
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractAttributeContainer implements AttributeContainer, Hierarchical {
-	private final String name;
-	private final String className;
-	private final ValueHolder<Class<?>> classReference;
-	private final Hierarchical superType;
-	private LinkedHashSet<Attribute> attributeSet = new LinkedHashSet<Attribute>();
-	private HashMap<String, Attribute> attributeMap = new HashMap<String, Attribute>();
-
-	public AbstractAttributeContainer(String name, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
-		this.name = name;
-		this.className = className;
-		this.classReference = classReference;
-		this.superType = superType;
-	}
-
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public String getClassName() {
-		return className;
-	}
-
-	@Override
-	public Class<?> getClassReference() {
-		return classReference.getValue();
-	}
-
-	@Override
-	public ValueHolder<Class<?>> getClassReferenceUnresolved() {
-		return classReference;
-	}
-
-	@Override
-	public Hierarchical getSuperType() {
-		return superType;
-	}
-
-	@Override
-	public Set<Attribute> attributes() {
-		return Collections.unmodifiableSet( attributeSet );
-	}
-
-	@Override
-	public String getRoleBaseName() {
-		return getClassName();
-	}
-
-	@Override
-	public Attribute locateAttribute(String name) {
-		return attributeMap.get( name );
-	}
-
-	@Override
-	public SingularAttribute locateSingularAttribute(String name) {
-		return (SingularAttribute) locateAttribute( name );
-	}
-
-	@Override
-	public SingularAttribute createSingularAttribute(String name) {
-		SingularAttribute attribute = new SingularAttributeImpl( name, this );
-		addAttribute( attribute );
-		return attribute;
-	}
-
-	@Override
-	public SingularAttribute createVirtualSingularAttribute(String name) {
-		throw new NotYetImplementedException();
-	}
-
-	@Override
-	public SingularAttribute locateComponentAttribute(String name) {
-		return (SingularAttributeImpl) locateAttribute( name );
-	}
-
-	@Override
-	public SingularAttribute createComponentAttribute(String name, Component component) {
-		SingularAttributeImpl attribute = new SingularAttributeImpl( name, this );
-		attribute.resolveType( component );
-		addAttribute( attribute );
-		return attribute;
-	}
-
-	@Override
-	public PluralAttribute locatePluralAttribute(String name) {
-		return (PluralAttribute) locateAttribute( name );
-	}
-
-	protected PluralAttribute createPluralAttribute(String name, PluralAttributeNature nature) {
-		PluralAttribute attribute = nature.isIndexed()
-				? new IndexedPluralAttributeImpl( name, nature, this )
-				: new PluralAttributeImpl( name, nature, this );
-		addAttribute( attribute );
-		return attribute;
-	}
-
-	@Override
-	public PluralAttribute locateBag(String name) {
-		return locatePluralAttribute( name );
-	}
-
-	@Override
-	public PluralAttribute createBag(String name) {
-		return createPluralAttribute( name, PluralAttributeNature.BAG );
-	}
-
-	@Override
-	public PluralAttribute locateSet(String name) {
-		return locatePluralAttribute( name );
-	}
-
-	@Override
-	public PluralAttribute createSet(String name) {
-		return createPluralAttribute( name, PluralAttributeNature.SET );
-	}
-
-	@Override
-	public IndexedPluralAttribute locateList(String name) {
-		return (IndexedPluralAttribute) locatePluralAttribute( name );
-	}
-
-	@Override
-	public IndexedPluralAttribute createList(String name) {
-		return (IndexedPluralAttribute) createPluralAttribute( name, PluralAttributeNature.LIST );
-	}
-
-	@Override
-	public IndexedPluralAttribute locateMap(String name) {
-		return (IndexedPluralAttribute) locatePluralAttribute( name );
-	}
-
-	@Override
-	public IndexedPluralAttribute createMap(String name) {
-		return (IndexedPluralAttribute) createPluralAttribute( name, PluralAttributeNature.MAP );
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "AbstractAttributeContainer" );
-		sb.append( "{name='" ).append( name ).append( '\'' );
-		sb.append( ", superType=" ).append( superType );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	protected void addAttribute(Attribute attribute) {
-		// todo : how to best "secure" this?
-		if ( attributeMap.put( attribute.getName(), attribute ) != null ) {
-			throw new IllegalArgumentException( "Attribute with name [" + attribute.getName() + "] already registered" );
-		}
-		attributeSet.add( attribute );
-	}
-
-	// todo : inner classes for now..
-
-	public static class SingularAttributeImpl implements SingularAttribute {
-		private final AttributeContainer attributeContainer;
-		private final String name;
-		private Type type;
-
-		public SingularAttributeImpl(String name, AttributeContainer attributeContainer) {
-			this.name = name;
-			this.attributeContainer = attributeContainer;
-		}
-
-		public boolean isTypeResolved() {
-			return type != null;
-		}
-
-		public void resolveType(Type type) {
-			if ( type == null ) {
-				throw new IllegalArgumentException( "Attempt to resolve with null type" );
-			}
-			this.type = type;
-		}
-
-		@Override
-		public Type getSingularAttributeType() {
-			return type;
-		}
-
-		@Override
-		public String getName() {
-			return name;
-		}
-
-		@Override
-		public AttributeContainer getAttributeContainer() {
-			return attributeContainer;
-		}
-
-		@Override
-		public boolean isSingular() {
-			return true;
-		}
-	}
-
-	public static class PluralAttributeImpl implements PluralAttribute {
-		private final AttributeContainer attributeContainer;
-		private final PluralAttributeNature nature;
-		private final String name;
-
-		private Type elementType;
-
-		public PluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
-			this.name = name;
-			this.nature = nature;
-			this.attributeContainer = attributeContainer;
-		}
-
-		@Override
-		public AttributeContainer getAttributeContainer() {
-			return attributeContainer;
-		}
-
-		@Override
-		public boolean isSingular() {
-			return false;
-		}
-
-		@Override
-		public PluralAttributeNature getNature() {
-			return nature;
-		}
-
-		@Override
-		public String getName() {
-			return name;
-		}
-
-		@Override
-		public String getRole() {
-			return StringHelper.qualify( attributeContainer.getRoleBaseName(), name );
-		}
-
-		@Override
-		public Type getElementType() {
-			return elementType;
-		}
-
-		@Override
-		public void setElementType(Type elementType) {
-			this.elementType = elementType;
-		}
-	}
-
-	public static class IndexedPluralAttributeImpl extends PluralAttributeImpl implements IndexedPluralAttribute {
-		private Type indexType;
-
-		public IndexedPluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
-			super( name, nature, attributeContainer );
-		}
-
-		@Override
-		public Type getIndexType() {
-			return indexType;
-		}
-
-		@Override
-		public void setIndexType(Type indexType) {
-			this.indexType = indexType;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Attribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Attribute.java
deleted file mode 100644
index c58bd8778f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Attribute.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * Describes an attribute.
- *
- * @author Steve Ebersole
- */
-public interface Attribute {
-	/**
-	 * Retrieve the attribute name.
-	 *
-	 * @return The attribute name.
-	 */
-	public String getName();
-
-	/**
-	 * Retrieve the declaring container for this attribute (entity/component).
-	 *
-	 * @return The attribute container.
-	 */
-	public AttributeContainer getAttributeContainer();
-
-	/**
-	 * An attribute can be either:<ul>
-	 * <li>singular - castable to {@link SingularAttribute}</li>
-	 * <li>plural - castable to {@link PluralAttribute}
-	 * </ul>
-	 *
-	 * @return True if attribute is singular; false if plural.
-	 */
-	public boolean isSingular();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java
deleted file mode 100644
index 6024c758e4..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import java.util.Set;
-
-/**
- * Basic contract for any container holding attributes. This allows polymorphic handling of both
- * components and entities in terms of the attributes they hold.
- *
- * @author Steve Ebersole
- */
-public interface AttributeContainer extends Type {
-	/**
-	 * Obtain the name of this container in terms of creating attribute role names.
-	 * <p/>
-	 * NOTE : A role uniquely names each attribute.  The role name is the name of the attribute prefixed by the "path"
-	 * to its container.
-	 *
-	 * @return The container base name for role construction.
-	 */
-	public String getRoleBaseName();
-
-	/**
-	 * Retrieve an attribute by name.
-	 *
-	 * @param name The name of the attribute to retrieve.
-	 *
-	 * @return The attribute matching the given name, or null.
-	 */
-	public Attribute locateAttribute(String name);
-
-	/**
-	 * Retrieve the attributes contained in this container.
-	 *
-	 * @return The contained attributes
-	 */
-	public Set<Attribute> attributes();
-
-	public SingularAttribute locateSingularAttribute(String name);
-	public SingularAttribute createSingularAttribute(String name);
-	public SingularAttribute createVirtualSingularAttribute(String name);
-
-	public SingularAttribute locateComponentAttribute(String name);
-	public SingularAttribute createComponentAttribute(String name, Component component);
-
-	public PluralAttribute locatePluralAttribute(String name);
-
-	public PluralAttribute locateBag(String name);
-	public PluralAttribute createBag(String name);
-
-	public PluralAttribute locateSet(String name);
-	public PluralAttribute createSet(String name);
-
-	public IndexedPluralAttribute locateList(String name);
-	public IndexedPluralAttribute createList(String name);
-
-	public IndexedPluralAttribute locateMap(String name);
-	public IndexedPluralAttribute createMap(String name);
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/BasicType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/BasicType.java
deleted file mode 100644
index 682ce46afd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/BasicType.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models a basic type.
- *
- * @author Steve Ebersole
- */
-public class BasicType implements Type {
-	private final String name;
-	private final ValueHolder<Class<?>> classReference;
-
-	public BasicType(String name, ValueHolder<Class<?>> classReference) {
-		this.name = name;
-		this.classReference = classReference;
-	}
-
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public String getClassName() {
-		return name;
-	}
-
-	@Override
-	public Class<?> getClassReference() {
-		return classReference.getValue();
-	}
-
-	@Override
-	public ValueHolder<Class<?>> getClassReferenceUnresolved() {
-		return classReference;
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return false;
-	}
-
-	@Override
-	public boolean isComponent() {
-		return false;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Component.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Component.java
deleted file mode 100644
index e300355a43..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Component.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models the notion of a component (what JPA calls an Embeddable).
- * <p/>
- * NOTE : Components are not currently really hierarchical.  But that is a feature I want to add.
- *
- * @author Steve Ebersole
- */
-public class Component extends AbstractAttributeContainer {
-	public Component(String name, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
-		super( name, className, classReference, superType );
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return false;
-	}
-
-	@Override
-	public boolean isComponent() {
-		return true;
-	}
-
-	@Override
-	public String getRoleBaseName() {
-		// todo : this is not really completely accurate atm
-		//		the role base here should really be the role of the component attribute.
-		return getClassName();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Entity.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Entity.java
deleted file mode 100644
index fc6b41f6a3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Entity.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models the notion of an entity
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class Entity extends AbstractAttributeContainer {
-	/**
-	 * Constructor for the entity
-	 *
-	 * @param entityName The name of the entity
-	 * @param className The name of this entity's java class
-	 * @param classReference The reference to this entity's {@link Class}
-	 * @param superType The super type for this entity. If there is not super type {@code null} needs to be passed.
-	 */
-	public Entity(String entityName, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
-		super( entityName, className, classReference, superType );
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return true;
-	}
-
-	@Override
-	public boolean isComponent() {
-		return false;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Hierarchical.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Hierarchical.java
deleted file mode 100644
index fd587b0a1f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Hierarchical.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * Additional contract for things that can occur in an inheritance hierarchy (specifically ones we would
- * need to traverse).
- *
- * @author Steve Ebersole
- */
-public interface Hierarchical extends AttributeContainer {
-	/**
-	 * Retrieve the super type.
-	 *
-	 * @return The super type, or null if no super type.
-	 */
-	public Hierarchical getSuperType();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/IndexedPluralAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/IndexedPluralAttribute.java
deleted file mode 100644
index 5a15664925..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/IndexedPluralAttribute.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public interface IndexedPluralAttribute extends PluralAttribute {
-	public Type getIndexType();
-	public void setIndexType(Type indexType);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java
deleted file mode 100644
index 1b89606989..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models the naming of a Java type where we may not have access to that type's {@link Class} reference.  Generally
- * speaking this is the case in various hibernate-tools and reverse-engineering use cases.
- *
- * @author Steve Ebersole
- */
-public class JavaType {
-	private final String name;
-	private final ValueHolder<Class<?>> classReference;
-
-	public JavaType(final String name, final ClassLoaderService classLoaderService) {
-		this.name = name;
-		this.classReference = new ValueHolder<Class<?>>(
-				new ValueHolder.DeferredInitializer<Class<?>>() {
-					@Override
-					public Class<?> initialize() {
-						return classLoaderService.classForName( name );
-					}
-				}
-		);
-	}
-
-	public JavaType(Class<?> theClass) {
-		this.name = theClass.getName();
-		this.classReference = new ValueHolder<Class<?>>( theClass );
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public Class<?> getClassReference() {
-		return classReference.getValue();
-	}
-
-	@Override
-	public String toString() {
-		return new StringBuilder( super.toString() )
-				.append( "[name=" ).append( name ).append( "]" )
-				.toString();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/NonEntity.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/NonEntity.java
deleted file mode 100644
index 973dc8af6e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/NonEntity.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models the concept class in the hierarchy with no persistent attributes.
- *
- * @author Hardy Ferentschik
- */
-public class NonEntity extends AbstractAttributeContainer {
-	/**
-	 * Constructor for the non-entity
-	 *
-	 * @param entityName The name of the non-entity
-	 * @param className The name of this non-entity's java class
-	 * @param classReference The reference to this non-entity's {@link Class}
-	 * @param superType The super type for this non-entity. If there is not super type {@code null} needs to be passed.
-	 */
-	public NonEntity(String entityName, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
-		super( entityName, className, classReference, superType );
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return true;
-	}
-
-	@Override
-	public boolean isComponent() {
-		return false;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttribute.java
deleted file mode 100644
index 4914f05da1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttribute.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public interface PluralAttribute extends Attribute {
-	public String getRole();
-	public PluralAttributeNature getNature();
-	public Type getElementType();
-	public void setElementType(Type elementType);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttributeNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttributeNature.java
deleted file mode 100644
index 492299ad68..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/PluralAttributeNature.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Identifies the specific semantic of a plural valued attribute.
- *
- * @author Steve Ebersole
- */
-public enum PluralAttributeNature {
-	BAG( "bag", Collection.class ),
-	IDBAG( "idbag", Collection.class ),
-	SET( "set", Set.class ),
-	LIST( "list", List.class ),
-	MAP( "map", Map.class );
-
-	private final String name;
-	private final Class javaContract;
-	private final boolean indexed;
-
-	PluralAttributeNature(String name, Class javaContract) {
-		this.name = name;
-		this.javaContract = javaContract;
-		this.indexed = Map.class.isAssignableFrom( javaContract ) || List.class.isAssignableFrom( javaContract );
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public Class getJavaContract() {
-		return javaContract;
-	}
-
-	public boolean isIndexed() {
-		return indexed;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/SingularAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/SingularAttribute.java
deleted file mode 100644
index f27b61fced..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/SingularAttribute.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * A single valued (non-collection) attribute
- *
- * @author Steve Ebersole
- */
-public interface SingularAttribute extends Attribute {
-	/**
-	 * Retrieve the attribute type descriptor.
-	 *
-	 * @return THe attribute type.
-	 */
-	public Type getSingularAttributeType();
-
-	public boolean isTypeResolved();
-
-	public void resolveType(Type type);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Superclass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Superclass.java
deleted file mode 100644
index 4a5a095339..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Superclass.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Models the concept of a (intermediate) superclass
- *
- * @author Steve Ebersole
- */
-public class Superclass extends AbstractAttributeContainer {
-	/**
-	 * Constructor for the entity
-	 *
-	 * @param entityName The name of the entity
-	 * @param className The name of this entity's java class
-	 * @param classReference The reference to this entity's {@link Class}
-	 * @param superType The super type for this entity. If there is not super type {@code null} needs to be passed.
-	 */
-	public Superclass(String entityName, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
-		super( entityName, className, classReference, superType );
-	}
-
-	@Override
-	public boolean isAssociation() {
-		return true;
-	}
-
-	@Override
-	public boolean isComponent() {
-		return false;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java
deleted file mode 100644
index 58d0f9592a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * Basic information about a Java type, in regards to its role in particular set of mappings.
- *
- * @author Steve Ebersole
- */
-public interface Type {
-	/**
-	 * Obtain the name of the type.
-	 *
-	 * @return The name
-	 */
-	public String getName();
-
-	/**
-	 * Obtain the java class name for this type.
-	 *
-	 * @return The class name
-	 */
-	public String getClassName();
-
-	/**
-	 * Obtain the java {@link Class} reference for this type
-	 *
-	 * @return The {@link Class} reference
-	 *
-	 * @throws org.hibernate.boot.registry.classloading.spi.ClassLoadingException Indicates the class reference
-	 * could not be determined.  Generally this is the case in reverse-engineering scenarios where the specified
-	 * domain model classes do not yet exist.
-	 */
-	public Class<?> getClassReference();
-
-	public ValueHolder<Class<?>> getClassReferenceUnresolved();
-
-	public boolean isAssociation();
-
-	public boolean isComponent();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/TypeNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/TypeNature.java
deleted file mode 100644
index 09350d2a80..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/TypeNature.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.domain;
-
-/**
- * Describes the type of a type :/
- *
- * @author Steve Ebersole
- */
-public enum TypeNature {
-	BASIC( "basic" ),
-	COMPONENT( "component" ),
-	ENTITY( "entity" ),
-	SUPERCLASS( "superclass" ),
-	NON_ENTITY( "non-entity" );
-
-	private final String name;
-
-	private TypeNature(String name) {
-		this.name = name;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String toString() {
-		return super.toString() + "[" + getName() + "]";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/package.html b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/package.html
deleted file mode 100644
index cb880cc0eb..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/package.html
+++ /dev/null
@@ -1,34 +0,0 @@
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ Copyright (c) 2010, Red Hat Inc. or third-party contributors as
-  ~ indicated by the @author tags or express copyright attribution
-  ~ statements applied by the authors.  All third-party contributions are
-  ~ distributed under license by Red Hat Inc.
-  ~
-  ~ This copyrighted material is made available to anyone wishing to use, modify,
-  ~ copy, or redistribute it subject to the terms and conditions of the GNU
-  ~ Lesser General Public License, as published by the Free Software Foundation.
-  ~
-  ~ This program is distributed in the hope that it will be useful,
-  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-  ~ for more details.
-  ~
-  ~ You should have received a copy of the GNU Lesser General Public License
-  ~ along with this distribution; if not, write to:
-  ~ Free Software Foundation, Inc.
-  ~ 51 Franklin Street, Fifth Floor
-  ~ Boston, MA  02110-1301  USA
-  -->
-
-<html>
-<body>
-<p>
-    This package defines metadata modeling of a logical domain model.  Specifically note that
-    this package does not in any way attempt to encapsulate data modeling information such
-    cardinality or associations.  Also note that the top-level logical model is represetation (entity-mode)
-    agnostic.
-</p>
-</body>
-</html>
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/package.html b/hibernate-core/src/main/java/org/hibernate/metamodel/package.html
deleted file mode 100644
index 08f331856d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/package.html
+++ /dev/null
@@ -1,36 +0,0 @@
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ Copyright (c) 2011, Red Hat Inc. or third-party contributors as
-  ~ indicated by the @author tags or express copyright attribution
-  ~ statements applied by the authors.  All third-party contributions are
-  ~ distributed under license by Red Hat Inc.
-  ~
-  ~ This copyrighted material is made available to anyone wishing to use, modify,
-  ~ copy, or redistribute it subject to the terms and conditions of the GNU
-  ~ Lesser General Public License, as published by the Free Software Foundation.
-  ~
-  ~ This program is distributed in the hope that it will be useful,
-  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-  ~ for more details.
-  ~
-  ~ You should have received a copy of the GNU Lesser General Public License
-  ~ along with this distribution; if not, write to:
-  ~ Free Software Foundation, Inc.
-  ~ 51 Franklin Street, Fifth Floor
-  ~ Boston, MA  02110-1301  USA
-  -->
-
-<html>
-<head></head>
-<body>
-<p>
-    <i>NOTE: This package is currently unfinished and therefore considered experimental and unsupported.</i>
-</p>
-<p>
-	This package defines the new Hibernate metamodel as well as the code used to build that metamodel from user sources
-    (HBM mapping files, annotations, etc).
-</p>
-</body>
-</html>
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractAuxiliaryDatabaseObject.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractAuxiliaryDatabaseObject.java
deleted file mode 100644
index 8b2b58c0a6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractAuxiliaryDatabaseObject.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Convenience base class for {@link org.hibernate.mapping.AuxiliaryDatabaseObject}s.
- * <p/>
- * This implementation performs dialect scoping checks strictly based on
- * dialect name comparisons.  Custom implementations might want to do
- * instanceof-type checks.
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractAuxiliaryDatabaseObject implements AuxiliaryDatabaseObject {
-	// Use a UUID in identifier prefix because this object is not qualified by a schema/catalog
-	// (not sure this matters...)
-	private static final String EXPORT_IDENTIFIER_PREFIX = "auxiliary-object-" + UUID.randomUUID();
-	private static final AtomicInteger counter = new AtomicInteger( 0 );
-	private final String exportIdentifier;
-	private final Set<String> dialectScopes;
-
-	protected AbstractAuxiliaryDatabaseObject(Set<String> dialectScopes) {
-		this.dialectScopes =  dialectScopes == null ? new HashSet<String>() : dialectScopes;
-		this.exportIdentifier =
-				new StringBuilder( EXPORT_IDENTIFIER_PREFIX )
-						.append( '.' )
-						.append( counter.getAndIncrement() )
-						.toString();
-	}
-
-	public void addDialectScope(String dialectName) {
-		dialectScopes.add( dialectName );
-	}
-
-	public Iterable<String> getDialectScopes() {
-		return dialectScopes;
-	}
-
-	public boolean appliesToDialect(Dialect dialect) {
-		// empty means no scoping
-		return dialectScopes.isEmpty() || dialectScopes.contains( dialect.getClass().getName() );
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		return exportIdentifier;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractConstraint.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractConstraint.java
deleted file mode 100644
index bad9ae1c74..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractConstraint.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.dialect.Dialect;
-
-/**
- * Support for writing {@link Constraint} implementations
- *
- * @todo do we need to support defining these on particular schemas/catalogs?
- *
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public abstract class AbstractConstraint implements Constraint {
-	private final TableSpecification table;
-	private final String name;
-	private List<Column> columns = new ArrayList<Column>();
-
-	protected AbstractConstraint(TableSpecification table, String name) {
-		this.table = table;
-		this.name = name;
-	}
-
-	public TableSpecification getTable() {
-		return table;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public Iterable<Column> getColumns() {
-		return columns;
-	}
-
-	protected int getColumnSpan() {
-		return columns.size();
-	}
-
-	protected List<Column> internalColumnAccess() {
-		return columns;
-	}
-
-	public void addColumn(Column column) {
-		internalAddColumn( column );
-	}
-
-	protected void internalAddColumn(Column column) {
-		if ( column.getTable() != getTable() ) {
-			throw new AssertionFailure(
-					String.format(
-							"Unable to add column to constraint; tables [%s, %s] did not match",
-							column.getTable().toLoggableString(),
-							getTable().toLoggableString()
-					)
-			);
-		}
-		columns.add( column );
-	}
-
-	protected boolean isCreationVetoed(Dialect dialect) {
-		return false;
-	}
-
-	protected abstract String sqlConstraintStringInAlterTable(Dialect dialect);
-
-	public String[] sqlDropStrings(Dialect dialect) {
-		if ( isCreationVetoed( dialect ) ) {
-			return null;
-		}
-		else {
-			return new String[] {
-					new StringBuilder()
-						.append( "alter table " )
-						.append( getTable().getQualifiedName( dialect ) )
-						.append( " drop constraint " )
-						.append( dialect.quote( getName() ) )
-						.toString()
-			};
-		}
-	}
-
-	public String[] sqlCreateStrings(Dialect dialect) {
-		if ( isCreationVetoed( dialect ) ) {
-			return null;
-		}
-		else {
-			return new String[] {
-					new StringBuilder( "alter table " )
-							.append( getTable().getQualifiedName( dialect ) )
-							.append( sqlConstraintStringInAlterTable( dialect ) )
-							.toString()
-			};
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractSimpleValue.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractSimpleValue.java
deleted file mode 100644
index 8bec29682f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractSimpleValue.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.ValidationException;
-
-import org.jboss.logging.Logger;
-
-/**
- * Basic support for {@link SimpleValue} implementations.
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractSimpleValue implements SimpleValue {
-
-    private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, AbstractSimpleValue.class.getName());
-
-	private final TableSpecification table;
-	private final int position;
-	private Datatype datatype;
-
-	protected AbstractSimpleValue(TableSpecification table, int position) {
-		this.table = table;
-		this.position = position;
-	}
-
-	@Override
-	public TableSpecification getTable() {
-		return table;
-	}
-
-	public int getPosition() {
-		return position;
-	}
-
-	@Override
-	public Datatype getDatatype() {
-		return datatype;
-	}
-
-	@Override
-	public void setDatatype(Datatype datatype) {
-		LOG.debugf( "setting datatype for column %s : %s", toLoggableString(), datatype );
-		if ( this.datatype != null && ! this.datatype.equals( datatype ) ) {
-			LOG.debugf( "overriding previous datatype : %s", this.datatype );
-		}
-		this.datatype = datatype;
-	}
-
-	@Override
-	public void validateJdbcTypes(JdbcCodes typeCodes) {
-		// todo : better compatibility testing...
-		if ( datatype.getTypeCode() != typeCodes.nextJdbcCde() ) {
-			throw new ValidationException( "Mismatched types" );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractTableSpecification.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractTableSpecification.java
deleted file mode 100644
index 3165c6b107..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AbstractTableSpecification.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Convenience base class for implementing the {@link ValueContainer} contract centralizing commonality
- * between modeling tables, views and inline views.
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractTableSpecification implements TableSpecification {
-	private final static AtomicInteger tableCounter = new AtomicInteger( 0 );
-	private final int tableNumber;
-
-	private final LinkedHashMap<String, SimpleValue> values = new LinkedHashMap<String, SimpleValue>();
-
-	private final PrimaryKey primaryKey = new PrimaryKey( this );
-	private final List<ForeignKey> foreignKeys = new ArrayList<ForeignKey>();
-
-	public AbstractTableSpecification() {
-		this.tableNumber = tableCounter.getAndIncrement();
-	}
-
-	@Override
-	public int getTableNumber() {
-		return tableNumber;
-	}
-
-	@Override
-	public Iterable<SimpleValue> values() {
-		return values.values();
-	}
-
-	@Override
-	public Column locateOrCreateColumn(String name) {
-		if(values.containsKey( name )){
-			return (Column) values.get( name );
-		}
-		final Column column = new Column( this, values.size(), name );
-		values.put( name, column );
-		return column;
-	}
-
-	@Override
-	public DerivedValue locateOrCreateDerivedValue(String fragment) {
-		if(values.containsKey( fragment )){
-			return (DerivedValue) values.get( fragment );
-		}
-		final DerivedValue value = new DerivedValue( this, values.size(), fragment );
-		values.put( fragment, value );
-		return value;
-	}
-
-	@Override
-	public Tuple createTuple(String name) {
-		return new Tuple( this, name );
-	}
-
-	@Override
-	public Iterable<ForeignKey> getForeignKeys() {
-		return foreignKeys;
-	}
-
-	@Override
-	public ForeignKey createForeignKey(TableSpecification targetTable, String name) {
-		ForeignKey fk = new ForeignKey( this, targetTable, name );
-		foreignKeys.add( fk );
-		return fk;
-	}
-
-	@Override
-	public PrimaryKey getPrimaryKey() {
-		return primaryKey;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AuxiliaryDatabaseObject.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AuxiliaryDatabaseObject.java
deleted file mode 100644
index 9b0b6dc770..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/AuxiliaryDatabaseObject.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.io.Serializable;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Auxiliary database objects (i.e., triggers, stored procedures, etc) defined
- * in the mappings.  Allows Hibernate to manage their lifecycle as part of
- * creating/dropping the schema.
- *
- * @author Steve Ebersole
- */
-public interface AuxiliaryDatabaseObject extends Exportable, Serializable {
-	/**
-	 * Does this database object apply to the given dialect?
-	 *
-	 * @param dialect The dialect to check against.
-	 * @return True if this database object does apply to the given dialect.
-	 */
-	boolean appliesToDialect(Dialect dialect);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/BasicAuxiliaryDatabaseObjectImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/BasicAuxiliaryDatabaseObjectImpl.java
deleted file mode 100644
index 07389d08ca..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/BasicAuxiliaryDatabaseObjectImpl.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.Set;
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class BasicAuxiliaryDatabaseObjectImpl extends AbstractAuxiliaryDatabaseObject {
-	private static final String CATALOG_NAME_PLACEHOLDER = "${catalog}";
-	private static final String SCHEMA_NAME_PLACEHOLDER = "${schema}";
-	private final Schema defaultSchema;
-	private final String createString;
-	private final String dropString;
-
-	public BasicAuxiliaryDatabaseObjectImpl(
-			Schema defaultSchema,
-			String createString,
-			String dropString,
-			Set<String> dialectScopes) {
-		super( dialectScopes );
-		// keep track of the default schema and the raw create/drop strings;
-		// we may want to allow copying into a database with a different default schema in the future;
-		this.defaultSchema = defaultSchema;
-		this.createString = createString;
-		this.dropString = dropString;
-	}
-
-	@Override
-	public String[] sqlCreateStrings(Dialect dialect) {
-		return new String[] { injectCatalogAndSchema( createString, defaultSchema ) };
-	}
-
-	@Override
-	public String[] sqlDropStrings(Dialect dialect) {
-		return new String[] { injectCatalogAndSchema( dropString, defaultSchema ) };
-	}
-
-	private static String injectCatalogAndSchema(String ddlString, Schema schema) {
-		String rtn = StringHelper.replace( ddlString, CATALOG_NAME_PLACEHOLDER, schema.getName().getCatalog().getName() );
-		rtn = StringHelper.replace( rtn, SCHEMA_NAME_PLACEHOLDER, schema.getName().getSchema().getName() );
-		return rtn;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/CheckConstraint.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/CheckConstraint.java
deleted file mode 100644
index 52c0a5c129..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/CheckConstraint.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * TODO : javadoc
- *
- * @author Steve Ebersole
- */
-public class CheckConstraint {
-	private final Table table;
-	private String name;
-	private String condition;
-
-	public CheckConstraint(Table table) {
-		this.table = table;
-	}
-
-	public CheckConstraint(Table table, String name, String condition) {
-		this.table = table;
-		this.name = name;
-		this.condition = condition;
-	}
-
-	public String getCondition() {
-		return condition;
-	}
-
-	public void setCondition(String condition) {
-		this.condition = condition;
-	}
-
-	/**
-	 * Obtain the table to which this constraint applies.
-	 *
-	 * @return The constrained table.
-	 */
-	public Table getTable() {
-		return table;
-	}
-
-	/**
-	 * Obtain the constraint name.
-	 *
-	 * @return the name.
-	 */
-	public String getName() {
-		return name;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Column.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Column.java
deleted file mode 100644
index 577712bc44..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Column.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.MappingException;
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.relational.state.ColumnRelationalState;
-
-/**
- * Models a physical column
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class Column extends AbstractSimpleValue {
-	private final Identifier columnName;
-	private boolean nullable;
-	private boolean unique;
-
-	private String defaultValue;
-	private String checkCondition;
-	private String sqlType;
-
-	private String readFragment;
-	private String writeFragment;
-
-	private String comment;
-
-	private Size size = new Size();
-
-	protected Column(TableSpecification table, int position, String name) {
-		this( table, position, Identifier.toIdentifier( name ) );
-	}
-
-	protected Column(TableSpecification table, int position, Identifier name) {
-		super( table, position );
-		this.columnName = name;
-	}
-
-	public void initialize(ColumnRelationalState state, boolean forceNonNullable, boolean forceUnique) {
-		size.initialize( state.getSize() );
-		nullable = ! forceNonNullable &&  state.isNullable();
-		unique = ! forceUnique && state.isUnique();
-		checkCondition = state.getCheckCondition();
-		defaultValue = state.getDefault();
-		sqlType = state.getSqlType();
-
-		// TODO: this should go into binding instead (I think???)
-		writeFragment = state.getCustomWriteFragment();
-		readFragment = state.getCustomReadFragment();
-		comment = state.getComment();
-		for ( String uniqueKey : state.getUniqueKeys() ) {
-			getTable().getOrCreateUniqueKey( uniqueKey ).addColumn( this );
-		}
-		for ( String index : state.getIndexes() ) {
-			getTable().getOrCreateIndex( index ).addColumn( this );
-		}
-	}
-
-	public Identifier getColumnName() {
-		return columnName;
-	}
-
-	public boolean isNullable() {
-		return nullable;
-	}
-
-	public void setNullable(boolean nullable) {
-		this.nullable = nullable;
-	}
-
-	public boolean isUnique() {
-		return unique;
-	}
-
-	public void setUnique(boolean unique) {
-		this.unique = unique;
-	}
-
-	public String getDefaultValue() {
-		return defaultValue;
-	}
-
-	public void setDefaultValue(String defaultValue) {
-		this.defaultValue = defaultValue;
-	}
-
-	public String getCheckCondition() {
-		return checkCondition;
-	}
-
-	public void setCheckCondition(String checkCondition) {
-		this.checkCondition = checkCondition;
-	}
-
-	public String getSqlType() {
-		return sqlType;
-	}
-
-	public void setSqlType(String sqlType) {
-		this.sqlType = sqlType;
-	}
-
-	public String getReadFragment() {
-		return readFragment;
-	}
-
-	public void setReadFragment(String readFragment) {
-		this.readFragment = readFragment;
-	}
-
-	public String getWriteFragment() {
-		return writeFragment;
-	}
-
-	public void setWriteFragment(String writeFragment) {
-		this.writeFragment = writeFragment;
-	}
-
-	public String getComment() {
-		return comment;
-	}
-
-	public void setComment(String comment) {
-		this.comment = comment;
-	}
-
-	public Size getSize() {
-		return size;
-	}
-
-	public void setSize(Size size) {
-		this.size = size;
-	}
-
-	@Override
-	public String toLoggableString() {
-		return getTable().getLoggableValueQualifier() + '.' + getColumnName();
-	}
-
-	@Override
-	public String getAlias(Dialect dialect) {
-		String alias = columnName.getName();
-		int lastLetter = StringHelper.lastIndexOfLetter( columnName.getName() );
-		if ( lastLetter == -1 ) {
-			alias = "column";
-		}
-		boolean useRawName =
-				columnName.getName().equals( alias ) &&
-						alias.length() <= dialect.getMaxAliasLength() &&
-						! columnName.isQuoted() &&
-						! columnName.getName().toLowerCase().equals( "rowid" );
-		if ( ! useRawName ) {
-			String unique =
-					new StringBuilder()
-					.append( getPosition() )
-					.append( '_' )
-					.append( getTable().getTableNumber() )
-					.append( '_' )
-					.toString();
-			if ( unique.length() >= dialect.getMaxAliasLength() ) {
-				throw new MappingException(
-						"Unique suffix [" + unique + "] length must be less than maximum [" + dialect.getMaxAliasLength() + "]"
-				);
-			}
-			if ( alias.length() + unique.length() > dialect.getMaxAliasLength()) {
-				alias = alias.substring( 0, dialect.getMaxAliasLength() - unique.length() );
-			}
-			alias = alias + unique;
-		}
-		return alias;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Constraint.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Constraint.java
deleted file mode 100644
index 5587ebcbd6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Constraint.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * Basic contract for the types of constraints we fully support as metadata constructs:<ul>
- * <li>primary key</li>
- * <li>foreign key</li>
- * <li>unique constraint</li>
- * </ul>
- *
- * @author Steve Ebersole
- */
-public interface Constraint extends Exportable {
-	/**
-	 * Obtain the table to which this constraint applies.
-	 *
-	 * @return The constrained table.
-	 */
-	public TableSpecification getTable();
-
-	/**
-	 * Obtain the constraint name.
-	 *
-	 * @return the name.
-	 */
-	public String getName();
-
-	/**
-	 * Obtain the columns that are part of this constraint.
-	 *
-	 * @return The constrained columns.
-	 */
-	public Iterable<Column> getColumns();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Database.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Database.java
deleted file mode 100644
index 3291b967ed..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Database.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.MappingException;
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.Metadata;
-
-/**
- * Represents a database and manages the named schema/catalog pairs defined within.
- *
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class Database {
-	private final Schema.Name implicitSchemaName;
-
-	private final Map<Schema.Name,Schema> schemaMap = new HashMap<Schema.Name, Schema>();
-	private final List<AuxiliaryDatabaseObject> auxiliaryDatabaseObjects = new ArrayList<AuxiliaryDatabaseObject>();
-
-	public Database(Metadata.Options options) {
-		String schemaName = options.getDefaultSchemaName();
-		String catalogName = options.getDefaultCatalogName();
-		if ( options.isGloballyQuotedIdentifiers() ) {
-			schemaName = StringHelper.quote( schemaName );
-			catalogName = StringHelper.quote( catalogName );
-		}
-		implicitSchemaName = new Schema.Name( schemaName, catalogName );
-		makeSchema( implicitSchemaName );
-	}
-
-	public Schema getDefaultSchema() {
-		return schemaMap.get( implicitSchemaName );
-	}
-
-	public Schema locateSchema(Schema.Name name) {
-		if ( name.getSchema() == null && name.getCatalog() == null ) {
-			return getDefaultSchema();
-		}
-		Schema schema = schemaMap.get( name );
-		if ( schema == null ) {
-			schema = makeSchema( name );
-		}
-		return schema;
-	}
-
-	private Schema makeSchema(Schema.Name name) {
-		Schema schema;
-		schema = new Schema( name );
-		schemaMap.put( name, schema );
-		return schema;
-	}
-
-	public Schema getSchema(Identifier schema, Identifier catalog) {
-		return locateSchema( new Schema.Name( schema, catalog ) );
-	}
-
-	public Schema getSchema(String schema, String catalog) {
-		return locateSchema( new Schema.Name( Identifier.toIdentifier( schema ), Identifier.toIdentifier( catalog ) ) );
-	}
-
-	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject auxiliaryDatabaseObject) {
-		if ( auxiliaryDatabaseObject == null ) {
-			throw new IllegalArgumentException( "Auxiliary database object is null." );
-		}
-		auxiliaryDatabaseObjects.add( auxiliaryDatabaseObject );
-	}
-
-	public Iterable<AuxiliaryDatabaseObject> getAuxiliaryDatabaseObjects() {
-		return auxiliaryDatabaseObjects;
-	}
-
-	public String[] generateSchemaCreationScript(Dialect dialect) {
-		Set<String> exportIdentifiers = new HashSet<String>( 50 );
-		List<String> script = new ArrayList<String>( 50 );
-
-		for ( Schema schema : schemaMap.values() ) {
-			// TODO: create schema/catalog???
-			for ( Table table : schema.getTables() ) {
-				addSqlCreateStrings( dialect, exportIdentifiers, script, table );
-			}
-		}
-
-		for ( Schema schema : schemaMap.values() ) {
-			for ( Table table : schema.getTables() ) {
-
-				for  ( UniqueKey uniqueKey : table.getUniqueKeys() ) {
-					addSqlCreateStrings( dialect, exportIdentifiers, script, uniqueKey );
-				}
-
-				for ( Index index : table.getIndexes() ) {
-					addSqlCreateStrings( dialect, exportIdentifiers, script, index );
-				}
-
-				if ( dialect.hasAlterTable() ) {
-					for ( ForeignKey foreignKey : table.getForeignKeys() ) {
-						// only add the foreign key if its target is a physical table
-						if ( Table.class.isInstance( foreignKey.getTargetTable() ) ) {
-							addSqlCreateStrings( dialect, exportIdentifiers, script, foreignKey );
-						}
-					}
-				}
-
-			}
-		}
-
-		// TODO: add sql create strings from PersistentIdentifierGenerator.sqlCreateStrings()
-
-		for ( AuxiliaryDatabaseObject auxiliaryDatabaseObject : auxiliaryDatabaseObjects ) {
-			if ( auxiliaryDatabaseObject.appliesToDialect( dialect ) ) {
-				addSqlCreateStrings( dialect, exportIdentifiers, script, auxiliaryDatabaseObject );
-			}
-		}
-
-		return ArrayHelper.toStringArray( script );
-	}
-
-	public String[] generateDropSchemaScript(Dialect dialect) {
-		Set<String> exportIdentifiers = new HashSet<String>( 50 );
-		List<String> script = new ArrayList<String>( 50 );
-
-
-		// drop them in reverse order in case db needs it done that way...
-		for ( int i = auxiliaryDatabaseObjects.size() - 1 ; i >= 0 ; i-- ) {
-			AuxiliaryDatabaseObject object = auxiliaryDatabaseObjects.get( i );
-			if ( object.appliesToDialect( dialect ) ) {
-				addSqlDropStrings( dialect, exportIdentifiers, script, object );
-			}
-		}
-
-		if ( dialect.dropConstraints() ) {
-			for ( Schema schema : schemaMap.values() ) {
-				for ( Table table : schema.getTables() ) {
-					for ( ForeignKey foreignKey : table.getForeignKeys() ) {
-						// only include foreign key if the target table is physical
-						if ( foreignKey.getTargetTable() instanceof Table ) {
-							addSqlDropStrings( dialect, exportIdentifiers, script, foreignKey );
-						}
-					}
-				}
-			}
-		}
-
-		for ( Schema schema : schemaMap.values() ) {
-			for ( Table table : schema.getTables() ) {
-				addSqlDropStrings( dialect, exportIdentifiers, script, table );
-			}
-		}
-
-		// TODO: add sql drop strings from PersistentIdentifierGenerator.sqlCreateStrings()
-
-		// TODO: drop schemas/catalogs???
-
-		return ArrayHelper.toStringArray( script );
-	}
-
-	private static void addSqlDropStrings(
-			Dialect dialect,
-			Set<String> exportIdentifiers,
-			List<String> script,
-			Exportable exportable) {
-		addSqlStrings(
-				exportIdentifiers, script, exportable.getExportIdentifier(), exportable.sqlDropStrings( dialect )
-		);
-	}
-
-	private static void addSqlCreateStrings(
-			Dialect dialect,
-			Set<String> exportIdentifiers,
-			List<String> script,
-			Exportable exportable) {
-		addSqlStrings(
-				exportIdentifiers, script, exportable.getExportIdentifier(), exportable.sqlCreateStrings( dialect )
-		);
-	}
-
-	private static void addSqlStrings(
-			Set<String> exportIdentifiers,
-			List<String> script,
-			String exportIdentifier,
-			String[] sqlStrings) {
-		if ( sqlStrings == null ) {
-			return;
-		}
-		if ( exportIdentifiers.contains( exportIdentifier ) ) {
-			throw new MappingException(
-					"SQL strings added more than once for: " + exportIdentifier
-			);
-		}
-		exportIdentifiers.add( exportIdentifier );
-		script.addAll( Arrays.asList( sqlStrings ) );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Datatype.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Datatype.java
deleted file mode 100644
index f0f5189b6d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Datatype.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * Models a JDBC {@link java.sql.Types DATATYPE}
- *
- * @todo Do we somehow link this in with {@link org.hibernate.internal.util.jdbc.TypeInfo} ?
- *
- * @author Steve Ebersole
- */
-public class Datatype {
-	private final int typeCode;
-	private final String typeName;
-	private final Class javaType;
-	private final int hashCode;
-
-	public Datatype(int typeCode, String typeName, Class javaType) {
-		this.typeCode = typeCode;
-		this.typeName = typeName;
-		this.javaType = javaType;
-		this.hashCode = generateHashCode();
-	}
-
-    private int generateHashCode() {
-        int result = typeCode;
-        if ( typeName != null ) {
-            result = 31 * result + typeName.hashCode();
-        }
-        if ( javaType != null ) {
-            result = 31 * result + javaType.hashCode();
-        }
-        return result;
-    }
-
-    public int getTypeCode() {
-		return typeCode;
-	}
-
-	public String getTypeName() {
-		return typeName;
-	}
-
-	public Class getJavaType() {
-		return javaType;
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		Datatype datatype = (Datatype) o;
-
-		return typeCode == datatype.typeCode
-				&& javaType.equals( datatype.javaType )
-				&& typeName.equals( datatype.typeName );
-
-	}
-
-	@Override
-	public int hashCode() {
-		return hashCode;
-	}
-
-	@Override
-	public String toString() {
-		return super.toString() + "[code=" + typeCode + ", name=" + typeName + ", javaClass=" + javaType.getName() + "]";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/DerivedValue.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/DerivedValue.java
deleted file mode 100644
index 2f39332ac7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/DerivedValue.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models a value expression.  It is the result of a <tt>formula</tt> mapping.
- *
- * @author Steve Ebersole
- */
-public class DerivedValue extends AbstractSimpleValue {
-	private final String expression;
-
-	public DerivedValue(TableSpecification table, int position, String expression) {
-		super( table, position );
-		this.expression = expression;
-	}
-
-	@Override
-	public String toLoggableString() {
-		return getTable().toLoggableString() + ".{derived-column}";
-	}
-
-	@Override
-	public String getAlias(Dialect dialect) {
-		return "formula" + Integer.toString( getPosition() ) + '_';
-	}
-
-	/**
-	 * Get the value expression.
-	 * @return the value expression
-	 */
-	public String getExpression() {
-		return expression;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Exportable.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Exportable.java
deleted file mode 100644
index 7d720c2322..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Exportable.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Contract for entities (in the ERD sense) which can be exported via {@code CREATE}, {@code ALTER}, etc
- *
- * @author Steve Ebersole
- */
-public interface Exportable {
-	/**
-	 * Get a unique identifier to make sure we are not exporting the same database structure multiple times.
-	 *
-	 * @return The exporting identifier.
-	 */
-	public String getExportIdentifier();
-
-	/**
-	 * Gets the SQL strings for creating the database object.
-	 *
-	 * @param dialect The dialect for which to generate the SQL creation strings
-	 *
-	 * @return the SQL strings for creating the database object.
-	 */
-	public String[] sqlCreateStrings(Dialect dialect);
-
-	/**
-	 * Gets the SQL strings for dropping the database object.
-	 *
-	 * @param dialect The dialect for which to generate the SQL drop strings
-	 *
-	 * @return the SQL strings for dropping the database object.
-	 */
-	public String[] sqlDropStrings(Dialect dialect);
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ForeignKey.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ForeignKey.java
deleted file mode 100644
index bcb8c84510..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ForeignKey.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.MappingException;
-import org.hibernate.dialect.Dialect;
-
-import org.jboss.logging.Logger;
-
-/**
- * Models the notion of a foreign key.
- * <p/>
- * Note that this need not mean a physical foreign key; we just mean a relationship between 2 table
- * specifications.
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class ForeignKey extends AbstractConstraint implements Constraint, Exportable {
-    private static final Logger LOG = Logger.getLogger( ForeignKey.class );
-
-	private static final String ON_DELETE = " on delete ";
-	private static final String ON_UPDATE = " on update ";
-
-	private final TableSpecification targetTable;
-	private List<Column> targetColumns;
-
-	private ReferentialAction deleteRule = ReferentialAction.NO_ACTION;
-	private ReferentialAction updateRule = ReferentialAction.NO_ACTION;
-
-	protected ForeignKey(TableSpecification sourceTable, TableSpecification targetTable, String name) {
-		super( sourceTable, name );
-		this.targetTable = targetTable;
-	}
-
-	protected ForeignKey(TableSpecification sourceTable, TableSpecification targetTable) {
-		this( sourceTable, targetTable, null );
-	}
-
-	public TableSpecification getSourceTable() {
-		return getTable();
-	}
-
-	public TableSpecification getTargetTable() {
-		return targetTable;
-	}
-
-	public Iterable<Column> getSourceColumns() {
-		return getColumns();
-	}
-
-	public Iterable<Column> getTargetColumns() {
-		return targetColumns == null
-				? getTargetTable().getPrimaryKey().getColumns()
-				: targetColumns;
-	}
-
-	@Override
-	public void addColumn(Column column) {
-		addColumnMapping( column, null );
-	}
-
-	public void addColumnMapping(Column sourceColumn, Column targetColumn) {
-		if ( targetColumn == null ) {
-			if ( targetColumns != null ) {
-				LOG.debugf(
-						"Attempt to map column [%s] to no target column after explicit target column(s) named for FK [name=%s]",
-						sourceColumn.toLoggableString(),
-						getName()
-				);
-			}
-		}
-		else {
-			checkTargetTable( targetColumn );
-			if ( targetColumns == null ) {
-				if (!internalColumnAccess().isEmpty()) {
-					LOG.debugf(
-							"Value mapping mismatch as part of FK [table=%s, name=%s] while adding source column [%s]",
-							getTable().toLoggableString(),
-							getName(),
-							sourceColumn.toLoggableString()
-					);
-				}
-				targetColumns = new ArrayList<Column>();
-			}
-			targetColumns.add( targetColumn );
-		}
-		internalAddColumn( sourceColumn );
-	}
-
-	private void checkTargetTable(Column targetColumn) {
-		if ( targetColumn.getTable() != getTargetTable() ) {
-			throw new AssertionFailure(
-					String.format(
-							"Unable to add column to constraint; tables [%s, %s] did not match",
-							targetColumn.getTable().toLoggableString(),
-							getTargetTable().toLoggableString()
-					)
-			);
-		}
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		return getSourceTable().getLoggableValueQualifier() + ".FK-" + getName();
-	}
-
-	public ReferentialAction getDeleteRule() {
-		return deleteRule;
-	}
-
-	public void setDeleteRule(ReferentialAction deleteRule) {
-		this.deleteRule = deleteRule;
-	}
-
-	public ReferentialAction getUpdateRule() {
-		return updateRule;
-	}
-
-	public void setUpdateRule(ReferentialAction updateRule) {
-		this.updateRule = updateRule;
-	}
-
-	@Override
-	public String[] sqlDropStrings(Dialect dialect) {
-		return new String[] {
-				"alter table " +
-						getTable().getQualifiedName( dialect ) +
-						dialect.getDropForeignKeyString() +
-						getName()
-		};
-	}
-
-	public String sqlConstraintStringInAlterTable(Dialect dialect) {
-		String[] columnNames = new String[ getColumnSpan() ];
-		String[] targetColumnNames = new String[ getColumnSpan() ];
-		int i=0;
-		Iterator<Column> itTargetColumn = getTargetColumns().iterator();
-		for ( Column column : getColumns() ) {
-			if ( ! itTargetColumn.hasNext() ) {
-				throw new MappingException( "More constraint columns that foreign key target columns." );
-			}
-			columnNames[i] = column.getColumnName().encloseInQuotesIfQuoted( dialect );
-			targetColumnNames[i] = ( itTargetColumn.next() ).getColumnName().encloseInQuotesIfQuoted( dialect );
-			i++;
-		}
-		if ( itTargetColumn.hasNext() ) {
-			throw new MappingException( "More foreign key target columns than constraint columns." );
-		}
-		StringBuilder sb =
-				new StringBuilder(
-						dialect.getAddForeignKeyConstraintString(
-								getName(),
-								columnNames,
-								targetTable.getQualifiedName( dialect ),
-								targetColumnNames,
-								this.targetColumns == null
-						)
-				);
-		// TODO: If a dialect does not support cascade-delete, can it support other actions? (HHH-6428)
-		// For now, assume not.
-		if ( dialect.supportsCascadeDelete() ) {
-			if ( deleteRule != ReferentialAction.NO_ACTION ) {
-				sb.append( ON_DELETE ).append( deleteRule.getActionString() );
-			}
-			if ( updateRule != ReferentialAction.NO_ACTION ) {
-				sb.append( ON_UPDATE ).append( updateRule.getActionString() );
-			}
-		}
-		return sb.toString();
-	}
-
-	public static enum ReferentialAction {
-		NO_ACTION( "no action" ),
-		CASCADE( "cascade" ),
-		SET_NULL( "set null" ),
-		SET_DEFAULT( "set default" ),
-		RESTRICT( "restrict" );
-
-		private final String actionString;
-
-		private ReferentialAction(String actionString) {
-			this.actionString = actionString;
-		}
-
-		public String getActionString() {
-			return actionString;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Identifier.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Identifier.java
deleted file mode 100644
index 3cd04f9479..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Identifier.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-
-/**
- * Models an identifier (name).
- *
- * @author Steve Ebersole
- */
-public class Identifier {
-	private final String name;
-	private final boolean isQuoted;
-
-	/**
-	 * Means to generate an {@link Identifier} instance from its simple name
-	 *
-	 * @param name The name
-	 *
-	 * @return The identifier form of the name.
-	 */
-	public static Identifier toIdentifier(String name) {
-		if ( StringHelper.isEmpty( name ) ) {
-			return null;
-		}
-		final String trimmedName = name.trim();
-		if ( isQuoted( trimmedName ) ) {
-			final String bareName = trimmedName.substring( 1, trimmedName.length() - 1 );
-			return new Identifier( bareName, true );
-		}
-		else {
-			return new Identifier( trimmedName, false );
-		}
-	}
-
-	public static boolean isQuoted(String name) {
-		return name.startsWith( "`" ) && name.endsWith( "`" );
-	}
-
-	/**
-	 * Constructs an identifier instance.
-	 *
-	 * @param name The identifier text.
-	 * @param quoted Is this a quoted identifier?
-	 */
-	public Identifier(String name, boolean quoted) {
-		if ( StringHelper.isEmpty( name ) ) {
-			throw new IllegalIdentifierException( "Identifier text cannot be null" );
-		}
-		if ( isQuoted( name ) ) {
-			throw new IllegalIdentifierException( "Identifier text should not contain quote markers (`)" );
-		}
-		this.name = name;
-		this.isQuoted = quoted;
-	}
-
-	/**
-	 * Get the identifiers name (text)
-	 *
-	 * @return The name
-	 */
-	public String getName() {
-		return name;
-	}
-
-	/**
-	 * Is this a quoted identifier>
-	 *
-	 * @return True if this is a quote identifier; false otherwise.
-	 */
-	public boolean isQuoted() {
-		return isQuoted;
-	}
-
-	/**
-	 * If this is a quoted identifier, then return the identifier name
-	 * enclosed in dialect-specific open- and end-quotes; otherwise,
-	 * simply return the identifier name.
-	 *
-	 * @param dialect The dialect whose dialect-specific quoting should be used.
-	 * @return if quoted, identifier name enclosed in dialect-specific open- and end-quotes; otherwise, the
-	 * identifier name.
-	 */
-	public String encloseInQuotesIfQuoted(Dialect dialect) {
-		return isQuoted ?
-				new StringBuilder( name.length() + 2 )
-						.append( dialect.openQuote() )
-						.append( name )
-						.append( dialect.closeQuote() )
-						.toString() :
-				name;
-	}
-
-	@Override
-	public String toString() {
-		return isQuoted
-				? '`' + getName() + '`'
-				: getName();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		Identifier that = (Identifier) o;
-
-		return isQuoted == that.isQuoted
-				&& name.equals( that.name );
-	}
-
-	@Override
-	public int hashCode() {
-		return name.hashCode();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/IllegalIdentifierException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/IllegalIdentifierException.java
deleted file mode 100644
index 80ccba8ecc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/IllegalIdentifierException.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.HibernateException;
-
-/**
- * Indicates an attempted use of a name that was deemed illegal
- *
- * @author Steve Ebersole
- */
-public class IllegalIdentifierException extends HibernateException {
-	public IllegalIdentifierException(String s) {
-		super( s );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/InLineView.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/InLineView.java
deleted file mode 100644
index 23651e8d82..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/InLineView.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.Collections;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * A <tt>data container</tt> defined by a <tt>SELECT</tt> statement.  This translates into an inline view in the
- * SQL statements: <code>select ... from (select ... from logical_table_table ...) ...</code>
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class InLineView extends AbstractTableSpecification {
-	private final Schema schema;
-	private final String logicalName;
-	private final String select;
-
-	public InLineView(Schema schema, String logicalName, String select) {
-		this.schema = schema;
-		this.logicalName = logicalName;
-		this.select = select;
-	}
-
-	public Schema getSchema() {
-		return schema;
-	}
-
-	public String getSelect() {
-		return select;
-	}
-
-	@Override
-	public String getLoggableValueQualifier() {
-		return logicalName;
-	}
-
-	@Override
-	public Iterable<Index> getIndexes() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public Index getOrCreateIndex(String name) {
-		throw new UnsupportedOperationException( "Cannot create index on inline view" );
-	}
-
-	@Override
-	public Iterable<UniqueKey> getUniqueKeys() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public UniqueKey getOrCreateUniqueKey(String name) {
-		throw new UnsupportedOperationException( "Cannot create unique-key on inline view" );
-	}
-
-	@Override
-	public Iterable<CheckConstraint> getCheckConstraints() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public void addCheckConstraint(String checkCondition) {
-		throw new UnsupportedOperationException( "Cannot create check constraint on inline view" );
-	}
-
-	@Override
-	public Iterable<String> getComments() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public void addComment(String comment) {
-		throw new UnsupportedOperationException( "Cannot comment on inline view" );
-	}
-
-	@Override
-	public String getQualifiedName(Dialect dialect) {
-		return new StringBuilder( select.length() + 4 )
-				.append( "( " )
-				.append( select )
-				.append( " )" )
-				.toString();
-	}
-
-	@Override
-	public String toLoggableString() {
-		return "{inline-view}";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Index.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Index.java
deleted file mode 100644
index 2eb119c914..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Index.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-
-/**
- * Models a SQL <tt>INDEX</tt>
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class Index extends AbstractConstraint implements Constraint {
-	protected Index(Table table, String name) {
-		super( table, name );
-	}
-
-
-	@Override
-	public String getExportIdentifier() {
-		StringBuilder sb = new StringBuilder( getTable().getLoggableValueQualifier());
-		sb.append( ".IDX" );
-		for ( Column column : getColumns() ) {
-			sb.append( '_' ).append( column.getColumnName().getName() );
-		}
-		return sb.toString();
-	}
-
-	public String[] sqlCreateStrings(Dialect dialect) {
-		return new String[] {
-				buildSqlCreateIndexString(
-						dialect, getName(), getTable(), getColumns(), false
-				)
-		};
-	}
-
-	public static String buildSqlCreateIndexString(
-			Dialect dialect,
-			String name,
-			TableSpecification table,
-			Iterable<Column> columns,
-			boolean unique
-	) {
-		StringBuilder buf = new StringBuilder( "create" )
-				.append( unique ?
-						" unique" :
-						"" )
-				.append( " index " )
-				.append( dialect.qualifyIndexName() ?
-						name :
-						StringHelper.unqualify( name ) )
-				.append( " on " )
-				.append( table.getQualifiedName( dialect ) )
-				.append( " (" );
-		boolean first = true;
-		for ( Column column : columns ) {
-			if ( first ) {
-				first = false;
-			}
-			else {
-				buf.append( ", " );
-			}
-			buf.append( ( column.getColumnName().encloseInQuotesIfQuoted( dialect ) ) );
-		}
-		buf.append( ")" );
-		return buf.toString();
-	}
-
-	public static String buildSqlDropIndexString(
-			Dialect dialect,
-			TableSpecification table,
-			String name
-	) {
-		return "drop index " +
-				StringHelper.qualify(
-						table.getQualifiedName( dialect ),
-						name
-				);
-	}
-
-	public String sqlConstraintStringInAlterTable(Dialect dialect) {
-		StringBuilder buf = new StringBuilder( " index (" );
-		boolean first = true;
-		for ( Column column : getColumns() ) {
-			if ( first ) {
-				first = false;
-			}
-			else {
-				buf.append( ", " );
-			}
-			buf.append( column.getColumnName().encloseInQuotesIfQuoted( dialect ) );
-		}
-		return buf.append( ')' ).toString();
-	}
-
-	public String[] sqlDropStrings(Dialect dialect) {
-		return new String[] {
-				new StringBuilder( "drop index " )
-				.append(
-						StringHelper.qualify(
-								getTable().getQualifiedName( dialect ),
-								getName()
-						)
-				).toString()
-		};
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Loggable.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Loggable.java
deleted file mode 100644
index b49008d244..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Loggable.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * Marker for things which can be logged.
- *
- * @author Steve Ebersole
- */
-public interface Loggable {
-	/**
-	 * Obtain the string representation of this value usable in log statements.
-	 *
-	 * @return The loggable representation
-	 */
-	public String toLoggableString();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ObjectName.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ObjectName.java
deleted file mode 100644
index b27b73ac27..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ObjectName.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.HibernateException;
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models the qualified name of a database object.
- * <p/>
- * Some things to keep in mind wrt catalog/schema:
- * 1) {@link java.sql.DatabaseMetaData#isCatalogAtStart}
- * 2) {@link java.sql.DatabaseMetaData#getCatalogSeparator()}
- *
- * @author Steve Ebersole
- */
-public class ObjectName {
-	// todo - should depend on DatabaseMetaData. For now hard coded (HF)
-	private static String SEPARATOR = ".";
-
-	private final Identifier schema;
-	private final Identifier catalog;
-	private final Identifier name;
-
-	private final String identifier;
-	private final int hashCode;
-
-	/**
-	 * Tries to create an {@code ObjectName} from a name.
-	 *
-	 * @param objectName simple or qualified name of the database object.
-	 */
-	public ObjectName(String objectName) {
-		this(
-				extractSchema( objectName ),
-				extractCatalog( objectName ),
-				extractName( objectName )
-		);
-	}
-
-	public ObjectName(Identifier name) {
-		this( null, null, name );
-	}
-
-	public ObjectName(Schema schema, String name) {
-		this( schema.getName().getSchema(), schema.getName().getCatalog(), Identifier.toIdentifier( name ) );
-	}
-
-	public ObjectName(Schema schema, Identifier name) {
-		this( schema.getName().getSchema(), schema.getName().getCatalog(), name );
-	}
-
-	public ObjectName(String schemaName, String catalogName, String name) {
-		this(
-				Identifier.toIdentifier( schemaName ),
-				Identifier.toIdentifier( catalogName ),
-				Identifier.toIdentifier( name )
-		);
-	}
-
-	/**
-	 * Creates a qualified name reference.
-	 *
-	 * @param schema The in which the object is defined (optional)
-	 * @param catalog The catalog in which the object is defined (optional)
-	 * @param name The name (required)
-	 */
-	public ObjectName(Identifier schema, Identifier catalog, Identifier name) {
-		if ( name == null ) {
-			// Identifier cannot be constructed with an 'empty' name
-			throw new IllegalIdentifierException( "Object name must be specified" );
-		}
-		this.name = name;
-		this.schema = schema;
-		this.catalog = catalog;
-
-		this.identifier = qualify(
-				schema == null ? null : schema.toString(),
-				catalog == null ? null : catalog.toString(),
-				name.toString()
-		);
-
-		int tmpHashCode = schema != null ? schema.hashCode() : 0;
-		tmpHashCode = 31 * tmpHashCode + ( catalog != null ? catalog.hashCode() : 0 );
-		tmpHashCode = 31 * tmpHashCode + name.hashCode();
-		this.hashCode = tmpHashCode;
-	}
-
-	public Identifier getSchema() {
-		return schema;
-	}
-
-	public Identifier getCatalog() {
-		return catalog;
-	}
-
-	public Identifier getName() {
-		return name;
-	}
-
-	public String toText() {
-		return identifier;
-	}
-
-	public String toText(Dialect dialect) {
-		if ( dialect == null ) {
-			throw new IllegalArgumentException( "dialect must be non-null." );
-		}
-		return qualify(
-				encloseInQuotesIfQuoted( schema, dialect ),
-				encloseInQuotesIfQuoted( catalog, dialect ),
-				encloseInQuotesIfQuoted( name, dialect )
-		);
-	}
-
-	private static String encloseInQuotesIfQuoted(Identifier identifier, Dialect dialect) {
-		return identifier == null ?
-				null :
-				identifier.encloseInQuotesIfQuoted( dialect );
-	}
-
-	private static String qualify(String schema, String catalog, String name) {
-		StringBuilder buff = new StringBuilder( name );
-		if ( catalog != null ) {
-			buff.insert( 0, catalog + '.' );
-		}
-		if ( schema != null ) {
-			buff.insert( 0, schema + '.' );
-		}
-		return buff.toString();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		ObjectName that = (ObjectName) o;
-
-		return name.equals( that.name )
-				&& areEqual( catalog, that.catalog )
-				&& areEqual( schema, that.schema );
-	}
-
-	@Override
-	public int hashCode() {
-		return hashCode;
-	}
-
-
-	@Override
-	public String toString() {
-		return "ObjectName{" +
-				"name='" + name + '\'' +
-				", schema='" + schema + '\'' +
-				", catalog='" + catalog + '\'' +
-				'}';
-	}
-
-	private boolean areEqual(Identifier one, Identifier other) {
-		return one == null
-				? other == null
-				: one.equals( other );
-	}
-
-	private static String extractSchema(String qualifiedName) {
-		if ( qualifiedName == null ) {
-			return null;
-		}
-		String[] tokens = qualifiedName.split( SEPARATOR );
-		if ( tokens.length == 0 || tokens.length == 1 ) {
-			return null;
-		}
-		else if ( tokens.length == 2 ) {
-			// todo - this case needs to be refined w/ help of  DatabaseMetaData (HF)
-			return null;
-		}
-		else if ( tokens.length == 3 ) {
-			return tokens[0];
-		}
-		else {
-			throw new HibernateException( "Unable to parse object name: " + qualifiedName );
-		}
-	}
-
-	private static String extractCatalog(String qualifiedName) {
-		if ( qualifiedName == null ) {
-			return null;
-		}
-		String[] tokens = qualifiedName.split( SEPARATOR );
-		if ( tokens.length == 0 || tokens.length == 1 ) {
-			return null;
-		}
-		else if ( tokens.length == 2 ) {
-			// todo - this case needs to be refined w/ help of  DatabaseMetaData (HF)
-			return null;
-		}
-		else if ( tokens.length == 3 ) {
-			return tokens[1];
-		}
-		else {
-			throw new HibernateException( "Unable to parse object name: " + qualifiedName );
-		}
-	}
-
-	private static String extractName(String qualifiedName) {
-		if ( qualifiedName == null ) {
-			return null;
-		}
-		String[] tokens = qualifiedName.split( SEPARATOR );
-		if ( tokens.length == 0 ) {
-			return qualifiedName;
-		}
-		else {
-			return tokens[tokens.length - 1];
-		}
-	}
-}
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/PrimaryKey.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/PrimaryKey.java
deleted file mode 100644
index 3962571ef4..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/PrimaryKey.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models a table's primary key.
- * <p/>
- * NOTE : This need not be a physical primary key; we just mean a column or columns which uniquely identify rows in
- * the table.  Of course it is recommended to define proper integrity constraints, including primary keys.
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class PrimaryKey extends AbstractConstraint implements Constraint, Exportable {
-	// IMPL NOTE : I override the name behavior here because:
-	//		(1) primary keys are not required to be named.
-	//		(2) because a primary key is required for each table, it is easier to allow setting the constraint name
-	// 			later in terms of building the metamodel
-	//
-	// todo : default name?  {TABLE_NAME}_PK maybe?
-	private String name;
-
-	protected PrimaryKey(TableSpecification table) {
-		super( table, null );
-	}
-
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		return getTable().getLoggableValueQualifier() + ".PK";
-	}
-
-	public String sqlConstraintStringInCreateTable(Dialect dialect) {
-		StringBuilder buf = new StringBuilder("primary key (");
-		boolean first = true;
-		for ( Column column : getColumns() ) {
-			if ( first ) {
-				first = false;
-			}
-			else {
-				buf.append(", ");
-			}
-			buf.append( column.getColumnName().encloseInQuotesIfQuoted( dialect ) );
-		}
-		return buf.append(')').toString();
-	}
-
-	public String sqlConstraintStringInAlterTable(Dialect dialect) {
-		StringBuilder buf = new StringBuilder(
-			dialect.getAddPrimaryKeyConstraintString( getName() )
-		).append('(');
-		boolean first = true;
-		for ( Column column : getColumns() ) {
-			if ( first ) {
-				first = false;
-			}
-			else {
-				buf.append(", ");
-			}
-			buf.append( column.getColumnName().encloseInQuotesIfQuoted( dialect ) );
-		}
-		return buf.append(')').toString();
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Schema.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Schema.java
deleted file mode 100644
index 25a36aac8b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Schema.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Represents a named schema/catalog pair and manages objects defined within.
- *
- * @author Steve Ebersole
- */
-public class Schema {
-	private final Name name;
-	private Map<String, InLineView> inLineViews = new HashMap<String, InLineView>();
-	private Map<Identifier, Table> tables = new HashMap<Identifier, Table>();
-
-	public Schema(Name name) {
-		this.name = name;
-	}
-
-	public Schema(Identifier schema, Identifier catalog) {
-		this( new Name( schema, catalog ) );
-	}
-
-	public Name getName() {
-		return name;
-	}
-
-	public Table locateTable(Identifier name) {
-		return tables.get( name );
-	}
-
-	public Table createTable(Identifier name) {
-		Table table = new Table( this, name );
-		tables.put( name, table );
-		return table;
-	}
-
-	public Table locateOrCreateTable(Identifier name) {
-		final Table existing = locateTable( name );
-		if ( existing == null ) {
-			return createTable( name );
-		}
-		return existing;
-	}
-
-	public Iterable<Table> getTables() {
-		return tables.values();
-	}
-
-	public InLineView getInLineView(String logicalName) {
-		return inLineViews.get( logicalName );
-	}
-
-	public InLineView createInLineView(String logicalName, String subSelect) {
-		InLineView inLineView = new InLineView( this, logicalName, subSelect );
-		inLineViews.put( logicalName, inLineView );
-		return inLineView;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "Schema" );
-		sb.append( "{name=" ).append( name );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		Schema schema = (Schema) o;
-
-		if ( name != null ? !name.equals( schema.name ) : schema.name != null ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public int hashCode() {
-		return name != null ? name.hashCode() : 0;
-	}
-
-	public static class Name {
-		private final Identifier schema;
-		private final Identifier catalog;
-
-		public Name(Identifier schema, Identifier catalog) {
-			this.schema = schema;
-			this.catalog = catalog;
-		}
-
-		public Name(String schema, String catalog) {
-			this( Identifier.toIdentifier( schema ), Identifier.toIdentifier( catalog ) );
-		}
-
-		public Identifier getSchema() {
-			return schema;
-		}
-
-		public Identifier getCatalog() {
-			return catalog;
-		}
-
-		@Override
-		public String toString() {
-			final StringBuilder sb = new StringBuilder();
-			sb.append( "Name" );
-			sb.append( "{schema=" ).append( schema );
-			sb.append( ", catalog=" ).append( catalog );
-			sb.append( '}' );
-			return sb.toString();
-		}
-
-		@Override
-		public boolean equals(Object o) {
-			if ( this == o ) {
-				return true;
-			}
-			if ( o == null || getClass() != o.getClass() ) {
-				return false;
-			}
-
-			Name name = (Name) o;
-
-			if ( catalog != null ? !catalog.equals( name.catalog ) : name.catalog != null ) {
-				return false;
-			}
-			if ( schema != null ? !schema.equals( name.schema ) : name.schema != null ) {
-				return false;
-			}
-
-			return true;
-		}
-
-		@Override
-		public int hashCode() {
-			int result = schema != null ? schema.hashCode() : 0;
-			result = 31 * result + ( catalog != null ? catalog.hashCode() : 0 );
-			return result;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Sequence.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Sequence.java
deleted file mode 100644
index fcaf7b886d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Sequence.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.MappingException;
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models a database {@code SEQUENCE}.
- *
- * @author Steve Ebersole
- */
-public class Sequence implements Exportable {
-	private final Schema schema;
-	private final String name;
-	private final String qualifiedName;
-	private int initialValue = 1;
-	private int incrementSize = 1;
-
-	public Sequence(Schema schema, String name) {
-		this.schema = schema;
-		this.name = name;
-		this.qualifiedName = new ObjectName( schema, name ).toText();
-	}
-
-	public Sequence(Schema schema, String name, int initialValue, int incrementSize) {
-		this( schema, name );
-		this.initialValue = initialValue;
-		this.incrementSize = incrementSize;
-	}
-
-	public Schema getSchema() {
-		return schema;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		return qualifiedName;
-	}
-
-	public int getInitialValue() {
-		return initialValue;
-	}
-
-	public int getIncrementSize() {
-		return incrementSize;
-	}
-
-	@Override
-	public String[] sqlCreateStrings(Dialect dialect) throws MappingException {
-		return dialect.getCreateSequenceStrings( name, initialValue,incrementSize );
-	}
-
-	@Override
-	public String[] sqlDropStrings(Dialect dialect) throws MappingException {
-		return dialect.getDropSequenceStrings( name );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/SimpleValue.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/SimpleValue.java
deleted file mode 100644
index 8cc4854bc9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/SimpleValue.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models a simple, non-compound value.
- *
- * @author Steve Ebersole
- */
-public interface SimpleValue extends Value {
-	/**
-	 * Retrieve the datatype of this value.
-	 *
-	 * @return The value's datatype
-	 */
-	public Datatype getDatatype();
-
-	/**
-	 * Set the datatype of this value.
-	 *
-	 * @param datatype The value's datatype
-	 */
-	public void setDatatype(Datatype datatype);
-
-	/**
-	 * For any column name, generate an alias that is unique
-	 * to that column name, unique across tables, and within
-	 * alias size constraints determined by
-	 * {@link org.hibernate.dialect.Dialect#getMaxAliasLength()}.
-	 *
-	 * @param dialect the dialect.
-	 * @return the alias.
-	 */
-	public String getAlias(Dialect dialect);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Table.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Table.java
deleted file mode 100644
index f88c2fdf08..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Table.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models the concept of a relational <tt>TABLE</tt> (or <tt>VIEW</tt>).
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class Table extends AbstractTableSpecification implements Exportable {
-	private final Schema database;
-	private final Identifier tableName;
-	private final ObjectName objectName;
-	private final String qualifiedName;
-
-	private final LinkedHashMap<String,Index> indexes = new LinkedHashMap<String,Index>();
-	private final LinkedHashMap<String,UniqueKey> uniqueKeys = new LinkedHashMap<String,UniqueKey>();
-	private final List<CheckConstraint> checkConstraints = new ArrayList<CheckConstraint>();
-	private final List<String> comments = new ArrayList<String>();
-
-	public Table(Schema database, String tableName) {
-		this( database, Identifier.toIdentifier( tableName ) );
-	}
-
-	public Table(Schema database, Identifier tableName) {
-		this.database = database;
-		this.tableName = tableName;
-		objectName = new ObjectName( database.getName().getSchema(), database.getName().getCatalog(), tableName );
-		this.qualifiedName = objectName.toText();
-	}
-
-	@Override
-	public Schema getSchema() {
-		return database;
-	}
-
-	public Identifier getTableName() {
-		return tableName;
-	}
-
-	@Override
-	public String getLoggableValueQualifier() {
-		return qualifiedName;
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		return qualifiedName;
-	}
-
-	@Override
-	public String toLoggableString() {
-		return qualifiedName;
-	}
-
-	@Override
-	public Iterable<Index> getIndexes() {
-		return indexes.values();
-	}
-
-	public Index getOrCreateIndex(String name) {
-		if( indexes.containsKey( name ) ){
-			return indexes.get( name );
-		}
-		Index index = new Index( this, name );
-		indexes.put(name, index );
-		return index;
-	}
-
-	@Override
-	public Iterable<UniqueKey> getUniqueKeys() {
-		return uniqueKeys.values();
-	}
-
-	public UniqueKey getOrCreateUniqueKey(String name) {
-		if( uniqueKeys.containsKey( name ) ){
-			return uniqueKeys.get( name );
-		}
-		UniqueKey uniqueKey = new UniqueKey( this, name );
-		uniqueKeys.put(name, uniqueKey );
-		return uniqueKey;
-	}
-
-	@Override
-	public Iterable<CheckConstraint> getCheckConstraints() {
-		return checkConstraints;
-	}
-
-	@Override
-	public void addCheckConstraint(String checkCondition) {
-        //todo ? StringHelper.isEmpty( checkCondition );
-        //todo default name?
-		checkConstraints.add( new CheckConstraint( this, "", checkCondition ) );
-	}
-
-	@Override
-	public Iterable<String> getComments() {
-		return comments;
-	}
-
-	@Override
-	public void addComment(String comment) {
-		comments.add( comment );
-	}
-
-	@Override
-	public String getQualifiedName(Dialect dialect) {
-		return objectName.toText( dialect );
-	}
-
-	public String[] sqlCreateStrings(Dialect dialect) {
-		boolean hasPrimaryKey = getPrimaryKey().getColumns().iterator().hasNext();
-		StringBuilder buf =
-				new StringBuilder(
-						hasPrimaryKey ? dialect.getCreateTableString() : dialect.getCreateMultisetTableString() )
-				.append( ' ' )
-				.append( objectName.toText( dialect ) )
-				.append( " (" );
-
-
-		// TODO: fix this when identity columns are supported by new metadata (HHH-6436)
-		// for now, assume false
-		//boolean identityColumn = idValue != null && idValue.isIdentityColumn( metadata.getIdentifierGeneratorFactory(), dialect );
-		boolean isPrimaryKeyIdentity = false;
-
-		// Try to find out the name of the primary key to create it as identity if the IdentityGenerator is used
-		String pkColName = null;
-		if ( hasPrimaryKey && isPrimaryKeyIdentity ) {
-			Column pkColumn = getPrimaryKey().getColumns().iterator().next();
-			pkColName = pkColumn.getColumnName().encloseInQuotesIfQuoted( dialect );
-		}
-
-		boolean isFirst = true;
-		for ( SimpleValue simpleValue : values() ) {
-			if ( ! Column.class.isInstance( simpleValue ) ) {
-				continue;
-			}
-			if ( isFirst ) {
-				isFirst = false;
-			}
-			else {
-				buf.append( ", " );
-			}
-			Column col = ( Column ) simpleValue;
-			String colName = col.getColumnName().encloseInQuotesIfQuoted( dialect );
-
-			buf.append( colName ).append( ' ' );
-
-			if ( isPrimaryKeyIdentity && colName.equals( pkColName ) ) {
-				// to support dialects that have their own identity data type
-				if ( dialect.hasDataTypeInIdentityColumn() ) {
-					buf.append( getTypeString( col, dialect ) );
-				}
-				buf.append( ' ' )
-						.append( dialect.getIdentityColumnString( col.getDatatype().getTypeCode() ) );
-			}
-			else {
-				buf.append( getTypeString( col, dialect ) );
-
-				String defaultValue = col.getDefaultValue();
-				if ( defaultValue != null ) {
-					buf.append( " default " ).append( defaultValue );
-				}
-
-				if ( col.isNullable() ) {
-					buf.append( dialect.getNullColumnString() );
-				}
-				else {
-					buf.append( " not null" );
-				}
-
-			}
-
-			if ( col.isUnique() ) {
-				UniqueKey uk = getOrCreateUniqueKey( col.getColumnName()
-						.encloseInQuotesIfQuoted( dialect ) + '_' );
-				uk.addColumn( col );
-				buf.append( dialect.getUniqueDelegate()
-						.getColumnDefinitionUniquenessFragment( col ) );
-			}
-
-			if ( col.getCheckCondition() != null && dialect.supportsColumnCheck() ) {
-				buf.append( " check (" )
-						.append( col.getCheckCondition() )
-						.append( ")" );
-			}
-
-			String columnComment = col.getComment();
-			if ( columnComment != null ) {
-				buf.append( dialect.getColumnComment( columnComment ) );
-			}
-		}
-		if ( hasPrimaryKey ) {
-			buf.append( ", " )
-					.append( getPrimaryKey().sqlConstraintStringInCreateTable( dialect ) );
-		}
-
-		buf.append( dialect.getUniqueDelegate().getTableCreationUniqueConstraintsFragment( this ) );
-
-		if ( dialect.supportsTableCheck() ) {
-			for ( CheckConstraint checkConstraint : checkConstraints ) {
-				buf.append( ", check (" )
-						.append( checkConstraint )
-						.append( ')' );
-			}
-		}
-
-		buf.append( ')' );
-		buf.append( dialect.getTableTypeString() );
-
-		String[] sqlStrings = new String[ comments.size() + 1 ];
-		sqlStrings[ 0 ] = buf.toString();
-
-		for ( int i = 0 ; i < comments.size(); i++ ) {
-			sqlStrings[ i + 1 ] = dialect.getTableComment( comments.get( i ) );
-		}
-
-		return sqlStrings;
-	}
-
-	private static String getTypeString(Column col, Dialect dialect) {
-		String typeString = null;
-		if ( col.getSqlType() != null ) {
-			typeString = col.getSqlType();
-		}
-		else {
-			Size size = col.getSize() == null ?
-					new Size( ) :
-					col.getSize();
-
-			typeString = dialect.getTypeName(
-						col.getDatatype().getTypeCode(),
-						size.getLength(),
-						size.getPrecision(),
-						size.getScale()
-			);
-		}
-		return typeString;
-	}
-
-	@Override
-	public String[] sqlDropStrings(Dialect dialect) {
-		return new String[] { dialect.getDropTableString( getQualifiedName( dialect ) ) };
-	}
-
-	@Override
-	public String toString() {
-		return "Table{name=" + qualifiedName + '}';
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/TableSpecification.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/TableSpecification.java
deleted file mode 100644
index 69fbd02d55..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/TableSpecification.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-
-/**
- * Models what ANSI SQL terms a table specification which is a table or a view or an inline view.
- *
- * @author Steve Ebersole
- */
-public interface TableSpecification extends ValueContainer, Loggable {
-	/**
-	 * Obtain a reference to the schema to which this table specification belongs.
-	 *
-	 * @return The schema to which this table specification belongs.
-	 */
-	public Schema getSchema();
-
-	/**
-	 * Get the table number.
-	 *
-	 * @return the table number.
-	 */
-	public int getTableNumber();
-
-	/**
-	 * Get the primary key definition for this table spec.
-	 *
-	 * @return The PK definition.
-	 */
-	public PrimaryKey getPrimaryKey();
-
-	/**
-	 * Factory method for creating a {@link Column} associated with this container.
-	 *
-	 * @param name The column name
-	 *
-	 * @return The generated column
-	 */
-	public Column locateOrCreateColumn(String name);
-
-	/**
-	 * Factory method for creating a {@link Column} associated with this container.
-	 *
-	 * @param name The column name
-	 *
-	 * @return The generated column
-	 */
-	public Tuple createTuple(String name);
-
-	/**
-	 * Factory method for creating a {@link DerivedValue} associated with this container.
-	 *
-	 * @param fragment The value expression
-	 *
-	 * @return The generated value.
-	 */
-	public DerivedValue locateOrCreateDerivedValue(String fragment);
-
-	public Iterable<ForeignKey> getForeignKeys();
-
-	public ForeignKey createForeignKey(TableSpecification targetTable, String name);
-
-	public Iterable<Index> getIndexes();
-
-	public Index getOrCreateIndex(String name);
-
-	public Iterable<UniqueKey> getUniqueKeys();
-
-	public UniqueKey getOrCreateUniqueKey(String name);
-
-	public Iterable<CheckConstraint> getCheckConstraints();
-
-	public void addCheckConstraint(String checkCondition);
-
-	public Iterable<String> getComments();
-
-	public void addComment(String comment);
-
-	public String getQualifiedName(Dialect dialect);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Tuple.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Tuple.java
deleted file mode 100644
index c566dead53..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Tuple.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.util.LinkedHashSet;
-
-/**
- * Models a compound value (a tuple or row-value-constructor is SQL terms).  It is both a {@link Value} and
- * a {@link ValueContainer} simultaneously.
- * <p/>
- * IMPL NOTE : in terms of the tables themselves, SQL has no notion of a tuple/compound-value.  We simply model
- * it this way because:
- * <ul>
- * <li>it is a cleaner mapping to the logical model</li>
- * <li>it allows more meaningful traversals from simple values back up to table through any intermediate tuples
- * because it gives us a better understanding of the model.</li>
- * <li>it better conveys intent</li>
- * <li>it adds richness to the model</li>
- * </ul>
- *
- * @author Steve Ebersole
- */
-public class Tuple implements Value, ValueContainer, Loggable {
-	private final TableSpecification table;
-	private final String name;
-	private final LinkedHashSet<SimpleValue> values = new LinkedHashSet<SimpleValue>();
-
-	public Tuple(TableSpecification table, String name) {
-		this.table = table;
-		this.name = name;
-	}
-
-	@Override
-	public TableSpecification getTable() {
-		return table;
-	}
-
-	public int valuesSpan() {
-		return values.size();
-	}
-
-	@Override
-	public Iterable<SimpleValue> values() {
-		return values;
-	}
-
-	public void addValue(SimpleValue value) {
-		if ( ! value.getTable().equals( getTable() ) ) {
-			throw new IllegalArgumentException( "Tuple can only group values from same table" );
-		}
-		values.add( value );
-	}
-
-	@Override
-	public String getLoggableValueQualifier() {
-		return getTable().getLoggableValueQualifier() + '.' + name + "{tuple}";
-	}
-
-	@Override
-	public String toLoggableString() {
-		return getLoggableValueQualifier();
-	}
-
-	@Override
-	public void validateJdbcTypes(JdbcCodes typeCodes) {
-		for ( Value value : values() ) {
-			value.validateJdbcTypes( typeCodes );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/UniqueKey.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/UniqueKey.java
deleted file mode 100644
index f130f2ebe9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/UniqueKey.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.internal.util.StringHelper;
-
-/**
- * Models a SQL <tt>INDEX</tt> defined as UNIQUE
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public class UniqueKey extends AbstractConstraint implements Constraint {
-	protected UniqueKey(Table table, String name) {
-		super( table, name );
-	}
-
-	@Override
-	public String getExportIdentifier() {
-		StringBuilder sb = new StringBuilder( getTable().getLoggableValueQualifier() );
-		sb.append( ".UK" );
-		for ( Column column : getColumns() ) {
-			sb.append( '_' ).append( column.getColumnName().getName() );
-		}
-		return sb.toString();
-	}
-
-	@Override
-	public String[] sqlCreateStrings(Dialect dialect) {
-		String s = dialect.getUniqueDelegate().getAlterTableToAddUniqueKeyCommand( this );
-		return StringHelper.toArrayElement( s );
-	}
-
-	@Override
-	public String[] sqlDropStrings(Dialect dialect) {
-		String s = dialect.getUniqueDelegate().getAlterTableToDropUniqueKeyCommand( this );
-		return StringHelper.toArrayElement( s );
-	}
-
-	@Override
-    protected String sqlConstraintStringInAlterTable(Dialect dialect) {
-		// not used
-		return "";
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Value.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Value.java
deleted file mode 100644
index 0549bb7cc1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Value.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * Models a value within a {@link ValueContainer}.  This will generally be either a {@link Column column} or a
- * {@link DerivedValue derived value}, but we also allow the notion of {@link Tuple} at this level
- *
- * @author Steve Ebersole
- */
-public interface Value {
-	/**
-	 * Retrieve the table that owns this value.
-	 *
-	 * @return The owning table.
-	 */
-	public TableSpecification getTable();
-
-	/**
-	 * Obtain the string representation of this value usable in log statements.
-	 *
-	 * @return The loggable representation
-	 */
-	public String toLoggableString();
-
-	/**
-	 * Used to track JDBC type usage throughout a series of potential recursive calls to component
-	 * values since we do not know ahead of time which values correspond to which indexes of the
-	 * jdbc type array.
-	 */
-	public static class JdbcCodes {
-		private final int[] typeCodes;
-		private int index = 0;
-
-		public JdbcCodes(int[] typeCodes) {
-			this.typeCodes = typeCodes;
-		}
-
-		public int nextJdbcCde() {
-			return typeCodes[index++];
-		}
-
-		public int getIndex() {
-			return index;
-		}
-	}
-
-	/**
-	 * Validate the value against the incoming JDBC type code array, both in terms of number of types
-	 * and compatibility of types.
-	 *
-	 * @param typeCodes The type codes.
-	 *
-	 * @throws org.hibernate.metamodel.ValidationException if validaton fails.
-	 */
-	public void validateJdbcTypes(JdbcCodes typeCodes);
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ValueContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ValueContainer.java
deleted file mode 100644
index 5523716f4e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/ValueContainer.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
- * third-party contributors as indicated by either @author tags or express
- * copyright attribution statements applied by the authors.  All
- * third-party contributions are distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-/**
- * Contract for data containers (what the ANSI SQL spec calls "table specifications") to which we can map
- * entity state.  The two flavors here are {@link Table physical table} and {@link InLineView inline view}, but a
- * {@link Tuple} is a conceptual value container as well.
- *
- * @author Steve Ebersole
- */
-public interface ValueContainer {
-	/**
-	 * Obtain an iterator over this containers current set of value definitions.
-	 *
-	 * @return Iterator over value definitions.
-	 */
-	public Iterable<SimpleValue> values();
-
-	/**
-	 * Get a qualifier which can be used to qualify {@link Value values} belonging to this container in
-	 * their logging.
-	 *
-	 * @return The qualifier
-	 */
-	public String getLoggableValueQualifier();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/package.html b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/package.html
deleted file mode 100644
index 4dd12a5ff3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/package.html
+++ /dev/null
@@ -1,31 +0,0 @@
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ Copyright (c) 2010, Red Hat Inc. or third-party contributors as
-  ~ indicated by the @author tags or express copyright attribution
-  ~ statements applied by the authors.  All third-party contributions are
-  ~ distributed under license by Red Hat Inc.
-  ~
-  ~ This copyrighted material is made available to anyone wishing to use, modify,
-  ~ copy, or redistribute it subject to the terms and conditions of the GNU
-  ~ Lesser General Public License, as published by the Free Software Foundation.
-  ~
-  ~ This program is distributed in the hope that it will be useful,
-  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-  ~ for more details.
-  ~
-  ~ You should have received a copy of the GNU Lesser General Public License
-  ~ along with this distribution; if not, write to:
-  ~ Free Software Foundation, Inc.
-  ~ 51 Franklin Street, Fifth Floor
-  ~ Boston, MA  02110-1301  USA
-  -->
-
-<html>
-<body>
-<p>
-    This package defines the metamodel of a relational database schema.
-</p>
-</body>
-</html>
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ColumnRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ColumnRelationalState.java
deleted file mode 100644
index ae141bcbd8..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ColumnRelationalState.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-import java.util.Set;
-
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.metamodel.relational.Size;
-
-/**
- * @author Gail Badner
- */
-public interface ColumnRelationalState extends SimpleValueRelationalState {
-	NamingStrategy getNamingStrategy();
-
-    boolean isGloballyQuotedIdentifiers();
-
-	String getExplicitColumnName();
-
-	boolean isUnique();
-
-	Size getSize();
-
-	boolean isNullable();
-
-	String getCheckCondition();
-
-	String getDefault();
-
-	String getSqlType();
-
-	String getCustomWriteFragment();
-
-	String getCustomReadFragment();
-
-	String getComment();
-
-	Set<String> getUniqueKeys();
-
-	Set<String> getIndexes();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/DerivedValueRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/DerivedValueRelationalState.java
deleted file mode 100644
index 19021f58c3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/DerivedValueRelationalState.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-/**
- * @author Gail Badner
- */
-public interface DerivedValueRelationalState extends SimpleValueRelationalState {
-	String getFormula();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ManyToOneRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ManyToOneRelationalState.java
deleted file mode 100644
index c441b3e621..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ManyToOneRelationalState.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-/**
- * @author Gail Badner
- */
-public interface ManyToOneRelationalState extends ValueRelationalState {
-	boolean isLogicalOneToOne();
-
-	String getForeignKeyName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/SimpleValueRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/SimpleValueRelationalState.java
deleted file mode 100644
index a0ea13a92c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/SimpleValueRelationalState.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-/**
- * @author Gail Badner
- */
-public interface SimpleValueRelationalState extends ValueRelationalState {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/TupleRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/TupleRelationalState.java
deleted file mode 100644
index 6bec20e59e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/TupleRelationalState.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-import java.util.List;
-
-/**
- * @author Gail Badner
- */
-public interface TupleRelationalState extends ValueRelationalState {
-	List<SimpleValueRelationalState> getRelationalStates();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ValueRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ValueRelationalState.java
deleted file mode 100644
index d8fb1ff8bd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/relational/state/ValueRelationalState.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational.state;
-
-/**
- * @author Gail Badner
- */
-public interface ValueRelationalState {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java
deleted file mode 100644
index 6fbcfc0c0c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.service.ServiceRegistry;
-
-/**
- * @author Steve Ebersole
- */
-public interface BindingContext {
-	public ServiceRegistry getServiceRegistry();
-
-	public NamingStrategy getNamingStrategy();
-
-	public MappingDefaults getMappingDefaults();
-
-	public MetadataImplementor getMetadataImplementor();
-
-	public <T> Class<T> locateClassByName(String name);
-
-	public Type makeJavaType(String className);
-
-	public boolean isGloballyQuotedIdentifiers();
-
-	public ValueHolder<Class<?>> makeClassReference(String className);
-
-	public String qualifyClassName(String name);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/LocalBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/LocalBindingContext.java
deleted file mode 100644
index 818beba54c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/LocalBindingContext.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import org.hibernate.internal.jaxb.Origin;
-
-/**
- * @author Steve Ebersole
- */
-public interface LocalBindingContext extends BindingContext {
-	public Origin getOrigin();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java
deleted file mode 100644
index bb66dc64f0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import org.hibernate.cache.spi.access.AccessType;
-
-/**
- * Defines a (contextual) set of values to use as defaults in the absence of related mapping information.  The
- * context here is conceptually a stack.  The "global" level is configuration settings.
- *
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public interface MappingDefaults {
-	/**
-	 * Identifies the default package name to use if none specified in the mapping.  Really only pertinent for
-	 * {@code hbm.xml} mappings.
-	 *
-	 * @return The default package name.
-	 */
-	public String getPackageName();
-
-	/**
-	 * Identifies the default database schema name to use if none specified in the mapping.
-	 *
-	 * @return The default schema name
-	 */
-	public String getSchemaName();
-
-	/**
-	 * Identifies the default database catalog name to use if none specified in the mapping.
-	 *
-	 * @return The default catalog name
-	 */
-	public String getCatalogName();
-
-	/**
-	 * Identifies the default column name to use for the identifier column if none specified in the mapping.
-	 *
-	 * @return The default identifier column name
-	 */
-	public String getIdColumnName();
-
-	/**
-	 * Identifies the default column name to use for the discriminator column if none specified in the mapping.
-	 *
-	 * @return The default discriminator column name
-	 */
-	public String getDiscriminatorColumnName();
-
-	/**
-	 * Identifies the default cascade style to apply to associations if none specified in the mapping.
-	 *
-	 * @return The default cascade style
-	 */
-	public String getCascadeStyle();
-
-	/**
-	 * Identifies the default {@link org.hibernate.property.PropertyAccessor} name to use if none specified in the
-	 * mapping.
-	 *
-	 * @return The default property accessor name
-	 * @see org.hibernate.property.PropertyAccessorFactory
-	 */
-	public String getPropertyAccessorName();
-
-	/**
-	 * Identifies whether associations are lazy by default if not specified in the mapping.
-	 *
-	 * @return The default association laziness
-	 */
-	public boolean areAssociationsLazy();
-
-	/**
-	 * The default cache access type to use
-	 *
-	 * @return The default cache access type.
-	 */
-	public AccessType getCacheAccessType();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java
deleted file mode 100644
index 47bd55cf87..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source;
-
-import org.hibernate.HibernateException;
-import org.hibernate.internal.jaxb.Origin;
-
-/**
- * Indicates a problem parsing a mapping document.
- *
- * @author Steve Ebersole
- */
-public class MappingException extends HibernateException {
-	private final Origin origin;
-
-	public MappingException(String message, Origin origin) {
-		super( message );
-		this.origin = origin;
-	}
-
-	public MappingException(String message, Throwable root, Origin origin) {
-		super( message, root );
-		this.origin = origin;
-	}
-
-	public Origin getOrigin() {
-		return origin;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java
deleted file mode 100644
index a0702f165e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source;
-
-import org.hibernate.internal.jaxb.Origin;
-
-/**
- * @author Steve Ebersole
- */
-public class MappingNotFoundException extends MappingException {
-	public MappingNotFoundException(String message, Origin origin) {
-		super( message, origin );
-	}
-
-	public MappingNotFoundException(Origin origin) {
-		super( String.format( "Mapping (%s) not found : %s", origin.getType(), origin.getName() ), origin );
-	}
-
-	public MappingNotFoundException(String message, Throwable root, Origin origin) {
-		super( message, root, origin );
-	}
-
-	public MappingNotFoundException(Throwable root, Origin origin) {
-		super( String.format( "Mapping (%s) not found : %s", origin.getType(), origin.getName() ), root, origin );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java
deleted file mode 100644
index 461c031863..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.hibernate.metamodel.binding.MetaAttribute;
-
-/**
- * @author Steve Ebersole
- */
-public class MetaAttributeContext {
-	private final MetaAttributeContext parentContext;
-	private final ConcurrentHashMap<String, MetaAttribute> metaAttributeMap = new ConcurrentHashMap<String, MetaAttribute>();
-
-	public MetaAttributeContext() {
-		this( null );
-	}
-
-	public MetaAttributeContext(MetaAttributeContext parentContext) {
-		this.parentContext = parentContext;
-	}
-
-
-	// read contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	public Iterable<String> getKeys() {
-		HashSet<String> keys = new HashSet<String>();
-		addKeys( keys );
-		return keys;
-	}
-
-	private void addKeys(Set<String> keys) {
-		keys.addAll( metaAttributeMap.keySet() );
-		if ( parentContext != null ) {
-			// recursive call
-			parentContext.addKeys( keys );
-		}
-	}
-
-	public Iterable<String> getLocalKeys() {
-		return metaAttributeMap.keySet();
-	}
-
-	public MetaAttribute getMetaAttribute(String key) {
-		MetaAttribute value = getLocalMetaAttribute( key );
-		if ( value == null ) {
-			// recursive call
-			value = parentContext.getMetaAttribute( key );
-		}
-		return value;
-	}
-
-	public MetaAttribute getLocalMetaAttribute(String key) {
-		return metaAttributeMap.get( key );
-	}
-
-
-	// write contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	public void add(MetaAttribute metaAttribute) {
-		metaAttributeMap.put( metaAttribute.getName(), metaAttribute );
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java
deleted file mode 100644
index 985272bc47..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import org.hibernate.engine.ResultSetMappingDefinition;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.engine.spi.Mapping;
-import org.hibernate.engine.spi.NamedQueryDefinition;
-import org.hibernate.engine.spi.NamedSQLQueryDefinition;
-import org.hibernate.metamodel.Metadata;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.relational.Database;
-import org.hibernate.service.ServiceRegistry;
-import org.hibernate.type.TypeResolver;
-
-/**
- * @author Steve Ebersole
- */
-public interface MetadataImplementor extends Metadata, BindingContext, Mapping {
-	public ServiceRegistry getServiceRegistry();
-
-	public Database getDatabase();
-
-	public TypeResolver getTypeResolver();
-
-	public void addImport(String entityName, String entityName1);
-
-	public void addEntity(EntityBinding entityBinding);
-
-	public void addCollection(PluralAttributeBinding collectionBinding);
-
-	public void addFetchProfile(FetchProfile profile);
-
-	public void addTypeDefinition(TypeDef typeDef);
-
-	public void addFilterDefinition(FilterDefinition filterDefinition);
-
-	public void addIdGenerator(IdGenerator generator);
-
-	public void registerIdentifierGenerator(String name, String clazz);
-
-	public void addNamedNativeQuery(NamedSQLQueryDefinition def);
-
-	public void addNamedQuery(NamedQueryDefinition def);
-
-	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition);
-
-	// todo : this needs to move to AnnotationBindingContext
-	public void setGloballyQuotedIdentifiers(boolean b);
-
-	public MetaAttributeContext getGlobalMetaAttributeContext();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataSourceProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataSourceProcessor.java
deleted file mode 100644
index 985d28aac0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataSourceProcessor.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source;
-
-import java.util.List;
-
-import org.hibernate.metamodel.MetadataSources;
-
-/**
- * Handles the processing of metadata sources in a dependency-ordered manner.
- *
- * @author Steve Ebersole
- */
-public interface MetadataSourceProcessor {
-	/**
-	 * Prepare for processing the given sources.
-	 *
-	 * @param sources The metadata sources.
-	 */
-	public void prepare(MetadataSources sources);
-
-	/**
-	 * Process the independent metadata.  These have no dependency on other types of metadata being processed.
-	 *
-	 * @param sources The metadata sources.
-	 *
-	 * @see #prepare
-	 */
-	public void processIndependentMetadata(MetadataSources sources);
-
-	/**
-	 * Process the parts of the metadata that depend on type information (type definitions) having been processed
-	 * and available.
-	 *
-	 * @param sources The metadata sources.
-	 *
-	 * @see #processIndependentMetadata
-	 */
-	public void processTypeDependentMetadata(MetadataSources sources);
-
-	/**
-	 * Process the mapping (entities, et al) metadata.
-	 *
-	 * @param sources The metadata sources.
-	 * @param processedEntityNames Collection of any already processed entity names.
-	 *
-	 * @see #processTypeDependentMetadata
-	 */
-	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames);
-
-	/**
-	 * Process the parts of the metadata that depend on mapping (entities, et al) information having been
-	 * processed and available.
-	 *
-	 * @param sources The metadata sources.
-	 *
-	 * @see #processMappingMetadata
-	 */
-	public void processMappingDependentMetadata(MetadataSources sources);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContext.java
deleted file mode 100644
index dc8dbe7843..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContext.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import org.hibernate.metamodel.source.BindingContext;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.Index;
-
-import com.fasterxml.classmate.ResolvedType;
-import com.fasterxml.classmate.ResolvedTypeWithMembers;
-
-/**
- * Defines an interface for providing additional annotation related context information.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public interface AnnotationBindingContext extends BindingContext {
-	Index getIndex();
-
-	ClassInfo getClassInfo(String name);
-
-	void resolveAllTypes(String className);
-
-	ResolvedType getResolvedType(Class<?> clazz);
-
-	ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java
deleted file mode 100644
index 20dd10da9b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.metamodel.source.MappingDefaults;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-
-import com.fasterxml.classmate.MemberResolver;
-import com.fasterxml.classmate.ResolvedType;
-import com.fasterxml.classmate.ResolvedTypeWithMembers;
-import com.fasterxml.classmate.TypeResolver;
-
-/**
- * @author Steve Ebersole
- */
-public class AnnotationBindingContextImpl implements AnnotationBindingContext {
-	private final MetadataImplementor metadata;
-	private final ValueHolder<ClassLoaderService> classLoaderService;
-	private final Index index;
-	private final TypeResolver typeResolver = new TypeResolver();
-	private final Map<Class<?>, ResolvedType> resolvedTypeCache = new HashMap<Class<?>, ResolvedType>();
-
-	public AnnotationBindingContextImpl(MetadataImplementor metadata, Index index) {
-		this.metadata = metadata;
-		this.classLoaderService = new ValueHolder<ClassLoaderService>(
-				new ValueHolder.DeferredInitializer<ClassLoaderService>() {
-					@Override
-					public ClassLoaderService initialize() {
-						return AnnotationBindingContextImpl.this.metadata
-								.getServiceRegistry()
-								.getService( ClassLoaderService.class );
-					}
-				}
-		);
-		this.index = index;
-	}
-
-	@Override
-	public Index getIndex() {
-		return index;
-	}
-
-	@Override
-	public ClassInfo getClassInfo(String name) {
-		DotName dotName = DotName.createSimple( name );
-		return index.getClassByName( dotName );
-	}
-
-	@Override
-	public void resolveAllTypes(String className) {
-		// the resolved type for the top level class in the hierarchy
-		Class<?> clazz = classLoaderService.getValue().classForName( className );
-		ResolvedType resolvedType = typeResolver.resolve( clazz );
-		while ( resolvedType != null ) {
-			// todo - check whether there is already something in the map
-			resolvedTypeCache.put( clazz, resolvedType );
-			resolvedType = resolvedType.getParentClass();
-			if ( resolvedType != null ) {
-				clazz = resolvedType.getErasedType();
-			}
-		}
-	}
-
-	@Override
-	public ResolvedType getResolvedType(Class<?> clazz) {
-		// todo - error handling
-		return resolvedTypeCache.get( clazz );
-	}
-
-	@Override
-	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type) {
-		// todo : is there a reason we create this resolver every time?
-		MemberResolver memberResolver = new MemberResolver( typeResolver );
-		return memberResolver.resolve( type, null, null );
-	}
-
-	@Override
-	public ServiceRegistry getServiceRegistry() {
-		return getMetadataImplementor().getServiceRegistry();
-	}
-
-	@Override
-	public NamingStrategy getNamingStrategy() {
-		return metadata.getNamingStrategy();
-	}
-
-	@Override
-	public MappingDefaults getMappingDefaults() {
-		return metadata.getMappingDefaults();
-	}
-
-	@Override
-	public MetadataImplementor getMetadataImplementor() {
-		return metadata;
-	}
-
-	@Override
-	public <T> Class<T> locateClassByName(String name) {
-		return classLoaderService.getValue().classForName( name );
-	}
-
-	private Map<String, Type> nameToJavaTypeMap = new HashMap<String, Type>();
-
-	@Override
-	public Type makeJavaType(String className) {
-		Type javaType = nameToJavaTypeMap.get( className );
-		if ( javaType == null ) {
-			javaType = metadata.makeJavaType( className );
-			nameToJavaTypeMap.put( className, javaType );
-		}
-		return javaType;
-	}
-
-	@Override
-	public ValueHolder<Class<?>> makeClassReference(String className) {
-		return new ValueHolder<Class<?>>( locateClassByName( className ) );
-	}
-
-	@Override
-	public String qualifyClassName(String name) {
-		return name;
-	}
-
-	@Override
-	public boolean isGloballyQuotedIdentifiers() {
-		return metadata.isGloballyQuotedIdentifiers();
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java
deleted file mode 100644
index cf375fb65a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.HibernateException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.MetadataSourceProcessor;
-import org.hibernate.metamodel.source.annotations.global.FetchProfileBinder;
-import org.hibernate.metamodel.source.annotations.global.FilterDefBinder;
-import org.hibernate.metamodel.source.annotations.global.IdGeneratorBinder;
-import org.hibernate.metamodel.source.annotations.global.QueryBinder;
-import org.hibernate.metamodel.source.annotations.global.TableBinder;
-import org.hibernate.metamodel.source.annotations.global.TypeDefBinder;
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-import org.hibernate.metamodel.source.annotations.xml.mocker.EntityMappingsMocker;
-import org.hibernate.metamodel.source.binder.Binder;
-import org.hibernate.metamodel.source.binder.EntityHierarchy;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-
-import org.jboss.jandex.Index;
-import org.jboss.jandex.Indexer;
-import org.jboss.logging.Logger;
-
-/**
- * Main class responsible to creating and binding the Hibernate meta-model from annotations.
- * This binder only has to deal with the (jandex) annotation index/repository. XML configuration is already processed
- * and pseudo annotations are created.
- *
- * @author Hardy Ferentschik
- * @author Steve Ebersole
- */
-public class AnnotationMetadataSourceProcessorImpl implements MetadataSourceProcessor {
-	private static final Logger LOG = Logger.getLogger( AnnotationMetadataSourceProcessorImpl.class );
-
-	private final MetadataImplementor metadata;
-	private AnnotationBindingContext bindingContext;
-
-	public AnnotationMetadataSourceProcessorImpl(MetadataImpl metadata) {
-		this.metadata = metadata;
-	}
-
-	@Override
-	@SuppressWarnings( { "unchecked" })
-	public void prepare(MetadataSources sources) {
-		// create a jandex index from the annotated classes
-		Indexer indexer = new Indexer();
-		for ( Class<?> clazz : sources.getAnnotatedClasses() ) {
-			indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
-		}
-
-		// add package-info from the configured packages
-		for ( String packageName : sources.getAnnotatedPackages() ) {
-			indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
-		}
-
-		Index index = indexer.complete();
-
-		List<JaxbRoot<JaxbEntityMappings>> mappings = new ArrayList<JaxbRoot<JaxbEntityMappings>>();
-		for ( JaxbRoot<?> root : sources.getJaxbRootList() ) {
-			if ( root.getRoot() instanceof JaxbEntityMappings ) {
-				mappings.add( (JaxbRoot<JaxbEntityMappings>) root );
-			}
-		}
-		if ( !mappings.isEmpty() ) {
-			index = parseAndUpdateIndex( mappings, index );
-		}
-
-		if ( index.getAnnotations( PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS ) != null ) {
-			// todo : this needs to move to AnnotationBindingContext
-			// what happens right now is that specifying this in an orm.xml causes it to effect all orm.xmls
-			metadata.setGloballyQuotedIdentifiers( true );
-		}
-		bindingContext = new AnnotationBindingContextImpl( metadata, index );
-	}
-
-	@Override
-	public void processIndependentMetadata(MetadataSources sources) {
-		assertBindingContextExists();
-		TypeDefBinder.bind( bindingContext );
-	}
-
-	private void assertBindingContextExists() {
-		if ( bindingContext == null ) {
-			throw new AssertionFailure( "The binding context should exist. Has prepare been called!?" );
-		}
-	}
-
-	@Override
-	public void processTypeDependentMetadata(MetadataSources sources) {
-		assertBindingContextExists();
-		IdGeneratorBinder.bind( bindingContext );
-	}
-
-	@Override
-	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames) {
-		assertBindingContextExists();
-		// need to order our annotated entities into an order we can process
-		Set<EntityHierarchy> hierarchies = EntityHierarchyBuilder.createEntityHierarchies( bindingContext );
-
-		Binder binder = new Binder( bindingContext.getMetadataImplementor(), new ArrayList<String>() );
-		for ( EntityHierarchy hierarchy : hierarchies ) {
-			binder.processEntityHierarchy( hierarchy );
-		}
-	}
-
-	@Override
-	public void processMappingDependentMetadata(MetadataSources sources) {
-		TableBinder.bind( bindingContext );
-		FetchProfileBinder.bind( bindingContext );
-		QueryBinder.bind( bindingContext );
-		FilterDefBinder.bind( bindingContext );
-	}
-
-	private Index parseAndUpdateIndex(List<JaxbRoot<JaxbEntityMappings>> mappings, Index annotationIndex) {
-		List<JaxbEntityMappings> list = new ArrayList<JaxbEntityMappings>( mappings.size() );
-		for ( JaxbRoot<JaxbEntityMappings> jaxbRoot : mappings ) {
-			list.add( jaxbRoot.getRoot() );
-		}
-		return new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex();
-	}
-
-	private void indexClass(Indexer indexer, String className) {
-		InputStream stream = metadata.getServiceRegistry().getService( ClassLoaderService.class ).locateResourceStream(
-				className
-		);
-		try {
-			indexer.index( stream );
-		}
-		catch ( IOException e ) {
-			throw new HibernateException( "Unable to open input stream for class " + className, e );
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyBuilder.java
deleted file mode 100644
index 1584c5c0d0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyBuilder.java
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.persistence.AccessType;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.internal.util.collections.CollectionHelper;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.annotations.entity.EntityClass;
-import org.hibernate.metamodel.source.annotations.entity.RootEntitySourceImpl;
-import org.hibernate.metamodel.source.annotations.entity.SubclassEntitySourceImpl;
-import org.hibernate.metamodel.source.binder.EntityHierarchy;
-import org.hibernate.metamodel.source.binder.EntitySource;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.FieldInfo;
-import org.jboss.jandex.Index;
-import org.jboss.jandex.MethodInfo;
-
-/**
- * Given a (jandex) annotation index build processes all classes with JPA relevant annotations and pre-orders
- * JPA entities respectively their inheritance hierarchy.
- *
- * @author Hardy Ferentschik
- */
-public class EntityHierarchyBuilder {
-	private static final DotName OBJECT = DotName.createSimple( Object.class.getName() );
-
-	/**
-	 * Pre-processes the annotated entities from the index and create a set of entity hierarchies which can be bound
-	 * to the metamodel.
-	 *
-	 * @param bindingContext The binding context, giving access to needed services and information
-	 *
-	 * @return a set of {@code EntityHierarchy} instances.
-	 */
-	public static Set<EntityHierarchy> createEntityHierarchies(AnnotationBindingContext bindingContext) {
-		Set<EntityHierarchy> hierarchies = new HashSet<EntityHierarchy>();
-
-		List<DotName> processedEntities = new ArrayList<DotName>();
-		Map<DotName, List<ClassInfo>> classToDirectSubClassMap = new HashMap<DotName, List<ClassInfo>>();
-		Index index = bindingContext.getIndex();
-		for ( ClassInfo info : index.getKnownClasses() ) {
-			if ( !isEntityClass( info ) ) {
-				continue;
-			}
-
-			if ( processedEntities.contains( info.name() ) ) {
-				continue;
-			}
-
-			ClassInfo rootClassInfo = findRootEntityClassInfo( index, info );
-			List<ClassInfo> rootClassWithAllSubclasses = new ArrayList<ClassInfo>();
-			// the root entity might have some mapped super classes which we have to take into consideration
-			// for inheritance type and default access
-			addMappedSuperclasses( index, rootClassInfo, rootClassWithAllSubclasses );
-
-			// collect the current root entity and all its subclasses
-			processHierarchy(
-					bindingContext,
-					rootClassInfo,
-					rootClassWithAllSubclasses,
-					processedEntities,
-					classToDirectSubClassMap
-			);
-
-			AccessType defaultAccessType = determineDefaultAccessType( rootClassWithAllSubclasses );
-			InheritanceType hierarchyInheritanceType = determineInheritanceType(
-					rootClassInfo,
-					rootClassWithAllSubclasses
-			);
-
-			// create the root entity source
-			EntityClass rootEntityClass = new EntityClass(
-					rootClassInfo,
-					null,
-					defaultAccessType,
-					hierarchyInheritanceType,
-					bindingContext
-			);
-			RootEntitySourceImpl rootSource = new RootEntitySourceImpl( rootEntityClass );
-
-			addSubclassEntitySources(
-					bindingContext,
-					classToDirectSubClassMap,
-					defaultAccessType,
-					hierarchyInheritanceType,
-					rootEntityClass,
-					rootSource
-			);
-
-
-			hierarchies.add( new EntityHierarchyImpl( rootSource, hierarchyInheritanceType ) );
-		}
-		return hierarchies;
-	}
-
-	private static void addSubclassEntitySources(AnnotationBindingContext bindingContext,
-												 Map<DotName, List<ClassInfo>> classToDirectSubClassMap,
-												 AccessType defaultAccessType,
-												 InheritanceType hierarchyInheritanceType,
-												 EntityClass entityClass,
-												 EntitySource entitySource) {
-		List<ClassInfo> subClassInfoList = classToDirectSubClassMap.get( DotName.createSimple( entitySource.getClassName() ) );
-		if ( subClassInfoList == null ) {
-			return;
-		}
-		for ( ClassInfo subClassInfo : subClassInfoList ) {
-			EntityClass subclassEntityClass = new EntityClass(
-					subClassInfo,
-					entityClass,
-					defaultAccessType,
-					hierarchyInheritanceType,
-					bindingContext
-			);
-			SubclassEntitySource subclassEntitySource = new SubclassEntitySourceImpl( subclassEntityClass );
-			entitySource.add( subclassEntitySource );
-			addSubclassEntitySources(
-					bindingContext,
-					classToDirectSubClassMap,
-					defaultAccessType,
-					hierarchyInheritanceType,
-					subclassEntityClass,
-					subclassEntitySource
-			);
-		}
-	}
-
-	/**
-	 * Finds the root entity starting at the entity given by {@code info}. The root entity is not the highest superclass
-	 * in a java type sense, but the highest superclass which is also an entity (annotated w/ {@code @Entity}.
-	 *
-	 * @param index the annotation repository
-	 * @param info the class info representing an entity
-	 *
-	 * @return Finds the root entity starting at the entity given by {@code info}
-	 */
-	private static ClassInfo findRootEntityClassInfo(Index index, ClassInfo info) {
-		ClassInfo rootEntity = info;
-
-		DotName superName = info.superName();
-		ClassInfo tmpInfo;
-		// walk up the hierarchy until java.lang.Object
-		while ( !OBJECT.equals( superName ) ) {
-			tmpInfo = index.getClassByName( superName );
-			if ( isEntityClass( tmpInfo ) ) {
-				rootEntity = tmpInfo;
-			}
-			superName = tmpInfo.superName();
-		}
-		return rootEntity;
-	}
-
-	private static void addMappedSuperclasses(Index index, ClassInfo info, List<ClassInfo> classInfoList) {
-		DotName superName = info.superName();
-		ClassInfo tmpInfo;
-		// walk up the hierarchy until java.lang.Object
-		while ( !OBJECT.equals( superName ) ) {
-			tmpInfo = index.getClassByName( superName );
-			if ( isMappedSuperclass( tmpInfo ) ) {
-				classInfoList.add( tmpInfo );
-			}
-			superName = tmpInfo.superName();
-		}
-	}
-
-	/**
-	 * This method does several things.
-	 * <ul>
-	 * <li>Collect all java subclasses (recursive) of {@code classInfo} in {@code rootClassWithAllSubclasses}. </li>
-	 * <li>Keeping track of all processed classed annotated with {@code @Entity}</li>
-	 * <li>Building up a map of class to direct subclass list</li>
-	 * </ul>
-	 *
-	 * @param bindingContext the binding context
-	 * @param classInfo the current class info
-	 * @param rootClassWithAllSubclasses used to collect all classes in the hierarchy starting at {@code classInfo}
-	 * @param processedEntities Used to keep track of all processed entities
-	 * @param classToDirectSubclassMap Create a map of class to direct subclass
-	 */
-	private static void processHierarchy(AnnotationBindingContext bindingContext,
-										 ClassInfo classInfo,
-										 List<ClassInfo> rootClassWithAllSubclasses,
-										 List<DotName> processedEntities,
-										 Map<DotName, List<ClassInfo>> classToDirectSubclassMap) {
-		processedEntities.add( classInfo.name() );
-		rootClassWithAllSubclasses.add( classInfo );
-		List<ClassInfo> subClasses = bindingContext.getIndex().getKnownDirectSubclasses( classInfo.name() );
-
-		// if there are no more subclasses we reached the leaf class. In order to properly resolve generics we
-		// need to resolve the type information using this leaf class
-		if ( subClasses.isEmpty() ) {
-			bindingContext.resolveAllTypes( classInfo.name().toString() );
-		}
-
-		for ( ClassInfo subClassInfo : subClasses ) {
-			addSubClassToSubclassMap( classInfo.name(), subClassInfo, classToDirectSubclassMap );
-			processHierarchy(
-					bindingContext,
-					subClassInfo,
-					rootClassWithAllSubclasses,
-					processedEntities,
-					classToDirectSubclassMap
-			);
-		}
-	}
-
-	private static void addSubClassToSubclassMap(DotName name, ClassInfo subClassInfo, Map<DotName, List<ClassInfo>> classToDirectSubclassMap) {
-		if ( classToDirectSubclassMap.containsKey( name ) ) {
-			classToDirectSubclassMap.get( name ).add( subClassInfo );
-		}
-		else {
-			List<ClassInfo> subclassList = new ArrayList<ClassInfo>();
-			subclassList.add( subClassInfo );
-			classToDirectSubclassMap.put( name, subclassList );
-		}
-	}
-
-	/**
-	 * Checks whether the class info represents an entity.
-	 *
-	 * @param info the jandex class info
-	 *
-	 * @return {@code true} if the class represented by {@code info} is annotated with {@code @Entity}, {@code false} otherwise.
-	 */
-	private static boolean isEntityClass(ClassInfo info) {
-		if ( info == null ) {
-			return false;
-		}
-
-		// we are only interested in building the class hierarchies for @Entity
-		AnnotationInstance jpaEntityAnnotation = JandexHelper.getSingleAnnotation( info, JPADotNames.ENTITY );
-		if ( jpaEntityAnnotation == null ) {
-			return false;
-		}
-
-		// some sanity checks
-		AnnotationInstance mappedSuperClassAnnotation = JandexHelper.getSingleAnnotation(
-				info, JPADotNames.MAPPED_SUPERCLASS
-		);
-		String className = info.toString();
-		assertNotEntityAndMappedSuperClass( jpaEntityAnnotation, mappedSuperClassAnnotation, className );
-
-		AnnotationInstance embeddableAnnotation = JandexHelper.getSingleAnnotation(
-				info, JPADotNames.EMBEDDABLE
-		);
-		assertNotEntityAndEmbeddable( jpaEntityAnnotation, embeddableAnnotation, className );
-
-		return true;
-	}
-
-	/**
-	 * Checks whether the class info represents a mapped superclass.
-	 *
-	 * @param info the jandex class info
-	 *
-	 * @return {@code true} if the class represented by {@code info} is annotated with {@code @MappedSuperclass}, {@code false} otherwise.
-	 */
-	private static boolean isMappedSuperclass(ClassInfo info) {
-		if ( info == null ) {
-			return false;
-		}
-
-		// we are only interested in building the class hierarchies for @Entity
-		AnnotationInstance mappedSuperclassAnnotation = JandexHelper.getSingleAnnotation(
-				info,
-				JPADotNames.MAPPED_SUPERCLASS
-		);
-		return mappedSuperclassAnnotation != null;
-	}
-
-	private static void assertNotEntityAndMappedSuperClass(AnnotationInstance jpaEntityAnnotation, AnnotationInstance mappedSuperClassAnnotation, String className) {
-		if ( jpaEntityAnnotation != null && mappedSuperClassAnnotation != null ) {
-			throw new AnnotationException(
-					"An entity cannot be annotated with both @Entity and @MappedSuperclass. " + className + " has both annotations."
-			);
-		}
-	}
-
-	private static void assertNotEntityAndEmbeddable(AnnotationInstance jpaEntityAnnotation, AnnotationInstance embeddableAnnotation, String className) {
-		if ( jpaEntityAnnotation != null && embeddableAnnotation != null ) {
-			throw new AnnotationException(
-					"An entity cannot be annotated with both @Entity and @Embeddable. " + className + " has both annotations."
-			);
-		}
-	}
-
-	/**
-	 * @param classes the classes in the hierarchy
-	 *
-	 * @return Returns the default access type for the configured class hierarchy independent of explicit
-	 *         {@code AccessType} annotations. The default access type is determined by the placement of the
-	 *         annotations.
-	 */
-	private static AccessType determineDefaultAccessType(List<ClassInfo> classes) {
-		AccessType accessTypeByEmbeddedIdPlacement = null;
-		AccessType accessTypeByIdPlacement = null;
-		for ( ClassInfo info : classes ) {
-			List<AnnotationInstance> idAnnotations = info.annotations().get( JPADotNames.ID );
-			List<AnnotationInstance> embeddedIdAnnotations = info.annotations().get( JPADotNames.EMBEDDED_ID );
-
-			if ( CollectionHelper.isNotEmpty( embeddedIdAnnotations ) ) {
-				accessTypeByEmbeddedIdPlacement = determineAccessTypeByIdPlacement( embeddedIdAnnotations );
-			}
-			if ( CollectionHelper.isNotEmpty( idAnnotations ) ) {
-				accessTypeByIdPlacement = determineAccessTypeByIdPlacement( idAnnotations );
-			}
-		}
-		if ( accessTypeByEmbeddedIdPlacement != null ) {
-			return accessTypeByEmbeddedIdPlacement;
-		}
-		else if ( accessTypeByIdPlacement != null ) {
-			return accessTypeByIdPlacement;
-		}
-		else {
-			return throwIdNotFoundAnnotationException( classes );
-		}
-	}
-
-	private static AccessType determineAccessTypeByIdPlacement(List<AnnotationInstance> idAnnotations) {
-		AccessType accessType = null;
-		for ( AnnotationInstance annotation : idAnnotations ) {
-			AccessType tmpAccessType;
-			if ( annotation.target() instanceof FieldInfo ) {
-				tmpAccessType = AccessType.FIELD;
-			}
-			else if ( annotation.target() instanceof MethodInfo ) {
-				tmpAccessType = AccessType.PROPERTY;
-			}
-			else {
-				throw new AnnotationException( "Invalid placement of @Id annotation" );
-			}
-
-			if ( accessType == null ) {
-				accessType = tmpAccessType;
-			}
-			else {
-				if ( !accessType.equals( tmpAccessType ) ) {
-					throw new AnnotationException( "Inconsistent placement of @Id annotation within hierarchy " );
-				}
-			}
-		}
-		return accessType;
-	}
-
-	private static InheritanceType determineInheritanceType(ClassInfo rootClassInfo, List<ClassInfo> classes) {
-		if(classes.size() == 1) {
-			return InheritanceType.NO_INHERITANCE;
-		}
-
-		// if we have more than one entity class the default is SINGLE_TABLE
-		InheritanceType inheritanceType = InheritanceType.SINGLE_TABLE;
-		AnnotationInstance inheritanceAnnotation = JandexHelper.getSingleAnnotation(
-				rootClassInfo, JPADotNames.INHERITANCE
-		);
-		if ( inheritanceAnnotation != null ) {
-			String enumName = inheritanceAnnotation.value( "strategy" ).asEnum();
-			javax.persistence.InheritanceType jpaInheritanceType = Enum.valueOf(
-					javax.persistence.InheritanceType.class, enumName
-			);
-			inheritanceType = InheritanceType.get( jpaInheritanceType );
-		}
-
-		// sanity check that the is no other @Inheritance annotation in the hierarchy
-		for ( ClassInfo info : classes ) {
-			if ( rootClassInfo.equals( info ) ) {
-				continue;
-			}
-			inheritanceAnnotation = JandexHelper.getSingleAnnotation(
-					info, JPADotNames.INHERITANCE
-			);
-			if ( inheritanceAnnotation != null ) {
-				throw new AnnotationException(
-						String.format(
-								"The inheritance type for %s must be specified on the root entity %s",
-								hierarchyListString( classes ),
-								rootClassInfo.name().toString()
-						)
-				);
-			}
-		}
-
-		return inheritanceType;
-	}
-
-	private static AccessType throwIdNotFoundAnnotationException(List<ClassInfo> classes) {
-		StringBuilder builder = new StringBuilder();
-		builder.append( "Unable to determine identifier attribute for class hierarchy consisting of the classe(s) " );
-		builder.append( hierarchyListString( classes ) );
-		throw new AnnotationException( builder.toString() );
-	}
-
-	private static String hierarchyListString(List<ClassInfo> classes) {
-		StringBuilder builder = new StringBuilder();
-		builder.append( "[" );
-
-		int count = 0;
-		for ( ClassInfo info : classes ) {
-			builder.append( info.name().toString() );
-			if ( count < classes.size() - 1 ) {
-				builder.append( ", " );
-			}
-			count++;
-		}
-		builder.append( "]" );
-		return builder.toString();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyImpl.java
deleted file mode 100644
index 2d970afbb6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EntityHierarchyImpl.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.binder.EntityHierarchy;
-import org.hibernate.metamodel.source.binder.RootEntitySource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class EntityHierarchyImpl implements EntityHierarchy {
-	private final RootEntitySource rootEntitySource;
-	private final InheritanceType inheritanceType;
-
-	public EntityHierarchyImpl(RootEntitySource source, InheritanceType inheritanceType) {
-		this.rootEntitySource = source;
-		this.inheritanceType = inheritanceType;
-	}
-
-	@Override
-	public InheritanceType getHierarchyInheritanceType() {
-		return inheritanceType;
-	}
-
-	@Override
-	public RootEntitySource getRootEntitySource() {
-		return rootEntitySource;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EnumConversionHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EnumConversionHelper.java
deleted file mode 100644
index 98ae17a720..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/EnumConversionHelper.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-import javax.persistence.CascadeType;
-import javax.persistence.GenerationType;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.FetchMode;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
-import org.hibernate.id.MultipleHiLoPerTableGenerator;
-import org.hibernate.internal.util.collections.CollectionHelper;
-
-/**
- * Helper class which converts between different enum types.
- *
- * @author Hardy Ferentschik
- */
-public class EnumConversionHelper {
-	private EnumConversionHelper() {
-	}
-
-	public static String generationTypeToGeneratorStrategyName(GenerationType generatorEnum, boolean useNewGeneratorMappings) {
-		switch ( generatorEnum ) {
-			case IDENTITY:
-				return "identity";
-			case AUTO:
-				return useNewGeneratorMappings
-						? "enhanced-sequence"
-						: "native";
-			case TABLE:
-				return useNewGeneratorMappings
-						? "enhanced-table"
-						: MultipleHiLoPerTableGenerator.class.getName();
-			case SEQUENCE:
-				return useNewGeneratorMappings
-						? "enhanced-sequence"
-						: "seqhilo";
-		}
-		throw new AssertionFailure( "Unknown GeneratorType: " + generatorEnum );
-	}
-
-	public static CascadeStyle cascadeTypeToCascadeStyle(CascadeType cascadeType) {
-		switch ( cascadeType ) {
-			case ALL: {
-				return CascadeStyles.ALL;
-			}
-			case PERSIST: {
-				return CascadeStyles.PERSIST;
-			}
-			case MERGE: {
-				return CascadeStyles.MERGE;
-			}
-			case REMOVE: {
-				return CascadeStyles.DELETE;
-			}
-			case REFRESH: {
-				return CascadeStyles.REFRESH;
-			}
-			case DETACH: {
-				return CascadeStyles.EVICT;
-			}
-			default: {
-				throw new AssertionFailure( "Unknown cascade type" );
-			}
-		}
-	}
-
-	public static FetchMode annotationFetchModeToHibernateFetchMode(org.hibernate.annotations.FetchMode annotationFetchMode) {
-		switch ( annotationFetchMode ) {
-			case JOIN: {
-				return FetchMode.JOIN;
-			}
-			case SELECT: {
-				return FetchMode.SELECT;
-			}
-			case SUBSELECT: {
-				// todo - is this correct? can the conversion be made w/o any additional information, eg
-				// todo - association nature
-				return FetchMode.SELECT;
-			}
-			default: {
-				throw new AssertionFailure( "Unknown fetch mode" );
-			}
-		}
-	}
-
-	public static Set<CascadeStyle> cascadeTypeToCascadeStyleSet(Set<CascadeType> cascadeTypes) {
-		if ( CollectionHelper.isEmpty( cascadeTypes ) ) {
-			return Collections.emptySet();
-		}
-		Set<CascadeStyle> cascadeStyleSet = new HashSet<CascadeStyle>();
-		for ( CascadeType cascadeType : cascadeTypes ) {
-			cascadeStyleSet.add( cascadeTypeToCascadeStyle( cascadeType ) );
-		}
-		return cascadeStyleSet;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java
deleted file mode 100644
index 932b672d00..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import org.hibernate.annotations.AccessType;
-import org.hibernate.annotations.Any;
-import org.hibernate.annotations.AnyMetaDef;
-import org.hibernate.annotations.AnyMetaDefs;
-import org.hibernate.annotations.BatchSize;
-import org.hibernate.annotations.Cache;
-import org.hibernate.annotations.Cascade;
-import org.hibernate.annotations.Check;
-import org.hibernate.annotations.CollectionId;
-import org.hibernate.annotations.ColumnTransformer;
-import org.hibernate.annotations.ColumnTransformers;
-import org.hibernate.annotations.Columns;
-import org.hibernate.annotations.DiscriminatorFormula;
-import org.hibernate.annotations.DiscriminatorOptions;
-import org.hibernate.annotations.Entity;
-import org.hibernate.annotations.Fetch;
-import org.hibernate.annotations.FetchProfile;
-import org.hibernate.annotations.FetchProfiles;
-import org.hibernate.annotations.Filter;
-import org.hibernate.annotations.FilterDef;
-import org.hibernate.annotations.FilterDefs;
-import org.hibernate.annotations.FilterJoinTable;
-import org.hibernate.annotations.FilterJoinTables;
-import org.hibernate.annotations.Filters;
-import org.hibernate.annotations.ForeignKey;
-import org.hibernate.annotations.Formula;
-import org.hibernate.annotations.Generated;
-import org.hibernate.annotations.GenericGenerator;
-import org.hibernate.annotations.GenericGenerators;
-import org.hibernate.annotations.Immutable;
-import org.hibernate.annotations.Index;
-import org.hibernate.annotations.IndexColumn;
-import org.hibernate.annotations.JoinColumnOrFormula;
-import org.hibernate.annotations.JoinColumnsOrFormulas;
-import org.hibernate.annotations.JoinFormula;
-import org.hibernate.annotations.LazyCollection;
-import org.hibernate.annotations.LazyToOne;
-import org.hibernate.annotations.Loader;
-import org.hibernate.annotations.ManyToAny;
-import org.hibernate.annotations.MapKeyType;
-import org.hibernate.annotations.MetaValue;
-import org.hibernate.annotations.NamedNativeQueries;
-import org.hibernate.annotations.NamedNativeQuery;
-import org.hibernate.annotations.NamedQueries;
-import org.hibernate.annotations.NamedQuery;
-import org.hibernate.annotations.NaturalId;
-import org.hibernate.annotations.NotFound;
-import org.hibernate.annotations.OnDelete;
-import org.hibernate.annotations.OptimisticLock;
-import org.hibernate.annotations.OrderBy;
-import org.hibernate.annotations.ParamDef;
-import org.hibernate.annotations.Parameter;
-import org.hibernate.annotations.Parent;
-import org.hibernate.annotations.Persister;
-import org.hibernate.annotations.Proxy;
-import org.hibernate.annotations.RowId;
-import org.hibernate.annotations.SQLDelete;
-import org.hibernate.annotations.SQLDeleteAll;
-import org.hibernate.annotations.SQLInsert;
-import org.hibernate.annotations.SQLUpdate;
-import org.hibernate.annotations.Sort;
-import org.hibernate.annotations.Source;
-import org.hibernate.annotations.Subselect;
-import org.hibernate.annotations.Synchronize;
-import org.hibernate.annotations.Table;
-import org.hibernate.annotations.Tables;
-import org.hibernate.annotations.Target;
-import org.hibernate.annotations.Tuplizer;
-import org.hibernate.annotations.Tuplizers;
-import org.hibernate.annotations.Type;
-import org.hibernate.annotations.TypeDef;
-import org.hibernate.annotations.TypeDefs;
-import org.hibernate.annotations.Where;
-import org.hibernate.annotations.WhereJoinTable;
-
-import org.jboss.jandex.DotName;
-
-/**
- * Defines the dot names for the Hibernate specific mapping annotations.
- *
- * @author Hardy Ferentschik
- */
-public interface HibernateDotNames {
-	DotName ACCESS_TYPE = DotName.createSimple( AccessType.class.getName() );
-	DotName ANY = DotName.createSimple( Any.class.getName() );
-	DotName ANY_META_DEF = DotName.createSimple( AnyMetaDef.class.getName() );
-	DotName ANY_META_DEFS = DotName.createSimple( AnyMetaDefs.class.getName() );
-	DotName BATCH_SIZE = DotName.createSimple( BatchSize.class.getName() );
-	DotName CACHE = DotName.createSimple( Cache.class.getName() );
-	DotName CASCADE = DotName.createSimple( Cascade.class.getName() );
-	DotName CHECK = DotName.createSimple( Check.class.getName() );
-	DotName COLLECTION_ID = DotName.createSimple( CollectionId.class.getName() );
-	DotName COLUMNS = DotName.createSimple( Columns.class.getName() );
-	DotName COLUMN_TRANSFORMER = DotName.createSimple( ColumnTransformer.class.getName() );
-	DotName COLUMN_TRANSFORMERS = DotName.createSimple( ColumnTransformers.class.getName() );
-	DotName DISCRIMINATOR_FORMULA = DotName.createSimple( DiscriminatorFormula.class.getName() );
-	DotName DISCRIMINATOR_OPTIONS = DotName.createSimple( DiscriminatorOptions.class.getName() );
-	DotName ENTITY = DotName.createSimple( Entity.class.getName() );
-	DotName FETCH = DotName.createSimple( Fetch.class.getName() );
-	DotName FETCH_PROFILE = DotName.createSimple( FetchProfile.class.getName() );
-	DotName FETCH_PROFILES = DotName.createSimple( FetchProfiles.class.getName() );
-	DotName FILTER = DotName.createSimple( Filter.class.getName() );
-	DotName FILTER_DEF = DotName.createSimple( FilterDef.class.getName() );
-	DotName FILTER_DEFS = DotName.createSimple( FilterDefs.class.getName() );
-	DotName FILTER_JOIN_TABLE = DotName.createSimple( FilterJoinTable.class.getName() );
-	DotName FILTER_JOIN_TABLES = DotName.createSimple( FilterJoinTables.class.getName() );
-	DotName FILTERS = DotName.createSimple( Filters.class.getName() );
-	DotName FOREIGN_KEY = DotName.createSimple( ForeignKey.class.getName() );
-	DotName FORMULA = DotName.createSimple( Formula.class.getName() );
-	DotName GENERATED = DotName.createSimple( Generated.class.getName() );
-	DotName GENERIC_GENERATOR = DotName.createSimple( GenericGenerator.class.getName() );
-	DotName GENERIC_GENERATORS = DotName.createSimple( GenericGenerators.class.getName() );
-	DotName IMMUTABLE = DotName.createSimple( Immutable.class.getName() );
-	DotName INDEX = DotName.createSimple( Index.class.getName() );
-	DotName INDEX_COLUMN = DotName.createSimple( IndexColumn.class.getName() );
-	DotName JOIN_COLUMN_OR_FORMULA = DotName.createSimple( JoinColumnOrFormula.class.getName() );
-	DotName JOIN_COLUMNS_OR_FORMULAS = DotName.createSimple( JoinColumnsOrFormulas.class.getName() );
-	DotName JOIN_FORMULA = DotName.createSimple( JoinFormula.class.getName() );
-	DotName LAZY_COLLECTION = DotName.createSimple( LazyCollection.class.getName() );
-	DotName LAZY_TO_ONE = DotName.createSimple( LazyToOne.class.getName() );
-	DotName LOADER = DotName.createSimple( Loader.class.getName() );
-	DotName MANY_TO_ANY = DotName.createSimple( ManyToAny.class.getName() );
-	DotName MAP_KEY_TYPE = DotName.createSimple( MapKeyType.class.getName() );
-	DotName META_VALUE = DotName.createSimple( MetaValue.class.getName() );
-	DotName NAMED_NATIVE_QUERIES = DotName.createSimple( NamedNativeQueries.class.getName() );
-	DotName NAMED_NATIVE_QUERY = DotName.createSimple( NamedNativeQuery.class.getName() );
-	DotName NAMED_QUERIES = DotName.createSimple( NamedQueries.class.getName() );
-	DotName NAMED_QUERY = DotName.createSimple( NamedQuery.class.getName() );
-	DotName NATURAL_ID = DotName.createSimple( NaturalId.class.getName() );
-	DotName NOT_FOUND = DotName.createSimple( NotFound.class.getName() );
-	DotName ON_DELETE = DotName.createSimple( OnDelete.class.getName() );
-	DotName OPTIMISTIC_LOCK = DotName.createSimple( OptimisticLock.class.getName() );
-	DotName ORDER_BY = DotName.createSimple( OrderBy.class.getName() );
-	DotName PARAM_DEF = DotName.createSimple( ParamDef.class.getName() );
-	DotName PARAMETER = DotName.createSimple( Parameter.class.getName() );
-	DotName PARENT = DotName.createSimple( Parent.class.getName() );
-	DotName PERSISTER = DotName.createSimple( Persister.class.getName() );
-	DotName PROXY = DotName.createSimple( Proxy.class.getName() );
-	DotName ROW_ID = DotName.createSimple( RowId.class.getName() );
-	DotName SORT = DotName.createSimple( Sort.class.getName() );
-	DotName SOURCE = DotName.createSimple( Source.class.getName() );
-	DotName SQL_DELETE = DotName.createSimple( SQLDelete.class.getName() );
-	DotName SQL_DELETE_ALL = DotName.createSimple( SQLDeleteAll.class.getName() );
-	DotName SQL_INSERT = DotName.createSimple( SQLInsert.class.getName() );
-	DotName SQL_UPDATE = DotName.createSimple( SQLUpdate.class.getName() );
-	DotName SUB_SELECT = DotName.createSimple( Subselect.class.getName() );
-	DotName SYNCHRONIZE = DotName.createSimple( Synchronize.class.getName() );
-	DotName TABLE = DotName.createSimple( Table.class.getName() );
-	DotName TABLES = DotName.createSimple( Tables.class.getName() );
-	DotName TARGET = DotName.createSimple( Target.class.getName() );
-	DotName TUPLIZER = DotName.createSimple( Tuplizer.class.getName() );
-	DotName TUPLIZERS = DotName.createSimple( Tuplizers.class.getName() );
-	DotName TYPE = DotName.createSimple( Type.class.getName() );
-	DotName TYPE_DEF = DotName.createSimple( TypeDef.class.getName() );
-	DotName TYPE_DEFS = DotName.createSimple( TypeDefs.class.getName() );
-	DotName WHERE = DotName.createSimple( Where.class.getName() );
-	DotName WHERE_JOIN_TABLE = DotName.createSimple( WhereJoinTable.class.getName() );
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java
deleted file mode 100644
index 20aa8a30e1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import javax.persistence.Access;
-import javax.persistence.AccessType;
-import javax.persistence.AssociationOverride;
-import javax.persistence.AssociationOverrides;
-import javax.persistence.AttributeOverride;
-import javax.persistence.AttributeOverrides;
-import javax.persistence.Basic;
-import javax.persistence.Cacheable;
-import javax.persistence.CascadeType;
-import javax.persistence.CollectionTable;
-import javax.persistence.Column;
-import javax.persistence.ColumnResult;
-import javax.persistence.Convert;
-import javax.persistence.Converter;
-import javax.persistence.DiscriminatorColumn;
-import javax.persistence.DiscriminatorType;
-import javax.persistence.DiscriminatorValue;
-import javax.persistence.ElementCollection;
-import javax.persistence.Embeddable;
-import javax.persistence.Embedded;
-import javax.persistence.EmbeddedId;
-import javax.persistence.Entity;
-import javax.persistence.EntityListeners;
-import javax.persistence.EntityResult;
-import javax.persistence.EnumType;
-import javax.persistence.Enumerated;
-import javax.persistence.ExcludeDefaultListeners;
-import javax.persistence.ExcludeSuperclassListeners;
-import javax.persistence.FetchType;
-import javax.persistence.FieldResult;
-import javax.persistence.GeneratedValue;
-import javax.persistence.GenerationType;
-import javax.persistence.Id;
-import javax.persistence.IdClass;
-import javax.persistence.Inheritance;
-import javax.persistence.InheritanceType;
-import javax.persistence.JoinColumn;
-import javax.persistence.JoinColumns;
-import javax.persistence.JoinTable;
-import javax.persistence.Lob;
-import javax.persistence.LockModeType;
-import javax.persistence.ManyToMany;
-import javax.persistence.ManyToOne;
-import javax.persistence.MapKey;
-import javax.persistence.MapKeyClass;
-import javax.persistence.MapKeyColumn;
-import javax.persistence.MapKeyEnumerated;
-import javax.persistence.MapKeyJoinColumn;
-import javax.persistence.MapKeyJoinColumns;
-import javax.persistence.MapKeyTemporal;
-import javax.persistence.MappedSuperclass;
-import javax.persistence.MapsId;
-import javax.persistence.NamedNativeQueries;
-import javax.persistence.NamedNativeQuery;
-import javax.persistence.NamedQueries;
-import javax.persistence.NamedQuery;
-import javax.persistence.OneToMany;
-import javax.persistence.OneToOne;
-import javax.persistence.OrderBy;
-import javax.persistence.OrderColumn;
-import javax.persistence.PersistenceContext;
-import javax.persistence.PersistenceContexts;
-import javax.persistence.PersistenceProperty;
-import javax.persistence.PersistenceUnit;
-import javax.persistence.PersistenceUnits;
-import javax.persistence.PostLoad;
-import javax.persistence.PostPersist;
-import javax.persistence.PostRemove;
-import javax.persistence.PostUpdate;
-import javax.persistence.PrePersist;
-import javax.persistence.PreRemove;
-import javax.persistence.PreUpdate;
-import javax.persistence.PrimaryKeyJoinColumn;
-import javax.persistence.PrimaryKeyJoinColumns;
-import javax.persistence.QueryHint;
-import javax.persistence.SecondaryTable;
-import javax.persistence.SecondaryTables;
-import javax.persistence.SequenceGenerator;
-import javax.persistence.SqlResultSetMapping;
-import javax.persistence.SqlResultSetMappings;
-import javax.persistence.Table;
-import javax.persistence.TableGenerator;
-import javax.persistence.Temporal;
-import javax.persistence.TemporalType;
-import javax.persistence.Transient;
-import javax.persistence.UniqueConstraint;
-import javax.persistence.Version;
-
-import org.jboss.jandex.DotName;
-
-/**
- * Defines the dot names for the JPA annotations
- *
- * @author Hardy Ferentschik
- */
-public interface JPADotNames {
-	DotName ACCESS = DotName.createSimple( Access.class.getName() );
-	DotName ACCESS_TYPE = DotName.createSimple( AccessType.class.getName() );
-	DotName ASSOCIATION_OVERRIDE = DotName.createSimple( AssociationOverride.class.getName() );
-	DotName ASSOCIATION_OVERRIDES = DotName.createSimple( AssociationOverrides.class.getName() );
-	DotName ATTRIBUTE_OVERRIDE = DotName.createSimple( AttributeOverride.class.getName() );
-	DotName ATTRIBUTE_OVERRIDES = DotName.createSimple( AttributeOverrides.class.getName() );
-	DotName BASIC = DotName.createSimple( Basic.class.getName() );
-	DotName CACHEABLE = DotName.createSimple( Cacheable.class.getName() );
-	DotName CASCADE_TYPE = DotName.createSimple( CascadeType.class.getName() );
-	DotName COLLECTION_TABLE = DotName.createSimple( CollectionTable.class.getName() );
-	DotName COLUMN = DotName.createSimple( Column.class.getName() );
-	DotName COLUMN_RESULT = DotName.createSimple( ColumnResult.class.getName() );
-	DotName CONVERT = DotName.createSimple( Convert.class.getName() );
-	DotName CONVERTER = DotName.createSimple( Converter.class.getName() );
-	DotName DISCRIMINATOR_COLUMN = DotName.createSimple( DiscriminatorColumn.class.getName() );
-	DotName DISCRIMINATOR_TYPE = DotName.createSimple( DiscriminatorType.class.getName() );
-	DotName DISCRIMINATOR_VALUE = DotName.createSimple( DiscriminatorValue.class.getName() );
-	DotName ELEMENT_COLLECTION = DotName.createSimple( ElementCollection.class.getName() );
-	DotName EMBEDDABLE = DotName.createSimple( Embeddable.class.getName() );
-	DotName EMBEDDED = DotName.createSimple( Embedded.class.getName() );
-	DotName EMBEDDED_ID = DotName.createSimple( EmbeddedId.class.getName() );
-	DotName ENTITY = DotName.createSimple( Entity.class.getName() );
-	DotName ENTITY_LISTENERS = DotName.createSimple( EntityListeners.class.getName() );
-	DotName ENTITY_RESULT = DotName.createSimple( EntityResult.class.getName() );
-	DotName ENUMERATED = DotName.createSimple( Enumerated.class.getName() );
-	DotName ENUM_TYPE = DotName.createSimple( EnumType.class.getName() );
-	DotName EXCLUDE_DEFAULT_LISTENERS = DotName.createSimple( ExcludeDefaultListeners.class.getName() );
-	DotName EXCLUDE_SUPERCLASS_LISTENERS = DotName.createSimple( ExcludeSuperclassListeners.class.getName() );
-	DotName FETCH_TYPE = DotName.createSimple( FetchType.class.getName() );
-	DotName FIELD_RESULT = DotName.createSimple( FieldResult.class.getName() );
-	DotName GENERATION_TYPE = DotName.createSimple( GenerationType.class.getName() );
-	DotName GENERATED_VALUE = DotName.createSimple( GeneratedValue.class.getName() );
-	DotName ID = DotName.createSimple( Id.class.getName() );
-	DotName ID_CLASS = DotName.createSimple( IdClass.class.getName() );
-	DotName INHERITANCE_TYPE = DotName.createSimple( InheritanceType.class.getName() );
-	DotName JOIN_COLUMN = DotName.createSimple( JoinColumn.class.getName() );
-	DotName INHERITANCE = DotName.createSimple( Inheritance.class.getName() );
-	DotName JOIN_COLUMNS = DotName.createSimple( JoinColumns.class.getName() );
-	DotName JOIN_TABLE = DotName.createSimple( JoinTable.class.getName() );
-	DotName LOB = DotName.createSimple( Lob.class.getName() );
-	DotName LOCK_MODE_TYPE = DotName.createSimple( LockModeType.class.getName() );
-	DotName MANY_TO_MANY = DotName.createSimple( ManyToMany.class.getName() );
-	DotName MANY_TO_ONE = DotName.createSimple( ManyToOne.class.getName() );
-	DotName MAP_KEY = DotName.createSimple( MapKey.class.getName() );
-	DotName MAP_KEY_CLASS = DotName.createSimple( MapKeyClass.class.getName() );
-	DotName MAP_KEY_COLUMN = DotName.createSimple( MapKeyColumn.class.getName() );
-	DotName MAP_KEY_ENUMERATED = DotName.createSimple( MapKeyEnumerated.class.getName() );
-	DotName MAP_KEY_JOIN_COLUMN = DotName.createSimple( MapKeyJoinColumn.class.getName() );
-	DotName MAP_KEY_JOIN_COLUMNS = DotName.createSimple( MapKeyJoinColumns.class.getName() );
-	DotName MAP_KEY_TEMPORAL = DotName.createSimple( MapKeyTemporal.class.getName() );
-	DotName MAPPED_SUPERCLASS = DotName.createSimple( MappedSuperclass.class.getName() );
-	DotName MAPS_ID = DotName.createSimple( MapsId.class.getName() );
-	DotName NAMED_NATIVE_QUERIES = DotName.createSimple( NamedNativeQueries.class.getName() );
-	DotName NAMED_NATIVE_QUERY = DotName.createSimple( NamedNativeQuery.class.getName() );
-	DotName NAMED_QUERIES = DotName.createSimple( NamedQueries.class.getName() );
-	DotName NAMED_QUERY = DotName.createSimple( NamedQuery.class.getName() );
-	DotName ONE_TO_MANY = DotName.createSimple( OneToMany.class.getName() );
-	DotName ONE_TO_ONE = DotName.createSimple( OneToOne.class.getName() );
-	DotName ORDER_BY = DotName.createSimple( OrderBy.class.getName() );
-	DotName ORDER_COLUMN = DotName.createSimple( OrderColumn.class.getName() );
-	DotName PERSISTENCE_CONTEXT = DotName.createSimple( PersistenceContext.class.getName() );
-	DotName PERSISTENCE_CONTEXTS = DotName.createSimple( PersistenceContexts.class.getName() );
-	DotName PERSISTENCE_PROPERTY = DotName.createSimple( PersistenceProperty.class.getName() );
-	DotName PERSISTENCE_UNIT = DotName.createSimple( PersistenceUnit.class.getName() );
-	DotName PERSISTENCE_UNITS = DotName.createSimple( PersistenceUnits.class.getName() );
-	DotName POST_LOAD = DotName.createSimple( PostLoad.class.getName() );
-	DotName POST_PERSIST = DotName.createSimple( PostPersist.class.getName() );
-	DotName POST_REMOVE = DotName.createSimple( PostRemove.class.getName() );
-	DotName POST_UPDATE = DotName.createSimple( PostUpdate.class.getName() );
-	DotName PRE_PERSIST = DotName.createSimple( PrePersist.class.getName() );
-	DotName PRE_REMOVE = DotName.createSimple( PreRemove.class.getName() );
-	DotName PRE_UPDATE = DotName.createSimple( PreUpdate.class.getName() );
-	DotName PRIMARY_KEY_JOIN_COLUMN = DotName.createSimple( PrimaryKeyJoinColumn.class.getName() );
-	DotName PRIMARY_KEY_JOIN_COLUMNS = DotName.createSimple( PrimaryKeyJoinColumns.class.getName() );
-	DotName QUERY_HINT = DotName.createSimple( QueryHint.class.getName() );
-	DotName SECONDARY_TABLE = DotName.createSimple( SecondaryTable.class.getName() );
-	DotName SECONDARY_TABLES = DotName.createSimple( SecondaryTables.class.getName() );
-	DotName SEQUENCE_GENERATOR = DotName.createSimple( SequenceGenerator.class.getName() );
-	DotName SQL_RESULT_SET_MAPPING = DotName.createSimple( SqlResultSetMapping.class.getName() );
-	DotName SQL_RESULT_SET_MAPPINGS = DotName.createSimple( SqlResultSetMappings.class.getName() );
-	DotName TABLE = DotName.createSimple( Table.class.getName() );
-	DotName TABLE_GENERATOR = DotName.createSimple( TableGenerator.class.getName() );
-	DotName TEMPORAL = DotName.createSimple( Temporal.class.getName() );
-	DotName TEMPORAL_TYPE = DotName.createSimple( TemporalType.class.getName() );
-	DotName TRANSIENT = DotName.createSimple( Transient.class.getName() );
-	DotName UNIQUE_CONSTRAINT = DotName.createSimple( UniqueConstraint.class.getName() );
-	DotName VERSION = DotName.createSimple( Version.class.getName() );
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
deleted file mode 100644
index 0a7270300d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.beans.Introspector;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.HibernateException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.util.type.PrimitiveWrapperHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.FieldInfo;
-import org.jboss.jandex.Index;
-import org.jboss.jandex.Indexer;
-import org.jboss.jandex.MethodInfo;
-import org.jboss.jandex.Type;
-
-/**
- * Utility methods for working with the jandex annotation index.
- *
- * @author Hardy Ferentschik
- */
-public class JandexHelper {
-	private static final Map<String, Object> DEFAULT_VALUES_BY_ELEMENT = new HashMap<String, Object>();
-
-	private JandexHelper() {
-	}
-
-	/**
-	 * Retrieves a jandex annotation element value. If the value is {@code null}, the default value specified in the
-	 * annotation class is retrieved instead.
-	 * <p>
-	 * There are two special cases. {@code Class} parameters should be retrieved as strings (and then can later be
-	 * loaded) and enumerated values should be retrieved via {@link #getEnumValue(AnnotationInstance, String, Class)}.
-	 * </p>
-	 *
-	 * @param annotation the annotation containing the element with the supplied name
-	 * @param element the name of the element value to be retrieve
-	 * @param type the type of element to retrieve. The following types are supported:
-	 * <ul>
-	 * <li>Byte</li>
-	 * <li>Short</li>
-	 * <li>Integer</li>
-	 * <li>Character</li>
-	 * <li>Float</li>
-	 * <li>Double</li>
-	 * <li>Long</li>
-	 * <li>Boolean</li>
-	 * <li>String</li>
-	 * <li>AnnotationInstance</li>
-	 *
-	 * @return the value if not {@code null}, else the default value if not
-	 *         {@code null}, else {@code null}.
-	 *
-	 * @throws AssertionFailure in case the specified {@code type} is a class instance or the specified type causes a {@code ClassCastException}
-	 * when retrieving the value.
-	 */
-	@SuppressWarnings("unchecked")
-	public static <T> T getValue(AnnotationInstance annotation, String element, Class<T> type) throws AssertionFailure {
-		if ( Class.class.equals( type ) ) {
-			throw new AssertionFailure(
-					"Annotation parameters of type Class should be retrieved as strings (fully qualified class names)"
-			);
-		}
-
-		if ( type.isPrimitive() ) {
-			type = PrimitiveWrapperHelper.getDescriptorByPrimitiveType( type ).getWrapperClass();
-		}
-
-		// try getting the untyped value from Jandex
-		AnnotationValue annotationValue = annotation.value( element );
-
-		try {
-			if ( annotationValue != null ) {
-				return explicitAnnotationParameter( annotationValue, type );
-			}
-			else {
-				return defaultAnnotationParameter( getDefaultValue( annotation, element ), type );
-			}
-		}
-		catch ( ClassCastException e ) {
-			throw new AssertionFailure(
-					String.format(
-							"the annotation property %s of annotation %s is not of type %s",
-							element,
-							annotation.name(),
-							type.getName()
-					),
-					e
-			);
-		}
-	}
-	
-	// THIS IS FOR 4.3.x AND SHOULD BE CONSIDERED TEMPORARY.  HHH-8118 corrected CL use in JandexHelper by adding
-	// CLS as method arguments.  But that was done in the metamodel branch only before I knew that master added a few
-	// uses.  HHH-8316 needs it for 4.3.  DO NOT LET THIS GET MERGED INTO METAMODEL!
-	public static <T> T getValue(AnnotationInstance annotation, String element, Class<T> type,
-			ClassLoaderService classLoaderService) throws AssertionFailure {
-		if ( Class.class.equals( type ) ) {
-			throw new AssertionFailure(
-					"Annotation parameters of type Class should be retrieved as strings (fully qualified class names)"
-			);
-		}
-
-		if ( type.isPrimitive() ) {
-			type = PrimitiveWrapperHelper.getDescriptorByPrimitiveType( type ).getWrapperClass();
-		}
-
-		// try getting the untyped value from Jandex
-		AnnotationValue annotationValue = annotation.value( element );
-
-		try {
-			if ( annotationValue != null ) {
-				return explicitAnnotationParameter( annotationValue, type );
-			}
-			else {
-				return defaultAnnotationParameter( getDefaultValue( annotation, element, classLoaderService ), type );
-			}
-		}
-		catch ( ClassCastException e ) {
-			throw new AssertionFailure(
-					String.format(
-							"the annotation property %s of annotation %s is not of type %s",
-							element,
-							annotation.name(),
-							type.getName()
-					),
-					e
-			);
-		}
-	}
-
-	/**
-	 * Retrieves a jandex annotation element value, converting it to the supplied enumerated type.  If the value is
-	 * <code>null</code>, the default value specified in the annotation class is retrieved instead.
-	 *
-	 * @param <T> an enumerated type
-	 * @param annotation the annotation containing the enumerated element with the supplied name
-	 * @param element the name of the enumerated element value to be retrieve
-	 * @param type the type to which to convert the value before being returned
-	 *
-	 * @return the value converted to the supplied enumerated type if the value is not <code>null</code>, else the default value if
-	 *         not <code>null</code>, else <code>null</code>.
-	 *
-	 * @see #getValue(AnnotationInstance, String, Class)
-	 */
-	@SuppressWarnings("unchecked")
-	public static <T extends Enum<T>> T getEnumValue(AnnotationInstance annotation, String element, Class<T> type) {
-		AnnotationValue val = annotation.value( element );
-		if ( val == null ) {
-			return (T) getDefaultValue( annotation, element );
-		}
-		return Enum.valueOf( type, val.asEnum() );
-	}
-
-	/**
-	 * Expects a method or field annotation target and returns the property name for this target
-	 *
-	 * @param target the annotation target
-	 *
-	 * @return the property name of the target. For a field it is the field name and for a method name it is
-	 *         the method name stripped of 'is', 'has' or 'get'
-	 */
-	public static String getPropertyName(AnnotationTarget target) {
-		if ( !( target instanceof MethodInfo || target instanceof FieldInfo ) ) {
-			throw new AssertionFailure( "Unexpected annotation target " + target.toString() );
-		}
-
-		if ( target instanceof FieldInfo ) {
-			return ( (FieldInfo) target ).name();
-		}
-		else {
-			final String methodName = ( (MethodInfo) target ).name();
-			String propertyName;
-			if ( methodName.startsWith( "is" ) ) {
-				propertyName = Introspector.decapitalize( methodName.substring( 2 ) );
-			}
-			else if ( methodName.startsWith( "has" ) ) {
-				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
-			}
-			else if ( methodName.startsWith( "get" ) ) {
-				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
-			}
-			else {
-				throw new AssertionFailure( "Expected a method following the Java Bean notation" );
-			}
-			return propertyName;
-		}
-	}
-
-	/**
-	 * @param classInfo the class info from which to retrieve the annotation instance
-	 * @param annotationName the annotation to retrieve from the class info
-	 *
-	 * @return the single annotation defined on the class or {@code null} in case the annotation is not specified at all
-	 *
-	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
-	 */
-	public static AnnotationInstance getSingleAnnotation(ClassInfo classInfo, DotName annotationName)
-			throws AssertionFailure {
-		return getSingleAnnotation( classInfo.annotations(), annotationName );
-	}
-
-	/**
-	 * @param annotations List of annotation instances keyed against their dot name.
-	 * @param annotationName the annotation to retrieve from map
-	 *
-	 * @return the single annotation of the specified dot name or {@code null} in case the annotation is not specified at all
-	 *
-	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
-	 */
-	public static AnnotationInstance getSingleAnnotation(Map<DotName, List<AnnotationInstance>> annotations, DotName annotationName)
-			throws AssertionFailure {
-		List<AnnotationInstance> annotationList = annotations.get( annotationName );
-		if ( annotationList == null ) {
-			return null;
-		}
-		else if ( annotationList.size() == 1 ) {
-			return annotationList.get( 0 );
-		}
-		else {
-			throw new AssertionFailure(
-					"Found more than one instance of the annotation "
-							+ annotationList.get( 0 ).name().toString()
-							+ ". Expected was one."
-			);
-		}
-	}
-
-	/**
-	 * @param annotations List of annotation instances keyed against their dot name.
-	 * @param annotationName the annotation to check
-	 *
-	 * @return returns {@code true} if the map contains only a single instance of specified annotation or {@code false} otherwise.
-	 *
-	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
-	 */
-	public static boolean containsSingleAnnotations(Map<DotName, List<AnnotationInstance>> annotations, DotName annotationName)
-			throws AssertionFailure {
-		return getSingleAnnotation( annotations, annotationName ) != null;
-	}
-
-	/**
-	 * Creates a jandex index for the specified classes
-	 *
-	 * @param classLoaderService class loader service
-	 * @param classes the classes to index
-	 *
-	 * @return an annotation repository w/ all the annotation discovered in the specified classes
-	 */
-	public static Index indexForClass(ClassLoaderService classLoaderService, Class<?>... classes) {
-		Indexer indexer = new Indexer();
-		for ( Class<?> clazz : classes ) {
-			InputStream stream = classLoaderService.locateResourceStream(
-					clazz.getName().replace( '.', '/' ) + ".class"
-			);
-			try {
-				indexer.index( stream );
-			}
-			catch ( IOException e ) {
-				StringBuilder builder = new StringBuilder();
-				builder.append( "[" );
-				int count = 0;
-				for ( Class<?> c : classes ) {
-					builder.append( c.getName() );
-					if ( count < classes.length - 1 ) {
-						builder.append( "," );
-					}
-					count++;
-				}
-				builder.append( "]" );
-				throw new HibernateException( "Unable to create annotation index for " + builder.toString() );
-			}
-		}
-		return indexer.complete();
-	}
-
-	public static Map<DotName, List<AnnotationInstance>> getMemberAnnotations(ClassInfo classInfo, String name) {
-		if ( classInfo == null ) {
-			throw new IllegalArgumentException( "classInfo cannot be null" );
-		}
-
-		if ( name == null ) {
-			throw new IllegalArgumentException( "name cannot be null" );
-		}
-
-		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
-		for ( List<AnnotationInstance> annotationList : classInfo.annotations().values() ) {
-			for ( AnnotationInstance instance : annotationList ) {
-				String targetName = null;
-				if ( instance.target() instanceof FieldInfo ) {
-					targetName = ( (FieldInfo) instance.target() ).name();
-				}
-				else if ( instance.target() instanceof MethodInfo ) {
-					targetName = ( (MethodInfo) instance.target() ).name();
-				}
-				if ( targetName != null && name.equals( targetName ) ) {
-					addAnnotationToMap( instance, annotations );
-				}
-			}
-		}
-		return annotations;
-	}
-
-	private static void addAnnotationToMap(AnnotationInstance instance, Map<DotName, List<AnnotationInstance>> annotations) {
-		DotName dotName = instance.name();
-		List<AnnotationInstance> list;
-		if ( annotations.containsKey( dotName ) ) {
-			list = annotations.get( dotName );
-		}
-		else {
-			list = new ArrayList<AnnotationInstance>();
-			annotations.put( dotName, list );
-		}
-		list.add( instance );
-	}
-
-	private static Object getDefaultValue(AnnotationInstance annotation, String element) {
-		String name = annotation.name().toString();
-		String fqElement = name + '.' + element;
-		Object val = DEFAULT_VALUES_BY_ELEMENT.get( fqElement );
-		if ( val != null ) {
-			return val;
-		}
-		try {
-			val = Index.class.getClassLoader().loadClass( name ).getMethod( element ).getDefaultValue();
-			DEFAULT_VALUES_BY_ELEMENT.put( fqElement, val );
-			return val == null ? null : val;
-		}
-		catch ( RuntimeException error ) {
-			throw error;
-		}
-		catch ( Exception error ) {
-			throw new AssertionFailure(
-					String.format( "The annotation %s does not define a parameter '%s'", name, element ),
-					error
-			);
-		}
-	}
-
-	// THIS IS FOR 4.3.x AND SHOULD BE CONSIDERED TEMPORARY.  HHH-8118 corrected CL use in JandexHelper by adding
-	// CLS as method arguments.  But that was done in the metamodel branch only before I knew that master added a few
-	// uses.  HHH-8316 needs it for 4.3.  DO NOT LET THIS GET MERGED INTO METAMODEL!
-	private static Object getDefaultValue(AnnotationInstance annotation, String element,
-			ClassLoaderService classLoaderService) {
-		String name = annotation.name().toString();
-		String fqElement = name + '.' + element;
-		Object val = DEFAULT_VALUES_BY_ELEMENT.get( fqElement );
-		if ( val != null ) {
-			return val;
-		}
-		try {
-			val = classLoaderService.classForName( name ).getMethod( element ).getDefaultValue();
-			if ( val != null ) {
-				// Annotation parameters of type Class are handled using Strings
-				if ( val instanceof Class ) {
-					val = ( ( Class ) val ).getName();
-				}
-			}
-			DEFAULT_VALUES_BY_ELEMENT.put( fqElement, val );
-			return val;
-		}
-		catch ( RuntimeException error ) {
-			throw error;
-		}
-		catch ( Exception error ) {
-			throw new AssertionFailure(
-					String.format( "The annotation %s does not define a parameter '%s'", name, element ),
-					error
-			);
-		}
-	}
-
-	private static <T> T defaultAnnotationParameter(Object defaultValue, Class<T> type) {
-		Object returnValue = defaultValue;
-
-		// resolve some mismatches between what's stored in jandex and what the defaults are for annotations
-		// in case of nested annotation arrays, jandex returns arrays of AnnotationInstances, hence we return
-		// an empty array of this type here
-		if ( defaultValue.getClass().isArray() && defaultValue.getClass().getComponentType().isAnnotation() ) {
-			returnValue = new AnnotationInstance[0];
-		}
-		return type.cast( returnValue );
-	}
-
-	private static <T> T explicitAnnotationParameter(AnnotationValue annotationValue, Class<T> type) {
-		Object returnValue = annotationValue.value();
-
-		// if the jandex return type is Type we actually try to retrieve a class parameter
-		// for our purposes we just return the fqcn of the class
-		if ( returnValue instanceof Type ) {
-			returnValue = ( (Type) returnValue ).name().toString();
-		}
-
-		// arrays we have to handle explicitly
-		if ( type.isArray() ) {
-			AnnotationValue[] values = (AnnotationValue[]) returnValue;
-			Class<?> componentType = type.getComponentType();
-			Object[] arr = (Object[]) Array.newInstance( componentType, values.length );
-			for ( int i = 0; i < values.length; i++ ) {
-				arr[i] = componentType.cast( values[i].value() );
-			}
-			returnValue = arr;
-		}
-
-		return type.cast( returnValue );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java
deleted file mode 100644
index 8b1f1a49dc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import java.beans.Introspector;
-import java.lang.reflect.Field;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Some helper methods for reflection tasks
- *
- * @author Hardy Ferentschik
- */
-public class ReflectionHelper {
-
-	private ReflectionHelper() {
-	}
-
-	/**
-	 * Process bean properties getter by applying the JavaBean naming conventions.
-	 *
-	 * @param member the member for which to get the property name.
-	 *
-	 * @return The bean method name with the "is" or "get" prefix stripped off, {@code null}
-	 *         the method name id not according to the JavaBeans standard.
-	 */
-	public static String getPropertyName(Member member) {
-		String name = null;
-
-		if ( member instanceof Field ) {
-			name = member.getName();
-		}
-
-		if ( member instanceof Method ) {
-			String methodName = member.getName();
-			if ( methodName.startsWith( "is" ) ) {
-				name = Introspector.decapitalize( methodName.substring( 2 ) );
-			}
-			else if ( methodName.startsWith( "has" ) ) {
-				name = Introspector.decapitalize( methodName.substring( 3 ) );
-			}
-			else if ( methodName.startsWith( "get" ) ) {
-				name = Introspector.decapitalize( methodName.substring( 3 ) );
-			}
-		}
-		return name;
-	}
-
-	public static boolean isProperty(Member m) {
-		if ( m instanceof Method ) {
-			Method method = (Method) m;
-			return !method.isSynthetic()
-					&& !method.isBridge()
-					&& !Modifier.isStatic( method.getModifiers() )
-					&& method.getParameterTypes().length == 0
-					&& ( method.getName().startsWith( "get" ) || method.getName().startsWith( "is" ) );
-		}
-		else {
-			return !Modifier.isTransient( m.getModifiers() ) && !m.isSynthetic();
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java
deleted file mode 100644
index 1f492d5d6c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations;
-
-import org.hibernate.HibernateException;
-
-/**
- * @author Steve Ebersole
- */
-public class UnknownInheritanceTypeException extends HibernateException {
-	public UnknownInheritanceTypeException(String message) {
-		super( message );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java
deleted file mode 100644
index 8c81080eac..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.persistence.CascadeType;
-import javax.persistence.FetchType;
-
-import org.hibernate.FetchMode;
-import org.hibernate.annotations.NotFoundAction;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.annotations.EnumConversionHelper;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolver;
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolverImpl;
-import org.hibernate.metamodel.source.annotations.attribute.type.CompositeAttributeTypeResolver;
-import org.hibernate.metamodel.source.annotations.entity.EntityBindingContext;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-
-/**
- * Represents an association attribute.
- *
- * @author Hardy Ferentschik
- * @todo Check whether we need further subclasses for different association types. Needs to evolve during development (HF)
- */
-public class AssociationAttribute extends MappedAttribute {
-	private final AttributeNature associationNature;
-	private final boolean ignoreNotFound;
-	private final String referencedEntityType;
-	private final String mappedBy;
-	private final Set<CascadeType> cascadeTypes;
-	private final boolean isOptional;
-	private final boolean isLazy;
-	private final boolean isOrphanRemoval;
-	private final FetchMode fetchMode;
-	private final boolean mapsId;
-	private final String referencedIdAttributeName;
-
-	private boolean isInsertable = true;
-	private boolean isUpdatable = true;
-	private AttributeTypeResolver resolver;
-
-	public static AssociationAttribute createAssociationAttribute(String name,
-																  Class<?> attributeType,
-																  AttributeNature attributeNature,
-																  String accessType,
-																  Map<DotName, List<AnnotationInstance>> annotations,
-																  EntityBindingContext context) {
-		return new AssociationAttribute(
-				name,
-				attributeType,
-				attributeNature,
-				accessType,
-				annotations,
-				context
-		);
-	}
-
-	private AssociationAttribute(String name,
-								 Class<?> javaType,
-								 AttributeNature associationType,
-								 String accessType,
-								 Map<DotName, List<AnnotationInstance>> annotations,
-								 EntityBindingContext context) {
-		super( name, javaType, accessType, annotations, context );
-		this.associationNature = associationType;
-		this.ignoreNotFound = ignoreNotFound();
-
-		AnnotationInstance associationAnnotation = JandexHelper.getSingleAnnotation(
-				annotations,
-				associationType.getAnnotationDotName()
-		);
-
-		// using jandex we don't really care which exact type of annotation we are dealing with
-		this.referencedEntityType = determineReferencedEntityType( associationAnnotation );
-		this.mappedBy = determineMappedByAttributeName( associationAnnotation );
-		this.isOptional = determineOptionality( associationAnnotation );
-		this.isLazy = determineFetchType( associationAnnotation );
-		this.isOrphanRemoval = determineOrphanRemoval( associationAnnotation );
-		this.cascadeTypes = determineCascadeTypes( associationAnnotation );
-
-		this.fetchMode = determineFetchMode();
-		this.referencedIdAttributeName = determineMapsId();
-		this.mapsId = referencedIdAttributeName != null;
-	}
-
-	public boolean isIgnoreNotFound() {
-		return ignoreNotFound;
-	}
-
-	public String getReferencedEntityType() {
-		return referencedEntityType;
-	}
-
-	public String getMappedBy() {
-		return mappedBy;
-	}
-
-	public AttributeNature getAssociationNature() {
-		return associationNature;
-	}
-
-	public Set<CascadeType> getCascadeTypes() {
-		return cascadeTypes;
-	}
-
-	public boolean isOrphanRemoval() {
-		return isOrphanRemoval;
-	}
-
-	public FetchMode getFetchMode() {
-		return fetchMode;
-	}
-
-	public String getReferencedIdAttributeName() {
-		return referencedIdAttributeName;
-	}
-
-	public boolean mapsId() {
-		return mapsId;
-	}
-
-	@Override
-	public AttributeTypeResolver getHibernateTypeResolver() {
-		if ( resolver == null ) {
-			resolver = getDefaultHibernateTypeResolver();
-		}
-		return resolver;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return isLazy;
-	}
-
-	@Override
-	public boolean isOptional() {
-		return isOptional;
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return isInsertable;
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return isUpdatable;
-	}
-
-	@Override
-	public PropertyGeneration getPropertyGeneration() {
-		return PropertyGeneration.NEVER;
-	}
-
-	private AttributeTypeResolver getDefaultHibernateTypeResolver() {
-		return new CompositeAttributeTypeResolver( new AttributeTypeResolverImpl( this ) );
-	}
-
-	private boolean ignoreNotFound() {
-		NotFoundAction action = NotFoundAction.EXCEPTION;
-		AnnotationInstance notFoundAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.NOT_FOUND
-		);
-		if ( notFoundAnnotation != null ) {
-			AnnotationValue actionValue = notFoundAnnotation.value( "action" );
-			if ( actionValue != null ) {
-				action = Enum.valueOf( NotFoundAction.class, actionValue.asEnum() );
-			}
-		}
-
-		return NotFoundAction.IGNORE.equals( action );
-	}
-
-	private boolean determineOptionality(AnnotationInstance associationAnnotation) {
-		boolean optional = true;
-
-		AnnotationValue optionalValue = associationAnnotation.value( "optional" );
-		if ( optionalValue != null ) {
-			optional = optionalValue.asBoolean();
-		}
-
-		return optional;
-	}
-
-	private boolean determineOrphanRemoval(AnnotationInstance associationAnnotation) {
-		boolean orphanRemoval = false;
-		AnnotationValue orphanRemovalValue = associationAnnotation.value( "orphanRemoval" );
-		if ( orphanRemovalValue != null ) {
-			orphanRemoval = orphanRemovalValue.asBoolean();
-		}
-		return orphanRemoval;
-	}
-
-	private boolean determineFetchType(AnnotationInstance associationAnnotation) {
-		boolean lazy = false;
-		AnnotationValue fetchValue = associationAnnotation.value( "fetch" );
-		if ( fetchValue != null ) {
-			FetchType fetchType = Enum.valueOf( FetchType.class, fetchValue.asEnum() );
-			if ( FetchType.LAZY.equals( fetchType ) ) {
-				lazy = true;
-			}
-		}
-		return lazy;
-	}
-
-	private String determineReferencedEntityType(AnnotationInstance associationAnnotation) {
-		String targetTypeName = getAttributeType().getName();
-
-		AnnotationInstance targetAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.TARGET
-		);
-		if ( targetAnnotation != null ) {
-			targetTypeName = targetAnnotation.value().asClass().name().toString();
-		}
-
-		AnnotationValue targetEntityValue = associationAnnotation.value( "targetEntity" );
-		if ( targetEntityValue != null ) {
-			targetTypeName = targetEntityValue.asClass().name().toString();
-		}
-
-		return targetTypeName;
-	}
-
-	private String determineMappedByAttributeName(AnnotationInstance associationAnnotation) {
-		String mappedBy = null;
-		AnnotationValue mappedByAnnotationValue = associationAnnotation.value( "mappedBy" );
-		if ( mappedByAnnotationValue != null ) {
-			mappedBy = mappedByAnnotationValue.asString();
-		}
-
-		return mappedBy;
-	}
-
-	private Set<CascadeType> determineCascadeTypes(AnnotationInstance associationAnnotation) {
-		Set<CascadeType> cascadeTypes = new HashSet<CascadeType>();
-		AnnotationValue cascadeValue = associationAnnotation.value( "cascade" );
-		if ( cascadeValue != null ) {
-			String[] cascades = cascadeValue.asEnumArray();
-			for ( String s : cascades ) {
-				cascadeTypes.add( Enum.valueOf( CascadeType.class, s ) );
-			}
-		}
-		return cascadeTypes;
-	}
-
-	private FetchMode determineFetchMode() {
-		FetchMode mode = FetchMode.DEFAULT;
-
-		AnnotationInstance fetchAnnotation = JandexHelper.getSingleAnnotation( annotations(), HibernateDotNames.FETCH );
-		if ( fetchAnnotation != null ) {
-			org.hibernate.annotations.FetchMode annotationFetchMode = JandexHelper.getEnumValue(
-					fetchAnnotation,
-					"value",
-					org.hibernate.annotations.FetchMode.class
-			);
-			mode = EnumConversionHelper.annotationFetchModeToHibernateFetchMode( annotationFetchMode );
-		}
-
-		return mode;
-	}
-
-	private String determineMapsId() {
-		String referencedIdAttributeName;
-		AnnotationInstance mapsIdAnnotation = JandexHelper.getSingleAnnotation( annotations(), JPADotNames.MAPS_ID );
-		if ( mapsIdAnnotation == null ) {
-			return null;
-		}
-
-		if ( !( AttributeNature.MANY_TO_ONE.equals( getAssociationNature() ) || AttributeNature.MANY_TO_ONE
-				.equals( getAssociationNature() ) ) ) {
-			throw new MappingException(
-					"@MapsId can only be specified on a many-to-one or one-to-one associations",
-					getContext().getOrigin()
-			);
-		}
-
-		referencedIdAttributeName = JandexHelper.getValue( mapsIdAnnotation, "value", String.class );
-
-		return referencedIdAttributeName;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeNature.java
deleted file mode 100644
index 8cf9228198..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeNature.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import org.jboss.jandex.DotName;
-
-/**
- * An enum defining the type of a mapped attribute.
- *
- * @author Hardy Ferentschik
- */
-public enum AttributeNature {
-	BASIC( JPADotNames.BASIC ),
-	ONE_TO_ONE( JPADotNames.ONE_TO_ONE ),
-	ONE_TO_MANY( JPADotNames.ONE_TO_MANY ),
-	MANY_TO_ONE( JPADotNames.MANY_TO_ONE ),
-	MANY_TO_MANY( JPADotNames.MANY_TO_MANY ),
-	ELEMENT_COLLECTION( JPADotNames.ELEMENT_COLLECTION ),
-	EMBEDDED_ID( JPADotNames.EMBEDDED_ID ),
-	EMBEDDED( JPADotNames.EMBEDDED );
-
-	private final DotName annotationDotName;
-
-	AttributeNature(DotName annotationDotName) {
-		this.annotationDotName = annotationDotName;
-	}
-
-	public DotName getAnnotationDotName() {
-		return annotationDotName;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeOverride.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeOverride.java
deleted file mode 100644
index 1f36ab1f58..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AttributeOverride.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * Contains the information about a single {@link javax.persistence.AttributeOverride}. Instances of this class
- * are creating during annotation processing and then applied onto the persistence attributes.
- *
- * @author Hardy Ferentschik
- * @todo Take care of prefixes of the form 'element', 'key' and 'value'. Add another type enum to handle this. (HF)
- */
-public class AttributeOverride {
-	private static final String PROPERTY_PATH_SEPARATOR = ".";
-	private final ColumnValues columnValues;
-	private final String attributePath;
-
-	public AttributeOverride(AnnotationInstance attributeOverrideAnnotation) {
-		this( null, attributeOverrideAnnotation );
-	}
-
-	public AttributeOverride(String prefix, AnnotationInstance attributeOverrideAnnotation) {
-		if ( attributeOverrideAnnotation == null ) {
-			throw new IllegalArgumentException( "An AnnotationInstance needs to be passed" );
-		}
-
-		if ( !JPADotNames.ATTRIBUTE_OVERRIDE.equals( attributeOverrideAnnotation.name() ) ) {
-			throw new AssertionFailure( "A @AttributeOverride annotation needs to be passed to the constructor" );
-		}
-
-		columnValues = new ColumnValues(
-				JandexHelper.getValue(
-						attributeOverrideAnnotation,
-						"column",
-						AnnotationInstance.class
-				)
-		);
-		attributePath = createAttributePath(
-				prefix,
-				JandexHelper.getValue( attributeOverrideAnnotation, "name", String.class )
-		);
-	}
-
-	public ColumnValues getColumnValues() {
-		return columnValues;
-	}
-
-	public String getAttributePath() {
-		return attributePath;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "AttributeOverride" );
-		sb.append( "{columnValues=" ).append( columnValues );
-		sb.append( ", attributePath='" ).append( attributePath ).append( '\'' );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		AttributeOverride that = (AttributeOverride) o;
-
-		if ( attributePath != null ? !attributePath.equals( that.attributePath ) : that.attributePath != null ) {
-			return false;
-		}
-		if ( columnValues != null ? !columnValues.equals( that.columnValues ) : that.columnValues != null ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public int hashCode() {
-		int result = columnValues != null ? columnValues.hashCode() : 0;
-		result = 31 * result + ( attributePath != null ? attributePath.hashCode() : 0 );
-		return result;
-	}
-
-	private String createAttributePath(String prefix, String name) {
-		String path = "";
-		if ( StringHelper.isNotEmpty( prefix ) ) {
-			path += prefix;
-		}
-		if ( StringHelper.isNotEmpty( path ) && !path.endsWith( PROPERTY_PATH_SEPARATOR ) ) {
-			path += PROPERTY_PATH_SEPARATOR;
-		}
-		path += name;
-		return path;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/BasicAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/BasicAttribute.java
deleted file mode 100644
index 280edcf9bf..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/BasicAttribute.java
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import javax.persistence.FetchType;
-import javax.persistence.GenerationType;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.annotations.GenerationTime;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.annotations.EnumConversionHelper;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolver;
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolverImpl;
-import org.hibernate.metamodel.source.annotations.attribute.type.CompositeAttributeTypeResolver;
-import org.hibernate.metamodel.source.annotations.attribute.type.EnumeratedTypeResolver;
-import org.hibernate.metamodel.source.annotations.attribute.type.LobTypeResolver;
-import org.hibernate.metamodel.source.annotations.attribute.type.TemporalTypeResolver;
-import org.hibernate.metamodel.source.annotations.entity.EntityBindingContext;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-
-/**
- * Represent a basic attribute (explicitly or implicitly mapped).
- *
- * @author Hardy Ferentschik
- */
-public class BasicAttribute extends MappedAttribute {
-
-	/**
-	 * The id generator in case this basic attribute represents an simple id. Will be {@code null} in case there
-	 * is no explicit id generator or the containing entity does not have a simple id
-	 */
-	private final IdGenerator idGenerator;
-
-	/**
-	 * Is this a versioned property (annotated w/ {@code @Version}.
-	 */
-	private final boolean isVersioned;
-
-	/**
-	 * Is this property lazy loaded (see {@link javax.persistence.Basic}).
-	 */
-	private boolean isLazy = false;
-
-	/**
-	 * Is this property optional  (see {@link javax.persistence.Basic}).
-	 */
-	private boolean isOptional = true;
-
-	/**
-	 * Are this properties generated and when
-	 */
-	private PropertyGeneration propertyGeneration;
-	private boolean isInsertable = true;
-	private boolean isUpdatable = true;
-
-	private final String customWriteFragment;
-	private final String customReadFragment;
-	private final String checkCondition;
-	private AttributeTypeResolver resolver;
-
-	public static BasicAttribute createSimpleAttribute(String name,
-													   Class<?> attributeType,
-													   Map<DotName, List<AnnotationInstance>> annotations,
-													   String accessType,
-													   EntityBindingContext context) {
-		return new BasicAttribute( name, attributeType, accessType, annotations, context );
-	}
-
-	BasicAttribute(String name,
-				   Class<?> attributeType,
-				   String accessType,
-				   Map<DotName, List<AnnotationInstance>> annotations,
-				   EntityBindingContext context) {
-		super( name, attributeType, accessType, annotations, context );
-
-		AnnotationInstance versionAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.VERSION );
-		isVersioned = versionAnnotation != null;
-
-		if ( isId() ) {
-			// an id must be unique and cannot be nullable
-			getColumnValues().setUnique( true );
-			getColumnValues().setNullable( false );
-			idGenerator = checkGeneratedValueAnnotation();
-		}
-		else {
-			idGenerator = null;
-		}
-
-		checkBasicAnnotation();
-		checkGeneratedAnnotation();
-
-		List<AnnotationInstance> columnTransformerAnnotations = getAllColumnTransformerAnnotations();
-		String[] readWrite = createCustomReadWrite( columnTransformerAnnotations );
-		this.customReadFragment = readWrite[0];
-		this.customWriteFragment = readWrite[1];
-		this.checkCondition = parseCheckAnnotation();
-	}
-
-	public boolean isVersioned() {
-		return isVersioned;
-	}
-
-	public boolean isLazy() {
-		return isLazy;
-	}
-
-	public boolean isOptional() {
-		return isOptional;
-	}
-
-	public boolean isInsertable() {
-		return isInsertable;
-	}
-
-	public boolean isUpdatable() {
-		return isUpdatable;
-	}
-
-	public PropertyGeneration getPropertyGeneration() {
-		return propertyGeneration;
-	}
-
-	public String getCustomWriteFragment() {
-		return customWriteFragment;
-	}
-
-	public String getCustomReadFragment() {
-		return customReadFragment;
-	}
-
-	public String getCheckCondition() {
-		return checkCondition;
-	}
-
-	public IdGenerator getIdGenerator() {
-		return idGenerator;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "SimpleAttribute" );
-		sb.append( "{name=" ).append( getName() );
-		return sb.toString();
-	}
-
-	private void checkBasicAnnotation() {
-		AnnotationInstance basicAnnotation = JandexHelper.getSingleAnnotation( annotations(), JPADotNames.BASIC );
-		if ( basicAnnotation != null ) {
-			FetchType fetchType = FetchType.LAZY;
-			AnnotationValue fetchValue = basicAnnotation.value( "fetch" );
-			if ( fetchValue != null ) {
-				fetchType = Enum.valueOf( FetchType.class, fetchValue.asEnum() );
-			}
-			this.isLazy = fetchType == FetchType.LAZY;
-
-			AnnotationValue optionalValue = basicAnnotation.value( "optional" );
-			if ( optionalValue != null ) {
-				this.isOptional = optionalValue.asBoolean();
-			}
-		}
-	}
-
-	// TODO - there is more todo for updatable and insertable. Checking the @Generated annotation is only one part (HF)
-	private void checkGeneratedAnnotation() {
-		AnnotationInstance generatedAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.GENERATED
-		);
-		if ( generatedAnnotation != null ) {
-			this.isInsertable = false;
-
-			AnnotationValue generationTimeValue = generatedAnnotation.value();
-			if ( generationTimeValue != null ) {
-				GenerationTime genTime = Enum.valueOf( GenerationTime.class, generationTimeValue.asEnum() );
-				if ( GenerationTime.ALWAYS.equals( genTime ) ) {
-					this.isUpdatable = false;
-					this.propertyGeneration = PropertyGeneration.parse( genTime.toString().toLowerCase() );
-				}
-			}
-		}
-	}
-
-	private List<AnnotationInstance> getAllColumnTransformerAnnotations() {
-		List<AnnotationInstance> allColumnTransformerAnnotations = new ArrayList<AnnotationInstance>();
-
-		// not quite sure about the usefulness of @ColumnTransformers (HF)
-		AnnotationInstance columnTransformersAnnotations = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.COLUMN_TRANSFORMERS
-		);
-		if ( columnTransformersAnnotations != null ) {
-			AnnotationInstance[] annotationInstances = allColumnTransformerAnnotations.get( 0 ).value().asNestedArray();
-			allColumnTransformerAnnotations.addAll( Arrays.asList( annotationInstances ) );
-		}
-
-		AnnotationInstance columnTransformerAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.COLUMN_TRANSFORMER
-		);
-		if ( columnTransformerAnnotation != null ) {
-			allColumnTransformerAnnotations.add( columnTransformerAnnotation );
-		}
-		return allColumnTransformerAnnotations;
-	}
-
-	private String[] createCustomReadWrite(List<AnnotationInstance> columnTransformerAnnotations) {
-		String[] readWrite = new String[2];
-
-		boolean alreadyProcessedForColumn = false;
-		for ( AnnotationInstance annotationInstance : columnTransformerAnnotations ) {
-			String forColumn = annotationInstance.value( "forColumn" ) == null ?
-					null : annotationInstance.value( "forColumn" ).asString();
-
-			if ( forColumn != null && !forColumn.equals( getName() ) ) {
-				continue;
-			}
-
-			if ( alreadyProcessedForColumn ) {
-				throw new AnnotationException( "Multiple definition of read/write conditions for column " + getName() );
-			}
-
-			readWrite[0] = annotationInstance.value( "read" ) == null ?
-					null : annotationInstance.value( "read" ).asString();
-			readWrite[1] = annotationInstance.value( "write" ) == null ?
-					null : annotationInstance.value( "write" ).asString();
-
-			alreadyProcessedForColumn = true;
-		}
-		return readWrite;
-	}
-
-	private String parseCheckAnnotation() {
-		String checkCondition = null;
-		AnnotationInstance checkAnnotation = JandexHelper.getSingleAnnotation( annotations(), HibernateDotNames.CHECK );
-		if ( checkAnnotation != null ) {
-			checkCondition = checkAnnotation.value( "constraints" ).toString();
-		}
-		return checkCondition;
-	}
-
-	private IdGenerator checkGeneratedValueAnnotation() {
-		IdGenerator generator = null;
-		AnnotationInstance generatedValueAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				JPADotNames.GENERATED_VALUE
-		);
-		if ( generatedValueAnnotation != null ) {
-			String name = JandexHelper.getValue( generatedValueAnnotation, "generator", String.class );
-			if ( StringHelper.isNotEmpty( name ) ) {
-				generator = getContext().getMetadataImplementor().getIdGenerator( name );
-				if ( generator == null ) {
-					throw new MappingException( String.format( "Unable to find named generator %s", name ), null );
-				}
-			}
-			else {
-				GenerationType genType = JandexHelper.getEnumValue(
-						generatedValueAnnotation,
-						"strategy",
-						GenerationType.class
-				);
-				String strategy = EnumConversionHelper.generationTypeToGeneratorStrategyName(
-						genType,
-						getContext().getMetadataImplementor().getOptions().useNewIdentifierGenerators()
-				);
-				generator = new IdGenerator( null, strategy, null );
-			}
-		}
-		return generator;
-	}
-
-	@Override
-	public AttributeTypeResolver getHibernateTypeResolver() {
-		if ( resolver == null ) {
-			resolver = getDefaultHibernateTypeResolver();
-		}
-		return resolver;
-	}
-
-	private AttributeTypeResolver getDefaultHibernateTypeResolver() {
-		CompositeAttributeTypeResolver resolver = new CompositeAttributeTypeResolver(
-				new AttributeTypeResolverImpl(
-						this
-				)
-		);
-		resolver.addHibernateTypeResolver( new TemporalTypeResolver( this ) );
-		resolver.addHibernateTypeResolver( new LobTypeResolver( this ) );
-		resolver.addHibernateTypeResolver( new EnumeratedTypeResolver( this ) );
-		return resolver;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnSourceImpl.java
deleted file mode 100644
index 232318662e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnSourceImpl.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.internal.util.StringHelper;
-
-/**
- * @author Hardy Ferentschik
- */
-public class ColumnSourceImpl extends ColumnValuesSourceImpl {
-	private final MappedAttribute attribute;
-	private final String name;
-
-	ColumnSourceImpl(MappedAttribute attribute, AttributeOverride attributeOverride) {
-		super( attribute.getColumnValues() );
-		if ( attributeOverride != null ) {
-			setOverrideColumnValues( attributeOverride.getColumnValues() );
-		}
-		this.attribute = attribute;
-		this.name = resolveColumnName();
-	}
-
-	protected String resolveColumnName() {
-		if ( StringHelper.isEmpty( super.getName() ) ) {
-			//no @Column defined.
-			return attribute.getContext().getNamingStrategy().propertyToColumnName( attribute.getName() );
-		}
-		else {
-			return super.getName();
-		}
-	}
-
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public String getReadFragment() {
-		if ( attribute instanceof BasicAttribute ) {
-			return ( (BasicAttribute) attribute ).getCustomReadFragment();
-		}
-		else {
-			return null;
-		}
-	}
-
-	@Override
-	public String getWriteFragment() {
-		if ( attribute instanceof BasicAttribute ) {
-			return ( (BasicAttribute) attribute ).getCustomWriteFragment();
-		}
-		else {
-			return null;
-		}
-	}
-
-	@Override
-	public String getCheckCondition() {
-		if ( attribute instanceof BasicAttribute ) {
-			return ( (BasicAttribute) attribute ).getCheckCondition();
-		}
-		else {
-			return null;
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValues.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValues.java
deleted file mode 100644
index 03b751aa90..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValues.java
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-
-/**
- * Container for the properties defined by {@link javax.persistence.Column}.
- *
- * @author Hardy Ferentschik
- */
-public class ColumnValues {
-	private String name = "";
-	private boolean unique = false;
-	private boolean nullable = true;
-	private boolean insertable = true;
-	private boolean updatable = true;
-	private String columnDefinition = "";
-	private String table = null;
-	private int length = 255;
-	private int precision = 0;
-	private int scale = 0;
-
-	ColumnValues() {
-		this( null );
-	}
-
-	public ColumnValues(AnnotationInstance columnAnnotation) {
-		if ( columnAnnotation != null && !JPADotNames.COLUMN.equals( columnAnnotation.name() ) ) {
-			throw new AssertionFailure( "A @Column annotation needs to be passed to the constructor" );
-		}
-		applyColumnValues( columnAnnotation );
-	}
-
-	private void applyColumnValues(AnnotationInstance columnAnnotation) {
-		// if the column annotation is null we don't have to do anything. Everything is already defaulted.
-		if ( columnAnnotation == null ) {
-			return;
-		}
-
-		AnnotationValue nameValue = columnAnnotation.value( "name" );
-		if ( nameValue != null ) {
-			this.name = nameValue.asString();
-		}
-
-		AnnotationValue uniqueValue = columnAnnotation.value( "unique" );
-		if ( uniqueValue != null ) {
-			this.unique = nameValue.asBoolean();
-		}
-
-		AnnotationValue nullableValue = columnAnnotation.value( "nullable" );
-		if ( nullableValue != null ) {
-			this.nullable = nullableValue.asBoolean();
-		}
-
-		AnnotationValue insertableValue = columnAnnotation.value( "insertable" );
-		if ( insertableValue != null ) {
-			this.insertable = insertableValue.asBoolean();
-		}
-
-		AnnotationValue updatableValue = columnAnnotation.value( "updatable" );
-		if ( updatableValue != null ) {
-			this.updatable = updatableValue.asBoolean();
-		}
-
-		AnnotationValue columnDefinition = columnAnnotation.value( "columnDefinition" );
-		if ( columnDefinition != null ) {
-			this.columnDefinition = columnDefinition.asString();
-		}
-
-		AnnotationValue tableValue = columnAnnotation.value( "table" );
-		if ( tableValue != null ) {
-			this.table = tableValue.asString();
-		}
-
-		AnnotationValue lengthValue = columnAnnotation.value( "length" );
-		if ( lengthValue != null ) {
-			this.length = lengthValue.asInt();
-		}
-
-		AnnotationValue precisionValue = columnAnnotation.value( "precision" );
-		if ( precisionValue != null ) {
-			this.precision = precisionValue.asInt();
-		}
-
-		AnnotationValue scaleValue = columnAnnotation.value( "scale" );
-		if ( scaleValue != null ) {
-			this.scale = scaleValue.asInt();
-		}
-	}
-
-	public final String getName() {
-		return name;
-	}
-
-	public final boolean isUnique() {
-		return unique;
-	}
-
-	public final boolean isNullable() {
-		return nullable;
-	}
-
-	public final boolean isInsertable() {
-		return insertable;
-	}
-
-	public final boolean isUpdatable() {
-		return updatable;
-	}
-
-	public final String getColumnDefinition() {
-		return columnDefinition;
-	}
-
-	public final String getTable() {
-		return table;
-	}
-
-	public final int getLength() {
-		return length;
-	}
-
-	public final int getPrecision() {
-		return precision;
-	}
-
-	public final int getScale() {
-		return scale;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	public void setUnique(boolean unique) {
-		this.unique = unique;
-	}
-
-	public void setNullable(boolean nullable) {
-		this.nullable = nullable;
-	}
-
-	public void setInsertable(boolean insertable) {
-		this.insertable = insertable;
-	}
-
-	public void setUpdatable(boolean updatable) {
-		this.updatable = updatable;
-	}
-
-	public void setColumnDefinition(String columnDefinition) {
-		this.columnDefinition = columnDefinition;
-	}
-
-	public void setTable(String table) {
-		this.table = table;
-	}
-
-	public void setLength(int length) {
-		this.length = length;
-	}
-
-	public void setPrecision(int precision) {
-		this.precision = precision;
-	}
-
-	public void setScale(int scale) {
-		this.scale = scale;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "ColumnValues" );
-		sb.append( "{name='" ).append( name ).append( '\'' );
-		sb.append( ", unique=" ).append( unique );
-		sb.append( ", nullable=" ).append( nullable );
-		sb.append( ", insertable=" ).append( insertable );
-		sb.append( ", updatable=" ).append( updatable );
-		sb.append( ", columnDefinition='" ).append( columnDefinition ).append( '\'' );
-		sb.append( ", table='" ).append( table ).append( '\'' );
-		sb.append( ", length=" ).append( length );
-		sb.append( ", precision=" ).append( precision );
-		sb.append( ", scale=" ).append( scale );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		ColumnValues that = (ColumnValues) o;
-
-		if ( insertable != that.insertable ) {
-			return false;
-		}
-		if ( length != that.length ) {
-			return false;
-		}
-		if ( nullable != that.nullable ) {
-			return false;
-		}
-		if ( precision != that.precision ) {
-			return false;
-		}
-		if ( scale != that.scale ) {
-			return false;
-		}
-		if ( unique != that.unique ) {
-			return false;
-		}
-		if ( updatable != that.updatable ) {
-			return false;
-		}
-		if ( columnDefinition != null ? !columnDefinition.equals( that.columnDefinition ) : that.columnDefinition != null ) {
-			return false;
-		}
-		if ( name != null ? !name.equals( that.name ) : that.name != null ) {
-			return false;
-		}
-		if ( table != null ? !table.equals( that.table ) : that.table != null ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public int hashCode() {
-		int result = name != null ? name.hashCode() : 0;
-		result = 31 * result + ( unique ? 1 : 0 );
-		result = 31 * result + ( nullable ? 1 : 0 );
-		result = 31 * result + ( insertable ? 1 : 0 );
-		result = 31 * result + ( updatable ? 1 : 0 );
-		result = 31 * result + ( columnDefinition != null ? columnDefinition.hashCode() : 0 );
-		result = 31 * result + ( table != null ? table.hashCode() : 0 );
-		result = 31 * result + length;
-		result = 31 * result + precision;
-		result = 31 * result + scale;
-		return result;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValuesSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValuesSourceImpl.java
deleted file mode 100644
index 16480cf0c0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ColumnValuesSourceImpl.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.Size;
-import org.hibernate.metamodel.source.binder.ColumnSource;
-
-/**
- * @author Steve Ebersole
- */
-public class ColumnValuesSourceImpl implements ColumnSource {
-	private ColumnValues columnValues;
-
-	public ColumnValuesSourceImpl(ColumnValues columnValues) {
-		this.columnValues = columnValues;
-	}
-
-	void setOverrideColumnValues(ColumnValues columnValues) {
-		this.columnValues = columnValues;
-	}
-
-	@Override
-	public String getName() {
-		return columnValues.getName();
-	}
-
-	@Override
-	public boolean isNullable() {
-		return columnValues.isNullable();
-	}
-
-	@Override
-	public String getDefaultValue() {
-		return null;
-	}
-
-	@Override
-	public String getSqlType() {
-		// todo
-		return null;
-	}
-
-	@Override
-	public Datatype getDatatype() {
-		// todo
-		return null;
-	}
-
-	@Override
-	public Size getSize() {
-		return new Size(
-				columnValues.getPrecision(),
-				columnValues.getScale(),
-				columnValues.getLength(),
-				Size.LobMultiplier.NONE
-		);
-	}
-
-	@Override
-	public boolean isUnique() {
-		return columnValues.isUnique();
-	}
-
-	@Override
-	public String getComment() {
-		// todo
-		return null;
-	}
-
-	@Override
-	public boolean isIncludedInInsert() {
-		return columnValues.isInsertable();
-	}
-
-	@Override
-	public boolean isIncludedInUpdate() {
-		return columnValues.isUpdatable();
-	}
-
-	@Override
-	public String getContainingTableName() {
-		return columnValues.getTable();
-	}
-
-
-	// these come from attribute ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	@Override
-	public String getReadFragment() {
-		return null;
-	}
-
-	@Override
-	public String getWriteFragment() {
-		return null;
-	}
-
-	@Override
-	public String getCheckCondition() {
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DerivedValueSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DerivedValueSourceImpl.java
deleted file mode 100644
index c53002db96..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DerivedValueSourceImpl.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.metamodel.source.binder.DerivedValueSource;
-
-/**
- * @author Strong Liu
- */
-public class DerivedValueSourceImpl implements DerivedValueSource {
-    private final FormulaValue formulaValue;
-
-    DerivedValueSourceImpl(FormulaValue formulaValue) {
-        this.formulaValue = formulaValue;
-    }
-
-    @Override
-    public String getExpression() {
-        return formulaValue.getExpression();
-    }
-
-    @Override
-    public String getContainingTableName() {
-        return formulaValue.getContainingTableName();
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorSourceImpl.java
deleted file mode 100644
index a2a3e50fe9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorSourceImpl.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import org.hibernate.metamodel.source.annotations.entity.EntityClass;
-import org.hibernate.metamodel.source.binder.DiscriminatorSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class DiscriminatorSourceImpl implements DiscriminatorSource {
-	private final EntityClass entityClass;
-
-	public DiscriminatorSourceImpl(EntityClass entityClass) {
-		this.entityClass = entityClass;
-	}
-
-	@Override
-	public boolean isForced() {
-		return entityClass.isDiscriminatorForced();
-	}
-
-	@Override
-	public boolean isInserted() {
-		return entityClass.isDiscriminatorIncludedInSql();
-	}
-
-    @Override
-    public RelationalValueSource getDiscriminatorRelationalValueSource() {
-        return entityClass.getDiscriminatorFormula() != null ?
-                new DerivedValueSourceImpl( entityClass.getDiscriminatorFormula() )
-                : new ColumnValuesSourceImpl( entityClass.getDiscriminatorColumnValues() );
-    }
-
-	@Override
-	public String getExplicitHibernateTypeName() {
-		return entityClass.getDiscriminatorType().getName();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ExplicitHibernateTypeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ExplicitHibernateTypeSourceImpl.java
deleted file mode 100644
index 6c4b1d7ce5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ExplicitHibernateTypeSourceImpl.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.Map;
-
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolver;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-
-/**
- * @author Strong Liu
- */
-public class ExplicitHibernateTypeSourceImpl implements ExplicitHibernateTypeSource {
-    private final AttributeTypeResolver typeResolver;
-
-    public ExplicitHibernateTypeSourceImpl(AttributeTypeResolver typeResolver) {
-        this.typeResolver = typeResolver;
-    }
-
-    @Override
-    public String getName() {
-        return typeResolver.getExplicitHibernateTypeName();
-    }
-
-    @Override
-    public Map<String, String> getParameters() {
-        return typeResolver.getExplicitHibernateTypeParameters();
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/FormulaValue.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/FormulaValue.java
deleted file mode 100644
index 8daaee9048..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/FormulaValue.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.hibernate.metamodel.source.annotations.attribute;
-
-/**
- * @author Strong Liu
- */
-public class FormulaValue {
-    private String tableName;
-    private final String expression;
-
-    public FormulaValue(String tableName, String expression) {
-        this.tableName = tableName;
-        this.expression = expression;
-    }
-
-    public String getExpression() {
-        return expression;
-    }
-
-    public String getContainingTableName() {
-        return tableName;
-    }
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/MappedAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/MappedAttribute.java
deleted file mode 100644
index 758e2c6e04..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/MappedAttribute.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.type.AttributeTypeResolver;
-import org.hibernate.metamodel.source.annotations.entity.EntityBindingContext;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.DotName;
-
-/**
- * Base class for the different types of mapped attributes
- *
- * @author Hardy Ferentschik
- */
-public abstract class MappedAttribute implements Comparable<MappedAttribute> {
-	/**
-	 * Annotations defined on the attribute, keyed against the annotation dot name.
-	 */
-	private final Map<DotName, List<AnnotationInstance>> annotations;
-
-	/**
-	 * The property name.
-	 */
-	private final String name;
-
-	/**
-	 * The java type of the attribute
-	 */
-	private final Class<?> attributeType;
-
-	/**
-	 * The access type for this property. At the moment this is either 'field' or 'property', but Hibernate
-	 * also allows custom named accessors (see {@link org.hibernate.property.PropertyAccessorFactory}).
-	 */
-	private final String accessType;
-
-	/**
-	 * Defines the column values (relational values) for this property.
-	 */
-	private ColumnValues columnValues;
-
-	/**
-	 * Is this property an id property (or part thereof).
-	 */
-	private final boolean isId;
-
-	/**
-	 * Whether a change of the property's value triggers a version increment of the entity (in case of optimistic
-	 * locking).
-	 */
-	private final boolean isOptimisticLockable;
-
-	/**
-	 * The binding context
-	 */
-	private final EntityBindingContext context;
-
-	MappedAttribute(String name, Class<?> attributeType, String accessType, Map<DotName, List<AnnotationInstance>> annotations, EntityBindingContext context) {
-		this.context = context;
-		this.annotations = annotations;
-		this.name = name;
-		this.attributeType = attributeType;
-		this.accessType = accessType;
-
-		//if this attribute has either @Id or @EmbeddedId, then it is an id attribute
-		AnnotationInstance idAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ID );
-		AnnotationInstance embeddedIdAnnotation = JandexHelper.getSingleAnnotation(
-				annotations,
-				JPADotNames.EMBEDDED_ID
-		);
-		isId = ( idAnnotation != null || embeddedIdAnnotation != null );
-
-		AnnotationInstance columnAnnotation = JandexHelper.getSingleAnnotation(
-				annotations,
-				JPADotNames.COLUMN
-		);
-		columnValues = new ColumnValues( columnAnnotation );
-
-		this.isOptimisticLockable = checkOptimisticLockAnnotation();
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public final Class<?> getAttributeType() {
-		return attributeType;
-	}
-
-	public String getAccessType() {
-		return accessType;
-	}
-
-	public EntityBindingContext getContext() {
-		return context;
-	}
-
-	public Map<DotName, List<AnnotationInstance>> annotations() {
-		return annotations;
-	}
-
-	public ColumnValues getColumnValues() {
-		return columnValues;
-	}
-
-	public boolean isId() {
-		return isId;
-	}
-
-	public boolean isOptimisticLockable() {
-		return isOptimisticLockable;
-	}
-
-	@Override
-	public int compareTo(MappedAttribute mappedProperty) {
-		return name.compareTo( mappedProperty.getName() );
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "MappedAttribute" );
-		sb.append( "{name='" ).append( name ).append( '\'' );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	public abstract AttributeTypeResolver getHibernateTypeResolver();
-
-	public abstract boolean isLazy();
-
-	public abstract boolean isOptional();
-
-	public abstract boolean isInsertable();
-
-	public abstract boolean isUpdatable();
-
-	public abstract PropertyGeneration getPropertyGeneration();
-
-	private boolean checkOptimisticLockAnnotation() {
-		boolean triggersVersionIncrement = true;
-		AnnotationInstance optimisticLockAnnotation = JandexHelper.getSingleAnnotation(
-				annotations(),
-				HibernateDotNames.OPTIMISTIC_LOCK
-		);
-		if ( optimisticLockAnnotation != null ) {
-			boolean exclude = optimisticLockAnnotation.value( "excluded" ).asBoolean();
-			triggersVersionIncrement = !exclude;
-		}
-		return triggersVersionIncrement;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleIdentifierSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleIdentifierSourceImpl.java
deleted file mode 100644
index e6ae635ea9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleIdentifierSourceImpl.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.source.binder.SimpleIdentifierSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class SimpleIdentifierSourceImpl implements SimpleIdentifierSource {
-	private final BasicAttribute attribute;
-	private final Map<String, AttributeOverride> attributeOverrideMap;
-
-	public SimpleIdentifierSourceImpl(BasicAttribute attribute, Map<String, AttributeOverride> attributeOverrideMap) {
-		if ( !attribute.isId() ) {
-			throw new AssertionFailure(
-					String.format(
-							"A non id attribute was passed to SimpleIdentifierSourceImpl: %s",
-							attribute.toString()
-					)
-			);
-		}
-		this.attribute = attribute;
-		this.attributeOverrideMap = attributeOverrideMap;
-	}
-
-	@Override
-	public Nature getNature() {
-		return Nature.SIMPLE;
-	}
-
-	@Override
-	public SingularAttributeSource getIdentifierAttributeSource() {
-		return new SingularAttributeSourceImpl( attribute );
-	}
-
-	@Override
-	public IdGenerator getIdentifierGeneratorDescriptor() {
-		return attribute.getIdGenerator();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SingularAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SingularAttributeSourceImpl.java
deleted file mode 100644
index 3b97d0b62c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SingularAttributeSourceImpl.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class SingularAttributeSourceImpl implements SingularAttributeSource {
-	private final MappedAttribute attribute;
-	private final AttributeOverride attributeOverride;
-
-	public SingularAttributeSourceImpl(MappedAttribute attribute) {
-		this(attribute, null);
-	}
-
-	public SingularAttributeSourceImpl(MappedAttribute attribute, AttributeOverride attributeOverride) {
-		this.attribute = attribute;
-		this.attributeOverride = attributeOverride;
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return new ExplicitHibernateTypeSourceImpl( attribute.getHibernateTypeResolver() );
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return attribute.getAccessType();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return attribute.isInsertable();
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return attribute.isUpdatable();
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return attribute.getPropertyGeneration();
-	}
-
-	@Override
-	public boolean isLazy() {
-		return attribute.isLazy();
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return attribute.isOptimisticLockable();
-	}
-
-	@Override
-	public String getName() {
-		return attribute.getName();
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		List<RelationalValueSource> valueSources = new ArrayList<RelationalValueSource>();
-		valueSources.add( new ColumnSourceImpl( attribute, attributeOverride ) );
-		return valueSources;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.BASIC;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Collections.emptySet();
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return true;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ToOneAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ToOneAttributeSourceImpl.java
deleted file mode 100644
index 3eae19acdc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/ToOneAttributeSourceImpl.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-import java.util.Set;
-
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.metamodel.source.annotations.EnumConversionHelper;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.ToOneAttributeSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class ToOneAttributeSourceImpl extends SingularAttributeSourceImpl implements ToOneAttributeSource {
-	private final AssociationAttribute associationAttribute;
-	private final Set<CascadeStyle> cascadeStyles;
-
-	public ToOneAttributeSourceImpl(AssociationAttribute associationAttribute) {
-		super( associationAttribute );
-		this.associationAttribute = associationAttribute;
-		this.cascadeStyles = EnumConversionHelper.cascadeTypeToCascadeStyleSet( associationAttribute.getCascadeTypes() );
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.MANY_TO_ONE;
-	}
-
-	@Override
-	public String getReferencedEntityName() {
-		return associationAttribute.getReferencedEntityType();
-	}
-
-	@Override
-	public String getReferencedEntityAttributeName() {
-		return associationAttribute.getMappedBy();
-	}
-
-	@Override
-	public Iterable<CascadeStyle> getCascadeStyles() {
-		return cascadeStyles;
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		return associationAttribute.getFetchMode();
-	}
-
-	@Override
-	public FetchTiming getFetchTiming() {
-		  // todo : implement
-		return FetchTiming.IMMEDIATE;
-	}
-
-	@Override
-	public FetchStyle getFetchStyle() {
-		// todo : implement
-		return FetchStyle.JOIN;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java
deleted file mode 100644
index 7a0ab7ea6a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute;
-
-/**
- * This package contains binding code for attributes.
- */
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AbstractAttributeTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AbstractAttributeTypeResolver.java
deleted file mode 100644
index 47916da9ed..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AbstractAttributeTypeResolver.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.util.Collections;
-import java.util.Map;
-
-import org.hibernate.internal.util.StringHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * @author Strong Liu
- */
-public abstract class AbstractAttributeTypeResolver implements AttributeTypeResolver {
-	protected abstract AnnotationInstance getTypeDeterminingAnnotationInstance();
-
-	protected abstract String resolveHibernateTypeName(AnnotationInstance annotationInstance);
-
-	protected Map<String, String> resolveHibernateTypeParameters(AnnotationInstance annotationInstance) {
-		return Collections.emptyMap();
-	}
-
-	@Override
-	final public String getExplicitHibernateTypeName() {
-		return resolveHibernateTypeName( getTypeDeterminingAnnotationInstance() );
-	}
-
-	@Override
-	final public Map<String, String> getExplicitHibernateTypeParameters() {
-		if ( StringHelper.isNotEmpty( getExplicitHibernateTypeName() ) ) {
-			return resolveHibernateTypeParameters( getTypeDeterminingAnnotationInstance() );
-		}
-		else {
-			return Collections.emptyMap();
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolver.java
deleted file mode 100644
index 7333c64109..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolver.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.util.Map;
-
-/**
- * Determines explicit Hibernate type information for JPA mapped attributes when additional type information is
- * provided via annotations like {@link javax.persistence.Lob}, {@link javax.persistence.Enumerated} and
- * {@link javax.persistence.Temporal}.
- *
- * @author Strong Liu
- */
-public interface AttributeTypeResolver {
-	/**
-	 * @return returns an explicit hibernate type name in case the mapped attribute has an additional
-	 *         {@link org.hibernate.annotations.Type} annotation or an implicit type is given via the use of annotations like
-	 *         {@link javax.persistence.Lob}, {@link javax.persistence.Enumerated} and
-	 *         {@link javax.persistence.Temporal}.
-	 */
-	String getExplicitHibernateTypeName();
-
-	/**
-	 * @return Returns a map of optional type parameters. See {@link #getExplicitHibernateTypeName()}.
-	 */
-	Map<String, String> getExplicitHibernateTypeParameters();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolverImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolverImpl.java
deleted file mode 100644
index f163fe520c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/AttributeTypeResolverImpl.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-
-/**
- * @author Strong Liu
- */
-public class AttributeTypeResolverImpl extends AbstractAttributeTypeResolver {
-	private final MappedAttribute mappedAttribute;
-
-	public AttributeTypeResolverImpl(MappedAttribute mappedAttribute) {
-		this.mappedAttribute = mappedAttribute;
-	}
-
-	@Override
-	protected String resolveHibernateTypeName(AnnotationInstance typeAnnotation) {
-		String typeName = null;
-		if ( typeAnnotation != null ) {
-			typeName = JandexHelper.getValue( typeAnnotation, "type", String.class );
-		}
-		return typeName;
-	}
-
-	@Override
-	protected Map<String, String> resolveHibernateTypeParameters(AnnotationInstance typeAnnotation) {
-		HashMap<String, String> typeParameters = new HashMap<String, String>();
-		AnnotationValue parameterAnnotationValue = typeAnnotation.value( "parameters" );
-		if ( parameterAnnotationValue != null ) {
-			AnnotationInstance[] parameterAnnotations = parameterAnnotationValue.asNestedArray();
-			for ( AnnotationInstance parameterAnnotationInstance : parameterAnnotations ) {
-				typeParameters.put(
-						JandexHelper.getValue( parameterAnnotationInstance, "name", String.class ),
-						JandexHelper.getValue( parameterAnnotationInstance, "value", String.class )
-				);
-			}
-		}
-		return typeParameters;
-	}
-
-	@Override
-	protected AnnotationInstance getTypeDeterminingAnnotationInstance() {
-		return JandexHelper.getSingleAnnotation(
-				mappedAttribute.annotations(),
-				HibernateDotNames.TYPE
-		);
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/CompositeAttributeTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/CompositeAttributeTypeResolver.java
deleted file mode 100644
index 26c36ff4ba..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/CompositeAttributeTypeResolver.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.collections.CollectionHelper;
-
-/**
- * @author Strong Liu
- */
-public class CompositeAttributeTypeResolver implements AttributeTypeResolver {
-	private List<AttributeTypeResolver> resolvers = new ArrayList<AttributeTypeResolver>();
-	private final AttributeTypeResolverImpl explicitHibernateTypeResolver;
-
-	public CompositeAttributeTypeResolver(AttributeTypeResolverImpl explicitHibernateTypeResolver) {
-		if ( explicitHibernateTypeResolver == null ) {
-			throw new AssertionFailure( "The Given AttributeTypeResolver is null." );
-		}
-		this.explicitHibernateTypeResolver = explicitHibernateTypeResolver;
-	}
-
-	public void addHibernateTypeResolver(AttributeTypeResolver resolver) {
-		if ( resolver == null ) {
-			throw new AssertionFailure( "The Given AttributeTypeResolver is null." );
-		}
-		resolvers.add( resolver );
-	}
-
-	@Override
-	public String getExplicitHibernateTypeName() {
-		String type = explicitHibernateTypeResolver.getExplicitHibernateTypeName();
-		if ( StringHelper.isEmpty( type ) ) {
-			for ( AttributeTypeResolver resolver : resolvers ) {
-				type = resolver.getExplicitHibernateTypeName();
-				if ( StringHelper.isNotEmpty( type ) ) {
-					break;
-				}
-			}
-		}
-		return type;
-	}
-
-	@Override
-	public Map<String, String> getExplicitHibernateTypeParameters() {
-		Map<String, String> parameters = explicitHibernateTypeResolver.getExplicitHibernateTypeParameters();
-		if ( CollectionHelper.isEmpty( parameters ) ) {
-			for ( AttributeTypeResolver resolver : resolvers ) {
-				parameters = resolver.getExplicitHibernateTypeParameters();
-				if ( CollectionHelper.isNotEmpty( parameters ) ) {
-					break;
-				}
-			}
-		}
-		return parameters;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/EnumeratedTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/EnumeratedTypeResolver.java
deleted file mode 100644
index 79c80e9157..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/EnumeratedTypeResolver.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.sql.Types;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
-import org.hibernate.type.EnumType;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * @author Strong Liu
- */
-public class EnumeratedTypeResolver extends AbstractAttributeTypeResolver {
-	private final MappedAttribute mappedAttribute;
-	private final boolean isMapKey;
-
-	public EnumeratedTypeResolver(MappedAttribute mappedAttribute) {
-		if ( mappedAttribute == null ) {
-			throw new AssertionFailure( "MappedAttribute is null" );
-		}
-		this.mappedAttribute = mappedAttribute;
-		this.isMapKey = false;//todo
-	}
-
-	@Override
-	protected AnnotationInstance getTypeDeterminingAnnotationInstance() {
-		return JandexHelper.getSingleAnnotation(
-				mappedAttribute.annotations(),
-				JPADotNames.ENUMERATED
-		);
-	}
-
-	@Override
-	public String resolveHibernateTypeName(AnnotationInstance enumeratedAnnotation) {
-		boolean isEnum = mappedAttribute.getAttributeType().isEnum();
-		if ( !isEnum ) {
-			if ( enumeratedAnnotation != null ) {
-				throw new AnnotationException( "Attribute " + mappedAttribute.getName() + " is not a Enumerated type, but has a @Enumerated annotation." );
-			}
-			else {
-				return null;
-			}
-		}
-		return EnumType.class.getName();
-	}
-
-	@Override
-	protected Map<String, String> resolveHibernateTypeParameters(AnnotationInstance annotationInstance) {
-		HashMap<String, String> typeParameters = new HashMap<String, String>();
-		typeParameters.put( EnumType.ENUM, mappedAttribute.getAttributeType().getName() );
-		if ( annotationInstance != null ) {
-			javax.persistence.EnumType enumType = JandexHelper.getEnumValue(
-					annotationInstance,
-					"value",
-					javax.persistence.EnumType.class
-			);
-			if ( javax.persistence.EnumType.ORDINAL.equals( enumType ) ) {
-				typeParameters.put( EnumType.TYPE, String.valueOf( Types.INTEGER ) );
-			}
-			else if ( javax.persistence.EnumType.STRING.equals( enumType ) ) {
-				typeParameters.put( EnumType.TYPE, String.valueOf( Types.VARCHAR ) );
-			}
-			else {
-				throw new AssertionFailure( "Unknown EnumType: " + enumType );
-			}
-		}
-		else {
-			typeParameters.put( EnumType.TYPE, String.valueOf( Types.INTEGER ) );
-		}
-		return typeParameters;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/LobTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/LobTypeResolver.java
deleted file mode 100644
index f0d405e903..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/LobTypeResolver.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.io.Serializable;
-import java.sql.Blob;
-import java.sql.Clob;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
-import org.hibernate.type.CharacterArrayClobType;
-import org.hibernate.type.PrimitiveCharacterArrayClobType;
-import org.hibernate.type.SerializableToBlobType;
-import org.hibernate.type.StandardBasicTypes;
-import org.hibernate.type.WrappedMaterializedBlobType;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * @author Strong Liu
- */
-public class LobTypeResolver extends AbstractAttributeTypeResolver {
-	private final MappedAttribute mappedAttribute;
-
-	public LobTypeResolver(MappedAttribute mappedAttribute) {
-		if ( mappedAttribute == null ) {
-			throw new AssertionFailure( "MappedAttribute is null" );
-		}
-		this.mappedAttribute = mappedAttribute;
-	}
-
-	@Override
-	protected AnnotationInstance getTypeDeterminingAnnotationInstance() {
-		return JandexHelper.getSingleAnnotation( mappedAttribute.annotations(), JPADotNames.LOB );
-	}
-
-	@Override
-	public String resolveHibernateTypeName(AnnotationInstance annotationInstance) {
-		if ( annotationInstance == null ) {
-			return null;
-		}
-		String type = null;
-		if ( Clob.class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = StandardBasicTypes.CLOB.getName();
-		}
-		else if ( Blob.class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = StandardBasicTypes.BLOB.getName();
-		}
-		else if ( String.class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = StandardBasicTypes.MATERIALIZED_CLOB.getName();
-		}
-		else if ( Character[].class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = CharacterArrayClobType.class.getName();
-		}
-		else if ( char[].class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = PrimitiveCharacterArrayClobType.class.getName();
-		}
-		else if ( Byte[].class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = WrappedMaterializedBlobType.class.getName();
-		}
-		else if ( byte[].class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = StandardBasicTypes.MATERIALIZED_BLOB.getName();
-		}
-		else if ( Serializable.class.isAssignableFrom( mappedAttribute.getAttributeType() ) ) {
-			type = SerializableToBlobType.class.getName();
-		}
-		else {
-			type = "blob";
-		}
-		return type;
-	}
-
-	@Override
-	protected Map<String, String> resolveHibernateTypeParameters(AnnotationInstance annotationInstance) {
-		if ( getExplicitHibernateTypeName().equals( SerializableToBlobType.class.getName() ) ) {
-			HashMap<String, String> typeParameters = new HashMap<String, String>();
-			typeParameters.put(
-					SerializableToBlobType.CLASS_NAME,
-					mappedAttribute.getAttributeType().getName()
-			);
-			return typeParameters;
-		}
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/TemporalTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/TemporalTypeResolver.java
deleted file mode 100644
index 41414aa63e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/TemporalTypeResolver.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-import java.util.Calendar;
-import java.util.Date;
-import javax.persistence.TemporalType;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.AssertionFailure;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
-import org.hibernate.type.StandardBasicTypes;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * @author Strong Liu
- */
-public class TemporalTypeResolver extends AbstractAttributeTypeResolver {
-	private final MappedAttribute mappedAttribute;
-	private final boolean isMapKey;
-
-	public TemporalTypeResolver(MappedAttribute mappedAttribute) {
-		if ( mappedAttribute == null ) {
-			throw new AssertionFailure( "MappedAttribute is null" );
-		}
-		this.mappedAttribute = mappedAttribute;
-		this.isMapKey = false;//todo
-	}
-
-	@Override
-	public String resolveHibernateTypeName(AnnotationInstance temporalAnnotation) {
-
-		if ( isTemporalType( mappedAttribute.getAttributeType() ) ) {
-			if ( temporalAnnotation == null ) {
-				//SPEC 11.1.47 The Temporal annotation must be specified for persistent fields or properties of type java.util.Date and java.util.Calendar.
-				throw new AnnotationException( "Attribute " + mappedAttribute.getName() + " is a Temporal type, but no @Temporal annotation found." );
-			}
-			TemporalType temporalType = JandexHelper.getEnumValue( temporalAnnotation, "value", TemporalType.class );
-			boolean isDate = Date.class.isAssignableFrom( mappedAttribute.getAttributeType() );
-			String type;
-			switch ( temporalType ) {
-				case DATE:
-					type = isDate ? StandardBasicTypes.DATE.getName() : StandardBasicTypes.CALENDAR_DATE.getName();
-					break;
-				case TIME:
-					type = StandardBasicTypes.TIME.getName();
-					if ( !isDate ) {
-						throw new NotYetImplementedException( "Calendar cannot persist TIME only" );
-					}
-					break;
-				case TIMESTAMP:
-					type = isDate ? StandardBasicTypes.TIMESTAMP.getName() : StandardBasicTypes.CALENDAR.getName();
-					break;
-				default:
-					throw new AssertionFailure( "Unknown temporal type: " + temporalType );
-			}
-			return type;
-		}
-		else {
-			if ( temporalAnnotation != null ) {
-				throw new AnnotationException(
-						"@Temporal should only be set on a java.util.Date or java.util.Calendar property: " + mappedAttribute
-								.getName()
-				);
-			}
-		}
-		return null;
-	}
-
-	@Override
-	protected AnnotationInstance getTypeDeterminingAnnotationInstance() {
-		return JandexHelper.getSingleAnnotation(
-				mappedAttribute.annotations(),
-				JPADotNames.TEMPORAL
-		);
-	}
-
-	private static boolean isTemporalType(Class type) {
-		return Date.class.isAssignableFrom( type ) || Calendar.class.isAssignableFrom( type );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java
deleted file mode 100644
index b7331a26aa..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.attribute.type;
-
-/**
- * This package contains type binding code for basic attributes.
- */
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ComponentAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ComponentAttributeSourceImpl.java
deleted file mode 100644
index 3ab8e3d2c1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ComponentAttributeSourceImpl.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.annotations.attribute.AssociationAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.AttributeOverride;
-import org.hibernate.metamodel.source.annotations.attribute.BasicAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.SingularAttributeSourceImpl;
-import org.hibernate.metamodel.source.annotations.attribute.ToOneAttributeSourceImpl;
-import org.hibernate.metamodel.source.binder.AttributeSource;
-import org.hibernate.metamodel.source.binder.ComponentAttributeSource;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-
-/**
- * Annotation backed implementation of {@code ComponentAttributeSource}.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class ComponentAttributeSourceImpl implements ComponentAttributeSource {
-	private static final String PATH_SEPERATOR = ".";
-	private final EmbeddableClass embeddableClass;
-	private final ValueHolder<Class<?>> classReference;
-	private final Map<String, AttributeOverride> attributeOverrides;
-	private final String path;
-
-	public ComponentAttributeSourceImpl(EmbeddableClass embeddableClass, String parentPath, Map<String, AttributeOverride> attributeOverrides) {
-		this.embeddableClass = embeddableClass;
-		this.classReference = new ValueHolder<Class<?>>( embeddableClass.getConfiguredClass() );
-		this.attributeOverrides = attributeOverrides;
-		if ( StringHelper.isEmpty( parentPath ) ) {
-			path = embeddableClass.getEmbeddedAttributeName();
-		}
-		else {
-			path = parentPath + "." + embeddableClass.getEmbeddedAttributeName();
-		}
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.COMPONENT;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public String getClassName() {
-		return embeddableClass.getConfiguredClass().getName();
-	}
-
-	@Override
-	public ValueHolder<Class<?>> getClassReference() {
-		return classReference;
-	}
-
-	@Override
-	public String getName() {
-		return embeddableClass.getEmbeddedAttributeName();
-	}
-
-	@Override
-	public String getExplicitTuplizerClassName() {
-		return embeddableClass.getCustomTuplizer();
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return embeddableClass.getClassAccessType().toString().toLowerCase();
-	}
-
-	@Override
-	public LocalBindingContext getLocalBindingContext() {
-		return embeddableClass.getLocalBindingContext();
-	}
-
-	@Override
-	public Iterable<AttributeSource> attributeSources() {
-		List<AttributeSource> attributeList = new ArrayList<AttributeSource>();
-		for ( BasicAttribute attribute : embeddableClass.getSimpleAttributes() ) {
-			AttributeOverride attributeOverride = null;
-			String tmp = getPath() + PATH_SEPERATOR + attribute.getName();
-			if ( attributeOverrides.containsKey( tmp ) ) {
-				attributeOverride = attributeOverrides.get( tmp );
-			}
-			attributeList.add( new SingularAttributeSourceImpl( attribute, attributeOverride ) );
-		}
-		for ( EmbeddableClass embeddable : embeddableClass.getEmbeddedClasses().values() ) {
-			attributeList.add(
-					new ComponentAttributeSourceImpl(
-							embeddable,
-							getPath(),
-							createAggregatedOverrideMap()
-					)
-			);
-		}
-		for ( AssociationAttribute associationAttribute : embeddableClass.getAssociationAttributes() ) {
-			attributeList.add( new ToOneAttributeSourceImpl( associationAttribute ) );
-		}
-		return attributeList;
-	}
-
-	@Override
-	public String getPath() {
-		return path;
-	}
-
-	@Override
-	public String getParentReferenceAttributeName() {
-		return embeddableClass.getParentReferencingAttributeName();
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		// not relevant for annotations
-		return Collections.emptySet();
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		// none, they are defined on the simple sub-attributes
-		return null;
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		// probably need to check for @Target in EmbeddableClass (HF)
-		return null;
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return true;
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return true;
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return null;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return false;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return true;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "ComponentAttributeSourceImpl" );
-		sb.append( "{embeddableClass=" ).append( embeddableClass.getConfiguredClass().getSimpleName() );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	private Map<String, AttributeOverride> createAggregatedOverrideMap() {
-		// add all overrides passed down to this instance - they override overrides ;-) which are defined further down
-		// the embeddable chain
-		Map<String, AttributeOverride> aggregatedOverrideMap = new HashMap<String, AttributeOverride>(
-				attributeOverrides
-		);
-
-		for ( Map.Entry<String, AttributeOverride> entry : embeddableClass.getAttributeOverrideMap().entrySet() ) {
-			String fullPath = getPath() + PATH_SEPERATOR + entry.getKey();
-			if ( !aggregatedOverrideMap.containsKey( fullPath ) ) {
-				aggregatedOverrideMap.put( fullPath, entry.getValue() );
-			}
-		}
-		return aggregatedOverrideMap;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java
deleted file mode 100644
index a2e8a60fed..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java
+++ /dev/null
@@ -1,708 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Member;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import javax.persistence.AccessType;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.AssertionFailure;
-import org.hibernate.EntityMode;
-import org.hibernate.HibernateException;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.ReflectionHelper;
-import org.hibernate.metamodel.source.annotations.attribute.AssociationAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.AttributeNature;
-import org.hibernate.metamodel.source.annotations.attribute.AttributeOverride;
-import org.hibernate.metamodel.source.annotations.attribute.BasicAttribute;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.FieldInfo;
-import org.jboss.jandex.MethodInfo;
-import org.jboss.logging.Logger;
-
-import com.fasterxml.classmate.ResolvedTypeWithMembers;
-import com.fasterxml.classmate.members.HierarchicType;
-import com.fasterxml.classmate.members.ResolvedMember;
-
-/**
- * Base class for a configured entity, mapped super class or embeddable
- *
- * @author Hardy Ferentschik
- */
-public class ConfiguredClass {
-	public static final Logger LOG = Logger.getLogger( ConfiguredClass.class.getName() );
-
-	/**
-	 * The parent of this configured class or {@code null} in case this configured class is the root of a hierarchy.
-	 */
-	private final ConfiguredClass parent;
-
-	/**
-	 * The Jandex class info for this configured class. Provides access to the annotation defined on this configured class.
-	 */
-	private final ClassInfo classInfo;
-
-	/**
-	 * The actual java type.
-	 */
-	private final Class<?> clazz;
-
-	/**
-	 * The default access type for this entity
-	 */
-	private final AccessType classAccessType;
-
-	/**
-	 * The type of configured class, entity, mapped super class, embeddable, ...
-	 */
-	private final ConfiguredClassType configuredClassType;
-
-	/**
-	 * The id attributes
-	 */
-	private final Map<String, BasicAttribute> idAttributeMap;
-
-	/**
-	 * The mapped association attributes for this entity
-	 */
-	private final Map<String, AssociationAttribute> associationAttributeMap;
-
-	/**
-	 * The mapped simple attributes for this entity
-	 */
-	private final Map<String, BasicAttribute> simpleAttributeMap;
-
-	/**
-	 * The version attribute or {@code null} in case none exists.
-	 */
-	private BasicAttribute versionAttribute;
-
-	/**
-	 * The embedded classes for this entity
-	 */
-	private final Map<String, EmbeddableClass> embeddedClasses = new HashMap<String, EmbeddableClass>();
-
-	/**
-	 * A map of all attribute overrides defined in this class. The override name is "normalised", meaning as if specified
-	 * on class level. If the override is specified on attribute level the attribute name is used as prefix.
-	 */
-	private final Map<String, AttributeOverride> attributeOverrideMap;
-
-	private final Set<String> transientFieldNames = new HashSet<String>();
-	private final Set<String> transientMethodNames = new HashSet<String>();
-
-	/**
-	 * Fully qualified name of a custom tuplizer
-	 */
-	private final String customTuplizer;
-
-	private final EntityBindingContext localBindingContext;
-
-	public ConfiguredClass(
-			ClassInfo classInfo,
-			AccessType defaultAccessType,
-			ConfiguredClass parent,
-			AnnotationBindingContext context) {
-		this.parent = parent;
-		this.classInfo = classInfo;
-		this.clazz = context.locateClassByName( classInfo.toString() );
-		this.configuredClassType = determineType();
-		this.classAccessType = determineClassAccessType( defaultAccessType );
-		this.customTuplizer = determineCustomTuplizer();
-
-		this.simpleAttributeMap = new TreeMap<String, BasicAttribute>();
-		this.idAttributeMap = new TreeMap<String, BasicAttribute>();
-		this.associationAttributeMap = new TreeMap<String, AssociationAttribute>();
-
-		this.localBindingContext = new EntityBindingContext( context, this );
-
-		collectAttributes();
-		attributeOverrideMap = Collections.unmodifiableMap( findAttributeOverrides() );
-	}
-
-	public String getName() {
-		return clazz.getName();
-	}
-
-	public Class<?> getConfiguredClass() {
-		return clazz;
-	}
-
-	public ClassInfo getClassInfo() {
-		return classInfo;
-	}
-
-	public ConfiguredClass getParent() {
-		return parent;
-	}
-
-	public EntityBindingContext getLocalBindingContext() {
-		return localBindingContext;
-	}
-
-	public Iterable<BasicAttribute> getSimpleAttributes() {
-		return simpleAttributeMap.values();
-	}
-
-	public Iterable<BasicAttribute> getIdAttributes() {
-		return idAttributeMap.values();
-	}
-
-	public BasicAttribute getVersionAttribute() {
-		return versionAttribute;
-	}
-
-	public Iterable<AssociationAttribute> getAssociationAttributes() {
-		return associationAttributeMap.values();
-	}
-
-	public Map<String, EmbeddableClass> getEmbeddedClasses() {
-		return embeddedClasses;
-	}
-
-	public Map<String, AttributeOverride> getAttributeOverrideMap() {
-		return attributeOverrideMap;
-	}
-
-	public AccessType getClassAccessType() {
-		return classAccessType;
-	}
-
-	public String getCustomTuplizer() {
-		return customTuplizer;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "ConfiguredClass" );
-		sb.append( "{clazz=" ).append( clazz.getSimpleName() );
-		sb.append( '}' );
-		return sb.toString();
-	}
-
-	private ConfiguredClassType determineType() {
-		if ( classInfo.annotations().containsKey( JPADotNames.ENTITY ) ) {
-			return ConfiguredClassType.ENTITY;
-		}
-		else if ( classInfo.annotations().containsKey( JPADotNames.MAPPED_SUPERCLASS ) ) {
-			return ConfiguredClassType.MAPPED_SUPERCLASS;
-		}
-		else if ( classInfo.annotations().containsKey( JPADotNames.EMBEDDABLE ) ) {
-			return ConfiguredClassType.EMBEDDABLE;
-		}
-		else {
-			return ConfiguredClassType.NON_ENTITY;
-		}
-	}
-
-	private AccessType determineClassAccessType(AccessType defaultAccessType) {
-		// default to the hierarchy access type to start with
-		AccessType accessType = defaultAccessType;
-
-		AnnotationInstance accessAnnotation = JandexHelper.getSingleAnnotation( classInfo, JPADotNames.ACCESS );
-		if ( accessAnnotation != null && accessAnnotation.target().getClass().equals( ClassInfo.class ) ) {
-			accessType = JandexHelper.getEnumValue( accessAnnotation, "value", AccessType.class );
-		}
-
-		return accessType;
-	}
-
-	/**
-	 * Find all attributes for this configured class and add them to the corresponding map
-	 */
-	private void collectAttributes() {
-		// find transient field and method names
-		findTransientFieldAndMethodNames();
-
-		// use the class mate library to generic types
-		ResolvedTypeWithMembers resolvedType = localBindingContext.resolveMemberTypes(
-				localBindingContext.getResolvedType(
-						clazz
-				)
-		);
-		for ( HierarchicType hierarchicType : resolvedType.allTypesAndOverrides() ) {
-			if ( hierarchicType.getType().getErasedType().equals( clazz ) ) {
-				resolvedType = localBindingContext.resolveMemberTypes( hierarchicType.getType() );
-				break;
-			}
-		}
-
-		if ( resolvedType == null ) {
-			throw new AssertionFailure( "Unable to resolve types for " + clazz.getName() );
-		}
-
-		Set<String> explicitlyConfiguredMemberNames = createExplicitlyConfiguredAccessProperties( resolvedType );
-
-		if ( AccessType.FIELD.equals( classAccessType ) ) {
-			Field fields[] = clazz.getDeclaredFields();
-			Field.setAccessible( fields, true );
-			for ( Field field : fields ) {
-				if ( isPersistentMember( transientFieldNames, explicitlyConfiguredMemberNames, field ) ) {
-					createMappedAttribute( field, resolvedType, AccessType.FIELD );
-				}
-			}
-		}
-		else {
-			Method[] methods = clazz.getDeclaredMethods();
-			Method.setAccessible( methods, true );
-			for ( Method method : methods ) {
-				if ( isPersistentMember( transientMethodNames, explicitlyConfiguredMemberNames, method ) ) {
-					createMappedAttribute( method, resolvedType, AccessType.PROPERTY );
-				}
-			}
-		}
-	}
-
-	private boolean isPersistentMember(Set<String> transientNames, Set<String> explicitlyConfiguredMemberNames, Member member) {
-		if ( !ReflectionHelper.isProperty( member ) ) {
-			return false;
-		}
-
-		if ( transientNames.contains( member.getName() ) ) {
-			return false;
-		}
-
-		if ( explicitlyConfiguredMemberNames.contains( ReflectionHelper.getPropertyName( member ) ) ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	/**
-	 * Creates {@code MappedProperty} instances for the explicitly configured persistent properties
-	 *
-	 * @param resolvedMembers the resolved type parameters for this class
-	 *
-	 * @return the property names of the explicitly configured attribute names in a set
-	 */
-	private Set<String> createExplicitlyConfiguredAccessProperties(ResolvedTypeWithMembers resolvedMembers) {
-		Set<String> explicitAccessPropertyNames = new HashSet<String>();
-
-		List<AnnotationInstance> accessAnnotations = classInfo.annotations().get( JPADotNames.ACCESS );
-		if ( accessAnnotations == null ) {
-			return explicitAccessPropertyNames;
-		}
-
-		// iterate over all @Access annotations defined on the current class
-		for ( AnnotationInstance accessAnnotation : accessAnnotations ) {
-			// we are only interested at annotations defined on fields and methods
-			AnnotationTarget annotationTarget = accessAnnotation.target();
-			if ( !( annotationTarget.getClass().equals( MethodInfo.class ) || annotationTarget.getClass()
-					.equals( FieldInfo.class ) ) ) {
-				continue;
-			}
-
-			AccessType accessType = JandexHelper.getEnumValue( accessAnnotation, "value", AccessType.class );
-
-			if ( !isExplicitAttributeAccessAnnotationPlacedCorrectly( annotationTarget, accessType ) ) {
-				continue;
-			}
-
-			// the placement is correct, get the member
-			Member member;
-			if ( annotationTarget instanceof MethodInfo ) {
-				Method m;
-				try {
-					m = clazz.getMethod( ( (MethodInfo) annotationTarget ).name() );
-				}
-				catch ( NoSuchMethodException e ) {
-					throw new HibernateException(
-							"Unable to load method "
-									+ ( (MethodInfo) annotationTarget ).name()
-									+ " of class " + clazz.getName()
-					);
-				}
-				member = m;
-				accessType = AccessType.PROPERTY;
-			}
-			else {
-				Field f;
-				try {
-					f = clazz.getField( ( (FieldInfo) annotationTarget ).name() );
-				}
-				catch ( NoSuchFieldException e ) {
-					throw new HibernateException(
-							"Unable to load field "
-									+ ( (FieldInfo) annotationTarget ).name()
-									+ " of class " + clazz.getName()
-					);
-				}
-				member = f;
-				accessType = AccessType.FIELD;
-			}
-			if ( ReflectionHelper.isProperty( member ) ) {
-				createMappedAttribute( member, resolvedMembers, accessType );
-				explicitAccessPropertyNames.add( ReflectionHelper.getPropertyName( member ) );
-			}
-		}
-		return explicitAccessPropertyNames;
-	}
-
-	private boolean isExplicitAttributeAccessAnnotationPlacedCorrectly(AnnotationTarget annotationTarget, AccessType accessType) {
-		// when the access type of the class is FIELD
-		// overriding access annotations must be placed on properties AND have the access type PROPERTY
-		if ( AccessType.FIELD.equals( classAccessType ) ) {
-			if ( !( annotationTarget instanceof MethodInfo ) ) {
-				LOG.tracef(
-						"The access type of class %s is AccessType.FIELD. To override the access for an attribute " +
-								"@Access has to be placed on the property (getter)", classInfo.name().toString()
-				);
-				return false;
-			}
-
-			if ( !AccessType.PROPERTY.equals( accessType ) ) {
-				LOG.tracef(
-						"The access type of class %s is AccessType.FIELD. To override the access for an attribute " +
-								"@Access has to be placed on the property (getter) with an access type of AccessType.PROPERTY. " +
-								"Using AccessType.FIELD on the property has no effect",
-						classInfo.name().toString()
-				);
-				return false;
-			}
-		}
-
-		// when the access type of the class is PROPERTY
-		// overriding access annotations must be placed on fields and have the access type FIELD
-		if ( AccessType.PROPERTY.equals( classAccessType ) ) {
-			if ( !( annotationTarget instanceof FieldInfo ) ) {
-				LOG.tracef(
-						"The access type of class %s is AccessType.PROPERTY. To override the access for a field " +
-								"@Access has to be placed on the field ", classInfo.name().toString()
-				);
-				return false;
-			}
-
-			if ( !AccessType.FIELD.equals( accessType ) ) {
-				LOG.tracef(
-						"The access type of class %s is AccessType.PROPERTY. To override the access for a field " +
-								"@Access has to be placed on the field with an access type of AccessType.FIELD. " +
-								"Using AccessType.PROPERTY on the field has no effect",
-						classInfo.name().toString()
-				);
-				return false;
-			}
-		}
-		return true;
-	}
-
-	private void createMappedAttribute(Member member, ResolvedTypeWithMembers resolvedType, AccessType accessType) {
-		final String attributeName = ReflectionHelper.getPropertyName( member );
-		ResolvedMember[] resolvedMembers;
-		if ( member instanceof Field ) {
-			resolvedMembers = resolvedType.getMemberFields();
-		}
-		else {
-			resolvedMembers = resolvedType.getMemberMethods();
-		}
-		Class<?> attributeType = (Class<?>) findResolvedType( member.getName(), resolvedMembers );
-		final Map<DotName, List<AnnotationInstance>> annotations = JandexHelper.getMemberAnnotations(
-				classInfo, member.getName()
-		);
-
-		AttributeNature attributeNature = determineAttributeNature( annotations );
-		String accessTypeString = accessType.toString().toLowerCase();
-		switch ( attributeNature ) {
-			case BASIC: {
-				BasicAttribute attribute = BasicAttribute.createSimpleAttribute(
-						attributeName, attributeType, annotations, accessTypeString, getLocalBindingContext()
-				);
-				if ( attribute.isId() ) {
-					idAttributeMap.put( attributeName, attribute );
-				}
-				else if ( attribute.isVersioned() ) {
-					if ( versionAttribute == null ) {
-						versionAttribute = attribute;
-					}
-					else {
-						throw new MappingException( "Multiple version attributes", localBindingContext.getOrigin() );
-					}
-				}
-				else {
-					simpleAttributeMap.put( attributeName, attribute );
-				}
-				break;
-			}
-			case ELEMENT_COLLECTION: {
-				throw new NotYetImplementedException( "Element collections must still be implemented." );
-			}
-			case EMBEDDED_ID: {
-				throw new NotYetImplementedException( "Embedded ids must still be implemented." );
-			}
-			case EMBEDDED: {
-				AnnotationInstance targetAnnotation = JandexHelper.getSingleAnnotation(
-						getClassInfo(),
-						HibernateDotNames.TARGET
-				);
-				if ( targetAnnotation != null ) {
-					attributeType = localBindingContext.locateClassByName(
-							JandexHelper.getValue( targetAnnotation, "value", String.class )
-					);
-				}
-				resolveEmbeddable( attributeName, attributeType );
-				break;
-			}
-			// OneToOne, OneToMany, ManyToOne, ManyToMany
-			default: {
-				AssociationAttribute attribute = AssociationAttribute.createAssociationAttribute(
-						attributeName,
-						attributeType,
-						attributeNature,
-						accessTypeString,
-						annotations,
-						getLocalBindingContext()
-				);
-				associationAttributeMap.put( attributeName, attribute );
-			}
-		}
-	}
-
-	private void resolveEmbeddable(String attributeName, Class<?> type) {
-		ClassInfo embeddableClassInfo = localBindingContext.getClassInfo( type.getName() );
-		if ( embeddableClassInfo == null ) {
-			String msg = String.format(
-					"Attribute '%s#%s' is annotated with @Embedded, but '%s' does not seem to be annotated " +
-							"with @Embeddable. Are all annotated classes added to the configuration?",
-					getConfiguredClass().getSimpleName(),
-					attributeName,
-					type.getSimpleName()
-			);
-			throw new AnnotationException( msg );
-		}
-
-		localBindingContext.resolveAllTypes( type.getName() );
-		EmbeddableHierarchy hierarchy = EmbeddableHierarchy.createEmbeddableHierarchy(
-				localBindingContext.<Object>locateClassByName( embeddableClassInfo.toString() ),
-				attributeName,
-				classAccessType,
-				localBindingContext
-		);
-		embeddedClasses.put( attributeName, hierarchy.getLeaf() );
-	}
-
-	/**
-	 * Given the annotations defined on a persistent attribute this methods determines the attribute type.
-	 *
-	 * @param annotations the annotations defined on the persistent attribute
-	 *
-	 * @return an instance of the {@code AttributeType} enum
-	 */
-	private AttributeNature determineAttributeNature(Map<DotName, List<AnnotationInstance>> annotations) {
-		EnumMap<AttributeNature, AnnotationInstance> discoveredAttributeTypes =
-				new EnumMap<AttributeNature, AnnotationInstance>( AttributeNature.class );
-
-		AnnotationInstance oneToOne = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ONE_TO_ONE );
-		if ( oneToOne != null ) {
-			discoveredAttributeTypes.put( AttributeNature.ONE_TO_ONE, oneToOne );
-		}
-
-		AnnotationInstance oneToMany = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ONE_TO_MANY );
-		if ( oneToMany != null ) {
-			discoveredAttributeTypes.put( AttributeNature.ONE_TO_MANY, oneToMany );
-		}
-
-		AnnotationInstance manyToOne = JandexHelper.getSingleAnnotation( annotations, JPADotNames.MANY_TO_ONE );
-		if ( manyToOne != null ) {
-			discoveredAttributeTypes.put( AttributeNature.MANY_TO_ONE, manyToOne );
-		}
-
-		AnnotationInstance manyToMany = JandexHelper.getSingleAnnotation( annotations, JPADotNames.MANY_TO_MANY );
-		if ( manyToMany != null ) {
-			discoveredAttributeTypes.put( AttributeNature.MANY_TO_MANY, manyToMany );
-		}
-
-		AnnotationInstance embedded = JandexHelper.getSingleAnnotation( annotations, JPADotNames.EMBEDDED );
-		if ( embedded != null ) {
-			discoveredAttributeTypes.put( AttributeNature.EMBEDDED, embedded );
-		}
-
-		AnnotationInstance embeddedId = JandexHelper.getSingleAnnotation( annotations, JPADotNames.EMBEDDED_ID );
-		if ( embeddedId != null ) {
-			discoveredAttributeTypes.put( AttributeNature.EMBEDDED_ID, embeddedId );
-		}
-
-		AnnotationInstance elementCollection = JandexHelper.getSingleAnnotation(
-				annotations,
-				JPADotNames.ELEMENT_COLLECTION
-		);
-		if ( elementCollection != null ) {
-			discoveredAttributeTypes.put( AttributeNature.ELEMENT_COLLECTION, elementCollection );
-		}
-
-		if ( discoveredAttributeTypes.size() == 0 ) {
-			return AttributeNature.BASIC;
-		}
-		else if ( discoveredAttributeTypes.size() == 1 ) {
-			return discoveredAttributeTypes.keySet().iterator().next();
-		}
-		else {
-			throw new AnnotationException( "More than one association type configured for property  " + getName() + " of class " + getName() );
-		}
-	}
-
-	private Type findResolvedType(String name, ResolvedMember[] resolvedMembers) {
-		for ( ResolvedMember resolvedMember : resolvedMembers ) {
-			if ( resolvedMember.getName().equals( name ) ) {
-				return resolvedMember.getType().getErasedType();
-			}
-		}
-		throw new AssertionFailure(
-				String.format(
-						"Unable to resolve type of attribute %s of class %s",
-						name,
-						classInfo.name().toString()
-				)
-		);
-	}
-
-	/**
-	 * Populates the sets of transient field and method names.
-	 */
-	private void findTransientFieldAndMethodNames() {
-		List<AnnotationInstance> transientMembers = classInfo.annotations().get( JPADotNames.TRANSIENT );
-		if ( transientMembers == null ) {
-			return;
-		}
-
-		for ( AnnotationInstance transientMember : transientMembers ) {
-			AnnotationTarget target = transientMember.target();
-			if ( target instanceof FieldInfo ) {
-				transientFieldNames.add( ( (FieldInfo) target ).name() );
-			}
-			else {
-				transientMethodNames.add( ( (MethodInfo) target ).name() );
-			}
-		}
-	}
-
-	private Map<String, AttributeOverride> findAttributeOverrides() {
-		Map<String, AttributeOverride> attributeOverrideList = new HashMap<String, AttributeOverride>();
-
-		AnnotationInstance attributeOverrideAnnotation = JandexHelper.getSingleAnnotation(
-				classInfo,
-				JPADotNames.ATTRIBUTE_OVERRIDE
-		);
-		if ( attributeOverrideAnnotation != null ) {
-			String prefix = createPathPrefix( attributeOverrideAnnotation.target() );
-			AttributeOverride override = new AttributeOverride( prefix, attributeOverrideAnnotation );
-			attributeOverrideList.put( override.getAttributePath(), override );
-		}
-
-		AnnotationInstance attributeOverridesAnnotation = JandexHelper.getSingleAnnotation(
-				classInfo,
-				JPADotNames.ATTRIBUTE_OVERRIDES
-		);
-		if ( attributeOverridesAnnotation != null ) {
-			AnnotationInstance[] annotationInstances = attributeOverridesAnnotation.value().asNestedArray();
-			for ( AnnotationInstance annotationInstance : annotationInstances ) {
-				String prefix = createPathPrefix( attributeOverridesAnnotation.target() );
-				AttributeOverride override = new AttributeOverride( prefix, annotationInstance );
-				attributeOverrideList.put( override.getAttributePath(), override );
-			}
-		}
-		return attributeOverrideList;
-	}
-
-	private String createPathPrefix(AnnotationTarget target) {
-		String prefix = null;
-		if ( target instanceof FieldInfo || target instanceof MethodInfo ) {
-			prefix = JandexHelper.getPropertyName( target );
-		}
-		return prefix;
-	}
-
-	private List<AnnotationInstance> findAssociationOverrides() {
-		List<AnnotationInstance> associationOverrideList = new ArrayList<AnnotationInstance>();
-
-		AnnotationInstance associationOverrideAnnotation = JandexHelper.getSingleAnnotation(
-				classInfo,
-				JPADotNames.ASSOCIATION_OVERRIDE
-		);
-		if ( associationOverrideAnnotation != null ) {
-			associationOverrideList.add( associationOverrideAnnotation );
-		}
-
-		AnnotationInstance associationOverridesAnnotation = JandexHelper.getSingleAnnotation(
-				classInfo,
-				JPADotNames.ASSOCIATION_OVERRIDES
-		);
-		if ( associationOverrideAnnotation != null ) {
-			AnnotationInstance[] attributeOverride = associationOverridesAnnotation.value().asNestedArray();
-			Collections.addAll( associationOverrideList, attributeOverride );
-		}
-
-		return associationOverrideList;
-	}
-
-	private String determineCustomTuplizer() {
-		final AnnotationInstance tuplizersAnnotation = JandexHelper.getSingleAnnotation(
-				classInfo, HibernateDotNames.TUPLIZERS
-		);
-		if ( tuplizersAnnotation == null ) {
-			return null;
-		}
-
-		AnnotationInstance[] annotations = JandexHelper.getValue(
-				tuplizersAnnotation,
-				"value",
-				AnnotationInstance[].class
-		);
-
-		AnnotationInstance pojoTuplizerAnnotation = null;
-		for ( AnnotationInstance tuplizerAnnotation : annotations ) {
-			if ( EntityMode.valueOf( tuplizerAnnotation.value( "entityModeType" ).asEnum() ) == EntityMode.POJO ) {
-				pojoTuplizerAnnotation = tuplizerAnnotation;
-				break;
-			}
-		}
-
-		String customTuplizer = null;
-		if ( pojoTuplizerAnnotation != null ) {
-			customTuplizer = pojoTuplizerAnnotation.value( "impl" ).asString();
-		}
-		return customTuplizer;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java
deleted file mode 100644
index cf7d0207ad..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-/**
- * @author Hardy Ferentschik
- */
-public enum ConfiguredClassType {
-	ENTITY,
-	MAPPED_SUPERCLASS,
-	EMBEDDABLE,
-	NON_ENTITY
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java
deleted file mode 100644
index ce162b0fef..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.AccessType;
-
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * Represents the information about an entity annotated with {@code @Embeddable}.
- *
- * @author Hardy Ferentschik
- */
-public class EmbeddableClass extends ConfiguredClass {
-	private final String embeddedAttributeName;
-	private final String parentReferencingAttributeName;
-
-	public EmbeddableClass(
-			ClassInfo classInfo,
-			String embeddedAttributeName,
-			ConfiguredClass parent,
-			AccessType defaultAccessType,
-			AnnotationBindingContext context) {
-		super( classInfo, defaultAccessType, parent, context );
-		this.embeddedAttributeName = embeddedAttributeName;
-		this.parentReferencingAttributeName = checkParentAnnotation();
-	}
-
-	private String checkParentAnnotation() {
-		AnnotationInstance parentAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(),
-				HibernateDotNames.PARENT
-		);
-		if ( parentAnnotation == null ) {
-			return null;
-		}
-		else {
-			return JandexHelper.getPropertyName( parentAnnotation.target() );
-		}
-	}
-
-	public String getEmbeddedAttributeName() {
-		return embeddedAttributeName;
-	}
-
-	public String getParentReferencingAttributeName() {
-		return parentReferencingAttributeName;
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableHierarchy.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableHierarchy.java
deleted file mode 100644
index 41f46f489c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableHierarchy.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import javax.persistence.AccessType;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-
-/**
- * Contains information about the access and inheritance type for all classes within a class hierarchy.
- *
- * @author Hardy Ferentschik
- */
-public class EmbeddableHierarchy implements Iterable<EmbeddableClass> {
-	private final AccessType defaultAccessType;
-	private final List<EmbeddableClass> embeddables;
-
-	/**
-	 * Builds the configured class hierarchy for a an embeddable class.
-	 *
-	 * @param embeddableClass the top level embedded class
-	 * @param propertyName the name of the property in the entity class embedding this embeddable
-	 * @param accessType the access type inherited from the class in which the embeddable gets embedded
-	 * @param context the annotation binding context with access to the service registry and the annotation index
-	 *
-	 * @return a set of {@code ConfiguredClassHierarchy}s. One for each "leaf" entity.
-	 */
-	public static EmbeddableHierarchy createEmbeddableHierarchy(Class<?> embeddableClass, String propertyName, AccessType accessType, AnnotationBindingContext context) {
-
-		ClassInfo embeddableClassInfo = context.getClassInfo( embeddableClass.getName() );
-		if ( embeddableClassInfo == null ) {
-			throw new AssertionFailure(
-					String.format(
-							"The specified class %s cannot be found in the annotation index",
-							embeddableClass.getName()
-					)
-			);
-		}
-
-		if ( JandexHelper.getSingleAnnotation( embeddableClassInfo, JPADotNames.EMBEDDABLE ) == null ) {
-			throw new AssertionFailure(
-					String.format(
-							"The specified class %s is not annotated with @Embeddable even though it is as embeddable",
-							embeddableClass.getName()
-					)
-			);
-		}
-
-		List<ClassInfo> classInfoList = new ArrayList<ClassInfo>();
-		ClassInfo tmpClassInfo;
-		Class<?> clazz = embeddableClass;
-		while ( clazz != null && !clazz.equals( Object.class ) ) {
-			tmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );
-			clazz = clazz.getSuperclass();
-			if ( tmpClassInfo == null ) {
-				continue;
-			}
-
-			classInfoList.add( 0, tmpClassInfo );
-		}
-
-		return new EmbeddableHierarchy(
-				classInfoList,
-				propertyName,
-				context,
-				accessType
-		);
-	}
-
-	@SuppressWarnings("unchecked")
-	private EmbeddableHierarchy(
-			List<ClassInfo> classInfoList,
-			String propertyName,
-			AnnotationBindingContext context,
-			AccessType defaultAccessType) {
-		this.defaultAccessType = defaultAccessType;
-
-		// the resolved type for the top level class in the hierarchy
-		context.resolveAllTypes( classInfoList.get( classInfoList.size() - 1 ).name().toString() );
-
-		embeddables = new ArrayList<EmbeddableClass>();
-		ConfiguredClass parent = null;
-		EmbeddableClass embeddable;
-		for ( ClassInfo info : classInfoList ) {
-			embeddable = new EmbeddableClass(
-					info, propertyName, parent, defaultAccessType, context
-			);
-			embeddables.add( embeddable );
-			parent = embeddable;
-		}
-	}
-
-
-	public AccessType getDefaultAccessType() {
-		return defaultAccessType;
-	}
-
-	/**
-	 * @return An iterator iterating in top down manner over the configured classes in this hierarchy.
-	 */
-	public Iterator<EmbeddableClass> iterator() {
-		return embeddables.iterator();
-	}
-
-	/**
-	 * @return Returns the leaf configured class
-	 */
-	public EmbeddableClass getLeaf() {
-		return embeddables.get( embeddables.size() - 1 );
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "EmbeddableHierarchy" );
-		sb.append( "{defaultAccessType=" ).append( defaultAccessType );
-		sb.append( ", embeddables=" ).append( embeddables );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBindingContext.java
deleted file mode 100644
index 70c0b2f07e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBindingContext.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.SourceType;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingDefaults;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.Index;
-
-import com.fasterxml.classmate.ResolvedType;
-import com.fasterxml.classmate.ResolvedTypeWithMembers;
-
-/**
- * Annotation version of a local binding context.
- * 
- * @author Steve Ebersole
- */
-public class EntityBindingContext implements LocalBindingContext, AnnotationBindingContext {
-	private final AnnotationBindingContext contextDelegate;
-	private final Origin origin;
-
-	public EntityBindingContext(AnnotationBindingContext contextDelegate, ConfiguredClass source) {
-		this.contextDelegate = contextDelegate;
-		this.origin = new Origin( SourceType.ANNOTATION, source.getName() );
-	}
-
-	@Override
-	public Origin getOrigin() {
-		return origin;
-	}
-
-	@Override
-	public ServiceRegistry getServiceRegistry() {
-		return contextDelegate.getServiceRegistry();
-	}
-
-	@Override
-	public NamingStrategy getNamingStrategy() {
-		return contextDelegate.getNamingStrategy();
-	}
-
-	@Override
-	public MappingDefaults getMappingDefaults() {
-		return contextDelegate.getMappingDefaults();
-	}
-
-	@Override
-	public MetadataImplementor getMetadataImplementor() {
-		return contextDelegate.getMetadataImplementor();
-	}
-
-	@Override
-	public <T> Class<T> locateClassByName(String name) {
-		return contextDelegate.locateClassByName( name );
-	}
-
-	@Override
-	public Type makeJavaType(String className) {
-		return contextDelegate.makeJavaType( className );
-	}
-
-	@Override
-	public boolean isGloballyQuotedIdentifiers() {
-		return contextDelegate.isGloballyQuotedIdentifiers();
-	}
-
-	@Override
-	public ValueHolder<Class<?>> makeClassReference(String className) {
-		return contextDelegate.makeClassReference( className );
-	}
-
-	@Override
-	public String qualifyClassName(String name) {
-		return contextDelegate.qualifyClassName( name );
-	}
-
-	@Override
-	public Index getIndex() {
-		return contextDelegate.getIndex();
-	}
-
-	@Override
-	public ClassInfo getClassInfo(String name) {
-		return contextDelegate.getClassInfo( name );
-	}
-
-	@Override
-	public void resolveAllTypes(String className) {
-		contextDelegate.resolveAllTypes( className );
-	}
-
-	@Override
-	public ResolvedType getResolvedType(Class<?> clazz) {
-		return contextDelegate.getResolvedType( clazz );
-	}
-
-	@Override
-	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type) {
-		return contextDelegate.resolveMemberTypes( type );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java
deleted file mode 100644
index d873e89a17..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java
+++ /dev/null
@@ -1,986 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.persistence.AccessType;
-import javax.persistence.DiscriminatorType;
-import javax.persistence.PersistenceException;
-import javax.persistence.PostLoad;
-import javax.persistence.PostPersist;
-import javax.persistence.PostRemove;
-import javax.persistence.PostUpdate;
-import javax.persistence.PrePersist;
-import javax.persistence.PreRemove;
-import javax.persistence.PreUpdate;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.MappingException;
-import org.hibernate.annotations.CacheConcurrencyStrategy;
-import org.hibernate.annotations.OptimisticLockType;
-import org.hibernate.annotations.PolymorphismType;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.attribute.ColumnValues;
-import org.hibernate.metamodel.source.annotations.attribute.FormulaValue;
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-import org.hibernate.metamodel.source.binder.ConstraintSource;
-import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.metamodel.source.binder.TableSource;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.MethodInfo;
-import org.jboss.jandex.Type;
-import org.jboss.jandex.Type.Kind;
-
-/**
- * Represents an entity or mapped superclass configured via annotations/orm-xml.
- *
- * @author Hardy Ferentschik
- */
-public class EntityClass extends ConfiguredClass {
-	private final IdType idType;
-	private final InheritanceType inheritanceType;
-
-	private final String explicitEntityName;
-	private final String customLoaderQueryName;
-	private final List<String> synchronizedTableNames;
-	private final int batchSize;
-
-	private final TableSource primaryTableSource;
-	private final Set<TableSource> secondaryTableSources;
-	private final Set<ConstraintSource> constraintSources;
-
-	private boolean isMutable;
-	private boolean isExplicitPolymorphism;
-	private OptimisticLockStyle optimisticLockStyle;
-	private String whereClause;
-	private String rowId;
-	private Caching caching;
-	private boolean isDynamicInsert;
-	private boolean isDynamicUpdate;
-	private boolean isSelectBeforeUpdate;
-	private String customPersister;
-
-	private CustomSQL customInsert;
-	private CustomSQL customUpdate;
-	private CustomSQL customDelete;
-
-	private boolean isLazy;
-	private String proxy;
-
-	private ColumnValues discriminatorColumnValues;
-	private FormulaValue discriminatorFormula;
-	private Class<?> discriminatorType;
-	private String discriminatorMatchValue;
-	private boolean isDiscriminatorForced = true;
-	private boolean isDiscriminatorIncludedInSql = true;
-
-	private final List<JpaCallbackClass> jpaCallbacks;
-
-	public EntityClass(
-			ClassInfo classInfo,
-			EntityClass parent,
-			AccessType hierarchyAccessType,
-			InheritanceType inheritanceType,
-			AnnotationBindingContext context) {
-		super( classInfo, hierarchyAccessType, parent, context );
-		this.inheritanceType = inheritanceType;
-		this.idType = determineIdType();
-		boolean hasOwnTable = definesItsOwnTable();
-		this.explicitEntityName = determineExplicitEntityName();
-		this.constraintSources = new HashSet<ConstraintSource>();
-
-		if ( hasOwnTable ) {
-			AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
-					getClassInfo(),
-					JPADotNames.TABLE
-			);
-			this.primaryTableSource = createTableSource( tableAnnotation );
-		}
-		else {
-			this.primaryTableSource = null;
-		}
-
-		this.secondaryTableSources = createSecondaryTableSources();
-		this.customLoaderQueryName = determineCustomLoader();
-		this.synchronizedTableNames = determineSynchronizedTableNames();
-		this.batchSize = determineBatchSize();
-		this.jpaCallbacks = determineEntityListeners();
-
-		processHibernateEntitySpecificAnnotations();
-		processCustomSqlAnnotations();
-		processProxyGeneration();
-		processDiscriminator();
-	}
-
-	public ColumnValues getDiscriminatorColumnValues() {
-		return discriminatorColumnValues;
-	}
-
-	public FormulaValue getDiscriminatorFormula() {
-		return discriminatorFormula;
-	}
-
-	public Class<?> getDiscriminatorType() {
-		return discriminatorType;
-	}
-
-	public IdType getIdType() {
-		return idType;
-	}
-
-	public boolean isExplicitPolymorphism() {
-		return isExplicitPolymorphism;
-	}
-
-	public boolean isMutable() {
-		return isMutable;
-	}
-
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		return optimisticLockStyle;
-	}
-
-	public String getWhereClause() {
-		return whereClause;
-	}
-
-	public String getRowId() {
-		return rowId;
-	}
-
-	public Caching getCaching() {
-		return caching;
-	}
-
-	public TableSource getPrimaryTableSource() {
-		if ( definesItsOwnTable() ) {
-			return primaryTableSource;
-		}
-		else {
-			return ( (EntityClass) getParent() ).getPrimaryTableSource();
-		}
-	}
-
-	public Set<TableSource> getSecondaryTableSources() {
-		return secondaryTableSources;
-	}
-
-	public Set<ConstraintSource> getConstraintSources() {
-		return constraintSources;
-	}
-
-	public String getExplicitEntityName() {
-		return explicitEntityName;
-	}
-
-	public String getEntityName() {
-		return getConfiguredClass().getSimpleName();
-	}
-
-	public boolean isDynamicInsert() {
-		return isDynamicInsert;
-	}
-
-	public boolean isDynamicUpdate() {
-		return isDynamicUpdate;
-	}
-
-	public boolean isSelectBeforeUpdate() {
-		return isSelectBeforeUpdate;
-	}
-
-	public String getCustomLoaderQueryName() {
-		return customLoaderQueryName;
-	}
-
-	public CustomSQL getCustomInsert() {
-		return customInsert;
-	}
-
-	public CustomSQL getCustomUpdate() {
-		return customUpdate;
-	}
-
-	public CustomSQL getCustomDelete() {
-		return customDelete;
-	}
-
-	public List<String> getSynchronizedTableNames() {
-		return synchronizedTableNames;
-	}
-
-	public String getCustomPersister() {
-		return customPersister;
-	}
-
-	public boolean isLazy() {
-		return isLazy;
-	}
-
-	public String getProxy() {
-		return proxy;
-	}
-
-	public int getBatchSize() {
-		return batchSize;
-	}
-
-	public boolean isEntityRoot() {
-		return getParent() == null;
-	}
-
-	public boolean isDiscriminatorForced() {
-		return isDiscriminatorForced;
-	}
-
-	public boolean isDiscriminatorIncludedInSql() {
-		return isDiscriminatorIncludedInSql;
-	}
-
-	public String getDiscriminatorMatchValue() {
-		return discriminatorMatchValue;
-	}
-
-	public List<JpaCallbackClass> getJpaCallbacks() {
-		return jpaCallbacks;
-	}
-
-	private String determineExplicitEntityName() {
-		final AnnotationInstance jpaEntityAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), JPADotNames.ENTITY
-		);
-		return JandexHelper.getValue( jpaEntityAnnotation, "name", String.class );
-	}
-
-
-	private boolean definesItsOwnTable() {
-		return !InheritanceType.SINGLE_TABLE.equals( inheritanceType ) || isEntityRoot();
-	}
-
-	private IdType determineIdType() {
-		List<AnnotationInstance> idAnnotations = findIdAnnotations( JPADotNames.ID );
-		List<AnnotationInstance> embeddedIdAnnotations = findIdAnnotations( JPADotNames.EMBEDDED_ID );
-
-		if ( !idAnnotations.isEmpty() && !embeddedIdAnnotations.isEmpty() ) {
-			throw new MappingException(
-					"@EmbeddedId and @Id cannot be used together. Check the configuration for " + getName() + "."
-			);
-		}
-
-		if ( !embeddedIdAnnotations.isEmpty() ) {
-			if ( embeddedIdAnnotations.size() == 1 ) {
-				return IdType.EMBEDDED;
-			}
-			else {
-				throw new AnnotationException( "Multiple @EmbeddedId annotations are not allowed" );
-			}
-		}
-
-		if ( !idAnnotations.isEmpty() ) {
-			return idAnnotations.size() == 1 ? IdType.SIMPLE : IdType.COMPOSED;
-		}
-		return IdType.NONE;
-	}
-
-	private List<AnnotationInstance> findIdAnnotations(DotName idAnnotationType) {
-		List<AnnotationInstance> idAnnotationList = new ArrayList<AnnotationInstance>();
-		if ( getClassInfo().annotations().containsKey( idAnnotationType ) ) {
-			idAnnotationList.addAll( getClassInfo().annotations().get( idAnnotationType ) );
-		}
-		ConfiguredClass parent = getParent();
-		while ( parent != null ) {
-			if ( parent.getClassInfo().annotations().containsKey( idAnnotationType ) ) {
-				idAnnotationList.addAll( parent.getClassInfo().annotations().get( idAnnotationType ) );
-			}
-			parent = parent.getParent();
-		}
-		return idAnnotationList;
-	}
-
-	private void processDiscriminator() {
-		if ( !InheritanceType.SINGLE_TABLE.equals( inheritanceType ) ) {
-			return;
-		}
-
-		final AnnotationInstance discriminatorValueAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), JPADotNames.DISCRIMINATOR_VALUE
-		);
-		if ( discriminatorValueAnnotation != null ) {
-			this.discriminatorMatchValue = discriminatorValueAnnotation.value().asString();
-		}
-
-		final AnnotationInstance discriminatorColumnAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), JPADotNames.DISCRIMINATOR_COLUMN
-		);
-
-		final AnnotationInstance discriminatorFormulaAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(),
-				HibernateDotNames.DISCRIMINATOR_FORMULA
-		);
-
-
-		Class<?> type = String.class; // string is the discriminator default
-		if ( discriminatorFormulaAnnotation != null ) {
-			String expression = JandexHelper.getValue( discriminatorFormulaAnnotation, "value", String.class );
-			discriminatorFormula = new FormulaValue( getPrimaryTableSource().getExplicitTableName(), expression );
-		}
-		discriminatorColumnValues = new ColumnValues( null ); //(stliu) give null here, will populate values below
-		discriminatorColumnValues.setNullable( false ); // discriminator column cannot be null
-		if ( discriminatorColumnAnnotation != null ) {
-
-			DiscriminatorType discriminatorType = Enum.valueOf(
-					DiscriminatorType.class, discriminatorColumnAnnotation.value( "discriminatorType" ).asEnum()
-			);
-			switch ( discriminatorType ) {
-				case STRING: {
-					type = String.class;
-					break;
-				}
-				case CHAR: {
-					type = Character.class;
-					break;
-				}
-				case INTEGER: {
-					type = Integer.class;
-					break;
-				}
-				default: {
-					throw new AnnotationException( "Unsupported discriminator type: " + discriminatorType );
-				}
-			}
-
-			discriminatorColumnValues.setName(
-					JandexHelper.getValue(
-							discriminatorColumnAnnotation,
-							"name",
-							String.class
-					)
-			);
-			discriminatorColumnValues.setLength(
-					JandexHelper.getValue(
-							discriminatorColumnAnnotation,
-							"length",
-							Integer.class
-					)
-			);
-			discriminatorColumnValues.setColumnDefinition(
-					JandexHelper.getValue(
-							discriminatorColumnAnnotation,
-							"columnDefinition",
-							String.class
-					)
-			);
-		}
-		discriminatorType = type;
-
-		AnnotationInstance discriminatorOptionsAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.DISCRIMINATOR_OPTIONS
-		);
-		if ( discriminatorOptionsAnnotation != null ) {
-			isDiscriminatorForced = discriminatorOptionsAnnotation.value( "force" ).asBoolean();
-			isDiscriminatorIncludedInSql = discriminatorOptionsAnnotation.value( "insert" ).asBoolean();
-		}
-		else {
-			isDiscriminatorForced = false;
-			isDiscriminatorIncludedInSql = true;
-		}
-	}
-
-	private void processHibernateEntitySpecificAnnotations() {
-		final AnnotationInstance hibernateEntityAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.ENTITY
-		);
-
-		// see HHH-6400
-		PolymorphismType polymorphism = PolymorphismType.IMPLICIT;
-		if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "polymorphism" ) != null ) {
-			polymorphism = PolymorphismType.valueOf( hibernateEntityAnnotation.value( "polymorphism" ).asEnum() );
-		}
-		isExplicitPolymorphism = polymorphism == PolymorphismType.EXPLICIT;
-
-		// see HHH-6401
-		OptimisticLockType optimisticLockType = OptimisticLockType.VERSION;
-		if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "optimisticLock" ) != null ) {
-			optimisticLockType = OptimisticLockType.valueOf(
-					hibernateEntityAnnotation.value( "optimisticLock" )
-							.asEnum()
-			);
-		}
-		optimisticLockStyle = OptimisticLockStyle.valueOf( optimisticLockType.name() );
-
-		final AnnotationInstance hibernateImmutableAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.IMMUTABLE
-		);
-		isMutable = hibernateImmutableAnnotation == null
-				&& hibernateEntityAnnotation != null
-				&& hibernateEntityAnnotation.value( "mutable" ) != null
-				&& hibernateEntityAnnotation.value( "mutable" ).asBoolean();
-
-
-		final AnnotationInstance whereAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.WHERE
-		);
-		whereClause = whereAnnotation != null && whereAnnotation.value( "clause" ) != null ?
-				whereAnnotation.value( "clause" ).asString() : null;
-
-		final AnnotationInstance rowIdAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.ROW_ID
-		);
-		rowId = rowIdAnnotation != null && rowIdAnnotation.value() != null
-				? rowIdAnnotation.value().asString() : null;
-
-		caching = determineCachingSettings();
-
-		// see HHH-6397
-		isDynamicInsert =
-				hibernateEntityAnnotation != null
-						&& hibernateEntityAnnotation.value( "dynamicInsert" ) != null
-						&& hibernateEntityAnnotation.value( "dynamicInsert" ).asBoolean();
-
-		// see HHH-6398
-		isDynamicUpdate =
-				hibernateEntityAnnotation != null
-						&& hibernateEntityAnnotation.value( "dynamicUpdate" ) != null
-						&& hibernateEntityAnnotation.value( "dynamicUpdate" ).asBoolean();
-
-
-		// see HHH-6399
-		isSelectBeforeUpdate =
-				hibernateEntityAnnotation != null
-						&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ) != null
-						&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ).asBoolean();
-
-		// Custom persister
-		final String entityPersisterClass;
-		final AnnotationInstance persisterAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.PERSISTER
-		);
-		if ( persisterAnnotation == null || persisterAnnotation.value( "impl" ) == null ) {
-			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
-				entityPersisterClass = hibernateEntityAnnotation.value( "persister" ).asString();
-			}
-			else {
-				entityPersisterClass = null;
-			}
-		}
-		else {
-			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
-				// todo : error?
-			}
-			entityPersisterClass = persisterAnnotation.value( "impl" ).asString();
-		}
-		this.customPersister = entityPersisterClass;
-	}
-
-	private Caching determineCachingSettings() {
-		final AnnotationInstance hibernateCacheAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.CACHE
-		);
-		if ( hibernateCacheAnnotation != null ) {
-			final org.hibernate.cache.spi.access.AccessType accessType = hibernateCacheAnnotation.value( "usage" ) == null
-					? getLocalBindingContext().getMappingDefaults().getCacheAccessType()
-					: CacheConcurrencyStrategy.parse( hibernateCacheAnnotation.value( "usage" ).asEnum() )
-					.toAccessType();
-			return new Caching(
-					hibernateCacheAnnotation.value( "region" ) == null
-							? getName()
-							: hibernateCacheAnnotation.value( "region" ).asString(),
-					accessType,
-					hibernateCacheAnnotation.value( "include" ) != null
-							&& "all".equals( hibernateCacheAnnotation.value( "include" ).asString() )
-			);
-		}
-
-		final AnnotationInstance jpaCacheableAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), JPADotNames.CACHEABLE
-		);
-
-		boolean cacheable = true; // true is the default
-		if ( jpaCacheableAnnotation != null && jpaCacheableAnnotation.value() != null ) {
-			cacheable = jpaCacheableAnnotation.value().asBoolean();
-		}
-
-		final boolean doCaching;
-		switch ( getLocalBindingContext().getMetadataImplementor().getOptions().getSharedCacheMode() ) {
-			case ALL: {
-				doCaching = true;
-				break;
-			}
-			case ENABLE_SELECTIVE: {
-				doCaching = cacheable;
-				break;
-			}
-			case DISABLE_SELECTIVE: {
-				doCaching = jpaCacheableAnnotation == null || cacheable;
-				break;
-			}
-			default: {
-				// treat both NONE and UNSPECIFIED the same
-				doCaching = false;
-				break;
-			}
-		}
-
-		if ( !doCaching ) {
-			return null;
-		}
-
-		return new Caching(
-				getName(),
-				getLocalBindingContext().getMappingDefaults().getCacheAccessType(),
-				true
-		);
-	}
-
-	/**
-	 * todo see {@code Binder#createTable}
-	 *
-	 * @param tableAnnotation a annotation instance, either {@link javax.persistence.Table} or {@link javax.persistence.SecondaryTable}
-	 *
-	 * @return A table source for the specified annotation instance
-	 */
-	private TableSource createTableSource(AnnotationInstance tableAnnotation) {
-		String schema = null;
-		String catalog = null;
-		if ( tableAnnotation != null ) {
-			schema = JandexHelper.getValue( tableAnnotation, "schema", String.class );
-			catalog = JandexHelper.getValue( tableAnnotation, "catalog", String.class );
-		}
-		// process the table name
-		String tableName = null;
-		String logicalTableName = null;
-
-		if ( tableAnnotation != null ) {
-			logicalTableName = JandexHelper.getValue( tableAnnotation, "name", String.class );
-			if ( StringHelper.isNotEmpty( logicalTableName ) ) {
-				tableName = logicalTableName;
-			}
-			createUniqueConstraints( tableAnnotation, tableName );
-		}
-
-		TableSourceImpl tableSourceImpl;
-		if ( tableAnnotation == null || JPADotNames.TABLE.equals( tableAnnotation.name() ) ) {
-			// for the main table @Table we use 'null' as logical name
-			tableSourceImpl = new TableSourceImpl( schema, catalog, tableName, null );
-		}
-		else {
-			// for secondary tables a name must be specified which is used as logical table name
-			tableSourceImpl = new TableSourceImpl( schema, catalog, tableName, logicalTableName );
-		}
-		return tableSourceImpl;
-	}
-
-	private Set<TableSource> createSecondaryTableSources() {
-		Set<TableSource> secondaryTableSources = new HashSet<TableSource>();
-		AnnotationInstance secondaryTables = JandexHelper.getSingleAnnotation(
-				getClassInfo(),
-				JPADotNames.SECONDARY_TABLES
-		);
-		AnnotationInstance secondaryTable = JandexHelper.getSingleAnnotation(
-				getClassInfo(),
-				JPADotNames.SECONDARY_TABLE
-		);
-		// collect all @secondaryTable annotations
-		List<AnnotationInstance> secondaryTableAnnotations = new ArrayList<AnnotationInstance>();
-		if ( secondaryTable != null ) {
-			secondaryTableAnnotations.add(
-					secondaryTable
-			);
-		}
-
-		if ( secondaryTables != null ) {
-			secondaryTableAnnotations.addAll(
-					Arrays.asList(
-							JandexHelper.getValue( secondaryTables, "value", AnnotationInstance[].class )
-					)
-			);
-		}
-
-		// create table sources
-		for ( AnnotationInstance annotationInstance : secondaryTableAnnotations ) {
-			secondaryTableSources.add( createTableSource( annotationInstance ) );
-		}
-
-		return secondaryTableSources;
-	}
-
-
-	private void createUniqueConstraints(AnnotationInstance tableAnnotation, String tableName) {
-		AnnotationValue value = tableAnnotation.value( "uniqueConstraints" );
-		if ( value == null ) {
-			return;
-		}
-
-		AnnotationInstance[] uniqueConstraints = value.asNestedArray();
-		for ( AnnotationInstance unique : uniqueConstraints ) {
-			String name = unique.value( "name" ) == null ? null : unique.value( "name" ).asString();
-			String[] columnNames = unique.value( "columnNames" ).asStringArray();
-			UniqueConstraintSourceImpl uniqueConstraintSource =
-					new UniqueConstraintSourceImpl(
-							name, tableName, Arrays.asList( columnNames )
-					);
-			constraintSources.add( uniqueConstraintSource );
-		}
-	}
-
-	private String determineCustomLoader() {
-		String customLoader = null;
-		// Custom sql loader
-		final AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.LOADER
-		);
-		if ( sqlLoaderAnnotation != null ) {
-			customLoader = sqlLoaderAnnotation.value( "namedQuery" ).asString();
-		}
-		return customLoader;
-	}
-
-	private CustomSQL createCustomSQL(AnnotationInstance customSqlAnnotation) {
-		if ( customSqlAnnotation == null ) {
-			return null;
-		}
-
-		final String sql = customSqlAnnotation.value( "sql" ).asString();
-		final boolean isCallable = customSqlAnnotation.value( "callable" ) != null
-				&& customSqlAnnotation.value( "callable" ).asBoolean();
-
-		final ExecuteUpdateResultCheckStyle checkStyle = customSqlAnnotation.value( "check" ) == null
-				? isCallable
-				? ExecuteUpdateResultCheckStyle.NONE
-				: ExecuteUpdateResultCheckStyle.COUNT
-				: ExecuteUpdateResultCheckStyle.valueOf( customSqlAnnotation.value( "check" ).asEnum() );
-
-		return new CustomSQL( sql, isCallable, checkStyle );
-	}
-
-	private void processCustomSqlAnnotations() {
-		// Custom sql insert
-		final AnnotationInstance sqlInsertAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.SQL_INSERT
-		);
-		customInsert = createCustomSQL( sqlInsertAnnotation );
-
-		// Custom sql update
-		final AnnotationInstance sqlUpdateAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.SQL_UPDATE
-		);
-		customUpdate = createCustomSQL( sqlUpdateAnnotation );
-
-		// Custom sql delete
-		final AnnotationInstance sqlDeleteAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.SQL_DELETE
-		);
-		customDelete = createCustomSQL( sqlDeleteAnnotation );
-	}
-
-	private List<String> determineSynchronizedTableNames() {
-		final AnnotationInstance synchronizeAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.SYNCHRONIZE
-		);
-		if ( synchronizeAnnotation != null ) {
-			final String[] tableNames = synchronizeAnnotation.value().asStringArray();
-			return Arrays.asList( tableNames );
-		}
-		else {
-			return Collections.emptyList();
-		}
-	}
-
-	private void processProxyGeneration() {
-		// Proxy generation
-		final AnnotationInstance hibernateProxyAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.PROXY
-		);
-		if ( hibernateProxyAnnotation != null ) {
-			isLazy = hibernateProxyAnnotation.value( "lazy" ) == null
-					|| hibernateProxyAnnotation.value( "lazy" ).asBoolean();
-			if ( isLazy ) {
-				final AnnotationValue proxyClassValue = hibernateProxyAnnotation.value( "proxyClass" );
-				if ( proxyClassValue == null ) {
-					proxy = getName();
-				}
-				else {
-					proxy = proxyClassValue.asString();
-				}
-			}
-			else {
-				proxy = null;
-			}
-		}
-		else {
-			isLazy = true;
-			proxy = getName();
-		}
-	}
-
-	private int determineBatchSize() {
-		final AnnotationInstance batchSizeAnnotation = JandexHelper.getSingleAnnotation(
-				getClassInfo(), HibernateDotNames.BATCH_SIZE
-		);
-		return batchSizeAnnotation == null ? -1 : batchSizeAnnotation.value( "size" ).asInt();
-	}
-
-	private List<JpaCallbackClass> determineEntityListeners() {
-		List<JpaCallbackClass> callbackClassList = new ArrayList<JpaCallbackClass>();
-
-		// Bind default JPA entity listener callbacks (unless excluded), using superclasses first (unless excluded)
-		if ( JandexHelper.getSingleAnnotation( getClassInfo(), JPADotNames.EXCLUDE_DEFAULT_LISTENERS ) == null ) {
-			List<AnnotationInstance> defaultEntityListenerAnnotations = getLocalBindingContext().getIndex()
-					.getAnnotations( PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
-			for ( AnnotationInstance annotation : defaultEntityListenerAnnotations ) {
-				for ( Type callbackClass : annotation.value().asClassArray() ) {
-					String callbackClassName = callbackClass.name().toString();
-					try {
-						processDefaultJpaCallbacks( callbackClassName, callbackClassList );
-					}
-					catch ( PersistenceException error ) {
-						throw new PersistenceException( error.getMessage() + "default entity listener " + callbackClassName );
-					}
-				}
-			}
-		}
-
-		// Bind JPA entity listener callbacks, using superclasses first (unless excluded)
-		List<AnnotationInstance> annotationList = getClassInfo().annotations().get( JPADotNames.ENTITY_LISTENERS );
-		if ( annotationList != null ) {
-			for ( AnnotationInstance annotation : annotationList ) {
-				for ( Type callbackClass : annotation.value().asClassArray() ) {
-					String callbackClassName = callbackClass.name().toString();
-					try {
-						processJpaCallbacks( callbackClassName, true, callbackClassList );
-					}
-					catch ( PersistenceException error ) {
-						throw new PersistenceException( error.getMessage() + "entity listener " + callbackClassName );
-					}
-				}
-			}
-		}
-
-		// Bind JPA entity.mapped superclass callbacks, using superclasses first (unless excluded)
-		try {
-			processJpaCallbacks( getName(), false, callbackClassList );
-		}
-		catch ( PersistenceException error ) {
-			throw new PersistenceException(
-					error.getMessage() + "entity/mapped superclass " + getClassInfo().name().toString()
-			);
-		}
-
-		return callbackClassList;
-	}
-
-	private void processDefaultJpaCallbacks(String instanceCallbackClassName, List<JpaCallbackClass> jpaCallbackClassList) {
-		ClassInfo callbackClassInfo = getLocalBindingContext().getClassInfo( instanceCallbackClassName );
-
-		// Process superclass first if available and not excluded
-		if ( JandexHelper.getSingleAnnotation( callbackClassInfo, JPADotNames.EXCLUDE_SUPERCLASS_LISTENERS ) != null ) {
-			DotName superName = callbackClassInfo.superName();
-			if ( superName != null ) {
-				processDefaultJpaCallbacks( instanceCallbackClassName, jpaCallbackClassList );
-			}
-		}
-
-		String callbackClassName = callbackClassInfo.name().toString();
-		Map<Class<?>, String> callbacksByType = new HashMap<Class<?>, String>();
-		createDefaultCallback(
-				PrePersist.class, PseudoJpaDotNames.DEFAULT_PRE_PERSIST, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PreRemove.class, PseudoJpaDotNames.DEFAULT_PRE_REMOVE, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PreUpdate.class, PseudoJpaDotNames.DEFAULT_PRE_UPDATE, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PostLoad.class, PseudoJpaDotNames.DEFAULT_POST_LOAD, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PostPersist.class, PseudoJpaDotNames.DEFAULT_POST_PERSIST, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PostRemove.class, PseudoJpaDotNames.DEFAULT_POST_REMOVE, callbackClassName, callbacksByType
-		);
-		createDefaultCallback(
-				PostUpdate.class, PseudoJpaDotNames.DEFAULT_POST_UPDATE, callbackClassName, callbacksByType
-		);
-		if ( !callbacksByType.isEmpty() ) {
-			jpaCallbackClassList.add( new JpaCallbackClassImpl( instanceCallbackClassName, callbacksByType, true ) );
-		}
-	}
-
-	private void processJpaCallbacks(String instanceCallbackClassName, boolean isListener, List<JpaCallbackClass> callbackClassList) {
-
-		ClassInfo callbackClassInfo = getLocalBindingContext().getClassInfo( instanceCallbackClassName );
-
-		// Process superclass first if available and not excluded
-		if ( JandexHelper.getSingleAnnotation( callbackClassInfo, JPADotNames.EXCLUDE_SUPERCLASS_LISTENERS ) != null ) {
-			DotName superName = callbackClassInfo.superName();
-			if ( superName != null ) {
-				processJpaCallbacks(
-						instanceCallbackClassName,
-						isListener,
-						callbackClassList
-				);
-			}
-		}
-
-		Map<Class<?>, String> callbacksByType = new HashMap<Class<?>, String>();
-		createCallback( PrePersist.class, JPADotNames.PRE_PERSIST, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PreRemove.class, JPADotNames.PRE_REMOVE, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PreUpdate.class, JPADotNames.PRE_UPDATE, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PostLoad.class, JPADotNames.POST_LOAD, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PostPersist.class, JPADotNames.POST_PERSIST, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PostRemove.class, JPADotNames.POST_REMOVE, callbacksByType, callbackClassInfo, isListener );
-		createCallback( PostUpdate.class, JPADotNames.POST_UPDATE, callbacksByType, callbackClassInfo, isListener );
-		if ( !callbacksByType.isEmpty() ) {
-			callbackClassList.add( new JpaCallbackClassImpl( instanceCallbackClassName, callbacksByType, isListener ) );
-		}
-	}
-
-	private void createDefaultCallback(Class callbackTypeClass,
-									   DotName callbackTypeName,
-									   String callbackClassName,
-									   Map<Class<?>, String> callbacksByClass) {
-		for ( AnnotationInstance callback : getLocalBindingContext().getIndex().getAnnotations( callbackTypeName ) ) {
-			MethodInfo methodInfo = (MethodInfo) callback.target();
-			validateMethod( methodInfo, callbackTypeClass, callbacksByClass, true );
-			if ( methodInfo.declaringClass().name().toString().equals( callbackClassName ) ) {
-				if ( methodInfo.args().length != 1 ) {
-					throw new PersistenceException(
-							String.format(
-									"Callback method %s must have exactly one argument defined as either Object or %s in ",
-									methodInfo.name(),
-									getEntityName()
-							)
-					);
-				}
-				callbacksByClass.put( callbackTypeClass, methodInfo.name() );
-			}
-		}
-	}
-
-	private void createCallback(Class callbackTypeClass,
-								DotName callbackTypeName,
-								Map<Class<?>, String> callbacksByClass,
-								ClassInfo callbackClassInfo,
-								boolean isListener) {
-		Map<DotName, List<AnnotationInstance>> annotations = callbackClassInfo.annotations();
-		List<AnnotationInstance> annotationInstances = annotations.get( callbackTypeName );
-		if ( annotationInstances == null ) {
-			return;
-		}
-		for ( AnnotationInstance callbackAnnotation : annotationInstances ) {
-			MethodInfo methodInfo = (MethodInfo) callbackAnnotation.target();
-			validateMethod( methodInfo, callbackTypeClass, callbacksByClass, isListener );
-			callbacksByClass.put( callbackTypeClass, methodInfo.name() );
-		}
-	}
-
-	private void validateMethod(MethodInfo methodInfo,
-								Class callbackTypeClass,
-								Map<Class<?>, String> callbacksByClass,
-								boolean isListener) {
-		if ( methodInfo.returnType().kind() != Kind.VOID ) {
-			throw new PersistenceException( "Callback method " + methodInfo.name() + " must have a void return type in " );
-		}
-		if ( Modifier.isStatic( methodInfo.flags() ) || Modifier.isFinal( methodInfo.flags() ) ) {
-			throw new PersistenceException( "Callback method " + methodInfo.name() + " must not be static or final in " );
-		}
-		Type[] argTypes = methodInfo.args();
-		if ( isListener ) {
-			if ( argTypes.length != 1 ) {
-				throw new PersistenceException( "Callback method " + methodInfo.name() + " must have exactly one argument in " );
-			}
-			String argTypeName = argTypes[0].name().toString();
-			if ( !argTypeName.equals( Object.class.getName() ) && !argTypeName.equals( getName() ) ) {
-				throw new PersistenceException(
-						"The argument for callback method " + methodInfo.name() +
-								" must be defined as either Object or " + getEntityName() + " in "
-				);
-			}
-		}
-		else if ( argTypes.length != 0 ) {
-			throw new PersistenceException( "Callback method " + methodInfo.name() + " must have no arguments in " );
-		}
-		if ( callbacksByClass.containsKey( callbackTypeClass ) ) {
-			throw new PersistenceException(
-					"Only one method may be annotated as a " + callbackTypeClass.getSimpleName() +
-							" callback method in "
-			);
-		}
-	}
-
-	// Process JPA callbacks, in superclass-first order (unless superclasses are excluded), using default listeners first
-	// (unless default listeners are excluded), then entity listeners, and finally the entity/mapped superclass itself
-	private class JpaCallbackClassImpl implements JpaCallbackClass {
-
-		private final Map<Class<?>, String> callbacksByType;
-		private final String name;
-		private final boolean isListener;
-
-		private JpaCallbackClassImpl(String name,
-									 Map<Class<?>, String> callbacksByType,
-									 boolean isListener) {
-			this.name = name;
-			this.callbacksByType = callbacksByType;
-			this.isListener = isListener;
-		}
-
-		@Override
-		public String getCallbackMethod(Class<?> callbackType) {
-			return callbacksByType.get( callbackType );
-		}
-
-		@Override
-		public String getName() {
-			return name;
-		}
-
-		@Override
-		public boolean isListener() {
-			return isListener;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntitySourceImpl.java
deleted file mode 100644
index 4c6c677e4e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntitySourceImpl.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.annotations.attribute.AssociationAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.BasicAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.SingularAttributeSourceImpl;
-import org.hibernate.metamodel.source.annotations.attribute.ToOneAttributeSourceImpl;
-import org.hibernate.metamodel.source.binder.AttributeSource;
-import org.hibernate.metamodel.source.binder.ConstraintSource;
-import org.hibernate.metamodel.source.binder.EntitySource;
-import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-import org.hibernate.metamodel.source.binder.TableSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class EntitySourceImpl implements EntitySource {
-	private final EntityClass entityClass;
-	private final Set<SubclassEntitySource> subclassEntitySources;
-
-	public EntitySourceImpl(EntityClass entityClass) {
-		this.entityClass = entityClass;
-		this.subclassEntitySources = new HashSet<SubclassEntitySource>();
-	}
-
-	public EntityClass getEntityClass() {
-		return entityClass;
-	}
-
-	@Override
-	public Origin getOrigin() {
-		return entityClass.getLocalBindingContext().getOrigin();
-	}
-
-	@Override
-	public LocalBindingContext getLocalBindingContext() {
-		return entityClass.getLocalBindingContext();
-	}
-
-	@Override
-	public String getEntityName() {
-		return entityClass.getName();
-	}
-
-	@Override
-	public String getClassName() {
-		return entityClass.getName();
-	}
-
-	@Override
-	public String getJpaEntityName() {
-		return entityClass.getExplicitEntityName();
-	}
-
-	@Override
-	public TableSource getPrimaryTable() {
-		return entityClass.getPrimaryTableSource();
-	}
-
-	@Override
-	public boolean isAbstract() {
-		return false;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return entityClass.isLazy();
-	}
-
-	@Override
-	public String getProxy() {
-		return entityClass.getProxy();
-	}
-
-	@Override
-	public int getBatchSize() {
-		return entityClass.getBatchSize();
-	}
-
-	@Override
-	public boolean isDynamicInsert() {
-		return entityClass.isDynamicInsert();
-	}
-
-	@Override
-	public boolean isDynamicUpdate() {
-		return entityClass.isDynamicUpdate();
-	}
-
-	@Override
-	public boolean isSelectBeforeUpdate() {
-		return entityClass.isSelectBeforeUpdate();
-	}
-
-	@Override
-	public String getCustomTuplizerClassName() {
-		return entityClass.getCustomTuplizer();
-	}
-
-	@Override
-	public String getCustomPersisterClassName() {
-		return entityClass.getCustomPersister();
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return entityClass.getCustomLoaderQueryName();
-	}
-
-	@Override
-	public CustomSQL getCustomSqlInsert() {
-		return entityClass.getCustomInsert();
-	}
-
-	@Override
-	public CustomSQL getCustomSqlUpdate() {
-		return entityClass.getCustomUpdate();
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDelete() {
-		return entityClass.getCustomDelete();
-	}
-
-	@Override
-	public List<String> getSynchronizedTableNames() {
-		return entityClass.getSynchronizedTableNames();
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Collections.emptySet();
-	}
-
-	@Override
-	public String getPath() {
-		return entityClass.getName();
-	}
-
-	@Override
-	public Iterable<AttributeSource> attributeSources() {
-		List<AttributeSource> attributeList = new ArrayList<AttributeSource>();
-		for ( BasicAttribute attribute : entityClass.getSimpleAttributes() ) {
-			attributeList.add( new SingularAttributeSourceImpl( attribute ) );
-		}
-		for ( EmbeddableClass component : entityClass.getEmbeddedClasses().values() ) {
-			attributeList.add(
-					new ComponentAttributeSourceImpl(
-							component,
-							"",
-							entityClass.getAttributeOverrideMap()
-					)
-			);
-		}
-		for ( AssociationAttribute associationAttribute : entityClass.getAssociationAttributes() ) {
-			attributeList.add( new ToOneAttributeSourceImpl( associationAttribute ) );
-		}
-		return attributeList;
-	}
-
-	@Override
-	public void add(SubclassEntitySource subclassEntitySource) {
-		subclassEntitySources.add( subclassEntitySource );
-	}
-
-	@Override
-	public Iterable<SubclassEntitySource> subclassEntitySources() {
-		return subclassEntitySources;
-	}
-
-	@Override
-	public String getDiscriminatorMatchValue() {
-		return entityClass.getDiscriminatorMatchValue();
-	}
-
-	@Override
-	public Iterable<ConstraintSource> getConstraints() {
-		return entityClass.getConstraintSources();
-	}
-
-	@Override
-	public List<JpaCallbackClass> getJpaCallbackClasses() {
-		return entityClass.getJpaCallbacks();
-	}
-
-	@Override
-	public Iterable<TableSource> getSecondaryTables() {
-		return entityClass.getSecondaryTableSources();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java
deleted file mode 100644
index 164e756af7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-/**
- * An emum for the type of id configuration for an entity.
- *
- * @author Hardy Ferentschik
- */
-public enum IdType {
-	// single @Id annotation
-	SIMPLE,
-	// multiple @Id annotations
-	COMPOSED,
-	// @EmbeddedId annotation
-	EMBEDDED,
-	// does not contain any identifier mappings
-	NONE
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/RootEntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/RootEntitySourceImpl.java
deleted file mode 100644
index 808c0b0cd9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/RootEntitySourceImpl.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.EntityMode;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.source.annotations.attribute.BasicAttribute;
-import org.hibernate.metamodel.source.annotations.attribute.DiscriminatorSourceImpl;
-import org.hibernate.metamodel.source.annotations.attribute.SimpleIdentifierSourceImpl;
-import org.hibernate.metamodel.source.annotations.attribute.SingularAttributeSourceImpl;
-import org.hibernate.metamodel.source.binder.DiscriminatorSource;
-import org.hibernate.metamodel.source.binder.IdentifierSource;
-import org.hibernate.metamodel.source.binder.RootEntitySource;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class RootEntitySourceImpl extends EntitySourceImpl implements RootEntitySource {
-	public RootEntitySourceImpl(EntityClass entityClass) {
-		super( entityClass );
-	}
-
-	@Override
-	public IdentifierSource getIdentifierSource() {
-		IdType idType = getEntityClass().getIdType();
-		switch ( idType ) {
-			case SIMPLE: {
-				BasicAttribute attribute = getEntityClass().getIdAttributes().iterator().next();
-				return new SimpleIdentifierSourceImpl( attribute, getEntityClass().getAttributeOverrideMap() );
-			}
-			case COMPOSED: {
-				throw new NotYetImplementedException( "Composed ids must still be implemented." );
-			}
-			case EMBEDDED: {
-				throw new NotYetImplementedException( "Embedded ids must still be implemented." );
-			}
-			default: {
-				throw new AssertionFailure( "The root entity needs to specify an identifier" );
-			}
-		}
-	}
-
-	@Override
-	public SingularAttributeSource getVersioningAttributeSource() {
-		SingularAttributeSource attributeSource = null;
-		EntityClass entityClass = getEntityClass();
-		if ( entityClass.getVersionAttribute() != null ) {
-			attributeSource = new SingularAttributeSourceImpl( entityClass.getVersionAttribute() );
-		}
-		return attributeSource;
-	}
-
-	@Override
-	public DiscriminatorSource getDiscriminatorSource() {
-		DiscriminatorSource discriminatorSource = null;
-		if ( getEntityClass().getDiscriminatorColumnValues() != null ) {
-			discriminatorSource = new DiscriminatorSourceImpl( getEntityClass() );
-		}
-		return discriminatorSource;
-	}
-
-	@Override
-	public EntityMode getEntityMode() {
-		return EntityMode.POJO;
-	}
-
-	@Override
-	public boolean isMutable() {
-		return getEntityClass().isMutable();
-	}
-
-	@Override
-	public boolean isExplicitPolymorphism() {
-		return getEntityClass().isExplicitPolymorphism();
-	}
-
-	@Override
-	public String getWhere() {
-		return getEntityClass().getWhereClause();
-	}
-
-	@Override
-	public String getRowId() {
-		return getEntityClass().getRowId();
-	}
-
-	@Override
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		return getEntityClass().getOptimisticLockStyle();
-	}
-
-	@Override
-	public Caching getCaching() {
-		return getEntityClass().getCaching();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/SubclassEntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/SubclassEntitySourceImpl.java
deleted file mode 100644
index 8fa01ef480..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/SubclassEntitySourceImpl.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-
-/**
- * @author Hardy Ferentschik
- */
-public class SubclassEntitySourceImpl extends EntitySourceImpl implements SubclassEntitySource {
-	public SubclassEntitySourceImpl(EntityClass entityClass) {
-		super( entityClass );
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/TableSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/TableSourceImpl.java
deleted file mode 100644
index 716a483e3c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/TableSourceImpl.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import org.hibernate.metamodel.source.binder.TableSource;
-
-class TableSourceImpl implements TableSource {
-	private final String schema;
-	private final String catalog;
-	private final String tableName;
-	private final String logicalName;
-
-	TableSourceImpl(String schema, String catalog, String tableName, String logicalName) {
-		this.schema = schema;
-		this.catalog = catalog;
-		this.tableName = tableName;
-		this.logicalName = logicalName;
-	}
-
-	@Override
-	public String getExplicitSchemaName() {
-		return schema;
-	}
-
-	@Override
-	public String getExplicitCatalogName() {
-		return catalog;
-	}
-
-	@Override
-	public String getExplicitTableName() {
-		return tableName;
-	}
-
-	@Override
-	public String getLogicalName() {
-		return logicalName;
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		TableSourceImpl that = (TableSourceImpl) o;
-
-		if ( catalog != null ? !catalog.equals( that.catalog ) : that.catalog != null ) {
-			return false;
-		}
-		if ( logicalName != null ? !logicalName.equals( that.logicalName ) : that.logicalName != null ) {
-			return false;
-		}
-		if ( schema != null ? !schema.equals( that.schema ) : that.schema != null ) {
-			return false;
-		}
-		if ( tableName != null ? !tableName.equals( that.tableName ) : that.tableName != null ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public int hashCode() {
-		int result = schema != null ? schema.hashCode() : 0;
-		result = 31 * result + ( catalog != null ? catalog.hashCode() : 0 );
-		result = 31 * result + ( tableName != null ? tableName.hashCode() : 0 );
-		result = 31 * result + ( logicalName != null ? logicalName.hashCode() : 0 );
-		return result;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "TableSourceImpl" );
-		sb.append( "{schema='" ).append( schema ).append( '\'' );
-		sb.append( ", catalog='" ).append( catalog ).append( '\'' );
-		sb.append( ", tableName='" ).append( tableName ).append( '\'' );
-		sb.append( ", logicalName='" ).append( logicalName ).append( '\'' );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintSourceImpl.java
deleted file mode 100644
index 3e26ca40b7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintSourceImpl.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.List;
-
-import org.hibernate.metamodel.source.binder.UniqueConstraintSource;
-
-/**
- * @author Hardy Ferentschik
- */
-class UniqueConstraintSourceImpl implements UniqueConstraintSource {
-	private final String name;
-	private final String tableName;
-	private final List<String> columnNames;
-
-	UniqueConstraintSourceImpl(String name, String tableName, List<String> columnNames) {
-		this.name = name;
-		this.tableName = tableName;
-		this.columnNames = columnNames;
-	}
-
-	@Override
-	public String name() {
-		return name;
-	}
-
-	@Override
-	public String getTableName() {
-		return tableName;
-	}
-
-	@Override
-	public Iterable<String> columnNames() {
-		return columnNames;
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if ( this == o ) {
-			return true;
-		}
-		if ( o == null || getClass() != o.getClass() ) {
-			return false;
-		}
-
-		UniqueConstraintSourceImpl that = (UniqueConstraintSourceImpl) o;
-
-		if ( columnNames != null ? !columnNames.equals( that.columnNames ) : that.columnNames != null ) {
-			return false;
-		}
-		if ( name != null ? !name.equals( that.name ) : that.name != null ) {
-			return false;
-		}
-		if ( tableName != null ? !tableName.equals( that.tableName ) : that.tableName != null ) {
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public int hashCode() {
-		int result = name != null ? name.hashCode() : 0;
-		result = 31 * result + ( tableName != null ? tableName.hashCode() : 0 );
-		result = 31 * result + ( columnNames != null ? columnNames.hashCode() : 0 );
-		return result;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "UniqueConstraintSourceImpl" );
-		sb.append( "{name='" ).append( name ).append( '\'' );
-		sb.append( ", tableName='" ).append( tableName ).append( '\'' );
-		sb.append( ", columnNames=" ).append( columnNames );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
-
-
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java
deleted file mode 100644
index 712d52c3f1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.hibernate.MappingException;
-import org.hibernate.annotations.FetchMode;
-import org.hibernate.annotations.FetchProfiles;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.metamodel.binding.FetchProfile.Fetch;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-
-/**
- * Binds fetch profiles found in annotations.
- *
- * @author Hardy Ferentschik
- */
-public class FetchProfileBinder {
-
-	private FetchProfileBinder() {
-	}
-
-	/**
-	 * Binds all {@link FetchProfiles} and {@link org.hibernate.annotations.FetchProfile} annotations to the supplied metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	// TODO verify that association exists. See former VerifyFetchProfileReferenceSecondPass
-	public static void bind(AnnotationBindingContext bindingContext) {
-
-		List<AnnotationInstance> annotations = bindingContext.getIndex()
-				.getAnnotations( HibernateDotNames.FETCH_PROFILE );
-		for ( AnnotationInstance fetchProfile : annotations ) {
-			bind( bindingContext.getMetadataImplementor(), fetchProfile );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.FETCH_PROFILES );
-		for ( AnnotationInstance fetchProfiles : annotations ) {
-			AnnotationInstance[] fetchProfileAnnotations = JandexHelper.getValue(
-					fetchProfiles,
-					"value",
-					AnnotationInstance[].class
-			);
-			for ( AnnotationInstance fetchProfile : fetchProfileAnnotations ) {
-				bind( bindingContext.getMetadataImplementor(), fetchProfile );
-			}
-		}
-	}
-
-	private static void bind(MetadataImplementor metadata, AnnotationInstance fetchProfile) {
-		String name = JandexHelper.getValue( fetchProfile, "name", String.class );
-		Set<Fetch> fetches = new HashSet<Fetch>();
-		AnnotationInstance[] overrideAnnotations = JandexHelper.getValue(
-				fetchProfile,
-				"fetchOverrides",
-				AnnotationInstance[].class
-		);
-		for ( AnnotationInstance override : overrideAnnotations ) {
-			FetchMode fetchMode = JandexHelper.getEnumValue( override, "mode", FetchMode.class );
-			if ( !fetchMode.equals( org.hibernate.annotations.FetchMode.JOIN ) ) {
-				throw new MappingException( "Only FetchMode.JOIN is currently supported" );
-			}
-			final String entityName = JandexHelper.getValue( override, "entity", String.class );
-			final String associationName = JandexHelper.getValue( override, "association", String.class );
-			fetches.add( new Fetch( entityName, associationName, fetchMode.toString().toLowerCase() ) );
-		}
-		metadata.addFetchProfile( new FetchProfile( name, fetches ) );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java
deleted file mode 100644
index 9c5c5c26fd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.annotations.FilterDef;
-import org.hibernate.annotations.FilterDefs;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.type.Type;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.logging.Logger;
-
-/**
- * Binds {@link FilterDefs} and {@link FilterDef} annotations.
- *
- * @author Hardy Ferentschik
- */
-public class FilterDefBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			FilterDefBinder.class.getName()
-	);
-
-	/**
-	 * Binds all {@link FilterDefs} and {@link FilterDef} annotations to the supplied metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	public static void bind(AnnotationBindingContext bindingContext) {
-		List<AnnotationInstance> annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.FILTER_DEF );
-		for ( AnnotationInstance filterDef : annotations ) {
-			bind( bindingContext.getMetadataImplementor(), filterDef );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.FILTER_DEFS );
-		for ( AnnotationInstance filterDefs : annotations ) {
-			AnnotationInstance[] filterDefAnnotations = JandexHelper.getValue(
-					filterDefs,
-					"value",
-					AnnotationInstance[].class
-			);
-			for ( AnnotationInstance filterDef : filterDefAnnotations ) {
-				bind( bindingContext.getMetadataImplementor(), filterDef );
-			}
-		}
-	}
-
-	private static void bind(MetadataImplementor metadata, AnnotationInstance filterDef) {
-		String name = JandexHelper.getValue( filterDef, "name", String.class );
-		Map<String, Type> prms = new HashMap<String, Type>();
-		for ( AnnotationInstance prm : JandexHelper.getValue( filterDef, "parameters", AnnotationInstance[].class ) ) {
-			prms.put(
-					JandexHelper.getValue( prm, "name", String.class ),
-					metadata.getTypeResolver().heuristicType( JandexHelper.getValue( prm, "type", String.class ) )
-			);
-		}
-		metadata.addFilterDefinition(
-				new FilterDefinition(
-						name,
-						JandexHelper.getValue( filterDef, "defaultCondition", String.class ),
-						prms
-				)
-		);
-		LOG.debugf( "Binding filter definition: %s", name );
-	}
-
-	private FilterDefBinder() {
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java
deleted file mode 100644
index 8039fd7802..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import javax.persistence.GenerationType;
-import javax.persistence.SequenceGenerator;
-
-import org.hibernate.annotations.GenericGenerator;
-import org.hibernate.annotations.GenericGenerators;
-import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.id.MultipleHiLoPerTableGenerator;
-import org.hibernate.id.PersistentIdentifierGenerator;
-import org.hibernate.id.SequenceHiLoGenerator;
-import org.hibernate.id.TableHiLoGenerator;
-import org.hibernate.id.enhanced.SequenceStyleGenerator;
-import org.hibernate.id.enhanced.TableGenerator;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.EnumConversionHelper;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.logging.Logger;
-
-/**
- * Binds {@link SequenceGenerator}, {@link javax.persistence.TableGenerator}, {@link GenericGenerator}, and
- * {@link GenericGenerators} annotations.
- *
- * @author Hardy Ferentschik
- */
-public class IdGeneratorBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			IdGeneratorBinder.class.getName()
-	);
-
-	private IdGeneratorBinder() {
-	}
-
-	/**
-	 * Binds all {@link SequenceGenerator}, {@link javax.persistence.TableGenerator}, {@link GenericGenerator}, and
-	 * {@link GenericGenerators} annotations to the supplied metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	public static void bind(AnnotationBindingContext bindingContext) {
-		List<AnnotationInstance> annotations = bindingContext.getIndex()
-				.getAnnotations( JPADotNames.SEQUENCE_GENERATOR );
-		for ( AnnotationInstance generator : annotations ) {
-			bindSequenceGenerator( bindingContext.getMetadataImplementor(), generator );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( JPADotNames.TABLE_GENERATOR );
-		for ( AnnotationInstance generator : annotations ) {
-			bindTableGenerator( bindingContext.getMetadataImplementor(), generator );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.GENERIC_GENERATOR );
-		for ( AnnotationInstance generator : annotations ) {
-			bindGenericGenerator( bindingContext.getMetadataImplementor(), generator );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.GENERIC_GENERATORS );
-		for ( AnnotationInstance generators : annotations ) {
-			for ( AnnotationInstance generator : JandexHelper.getValue(
-					generators,
-					"value",
-					AnnotationInstance[].class
-			) ) {
-				bindGenericGenerator( bindingContext.getMetadataImplementor(), generator );
-			}
-		}
-	}
-
-	private static void addStringParameter(AnnotationInstance annotation,
-										   String element,
-										   Map<String, String> parameters,
-										   String parameter) {
-		String string = JandexHelper.getValue( annotation, element, String.class );
-		if ( StringHelper.isNotEmpty( string ) ) {
-			parameters.put( parameter, string );
-		}
-	}
-
-	private static void bindGenericGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
-		String name = JandexHelper.getValue( generator, "name", String.class );
-		Map<String, String> parameterMap = new HashMap<String, String>();
-		AnnotationInstance[] parameterAnnotations = JandexHelper.getValue(
-				generator,
-				"parameters",
-				AnnotationInstance[].class
-		);
-		for ( AnnotationInstance parameterAnnotation : parameterAnnotations ) {
-			parameterMap.put(
-					JandexHelper.getValue( parameterAnnotation, "name", String.class ),
-					JandexHelper.getValue( parameterAnnotation, "value", String.class )
-			);
-		}
-		metadata.addIdGenerator(
-				new IdGenerator(
-						name,
-						JandexHelper.getValue( generator, "strategy", String.class ),
-						parameterMap
-				)
-		);
-		LOG.tracef( "Add generic generator with name: %s", name );
-	}
-
-	private static void bindSequenceGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
-		String name = JandexHelper.getValue( generator, "name", String.class );
-		Map<String, String> parameterMap = new HashMap<String, String>();
-		addStringParameter( generator, "sequenceName", parameterMap, SequenceStyleGenerator.SEQUENCE_PARAM );
-		boolean useNewIdentifierGenerators = metadata.getOptions().useNewIdentifierGenerators();
-		String strategy = EnumConversionHelper.generationTypeToGeneratorStrategyName(
-				GenerationType.SEQUENCE,
-				useNewIdentifierGenerators
-		);
-		if ( useNewIdentifierGenerators ) {
-			addStringParameter( generator, "catalog", parameterMap, PersistentIdentifierGenerator.CATALOG );
-			addStringParameter( generator, "schema", parameterMap, PersistentIdentifierGenerator.SCHEMA );
-			parameterMap.put(
-					SequenceStyleGenerator.INCREMENT_PARAM,
-					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) )
-			);
-			parameterMap.put(
-					SequenceStyleGenerator.INITIAL_PARAM,
-					String.valueOf( JandexHelper.getValue( generator, "initialValue", Integer.class ) )
-			);
-		}
-		else {
-			if ( JandexHelper.getValue( generator, "initialValue", Integer.class ) != 1 ) {
-				LOG.unsupportedInitialValue( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS );
-			}
-			parameterMap.put(
-					SequenceHiLoGenerator.MAX_LO,
-					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) - 1 )
-			);
-		}
-		metadata.addIdGenerator( new IdGenerator( name, strategy, parameterMap ) );
-		LOG.tracef( "Add sequence generator with name: %s", name );
-	}
-
-	private static void bindTableGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
-		String name = JandexHelper.getValue( generator, "name", String.class );
-		Map<String, String> parameterMap = new HashMap<String, String>();
-		addStringParameter( generator, "catalog", parameterMap, PersistentIdentifierGenerator.CATALOG );
-		addStringParameter( generator, "schema", parameterMap, PersistentIdentifierGenerator.SCHEMA );
-		boolean useNewIdentifierGenerators = metadata.getOptions().useNewIdentifierGenerators();
-		String strategy = EnumConversionHelper.generationTypeToGeneratorStrategyName(
-				GenerationType.TABLE,
-				useNewIdentifierGenerators
-		);
-		if ( useNewIdentifierGenerators ) {
-			parameterMap.put( TableGenerator.CONFIG_PREFER_SEGMENT_PER_ENTITY, "true" );
-			addStringParameter( generator, "table", parameterMap, TableGenerator.TABLE_PARAM );
-			addStringParameter( generator, "pkColumnName", parameterMap, TableGenerator.SEGMENT_COLUMN_PARAM );
-			addStringParameter( generator, "pkColumnValue", parameterMap, TableGenerator.SEGMENT_VALUE_PARAM );
-			addStringParameter( generator, "valueColumnName", parameterMap, TableGenerator.VALUE_COLUMN_PARAM );
-			parameterMap.put(
-					TableGenerator.INCREMENT_PARAM,
-					String.valueOf( JandexHelper.getValue( generator, "allocationSize", String.class ) )
-			);
-			parameterMap.put(
-					TableGenerator.INITIAL_PARAM,
-					String.valueOf( JandexHelper.getValue( generator, "initialValue", String.class ) + 1 )
-			);
-		}
-		else {
-			addStringParameter( generator, "table", parameterMap, MultipleHiLoPerTableGenerator.ID_TABLE );
-			addStringParameter( generator, "pkColumnName", parameterMap, MultipleHiLoPerTableGenerator.PK_COLUMN_NAME );
-			addStringParameter( generator, "pkColumnValue", parameterMap, MultipleHiLoPerTableGenerator.PK_VALUE_NAME );
-			addStringParameter( generator, "valueColumnName", parameterMap, MultipleHiLoPerTableGenerator.VALUE_COLUMN_NAME );
-			parameterMap.put(
-					TableHiLoGenerator.MAX_LO,
-					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) - 1 )
-			);
-		}
-		if ( JandexHelper.getValue( generator, "uniqueConstraints", AnnotationInstance[].class ).length > 0 ) {
-			LOG.ignoringTableGeneratorConstraints( name );
-		}
-		metadata.addIdGenerator( new IdGenerator( name, strategy, parameterMap ) );
-		LOG.tracef( "Add table generator with name: %s", name );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java
deleted file mode 100644
index a7bbd8e1fc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.HashMap;
-import java.util.List;
-import javax.persistence.NamedNativeQueries;
-import javax.persistence.NamedNativeQuery;
-import javax.persistence.NamedQueries;
-import javax.persistence.NamedQuery;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.CacheMode;
-import org.hibernate.FlushMode;
-import org.hibernate.LockMode;
-import org.hibernate.annotations.QueryHints;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
-import org.hibernate.engine.spi.NamedQueryDefinitionBuilder;
-import org.hibernate.engine.spi.NamedSQLQueryDefinition;
-import org.hibernate.engine.spi.NamedSQLQueryDefinitionBuilder;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.logging.Logger;
-
-/**
- * Binds {@link NamedQuery}, {@link NamedQueries}, {@link NamedNativeQuery}, {@link NamedNativeQueries},
- * {@link org.hibernate.annotations.NamedQuery}, {@link org.hibernate.annotations.NamedQueries},
- * {@link org.hibernate.annotations.NamedNativeQuery}, and {@link org.hibernate.annotations.NamedNativeQueries}.
- *
- * @author Hardy Ferentschik
- */
-public class QueryBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			QueryBinder.class.getName()
-	);
-
-	private QueryBinder() {
-	}
-
-	/**
-	 * Binds all {@link NamedQuery}, {@link NamedQueries}, {@link NamedNativeQuery}, {@link NamedNativeQueries},
-	 * {@link org.hibernate.annotations.NamedQuery}, {@link org.hibernate.annotations.NamedQueries},
-	 * {@link org.hibernate.annotations.NamedNativeQuery}, and {@link org.hibernate.annotations.NamedNativeQueries}
-	 * annotations to the supplied metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	public static void bind(AnnotationBindingContext bindingContext) {
-		List<AnnotationInstance> annotations = bindingContext.getIndex().getAnnotations( JPADotNames.NAMED_QUERY );
-		for ( AnnotationInstance query : annotations ) {
-			bindNamedQuery( bindingContext.getMetadataImplementor(), query );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( JPADotNames.NAMED_QUERIES );
-		for ( AnnotationInstance queries : annotations ) {
-			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
-				bindNamedQuery( bindingContext.getMetadataImplementor(), query );
-			}
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( JPADotNames.NAMED_NATIVE_QUERY );
-		for ( AnnotationInstance query : annotations ) {
-			bindNamedNativeQuery( bindingContext.getMetadataImplementor(), query );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( JPADotNames.NAMED_NATIVE_QUERIES );
-		for ( AnnotationInstance queries : annotations ) {
-			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
-				bindNamedNativeQuery( bindingContext.getMetadataImplementor(), query );
-			}
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.NAMED_QUERY );
-		for ( AnnotationInstance query : annotations ) {
-			bindNamedQuery( bindingContext.getMetadataImplementor(), query );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.NAMED_QUERIES );
-		for ( AnnotationInstance queries : annotations ) {
-			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
-				bindNamedQuery( bindingContext.getMetadataImplementor(), query );
-			}
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
-		for ( AnnotationInstance query : annotations ) {
-			bindNamedNativeQuery( bindingContext.getMetadataImplementor(), query );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERIES );
-		for ( AnnotationInstance queries : annotations ) {
-			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
-				bindNamedNativeQuery( bindingContext.getMetadataImplementor(), query );
-			}
-		}
-	}
-
-	/**
-	 * Binds {@link javax.persistence.NamedQuery} as well as {@link org.hibernate.annotations.NamedQuery}.
-	 *
-	 * @param metadata the current metadata
-	 * @param annotation the named query annotation
-	 */
-	private static void bindNamedQuery(MetadataImplementor metadata, AnnotationInstance annotation) {
-		String name = JandexHelper.getValue( annotation, "name", String.class );
-		if ( StringHelper.isEmpty( name ) ) {
-			throw new AnnotationException( "A named query must have a name when used in class or package level" );
-		}
-
-		String query = JandexHelper.getValue( annotation, "query", String.class );
-
-		AnnotationInstance[] hints = JandexHelper.getValue( annotation, "hints", AnnotationInstance[].class );
-
-		String cacheRegion = getString( hints, QueryHints.CACHE_REGION );
-		if ( StringHelper.isEmpty( cacheRegion ) ) {
-			cacheRegion = null;
-		}
-
-		Integer timeout = getTimeout( hints, query );
-		if ( timeout != null && timeout < 0 ) {
-			timeout = null;
-		}
-
-		Integer fetchSize = getInteger( hints, QueryHints.FETCH_SIZE, name );
-		if ( fetchSize != null && fetchSize < 0 ) {
-			fetchSize = null;
-		}
-
-		String comment = getString( hints, QueryHints.COMMENT );
-		if ( StringHelper.isEmpty( comment ) ) {
-			comment = null;
-		}
-
-		metadata.addNamedQuery(
-				new NamedQueryDefinitionBuilder().setName( name ).setQuery( query ).setCacheable(
-						getBoolean(
-								hints,
-								QueryHints.CACHEABLE,
-								name
-						)
-				).setCacheRegion( cacheRegion ).setTimeout( timeout ).setFetchSize( fetchSize ).setFlushMode(
-						getFlushMode( hints, QueryHints.FLUSH_MODE, name )
-				).setCacheMode( getCacheMode( hints, QueryHints.CACHE_MODE, name ) ).setReadOnly(
-						getBoolean(
-								hints,
-								QueryHints.READ_ONLY,
-								name
-						)
-				).setComment( comment ).setParameterTypes( null ).createNamedQueryDefinition()
-		);
-		LOG.debugf( "Binding named query: %s => %s", name, query );
-	}
-
-	private static void bindNamedNativeQuery(MetadataImplementor metadata, AnnotationInstance annotation) {
-		String name = JandexHelper.getValue( annotation, "name", String.class );
-		if ( StringHelper.isEmpty( name ) ) {
-			throw new AnnotationException( "A named native query must have a name when used in class or package level" );
-		}
-
-		String query = JandexHelper.getValue( annotation, "query", String.class );
-
-		String resultSetMapping = JandexHelper.getValue( annotation, "resultSetMapping", String.class );
-
-		AnnotationInstance[] hints = JandexHelper.getValue( annotation, "hints", AnnotationInstance[].class );
-
-		boolean cacheable = getBoolean( hints, "org.hibernate.cacheable", name );
-		String cacheRegion = getString( hints, QueryHints.CACHE_REGION );
-		if ( StringHelper.isEmpty( cacheRegion ) ) {
-			cacheRegion = null;
-		}
-
-		Integer timeout = getTimeout( hints, query );
-		if ( timeout != null && timeout < 0 ) {
-			timeout = null;
-		}
-
-		Integer fetchSize = getInteger( hints, QueryHints.FETCH_SIZE, name );
-		if ( fetchSize != null && fetchSize < 0 ) {
-			fetchSize = null;
-		}
-
-		FlushMode flushMode = getFlushMode( hints, QueryHints.FLUSH_MODE, name );
-		CacheMode cacheMode = getCacheMode( hints, QueryHints.CACHE_MODE, name );
-
-		boolean readOnly = getBoolean( hints, QueryHints.READ_ONLY, name );
-
-		String comment = getString( hints, QueryHints.COMMENT );
-		if ( StringHelper.isEmpty( comment ) ) {
-			comment = null;
-		}
-
-		boolean callable = getBoolean( hints, QueryHints.CALLABLE, name );
-		NamedSQLQueryDefinition def;
-		if ( StringHelper.isNotEmpty( resultSetMapping ) ) {
-			def = new NamedSQLQueryDefinitionBuilder().setName( name )
-					.setQuery( query )
-					.setResultSetRef(
-							resultSetMapping
-					)
-					.setQuerySpaces( null )
-					.setCacheable( cacheable )
-					.setCacheRegion( cacheRegion )
-					.setTimeout( timeout )
-					.setFetchSize( fetchSize )
-					.setFlushMode( flushMode )
-					.setCacheMode( cacheMode )
-					.setReadOnly( readOnly )
-					.setComment( comment )
-					.setParameterTypes( null )
-					.setCallable( callable )
-					.createNamedQueryDefinition();
-		}
-		else {
-			AnnotationValue annotationValue = annotation.value( "resultClass" );
-			if ( annotationValue == null ) {
-				throw new NotYetImplementedException( "Pure native scalar queries are not yet supported" );
-			}
-			NativeSQLQueryRootReturn queryRoots[] = new NativeSQLQueryRootReturn[] {
-					new NativeSQLQueryRootReturn(
-							"alias1",
-							annotationValue.asString(),
-							new HashMap<String, String[]>(),
-							LockMode.READ
-					)
-			};
-			def = new NamedSQLQueryDefinitionBuilder().setName( name )
-					.setQuery( query )
-					.setQueryReturns( queryRoots )
-					.setQuerySpaces( null )
-					.setCacheable( cacheable )
-					.setCacheRegion( cacheRegion )
-					.setTimeout( timeout )
-					.setFetchSize( fetchSize )
-					.setFlushMode( flushMode )
-					.setCacheMode( cacheMode )
-					.setReadOnly( readOnly )
-					.setComment( comment )
-					.setParameterTypes( null )
-					.setCallable( callable )
-					.createNamedQueryDefinition();
-		}
-		metadata.addNamedNativeQuery( def );
-		LOG.debugf( "Binding named native query: %s => %s", name, query );
-	}
-
-	private static boolean getBoolean(AnnotationInstance[] hints, String element, String query) {
-		String val = getString( hints, element );
-		if ( val == null || val.equalsIgnoreCase( "false" ) ) {
-			return false;
-		}
-		if ( val.equalsIgnoreCase( "true" ) ) {
-			return true;
-		}
-		throw new AnnotationException( "Not a boolean in hint: " + query + ":" + element );
-	}
-
-	private static CacheMode getCacheMode(AnnotationInstance[] hints, String element, String query) {
-		String val = getString( hints, element );
-		if ( val == null ) {
-			return null;
-		}
-		if ( val.equalsIgnoreCase( CacheMode.GET.toString() ) ) {
-			return CacheMode.GET;
-		}
-		if ( val.equalsIgnoreCase( CacheMode.IGNORE.toString() ) ) {
-			return CacheMode.IGNORE;
-		}
-		if ( val.equalsIgnoreCase( CacheMode.NORMAL.toString() ) ) {
-			return CacheMode.NORMAL;
-		}
-		if ( val.equalsIgnoreCase( CacheMode.PUT.toString() ) ) {
-			return CacheMode.PUT;
-		}
-		if ( val.equalsIgnoreCase( CacheMode.REFRESH.toString() ) ) {
-			return CacheMode.REFRESH;
-		}
-		throw new AnnotationException( "Unknown CacheMode in hint: " + query + ":" + element );
-	}
-
-	private static FlushMode getFlushMode(AnnotationInstance[] hints, String element, String query) {
-		String val = getString( hints, element );
-		if ( val == null ) {
-			return null;
-		}
-		if ( val.equalsIgnoreCase( FlushMode.ALWAYS.toString() ) ) {
-			return FlushMode.ALWAYS;
-		}
-		else if ( val.equalsIgnoreCase( FlushMode.AUTO.toString() ) ) {
-			return FlushMode.AUTO;
-		}
-		else if ( val.equalsIgnoreCase( FlushMode.COMMIT.toString() ) ) {
-			return FlushMode.COMMIT;
-		}
-		else if ( val.equalsIgnoreCase( FlushMode.NEVER.toString() ) ) {
-			return FlushMode.MANUAL;
-		}
-		else if ( val.equalsIgnoreCase( FlushMode.MANUAL.toString() ) ) {
-			return FlushMode.MANUAL;
-		}
-		else {
-			throw new AnnotationException( "Unknown FlushMode in hint: " + query + ":" + element );
-		}
-	}
-
-	private static Integer getInteger(AnnotationInstance[] hints, String element, String query) {
-		String val = getString( hints, element );
-		if ( val == null ) {
-			return null;
-		}
-		try {
-			return Integer.decode( val );
-		}
-		catch ( NumberFormatException nfe ) {
-			throw new AnnotationException( "Not an integer in hint: " + query + ":" + element, nfe );
-		}
-	}
-
-	private static String getString(AnnotationInstance[] hints, String element) {
-		for ( AnnotationInstance hint : hints ) {
-			if ( element.equals( JandexHelper.getValue( hint, "name", String.class ) ) ) {
-				return JandexHelper.getValue( hint, "value", String.class );
-			}
-		}
-		return null;
-	}
-
-	private static Integer getTimeout(AnnotationInstance[] hints, String query) {
-		Integer timeout = getInteger( hints, QueryHints.TIMEOUT_JPA, query );
-		if ( timeout == null ) {
-			return getInteger( hints, QueryHints.TIMEOUT_HIBERNATE, query ); // timeout is already in seconds
-		}
-		return ( ( timeout + 500 ) / 1000 ); // convert milliseconds to seconds (rounded)
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java
deleted file mode 100644
index 72c0511e32..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.List;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.ObjectName;
-import org.hibernate.metamodel.relational.Schema;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.logging.Logger;
-
-/**
- * Binds table related information. This binder is called after the entities are bound.
- *
- * @author Hardy Ferentschik
- */
-public class TableBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			TableBinder.class.getName()
-	);
-
-	private TableBinder() {
-	}
-
-	/**
-	 * Binds {@link org.hibernate.annotations.Tables} and {@link org.hibernate.annotations.Table} annotations to the supplied
-	 * metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	public static void bind(AnnotationBindingContext bindingContext) {
-		List<AnnotationInstance> annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.TABLE );
-		for ( AnnotationInstance tableAnnotation : annotations ) {
-			bind( bindingContext.getMetadataImplementor(), tableAnnotation );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.TABLES );
-		for ( AnnotationInstance tables : annotations ) {
-			for ( AnnotationInstance table : JandexHelper.getValue( tables, "value", AnnotationInstance[].class ) ) {
-				bind( bindingContext.getMetadataImplementor(), table );
-			}
-		}
-	}
-
-	private static void bind(MetadataImplementor metadata, AnnotationInstance tableAnnotation) {
-		String tableName = JandexHelper.getValue( tableAnnotation, "appliesTo", String.class );
-		ObjectName objectName = new ObjectName( tableName );
-		Schema schema = metadata.getDatabase().getSchema( objectName.getSchema(), objectName.getCatalog() );
-		Table table = schema.locateTable( objectName.getName() );
-		if ( table != null ) {
-			bindHibernateTableAnnotation( table, tableAnnotation );
-		}
-	}
-
-	private static void bindHibernateTableAnnotation(Table table, AnnotationInstance tableAnnotation) {
-		for ( AnnotationInstance indexAnnotation : JandexHelper.getValue(
-				tableAnnotation,
-				"indexes",
-				AnnotationInstance[].class
-		) ) {
-			bindIndexAnnotation( table, indexAnnotation );
-		}
-		String comment = JandexHelper.getValue( tableAnnotation, "comment", String.class );
-		if ( StringHelper.isNotEmpty( comment ) ) {
-			table.addComment( comment.trim() );
-		}
-	}
-
-	private static void bindIndexAnnotation(Table table, AnnotationInstance indexAnnotation) {
-		String indexName = JandexHelper.getValue( indexAnnotation, "appliesTo", String.class );
-		String[] columnNames = JandexHelper.getValue( indexAnnotation, "columnNames", String[].class );
-		if ( columnNames == null ) {
-			LOG.noColumnsSpecifiedForIndex( indexName, table.toLoggableString() );
-			return;
-		}
-		org.hibernate.metamodel.relational.Index index = table.getOrCreateIndex( indexName );
-		for ( String columnName : columnNames ) {
-			Column column = findColumn( table, columnName );
-			if ( column == null ) {
-				throw new AnnotationException( "@Index references a unknown column: " + columnName );
-			}
-			index.addColumn( column );
-		}
-	}
-
-	private static Column findColumn(Table table, String columnName) {
-		Column column = null;
-		for ( SimpleValue value : table.values() ) {
-			if ( value instanceof Column && ( (Column) value ).getColumnName().getName().equals( columnName ) ) {
-				column = (Column) value;
-				break;
-			}
-		}
-		return column;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java
deleted file mode 100644
index 9031f036ea..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.annotations.TypeDefs;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.logging.Logger;
-
-/**
- * Binds {@link org.hibernate.annotations.TypeDef} and {@link TypeDefs}.
- *
- * @author Hardy Ferentschik
- */
-public class TypeDefBinder {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			TypeDefBinder.class.getName()
-	);
-
-	/**
-	 * Binds all {@link org.hibernate.annotations.TypeDef} and {@link TypeDefs} annotations to the supplied metadata.
-	 *
-	 * @param bindingContext the context for annotation binding
-	 */
-	public static void bind(AnnotationBindingContext bindingContext) {
-		List<AnnotationInstance> annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.TYPE_DEF );
-		for ( AnnotationInstance typeDef : annotations ) {
-			bind( bindingContext.getMetadataImplementor(), typeDef );
-		}
-
-		annotations = bindingContext.getIndex().getAnnotations( HibernateDotNames.TYPE_DEFS );
-		for ( AnnotationInstance typeDefs : annotations ) {
-			AnnotationInstance[] typeDefAnnotations = JandexHelper.getValue(
-					typeDefs,
-					"value",
-					AnnotationInstance[].class
-			);
-			for ( AnnotationInstance typeDef : typeDefAnnotations ) {
-				bind( bindingContext.getMetadataImplementor(), typeDef );
-			}
-		}
-	}
-
-	private static void bind(MetadataImplementor metadata, AnnotationInstance typeDefAnnotation) {
-		String name = JandexHelper.getValue( typeDefAnnotation, "name", String.class );
-		String defaultForType = JandexHelper.getValue( typeDefAnnotation, "defaultForType", String.class );
-		String typeClass = JandexHelper.getValue( typeDefAnnotation, "typeClass", String.class );
-
-		boolean noName = StringHelper.isEmpty( name );
-		boolean noDefaultForType = defaultForType == null || defaultForType.equals( void.class.getName() );
-
-		if ( noName && noDefaultForType ) {
-			throw new AnnotationException(
-					"Either name or defaultForType (or both) attribute should be set in TypeDef having typeClass "
-							+ typeClass
-			);
-		}
-
-		Map<String, String> parameterMaps = new HashMap<String, String>();
-		AnnotationInstance[] parameterAnnotations = JandexHelper.getValue(
-				typeDefAnnotation,
-				"parameters",
-				AnnotationInstance[].class
-		);
-		for ( AnnotationInstance parameterAnnotation : parameterAnnotations ) {
-			parameterMaps.put(
-					JandexHelper.getValue( parameterAnnotation, "name", String.class ),
-					JandexHelper.getValue( parameterAnnotation, "value", String.class )
-			);
-		}
-
-		if ( !noName ) {
-			bind( name, typeClass, parameterMaps, metadata );
-		}
-		if ( !noDefaultForType ) {
-			bind( defaultForType, typeClass, parameterMaps, metadata );
-		}
-	}
-
-	private static void bind(
-			String name,
-			String typeClass,
-			Map<String, String> prms,
-			MetadataImplementor metadata) {
-		LOG.debugf( "Binding type definition: %s", name );
-		metadata.addTypeDefinition( new TypeDef( name, typeClass, prms ) );
-	}
-
-	private TypeDefBinder() {
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java
deleted file mode 100644
index de9a703dba..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml;
-
-import org.jboss.jandex.DotName;
-
-/**
- * Pseudo JPA Annotation name to distinguish Annotations defined in <persistence-unit-metadata>
- *
- * @author Strong Liu
- */
-public interface PseudoJpaDotNames {
-	DotName DEFAULT_ACCESS = DotName.createSimple( "default.access" );
-	DotName DEFAULT_DELIMITED_IDENTIFIERS = DotName.createSimple( "default.delimited.identifiers" );
-	DotName DEFAULT_ENTITY_LISTENERS = DotName.createSimple( "default.entity.listeners" );
-	DotName DEFAULT_POST_LOAD = DotName.createSimple( "default.entity.listener.post.load" );
-	DotName DEFAULT_POST_PERSIST = DotName.createSimple( "default.entity.listener.post.persist" );
-	DotName DEFAULT_POST_REMOVE = DotName.createSimple( "default.entity.listener.post.remove" );
-	DotName DEFAULT_POST_UPDATE = DotName.createSimple( "default.entity.listener.post.update" );
-	DotName DEFAULT_PRE_PERSIST = DotName.createSimple( "default.entity.listener.pre.persist" );
-	DotName DEFAULT_PRE_REMOVE = DotName.createSimple( "default.entity.listener.pre.remove" );
-	DotName DEFAULT_PRE_UPDATE = DotName.createSimple( "default.entity.listener.pre.update" );
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
deleted file mode 100644
index ff1530e03a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.filter;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-abstract class AbstractAnnotationFilter implements IndexedAnnotationFilter {
-	protected static final DotName[] EMPTY_DOTNAME_ARRAY = new DotName[0];
-	private Set<DotName> candidates;
-
-	private boolean match(DotName annName) {
-		if ( candidates == null ) {
-			candidates = new HashSet<DotName>();
-			candidates.addAll( Arrays.asList( targetAnnotation() ) );
-		}
-		return candidates.contains( annName );
-	}
-
-	@Override
-	public void beforePush(IndexBuilder indexBuilder, DotName classDotName, AnnotationInstance annotationInstance) {
-		DotName annName = annotationInstance.name();
-		if ( !match( annName ) ) {
-			return;
-		}
-		Map<DotName, List<AnnotationInstance>> map = indexBuilder.getIndexedAnnotations( classDotName );
-		overrideIndexedAnnotationMap( annName, annotationInstance, map );
-	}
-
-	protected void overrideIndexedAnnotationMap(DotName annName, AnnotationInstance annotationInstance, Map<DotName, List<AnnotationInstance>> map) {
-		if ( !map.containsKey( annName ) ) {
-			return;
-		}
-		List<AnnotationInstance> indexedAnnotationInstanceList = map.get( annName );
-		if ( indexedAnnotationInstanceList.isEmpty() ) {
-			return;
-		}
-		process( annName, annotationInstance, indexedAnnotationInstanceList );
-	}
-
-	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
-	}
-
-	protected DotName[] targetAnnotation() {
-		return EMPTY_DOTNAME_ARRAY;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
deleted file mode 100644
index a666ffadc2..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.filter;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.metamodel.source.annotations.xml.mocker.MockHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-class ExclusiveAnnotationFilter extends AbstractAnnotationFilter {
-
-	public static ExclusiveAnnotationFilter INSTANCE = new ExclusiveAnnotationFilter();
-	private DotName[] targetNames;
-	private List<ExclusiveGroup> exclusiveGroupList;
-
-	private ExclusiveAnnotationFilter() {
-		this.exclusiveGroupList = getExclusiveGroupList();
-		Set<DotName> names = new HashSet<DotName>();
-		for ( ExclusiveGroup group : exclusiveGroupList ) {
-			names.addAll( group.getNames() );
-		}
-		targetNames = names.toArray( new DotName[names.size()] );
-	}
-
-	private List<ExclusiveGroup> getExclusiveGroupList() {
-		if ( exclusiveGroupList == null ) {
-			exclusiveGroupList = new ArrayList<ExclusiveGroup>();
-			ExclusiveGroup group = new ExclusiveGroup();
-			group.add( ENTITY );
-			group.add( MAPPED_SUPERCLASS );
-			group.add( EMBEDDABLE );
-			group.scope = Scope.TYPE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( SECONDARY_TABLES );
-			group.add( SECONDARY_TABLE );
-			group.scope = Scope.TYPE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( PRIMARY_KEY_JOIN_COLUMNS );
-			group.add( PRIMARY_KEY_JOIN_COLUMN );
-			group.scope = Scope.ATTRIBUTE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( SQL_RESULT_SET_MAPPING );
-			group.add( SQL_RESULT_SET_MAPPINGS );
-			group.scope = Scope.TYPE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( NAMED_NATIVE_QUERY );
-			group.add( NAMED_NATIVE_QUERIES );
-			group.scope = Scope.TYPE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( NAMED_QUERY );
-			group.add( NAMED_QUERIES );
-			group.scope = Scope.TYPE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( ATTRIBUTE_OVERRIDES );
-			group.add( ATTRIBUTE_OVERRIDE );
-			group.scope = Scope.ATTRIBUTE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( ASSOCIATION_OVERRIDE );
-			group.add( ASSOCIATION_OVERRIDES );
-			group.scope = Scope.ATTRIBUTE;
-			exclusiveGroupList.add( group );
-
-			group = new ExclusiveGroup();
-			group.add( MAP_KEY_JOIN_COLUMN );
-			group.add( MAP_KEY_JOIN_COLUMNS );
-			group.scope = Scope.ATTRIBUTE;
-			exclusiveGroupList.add( group );
-
-		}
-		return exclusiveGroupList;
-	}
-
-	@Override
-	protected void overrideIndexedAnnotationMap(DotName annName, AnnotationInstance annotationInstance, Map<DotName, List<AnnotationInstance>> map) {
-		ExclusiveGroup group = getExclusiveGroup( annName );
-		if ( group == null ) {
-			return;
-		}
-		AnnotationTarget target = annotationInstance.target();
-		for ( DotName entityAnnName : group ) {
-			if ( !map.containsKey( entityAnnName ) ) {
-				continue;
-			}
-			switch ( group.scope ) {
-				case TYPE:
-					map.put( entityAnnName, Collections.<AnnotationInstance>emptyList() );
-					break;
-				case ATTRIBUTE:
-					List<AnnotationInstance> indexedAnnotationInstanceList = map.get( entityAnnName );
-					Iterator<AnnotationInstance> iter = indexedAnnotationInstanceList.iterator();
-					while ( iter.hasNext() ) {
-						AnnotationInstance ann = iter.next();
-						if ( MockHelper.targetEquals( target, ann.target() ) ) {
-							iter.remove();
-						}
-					}
-					break;
-			}
-		}
-	}
-
-	@Override
-	protected DotName[] targetAnnotation() {
-		return targetNames;
-	}
-
-	private ExclusiveGroup getExclusiveGroup(DotName annName) {
-		for ( ExclusiveGroup group : exclusiveGroupList ) {
-			if ( group.contains( annName ) ) {
-				return group;
-			}
-		}
-		return null;
-	}
-
-	enum Scope {TYPE, ATTRIBUTE}
-
-	private class ExclusiveGroup implements Iterable<DotName> {
-		public Set<DotName> getNames() {
-			return names;
-		}
-
-		private Set<DotName> names = new HashSet<DotName>();
-		Scope scope = Scope.ATTRIBUTE;
-
-		@Override
-		public Iterator iterator() {
-			return names.iterator();
-		}
-
-		boolean contains(DotName name) {
-			return names.contains( name );
-		}
-
-		void add(DotName name) {
-			names.add( name );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java
deleted file mode 100644
index 9a2aaeac52..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.filter;
-
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-public interface IndexedAnnotationFilter extends JPADotNames {
-	final IndexedAnnotationFilter[] ALL_FILTERS = new IndexedAnnotationFilter[] {
-			ExclusiveAnnotationFilter.INSTANCE,
-			NameAnnotationFilter.INSTANCE, NameTargetAnnotationFilter.INSTANCE
-	};
-
-
-	void beforePush(IndexBuilder indexBuilder, DotName classDotName, AnnotationInstance annotationInstance);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java
deleted file mode 100644
index 5635134bca..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.filter;
-
-import java.util.List;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.DotName;
-
-/**
- * if class from index has matched annotations, then remove.
- *
- * @author Strong Liu
- */
-class NameAnnotationFilter extends AbstractAnnotationFilter {
-	@Override
-	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
-		indexedAnnotationInstanceList.clear();
-	}
-
-	public static NameTargetAnnotationFilter INSTANCE = new NameTargetAnnotationFilter();
-
-	@Override
-	protected DotName[] targetAnnotation() {
-		return new DotName[] {
-				CACHEABLE,
-				TABLE,
-				EXCLUDE_DEFAULT_LISTENERS,
-				EXCLUDE_SUPERCLASS_LISTENERS,
-				ID_CLASS,
-				INHERITANCE,
-				DISCRIMINATOR_VALUE,
-				DISCRIMINATOR_COLUMN,
-				ENTITY_LISTENERS
-		};
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java
deleted file mode 100644
index 4df19be708..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.filter;
-
-import java.util.Iterator;
-import java.util.List;
-
-import org.hibernate.metamodel.source.annotations.xml.mocker.MockHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-class NameTargetAnnotationFilter extends AbstractAnnotationFilter {
-	@Override
-	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
-		AnnotationTarget target = annotationInstance.target();
-
-		for ( Iterator<AnnotationInstance> iter = indexedAnnotationInstanceList.iterator(); iter.hasNext(); ) {
-			AnnotationInstance ann = iter.next();
-			if ( MockHelper.targetEquals( target, ann.target() ) ) {
-				iter.remove();
-			}
-		}
-	}
-
-	public static NameTargetAnnotationFilter INSTANCE = new NameTargetAnnotationFilter();
-
-	@Override
-	protected DotName[] targetAnnotation() {
-		return new DotName[] {
-				LOB,
-				ID,
-				BASIC,
-				GENERATED_VALUE,
-				VERSION,
-				TRANSIENT,
-				ACCESS,
-				POST_LOAD,
-				POST_PERSIST,
-				POST_REMOVE,
-				POST_UPDATE,
-				PRE_PERSIST,
-				PRE_REMOVE,
-				PRE_UPDATE,
-				EMBEDDED_ID,
-				EMBEDDED,
-				MANY_TO_ONE,
-				MANY_TO_MANY,
-				ONE_TO_ONE,
-				ONE_TO_MANY,
-				ELEMENT_COLLECTION,
-				COLLECTION_TABLE,
-				COLUMN,
-				ENUMERATED,
-				JOIN_TABLE,
-				TEMPORAL,
-				ORDER_BY,
-				ORDER_COLUMN,
-				JOIN_COLUMN,
-				JOIN_COLUMNS,
-				MAPS_ID,
-				MAP_KEY_TEMPORAL,
-				MAP_KEY,
-				MAP_KEY_CLASS,
-				MAP_KEY_COLUMN,
-				MAP_KEY_ENUMERATED
-		};
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
deleted file mode 100644
index 425b308b01..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbBasic;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbElementCollection;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbedded;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddedId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTransient;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbVersion;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * Abstract Parser to handle {@link org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes JaxbAttributes}
- * and {@link org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddableAttributes JaxbEmbeddableAttributes}.
- *
- * It would be really helpful if these two classes can implement an interface with those abstract methods in this class.
- *
- * @author Strong Liu
- */
-abstract class AbstractAttributesBuilder {
-
-	private ClassInfo classInfo;
-	private EntityMappingsMocker.Default defaults;
-	private IndexBuilder indexBuilder;
-
-	AbstractAttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults) {
-		this.indexBuilder = indexBuilder;
-		this.classInfo = classInfo;
-		this.defaults = defaults;
-	}
-
-	final void parser() {
-		for ( JaxbId id : getId() ) {
-			new IdMocker( indexBuilder, classInfo, defaults, id ).process();
-		}
-		for ( JaxbTransient transientObj : getTransient() ) {
-			new TransientMocker( indexBuilder, classInfo, defaults, transientObj ).process();
-		}
-		for ( JaxbVersion version : getVersion() ) {
-			new VersionMocker( indexBuilder, classInfo, defaults, version ).process();
-		}
-
-		for ( JaxbBasic basic : getBasic() ) {
-			new BasicMocker( indexBuilder, classInfo, defaults, basic ).process();
-		}
-		for ( JaxbElementCollection elementCollection : getElementCollection() ) {
-			new ElementCollectionMocker(
-					indexBuilder, classInfo, defaults, elementCollection
-			).process();
-		}
-		for ( JaxbEmbedded embedded : getEmbedded() ) {
-			new EmbeddedMocker( indexBuilder, classInfo, defaults, embedded ).process();
-		}
-		for ( JaxbManyToMany manyToMany : getManyToMany() ) {
-			new ManyToManyMocker( indexBuilder, classInfo, defaults, manyToMany ).process();
-		}
-
-		for ( JaxbManyToOne manyToOne : getManyToOne() ) {
-			new ManyToOneMocker( indexBuilder, classInfo, defaults, manyToOne ).process();
-		}
-		for ( JaxbOneToMany oneToMany : getOneToMany() ) {
-			new OneToManyMocker(
-					indexBuilder, classInfo, defaults, oneToMany
-			).process();
-		}
-		for ( JaxbOneToOne oneToOne : getOneToOne() ) {
-			new OneToOneMocker( indexBuilder, classInfo, defaults, oneToOne ).process();
-		}
-		if ( getEmbeddedId() != null ) {
-			new EmbeddedIdMocker(
-					indexBuilder, classInfo, defaults, getEmbeddedId()
-			).process();
-		}
-	}
-
-	abstract List<JaxbId> getId();
-
-	abstract List<JaxbTransient> getTransient();
-
-	abstract List<JaxbVersion> getVersion();
-
-	abstract List<JaxbBasic> getBasic();
-
-	abstract List<JaxbElementCollection> getElementCollection();
-
-	abstract List<JaxbEmbedded> getEmbedded();
-
-	abstract List<JaxbManyToMany> getManyToMany();
-
-	abstract List<JaxbManyToOne> getManyToOne();
-
-	abstract List<JaxbOneToMany> getOneToMany();
-
-	abstract List<JaxbOneToOne> getOneToOne();
-
-	abstract JaxbEmbeddedId getEmbeddedId();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
deleted file mode 100644
index 8248e3e6a5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListeners;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbIdClass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostLoad;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostPersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrePersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreUpdate;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-abstract class AbstractEntityObjectMocker extends AnnotationMocker {
-	private ListenerMocker listenerParser;
-	protected AbstractAttributesBuilder attributesBuilder;
-	protected ClassInfo classInfo;
-
-	AbstractEntityObjectMocker(IndexBuilder indexBuilder, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder, defaults );
-	}
-
-	private boolean isPreProcessCalled = false;
-
-	/**
-	 * Pre-process Entity Objects to find the default {@link javax.persistence.Access} for later attributes processing.
-	 */
-	final void preProcess() {
-		applyDefaults();
-		classInfo = indexBuilder.createClassInfo( getClassName() );
-		DotName classDotName = classInfo.name();
-		if ( isMetadataComplete() ) {
-			indexBuilder.metadataComplete( classDotName );
-		}
-		parserAccessType( getAccessType(), getTarget() );
-		isPreProcessCalled = true;
-	}
-
-	final void process() {
-		if ( !isPreProcessCalled ) {
-			throw new AssertionFailure( "preProcess should be called before process" );
-		}
-		if ( getAccessType() == null ) {
-			JaxbAccessType accessType = AccessHelper.getEntityAccess( getTargetName(), indexBuilder );
-			if ( accessType == null ) {
-				accessType = getDefaults().getAccess();
-			}
-			parserAccessType( accessType, getTarget() );
-		}
-		processExtra();
-		if ( isExcludeDefaultListeners() ) {
-			create( EXCLUDE_DEFAULT_LISTENERS );
-		}
-		if ( isExcludeSuperclassListeners() ) {
-			create( EXCLUDE_SUPERCLASS_LISTENERS );
-		}
-		parserIdClass( getIdClass() );
-
-		if ( getAttributes() != null ) {
-			getAttributesBuilder().parser();
-
-		}
-		if ( getEntityListeners() != null ) {
-			getListenerParser().parser( getEntityListeners() );
-		}
-		getListenerParser().parser( getPrePersist() );
-		getListenerParser().parser( getPreRemove() );
-		getListenerParser().parser( getPreUpdate() );
-		getListenerParser().parser( getPostPersist() );
-		getListenerParser().parser( getPostUpdate() );
-		getListenerParser().parser( getPostRemove() );
-		getListenerParser().parser( getPostLoad() );
-
-		indexBuilder.finishEntityObject( getTargetName(), getDefaults() );
-	}
-
-
-	abstract protected void processExtra();
-
-	/**
-	 * give a chance to the sub-classes to override defaults configuration
-	 */
-	abstract protected void applyDefaults();
-
-	abstract protected boolean isMetadataComplete();
-
-	abstract protected boolean isExcludeDefaultListeners();
-
-	abstract protected boolean isExcludeSuperclassListeners();
-
-	abstract protected JaxbIdClass getIdClass();
-
-	abstract protected JaxbEntityListeners getEntityListeners();
-
-	abstract protected JaxbAccessType getAccessType();
-
-	abstract protected String getClassName();
-
-	abstract protected JaxbPrePersist getPrePersist();
-
-	abstract protected JaxbPreRemove getPreRemove();
-
-	abstract protected JaxbPreUpdate getPreUpdate();
-
-	abstract protected JaxbPostPersist getPostPersist();
-
-	abstract protected JaxbPostUpdate getPostUpdate();
-
-	abstract protected JaxbPostRemove getPostRemove();
-
-	abstract protected JaxbPostLoad getPostLoad();
-
-	abstract protected JaxbAttributes getAttributes();
-
-	protected ListenerMocker getListenerParser() {
-		if ( listenerParser == null ) {
-			listenerParser = new ListenerMocker( indexBuilder, classInfo );
-		}
-		return listenerParser;
-	}
-
-	protected AbstractAttributesBuilder getAttributesBuilder() {
-		if ( attributesBuilder == null ) {
-			attributesBuilder = new AttributesBuilder(
-					indexBuilder, classInfo, getAccessType(), getDefaults(), getAttributes()
-			);
-		}
-		return attributesBuilder;
-	}
-
-	protected AnnotationInstance parserIdClass(JaxbIdClass idClass) {
-		if ( idClass == null ) {
-			return null;
-		}
-		String className = MockHelper.buildSafeClassName( idClass.getClazz(), getDefaults().getPackageName() );
-		return create(
-				ID_CLASS, MockHelper.classValueArray(
-				"value", className, indexBuilder.getServiceRegistry()
-		)
-		);
-	}
-
-
-	@Override
-	protected DotName getTargetName() {
-		return classInfo.name();
-	}
-
-	@Override
-	protected AnnotationTarget getTarget() {
-		return classInfo;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java
deleted file mode 100644
index d5cfb09c4f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbUniqueConstraint;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-
-/**
- * Base class for the mock jandex annotations created from orm.xml.
- *
- * @author Strong Liu
- */
-abstract class AbstractMocker implements JPADotNames {
-	final protected IndexBuilder indexBuilder;
-
-	AbstractMocker(IndexBuilder indexBuilder) {
-		this.indexBuilder = indexBuilder;
-	}
-
-
-	abstract protected AnnotationInstance push(AnnotationInstance annotationInstance);
-
-
-	protected AnnotationInstance create(DotName name, AnnotationTarget target) {
-		return create( name, target, MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY );
-	}
-
-
-	protected AnnotationInstance create(DotName name, AnnotationTarget target, List<AnnotationValue> annotationValueList) {
-		return create( name, target, MockHelper.toArray( annotationValueList ) );
-	}
-
-	protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
-		AnnotationInstance annotationInstance = MockHelper.create( name, target, annotationValues );
-		push( annotationInstance );
-		return annotationInstance;
-
-	}
-
-
-	protected AnnotationInstance parserAccessType(JaxbAccessType accessType, AnnotationTarget target) {
-		if ( accessType == null ) {
-			return null;
-		}
-		return create( ACCESS, target, MockHelper.enumValueArray( "value", ACCESS_TYPE, accessType ) );
-	}
-
-	protected void nestedUniqueConstraintList(String name, List<JaxbUniqueConstraint> constraints, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( constraints ) ) {
-			AnnotationValue[] values = new AnnotationValue[constraints.size()];
-			for ( int i = 0; i < constraints.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserUniqueConstraint( constraints.get( i ), null );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-		}
-
-	}
-
-	//@UniqueConstraint
-	protected AnnotationInstance parserUniqueConstraint(JaxbUniqueConstraint uniqueConstraint, AnnotationTarget target) {
-		if ( uniqueConstraint == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", uniqueConstraint.getName(), annotationValueList );
-		MockHelper.stringArrayValue( "columnNames", uniqueConstraint.getColumnName(), annotationValueList );
-		return
-				create( UNIQUE_CONSTRAINT, target,
-						annotationValueList );
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java
deleted file mode 100644
index 1ba239c296..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.MappingException;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.MethodInfo;
-import org.jboss.logging.Logger;
-
-/**
- * @author Strong Liu
- */
-class AccessHelper implements JPADotNames {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			AccessHelper.class.getName()
-	);
-
-	static JaxbAccessType getAccessFromDefault(IndexBuilder indexBuilder) {
-		AnnotationInstance annotationInstance = JandexHelper.getSingleAnnotation(
-				indexBuilder.getAnnotations(),
-				PseudoJpaDotNames.DEFAULT_ACCESS
-		);
-		if ( annotationInstance == null ) {
-			return null;
-		}
-		else {
-			return JandexHelper.getEnumValue( annotationInstance, "value", JaxbAccessType.class );
-		}
-
-	}
-
-	static JaxbAccessType getAccessFromIdPosition(DotName className, IndexBuilder indexBuilder) {
-		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
-		Map<DotName, List<AnnotationInstance>> ormAnnotations = indexBuilder.getClassInfoAnnotationsMap( className );
-		JaxbAccessType accessType = getAccessFromIdPosition( ormAnnotations );
-		if ( accessType == null ) {
-			accessType = getAccessFromIdPosition( indexedAnnotations );
-		}
-		if ( accessType == null ) {
-			ClassInfo parent = indexBuilder.getClassInfo( className );
-			if ( parent == null ) {
-				parent = indexBuilder.getIndexedClassInfo( className );
-			}
-			if ( parent != null ) {
-				DotName parentClassName = parent.superName();
-				accessType = getAccessFromIdPosition( parentClassName, indexBuilder );
-			}
-
-		}
-
-		return accessType;
-	}
-
-	private static JaxbAccessType getAccessFromIdPosition(Map<DotName, List<AnnotationInstance>> annotations) {
-		if ( annotations == null || annotations.isEmpty() || !( annotations.containsKey( ID ) ) ) {
-			return null;
-		}
-		List<AnnotationInstance> idAnnotationInstances = annotations.get( ID );
-		if ( MockHelper.isNotEmpty( idAnnotationInstances ) ) {
-			return processIdAnnotations( idAnnotationInstances );
-		}
-		return null;
-	}
-
-	private static JaxbAccessType processIdAnnotations(List<AnnotationInstance> idAnnotations) {
-		JaxbAccessType accessType = null;
-		for ( AnnotationInstance annotation : idAnnotations ) {
-			AnnotationTarget tmpTarget = annotation.target();
-			if ( tmpTarget == null ) {
-				throw new AssertionFailure( "@Id has no AnnotationTarget, this is mostly a internal error." );
-			}
-			if ( accessType == null ) {
-				accessType = annotationTargetToAccessType( tmpTarget );
-			}
-			else {
-				if ( !accessType.equals( annotationTargetToAccessType( tmpTarget ) ) ) {
-					throw new MappingException( "Inconsistent placement of @Id annotation within hierarchy " );
-				}
-			}
-		}
-		return accessType;
-	}
-
-	static JaxbAccessType annotationTargetToAccessType(AnnotationTarget target) {
-		return ( target instanceof MethodInfo ) ? JaxbAccessType.PROPERTY : JaxbAccessType.FIELD;
-	}
-
-	static JaxbAccessType getEntityAccess(DotName className, IndexBuilder indexBuilder) {
-		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
-		Map<DotName, List<AnnotationInstance>> ormAnnotations = indexBuilder.getClassInfoAnnotationsMap( className );
-		JaxbAccessType accessType = getAccess( ormAnnotations );
-		if ( accessType == null ) {
-			accessType = getAccess( indexedAnnotations );
-		}
-		if ( accessType == null ) {
-			ClassInfo parent = indexBuilder.getClassInfo( className );
-			if ( parent == null ) {
-				parent = indexBuilder.getIndexedClassInfo( className );
-			}
-			if ( parent != null ) {
-				DotName parentClassName = parent.superName();
-				accessType = getEntityAccess( parentClassName, indexBuilder );
-			}
-		}
-		return accessType;
-
-	}
-
-	private static JaxbAccessType getAccess(Map<DotName, List<AnnotationInstance>> annotations) {
-		if ( annotations == null || annotations.isEmpty() || !isEntityObject( annotations ) ) {
-			return null;
-		}
-		List<AnnotationInstance> accessAnnotationInstances = annotations.get( JPADotNames.ACCESS );
-		if ( MockHelper.isNotEmpty( accessAnnotationInstances ) ) {
-			for ( AnnotationInstance annotationInstance : accessAnnotationInstances ) {
-				if ( annotationInstance.target() != null && annotationInstance.target() instanceof ClassInfo ) {
-					return JandexHelper.getEnumValue(
-							annotationInstance,
-							"value",
-							JaxbAccessType.class
-					);
-				}
-			}
-		}
-		return null;
-	}
-
-	private static boolean isEntityObject(Map<DotName, List<AnnotationInstance>> annotations) {
-		return annotations.containsKey( ENTITY ) || annotations.containsKey( MAPPED_SUPERCLASS ) || annotations
-				.containsKey( EMBEDDABLE );
-	}
-
-	/**
-	 * Get {@link javax.persistence.AccessType } from {@link javax.persistence.Access @Access} on the attribute of the given class
-	 */
-	static JaxbAccessType getAccessFromAttributeAnnotation(DotName className, String attributeName, IndexBuilder indexBuilder) {
-		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
-		if ( indexedAnnotations != null && indexedAnnotations.containsKey( ACCESS ) ) {
-			List<AnnotationInstance> annotationInstances = indexedAnnotations.get( ACCESS );
-			if ( MockHelper.isNotEmpty( annotationInstances ) ) {
-				for ( AnnotationInstance annotationInstance : annotationInstances ) {
-					AnnotationTarget indexedPropertyTarget = annotationInstance.target();
-					if ( indexedPropertyTarget == null ) {
-						continue;
-					}
-					if ( JandexHelper.getPropertyName( indexedPropertyTarget ).equals( attributeName ) ) {
-						JaxbAccessType accessType = JandexHelper.getEnumValue(
-								annotationInstance,
-								"value",
-								JaxbAccessType.class
-						);
-						/**
-						 * here we ignore @Access(FIELD) on property (getter) and @Access(PROPERTY) on field
-						 */
-						JaxbAccessType targetAccessType = annotationTargetToAccessType( indexedPropertyTarget );
-						if ( accessType.equals( targetAccessType ) ) {
-							return targetAccessType;
-						}
-						else {
-							LOG.warn(
-									String.format(
-											"%s.%s has @Access on %s, but it tries to assign the access type to %s, this is not allowed by JPA spec, and will be ignored.",
-											className,
-											attributeName,
-											targetAccessType,
-											accessType
-									)
-							);
-						}
-					}
-				}
-			}
-		}
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java
deleted file mode 100644
index 08f9ba63ea..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java
+++ /dev/null
@@ -1,557 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAssociationOverride;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributeOverride;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbCollectionTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEnumType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbJoinColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbJoinTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbLob;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOrderColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrimaryKeyJoinColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTemporalType;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-abstract class AnnotationMocker extends AbstractMocker {
-	private EntityMappingsMocker.Default defaults;
-
-	AnnotationMocker(IndexBuilder indexBuilder, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder );
-		this.defaults = defaults;
-	}
-
-	abstract void process();
-
-	protected EntityMappingsMocker.Default getDefaults() {
-		return defaults;
-	}
-
-	protected boolean isDefaultCascadePersist() {
-		return defaults.isCascadePersist()!=null && defaults.isCascadePersist();
-	}
-
-	//@JoinTable
-	protected AnnotationInstance parserJoinTable(JaxbJoinTable joinTable, AnnotationTarget target) {
-		if ( joinTable == null ) {
-			return null;
-		}
-		DefaultConfigurationHelper.INSTANCE.applyDefaults(
-				new SchemaAware.JoinTableSchemaAware( joinTable ),
-				getDefaults()
-		);
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", joinTable.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", joinTable.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", joinTable.getSchema(), annotationValueList );
-		nestedJoinColumnList( "joinColumns", joinTable.getJoinColumn(), annotationValueList );
-		nestedJoinColumnList(
-				"inverseJoinColumns", joinTable.getInverseJoinColumn(), annotationValueList
-		);
-		nestedUniqueConstraintList(
-				"uniqueConstraints", joinTable.getUniqueConstraint(), annotationValueList
-		);
-		return create( JOIN_TABLE, target, annotationValueList );
-	}
-
-	//@AssociationOverride
-	private AnnotationInstance parserAssociationOverride(JaxbAssociationOverride associationOverride, AnnotationTarget target) {
-		if ( associationOverride == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", associationOverride.getName(), annotationValueList );
-		if ( associationOverride instanceof JaxbAssociationOverrideProxy ) {
-			JaxbAssociationOverrideProxy proxy = (JaxbAssociationOverrideProxy) associationOverride;
-			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getJoinColumnsAnnotationValue() );
-			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getJoinTableAnnotationValue() );
-		}
-		else {
-			nestedJoinColumnList(
-					"joinColumns", associationOverride.getJoinColumn(), annotationValueList
-			);
-			MockHelper.nestedAnnotationValue(
-					"joinTable", parserJoinTable( associationOverride.getJoinTable(), null ), annotationValueList
-			);
-		}
-		return create( ASSOCIATION_OVERRIDE, target, annotationValueList );
-	}
-
-	private AnnotationValue[] nestedJoinColumnList(String name, List<JaxbJoinColumn> columns, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( columns ) ) {
-			AnnotationValue[] values = new AnnotationValue[columns.size()];
-			for ( int i = 0; i < columns.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserJoinColumn( columns.get( i ), null );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-			return values;
-		}
-		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
-	}
-
-	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-	//@Column
-	protected AnnotationInstance parserColumn(JaxbColumn column, AnnotationTarget target) {
-		if ( column == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", column.getName(), annotationValueList );
-		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
-		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
-		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
-		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
-		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
-		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
-		MockHelper.integerValue( "length", column.getLength(), annotationValueList );
-		MockHelper.integerValue( "precision", column.getPrecision(), annotationValueList );
-		MockHelper.integerValue( "scale", column.getScale(), annotationValueList );
-		return create( COLUMN, target, annotationValueList );
-	}
-
-	//@AttributeOverride
-	private AnnotationInstance parserAttributeOverride(JaxbAttributeOverride attributeOverride, AnnotationTarget target) {
-		if ( attributeOverride == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", attributeOverride.getName(), annotationValueList );
-		if ( attributeOverride instanceof JaxbAttributeOverrideProxy ) {
-			JaxbAttributeOverrideProxy proxy = (JaxbAttributeOverrideProxy) attributeOverride;
-			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getColumnAnnotationValue() );
-		}
-		else {
-			MockHelper.nestedAnnotationValue(
-					"column", parserColumn( attributeOverride.getColumn(), null ), annotationValueList
-			);
-		}
-		return
-				create(
-						ATTRIBUTE_OVERRIDE, target, annotationValueList
-
-				);
-	}
-
-
-	protected AnnotationInstance parserOrderColumn(JaxbOrderColumn orderColumn, AnnotationTarget target) {
-		if ( orderColumn == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", orderColumn.getName(), annotationValueList );
-		MockHelper.stringValue( "columnDefinition", orderColumn.getColumnDefinition(), annotationValueList );
-		MockHelper.booleanValue( "nullable", orderColumn.isNullable(), annotationValueList );
-		MockHelper.booleanValue( "insertable", orderColumn.isInsertable(), annotationValueList );
-		MockHelper.booleanValue( "updatable", orderColumn.isUpdatable(), annotationValueList );
-		return create( ORDER_COLUMN, target, annotationValueList );
-	}
-
-	//@JoinColumn
-	protected AnnotationInstance parserJoinColumn(JaxbJoinColumn column, AnnotationTarget target) {
-		if ( column == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", column.getName(), annotationValueList );
-		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
-		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
-		MockHelper.stringValue(
-				"referencedColumnName", column.getReferencedColumnName(), annotationValueList
-		);
-		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
-		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
-		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
-		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
-		return create( JOIN_COLUMN, target, annotationValueList );
-	}
-
-	protected AnnotationInstance parserLob(JaxbLob lob, AnnotationTarget target) {
-		if ( lob == null ) {
-			return null;
-		}
-		return create( LOB, target );
-	}
-
-	protected AnnotationInstance parserTemporalType(JaxbTemporalType temporalType, AnnotationTarget target) {
-		if ( temporalType == null ) {
-			return null;
-		}
-		return create( TEMPORAL, target, MockHelper.enumValueArray( "value", TEMPORAL_TYPE, temporalType ) );
-	}
-
-	protected AnnotationInstance parserEnumType(JaxbEnumType enumerated, AnnotationTarget target) {
-		if ( enumerated == null ) {
-			return null;
-		}
-		return create( ENUMERATED, target, MockHelper.enumValueArray( "value", ENUM_TYPE, enumerated ) );
-	}
-
-
-	protected AnnotationInstance parserPrimaryKeyJoinColumn(JaxbPrimaryKeyJoinColumn primaryKeyJoinColumn, AnnotationTarget target) {
-		if ( primaryKeyJoinColumn == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", primaryKeyJoinColumn.getName(), annotationValueList );
-		MockHelper.stringValue(
-				"referencedColumnName", primaryKeyJoinColumn.getReferencedColumnName(), annotationValueList
-		);
-		MockHelper.stringValue(
-				"columnDefinition", primaryKeyJoinColumn.getColumnDefinition(), annotationValueList
-		);
-		return
-				create(
-						PRIMARY_KEY_JOIN_COLUMN, target, annotationValueList
-
-				);
-	}
-
-	protected AnnotationInstance parserPrimaryKeyJoinColumnList(List<JaxbPrimaryKeyJoinColumn> primaryKeyJoinColumnList, AnnotationTarget target) {
-		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
-			if ( primaryKeyJoinColumnList.size() == 1 ) {
-				return parserPrimaryKeyJoinColumn( primaryKeyJoinColumnList.get( 0 ), target );
-			}
-			else {
-				return create(
-						PRIMARY_KEY_JOIN_COLUMNS,
-						target,
-						nestedPrimaryKeyJoinColumnList( "value", primaryKeyJoinColumnList, null )
-				);
-			}
-		}
-
-		return null;
-
-	}
-
-	protected AnnotationValue[] nestedPrimaryKeyJoinColumnList(String name, List<JaxbPrimaryKeyJoinColumn> constraints, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( constraints ) ) {
-			AnnotationValue[] values = new AnnotationValue[constraints.size()];
-			for ( int i = 0; i < constraints.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserPrimaryKeyJoinColumn( constraints.get( i ), null );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-			return values;
-		}
-		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
-
-	}
-
-	protected void getAnnotationInstanceByTarget(DotName annName, AnnotationTarget target, Operation operation) {
-		Map<DotName, List<AnnotationInstance>> annotatedMap = indexBuilder.getIndexedAnnotations( getTargetName() );
-		if ( !annotatedMap.containsKey( annName ) ) {
-			return;
-		}
-		List<AnnotationInstance> annotationInstanceList = annotatedMap.get( annName );
-		if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
-			for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
-				AnnotationTarget annotationTarget = annotationInstance.target();
-				if ( MockHelper.targetEquals( target, annotationTarget ) ) {
-					if ( operation.process( annotationInstance ) ) {
-						return;
-					}
-				}
-			}
-		}
-	}
-
-
-	protected AnnotationInstance parserAttributeOverrides(List<JaxbAttributeOverride> attributeOverrides, AnnotationTarget target) {
-		if ( target == null ) {
-			throw new AssertionFailure( "target can not be null" );
-		}
-		if ( attributeOverrides == null || attributeOverrides.isEmpty() ) {
-			return null;
-		}
-		Set<String> names = new HashSet<String>();
-		for ( JaxbAttributeOverride attributeOverride : attributeOverrides ) {
-			names.add( attributeOverride.getName() );
-		}
-		Operation operation = new AttributeOverrideOperation( names, attributeOverrides );
-		getAnnotationInstanceByTarget(
-				ATTRIBUTE_OVERRIDES, target, new ContainerOperation( operation )
-		);
-		getAnnotationInstanceByTarget(
-				ATTRIBUTE_OVERRIDE, target, operation
-		);
-		if ( attributeOverrides.size() == 1 ) {
-			return parserAttributeOverride( attributeOverrides.get( 0 ), target );
-		}
-		else {
-			AnnotationValue[] values = new AnnotationValue[attributeOverrides.size()];
-			for ( int i = 0; i < values.length; i++ ) {
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", parserAttributeOverride( attributeOverrides.get( i ), null )
-				);
-			}
-			return create(
-					ATTRIBUTE_OVERRIDES,
-					target,
-					new AnnotationValue[] { AnnotationValue.createArrayValue( "value", values ) }
-			);
-		}
-	}
-
-	protected AnnotationInstance parserAssociationOverrides(List<JaxbAssociationOverride> associationOverrides, AnnotationTarget target) {
-		if ( target == null ) {
-			throw new AssertionFailure( "target can not be null" );
-		}
-		if ( associationOverrides == null || associationOverrides.isEmpty() ) {
-			return null;
-		}
-
-		Set<String> names = new HashSet<String>();
-		for ( JaxbAssociationOverride associationOverride : associationOverrides ) {
-			names.add( associationOverride.getName() );
-		}
-		Operation operation = new AssociationOverrideOperation( names, associationOverrides );
-		getAnnotationInstanceByTarget(
-				ASSOCIATION_OVERRIDES, target, new ContainerOperation( operation )
-		);
-		getAnnotationInstanceByTarget(
-				ASSOCIATION_OVERRIDE, target, operation
-		);
-
-
-		if ( associationOverrides.size() == 1 ) {
-			return parserAssociationOverride( associationOverrides.get( 0 ), target );
-		}
-		else {
-			AnnotationValue[] values = new AnnotationValue[associationOverrides.size()];
-			for ( int i = 0; i < values.length; i++ ) {
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", parserAssociationOverride( associationOverrides.get( i ), null )
-				);
-			}
-			return create(
-					ASSOCIATION_OVERRIDES,
-					target,
-					new AnnotationValue[] { AnnotationValue.createArrayValue( "value", values ) }
-			);
-		}
-
-	}
-
-	protected AnnotationInstance parserCollectionTable(JaxbCollectionTable collectionTable, AnnotationTarget target) {
-		if ( collectionTable == null ) {
-			return null;
-		}
-		DefaultConfigurationHelper.INSTANCE.applyDefaults(
-				new SchemaAware.CollectionTableSchemaAware( collectionTable ),
-				getDefaults()
-		);
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", collectionTable.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", collectionTable.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", collectionTable.getSchema(), annotationValueList );
-		nestedJoinColumnList( "joinColumns", collectionTable.getJoinColumn(), annotationValueList );
-		nestedUniqueConstraintList( "uniqueConstraints", collectionTable.getUniqueConstraint(), annotationValueList );
-		return create( COLLECTION_TABLE, target, annotationValueList );
-	}
-
-
-	protected AnnotationInstance parserJoinColumnList(List<JaxbJoinColumn> joinColumnList, AnnotationTarget target) {
-		if ( MockHelper.isNotEmpty( joinColumnList ) ) {
-			if ( joinColumnList.size() == 1 ) {
-				return parserJoinColumn( joinColumnList.get( 0 ), target );
-			}
-			else {
-				AnnotationValue[] values = nestedJoinColumnList( "value", joinColumnList, null );
-				return create(
-						JOIN_COLUMNS,
-						target,
-						values
-				);
-			}
-		}
-		return null;
-
-	}
-
-	protected interface Operation {
-		boolean process(AnnotationInstance annotationInstance);
-	}
-
-	class ContainerOperation implements Operation {
-		private Operation child;
-
-		ContainerOperation(Operation child) {
-			this.child = child;
-		}
-
-		@Override
-		public boolean process(AnnotationInstance annotationInstance) {
-			AnnotationValue value = annotationInstance.value();
-			AnnotationInstance[] indexedAttributeOverridesValues = value.asNestedArray();
-			for ( AnnotationInstance ai : indexedAttributeOverridesValues ) {
-				child.process( ai );
-			}
-			return true;
-		}
-	}
-
-	class AttributeOverrideOperation implements Operation {
-		private Set<String> names;
-		private List<JaxbAttributeOverride> attributeOverrides;
-
-		AttributeOverrideOperation(Set<String> names, List<JaxbAttributeOverride> attributeOverrides) {
-			this.names = names;
-			this.attributeOverrides = attributeOverrides;
-		}
-
-		@Override
-		public boolean process(AnnotationInstance annotationInstance) {
-			String name = annotationInstance.value( "name" ).asString();
-			if ( !names.contains( name ) ) {
-				JaxbAttributeOverrideProxy attributeOverride = new JaxbAttributeOverrideProxy();
-				attributeOverride.setName( name );
-				attributeOverride.setColumnAnnotationValue( annotationInstance.value( "column" ) );
-				attributeOverrides.add( attributeOverride );
-			}
-			return false;
-		}
-	}
-
-
-	class AssociationOverrideOperation implements Operation {
-		private Set<String> names;
-		private List<JaxbAssociationOverride> associationOverrides;
-
-		AssociationOverrideOperation(Set<String> names, List<JaxbAssociationOverride> associationOverrides) {
-			this.names = names;
-			this.associationOverrides = associationOverrides;
-		}
-
-		@Override
-		public boolean process(AnnotationInstance annotationInstance) {
-			String name = annotationInstance.value( "name" ).asString();
-			if ( !names.contains( name ) ) {
-				JaxbAssociationOverrideProxy associationOverride = new JaxbAssociationOverrideProxy();
-				associationOverride.setName( name );
-				associationOverride.setJoinColumnsAnnotationValue( annotationInstance.value( "joinColumns" ) );
-				associationOverride.setJoinTableAnnotationValue( annotationInstance.value( "joinTable" ) );
-				associationOverrides.add( associationOverride );
-			}
-			return false;
-		}
-
-	}
-
-	class JaxbAssociationOverrideProxy extends JaxbAssociationOverride {
-		private AnnotationValue joinTableAnnotationValue;
-		private AnnotationValue joinColumnsAnnotationValue;
-
-		AnnotationValue getJoinColumnsAnnotationValue() {
-			return joinColumnsAnnotationValue;
-		}
-
-		void setJoinColumnsAnnotationValue(AnnotationValue joinColumnsAnnotationValue) {
-			this.joinColumnsAnnotationValue = joinColumnsAnnotationValue;
-		}
-
-		AnnotationValue getJoinTableAnnotationValue() {
-			return joinTableAnnotationValue;
-		}
-
-		void setJoinTableAnnotationValue(AnnotationValue joinTableAnnotationValue) {
-			this.joinTableAnnotationValue = joinTableAnnotationValue;
-		}
-	}
-
-	class JaxbAttributeOverrideProxy extends JaxbAttributeOverride {
-		private AnnotationValue columnAnnotationValue;
-
-		AnnotationValue getColumnAnnotationValue() {
-			return columnAnnotationValue;
-		}
-
-		void setColumnAnnotationValue(AnnotationValue columnAnnotationValue) {
-			this.columnAnnotationValue = columnAnnotationValue;
-		}
-	}
-
-	/**
-	 * Create simple AnnotationInstance with empty annotation value.
-	 * AnnotationInstance's target is get from #{getTarget}
-	 *
-	 * @param name annotation name
-	 *
-	 * @return annotationInstance which name is , target is from #{getTarget}, and has no annotation values.
-	 */
-	protected AnnotationInstance create(DotName name) {
-		return create( name, MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY );
-	}
-
-	protected AnnotationInstance create(DotName name, AnnotationValue[] annotationValues) {
-		return create( name, getTarget(), annotationValues );
-
-	}
-
-	protected AnnotationInstance create(DotName name, List<AnnotationValue> annotationValueList) {
-		return create( name, getTarget(), annotationValueList );
-	}
-
-	/**
-	 * @return DotName as the key for the ClassInfo object this mocker created that being push to.
-	 */
-	abstract protected DotName getTargetName();
-
-	/**
-	 * @return Default Annotation Target for #{create} and #{mocker} methods.
-	 */
-	abstract protected AnnotationTarget getTarget();
-
-	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
-		if ( annotationInstance != null && annotationInstance.target() != null ) {
-			indexBuilder.addAnnotationInstance( getTargetName(), annotationInstance );
-		}
-		return annotationInstance;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java
deleted file mode 100644
index d695b7ad82..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbBasic;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbElementCollection;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbedded;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddedId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTransient;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbVersion;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class AttributesBuilder extends AbstractAttributesBuilder {
-	private JaxbAttributes attributes;
-
-	AttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, JaxbAccessType accessType, EntityMappingsMocker.Default defaults, JaxbAttributes attributes) {
-		super( indexBuilder, classInfo, defaults );
-		this.attributes = attributes;
-	}
-
-	@Override
-	List<JaxbBasic> getBasic() {
-		return attributes.getBasic();
-	}
-
-	@Override
-	List<JaxbId> getId() {
-		return attributes.getId();
-	}
-
-	@Override
-	List<JaxbTransient> getTransient() {
-		return attributes.getTransient();
-	}
-
-	@Override
-	List<JaxbVersion> getVersion() {
-		return attributes.getVersion();
-	}
-
-	@Override
-	List<JaxbElementCollection> getElementCollection() {
-		return attributes.getElementCollection();
-	}
-
-	@Override
-	List<JaxbEmbedded> getEmbedded() {
-		return attributes.getEmbedded();
-	}
-
-	@Override
-	List<JaxbManyToMany> getManyToMany() {
-		return attributes.getManyToMany();
-	}
-
-	@Override
-	List<JaxbManyToOne> getManyToOne() {
-		return attributes.getManyToOne();
-	}
-
-	@Override
-	List<JaxbOneToMany> getOneToMany() {
-		return attributes.getOneToMany();
-	}
-
-	@Override
-	List<JaxbOneToOne> getOneToOne() {
-		return attributes.getOneToOne();
-	}
-
-	@Override
-	JaxbEmbeddedId getEmbeddedId() {
-		return attributes.getEmbeddedId();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java
deleted file mode 100644
index ff46073ede..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbBasic;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class BasicMocker extends PropertyMocker {
-	private JaxbBasic basic;
-
-	BasicMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbBasic basic) {
-		super( indexBuilder, classInfo, defaults );
-		this.basic = basic;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return basic.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.booleanValue( "optional", basic.isOptional(), annotationValueList );
-		MockHelper.enumValue( "fetch", FETCH_TYPE, basic.getFetch(), annotationValueList );
-		create( BASIC, annotationValueList );
-		parserColumn( basic.getColumn(), getTarget() );
-		parserEnumType( basic.getEnumerated(), getTarget() );
-		parserLob( basic.getLob(), getTarget() );
-		parserTemporalType( basic.getTemporal(), getTarget() );
-
-	}
-
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return basic.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		basic.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java
deleted file mode 100644
index 47eac0c95f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMappedSuperclass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTable;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.xml.filter.IndexedAnnotationFilter;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-import org.jboss.logging.Logger;
-
-/**
- * @author Strong Liu
- */
-class DefaultConfigurationHelper {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			DefaultConfigurationHelper.class.getName()
-	);
-	static final DefaultConfigurationHelper INSTANCE = new DefaultConfigurationHelper();
-	static final DotName[] GLOBAL_ANNOTATIONS = new DotName[] {
-			JPADotNames.SEQUENCE_GENERATOR,
-			JPADotNames.TABLE_GENERATOR,
-			JPADotNames.NAMED_QUERIES,
-			JPADotNames.NAMED_QUERY,
-			JPADotNames.NAMED_NATIVE_QUERIES,
-			JPADotNames.NAMED_NATIVE_QUERY,
-			JPADotNames.SQL_RESULT_SET_MAPPING,
-			JPADotNames.SQL_RESULT_SET_MAPPINGS
-	};
-	static final DotName[] SCHEMA_AWARE_ANNOTATIONS = new DotName[] {
-			JPADotNames.TABLE,
-			JPADotNames.JOIN_TABLE,
-			JPADotNames.COLLECTION_TABLE,
-			JPADotNames.SECONDARY_TABLE,
-			JPADotNames.SECONDARY_TABLES,
-			JPADotNames.TABLE_GENERATOR,
-			JPADotNames.SEQUENCE_GENERATOR
-	};
-	static final DotName[] ASSOCIATION_ANNOTATIONS = new DotName[] {
-			JPADotNames.ONE_TO_MANY, JPADotNames.ONE_TO_ONE, JPADotNames.MANY_TO_ONE, JPADotNames.MANY_TO_MANY
-	};
-
-	private DefaultConfigurationHelper() {
-	}
-
-	void applyDefaults(SchemaAware schemaAware, EntityMappingsMocker.Default defaults) {
-		if ( hasSchemaOrCatalogDefined( defaults ) ) {
-			if ( StringHelper.isEmpty( schemaAware.getSchema() ) ) {
-				schemaAware.setSchema( defaults.getSchema() );
-			}
-			if ( StringHelper.isEmpty( schemaAware.getCatalog() ) ) {
-				schemaAware.setCatalog( defaults.getCatalog() );
-			}
-		}
-	}
-
-	void applyDefaults(Map<DotName, List<AnnotationInstance>> annotationsMap, EntityMappingsMocker.Default defaults) {
-		if ( annotationsMap.isEmpty() || defaults == null ) {
-			return;
-		}
-		if ( hasSchemaOrCatalogDefined( defaults ) ) {
-			applyDefaultSchemaAndCatalog( annotationsMap, defaults );
-		}
-		if ( defaults.isCascadePersist()!=null && defaults.isCascadePersist() ) {
-			applyDefaultCascadePersist( annotationsMap );
-		}
-	}
-
-	void applyDefaults(JaxbMappedSuperclass mappedSuperclass, EntityMappingsMocker.Default defaults) {
-		applyDefaultsToEntityObject( new MappedSuperClassEntityObject( mappedSuperclass ), defaults );
-	}
-
-	void applyDefaults(JaxbEmbeddable embeddable, EntityMappingsMocker.Default defaults) {
-		applyDefaultsToEntityObject( new EmbeddableEntityObject( embeddable ), defaults );
-	}
-
-	void applyDefaults(JaxbEntity entity, EntityMappingsMocker.Default defaults) {
-		mockTableIfNonExist( entity, defaults );
-		applyDefaultsToEntityObject( new EntityEntityObject( entity ), defaults );
-	}
-
-	private void applyDefaultsToEntityObject(EntityObject entityObject, EntityMappingsMocker.Default defaults) {
-		if ( defaults == null ) {
-			return;
-		}
-		String className = MockHelper.buildSafeClassName( entityObject.getClazz(), defaults.getPackageName() );
-		entityObject.setClazz( className );
-		if ( entityObject.isMetadataComplete() == null ) {
-			entityObject.setMetadataComplete( defaults.isMetadataComplete() );
-		}
-		LOG.debugf( "Adding XML overriding information for %s", className );
-	}
-
-	private boolean hasSchemaOrCatalogDefined(EntityMappingsMocker.Default defaults) {
-		return ( defaults != null ) && ( StringHelper.isNotEmpty( defaults.getSchema() ) || StringHelper.isNotEmpty(
-				defaults.getCatalog()
-		) );
-	}
-
-	private void applyDefaultCascadePersist(Map<DotName, List<AnnotationInstance>> annotationsMap) {
-		for ( DotName annName : ASSOCIATION_ANNOTATIONS ) {
-			if ( annotationsMap.containsKey( annName ) ) {
-				addCascadePersistIfNotExist( annName, annotationsMap );
-			}
-		}
-	}
-
-	private void applyDefaultSchemaAndCatalog(Map<DotName, List<AnnotationInstance>> annotationsMap, EntityMappingsMocker.Default defaults) {
-		for ( DotName annName : SCHEMA_AWARE_ANNOTATIONS ) {
-			mockTableIfNonExist( annotationsMap, annName );
-			if ( annotationsMap.containsKey( annName ) ) {
-				overrideSchemaCatalogByDefault( annName, annotationsMap, defaults );
-			}
-		}
-	}
-
-	private void mockTableIfNonExist(Map<DotName, List<AnnotationInstance>> annotationsMap, DotName annName) {
-		if ( annName == JPADotNames.TABLE && !annotationsMap.containsKey( JPADotNames.TABLE ) && annotationsMap
-				.containsKey( JPADotNames.ENTITY ) ) {
-			//if an entity doesn't have a @Table, we create one here
-			AnnotationInstance entity = JandexHelper.getSingleAnnotation( annotationsMap, JPADotNames.ENTITY );
-			AnnotationInstance table = MockHelper.create(
-					JPADotNames.TABLE, entity.target(), MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY
-			);
-			List<AnnotationInstance> annotationInstanceList = new ArrayList<AnnotationInstance>( 1 );
-			annotationInstanceList.add( table );
-			annotationsMap.put( JPADotNames.TABLE, annotationInstanceList );
-		}
-	}
-
-	private void mockTableIfNonExist(JaxbEntity entity, EntityMappingsMocker.Default defaults) {
-		if ( hasSchemaOrCatalogDefined( defaults ) ) {
-			JaxbTable table = entity.getTable();
-			if ( table == null ) {
-				table = new JaxbTable();
-				entity.setTable( table );
-			}
-		}
-	}
-
-	private void addCascadePersistIfNotExist(DotName annName, Map<DotName, List<AnnotationInstance>> indexedAnnotationMap) {
-		List<AnnotationInstance> annotationInstanceList = indexedAnnotationMap.get( annName );
-		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
-			return;
-		}
-		List<AnnotationInstance> newAnnotationInstanceList = new ArrayList<AnnotationInstance>( annotationInstanceList.size() );
-		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
-			AnnotationValue cascadeValue = annotationInstance.value( "cascade" );
-			List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
-			newAnnotationValueList.addAll( annotationInstance.values() );
-			if ( cascadeValue == null ) {
-				AnnotationValue temp = AnnotationValue.createEnumValue( "", JPADotNames.CASCADE_TYPE, "PERSIST" );
-				cascadeValue = AnnotationValue.createArrayValue( "cascade", new AnnotationValue[] { temp } );
-			}
-			else {
-				newAnnotationValueList.remove( cascadeValue );
-				String[] cascadeTypes = cascadeValue.asEnumArray();
-				boolean hasPersistDefined = false;
-				for ( String type : cascadeTypes ) {
-					if ( "PERSIST".equals( type ) ) {
-						hasPersistDefined = true;
-						continue;
-					}
-				}
-				if ( hasPersistDefined ) {
-					newAnnotationInstanceList.add( annotationInstance );
-					continue;
-				}
-				String[] newCascadeTypes = new String[cascadeTypes.length + 1];
-				newCascadeTypes[0] = "PERSIST";
-				System.arraycopy( cascadeTypes, 0, newCascadeTypes, 1, cascadeTypes.length );
-				AnnotationValue[] cascades = new AnnotationValue[newCascadeTypes.length];
-				for ( int i = 0; i < newCascadeTypes.length; i++ ) {
-					cascades[i] = AnnotationValue.createEnumValue( "", JPADotNames.CASCADE_TYPE, newCascadeTypes[i] );
-				}
-				cascadeValue = AnnotationValue.createArrayValue( "cascade", cascades );
-
-			}
-			newAnnotationValueList.add( cascadeValue );
-
-			AnnotationInstance newAnnotationInstance = MockHelper.create(
-					annotationInstance.name(),
-					annotationInstance.target(),
-					MockHelper.toArray( newAnnotationValueList )
-			);
-			newAnnotationInstanceList.add( newAnnotationInstance );
-		}
-		indexedAnnotationMap.put( annName, newAnnotationInstanceList );
-	}
-
-	//@Table, @CollectionTable, @JoinTable, @SecondaryTable
-	private void overrideSchemaCatalogByDefault(DotName annName, Map<DotName, List<AnnotationInstance>> indexedAnnotationMap, EntityMappingsMocker.Default defaults) {
-		List<AnnotationInstance> annotationInstanceList = indexedAnnotationMap.get( annName );
-		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
-			return;
-		}
-		List<AnnotationInstance> newAnnotationInstanceList = new ArrayList<AnnotationInstance>( annotationInstanceList.size() );
-		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
-			if ( annName.equals( IndexedAnnotationFilter.SECONDARY_TABLES ) ) {
-				AnnotationInstance[] secondaryTableAnnotationInstanceArray = annotationInstance.value().asNestedArray();
-				AnnotationValue[] newAnnotationValueArray = new AnnotationValue[secondaryTableAnnotationInstanceArray.length];
-				for ( int i = 0; i < secondaryTableAnnotationInstanceArray.length; i++ ) {
-					newAnnotationValueArray[i] = MockHelper.nestedAnnotationValue(
-							"", overrideSchemaCatalogByDefault(
-							secondaryTableAnnotationInstanceArray[i],
-							defaults
-					)
-					);
-				}
-				AnnotationInstance secondaryTablesAnnotationInstance = MockHelper.create(
-						annName,
-						annotationInstance.target(),
-						new AnnotationValue[] {
-								AnnotationValue.createArrayValue( "value", newAnnotationValueArray )
-						}
-				);
-				newAnnotationInstanceList.add( secondaryTablesAnnotationInstance );
-			}
-			else {
-				newAnnotationInstanceList.add( overrideSchemaCatalogByDefault( annotationInstance, defaults ) );
-			}
-		}
-		indexedAnnotationMap.put( annName, newAnnotationInstanceList );
-	}
-
-	private AnnotationInstance overrideSchemaCatalogByDefault(AnnotationInstance annotationInstance, EntityMappingsMocker.Default defaults) {
-		List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
-		newAnnotationValueList.addAll( annotationInstance.values() );
-		boolean schemaDefined = false;
-		boolean catalogDefined = false;
-		if ( annotationInstance.value( "schema" ) != null ) {
-			schemaDefined = true;
-		}
-		if ( annotationInstance.value( "catalog" ) != null ) {
-			catalogDefined = true;
-		}
-		if ( schemaDefined && catalogDefined ) {
-			return annotationInstance;
-		}
-		if ( !catalogDefined && StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
-			newAnnotationValueList.add(
-					AnnotationValue.createStringValue(
-							"catalog", defaults.getCatalog()
-					)
-			);
-		}
-		if ( !schemaDefined && StringHelper.isNotEmpty( defaults.getSchema() ) ) {
-			newAnnotationValueList.add(
-					AnnotationValue.createStringValue(
-							"schema", defaults.getSchema()
-					)
-			);
-		}
-		return MockHelper.create(
-				annotationInstance.name(),
-				annotationInstance.target(),
-				MockHelper.toArray( newAnnotationValueList )
-		);
-	}
-
-	private static interface EntityObject {
-		String getClazz();
-
-		void setClazz(String className);
-
-		Boolean isMetadataComplete();
-
-		void setMetadataComplete(Boolean isMetadataComplete);
-	}
-
-	private static class EntityEntityObject implements EntityObject {
-		private JaxbEntity entity;
-
-		private EntityEntityObject(JaxbEntity entity) {
-			this.entity = entity;
-		}
-
-		@Override
-		public String getClazz() {
-			return entity.getClazz();
-		}
-
-		@Override
-		public void setClazz(String className) {
-			entity.setClazz( className );
-		}
-
-		@Override
-		public Boolean isMetadataComplete() {
-			return entity.isMetadataComplete();
-		}
-
-		@Override
-		public void setMetadataComplete(Boolean isMetadataComplete) {
-			entity.setMetadataComplete( isMetadataComplete );
-		}
-	}
-
-	private static class EmbeddableEntityObject implements EntityObject {
-		private JaxbEmbeddable entity;
-
-		private EmbeddableEntityObject(JaxbEmbeddable entity) {
-			this.entity = entity;
-		}
-
-		@Override
-		public String getClazz() {
-			return entity.getClazz();
-		}
-
-		@Override
-		public void setClazz(String className) {
-			entity.setClazz( className );
-		}
-
-		@Override
-		public Boolean isMetadataComplete() {
-			return entity.isMetadataComplete();
-		}
-
-		@Override
-		public void setMetadataComplete(Boolean isMetadataComplete) {
-			entity.setMetadataComplete( isMetadataComplete );
-		}
-	}
-
-	private static class MappedSuperClassEntityObject implements EntityObject {
-		private JaxbMappedSuperclass entity;
-
-		private MappedSuperClassEntityObject(JaxbMappedSuperclass entity) {
-			this.entity = entity;
-		}
-
-		@Override
-		public String getClazz() {
-			return entity.getClazz();
-		}
-
-		@Override
-		public void setClazz(String className) {
-			entity.setClazz( className );
-		}
-
-		@Override
-		public Boolean isMetadataComplete() {
-			return entity.isMetadataComplete();
-		}
-
-		@Override
-		public void setMetadataComplete(Boolean isMetadataComplete) {
-			entity.setMetadataComplete( isMetadataComplete );
-		}
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java
deleted file mode 100644
index e58cee635f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbElementCollection;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class ElementCollectionMocker extends PropertyMocker {
-	private JaxbElementCollection elementCollection;
-
-	ElementCollectionMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbElementCollection elementCollection) {
-		super( indexBuilder, classInfo, defaults );
-		this.elementCollection = elementCollection;
-	}
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.classValue(
-				"targetClass",
-				elementCollection.getTargetClass(),
-				annotationValueList,
-				indexBuilder.getServiceRegistry()
-		);
-		MockHelper.enumValue( "fetch", FETCH_TYPE, elementCollection.getFetch(), annotationValueList );
-		create( ELEMENT_COLLECTION, annotationValueList );
-		parserLob( elementCollection.getLob(), getTarget() );
-		parserEnumType( elementCollection.getEnumerated(), getTarget() );
-		parserColumn( elementCollection.getColumn(), getTarget() );
-		parserTemporalType( elementCollection.getTemporal(), getTarget() );
-		parserCollectionTable( elementCollection.getCollectionTable(), getTarget() );
-		parserAssociationOverrides( elementCollection.getAssociationOverride(), getTarget() );
-		parserAttributeOverrides( elementCollection.getAttributeOverride(), getTarget() );
-		if ( elementCollection.getOrderBy() != null ) {
-			create( ORDER_BY, MockHelper.stringValueArray( "value", elementCollection.getOrderBy() ) );
-		}
-		parserAttributeOverrides( elementCollection.getMapKeyAttributeOverride(), getTarget() );
-		parserMapKeyJoinColumnList( elementCollection.getMapKeyJoinColumn(), getTarget() );
-		parserMapKey( elementCollection.getMapKey(), getTarget() );
-		parserMapKeyColumn( elementCollection.getMapKeyColumn(), getTarget() );
-		parserMapKeyClass( elementCollection.getMapKeyClass(), getTarget() );
-		parserMapKeyEnumerated( elementCollection.getMapKeyEnumerated(), getTarget() );
-		parserMapKeyTemporal( elementCollection.getMapKeyTemporal(), getTarget() );
-	}
-
-	@Override
-	protected String getFieldName() {
-		return elementCollection.getName();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return elementCollection.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		elementCollection.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
deleted file mode 100644
index c3692bb7d6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.Collections;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbBasic;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbElementCollection;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddableAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbedded;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddedId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToMany;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToOne;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTransient;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbVersion;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class EmbeddableAttributesBuilder extends AbstractAttributesBuilder {
-	private JaxbEmbeddableAttributes attributes;
-
-	EmbeddableAttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, JaxbAccessType accessType, EntityMappingsMocker.Default defaults, JaxbEmbeddableAttributes embeddableAttributes) {
-		super( indexBuilder, classInfo, defaults );
-		this.attributes = embeddableAttributes;
-	}
-
-	@Override
-	List<JaxbBasic> getBasic() {
-		return attributes.getBasic();
-	}
-
-	@Override
-	List<JaxbId> getId() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	List<JaxbTransient> getTransient() {
-		return attributes.getTransient();
-	}
-
-	@Override
-	List<JaxbVersion> getVersion() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	List<JaxbElementCollection> getElementCollection() {
-		return attributes.getElementCollection();
-	}
-
-	@Override
-	List<JaxbEmbedded> getEmbedded() {
-		return attributes.getEmbedded();
-	}
-
-	@Override
-	List<JaxbManyToMany> getManyToMany() {
-		return attributes.getManyToMany();
-	}
-
-	@Override
-	List<JaxbManyToOne> getManyToOne() {
-		return attributes.getManyToOne();
-	}
-
-	@Override
-	List<JaxbOneToMany> getOneToMany() {
-		return attributes.getOneToMany();
-	}
-
-	@Override
-	List<JaxbOneToOne> getOneToOne() {
-		return attributes.getOneToOne();
-	}
-
-	@Override
-	JaxbEmbeddedId getEmbeddedId() {
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java
deleted file mode 100644
index cda89b1c59..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListeners;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbIdClass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostLoad;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostPersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrePersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreUpdate;
-
-import org.jboss.logging.Logger;
-
-/**
- * Mock <embeddable> to {@link javax.persistence.Embeddable @Embeddable}
- *
- * @author Strong Liu
- */
-class EmbeddableMocker extends AbstractEntityObjectMocker {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			EmbeddableMocker.class.getName()
-	);
-	private JaxbEmbeddable embeddable;
-
-	EmbeddableMocker(IndexBuilder indexBuilder, JaxbEmbeddable embeddable, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder, defaults );
-		this.embeddable = embeddable;
-	}
-
-	@Override
-	protected AbstractAttributesBuilder getAttributesBuilder() {
-		if ( attributesBuilder == null ) {
-			attributesBuilder = new EmbeddableAttributesBuilder(
-					indexBuilder, classInfo, getAccessType(), getDefaults(), embeddable.getAttributes()
-			);
-		}
-		return attributesBuilder;
-	}
-
-	@Override
-	protected void processExtra() {
-		create( EMBEDDABLE );
-	}
-
-	@Override
-	protected void applyDefaults() {
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( embeddable, getDefaults() );
-	}
-
-	@Override
-	protected boolean isMetadataComplete() {
-		return embeddable.isMetadataComplete() != null && embeddable.isMetadataComplete();
-	}
-
-	@Override
-	protected boolean isExcludeDefaultListeners() {
-		return false;
-	}
-
-	@Override
-	protected boolean isExcludeSuperclassListeners() {
-		return false;
-	}
-
-	@Override
-	protected JaxbIdClass getIdClass() {
-		return null;
-	}
-
-	@Override
-	protected JaxbEntityListeners getEntityListeners() {
-		return null;
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return embeddable.getAccess();
-	}
-
-	@Override
-	protected String getClassName() {
-		return embeddable.getClazz();
-	}
-
-	@Override
-	protected JaxbPrePersist getPrePersist() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPreRemove getPreRemove() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPreUpdate getPreUpdate() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPostPersist getPostPersist() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPostUpdate getPostUpdate() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPostRemove getPostRemove() {
-		return null;
-	}
-
-	@Override
-	protected JaxbPostLoad getPostLoad() {
-		return null;
-	}
-
-	@Override
-	protected JaxbAttributes getAttributes() {
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java
deleted file mode 100644
index 44f585005b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddedId;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class EmbeddedIdMocker extends PropertyMocker {
-	private JaxbEmbeddedId embeddedId;
-
-	EmbeddedIdMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbEmbeddedId embeddedId) {
-		super( indexBuilder, classInfo, defaults );
-		this.embeddedId = embeddedId;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return embeddedId.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		create( EMBEDDED_ID );
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return embeddedId.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		embeddedId.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java
deleted file mode 100644
index f75a268c41..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbedded;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class EmbeddedMocker extends PropertyMocker {
-	private JaxbEmbedded embedded;
-
-	EmbeddedMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbEmbedded embedded) {
-		super( indexBuilder, classInfo, defaults );
-		this.embedded = embedded;
-	}
-
-	@Override
-	protected void processExtra() {
-		create( EMBEDDED );
-		parserAttributeOverrides( embedded.getAttributeOverride(), getTarget() );
-		parserAssociationOverrides( embedded.getAssociationOverride(), getTarget() );
-
-	}
-
-	@Override
-	protected String getFieldName() {
-		return embedded.getName();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return embedded.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		embedded.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java
deleted file mode 100644
index 0f518669cc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMappedSuperclass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPersistenceUnitDefaults;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPersistenceUnitMetadata;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.jandex.Index;
-import org.jboss.logging.Logger;
-
-/**
- * Parse all {@link org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings} generated from orm.xml.
- *
- * @author Strong Liu
- */
-public class EntityMappingsMocker {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			EntityMappingsMocker.class.getName()
-	);
-	private final List<JaxbEntityMappings> entityMappingsList;
-	/**
-	 * Default configuration defined in Persistence Metadata Unit, one or zero per Persistence Unit.
-	 */
-	private Default globalDefaults;
-	private final IndexBuilder indexBuilder;
-	private final GlobalAnnotations globalAnnotations;
-
-	public EntityMappingsMocker(List<JaxbEntityMappings> entityMappingsList, Index index, ServiceRegistry serviceRegistry) {
-		this.entityMappingsList = entityMappingsList;
-		this.indexBuilder = new IndexBuilder( index, serviceRegistry );
-		this.globalAnnotations = new GlobalAnnotations();
-	}
-
-	/**
-	 * Create new {@link Index} with mocking JPA annotations from {@link org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings} and merge them with existing {@link Index}
-	 *
-	 * @return new {@link Index}
-	 */
-	public Index mockNewIndex() {
-		processPersistenceUnitMetadata( entityMappingsList );
-		processEntityMappings( entityMappingsList );
-		processGlobalAnnotations();
-		return indexBuilder.build( globalDefaults );
-	}
-
-	/**
-	 * processing PersistenceUnitMetadata, there should be only one PersistenceUnitMetadata in all mapping xml files.
-	 */
-	private void processPersistenceUnitMetadata(List<JaxbEntityMappings> entityMappingsList) {
-		for ( JaxbEntityMappings entityMappings : entityMappingsList ) {
-			//we have to iterate entityMappingsList first to find persistence-unit-metadata
-			JaxbPersistenceUnitMetadata pum = entityMappings.getPersistenceUnitMetadata();
-			if ( globalDefaults != null ) {
-				LOG.duplicateMetadata();
-				return;
-			}
-			if ( pum == null ) {
-				continue;
-			}
-			globalDefaults = new Default();
-			if ( pum.getXmlMappingMetadataComplete() != null ) {
-				globalDefaults.setMetadataComplete( true );
-				indexBuilder.mappingMetadataComplete();
-			}
-			JaxbPersistenceUnitDefaults pud = pum.getPersistenceUnitDefaults();
-			if ( pud == null ) {
-				return;
-			}
-			globalDefaults.setSchema( pud.getSchema() );
-			globalDefaults.setCatalog( pud.getCatalog() );
-			//globalDefaults.setAccess( pud.getAccess() );
-			globalDefaults.setCascadePersist( pud.getCascadePersist() != null );
-			new PersistenceMetadataMocker( indexBuilder, pud ).process();
-		}
-	}
-
-
-	private void processEntityMappings(List<JaxbEntityMappings> entityMappingsList) {
-		List<AbstractEntityObjectMocker> mockerList = new ArrayList<AbstractEntityObjectMocker>();
-		for ( JaxbEntityMappings entityMappings : entityMappingsList ) {
-			final Default defaults = getEntityMappingsDefaults( entityMappings );
-			globalAnnotations.collectGlobalMappings( entityMappings, defaults );
-			for ( JaxbMappedSuperclass mappedSuperclass : entityMappings.getMappedSuperclass() ) {
-				AbstractEntityObjectMocker mocker =
-						new MappedSuperclassMocker( indexBuilder, mappedSuperclass, defaults );
-				mockerList.add( mocker );
-				mocker.preProcess();
-			}
-			for ( JaxbEmbeddable embeddable : entityMappings.getEmbeddable() ) {
-				AbstractEntityObjectMocker mocker =
-						new EmbeddableMocker( indexBuilder, embeddable, defaults );
-				mockerList.add( mocker );
-				mocker.preProcess();
-			}
-			for ( JaxbEntity entity : entityMappings.getEntity() ) {
-				globalAnnotations.collectGlobalMappings( entity, defaults );
-				AbstractEntityObjectMocker mocker =
-						new EntityMocker( indexBuilder, entity, defaults );
-				mockerList.add( mocker );
-				mocker.preProcess();
-			}
-		}
-		for ( AbstractEntityObjectMocker mocker : mockerList ) {
-			mocker.process();
-		}
-	}
-
-	private void processGlobalAnnotations() {
-		if ( globalAnnotations.hasGlobalConfiguration() ) {
-			indexBuilder.collectGlobalConfigurationFromIndex( globalAnnotations );
-			new GlobalAnnotationMocker(
-					indexBuilder, globalAnnotations
-			).process();
-		}
-	}
-
-	private Default getEntityMappingsDefaults(JaxbEntityMappings entityMappings) {
-		Default entityMappingDefault = new Default();
-		entityMappingDefault.setPackageName( entityMappings.getPackage() );
-		entityMappingDefault.setSchema( entityMappings.getSchema() );
-		entityMappingDefault.setCatalog( entityMappings.getCatalog() );
-		entityMappingDefault.setAccess( entityMappings.getAccess() );
-		final Default defaults = new Default();
-		defaults.override( globalDefaults );
-		defaults.override( entityMappingDefault );
-		return defaults;
-	}
-
-
-	public static class Default implements Serializable {
-		private JaxbAccessType access;
-		private String packageName;
-		private String schema;
-		private String catalog;
-		private Boolean metadataComplete;
-		private Boolean cascadePersist;
-
-		public JaxbAccessType getAccess() {
-			return access;
-		}
-
-		void setAccess(JaxbAccessType access) {
-			this.access = access;
-		}
-
-		public String getCatalog() {
-			return catalog;
-		}
-
-		void setCatalog(String catalog) {
-			this.catalog = catalog;
-		}
-
-		public String getPackageName() {
-			return packageName;
-		}
-
-		void setPackageName(String packageName) {
-			this.packageName = packageName;
-		}
-
-		public String getSchema() {
-			return schema;
-		}
-
-		void setSchema(String schema) {
-			this.schema = schema;
-		}
-
-		public Boolean isMetadataComplete() {
-			return metadataComplete;
-		}
-
-		void setMetadataComplete(Boolean metadataComplete) {
-			this.metadataComplete = metadataComplete;
-		}
-
-		public Boolean isCascadePersist() {
-			return cascadePersist;
-		}
-
-		void setCascadePersist(Boolean cascadePersist) {
-			this.cascadePersist = cascadePersist;
-		}
-
-		void override(Default globalDefault) {
-			if ( globalDefault != null ) {
-				if ( globalDefault.getAccess() != null ) {
-					access = globalDefault.getAccess();
-				}
-				if ( globalDefault.getPackageName() != null ) {
-					packageName = globalDefault.getPackageName();
-				}
-				if ( globalDefault.getSchema() != null ) {
-					schema = globalDefault.getSchema();
-				}
-				if ( globalDefault.getCatalog() != null ) {
-					catalog = globalDefault.getCatalog();
-				}
-				if ( globalDefault.isCascadePersist() != null ) {
-					cascadePersist = globalDefault.isCascadePersist();
-				}
-				if ( globalDefault.isMetadataComplete() != null ) {
-					metadataComplete = globalDefault.isMetadataComplete();
-				}
-
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java
deleted file mode 100644
index 8ee892122e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import javax.persistence.AccessType;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbDiscriminatorColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListeners;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbIdClass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbInheritance;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostLoad;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostPersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrePersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSecondaryTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTable;
-import org.hibernate.internal.util.StringHelper;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.logging.Logger;
-
-/**
- * Mock <entity> to {@link javax.persistence.Entity @Entity}
- *
- * @author Strong Liu
- */
-class EntityMocker extends AbstractEntityObjectMocker {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			EntityMocker.class.getName()
-	);
-	private JaxbEntity entity;
-
-	EntityMocker(IndexBuilder indexBuilder, JaxbEntity entity, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder, defaults );
-		this.entity = entity;
-	}
-
-	@Override
-	protected String getClassName() {
-		return entity.getClazz();
-	}
-
-	@Override
-	protected void processExtra() {
-		//@Entity
-		create( ENTITY, MockHelper.stringValueArray( "name", entity.getName() ) );
-
-
-		if ( entity.isCacheable() != null ) {
-			//@Cacheable
-			create(
-					CACHEABLE,
-					MockHelper.booleanValueArray( "value", entity.isCacheable() )
-
-			);
-		}
-		if ( StringHelper.isNotEmpty( entity.getDiscriminatorValue() ) ) {
-			//@DiscriminatorValue
-			create(
-					DISCRIMINATOR_VALUE,
-					MockHelper.stringValueArray( "value", entity.getDiscriminatorValue() )
-
-			);
-		}
-		//@Table
-		parserTable( entity.getTable() );
-		parserInheritance( entity.getInheritance() );
-		parserDiscriminatorColumn( entity.getDiscriminatorColumn() );
-		parserAttributeOverrides( entity.getAttributeOverride(), getTarget() );
-		parserAssociationOverrides( entity.getAssociationOverride(), getTarget() );
-		parserPrimaryKeyJoinColumnList( entity.getPrimaryKeyJoinColumn(), getTarget() );
-		parserSecondaryTableList( entity.getSecondaryTable(), getTarget() );
-
-	}
-
-	//@Table  (entity only)
-	private AnnotationInstance parserTable(JaxbTable table) {
-		if ( table == null ) {
-			return null;
-		}
-		DefaultConfigurationHelper.INSTANCE.applyDefaults(
-				new SchemaAware.TableSchemaAware( table ),
-				getDefaults()
-		);
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", table.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", table.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", table.getSchema(), annotationValueList );
-		nestedUniqueConstraintList( "uniqueConstraints", table.getUniqueConstraint(), annotationValueList );
-		return create( TABLE, annotationValueList );
-	}
-
-	protected AccessType getDefaultAccess() {
-		if ( entity.getAccess() != null ) {
-			return AccessType.valueOf( entity.getAccess().value() );
-		}
-
-		return null;
-	}
-
-	protected AccessType getAccessFromIndex(DotName className) {
-		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
-		List<AnnotationInstance> accessAnnotationInstances = indexedAnnotations.get( ACCESS );
-		if ( MockHelper.isNotEmpty( accessAnnotationInstances ) ) {
-			for ( AnnotationInstance annotationInstance : accessAnnotationInstances ) {
-				if ( annotationInstance.target() != null && annotationInstance.target() instanceof ClassInfo ) {
-					ClassInfo ci = (ClassInfo) ( annotationInstance.target() );
-					if ( className.equals( ci.name() ) ) {
-						//todo does ci need to have @Entity or @MappedSuperClass ??
-						return AccessType.valueOf( annotationInstance.value().asEnum() );
-					}
-				}
-			}
-		}
-		return null;
-	}
-
-	@Override
-	protected void applyDefaults() {
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, getDefaults() );
-	}
-
-	@Override
-	protected JaxbPrePersist getPrePersist() {
-		return entity.getPrePersist();
-	}
-
-	@Override
-	protected JaxbPreRemove getPreRemove() {
-		return entity.getPreRemove();
-	}
-
-	@Override
-	protected JaxbPreUpdate getPreUpdate() {
-		return entity.getPreUpdate();
-	}
-
-	@Override
-	protected JaxbPostPersist getPostPersist() {
-		return entity.getPostPersist();
-	}
-
-	@Override
-	protected JaxbPostUpdate getPostUpdate() {
-		return entity.getPostUpdate();
-	}
-
-	@Override
-	protected JaxbPostRemove getPostRemove() {
-		return entity.getPostRemove();
-	}
-
-	@Override
-	protected JaxbPostLoad getPostLoad() {
-		return entity.getPostLoad();
-	}
-
-	@Override
-	protected JaxbAttributes getAttributes() {
-		return entity.getAttributes();
-	}
-
-	@Override
-	protected boolean isMetadataComplete() {
-		return entity.isMetadataComplete() != null && entity.isMetadataComplete();
-	}
-
-	@Override
-	protected boolean isExcludeDefaultListeners() {
-		return entity.getExcludeDefaultListeners() != null;
-	}
-
-	@Override
-	protected boolean isExcludeSuperclassListeners() {
-		return entity.getExcludeSuperclassListeners() != null;
-	}
-
-	@Override
-	protected JaxbIdClass getIdClass() {
-		return entity.getIdClass();
-	}
-
-	@Override
-	protected JaxbEntityListeners getEntityListeners() {
-		return entity.getEntityListeners();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return entity.getAccess();
-	}
-
-	//@Inheritance
-	protected AnnotationInstance parserInheritance(JaxbInheritance inheritance) {
-		if ( inheritance == null ) {
-			return null;
-		}
-		return
-				create(
-						INHERITANCE,
-						MockHelper.enumValueArray( "strategy", INHERITANCE_TYPE, inheritance.getStrategy() )
-
-				);
-	}
-
-	//@DiscriminatorColumn
-	protected AnnotationInstance parserDiscriminatorColumn(JaxbDiscriminatorColumn discriminatorColumn) {
-		if ( discriminatorColumn == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", discriminatorColumn.getName(), annotationValueList );
-		MockHelper.stringValue(
-				"columnDefinition", discriminatorColumn.getColumnDefinition(), annotationValueList
-		);
-		MockHelper.integerValue( "length", discriminatorColumn.getLength(), annotationValueList );
-		MockHelper.enumValue(
-				"discriminatorType", DISCRIMINATOR_TYPE, discriminatorColumn.getDiscriminatorType(), annotationValueList
-		);
-		return
-				create(
-						DISCRIMINATOR_COLUMN, annotationValueList
-
-				);
-
-	}
-
-	//@SecondaryTable
-	protected AnnotationInstance parserSecondaryTable(JaxbSecondaryTable secondaryTable, AnnotationTarget target) {
-		if ( secondaryTable == null ) {
-			return null;
-		}
-		DefaultConfigurationHelper.INSTANCE.applyDefaults(
-				new SchemaAware.SecondaryTableSchemaAware( secondaryTable ),
-				getDefaults()
-		);
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", secondaryTable.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", secondaryTable.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", secondaryTable.getSchema(), annotationValueList );
-		nestedPrimaryKeyJoinColumnList(
-				"pkJoinColumns", secondaryTable.getPrimaryKeyJoinColumn(), annotationValueList
-		);
-		nestedUniqueConstraintList(
-				"uniqueConstraints", secondaryTable.getUniqueConstraint(), annotationValueList
-		);
-		return
-				create(
-						SECONDARY_TABLE, target, annotationValueList
-				);
-	}
-
-
-	protected AnnotationInstance parserSecondaryTableList(List<JaxbSecondaryTable> primaryKeyJoinColumnList, AnnotationTarget target) {
-		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
-			if ( primaryKeyJoinColumnList.size() == 1 ) {
-				return parserSecondaryTable( primaryKeyJoinColumnList.get( 0 ), target );
-			}
-			else {
-				return create(
-						SECONDARY_TABLES,
-						target,
-						nestedSecondaryTableList( "value", primaryKeyJoinColumnList, null )
-				);
-			}
-		}
-		return null;
-
-	}
-
-	protected AnnotationValue[] nestedSecondaryTableList(String name, List<JaxbSecondaryTable> secondaryTableList, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( secondaryTableList ) ) {
-			AnnotationValue[] values = new AnnotationValue[secondaryTableList.size()];
-			for ( int i = 0; i < secondaryTableList.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserSecondaryTable( secondaryTableList.get( i ), null );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-			return values;
-		}
-		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
-
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java
deleted file mode 100644
index b7ed83fa68..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbColumnResult;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityResult;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbFieldResult;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbNamedNativeQuery;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbNamedQuery;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbQueryHint;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSequenceGenerator;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSqlResultSetMapping;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTableGenerator;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-
-/**
- * @author Strong Liu
- */
-class GlobalAnnotationMocker extends AbstractMocker {
-	private GlobalAnnotations globalAnnotations;
-
-	GlobalAnnotationMocker(IndexBuilder indexBuilder, GlobalAnnotations globalAnnotations) {
-		super( indexBuilder );
-		this.globalAnnotations = globalAnnotations;
-	}
-
-
-	void process() {
-		if ( !globalAnnotations.getTableGeneratorMap().isEmpty() ) {
-			for ( JaxbTableGenerator generator : globalAnnotations.getTableGeneratorMap().values() ) {
-				parserTableGenerator( generator );
-			}
-		}
-		if ( !globalAnnotations.getSequenceGeneratorMap().isEmpty() ) {
-			for ( JaxbSequenceGenerator generator : globalAnnotations.getSequenceGeneratorMap().values() ) {
-				parserSequenceGenerator( generator );
-			}
-		}
-		if ( !globalAnnotations.getNamedQueryMap().isEmpty() ) {
-			Collection<JaxbNamedQuery> namedQueries = globalAnnotations.getNamedQueryMap().values();
-			if ( namedQueries.size() > 1 ) {
-				parserNamedQueries( namedQueries );
-			}
-			else {
-				parserNamedQuery( namedQueries.iterator().next() );
-			}
-		}
-		if ( !globalAnnotations.getNamedNativeQueryMap().isEmpty() ) {
-			Collection<JaxbNamedNativeQuery> namedQueries = globalAnnotations.getNamedNativeQueryMap().values();
-			if ( namedQueries.size() > 1 ) {
-				parserNamedNativeQueries( namedQueries );
-			}
-			else {
-				parserNamedNativeQuery( namedQueries.iterator().next() );
-			}
-		}
-		if ( !globalAnnotations.getSqlResultSetMappingMap().isEmpty() ) {
-			parserSqlResultSetMappings( globalAnnotations.getSqlResultSetMappingMap().values() );
-		}
-		indexBuilder.finishGlobalConfigurationMocking( globalAnnotations );
-	}
-
-	private AnnotationInstance parserSqlResultSetMappings(Collection<JaxbSqlResultSetMapping> namedQueries) {
-		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
-		int i = 0;
-		for ( Iterator<JaxbSqlResultSetMapping> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
-			AnnotationInstance annotationInstance = parserSqlResultSetMapping( iterator.next() );
-			values[i++] = MockHelper.nestedAnnotationValue(
-					"", annotationInstance
-			);
-		}
-		return create(
-				SQL_RESULT_SET_MAPPINGS, null,
-				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
-
-		);
-	}
-
-
-	//@SqlResultSetMapping
-	private AnnotationInstance parserSqlResultSetMapping(JaxbSqlResultSetMapping mapping) {
-
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", mapping.getName(), annotationValueList );
-		nestedEntityResultList( "entities", mapping.getEntityResult(), annotationValueList );
-		nestedColumnResultList( "columns", mapping.getColumnResult(), annotationValueList );
-		return
-				create(
-						SQL_RESULT_SET_MAPPING, null, annotationValueList
-
-				);
-	}
-
-
-	//@EntityResult
-	private AnnotationInstance parserEntityResult(JaxbEntityResult result) {
-
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue(
-				"discriminatorColumn", result.getDiscriminatorColumn(), annotationValueList
-		);
-		nestedFieldResultList( "fields", result.getFieldResult(), annotationValueList );
-		MockHelper.classValue(
-				"entityClass", result.getEntityClass(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		return
-				create(
-						ENTITY_RESULT, null, annotationValueList
-
-				);
-	}
-
-	private void nestedEntityResultList(String name, List<JaxbEntityResult> entityResults, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( entityResults ) ) {
-			AnnotationValue[] values = new AnnotationValue[entityResults.size()];
-			for ( int i = 0; i < entityResults.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserEntityResult( entityResults.get( i ) );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-		}
-	}
-
-	//@ColumnResult
-	private AnnotationInstance parserColumnResult(JaxbColumnResult result) {
-		return create( COLUMN_RESULT, null, MockHelper.stringValueArray( "name", result.getName() ) );
-	}
-
-	private void nestedColumnResultList(String name, List<JaxbColumnResult> columnResults, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( columnResults ) ) {
-			AnnotationValue[] values = new AnnotationValue[columnResults.size()];
-			for ( int i = 0; i < columnResults.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserColumnResult( columnResults.get( i ) );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-		}
-	}
-
-	//@FieldResult
-	private AnnotationInstance parserFieldResult(JaxbFieldResult result) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", result.getName(), annotationValueList );
-		MockHelper.stringValue( "column", result.getColumn(), annotationValueList );
-		return create( FIELD_RESULT, null, annotationValueList );
-	}
-
-
-	private void nestedFieldResultList(String name, List<JaxbFieldResult> fieldResultList, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( fieldResultList ) ) {
-			AnnotationValue[] values = new AnnotationValue[fieldResultList.size()];
-			for ( int i = 0; i < fieldResultList.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserFieldResult( fieldResultList.get( i ) );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-		}
-	}
-
-	private AnnotationInstance parserNamedNativeQueries(Collection<JaxbNamedNativeQuery> namedQueries) {
-		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
-		int i = 0;
-		for ( Iterator<JaxbNamedNativeQuery> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
-			AnnotationInstance annotationInstance = parserNamedNativeQuery( iterator.next() );
-			values[i++] = MockHelper.nestedAnnotationValue(
-					"", annotationInstance
-			);
-		}
-		return create(
-				NAMED_NATIVE_QUERIES, null,
-				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
-
-		);
-	}
-
-	//@NamedNativeQuery
-	private AnnotationInstance parserNamedNativeQuery(JaxbNamedNativeQuery namedNativeQuery) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", namedNativeQuery.getName(), annotationValueList );
-		MockHelper.stringValue( "query", namedNativeQuery.getQuery(), annotationValueList );
-		MockHelper.stringValue(
-				"resultSetMapping", namedNativeQuery.getResultSetMapping(), annotationValueList
-		);
-		MockHelper.classValue(
-				"resultClass", namedNativeQuery.getResultClass(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		nestedQueryHintList( "hints", namedNativeQuery.getHint(), annotationValueList );
-		return
-				create(
-						NAMED_NATIVE_QUERY, null, annotationValueList
-
-				);
-	}
-
-
-	private AnnotationInstance parserNamedQueries(Collection<JaxbNamedQuery> namedQueries) {
-		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
-		int i = 0;
-		for ( Iterator<JaxbNamedQuery> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
-			AnnotationInstance annotationInstance = parserNamedQuery( iterator.next() );
-			values[i++] = MockHelper.nestedAnnotationValue(
-					"", annotationInstance
-			);
-		}
-		return create(
-				NAMED_QUERIES, null,
-				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
-
-		);
-	}
-
-
-	//@NamedQuery
-	private AnnotationInstance parserNamedQuery(JaxbNamedQuery namedQuery) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", namedQuery.getName(), annotationValueList );
-		MockHelper.stringValue( "query", namedQuery.getQuery(), annotationValueList );
-		MockHelper.enumValue( "lockMode", LOCK_MODE_TYPE, namedQuery.getLockMode(), annotationValueList );
-		nestedQueryHintList( "hints", namedQuery.getHint(), annotationValueList );
-		return create( NAMED_QUERY, null, annotationValueList );
-	}
-
-	//@QueryHint
-	private AnnotationInstance parserQueryHint(JaxbQueryHint queryHint) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", queryHint.getName(), annotationValueList );
-		MockHelper.stringValue( "value", queryHint.getValue(), annotationValueList );
-		return create( QUERY_HINT, null, annotationValueList );
-
-	}
-
-	private void nestedQueryHintList(String name, List<JaxbQueryHint> constraints, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( constraints ) ) {
-			AnnotationValue[] values = new AnnotationValue[constraints.size()];
-			for ( int i = 0; i < constraints.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserQueryHint( constraints.get( i ) );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-		}
-	}
-
-
-	//@SequenceGenerator
-	private AnnotationInstance parserSequenceGenerator(JaxbSequenceGenerator generator) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", generator.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", generator.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", generator.getSchema(), annotationValueList );
-		MockHelper.stringValue( "sequenceName", generator.getSequenceName(), annotationValueList );
-		MockHelper.integerValue( "initialValue", generator.getInitialValue(), annotationValueList );
-		MockHelper.integerValue( "allocationSize", generator.getAllocationSize(), annotationValueList );
-		return
-				create(
-						SEQUENCE_GENERATOR, null, annotationValueList
-
-				);
-	}
-
-	//@TableGenerator
-	private AnnotationInstance parserTableGenerator(JaxbTableGenerator generator) {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", generator.getName(), annotationValueList );
-		MockHelper.stringValue( "catalog", generator.getCatalog(), annotationValueList );
-		MockHelper.stringValue( "schema", generator.getSchema(), annotationValueList );
-		MockHelper.stringValue( "table", generator.getTable(), annotationValueList );
-		MockHelper.stringValue( "pkColumnName", generator.getPkColumnName(), annotationValueList );
-		MockHelper.stringValue( "valueColumnName", generator.getValueColumnName(), annotationValueList );
-		MockHelper.stringValue( "pkColumnValue", generator.getPkColumnValue(), annotationValueList );
-		MockHelper.integerValue( "initialValue", generator.getInitialValue(), annotationValueList );
-		MockHelper.integerValue( "allocationSize", generator.getAllocationSize(), annotationValueList );
-		nestedUniqueConstraintList( "uniqueConstraints", generator.getUniqueConstraint(), annotationValueList );
-		return
-				create(
-						TABLE_GENERATOR, null, annotationValueList
-
-				);
-	}
-
-	@Override
-	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
-		if ( annotationInstance != null ) {
-			return globalAnnotations.push( annotationInstance.name(), annotationInstance );
-		}
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java
deleted file mode 100644
index efba9e67e6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbNamedNativeQuery;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbNamedQuery;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSequenceGenerator;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSqlResultSetMapping;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTableGenerator;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-import org.jboss.logging.Logger;
-
-/**
- * @author Strong Liu
- */
-class GlobalAnnotations implements JPADotNames {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			GlobalAnnotations.class.getName()
-	);
-	private Map<String, JaxbSequenceGenerator> sequenceGeneratorMap = new HashMap<String, JaxbSequenceGenerator>();
-	private Map<String, JaxbTableGenerator> tableGeneratorMap = new HashMap<String, JaxbTableGenerator>();
-	private Map<String, JaxbNamedQuery> namedQueryMap = new HashMap<String, JaxbNamedQuery>();
-	private Map<String, JaxbNamedNativeQuery> namedNativeQueryMap = new HashMap<String, JaxbNamedNativeQuery>();
-	private Map<String, JaxbSqlResultSetMapping> sqlResultSetMappingMap = new HashMap<String, JaxbSqlResultSetMapping>();
-	private Map<DotName, List<AnnotationInstance>> annotationInstanceMap = new HashMap<DotName, List<AnnotationInstance>>();
-	private List<AnnotationInstance> indexedAnnotationInstanceList = new ArrayList<AnnotationInstance>();
-	//---------------------------
-	private Set<String> defaultNamedNativeQueryNames = new HashSet<String>();
-	private Set<String> defaultNamedQueryNames = new HashSet<String>();
-	private Set<String> defaultNamedGenerators = new HashSet<String>();
-	private Set<String> defaultSqlResultSetMappingNames = new HashSet<String>();
-
-	Map<DotName, List<AnnotationInstance>> getAnnotationInstanceMap() {
-		return annotationInstanceMap;
-	}
-
-	AnnotationInstance push(DotName name, AnnotationInstance annotationInstance) {
-		if ( name == null || annotationInstance == null ) {
-			return null;
-		}
-		List<AnnotationInstance> list = annotationInstanceMap.get( name );
-		if ( list == null ) {
-			list = new ArrayList<AnnotationInstance>();
-			annotationInstanceMap.put( name, list );
-		}
-		list.add( annotationInstance );
-		return annotationInstance;
-	}
-
-
-	void addIndexedAnnotationInstance(List<AnnotationInstance> annotationInstanceList) {
-		if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
-			indexedAnnotationInstanceList.addAll( annotationInstanceList );
-		}
-	}
-
-	/**
-	 * do the orm xmls define global configurations?
-	 */
-	boolean hasGlobalConfiguration() {
-		return !( namedQueryMap.isEmpty() && namedNativeQueryMap.isEmpty() && sequenceGeneratorMap.isEmpty() && tableGeneratorMap
-				.isEmpty() && sqlResultSetMappingMap.isEmpty() );
-	}
-
-	Map<String, JaxbNamedNativeQuery> getNamedNativeQueryMap() {
-		return namedNativeQueryMap;
-	}
-
-	Map<String, JaxbNamedQuery> getNamedQueryMap() {
-		return namedQueryMap;
-	}
-
-	Map<String, JaxbSequenceGenerator> getSequenceGeneratorMap() {
-		return sequenceGeneratorMap;
-	}
-
-	Map<String, JaxbSqlResultSetMapping> getSqlResultSetMappingMap() {
-		return sqlResultSetMappingMap;
-	}
-
-	Map<String, JaxbTableGenerator> getTableGeneratorMap() {
-		return tableGeneratorMap;
-	}
-
-
-	public void filterIndexedAnnotations() {
-		for ( AnnotationInstance annotationInstance : indexedAnnotationInstanceList ) {
-			pushIfNotExist( annotationInstance );
-		}
-	}
-
-	private void pushIfNotExist(AnnotationInstance annotationInstance) {
-		DotName annName = annotationInstance.name();
-		boolean isNotExist = false;
-		if ( annName.equals( SQL_RESULT_SET_MAPPINGS ) ) {
-			AnnotationInstance[] annotationInstances = annotationInstance.value().asNestedArray();
-			for ( AnnotationInstance ai : annotationInstances ) {
-				pushIfNotExist( ai );
-			}
-		}
-		else {
-			AnnotationValue value = annotationInstance.value( "name" );
-			String name = value.asString();
-			isNotExist = ( annName.equals( TABLE_GENERATOR ) && !tableGeneratorMap.containsKey( name ) ) ||
-					( annName.equals( SEQUENCE_GENERATOR ) && !sequenceGeneratorMap.containsKey( name ) ) ||
-					( annName.equals( NAMED_QUERY ) && !namedQueryMap.containsKey( name ) ) ||
-					( annName.equals( NAMED_NATIVE_QUERY ) && !namedNativeQueryMap.containsKey( name ) ) ||
-					( annName.equals( SQL_RESULT_SET_MAPPING ) && !sqlResultSetMappingMap.containsKey( name ) );
-		}
-		if ( isNotExist ) {
-			push( annName, annotationInstance );
-		}
-	}
-
-	void collectGlobalMappings(JaxbEntityMappings entityMappings, EntityMappingsMocker.Default defaults) {
-		for ( JaxbSequenceGenerator generator : entityMappings.getSequenceGenerator() ) {
-			put( generator, defaults );
-			defaultNamedGenerators.add( generator.getName() );
-		}
-		for ( JaxbTableGenerator generator : entityMappings.getTableGenerator() ) {
-			put( generator, defaults );
-			defaultNamedGenerators.add( generator.getName() );
-		}
-		for ( JaxbNamedQuery namedQuery : entityMappings.getNamedQuery() ) {
-			put( namedQuery );
-			defaultNamedQueryNames.add( namedQuery.getName() );
-		}
-		for ( JaxbNamedNativeQuery namedNativeQuery : entityMappings.getNamedNativeQuery() ) {
-			put( namedNativeQuery );
-			defaultNamedNativeQueryNames.add( namedNativeQuery.getName() );
-		}
-		for ( JaxbSqlResultSetMapping sqlResultSetMapping : entityMappings.getSqlResultSetMapping() ) {
-			put( sqlResultSetMapping );
-			defaultSqlResultSetMappingNames.add( sqlResultSetMapping.getName() );
-		}
-	}
-
-	void collectGlobalMappings(JaxbEntity entity, EntityMappingsMocker.Default defaults) {
-		for ( JaxbNamedQuery namedQuery : entity.getNamedQuery() ) {
-			if ( !defaultNamedQueryNames.contains( namedQuery.getName() ) ) {
-				put( namedQuery );
-			}
-			else {
-				LOG.warn( "Named Query [" + namedQuery.getName() + "] duplicated." );
-			}
-		}
-		for ( JaxbNamedNativeQuery namedNativeQuery : entity.getNamedNativeQuery() ) {
-			if ( !defaultNamedNativeQueryNames.contains( namedNativeQuery.getName() ) ) {
-				put( namedNativeQuery );
-			}
-			else {
-				LOG.warn( "Named native Query [" + namedNativeQuery.getName() + "] duplicated." );
-			}
-		}
-		for ( JaxbSqlResultSetMapping sqlResultSetMapping : entity.getSqlResultSetMapping() ) {
-			if ( !defaultSqlResultSetMappingNames.contains( sqlResultSetMapping.getName() ) ) {
-				put( sqlResultSetMapping );
-			}
-		}
-		JaxbSequenceGenerator sequenceGenerator = entity.getSequenceGenerator();
-		if ( sequenceGenerator != null ) {
-			if ( !defaultNamedGenerators.contains( sequenceGenerator.getName() ) ) {
-				put( sequenceGenerator, defaults );
-			}
-		}
-		JaxbTableGenerator tableGenerator = entity.getTableGenerator();
-		if ( tableGenerator != null ) {
-			if ( !defaultNamedGenerators.contains( tableGenerator.getName() ) ) {
-				put( tableGenerator, defaults );
-			}
-		}
-		JaxbAttributes attributes = entity.getAttributes();
-		if ( attributes != null ) {
-			for ( JaxbId id : attributes.getId() ) {
-				sequenceGenerator = id.getSequenceGenerator();
-				if ( sequenceGenerator != null ) {
-					put( sequenceGenerator, defaults );
-				}
-				tableGenerator = id.getTableGenerator();
-				if ( tableGenerator != null ) {
-					put( tableGenerator, defaults );
-				}
-			}
-		}
-	}
-
-	/**
-	 * Override SequenceGenerator using info definded in EntityMappings/Persistence-Metadata-Unit
-	 */
-	private static JaxbSequenceGenerator overrideGenerator(JaxbSequenceGenerator generator, EntityMappingsMocker.Default defaults) {
-		if ( StringHelper.isEmpty( generator.getSchema() ) && defaults != null ) {
-			generator.setSchema( defaults.getSchema() );
-		}
-		if ( StringHelper.isEmpty( generator.getCatalog() ) && defaults != null ) {
-			generator.setCatalog( defaults.getCatalog() );
-		}
-		return generator;
-	}
-
-	/**
-	 * Override TableGenerator using info definded in EntityMappings/Persistence-Metadata-Unit
-	 */
-	private static JaxbTableGenerator overrideGenerator(JaxbTableGenerator generator, EntityMappingsMocker.Default defaults) {
-		if ( StringHelper.isEmpty( generator.getSchema() ) && defaults != null ) {
-			generator.setSchema( defaults.getSchema() );
-		}
-		if ( StringHelper.isEmpty( generator.getCatalog() ) && defaults != null ) {
-			generator.setCatalog( defaults.getCatalog() );
-		}
-		return generator;
-	}
-
-	private void put(JaxbNamedNativeQuery query) {
-		if ( query != null ) {
-			checkQueryName( query.getName() );
-			namedNativeQueryMap.put( query.getName(), query );
-		}
-	}
-
-	private void checkQueryName(String name) {
-		if ( namedQueryMap.containsKey( name ) || namedNativeQueryMap.containsKey( name ) ) {
-			throw new MappingException( "Duplicated query mapping " + name, null );
-		}
-	}
-
-	private void put(JaxbNamedQuery query) {
-		if ( query != null ) {
-			checkQueryName( query.getName() );
-			namedQueryMap.put( query.getName(), query );
-		}
-	}
-
-	private void put(JaxbSequenceGenerator generator, EntityMappingsMocker.Default defaults) {
-		if ( generator != null ) {
-			Object old = sequenceGeneratorMap.put( generator.getName(), overrideGenerator( generator, defaults ) );
-			if ( old != null ) {
-				LOG.duplicateGeneratorName( generator.getName() );
-			}
-		}
-	}
-
-	private void put(JaxbTableGenerator generator, EntityMappingsMocker.Default defaults) {
-		if ( generator != null ) {
-			Object old = tableGeneratorMap.put( generator.getName(), overrideGenerator( generator, defaults ) );
-			if ( old != null ) {
-				LOG.duplicateGeneratorName( generator.getName() );
-			}
-		}
-	}
-
-	private void put(JaxbSqlResultSetMapping mapping) {
-		if ( mapping != null ) {
-			Object old = sqlResultSetMappingMap.put( mapping.getName(), mapping );
-			if ( old != null ) {
-				throw new MappingException( "Duplicated SQL result set mapping " +  mapping.getName(), null );
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java
deleted file mode 100644
index 150b8fa011..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbGeneratedValue;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class IdMocker extends PropertyMocker {
-	private JaxbId id;
-
-	IdMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbId id) {
-		super( indexBuilder, classInfo, defaults );
-		this.id = id;
-	}
-
-	@Override
-	protected void processExtra() {
-		create( ID );
-		parserColumn( id.getColumn(), getTarget() );
-		parserGeneratedValue( id.getGeneratedValue(), getTarget() );
-		parserTemporalType( id.getTemporal(), getTarget() );
-	}
-
-	private AnnotationInstance parserGeneratedValue(JaxbGeneratedValue generatedValue, AnnotationTarget target) {
-		if ( generatedValue == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "generator", generatedValue.getGenerator(), annotationValueList );
-		MockHelper.enumValue(
-				"strategy", GENERATION_TYPE, generatedValue.getStrategy(), annotationValueList
-		);
-
-		return create( GENERATED_VALUE, target, annotationValueList );
-	}
-
-	@Override
-	protected String getFieldName() {
-		return id.getName();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return id.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		id.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
deleted file mode 100644
index 90e19ce82f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.annotations.xml.filter.IndexedAnnotationFilter;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.jboss.logging.Logger;
-
-/**
- * @author Strong Liu
- */
-public class IndexBuilder {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			IndexBuilder.class.getName()
-	);
-	private Map<DotName, List<AnnotationInstance>> annotations;
-	private Map<DotName, List<ClassInfo>> subclasses;
-	private Map<DotName, List<ClassInfo>> implementors;
-	private Map<DotName, ClassInfo> classes;
-	private Index index;
-	private Map<DotName, Map<DotName, List<AnnotationInstance>>> classInfoAnnotationsMap;
-	private Map<DotName, Map<DotName, List<AnnotationInstance>>> indexedClassInfoAnnotationsMap;
-	private ServiceRegistry serviceRegistry;
-
-	IndexBuilder(Index index, ServiceRegistry serviceRegistry) {
-		this.index = index;
-		this.serviceRegistry = serviceRegistry;
-		this.annotations = new HashMap<DotName, List<AnnotationInstance>>();
-		this.subclasses = new HashMap<DotName, List<ClassInfo>>();
-		this.implementors = new HashMap<DotName, List<ClassInfo>>();
-		this.classes = new HashMap<DotName, ClassInfo>();
-		this.classInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
-		this.indexedClassInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
-	}
-
-	/**
-	 * Build new {@link Index} with mocked annotations from orm.xml.
-	 * This method should be only called once per {@org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder IndexBuilder} instance.
-	 *
-	 * @param globalDefaults Global defaults from <persistence-unit-metadata>, or null.
-	 *
-	 * @return Index.
-	 */
-	Index build(EntityMappingsMocker.Default globalDefaults) {
-		//merge annotations that not overrided by xml into the new Index
-		for ( ClassInfo ci : index.getKnownClasses() ) {
-			DotName name = ci.name();
-			if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
-				//this class has been overrided by orm.xml
-				continue;
-			}
-			if ( ci.annotations() != null && !ci.annotations().isEmpty() ) {
-				Map<DotName, List<AnnotationInstance>> tmp = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
-				DefaultConfigurationHelper.INSTANCE.applyDefaults( tmp, globalDefaults );
-				mergeAnnotationMap( tmp, annotations );
-				classes.put( name, ci );
-				if ( ci.superName() != null ) {
-					addSubClasses( ci.superName(), ci );
-				}
-				if ( ci.interfaces() != null && ci.interfaces().length > 0 ) {
-					addImplementors( ci.interfaces(), ci );
-				}
-			}
-		}
-		return Index.create(
-				annotations, subclasses, implementors, classes
-		);
-	}
-	Map<DotName, List<AnnotationInstance>> getAnnotations(){
-		return Collections.unmodifiableMap( annotations );
-	}
-	/**
-	 * If {@code xml-mapping-metadata-complete} is defined in PersistenceUnitMetadata, we create a new empty {@link Index} here.
-	 */
-	void mappingMetadataComplete() {
-		LOG.debug(
-				"xml-mapping-metadata-complete is specified in persistence-unit-metadata, ignore JPA annotations."
-		);
-		index = Index.create(
-				new HashMap<DotName, List<AnnotationInstance>>(),
-				new HashMap<DotName, List<ClassInfo>>(),
-				new HashMap<DotName, List<ClassInfo>>(),
-				new HashMap<DotName, ClassInfo>()
-		);
-	}
-
-	/**
-	 * @param name Entity Object dot name which is being process.
-	 */
-	void metadataComplete(DotName name) {
-		LOG.debug(
-				"metadata-complete is specified in " + name + ", ignore JPA annotations."
-		);
-		getIndexedAnnotations( name ).clear();
-	}
-
-	public Map<DotName, List<AnnotationInstance>> getIndexedAnnotations(DotName name) {
-		Map<DotName, List<AnnotationInstance>> map = indexedClassInfoAnnotationsMap.get( name );
-		if ( map == null ) {
-			ClassInfo ci = index.getClassByName( name );
-			if ( ci == null || ci.annotations() == null ) {
-				map = Collections.emptyMap();
-			}
-			else {
-				map = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
-				//here we ignore global annotations
-				for ( DotName globalAnnotationName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
-					if ( map.containsKey( globalAnnotationName ) ) {
-						map.put( globalAnnotationName, Collections.<AnnotationInstance>emptyList() );
-					}
-				}
-			}
-			indexedClassInfoAnnotationsMap.put( name, map );
-		}
-		return map;
-	}
-
-	public Map<DotName, List<AnnotationInstance>> getClassInfoAnnotationsMap(DotName name) {
-		return classInfoAnnotationsMap.get( name );
-	}
-
-	public ClassInfo getClassInfo(DotName name) {
-		return classes.get( name );
-	}
-
-	public ClassInfo getIndexedClassInfo(DotName name) {
-		return index.getClassByName( name );
-	}
-
-	void collectGlobalConfigurationFromIndex(GlobalAnnotations globalAnnotations) {
-		for ( DotName annName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
-			List<AnnotationInstance> annotationInstanceList = index.getAnnotations( annName );
-			if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
-				globalAnnotations.addIndexedAnnotationInstance( annotationInstanceList );
-			}
-		}
-		globalAnnotations.filterIndexedAnnotations();
-	}
-
-	void finishGlobalConfigurationMocking(GlobalAnnotations globalAnnotations) {
-		annotations.putAll( globalAnnotations.getAnnotationInstanceMap() );
-	}
-
-	void finishEntityObject(final DotName name, final EntityMappingsMocker.Default defaults) {
-		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( name );
-		if ( map == null ) {
-			throw new AssertionFailure( "Calling finish entity object " + name + " before create it." );
-		}
-		// annotations classes overrided by xml
-		if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
-			Map<DotName, List<AnnotationInstance>> tmp = getIndexedAnnotations( name );
-			mergeAnnotationMap( tmp, map );
-		}
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( map, defaults );
-		
-		mergeAnnotationMap( map, annotations );
-	}
-
-
-	void addAnnotationInstance(DotName targetClassName, AnnotationInstance annotationInstance) {
-		if ( annotationInstance == null ) {
-			return;
-		}
-		for ( IndexedAnnotationFilter indexedAnnotationFilter : IndexedAnnotationFilter.ALL_FILTERS ) {
-			indexedAnnotationFilter.beforePush( this, targetClassName, annotationInstance );
-		}
-		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( targetClassName );
-		if ( map == null ) {
-			throw new AssertionFailure( "Can't find " + targetClassName + " in internal cache, should call createClassInfo first" );
-		}
-
-		List<AnnotationInstance> annotationInstanceList = map.get( annotationInstance.name() );
-		if ( annotationInstanceList == null ) {
-			annotationInstanceList = new ArrayList<AnnotationInstance>();
-			map.put( annotationInstance.name(), annotationInstanceList );
-		}
-		annotationInstanceList.add( annotationInstance );
-	}
-
-	ServiceRegistry getServiceRegistry() {
-		return serviceRegistry;
-	}
-
-	ClassInfo createClassInfo(String className) {
-		if ( StringHelper.isEmpty( className ) ) {
-			throw new AssertionFailure( "Class Name used to create ClassInfo is empty." );
-		}
-		DotName classDotName = DotName.createSimple( className );
-		if ( classes.containsKey( classDotName ) ) {
-			//classInfoAnnotationsMap.put( classDotName, new HashMap<DotName, List<AnnotationInstance>>(classes.get( classDotName ).annotations()) );
-			return classes.get( classDotName );
-		}
-		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( className );
-		DotName superName = null;
-		DotName[] interfaces = null;
-		short access_flag;
-		ClassInfo annClassInfo = index.getClassByName( classDotName );
-		if ( annClassInfo != null ) {
-			superName = annClassInfo.superName();
-			interfaces = annClassInfo.interfaces();
-			access_flag = annClassInfo.flags();
-		}
-		else {
-			Class superClass = clazz.getSuperclass();
-			if ( superClass != null ) {
-				superName = DotName.createSimple( superClass.getName() );
-			}
-			Class[] classInterfaces = clazz.getInterfaces();
-			if ( classInterfaces != null && classInterfaces.length > 0 ) {
-				interfaces = new DotName[classInterfaces.length];
-				for ( int i = 0; i < classInterfaces.length; i++ ) {
-					interfaces[i] = DotName.createSimple( classInterfaces[i].getName() );
-				}
-			}
-			access_flag = (short) ( clazz.getModifiers() | 0x20 );//(modifiers | ACC_SUPER)
-		}
-		Map<DotName, List<AnnotationInstance>> map = new HashMap<DotName, List<AnnotationInstance>>();
-		classInfoAnnotationsMap.put( classDotName, map );
-		ClassInfo classInfo = ClassInfo.create(
-				classDotName, superName, access_flag, interfaces, map
-		);
-		classes.put( classDotName, classInfo );
-		addSubClasses( superName, classInfo );
-		addImplementors( interfaces, classInfo );
-		return classInfo;
-	}
-
-	private void addSubClasses(DotName superClassDotName, ClassInfo classInfo) {
-		if ( superClassDotName != null ) {
-			List<ClassInfo> classInfoList = subclasses.get( superClassDotName );
-			if ( classInfoList == null ) {
-				classInfoList = new ArrayList<ClassInfo>();
-				subclasses.put( superClassDotName, classInfoList );
-			}
-			classInfoList.add( classInfo );
-		}
-	}
-
-	private void addImplementors(DotName[] dotNames, ClassInfo classInfo) {
-		if ( dotNames != null && dotNames.length > 0 ) {
-			for ( DotName dotName : dotNames ) {
-				List<ClassInfo> classInfoList = implementors.get( dotName );
-				if ( classInfoList == null ) {
-					classInfoList = new ArrayList<ClassInfo>();
-					implementors.put( dotName, classInfoList );
-				}
-				classInfoList.add( classInfo );
-			}
-		}
-	}
-
-	//merge source into target
-	private void mergeAnnotationMap(Map<DotName, List<AnnotationInstance>> source, Map<DotName, List<AnnotationInstance>> target) {
-		if ( source != null ) {
-			for ( Map.Entry<DotName, List<AnnotationInstance>> el : source.entrySet() ) {
-				if ( el.getValue().isEmpty() ) {
-					continue;
-				}
-				DotName annotationName = el.getKey();
-				List<AnnotationInstance> value = el.getValue();
-				List<AnnotationInstance> annotationInstanceList = target.get( annotationName );
-				if ( annotationInstanceList == null ) {
-					annotationInstanceList = new ArrayList<AnnotationInstance>();
-					target.put( annotationName, annotationInstanceList );
-				}
-				annotationInstanceList.addAll( value );
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java
deleted file mode 100644
index 58f946667a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.MappingException;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListener;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListeners;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostLoad;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostPersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrePersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreUpdate;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * {@link javax.persistence.EntityListeners @EntityListeners} mocker
- *
- * @author Strong Liu
- */
-class ListenerMocker extends AbstractMocker {
-	private final ClassInfo classInfo;
-
-	ListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
-		super( indexBuilder );
-		this.classInfo = classInfo;
-	}
-
-	AnnotationInstance parser(JaxbEntityListeners entityListeners) {
-		if ( entityListeners.getEntityListener().isEmpty() ) {
-			throw new MappingException( "No child element of <entity-listener> found under <entity-listeners>." );
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>( 1 );
-		List<String> clazzNameList = new ArrayList<String>( entityListeners.getEntityListener().size() );
-		for ( JaxbEntityListener listener : entityListeners.getEntityListener() ) {
-			MockHelper.addToCollectionIfNotNull( clazzNameList, listener.getClazz() );
-			parserEntityListener( listener );
-		}
-		MockHelper.classArrayValue( "value", clazzNameList, annotationValueList, indexBuilder.getServiceRegistry() );
-		return create( ENTITY_LISTENERS, classInfo, annotationValueList );
-	}
-
-	private void parserEntityListener(JaxbEntityListener listener) {
-		String clazz = listener.getClazz();
-		ClassInfo tempClassInfo = indexBuilder.createClassInfo( clazz );
-		ListenerMocker mocker = createListenerMocker( indexBuilder, tempClassInfo );
-		mocker.parser( listener.getPostLoad() );
-		mocker.parser( listener.getPostPersist() );
-		mocker.parser( listener.getPostRemove() );
-		mocker.parser( listener.getPostUpdate() );
-		mocker.parser( listener.getPrePersist() );
-		mocker.parser( listener.getPreRemove() );
-		mocker.parser( listener.getPreUpdate() );
-		indexBuilder.finishEntityObject( tempClassInfo.name(), null );
-	}
-
-	protected ListenerMocker createListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
-		return new ListenerMocker( indexBuilder, classInfo );
-	}
-
-	//@PrePersist
-	AnnotationInstance parser(JaxbPrePersist callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( PRE_PERSIST, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PreRemove
-	AnnotationInstance parser(JaxbPreRemove callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( PRE_REMOVE, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PreUpdate
-	AnnotationInstance parser(JaxbPreUpdate callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( PRE_UPDATE, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PostPersist
-	AnnotationInstance parser(JaxbPostPersist callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( POST_PERSIST, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PostUpdate
-	AnnotationInstance parser(JaxbPostUpdate callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( POST_UPDATE, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PostRemove
-	AnnotationInstance parser(JaxbPostRemove callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( POST_REMOVE, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	//@PostLoad
-	AnnotationInstance parser(JaxbPostLoad callback) {
-		if ( callback == null ) {
-			return null;
-		}
-		return create( POST_LOAD, getListenerTarget( callback.getMethodName() ) );
-	}
-
-	private AnnotationTarget getListenerTarget(String methodName) {
-		return MockHelper.getTarget(
-				indexBuilder.getServiceRegistry(), classInfo, methodName, MockHelper.TargetType.METHOD
-		);
-	}
-
-	@Override
-	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
-		if ( annotationInstance != null && annotationInstance.target() != null ) {
-			indexBuilder.addAnnotationInstance( classInfo.name(), annotationInstance );
-		}
-		return annotationInstance;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java
deleted file mode 100644
index 985892209a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToMany;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class ManyToManyMocker extends PropertyMocker {
-	private JaxbManyToMany manyToMany;
-
-	ManyToManyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbManyToMany manyToMany) {
-		super( indexBuilder, classInfo, defaults );
-		this.manyToMany = manyToMany;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return manyToMany.getName();
-	}
-
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.classValue(
-				"targetEntity", manyToMany.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		MockHelper.enumValue( "fetch", FETCH_TYPE, manyToMany.getFetch(), annotationValueList );
-		MockHelper.stringValue( "mappedBy", manyToMany.getMappedBy(), annotationValueList );
-		MockHelper.cascadeValue( "cascade", manyToMany.getCascade(), isDefaultCascadePersist(), annotationValueList );
-		create( MANY_TO_MANY, annotationValueList );
-		parserMapKeyClass( manyToMany.getMapKeyClass(), getTarget() );
-		parserMapKeyTemporal( manyToMany.getMapKeyTemporal(), getTarget() );
-		parserMapKeyEnumerated( manyToMany.getMapKeyEnumerated(), getTarget() );
-		parserMapKey( manyToMany.getMapKey(), getTarget() );
-		parserAttributeOverrides( manyToMany.getMapKeyAttributeOverride(), getTarget() );
-		parserMapKeyJoinColumnList( manyToMany.getMapKeyJoinColumn(), getTarget() );
-		parserOrderColumn( manyToMany.getOrderColumn(), getTarget() );
-		parserJoinTable( manyToMany.getJoinTable(), getTarget() );
-		if ( manyToMany.getOrderBy() != null ) {
-			create( ORDER_BY, MockHelper.stringValueArray( "value", manyToMany.getOrderBy() ) );
-		}
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return manyToMany.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		manyToMany.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java
deleted file mode 100644
index c3dca779a1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToOne;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class ManyToOneMocker extends PropertyMocker {
-	private JaxbManyToOne manyToOne;
-
-	ManyToOneMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbManyToOne manyToOne) {
-		super( indexBuilder, classInfo, defaults );
-		this.manyToOne = manyToOne;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return manyToOne.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.classValue(
-				"targetEntity", manyToOne.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		MockHelper.enumValue( "fetch", FETCH_TYPE, manyToOne.getFetch(), annotationValueList );
-		MockHelper.booleanValue( "optional", manyToOne.isOptional(), annotationValueList );
-		MockHelper.cascadeValue( "cascade", manyToOne.getCascade(), isDefaultCascadePersist(), annotationValueList );
-		create( MANY_TO_ONE, annotationValueList );
-		parserJoinColumnList( manyToOne.getJoinColumn(), getTarget() );
-		parserJoinTable( manyToOne.getJoinTable(), getTarget() );
-		if ( manyToOne.getMapsId() != null ) {
-			create( MAPS_ID, MockHelper.stringValueArray( "value", manyToOne.getMapsId() ) );
-		}
-		if ( manyToOne.isId() != null && manyToOne.isId() ) {
-			create( ID );
-		}
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return manyToOne.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		manyToOne.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java
deleted file mode 100644
index 018a1b53c0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityListeners;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbIdClass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMappedSuperclass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostLoad;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostPersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPostUpdate;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPrePersist;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreRemove;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPreUpdate;
-
-import org.jboss.logging.Logger;
-
-/**
- * Mock <mapped-superclass> to {@link javax.persistence.MappedSuperclass @MappedSuperClass}
- *
- * @author Strong Liu
- */
-class MappedSuperclassMocker extends AbstractEntityObjectMocker {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			MappedSuperclassMocker.class.getName()
-	);
-	private JaxbMappedSuperclass mappedSuperclass;
-
-	MappedSuperclassMocker(IndexBuilder indexBuilder, JaxbMappedSuperclass mappedSuperclass, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder, defaults );
-		this.mappedSuperclass = mappedSuperclass;
-	}
-
-	@Override
-	protected void applyDefaults() {
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( mappedSuperclass, getDefaults() );
-	}
-
-	@Override
-	protected void processExtra() {
-		create( MAPPED_SUPERCLASS );
-	}
-
-	@Override
-	protected JaxbAttributes getAttributes() {
-		return mappedSuperclass.getAttributes();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return mappedSuperclass.getAccess();
-	}
-
-	@Override
-	protected boolean isMetadataComplete() {
-		return mappedSuperclass.isMetadataComplete() != null && mappedSuperclass.isMetadataComplete();
-	}
-
-	@Override
-	protected boolean isExcludeDefaultListeners() {
-		return mappedSuperclass.getExcludeDefaultListeners() != null;
-	}
-
-	@Override
-	protected boolean isExcludeSuperclassListeners() {
-		return mappedSuperclass.getExcludeSuperclassListeners() != null;
-	}
-
-	@Override
-	protected JaxbIdClass getIdClass() {
-		return mappedSuperclass.getIdClass();
-	}
-
-	@Override
-	protected JaxbEntityListeners getEntityListeners() {
-		return mappedSuperclass.getEntityListeners();
-	}
-
-	protected String getClassName() {
-		return mappedSuperclass.getClazz();
-	}
-
-	@Override
-	protected JaxbPrePersist getPrePersist() {
-		return mappedSuperclass.getPrePersist();
-	}
-
-	@Override
-	protected JaxbPreRemove getPreRemove() {
-		return mappedSuperclass.getPreRemove();
-	}
-
-	@Override
-	protected JaxbPreUpdate getPreUpdate() {
-		return mappedSuperclass.getPreUpdate();
-	}
-
-	@Override
-	protected JaxbPostPersist getPostPersist() {
-		return mappedSuperclass.getPostPersist();
-	}
-
-	@Override
-	protected JaxbPostUpdate getPostUpdate() {
-		return mappedSuperclass.getPostUpdate();
-	}
-
-	@Override
-	protected JaxbPostRemove getPostRemove() {
-		return mappedSuperclass.getPostRemove();
-	}
-
-	@Override
-	protected JaxbPostLoad getPostLoad() {
-		return mappedSuperclass.getPostLoad();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
deleted file mode 100644
index a2e71bdcc7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
+++ /dev/null
@@ -1,471 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.beans.Introspector;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.hibernate.HibernateException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbCascadeType;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.FieldInfo;
-import org.jboss.jandex.MethodInfo;
-import org.jboss.jandex.Type;
-
-/**
- * @author Strong Liu
- */
-public class MockHelper {
-
-	static final AnnotationValue[] EMPTY_ANNOTATION_VALUE_ARRAY = new AnnotationValue[0];
-	static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-	/**
-	 * util method for String Array attribute Annotation
-	 *
-	 * @param name
-	 * @param values
-	 * @param annotationValueList
-	 */
-	static void stringArrayValue(String name, List<String> values, List<AnnotationValue> annotationValueList) {
-		if ( isNotEmpty( values ) ) {
-			AnnotationValue[] annotationValues = new AnnotationValue[values.size()];
-			for ( int j = 0; j < values.size(); j++ ) {
-				annotationValues[j] = stringValue( "", values.get( j ) );
-			}
-			annotationValueList.add(
-					AnnotationValue.createArrayValue(
-							name, annotationValues
-					)
-			);
-		}
-	}
-
-	/**
-	 * util method for single string attribute Annotation only
-	 */
-	static AnnotationValue[] stringValueArray(String name, String value) {
-		return nullSafe( stringValue( name, value ) );
-	}
-
-	private static AnnotationValue stringValue(String name, String value) {
-		if ( StringHelper.isNotEmpty( value ) ) {
-			return AnnotationValue.createStringValue( name, value );
-		}
-		return null;
-	}
-
-	static void stringValue(String name, String value, List<AnnotationValue> annotationValueList) {
-		addToCollectionIfNotNull( annotationValueList, stringValue( name, value ) );
-	}
-
-	private static AnnotationValue integerValue(String name, Integer value) {
-		if ( value == null ) {
-			return null;
-		}
-		return AnnotationValue.createIntegerValue( name, value );
-	}
-
-	static void integerValue(String name, Integer value, List<AnnotationValue> annotationValueList) {
-		addToCollectionIfNotNull( annotationValueList, integerValue( name, value ) );
-	}
-
-	static AnnotationValue[] booleanValueArray(String name, Boolean value) {
-		return nullSafe( booleanValue( name, value ) );
-	}
-
-	static void booleanValue(String name, Boolean value, List<AnnotationValue> annotationValueList) {
-		addToCollectionIfNotNull( annotationValueList, booleanValue( name, value ) );
-	}
-
-	private static AnnotationValue booleanValue(String name, Boolean value) {
-		if ( value == null ) {
-			return null;
-		}
-		return AnnotationValue.createBooleanValue( name, value );
-	}
-
-	private static AnnotationValue classValue(String name, String className, ServiceRegistry serviceRegistry) {
-		if ( StringHelper.isNotEmpty( className ) ) {
-			return AnnotationValue.createClassValue( name, getType( className, serviceRegistry ) );
-		}
-		return null;
-	}
-
-
-	static void classValue(String name, String className, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
-		addToCollectionIfNotNull( list, classValue( name, className, serviceRegistry ) );
-	}
-
-	static AnnotationValue[] classValueArray(String name, String className, ServiceRegistry serviceRegistry) {
-		return nullSafe( classValue( name, className, serviceRegistry ) );
-	}
-
-	static AnnotationValue nestedAnnotationValue(String name, AnnotationInstance value) {
-		if ( value == null ) {
-			return null;
-		}
-		return AnnotationValue.createNestedAnnotationValue(
-				name, value
-		);
-	}
-
-	static void nestedAnnotationValue(String name, AnnotationInstance value, List<AnnotationValue> list) {
-		addToCollectionIfNotNull( list, nestedAnnotationValue( name, value ) );
-	}
-
-	private static AnnotationValue[] nullSafe(AnnotationValue value) {
-		return value == null ? EMPTY_ANNOTATION_VALUE_ARRAY : new AnnotationValue[] {
-				value
-		};
-	}
-
-	static void classArrayValue(String name, List<String> classNameList, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
-		if ( isNotEmpty( classNameList ) ) {
-
-			List<AnnotationValue> clazzValueList = new ArrayList<AnnotationValue>( classNameList.size() );
-			for ( String clazz : classNameList ) {
-				addToCollectionIfNotNull( clazzValueList, classValue( "", clazz, serviceRegistry ) );
-			}
-
-			list.add(
-					AnnotationValue.createArrayValue(
-							name, toArray( clazzValueList )
-					)
-			);
-		}
-	}
-
-	public static AnnotationValue[] toArray(List<AnnotationValue> list) {
-		AnnotationValue[] values = EMPTY_ANNOTATION_VALUE_ARRAY;
-		if ( isNotEmpty( list ) ) {
-			values = list.toArray( new AnnotationValue[list.size()] );
-		}
-		return values;
-	}
-
-	private static AnnotationValue enumValue(String name, DotName typeName, Enum value) {
-		if ( value != null && StringHelper.isNotEmpty( value.toString() ) ) {
-			return AnnotationValue.createEnumValue( name, typeName, value.toString() );
-		}
-		return null;
-	}
-
-	static void cascadeValue(String name, JaxbCascadeType cascadeType, boolean isCascadePersistDefault, List<AnnotationValue> annotationValueList) {
-		List<Enum> enumList = new ArrayList<Enum>();
-		if ( isCascadePersistDefault ) {
-			enumList.add( javax.persistence.CascadeType.PERSIST );
-		}
-		if ( cascadeType != null ) {
-			if ( cascadeType.getCascadeAll() != null ) {
-				enumList.add( javax.persistence.CascadeType.ALL );
-			}
-			if ( cascadeType.getCascadePersist() != null && !isCascadePersistDefault ) {
-				enumList.add( javax.persistence.CascadeType.PERSIST );
-			}
-			if ( cascadeType.getCascadeMerge() != null ) {
-				enumList.add( javax.persistence.CascadeType.MERGE );
-			}
-			if ( cascadeType.getCascadeRemove() != null ) {
-				enumList.add( javax.persistence.CascadeType.REMOVE );
-			}
-			if ( cascadeType.getCascadeRefresh() != null ) {
-				enumList.add( javax.persistence.CascadeType.REFRESH );
-			}
-			if ( cascadeType.getCascadeDetach() != null ) {
-				enumList.add( javax.persistence.CascadeType.DETACH );
-			}
-		}
-		if ( !enumList.isEmpty() ) {
-			MockHelper.enumArrayValue( name, JPADotNames.CASCADE_TYPE, enumList, annotationValueList );
-		}
-	}
-
-	static void enumArrayValue(String name, DotName typeName, List<Enum> valueList, List<AnnotationValue> list) {
-		if ( isNotEmpty( valueList ) ) {
-
-			List<AnnotationValue> enumValueList = new ArrayList<AnnotationValue>( valueList.size() );
-			for ( Enum e : valueList ) {
-				addToCollectionIfNotNull( enumValueList, enumValue( "", typeName, e ) );
-			}
-			list.add(
-					AnnotationValue.createArrayValue(
-							name, toArray( enumValueList )
-					)
-			);
-		}
-	}
-
-	static void enumValue(String name, DotName typeName, Enum value, List<AnnotationValue> list) {
-		addToCollectionIfNotNull( list, enumValue( name, typeName, value ) );
-	}
-
-	static AnnotationValue[] enumValueArray(String name, DotName typeName, Enum value) {
-		return nullSafe( enumValue( name, typeName, value ) );
-	}
-
-	public static void addToCollectionIfNotNull(Collection collection, Object value) {
-		if ( value != null && collection != null ) {
-			collection.add( value );
-		}
-	}
-
-
-	/**
-	 * @param t1 can't be null
-	 * @param t2 can't be null
-	 */
-	public static boolean targetEquals(AnnotationTarget t1, AnnotationTarget t2) {
-		if ( t1 == t2 ) {
-			return true;
-		}
-		if ( t1 != null && t2 != null ) {
-
-			if ( t1.getClass() == t2.getClass() ) {
-				if ( t1.getClass() == ClassInfo.class ) {
-					return ( (ClassInfo) t1 ).name().equals( ( (ClassInfo) t2 ).name() );
-				}
-				else if ( t1.getClass() == MethodInfo.class ) {
-					return ( (MethodInfo) t1 ).name().equals( ( (MethodInfo) t2 ).name() );
-				}
-				else {
-					return ( (FieldInfo) t1 ).name().equals( ( (FieldInfo) t2 ).name() );
-				}
-			}
-		}
-		return false;
-	}
-
-	public static boolean isNotEmpty(Collection collection) {
-		return collection != null && !collection.isEmpty();
-	}
-
-
-	static AnnotationInstance create(DotName name, AnnotationTarget target, List<AnnotationValue> annotationValueList) {
-		return create(
-				name, target, toArray( annotationValueList )
-		);
-
-	}
-
-	static String buildSafeClassName(String className, String defaultPackageName) {
-		if ( className.indexOf( '.' ) < 0 && StringHelper.isNotEmpty( defaultPackageName ) ) {
-			className = StringHelper.qualify( defaultPackageName, className );
-		}
-		return className;
-	}
-
-	static AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] values) {
-		if ( values == null || values.length == 0 ) {
-			values = EMPTY_ANNOTATION_VALUE_ARRAY;
-		}
-		return AnnotationInstance.create( name, target, addMockMark( values ) );
-	}
-
-	private static AnnotationValue[] addMockMark(AnnotationValue[] values) {
-		AnnotationValue[] newValues = new AnnotationValue[values.length + 1];
-		System.arraycopy( values, 0, newValues, 0, values.length );
-		newValues[values.length] = booleanValue( "isMocked", true );
-		return newValues;
-	}
-
-
-	private static MethodInfo getMethodInfo(ClassInfo classInfo, Method method) {
-		Class returnTypeClass = method.getReturnType();
-		short access_flags = (short) method.getModifiers();
-		return MethodInfo.create(
-				classInfo,
-				method.getName(),
-				getTypes( method.getParameterTypes() ),
-				getType( returnTypeClass ),
-				access_flags
-		);
-	}
-
-	enum TargetType {METHOD, FIELD, PROPERTY}
-
-	static AnnotationTarget getTarget(ServiceRegistry serviceRegistry, ClassInfo classInfo, String name, TargetType type) {
-		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( classInfo.toString() );
-		switch ( type ) {
-			case FIELD:
-				Field field = getField( clazz, name );
-				if ( field == null ) {
-					throw new HibernateException(
-							"Unable to load field "
-									+ name
-									+ " of class " + clazz.getName()
-					);
-				}
-
-				return FieldInfo.create(
-						classInfo, name, getType( field.getType() ), (short) ( field.getModifiers() )
-				);
-			case METHOD:
-				Method method = getMethod( clazz, name );
-				if ( method == null ) {
-					throw new HibernateException(
-							"Unable to load method "
-									+ name
-									+ " of class " + clazz.getName()
-					);
-				}
-				return getMethodInfo( classInfo, method );
-			case PROPERTY:
-				method = getterMethod( clazz, name );
-				if ( method == null ) {
-					throw new HibernateException(
-							"Unable to load property "
-									+ name
-									+ " of class " + clazz.getName()
-					);
-				}
-				return getMethodInfo( classInfo, method );
-
-		}
-		throw new HibernateException( "" );
-	}
-
-	//copied from org.hibernate.internal.util.ReflectHelper
-	private static Method getterMethod(Class theClass, String propertyName) {
-		Method[] methods = theClass.getDeclaredMethods();
-		Method.setAccessible( methods, true );
-		for ( Method method : methods ) {
-			// if the method has parameters, skip it
-			if ( method.getParameterTypes().length != 0 ) {
-				continue;
-			}
-			// if the method is a "bridge", skip it
-			if ( method.isBridge() ) {
-				continue;
-			}
-
-			final String methodName = method.getName();
-
-			// try "get"
-			if ( methodName.startsWith( "get" ) || methodName.startsWith( "has" ) ) {
-				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
-				String testOldMethod = methodName.substring( 3 );
-				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
-					return method;
-				}
-			}
-
-			// if not "get", then try "is"
-			if ( methodName.startsWith( "is" ) ) {
-				String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) );
-				String testOldMethod = methodName.substring( 2 );
-				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
-					return method;
-				}
-			}
-		}
-
-		return null;
-	}
-
-
-	private static Method getMethod(Class theClass, String propertyName) {
-		Method[] methods = theClass.getDeclaredMethods();
-		Method.setAccessible( methods, true );
-		for ( Method method : methods ) {
-			// if the method has parameters, skip it
-			if ( method.getParameterTypes().length != 0 ) {
-				continue;
-			}
-			// if the method is a "bridge", skip it
-			if ( method.isBridge() ) {
-				continue;
-			}
-
-			final String methodName = method.getName();
-			if ( methodName.equals( propertyName ) ) {
-				return method;
-			}
-		}
-
-		return null;
-	}
-
-	private static Field getField(Class clazz, String name) {
-		Field[] fields = clazz.getDeclaredFields();
-		Field.setAccessible( fields, true );
-		for ( Field field : fields ) {
-			if ( field.getName().equals( name ) ) {
-				return field;
-			}
-		}
-		return null;
-	}
-
-	private static Type[] getTypes(Class[] classes) {
-		if ( classes == null || classes.length == 0 ) {
-			return EMPTY_TYPE_ARRAY;
-		}
-		Type[] types = new Type[classes.length];
-		for ( int i = 0; i < types.length; i++ ) {
-			types[i] = getType( classes[i] );
-		}
-		return types;
-	}
-
-
-	private static Type getType(String className, ServiceRegistry serviceRegistry) {
-		return getType( serviceRegistry.getService( ClassLoaderService.class ).classForName( className ) );
-	}
-
-	private static Type getType(Class clazz) {
-		return Type.create( DotName.createSimple( clazz.getName() ), getTypeKind( clazz ) );
-	}
-
-	private static Type.Kind getTypeKind(Class clazz) {
-		Type.Kind kind;
-		if ( clazz == Void.TYPE ) {
-			kind = Type.Kind.VOID;
-		}
-		else if ( clazz.isPrimitive() ) {
-			kind = Type.Kind.PRIMITIVE;
-		}
-		else if ( clazz.isArray() ) {
-			kind = Type.Kind.ARRAY;
-		}
-		else {
-			kind = Type.Kind.CLASS;
-		}
-		return kind;
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java
deleted file mode 100644
index ee957d0d56..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToMany;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class OneToManyMocker extends PropertyMocker {
-	private JaxbOneToMany oneToMany;
-
-	OneToManyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbOneToMany oneToMany) {
-		super( indexBuilder, classInfo, defaults );
-		this.oneToMany = oneToMany;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return oneToMany.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.classValue(
-				"targetEntity", oneToMany.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		MockHelper.enumValue( "fetch", FETCH_TYPE, oneToMany.getFetch(), annotationValueList );
-		MockHelper.stringValue( "mappedBy", oneToMany.getMappedBy(), annotationValueList );
-		MockHelper.booleanValue( "orphanRemoval", oneToMany.isOrphanRemoval(), annotationValueList );
-		MockHelper.cascadeValue( "cascade", oneToMany.getCascade(), isDefaultCascadePersist(), annotationValueList );
-		create( ONE_TO_MANY, getTarget(), annotationValueList );
-		parserAttributeOverrides( oneToMany.getMapKeyAttributeOverride(), getTarget() );
-		parserMapKeyJoinColumnList( oneToMany.getMapKeyJoinColumn(), getTarget() );
-		parserMapKey( oneToMany.getMapKey(), getTarget() );
-		parserMapKeyColumn( oneToMany.getMapKeyColumn(), getTarget() );
-		parserMapKeyClass( oneToMany.getMapKeyClass(), getTarget() );
-		parserMapKeyTemporal( oneToMany.getMapKeyTemporal(), getTarget() );
-		parserMapKeyEnumerated( oneToMany.getMapKeyEnumerated(), getTarget() );
-		parserJoinColumnList( oneToMany.getJoinColumn(), getTarget() );
-		parserOrderColumn( oneToMany.getOrderColumn(), getTarget() );
-		parserJoinTable( oneToMany.getJoinTable(), getTarget() );
-		if ( oneToMany.getOrderBy() != null ) {
-			create( ORDER_BY, getTarget(), MockHelper.stringValueArray( "value", oneToMany.getOrderBy() ) );
-		}
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return oneToMany.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		oneToMany.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java
deleted file mode 100644
index f99f4eaa70..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToOne;
-
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class OneToOneMocker extends PropertyMocker {
-	private JaxbOneToOne oneToOne;
-
-	OneToOneMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbOneToOne oneToOne) {
-		super( indexBuilder, classInfo, defaults );
-		this.oneToOne = oneToOne;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return oneToOne.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.classValue(
-				"targetEntity", oneToOne.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
-		);
-		MockHelper.enumValue( "fetch", FETCH_TYPE, oneToOne.getFetch(), annotationValueList );
-		MockHelper.booleanValue( "optional", oneToOne.isOptional(), annotationValueList );
-		MockHelper.booleanValue( "orphanRemoval", oneToOne.isOrphanRemoval(), annotationValueList );
-		MockHelper.stringValue( "mappedBy", oneToOne.getMappedBy(), annotationValueList );
-		MockHelper.cascadeValue( "cascade", oneToOne.getCascade(), isDefaultCascadePersist(), annotationValueList );
-		create( ONE_TO_ONE, annotationValueList );
-
-		parserPrimaryKeyJoinColumnList( oneToOne.getPrimaryKeyJoinColumn(), getTarget() );
-		parserJoinColumnList( oneToOne.getJoinColumn(), getTarget() );
-		parserJoinTable( oneToOne.getJoinTable(), getTarget() );
-		if ( oneToOne.getMapsId() != null ) {
-			create( MAPS_ID, MockHelper.stringValueArray( "value", oneToOne.getMapsId() ) );
-		}
-		if ( oneToOne.isId() != null && oneToOne.isId() ) {
-			create( ID );
-		}
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return oneToOne.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		oneToOne.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java
deleted file mode 100644
index 02820e5c98..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbPersistenceUnitDefaults;
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-class PersistenceMetadataMocker extends AbstractMocker {
-	private final JaxbPersistenceUnitDefaults persistenceUnitDefaults;
-	private final GlobalAnnotations globalAnnotations = new GlobalAnnotations();
-	/**
-	 * Map JPA Annotations name to Pseudo JPA Annotations name.
-	 */
-	private final static Map<DotName, DotName> nameMapper = new HashMap<DotName, DotName>();
-
-	static {
-		nameMapper.put( ACCESS, PseudoJpaDotNames.DEFAULT_ACCESS );
-		nameMapper.put( ENTITY_LISTENERS, PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
-		nameMapper.put( POST_LOAD, PseudoJpaDotNames.DEFAULT_POST_LOAD );
-		nameMapper.put( POST_REMOVE, PseudoJpaDotNames.DEFAULT_POST_REMOVE );
-		nameMapper.put( POST_UPDATE, PseudoJpaDotNames.DEFAULT_POST_UPDATE );
-		nameMapper.put( POST_PERSIST, PseudoJpaDotNames.DEFAULT_POST_PERSIST );
-		nameMapper.put( PRE_REMOVE, PseudoJpaDotNames.DEFAULT_PRE_REMOVE );
-		nameMapper.put( PRE_UPDATE, PseudoJpaDotNames.DEFAULT_PRE_UPDATE );
-		nameMapper.put( PRE_PERSIST, PseudoJpaDotNames.DEFAULT_PRE_PERSIST );
-		nameMapper.put(
-				PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS,
-				PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS
-		);
-	}
-
-	PersistenceMetadataMocker(IndexBuilder indexBuilder, JaxbPersistenceUnitDefaults persistenceUnitDefaults) {
-		super( indexBuilder );
-		this.persistenceUnitDefaults = persistenceUnitDefaults;
-	}
-
-	/**
-	 * Mock global configurations defined in <persistence-unit-metadata> with pseudo JPA annotation name.
-	 * NOTE: These mocked annotations do not have {@link AnnotationTarget target}.
-	 */
-	final void process() {
-		parserAccessType( persistenceUnitDefaults.getAccess(), null );
-		if ( persistenceUnitDefaults.getDelimitedIdentifiers() != null ) {
-			create( PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS, null );
-		}
-		if ( persistenceUnitDefaults.getEntityListeners() != null ) {
-			new DefaultListenerMocker( indexBuilder, null ).parser( persistenceUnitDefaults.getEntityListeners() );
-		}
-		indexBuilder.finishGlobalConfigurationMocking( globalAnnotations );
-	}
-
-	@Override
-	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
-		if ( annotationInstance != null ) {
-			return globalAnnotations.push( annotationInstance.name(), annotationInstance );
-		}
-		return null;
-	}
-
-	@Override
-	protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
-		DotName defaultName = nameMapper.get( name );
-		if ( defaultName == null ) {
-			return null;
-		}
-		return super.create( defaultName, target, annotationValues );
-
-	}
-
-	private class DefaultListenerMocker extends ListenerMocker {
-		DefaultListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
-			super( indexBuilder, classInfo );
-		}
-
-		@Override
-		protected AnnotationInstance push(AnnotationInstance annotationInstance) {
-			return PersistenceMetadataMocker.this.push( annotationInstance );
-		}
-
-		@Override
-		protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
-			return PersistenceMetadataMocker.this.create( name, target, annotationValues );
-		}
-
-		@Override
-		protected ListenerMocker createListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
-			return new DefaultListenerMocker( indexBuilder, classInfo );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java
deleted file mode 100644
index dccdbbeb11..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.HibernateException;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEnumType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMapKey;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMapKeyClass;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMapKeyColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbMapKeyJoinColumn;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTemporalType;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationTarget;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-
-/**
- * @author Strong Liu
- */
-abstract class PropertyMocker extends AnnotationMocker {
-	protected ClassInfo classInfo;
-	private AnnotationTarget target;
-
-	PropertyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults) {
-		super( indexBuilder, defaults );
-		this.classInfo = classInfo;
-	}
-
-	protected abstract void processExtra();
-
-	protected abstract String getFieldName();
-
-	protected abstract JaxbAccessType getAccessType();
-
-	protected abstract void setAccessType(JaxbAccessType accessType);
-
-	@Override
-	protected DotName getTargetName() {
-		return classInfo.name();
-	}
-
-	protected void resolveTarget() {
-		//attribute in orm.xml has access sub-element
-		JaxbAccessType accessType = getAccessType();
-		if ( accessType == null ) {
-			//attribute in the entity class has @Access
-			accessType = AccessHelper.getAccessFromAttributeAnnotation( getTargetName(), getFieldName(), indexBuilder );
-			if ( accessType == null ) {
-				accessType = AccessHelper.getEntityAccess( getTargetName(), indexBuilder );
-			}
-			if ( accessType == null ) {
-				accessType = AccessHelper.getAccessFromIdPosition( getTargetName(), indexBuilder );
-			}
-			if (accessType == null ) {
-				//this should only for determin @Id position
-				accessType = AccessHelper.getAccessFromDefault( indexBuilder );
-			}
-			if ( accessType == null ) {
-				accessType = JaxbAccessType.PROPERTY;
-
-			}
-			setAccessType( accessType );
-		}
-
-	}
-
-	@Override
-	protected AnnotationTarget getTarget() {
-		if ( target == null ) {
-			target = getTargetFromAttributeAccessType( getAccessType() );
-		}
-		return target;
-	}
-
-	protected AnnotationTarget getTargetFromAttributeAccessType(JaxbAccessType accessType) {
-		if ( accessType == null ) {
-			throw new IllegalArgumentException( "access type can't be null." );
-		}
-		switch ( accessType ) {
-			case FIELD:
-				return MockHelper.getTarget(
-						indexBuilder.getServiceRegistry(),
-						classInfo,
-						getFieldName(),
-						MockHelper.TargetType.FIELD
-				);
-			case PROPERTY:
-				return MockHelper.getTarget(
-						indexBuilder.getServiceRegistry(),
-						classInfo,
-						getFieldName(),
-						MockHelper.TargetType.PROPERTY
-				);
-			default:
-				throw new HibernateException( "can't determin access type [" + accessType + "]" );
-		}
-	}
-
-
-	@Override
-	final void process() {
-		resolveTarget();
-		processExtra();
-	}
-
-	protected AnnotationInstance parserMapKeyColumn(JaxbMapKeyColumn mapKeyColumn, AnnotationTarget target) {
-		if ( mapKeyColumn == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", mapKeyColumn.getName(), annotationValueList );
-		MockHelper.stringValue( "columnDefinition", mapKeyColumn.getColumnDefinition(), annotationValueList );
-		MockHelper.stringValue( "table", mapKeyColumn.getTable(), annotationValueList );
-		MockHelper.booleanValue( "nullable", mapKeyColumn.isNullable(), annotationValueList );
-		MockHelper.booleanValue( "insertable", mapKeyColumn.isInsertable(), annotationValueList );
-		MockHelper.booleanValue( "updatable", mapKeyColumn.isUpdatable(), annotationValueList );
-		MockHelper.booleanValue( "unique", mapKeyColumn.isUnique(), annotationValueList );
-		MockHelper.integerValue( "length", mapKeyColumn.getLength(), annotationValueList );
-		MockHelper.integerValue( "precision", mapKeyColumn.getPrecision(), annotationValueList );
-		MockHelper.integerValue( "scale", mapKeyColumn.getScale(), annotationValueList );
-		return create( MAP_KEY_COLUMN, target, annotationValueList );
-	}
-
-	protected AnnotationInstance parserMapKeyClass(JaxbMapKeyClass mapKeyClass, AnnotationTarget target) {
-		if ( mapKeyClass == null ) {
-			return null;
-		}
-		return create(
-				MAP_KEY_CLASS, target, MockHelper.classValueArray(
-				"value", mapKeyClass.getClazz(), indexBuilder.getServiceRegistry()
-		)
-		);
-	}
-
-	protected AnnotationInstance parserMapKeyTemporal(JaxbTemporalType temporalType, AnnotationTarget target) {
-		if ( temporalType == null ) {
-			return null;
-		}
-		return create(
-				MAP_KEY_TEMPORAL, target,
-				MockHelper.enumValueArray( "value", TEMPORAL_TYPE, temporalType )
-		);
-	}
-
-	protected AnnotationInstance parserMapKeyEnumerated(JaxbEnumType enumType, AnnotationTarget target) {
-		if ( enumType == null ) {
-			return null;
-		}
-		return create(
-				MAP_KEY_ENUMERATED, target,
-				MockHelper.enumValueArray( "value", ENUM_TYPE, enumType )
-		);
-	}
-
-	protected AnnotationInstance parserMapKey(JaxbMapKey mapKey, AnnotationTarget target) {
-		if ( mapKey == null ) {
-			return null;
-		}
-		return create( MAP_KEY, target, MockHelper.stringValueArray( "name", mapKey.getName() ) );
-	}
-
-	private AnnotationValue[] nestedMapKeyJoinColumnList(String name, List<JaxbMapKeyJoinColumn> columns, List<AnnotationValue> annotationValueList) {
-		if ( MockHelper.isNotEmpty( columns ) ) {
-			AnnotationValue[] values = new AnnotationValue[columns.size()];
-			for ( int i = 0; i < columns.size(); i++ ) {
-				AnnotationInstance annotationInstance = parserMapKeyJoinColumn( columns.get( i ), null );
-				values[i] = MockHelper.nestedAnnotationValue(
-						"", annotationInstance
-				);
-			}
-			MockHelper.addToCollectionIfNotNull(
-					annotationValueList, AnnotationValue.createArrayValue( name, values )
-			);
-			return values;
-		}
-		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
-	}
-
-	protected AnnotationInstance parserMapKeyJoinColumnList(List<JaxbMapKeyJoinColumn> joinColumnList, AnnotationTarget target) {
-		if ( MockHelper.isNotEmpty( joinColumnList ) ) {
-			if ( joinColumnList.size() == 1 ) {
-				return parserMapKeyJoinColumn( joinColumnList.get( 0 ), target );
-			}
-			else {
-				AnnotationValue[] values = nestedMapKeyJoinColumnList( "value", joinColumnList, null );
-				return create(
-						MAP_KEY_JOIN_COLUMNS,
-						target,
-						values
-				);
-			}
-		}
-		return null;
-
-	}
-
-	//@MapKeyJoinColumn
-	private AnnotationInstance parserMapKeyJoinColumn(JaxbMapKeyJoinColumn column, AnnotationTarget target) {
-		if ( column == null ) {
-			return null;
-		}
-		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
-		MockHelper.stringValue( "name", column.getName(), annotationValueList );
-		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
-		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
-		MockHelper.stringValue(
-				"referencedColumnName", column.getReferencedColumnName(), annotationValueList
-		);
-		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
-		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
-		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
-		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
-		return create( MAP_KEY_JOIN_COLUMN, target, annotationValueList );
-	}
-
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java
deleted file mode 100644
index d276b6d1aa..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbCollectionTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbJoinTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbSecondaryTable;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTable;
-
-/**
- * @author Strong Liu
- */
-interface SchemaAware {
-	String getSchema();
-
-	void setSchema(String schema);
-
-	String getCatalog();
-
-	void setCatalog(String catalog);
-
-	static class SecondaryTableSchemaAware implements SchemaAware {
-		private JaxbSecondaryTable table;
-
-		SecondaryTableSchemaAware(JaxbSecondaryTable table) {
-			this.table = table;
-		}
-
-		@Override
-		public String getCatalog() {
-			return table.getCatalog();
-		}
-
-		@Override
-		public String getSchema() {
-			return table.getSchema();
-		}
-
-		@Override
-		public void setSchema(String schema) {
-			table.setSchema( schema );
-		}
-
-		@Override
-		public void setCatalog(String catalog) {
-			table.setCatalog( catalog );
-		}
-	}
-
-	static class TableSchemaAware implements SchemaAware {
-		private JaxbTable table;
-
-		public TableSchemaAware(JaxbTable table) {
-			this.table = table;
-		}
-
-		@Override
-		public String getCatalog() {
-			return table.getCatalog();
-		}
-
-		@Override
-		public String getSchema() {
-			return table.getSchema();
-		}
-
-		@Override
-		public void setSchema(String schema) {
-			table.setSchema( schema );
-		}
-
-		@Override
-		public void setCatalog(String catalog) {
-			table.setCatalog( catalog );
-		}
-	}
-
-	static class JoinTableSchemaAware implements SchemaAware {
-		private JaxbJoinTable table;
-
-		public JoinTableSchemaAware(JaxbJoinTable table) {
-			this.table = table;
-		}
-
-		@Override
-		public String getCatalog() {
-			return table.getCatalog();
-		}
-
-		@Override
-		public String getSchema() {
-			return table.getSchema();
-		}
-
-		@Override
-		public void setSchema(String schema) {
-			table.setSchema( schema );
-		}
-
-		@Override
-		public void setCatalog(String catalog) {
-			table.setCatalog( catalog );
-		}
-	}
-
-	static class CollectionTableSchemaAware implements SchemaAware {
-		private JaxbCollectionTable table;
-
-		public CollectionTableSchemaAware(JaxbCollectionTable table) {
-			this.table = table;
-		}
-
-		@Override
-		public String getCatalog() {
-			return table.getCatalog();
-		}
-
-		@Override
-		public String getSchema() {
-			return table.getSchema();
-		}
-
-		@Override
-		public void setSchema(String schema) {
-			table.setSchema( schema );
-		}
-
-		@Override
-		public void setCatalog(String catalog) {
-			table.setCatalog( catalog );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java
deleted file mode 100644
index 7154dcff64..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbTransient;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class TransientMocker extends PropertyMocker {
-	private JaxbTransient transientObj;
-
-	TransientMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbTransient transientObj) {
-		super( indexBuilder, classInfo, defaults );
-		this.transientObj = transientObj;
-	}
-
-	@Override
-	protected void processExtra() {
-		create( TRANSIENT );
-	}
-
-	@Override
-	protected String getFieldName() {
-		return transientObj.getName();
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return JaxbAccessType.FIELD;
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		//ignore
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java
deleted file mode 100644
index d54c94168e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAccessType;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbVersion;
-
-import org.jboss.jandex.ClassInfo;
-
-/**
- * @author Strong Liu
- */
-class VersionMocker extends PropertyMocker {
-	private JaxbVersion version;
-
-	VersionMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, JaxbVersion version) {
-		super( indexBuilder, classInfo, defaults );
-		this.version = version;
-	}
-
-	@Override
-	protected String getFieldName() {
-		return version.getName();
-	}
-
-	@Override
-	protected void processExtra() {
-		create( VERSION );
-		parserColumn( version.getColumn(), getTarget() );
-		parserTemporalType( version.getTemporal(), getTarget() );
-	}
-
-	@Override
-	protected JaxbAccessType getAccessType() {
-		return version.getAccess();
-	}
-
-	@Override
-	protected void setAccessType(JaxbAccessType accessType) {
-		version.setAccess( accessType );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AssociationAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AssociationAttributeSource.java
deleted file mode 100644
index 57743a69e4..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AssociationAttributeSource.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-
-/**
- * Contract describing sources for attributes which model associations.
- *
- * @author Steve Ebersole
- */
-public interface AssociationAttributeSource extends AttributeSource {
-	/**
-	 * Obtain the cascade styles to be applied to this association.
-	 *
-	 * @return The cascade styles.
-	 */
-	public Iterable<CascadeStyle> getCascadeStyles();
-
-	/**
-	 * Obtain the fetch mode to be applied to this association.
-	 *
-	 * @return The fetch mode.
-	 */
-	public FetchMode getFetchMode();
-
-	public FetchTiming getFetchTiming();
-
-	public FetchStyle getFetchStyle();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSource.java
deleted file mode 100644
index 2999634f1a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSource.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract for sources of persistent attribute descriptions.
- *
- * @author Steve Ebersole
- */
-public interface AttributeSource {
-	/**
-	 * Obtain the attribute name.
-	 *
-	 * @return The attribute name. {@code null} ais NOT allowed!
-	 */
-	public String getName();
-
-	/**
-	 * Is this a singular attribute?  Specifically, can it be cast to {@link SingularAttributeSource}?
-	 *
-	 * @return {@code true} indicates this is castable to {@link SingularAttributeSource}; {@code false} otherwise.
-	 */
-	public boolean isSingular();
-
-	/**
-	 * Obtain information about the Hibernate type ({@link org.hibernate.type.Type}) for this attribute.
-	 *
-	 * @return The Hibernate type information
-	 */
-	public ExplicitHibernateTypeSource getTypeInformation();
-
-	/**
-	 * Obtain the name of the property accessor style used to access this attribute.
-	 *
-	 * @return The property accessor style for this attribute.
-	 *
-	 * @see org.hibernate.property.PropertyAccessor
-	 */
-	public String getPropertyAccessorName();
-
-	/**
-	 * If the containing entity is using {@link org.hibernate.engine.OptimisticLockStyle#ALL} or
-	 * {@link org.hibernate.engine.OptimisticLockStyle#DIRTY} style optimistic locking, should this attribute
-	 * be used?
-	 *
-	 * @return {@code true} indicates it should be included; {@code false}, it should not.
-	 */
-	public boolean isIncludedInOptimisticLocking();
-
-	/**
-	 * Obtain the meta-attribute sources associated with this attribute.
-	 *
-	 * @return The meta-attribute sources.
-	 */
-	public Iterable<MetaAttributeSource> metaAttributes();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSourceContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSourceContainer.java
deleted file mode 100644
index d4d088bbe3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/AttributeSourceContainer.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.metamodel.source.LocalBindingContext;
-
-/**
- * Contract for a container of {@link AttributeSource} references.  Both entities and components contain
- * attributes.
- *
- * @author Steve Ebersole
- */
-public interface AttributeSourceContainer {
-	/**
-	 * Obtain the path used to uniquely identify this container.
-	 *
-	 * @return The unique identifier path
-	 */
-	public String getPath();
-
-	/**
-	 * Obtain this container's attribute sources.
-	 *
-	 * @return The attribute sources.
-	 */
-	public Iterable<AttributeSource> attributeSources();
-
-	/**
-	 * Obtain the local binding context associated with this container.
-	 *
-	 * @return The local binding context
-	 */
-	public LocalBindingContext getLocalBindingContext();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/BasicPluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/BasicPluralAttributeElementSource.java
deleted file mode 100644
index bf1d055bd8..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/BasicPluralAttributeElementSource.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.List;
-
-/**
- * @author Steve Ebersole
- */
-public interface BasicPluralAttributeElementSource extends PluralAttributeElementSource {
-	public List<RelationalValueSource> getValueSources();
-	public ExplicitHibernateTypeSource getExplicitHibernateTypeSource();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Binder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Binder.java
deleted file mode 100644
index 2e5e2c84d3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Binder.java
+++ /dev/null
@@ -1,1123 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.beans.BeanInfo;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.ParameterizedType;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.EntityMode;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.id.IdentifierGenerator;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.beans.BeanInfoHelper;
-import org.hibernate.metamodel.binding.AbstractPluralAttributeBinding;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.AttributeBindingContainer;
-import org.hibernate.metamodel.binding.BasicAttributeBinding;
-import org.hibernate.metamodel.binding.BasicCollectionElement;
-import org.hibernate.metamodel.binding.CollectionElementNature;
-import org.hibernate.metamodel.binding.CollectionLaziness;
-import org.hibernate.metamodel.binding.ComponentAttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.EntityDiscriminator;
-import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.binding.ManyToOneAttributeBinding;
-import org.hibernate.metamodel.binding.MetaAttribute;
-import org.hibernate.metamodel.binding.SimpleValueBinding;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
-import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.domain.Component;
-import org.hibernate.metamodel.domain.Entity;
-import org.hibernate.metamodel.domain.PluralAttribute;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.DerivedValue;
-import org.hibernate.metamodel.relational.Identifier;
-import org.hibernate.metamodel.relational.Schema;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.relational.TableSpecification;
-import org.hibernate.metamodel.relational.Tuple;
-import org.hibernate.metamodel.relational.UniqueKey;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.hbm.Helper;
-import org.hibernate.persister.collection.CollectionPersister;
-import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.tuple.entity.EntityTuplizer;
-
-/**
- * The common binder shared between annotations and {@code hbm.xml} processing.
- * <p/>
- * The API consists of {@link #Binder(MetadataImplementor, List)} and {@link #processEntityHierarchy(EntityHierarchy)}
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class Binder {
-	private final MetadataImplementor metadata;
-	private final List<String> processedEntityNames;
-
-	private InheritanceType currentInheritanceType;
-	private EntityMode currentHierarchyEntityMode;
-	private LocalBindingContext currentBindingContext;
-
-	public Binder(MetadataImplementor metadata, List<String> processedEntityNames) {
-		this.metadata = metadata;
-		this.processedEntityNames = processedEntityNames;
-	}
-
-	/**
-	 * Process an entity hierarchy.
-	 *
-	 * @param entityHierarchy THe hierarchy to process.
-	 */
-	public void processEntityHierarchy(EntityHierarchy entityHierarchy) {
-		currentInheritanceType = entityHierarchy.getHierarchyInheritanceType();
-		EntityBinding rootEntityBinding = createEntityBinding( entityHierarchy.getRootEntitySource(), null );
-		if ( currentInheritanceType != InheritanceType.NO_INHERITANCE ) {
-			processHierarchySubEntities( entityHierarchy.getRootEntitySource(), rootEntityBinding );
-		}
-		currentHierarchyEntityMode = null;
-	}
-
-	private void processHierarchySubEntities(SubclassEntityContainer subclassEntitySource, EntityBinding superEntityBinding) {
-		for ( SubclassEntitySource subEntity : subclassEntitySource.subclassEntitySources() ) {
-			EntityBinding entityBinding = createEntityBinding( subEntity, superEntityBinding );
-			processHierarchySubEntities( subEntity, entityBinding );
-		}
-	}
-
-
-	// Entities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	private EntityBinding createEntityBinding(EntitySource entitySource, EntityBinding superEntityBinding) {
-		if ( processedEntityNames.contains( entitySource.getEntityName() ) ) {
-			return metadata.getEntityBinding( entitySource.getEntityName() );
-		}
-
-		currentBindingContext = entitySource.getLocalBindingContext();
-		try {
-			final EntityBinding entityBinding = doCreateEntityBinding( entitySource, superEntityBinding );
-
-			metadata.addEntity( entityBinding );
-			processedEntityNames.add( entityBinding.getEntity().getName() );
-
-			processFetchProfiles( entitySource, entityBinding );
-
-			return entityBinding;
-		}
-		finally {
-			currentBindingContext = null;
-		}
-	}
-
-	private EntityBinding doCreateEntityBinding(EntitySource entitySource, EntityBinding superEntityBinding) {
-		final EntityBinding entityBinding = createBasicEntityBinding( entitySource, superEntityBinding );
-
-		bindSecondaryTables( entitySource, entityBinding );
-		bindAttributes( entitySource, entityBinding );
-
-		bindTableUniqueConstraints( entitySource, entityBinding );
-
-		return entityBinding;
-	}
-
-	private EntityBinding createBasicEntityBinding(EntitySource entitySource, EntityBinding superEntityBinding) {
-		if ( superEntityBinding == null ) {
-			return makeRootEntityBinding( (RootEntitySource) entitySource );
-		}
-		else {
-			switch ( currentInheritanceType ) {
-				case SINGLE_TABLE:
-					return makeDiscriminatedSubclassBinding( (SubclassEntitySource) entitySource, superEntityBinding );
-				case JOINED:
-					return makeJoinedSubclassBinding( (SubclassEntitySource) entitySource, superEntityBinding );
-				case TABLE_PER_CLASS:
-					return makeUnionedSubclassBinding( (SubclassEntitySource) entitySource, superEntityBinding );
-				default:
-					// extreme internal error!
-					throw new AssertionFailure( "Internal condition failure" );
-			}
-		}
-	}
-
-	private EntityBinding makeRootEntityBinding(RootEntitySource entitySource) {
-		currentHierarchyEntityMode = entitySource.getEntityMode();
-
-		final EntityBinding entityBinding = buildBasicEntityBinding( entitySource, null );
-
-		bindPrimaryTable( entitySource, entityBinding );
-
-		bindIdentifier( entitySource, entityBinding );
-		bindVersion( entityBinding, entitySource );
-		bindDiscriminator( entitySource, entityBinding );
-
-		entityBinding.getHierarchyDetails().setCaching( entitySource.getCaching() );
-		entityBinding.getHierarchyDetails().setExplicitPolymorphism( entitySource.isExplicitPolymorphism() );
-		entityBinding.getHierarchyDetails().setOptimisticLockStyle( entitySource.getOptimisticLockStyle() );
-
-		entityBinding.setMutable( entitySource.isMutable() );
-		entityBinding.setWhereFilter( entitySource.getWhere() );
-		entityBinding.setRowId( entitySource.getRowId() );
-
-		return entityBinding;
-	}
-
-	private EntityBinding buildBasicEntityBinding(EntitySource entitySource, EntityBinding superEntityBinding) {
-		final EntityBinding entityBinding = superEntityBinding == null
-				? new EntityBinding( currentInheritanceType, currentHierarchyEntityMode )
-				: new EntityBinding( superEntityBinding );
-
-		final String entityName = entitySource.getEntityName();
-		final String className = currentHierarchyEntityMode == EntityMode.POJO ? entitySource.getClassName() : null;
-
-		final Entity entity = new Entity(
-				entityName,
-				className,
-				currentBindingContext.makeClassReference( className ),
-				superEntityBinding == null ? null : superEntityBinding.getEntity()
-		);
-		entityBinding.setEntity( entity );
-
-		entityBinding.setJpaEntityName( entitySource.getJpaEntityName() );
-
-		if ( currentHierarchyEntityMode == EntityMode.POJO ) {
-			final String proxy = entitySource.getProxy();
-			if ( proxy != null ) {
-				entityBinding.setProxyInterfaceType(
-						currentBindingContext.makeClassReference(
-								currentBindingContext.qualifyClassName( proxy )
-						)
-				);
-				entityBinding.setLazy( true );
-			}
-			else if ( entitySource.isLazy() ) {
-				entityBinding.setProxyInterfaceType( entityBinding.getEntity().getClassReferenceUnresolved() );
-				entityBinding.setLazy( true );
-			}
-		}
-		else {
-			entityBinding.setProxyInterfaceType( null );
-			entityBinding.setLazy( entitySource.isLazy() );
-		}
-
-		final String customTuplizerClassName = entitySource.getCustomTuplizerClassName();
-		if ( customTuplizerClassName != null ) {
-			entityBinding.setCustomEntityTuplizerClass(
-					currentBindingContext.<EntityTuplizer>locateClassByName(
-							customTuplizerClassName
-					)
-			);
-		}
-
-		final String customPersisterClassName = entitySource.getCustomPersisterClassName();
-		if ( customPersisterClassName != null ) {
-			entityBinding.setCustomEntityPersisterClass(
-					currentBindingContext.<EntityPersister>locateClassByName(
-							customPersisterClassName
-					)
-			);
-		}
-
-		entityBinding.setMetaAttributeContext( buildMetaAttributeContext( entitySource ) );
-
-		entityBinding.setDynamicUpdate( entitySource.isDynamicUpdate() );
-		entityBinding.setDynamicInsert( entitySource.isDynamicInsert() );
-		entityBinding.setBatchSize( entitySource.getBatchSize() );
-		entityBinding.setSelectBeforeUpdate( entitySource.isSelectBeforeUpdate() );
-		entityBinding.setAbstract( entitySource.isAbstract() );
-
-		entityBinding.setCustomLoaderName( entitySource.getCustomLoaderName() );
-		entityBinding.setCustomInsert( entitySource.getCustomSqlInsert() );
-		entityBinding.setCustomUpdate( entitySource.getCustomSqlUpdate() );
-		entityBinding.setCustomDelete( entitySource.getCustomSqlDelete() );
-
-		if ( entitySource.getSynchronizedTableNames() != null ) {
-			entityBinding.addSynchronizedTableNames( entitySource.getSynchronizedTableNames() );
-		}
-
-		entityBinding.setJpaCallbackClasses(entitySource.getJpaCallbackClasses());
-
-		return entityBinding;
-	}
-
-	private EntityBinding makeDiscriminatedSubclassBinding(SubclassEntitySource entitySource, EntityBinding superEntityBinding) {
-		final EntityBinding entityBinding = buildBasicEntityBinding( entitySource, superEntityBinding );
-
-		entityBinding.setPrimaryTable( superEntityBinding.getPrimaryTable() );
-		entityBinding.setPrimaryTableName( superEntityBinding.getPrimaryTableName() );
-		bindDiscriminatorValue( entitySource, entityBinding );
-
-		return entityBinding;
-	}
-
-	private EntityBinding makeJoinedSubclassBinding(SubclassEntitySource entitySource, EntityBinding superEntityBinding) {
-		final EntityBinding entityBinding = buildBasicEntityBinding( entitySource, superEntityBinding );
-
-		bindPrimaryTable( entitySource, entityBinding );
-
-		// todo : join
-
-		return entityBinding;
-	}
-
-	private EntityBinding makeUnionedSubclassBinding(SubclassEntitySource entitySource, EntityBinding superEntityBinding) {
-		final EntityBinding entityBinding = buildBasicEntityBinding( entitySource, superEntityBinding );
-
-		bindPrimaryTable( entitySource, entityBinding );
-
-		// todo : ??
-
-		return entityBinding;
-	}
-
-	// Attributes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	private void bindIdentifier(RootEntitySource entitySource, EntityBinding entityBinding) {
-		if ( entitySource.getIdentifierSource() == null ) {
-			throw new AssertionFailure( "Expecting identifier information on root entity descriptor" );
-		}
-		switch ( entitySource.getIdentifierSource().getNature() ) {
-			case SIMPLE: {
-				bindSimpleIdentifier( (SimpleIdentifierSource) entitySource.getIdentifierSource(), entityBinding );
-				break;
-			}
-			case AGGREGATED_COMPOSITE: {
-				// composite id with an actual component class
-			    break;
-			}
-			case COMPOSITE: {
-				// what we used to term an "embedded composite identifier", which is not tobe confused with the JPA
-				// term embedded. Specifically a composite id where there is no component class, though there may
-				// be a @IdClass :/
-			    break;
-			}
-		}
-	}
-
-	private void bindSimpleIdentifier(SimpleIdentifierSource identifierSource, EntityBinding entityBinding) {
-		final BasicAttributeBinding idAttributeBinding = doBasicSingularAttributeBindingCreation(
-				identifierSource.getIdentifierAttributeSource(), entityBinding
-		);
-
-		entityBinding.getHierarchyDetails().getEntityIdentifier().setValueBinding( idAttributeBinding );
-		IdGenerator generator = identifierSource.getIdentifierGeneratorDescriptor();
-		if ( generator == null ) {
-			Map<String, String> params = new HashMap<String, String>();
-			params.put( IdentifierGenerator.ENTITY_NAME, entityBinding.getEntity().getName() );
-			generator = new IdGenerator( "default_assign_identity_generator", "assigned", params );
-		}
-		entityBinding.getHierarchyDetails()
-				.getEntityIdentifier()
-				.setIdGenerator( generator );
-
-		final org.hibernate.metamodel.relational.Value relationalValue = idAttributeBinding.getValue();
-
-		if ( SimpleValue.class.isInstance( relationalValue ) ) {
-			if ( !Column.class.isInstance( relationalValue ) ) {
-				// this should never ever happen..
-				throw new AssertionFailure( "Simple-id was not a column." );
-			}
-			entityBinding.getPrimaryTable().getPrimaryKey().addColumn( Column.class.cast( relationalValue ) );
-		}
-		else {
-			for ( SimpleValue subValue : ( (Tuple) relationalValue ).values() ) {
-				if ( Column.class.isInstance( subValue ) ) {
-					entityBinding.getPrimaryTable().getPrimaryKey().addColumn( Column.class.cast( subValue ) );
-				}
-			}
-		}
-	}
-
-	private void bindVersion(EntityBinding entityBinding, RootEntitySource entitySource) {
-		final SingularAttributeSource versioningAttributeSource = entitySource.getVersioningAttributeSource();
-		if ( versioningAttributeSource == null ) {
-			return;
-		}
-
-		BasicAttributeBinding attributeBinding = doBasicSingularAttributeBindingCreation(
-				versioningAttributeSource, entityBinding
-		);
-		entityBinding.getHierarchyDetails().setVersioningAttributeBinding( attributeBinding );
-	}
-
-	private void bindDiscriminator(RootEntitySource entitySource, EntityBinding entityBinding) {
-		final DiscriminatorSource discriminatorSource = entitySource.getDiscriminatorSource();
-		if ( discriminatorSource == null ) {
-			return;
-		}
-
-		EntityDiscriminator discriminator = new EntityDiscriminator();
-		SimpleValue relationalValue = makeSimpleValue(
-				entityBinding,
-				discriminatorSource.getDiscriminatorRelationalValueSource()
-		);
-		discriminator.setBoundValue( relationalValue );
-
-		discriminator.getExplicitHibernateTypeDescriptor().setExplicitTypeName(
-				discriminatorSource.getExplicitHibernateTypeName() != null
-						? discriminatorSource.getExplicitHibernateTypeName()
-						: "string"
-		);
-
-		discriminator.setInserted( discriminatorSource.isInserted() );
-		discriminator.setForced( discriminatorSource.isForced() );
-
-		entityBinding.getHierarchyDetails().setEntityDiscriminator( discriminator );
-		entityBinding.setDiscriminatorMatchValue( entitySource.getDiscriminatorMatchValue() );
-	}
-
-	private void bindDiscriminatorValue(SubclassEntitySource entitySource, EntityBinding entityBinding) {
-		final String discriminatorValue = entitySource.getDiscriminatorMatchValue();
-		if ( discriminatorValue == null ) {
-			return;
-		}
-		entityBinding.setDiscriminatorMatchValue( discriminatorValue );
-	}
-
-	private void bindAttributes(AttributeSourceContainer attributeSourceContainer, AttributeBindingContainer attributeBindingContainer) {
-		// todo : we really need the notion of a Stack here for the table from which the columns come for binding these attributes.
-		// todo : adding the concept (interface) of a source of attribute metadata would allow reuse of this method for entity, component, unique-key, etc
-		// for now, simply assume all columns come from the base table....
-
-		for ( AttributeSource attributeSource : attributeSourceContainer.attributeSources() ) {
-			if ( attributeSource.isSingular() ) {
-				final SingularAttributeSource singularAttributeSource = (SingularAttributeSource) attributeSource;
-				if ( singularAttributeSource.getNature() == SingularAttributeNature.COMPONENT ) {
-					bindComponent( (ComponentAttributeSource) singularAttributeSource, attributeBindingContainer );
-				}
-				else {
-					doBasicSingularAttributeBindingCreation( singularAttributeSource, attributeBindingContainer );
-				}
-			}
-			else {
-				bindPersistentCollection( (PluralAttributeSource) attributeSource, attributeBindingContainer );
-			}
-		}
-	}
-
-	private void bindComponent(ComponentAttributeSource attributeSource, AttributeBindingContainer container) {
-		final String attributeName = attributeSource.getName();
-		SingularAttribute attribute = container.getAttributeContainer().locateComponentAttribute( attributeName );
-		if ( attribute == null ) {
-			final Component component = new Component(
-					attributeSource.getPath(),
-					attributeSource.getClassName(),
-					attributeSource.getClassReference(),
-					null // component inheritance not YET supported
-			);
-			attribute = container.getAttributeContainer().createComponentAttribute( attributeName, component );
-		}
-		ComponentAttributeBinding componentAttributeBinding = container.makeComponentAttributeBinding( attribute );
-
-		if ( StringHelper.isNotEmpty( attributeSource.getParentReferenceAttributeName() ) ) {
-			final SingularAttribute parentReferenceAttribute =
-					componentAttributeBinding.getComponent()
-							.createSingularAttribute( attributeSource.getParentReferenceAttributeName() );
-			componentAttributeBinding.setParentReference( parentReferenceAttribute );
-		}
-
-		componentAttributeBinding.setMetaAttributeContext(
-				buildMetaAttributeContext( attributeSource.metaAttributes(), container.getMetaAttributeContext() )
-		);
-
-		bindAttributes( attributeSource, componentAttributeBinding );
-	}
-
-	private void bindPersistentCollection(PluralAttributeSource attributeSource, AttributeBindingContainer attributeBindingContainer) {
-		final PluralAttribute existingAttribute = attributeBindingContainer.getAttributeContainer()
-				.locatePluralAttribute( attributeSource.getName() );
-		final AbstractPluralAttributeBinding pluralAttributeBinding;
-
-		if ( attributeSource.getPluralAttributeNature() == PluralAttributeNature.BAG ) {
-			final PluralAttribute attribute = existingAttribute != null
-					? existingAttribute
-					: attributeBindingContainer.getAttributeContainer().createBag( attributeSource.getName() );
-			pluralAttributeBinding = attributeBindingContainer.makeBagAttributeBinding(
-					attribute,
-					convert( attributeSource.getElementSource().getNature() )
-			);
-		}
-		else if ( attributeSource.getPluralAttributeNature() == PluralAttributeNature.SET ) {
-			final PluralAttribute attribute = existingAttribute != null
-					? existingAttribute
-					: attributeBindingContainer.getAttributeContainer().createSet( attributeSource.getName() );
-			pluralAttributeBinding = attributeBindingContainer.makeSetAttributeBinding(
-					attribute,
-					convert( attributeSource.getElementSource().getNature() )
-			);
-		}
-		else {
-			// todo : implement other collection types
-			throw new NotYetImplementedException( "Collections other than bag and set not yet implemented :(" );
-		}
-
-		doBasicPluralAttributeBinding( attributeSource, pluralAttributeBinding );
-
-		bindCollectionTable( attributeSource, pluralAttributeBinding );
-		bindSortingAndOrdering( attributeSource, pluralAttributeBinding );
-
-		bindCollectionKey( attributeSource, pluralAttributeBinding );
-		bindCollectionElement( attributeSource, pluralAttributeBinding );
-		bindCollectionIndex( attributeSource, pluralAttributeBinding );
-
-		metadata.addCollection( pluralAttributeBinding );
-	}
-
-	private void doBasicPluralAttributeBinding(PluralAttributeSource source, AbstractPluralAttributeBinding binding) {
-		binding.setFetchTiming( source.getFetchTiming() );
-		binding.setFetchStyle( source.getFetchStyle() );
-		binding.setCascadeStyles( source.getCascadeStyles() );
-
-		binding.setCaching( source.getCaching() );
-
-		binding.getHibernateTypeDescriptor().setJavaTypeName(
-				source.getPluralAttributeNature().reportedJavaType().getName()
-		);
-		binding.getHibernateTypeDescriptor().setExplicitTypeName( source.getTypeInformation().getName() );
-		binding.getHibernateTypeDescriptor().getTypeParameters().putAll( source.getTypeInformation().getParameters() );
-
-		if ( StringHelper.isNotEmpty( source.getCustomPersisterClassName() ) ) {
-			binding.setCollectionPersisterClass(
-					currentBindingContext.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
-			);
-		}
-
-		if ( source.getCustomPersisterClassName() != null ) {
-			binding.setCollectionPersisterClass(
-					metadata.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
-			);
-		}
-
-		binding.setCustomLoaderName( source.getCustomLoaderName() );
-		binding.setCustomSqlInsert( source.getCustomSqlInsert() );
-		binding.setCustomSqlUpdate( source.getCustomSqlUpdate() );
-		binding.setCustomSqlDelete( source.getCustomSqlDelete() );
-		binding.setCustomSqlDeleteAll( source.getCustomSqlDeleteAll() );
-
-		binding.setMetaAttributeContext(
-				buildMetaAttributeContext(
-						source.metaAttributes(),
-						binding.getContainer().getMetaAttributeContext()
-				)
-		);
-
-		doBasicAttributeBinding( source, binding );
-	}
-
-	private CollectionLaziness interpretLaziness(String laziness) {
-		if ( laziness == null ) {
-			laziness = Boolean.toString( metadata.getMappingDefaults().areAssociationsLazy() );
-		}
-
-		if ( "extra".equals( laziness ) ) {
-			return CollectionLaziness.EXTRA;
-		}
-		else if ( "false".equals( laziness ) ) {
-			return CollectionLaziness.NOT;
-		}
-		else if ( "true".equals( laziness ) ) {
-			return CollectionLaziness.LAZY;
-		}
-
-		throw new MappingException(
-				String.format( "Unexpected collection laziness value %s", laziness ),
-				currentBindingContext.getOrigin()
-		);
-	}
-
-	private void bindCollectionTable(
-			PluralAttributeSource attributeSource,
-			AbstractPluralAttributeBinding pluralAttributeBinding) {
-		if ( attributeSource.getElementSource().getNature() == PluralAttributeElementNature.ONE_TO_MANY ) {
-			return;
-		}
-
-		final Schema.Name schemaName = Helper.determineDatabaseSchemaName(
-				attributeSource.getExplicitSchemaName(),
-				attributeSource.getExplicitCatalogName(),
-				currentBindingContext
-		);
-		final Schema schema = metadata.getDatabase().locateSchema( schemaName );
-
-		final String tableName = attributeSource.getExplicitCollectionTableName();
-		if ( StringHelper.isNotEmpty( tableName ) ) {
-			final Identifier tableIdentifier = Identifier.toIdentifier(
-					currentBindingContext.getNamingStrategy().tableName( tableName )
-			);
-			Table collectionTable = schema.locateTable( tableIdentifier );
-			if ( collectionTable == null ) {
-				collectionTable = schema.createTable( tableIdentifier );
-			}
-			pluralAttributeBinding.setCollectionTable( collectionTable );
-		}
-		else {
-			// todo : not sure wel have all the needed info here in all cases, specifically when needing to know the "other side"
-			final EntityBinding owner = pluralAttributeBinding.getContainer().seekEntityBinding();
-			final String ownerTableLogicalName = Table.class.isInstance( owner.getPrimaryTable() )
-					? Table.class.cast( owner.getPrimaryTable() ).getTableName().getName()
-					: null;
-			String collectionTableName = currentBindingContext.getNamingStrategy().collectionTableName(
-					owner.getEntity().getName(),
-					ownerTableLogicalName,
-					null,	// todo : here
-					null,	// todo : and here
-					pluralAttributeBinding.getContainer().getPathBase() + '.' + attributeSource.getName()
-			);
-			collectionTableName = quoteIdentifier( collectionTableName );
-			pluralAttributeBinding.setCollectionTable(
-					schema.locateOrCreateTable(
-							Identifier.toIdentifier(
-									collectionTableName
-							)
-					)
-			);
-		}
-
-		if ( StringHelper.isNotEmpty( attributeSource.getCollectionTableComment() ) ) {
-			pluralAttributeBinding.getCollectionTable().addComment( attributeSource.getCollectionTableComment() );
-		}
-
-		if ( StringHelper.isNotEmpty( attributeSource.getCollectionTableCheck() ) ) {
-			pluralAttributeBinding.getCollectionTable().addCheckConstraint( attributeSource.getCollectionTableCheck() );
-		}
-
-		pluralAttributeBinding.setWhere( attributeSource.getWhere() );
-	}
-
-	private void bindCollectionKey(
-			PluralAttributeSource attributeSource,
-			AbstractPluralAttributeBinding pluralAttributeBinding) {
-		pluralAttributeBinding.getCollectionKey().prepareForeignKey(
-				attributeSource.getKeySource().getExplicitForeignKeyName(),
-				null  // todo : handle secondary table names
-		);
-		pluralAttributeBinding.getCollectionKey().getForeignKey().setDeleteRule(
-				attributeSource.getKeySource().getOnDeleteAction()
-		);
-		// todo : need to bind "relational values", account for property-ref
-	}
-
-	private void bindCollectionElement(
-			PluralAttributeSource attributeSource,
-			AbstractPluralAttributeBinding pluralAttributeBinding) {
-		final PluralAttributeElementSource elementSource = attributeSource.getElementSource();
-		if ( elementSource.getNature() == PluralAttributeElementNature.BASIC ) {
-			final BasicPluralAttributeElementSource basicElementSource = (BasicPluralAttributeElementSource) elementSource;
-			final BasicCollectionElement basicCollectionElement = (BasicCollectionElement) pluralAttributeBinding.getCollectionElement();
-			resolveTypeInformation(
-					basicElementSource.getExplicitHibernateTypeSource(),
-					pluralAttributeBinding.getAttribute(),
-					basicCollectionElement
-			);
-			// todo : temp
-			return;
-		}
-		// todo : implement
-		throw new NotYetImplementedException(
-				String.format(
-						"Support for collection elements of type %s not yet implemented",
-						elementSource.getNature()
-				)
-		);
-	}
-
-	private void bindCollectionIndex(
-			PluralAttributeSource attributeSource,
-			AbstractPluralAttributeBinding pluralAttributeBinding) {
-		if ( attributeSource.getPluralAttributeNature() != PluralAttributeNature.LIST
-				&& attributeSource.getPluralAttributeNature() != PluralAttributeNature.MAP ) {
-			return;
-		}
-
-		// todo : implement
-		throw new NotYetImplementedException();
-	}
-
-	private void bindSortingAndOrdering(
-			PluralAttributeSource attributeSource,
-			AbstractPluralAttributeBinding pluralAttributeBinding) {
-		if ( Sortable.class.isInstance( attributeSource ) ) {
-			final Sortable sortable = Sortable.class.cast( attributeSource );
-			if ( sortable.isSorted() ) {
-				// todo : handle setting comparator
-
-				// and then return because sorting and ordering are mutually exclusive
-				return;
-			}
-		}
-
-		if ( Orderable.class.isInstance( attributeSource ) ) {
-			final Orderable orderable = Orderable.class.cast( attributeSource );
-			if ( orderable.isOrdered() ) {
-				// todo : handle setting ordering
-			}
-		}
-	}
-
-	private void doBasicAttributeBinding(AttributeSource attributeSource, AttributeBinding attributeBinding) {
-		attributeBinding.setPropertyAccessorName( attributeSource.getPropertyAccessorName() );
-		attributeBinding.setIncludedInOptimisticLocking( attributeSource.isIncludedInOptimisticLocking() );
-	}
-
-	private CollectionElementNature convert(PluralAttributeElementNature pluralAttributeElementNature) {
-		return CollectionElementNature.valueOf( pluralAttributeElementNature.name() );
-	}
-
-	private BasicAttributeBinding doBasicSingularAttributeBindingCreation(
-			SingularAttributeSource attributeSource,
-			AttributeBindingContainer attributeBindingContainer) {
-		final SingularAttribute existingAttribute = attributeBindingContainer.getAttributeContainer()
-				.locateSingularAttribute( attributeSource.getName() );
-		final SingularAttribute attribute;
-		if ( existingAttribute != null ) {
-			attribute = existingAttribute;
-		}
-		else if ( attributeSource.isVirtualAttribute() ) {
-			attribute = attributeBindingContainer.getAttributeContainer().createVirtualSingularAttribute(
-					attributeSource.getName()
-			);
-		}
-		else {
-			attribute = attributeBindingContainer.getAttributeContainer()
-					.createSingularAttribute( attributeSource.getName() );
-		}
-
-		final BasicAttributeBinding attributeBinding;
-		if ( attributeSource.getNature() == SingularAttributeNature.BASIC ) {
-			attributeBinding = attributeBindingContainer.makeBasicAttributeBinding( attribute );
-			resolveTypeInformation( attributeSource.getTypeInformation(), attributeBinding );
-		}
-		else if ( attributeSource.getNature() == SingularAttributeNature.MANY_TO_ONE ) {
-			attributeBinding = attributeBindingContainer.makeManyToOneAttributeBinding( attribute );
-			resolveTypeInformation( attributeSource.getTypeInformation(), attributeBinding );
-			resolveToOneInformation(
-					(ToOneAttributeSource) attributeSource,
-					(ManyToOneAttributeBinding) attributeBinding
-			);
-		}
-		else {
-			throw new NotYetImplementedException();
-		}
-
-		attributeBinding.setGeneration( attributeSource.getGeneration() );
-		attributeBinding.setLazy( attributeSource.isLazy() );
-		attributeBinding.setIncludedInOptimisticLocking( attributeSource.isIncludedInOptimisticLocking() );
-
-		attributeBinding.setPropertyAccessorName(
-				Helper.getPropertyAccessorName(
-						attributeSource.getPropertyAccessorName(),
-						false,
-						currentBindingContext.getMappingDefaults().getPropertyAccessorName()
-				)
-		);
-
-		bindRelationalValues( attributeSource, attributeBinding );
-
-		attributeBinding.setMetaAttributeContext(
-				buildMetaAttributeContext(
-						attributeSource.metaAttributes(),
-						attributeBindingContainer.getMetaAttributeContext()
-				)
-		);
-
-		return attributeBinding;
-	}
-
-	private void resolveTypeInformation(ExplicitHibernateTypeSource typeSource, BasicAttributeBinding attributeBinding) {
-		final Class<?> attributeJavaType = determineJavaType( attributeBinding.getAttribute() );
-		if ( attributeJavaType != null ) {
-			attributeBinding.getAttribute()
-					.resolveType( currentBindingContext.makeJavaType( attributeJavaType.getName() ) );
-		}
-
-		resolveTypeInformation( typeSource, attributeBinding.getHibernateTypeDescriptor(), attributeJavaType );
-	}
-
-	private void resolveTypeInformation(
-			ExplicitHibernateTypeSource typeSource,
-			PluralAttribute attribute,
-			BasicCollectionElement collectionElement) {
-		final Class<?> attributeJavaType = determineJavaType( attribute );
-		resolveTypeInformation( typeSource, collectionElement.getHibernateTypeDescriptor(), attributeJavaType );
-	}
-
-	private void resolveTypeInformation(
-			ExplicitHibernateTypeSource typeSource,
-			HibernateTypeDescriptor hibernateTypeDescriptor,
-			Class<?> discoveredJavaType) {
-		if ( discoveredJavaType != null ) {
-			hibernateTypeDescriptor.setJavaTypeName( discoveredJavaType.getName() );
-		}
-
-		final String explicitTypeName = typeSource.getName();
-		if ( explicitTypeName != null ) {
-			final TypeDef typeDef = currentBindingContext.getMetadataImplementor()
-					.getTypeDefinition( explicitTypeName );
-			if ( typeDef != null ) {
-				hibernateTypeDescriptor.setExplicitTypeName( typeDef.getTypeClass() );
-				hibernateTypeDescriptor.getTypeParameters().putAll( typeDef.getParameters() );
-			}
-			else {
-				hibernateTypeDescriptor.setExplicitTypeName( explicitTypeName );
-			}
-			final Map<String, String> parameters = typeSource.getParameters();
-			if ( parameters != null ) {
-				hibernateTypeDescriptor.getTypeParameters().putAll( parameters );
-			}
-		}
-		else {
-			if ( discoveredJavaType == null ) {
-				// we will have problems later determining the Hibernate Type to use.  Should we throw an
-				// exception now?  Might be better to get better contextual info
-			}
-		}
-	}
-
-	/**
-	 * @param attribute the domain attribute
-	 *
-	 * @return Returns the Java type of the attribute using reflection or {@code null} if the type cannot be discovered
-	 */
-	private Class<?> determineJavaType(final SingularAttribute attribute) {
-		try {
-			final Class<?> ownerClass = attribute.getAttributeContainer().getClassReference();
-			AttributeJavaTypeDeterminerDelegate delegate = new AttributeJavaTypeDeterminerDelegate( attribute.getName() );
-			BeanInfoHelper.visitBeanInfo( ownerClass, delegate );
-			return delegate.javaType;
-		}
-		catch ( Exception ignore ) {
-			// todo : log it?
-		}
-		return null;
-	}
-
-	private Class<?> determineJavaType(PluralAttribute attribute) {
-		try {
-			final Class<?> ownerClass = attribute.getAttributeContainer().getClassReference();
-			PluralAttributeJavaTypeDeterminerDelegate delegate = new PluralAttributeJavaTypeDeterminerDelegate(
-					ownerClass,
-					attribute.getName()
-			);
-			BeanInfoHelper.visitBeanInfo( ownerClass, delegate );
-			return delegate.javaType;
-		}
-		catch ( Exception ignore ) {
-			// todo : log it?
-		}
-		return null;
-	}
-
-	private class PluralAttributeJavaTypeDeterminerDelegate implements BeanInfoHelper.BeanInfoDelegate {
-		private final Class<?> ownerClass;
-		private final String attributeName;
-
-		private Class<?> javaType = null;
-
-		private PluralAttributeJavaTypeDeterminerDelegate(Class<?> ownerClass, String attributeName) {
-			this.ownerClass = ownerClass;
-			this.attributeName = attributeName;
-		}
-
-		@Override
-		public void processBeanInfo(BeanInfo beanInfo) throws Exception {
-			for ( PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors() ) {
-				if ( propertyDescriptor.getName().equals( attributeName ) ) {
-					javaType = extractCollectionComponentType( beanInfo, propertyDescriptor );
-					break;
-				}
-			}
-		}
-
-		@SuppressWarnings( { "unchecked" })
-		private Class<?> extractCollectionComponentType(BeanInfo beanInfo, PropertyDescriptor propertyDescriptor) {
-			final java.lang.reflect.Type collectionAttributeType;
-			if ( propertyDescriptor.getReadMethod() != null ) {
-				collectionAttributeType = propertyDescriptor.getReadMethod().getGenericReturnType();
-			}
-			else if ( propertyDescriptor.getWriteMethod() != null ) {
-				collectionAttributeType = propertyDescriptor.getWriteMethod().getGenericParameterTypes()[0];
-			}
-			else {
-				// we need to look for the field and look at it...
-				try {
-					collectionAttributeType = ownerClass.getField( propertyDescriptor.getName() ).getGenericType();
-				}
-				catch ( Exception e ) {
-					return null;
-				}
-			}
-
-			if ( ParameterizedType.class.isInstance( collectionAttributeType ) ) {
-				final java.lang.reflect.Type[] types = ( (ParameterizedType) collectionAttributeType ).getActualTypeArguments();
-				if ( types == null ) {
-					return null;
-				}
-				else if ( types.length == 1 ) {
-					return (Class<?>) types[0];
-				}
-				else if ( types.length == 2 ) {
-					// Map<K,V>
-					return (Class<?>) types[1];
-				}
-			}
-			return null;
-		}
-	}
-
-	private void resolveToOneInformation(ToOneAttributeSource attributeSource, ManyToOneAttributeBinding attributeBinding) {
-		final String referencedEntityName = attributeSource.getReferencedEntityName() != null
-				? attributeSource.getReferencedEntityName()
-				: attributeBinding.getAttribute().getSingularAttributeType().getClassName();
-		attributeBinding.setReferencedEntityName( referencedEntityName );
-		// todo : we should consider basing references on columns instead of property-ref, which would require a resolution (later) of property-ref to column names
-		attributeBinding.setReferencedAttributeName( attributeSource.getReferencedEntityAttributeName() );
-
-		attributeBinding.setCascadeStyles( attributeSource.getCascadeStyles() );
-		attributeBinding.setFetchTiming( attributeSource.getFetchTiming() );
-		attributeBinding.setFetchStyle( attributeSource.getFetchStyle() );
-	}
-
-	private MetaAttributeContext buildMetaAttributeContext(EntitySource entitySource) {
-		return buildMetaAttributeContext(
-				entitySource.metaAttributes(),
-				true,
-				currentBindingContext.getMetadataImplementor().getGlobalMetaAttributeContext()
-		);
-	}
-
-	private static MetaAttributeContext buildMetaAttributeContext(
-			Iterable<MetaAttributeSource> metaAttributeSources,
-			MetaAttributeContext parentContext) {
-		return buildMetaAttributeContext( metaAttributeSources, false, parentContext );
-	}
-
-	private static MetaAttributeContext buildMetaAttributeContext(
-			Iterable<MetaAttributeSource> metaAttributeSources,
-			boolean onlyInheritable,
-			MetaAttributeContext parentContext) {
-		final MetaAttributeContext subContext = new MetaAttributeContext( parentContext );
-
-		for ( MetaAttributeSource metaAttributeSource : metaAttributeSources ) {
-			if ( onlyInheritable & !metaAttributeSource.isInheritable() ) {
-				continue;
-			}
-
-			final String name = metaAttributeSource.getName();
-			final MetaAttribute inheritedMetaAttribute = parentContext.getMetaAttribute( name );
-			MetaAttribute metaAttribute = subContext.getLocalMetaAttribute( name );
-			if ( metaAttribute == null || metaAttribute == inheritedMetaAttribute ) {
-				metaAttribute = new MetaAttribute( name );
-				subContext.add( metaAttribute );
-			}
-			metaAttribute.addValue( metaAttributeSource.getValue() );
-		}
-
-		return subContext;
-	}
-
-	// Relational ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	private void bindPrimaryTable(EntitySource entitySource, EntityBinding entityBinding) {
-		final TableSource tableSource = entitySource.getPrimaryTable();
-		final Table table = createTable( entityBinding, tableSource );
-		entityBinding.setPrimaryTable( table );
-		entityBinding.setPrimaryTableName( table.getTableName().getName() );
-	}
-
-	private void bindSecondaryTables(EntitySource entitySource, EntityBinding entityBinding) {
-		for ( TableSource secondaryTableSource : entitySource.getSecondaryTables() ) {
-			final Table table = createTable( entityBinding, secondaryTableSource );
-			entityBinding.addSecondaryTable( secondaryTableSource.getLogicalName(), table );
-		}
-	}
-
-	private Table createTable(EntityBinding entityBinding, TableSource tableSource) {
-		String tableName = tableSource.getExplicitTableName();
-		if ( StringHelper.isEmpty( tableName ) ) {
-			tableName = currentBindingContext.getNamingStrategy()
-					.classToTableName( entityBinding.getEntity().getClassName() );
-		}
-		else {
-			tableName = currentBindingContext.getNamingStrategy().tableName( tableName );
-		}
-		tableName = quoteIdentifier( tableName );
-
-		final Schema.Name databaseSchemaName = Helper.determineDatabaseSchemaName(
-				tableSource.getExplicitSchemaName(),
-				tableSource.getExplicitCatalogName(),
-				currentBindingContext
-		);
-		return currentBindingContext.getMetadataImplementor()
-				.getDatabase()
-				.locateSchema( databaseSchemaName )
-				.locateOrCreateTable( Identifier.toIdentifier( tableName ) );
-	}
-
-	private void bindTableUniqueConstraints(EntitySource entitySource, EntityBinding entityBinding) {
-		for ( ConstraintSource constraintSource : entitySource.getConstraints() ) {
-			if ( constraintSource instanceof UniqueConstraintSource ) {
-				TableSpecification table = entityBinding.locateTable( constraintSource.getTableName() );
-				if ( table == null ) {
-					// throw exception !?
-				}
-				String constraintName = constraintSource.name();
-				if ( constraintName == null ) {
-					// create a default name
-				}
-
-				UniqueKey uniqueKey = table.getOrCreateUniqueKey( constraintName );
-				for ( String columnName : constraintSource.columnNames() ) {
-					uniqueKey.addColumn( table.locateOrCreateColumn( quoteIdentifier( columnName ) ) );
-				}
-			}
-		}
-	}
-
-	private void bindRelationalValues(
-			RelationalValueSourceContainer relationalValueSourceContainer,
-			SingularAttributeBinding attributeBinding) {
-
-		List<SimpleValueBinding> valueBindings = new ArrayList<SimpleValueBinding>();
-
-		if ( !relationalValueSourceContainer.relationalValueSources().isEmpty() ) {
-			for ( RelationalValueSource valueSource : relationalValueSourceContainer.relationalValueSources() ) {
-				final TableSpecification table = attributeBinding.getContainer()
-						.seekEntityBinding()
-						.locateTable( valueSource.getContainingTableName() );
-
-				if ( ColumnSource.class.isInstance( valueSource ) ) {
-					final ColumnSource columnSource = ColumnSource.class.cast( valueSource );
-					final Column column = makeColumn( (ColumnSource) valueSource, table );
-					valueBindings.add(
-							new SimpleValueBinding(
-									column,
-									columnSource.isIncludedInInsert(),
-									columnSource.isIncludedInUpdate()
-							)
-					);
-				}
-				else {
-					valueBindings.add(
-							new SimpleValueBinding(
-									makeDerivedValue( ( (DerivedValueSource) valueSource ), table )
-							)
-					);
-				}
-			}
-		}
-		else {
-			String name = metadata.getOptions()
-					.getNamingStrategy()
-					.propertyToColumnName( attributeBinding.getAttribute().getName() );
-			name = quoteIdentifier( name );
-			Column column = attributeBinding.getContainer()
-									.seekEntityBinding()
-									.getPrimaryTable()
-									.locateOrCreateColumn( name );
-			column.setNullable( relationalValueSourceContainer.areValuesNullableByDefault() );
-			valueBindings.add(
-					new SimpleValueBinding(
-							column,
-							relationalValueSourceContainer.areValuesIncludedInInsertByDefault(),
-							relationalValueSourceContainer.areValuesIncludedInUpdateByDefault()
-					)
-			);
-		}
-		attributeBinding.setSimpleValueBindings( valueBindings );
-	}
-
-	private String quoteIdentifier(String identifier) {
-		return currentBindingContext.isGloballyQuotedIdentifiers() ? StringHelper.quote( identifier ) : identifier;
-	}
-
-	private SimpleValue makeSimpleValue(
-			EntityBinding entityBinding,
-			RelationalValueSource valueSource) {
-		final TableSpecification table = entityBinding.locateTable( valueSource.getContainingTableName() );
-
-		if ( ColumnSource.class.isInstance( valueSource ) ) {
-			return makeColumn( (ColumnSource) valueSource, table );
-		}
-		else {
-			return makeDerivedValue( (DerivedValueSource) valueSource, table );
-		}
-	}
-
-	private Column makeColumn(ColumnSource columnSource, TableSpecification table) {
-		String name = columnSource.getName();
-		name = metadata.getOptions().getNamingStrategy().columnName( name );
-		name = quoteIdentifier( name );
-		final Column column = table.locateOrCreateColumn( name );
-		column.setNullable( columnSource.isNullable() );
-		column.setDefaultValue( columnSource.getDefaultValue() );
-		column.setSqlType( columnSource.getSqlType() );
-		column.setSize( columnSource.getSize() );
-		column.setDatatype( columnSource.getDatatype() );
-		column.setReadFragment( columnSource.getReadFragment() );
-		column.setWriteFragment( columnSource.getWriteFragment() );
-		column.setUnique( columnSource.isUnique() );
-		column.setCheckCondition( columnSource.getCheckCondition() );
-		column.setComment( columnSource.getComment() );
-		return column;
-	}
-
-	private DerivedValue makeDerivedValue(DerivedValueSource derivedValueSource, TableSpecification table) {
-		return table.locateOrCreateDerivedValue( derivedValueSource.getExpression() );
-	}
-
-	private void processFetchProfiles(EntitySource entitySource, EntityBinding entityBinding) {
-		// todo : process the entity-local fetch-profile declaration
-	}
-
-	private static class AttributeJavaTypeDeterminerDelegate implements BeanInfoHelper.BeanInfoDelegate {
-		private final String attributeName;
-		private Class<?> javaType = null;
-
-		private AttributeJavaTypeDeterminerDelegate(String attributeName) {
-			this.attributeName = attributeName;
-		}
-
-		@Override
-		public void processBeanInfo(BeanInfo beanInfo) throws Exception {
-			for ( PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors() ) {
-				if ( propertyDescriptor.getName().equals( attributeName ) ) {
-					javaType = propertyDescriptor.getPropertyType();
-					break;
-				}
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ColumnSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ColumnSource.java
deleted file mode 100644
index 3f86bd6b0f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ColumnSource.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.Size;
-
-/**
- * Contract for source information pertaining to a column definition.
- *
- * @author Steve Ebersole
- */
-public interface ColumnSource extends RelationalValueSource {
-	/**
-	 * Obtain the name of the column.
-	 *
-	 * @return The name of the column.  Can be {@code null}, in which case a naming strategy is applied.
-	 */
-	public String getName();
-
-	/**
-	 * A SQL fragment to apply to the column value on read.
-	 *
-	 * @return The SQL read fragment
-	 */
-	public String getReadFragment();
-
-	/**
-	 * A SQL fragment to apply to the column value on write.
-	 *
-	 * @return The SQL write fragment
-	 */
-	public String getWriteFragment();
-
-	/**
-	 * Is this column nullable?
-	 *
-	 * @return {@code true} indicates it is nullable; {@code false} non-nullable.
-	 */
-	public boolean isNullable();
-
-	/**
-	 * Obtain a specified default value for the column
-	 *
-	 * @return THe column default
-	 */
-	public String getDefaultValue();
-
-	/**
-	 * Obtain the free-hand definition of the column's type.
-	 *
-	 * @return The free-hand column type
-	 */
-	public String getSqlType();
-
-	/**
-	 * The deduced (and dialect convertible) type for this column
-	 *
-	 * @return The column's SQL data type.
-	 */
-	public Datatype getDatatype();
-
-	/**
-	 * Obtain the specified column size.
-	 *
-	 * @return The column size.
-	 */
-	public Size getSize();
-
-	/**
-	 * Is this column unique?
-	 *
-	 * @return {@code true} indicates it is unique; {@code false} non-unique.
-	 */
-	public boolean isUnique();
-
-	/**
-	 * Obtain the specified check constraint condition
-	 *
-	 * @return Check constraint condition
-	 */
-	public String getCheckCondition();
-
-	/**
-	 * Obtain the specified SQL comment
-	 *
-	 * @return SQL comment
-	 */
-	public String getComment();
-
-	public boolean isIncludedInInsert();
-
-	public boolean isIncludedInUpdate();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentAttributeSource.java
deleted file mode 100644
index a480489397..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentAttributeSource.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * @author Steve Ebersole
- */
-public interface ComponentAttributeSource extends SingularAttributeSource, AttributeSourceContainer {
-	public String getClassName();
-
-	public ValueHolder<Class<?>> getClassReference();
-
-	public String getParentReferenceAttributeName();
-
-	public String getExplicitTuplizerClassName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentIdentifierSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentIdentifierSource.java
deleted file mode 100644
index feb396751c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ComponentIdentifierSource.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Strong Liu
- */
-public interface ComponentIdentifierSource extends IdentifierSource {
-    /**
-     * Obtain the source descriptor for the identifier attribute.
-     *
-     * @return The identifier attribute source.
-     */
-    public ComponentAttributeSource getIdentifierAttributeSource();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/CompositePluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/CompositePluralAttributeElementSource.java
deleted file mode 100644
index 0965d93fc8..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/CompositePluralAttributeElementSource.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.internal.util.ValueHolder;
-
-/**
- * @author Steve Ebersole
- */
-public interface CompositePluralAttributeElementSource extends PluralAttributeElementSource, AttributeSourceContainer {
-	public String getClassName();
-
-	public ValueHolder<Class<?>> getClassReference();
-
-	public String getParentReferenceAttributeName();
-
-	public String getExplicitTuplizerClassName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ConstraintSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ConstraintSource.java
deleted file mode 100644
index 0f59e50fb3..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ConstraintSource.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract describing source of table constraints
- *
- * @author Hardy Ferentschik
- */
-public interface ConstraintSource {
-	/**
-	 * @return returns the name of the constraint or {@code null} in case a generated name should be used
-	 */
-	public String name();
-
-	/**
-	 * Obtain the logical name of the table for this constraint.
-	 *
-	 * @return The logical table name. Can be {@code null} in the case of the "primary table".
-	 */
-	public String getTableName();
-
-	/**
-	 * @return returns the names of the column which are part of this constraint
-	 */
-	Iterable<String> columnNames();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DerivedValueSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DerivedValueSource.java
deleted file mode 100644
index 85b2738c49..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DerivedValueSource.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract describing source of a derived value (formula).
- *
- * @author Steve Ebersole
- */
-public interface DerivedValueSource extends RelationalValueSource {
-	/**
-	 * Obtain the expression used to derive the value.
-	 *
-	 * @return The derived value expression.
-	 */
-	public String getExpression();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DiscriminatorSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DiscriminatorSource.java
deleted file mode 100644
index c2fcc9c927..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/DiscriminatorSource.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract for sources of information about a mapped discriminator.
- *
- * @author Hardy Ferentschik
- * @author Steve Ebersole
- */
-public interface DiscriminatorSource {
-	/**
-	 * Obtain the column/formula information about the discriminator.
-	 *
-	 * @return The column/formula information
-	 */
-	public RelationalValueSource getDiscriminatorRelationalValueSource();
-
-	/**
-	 * Obtain the discriminator type.  Unlike the type of attributes, implementors here should generally specify the type
-	 * in case of no user selection rather than return null because we cannot infer it from any physical java member.
-	 *
-	 * @return The discriminator type
-	 */
-	public String getExplicitHibernateTypeName();
-
-	/**
-	 * "Forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the
-	 * root class.
-	 *
-	 * @return {@code true} in case the discriminator value should be forces, {@code false} otherwise. Default
-	 * is {@code false}.
-	 */
-	boolean isForced();
-
-	/**
-	 * Set this to {@code false}, if your discriminator column is also part of a mapped composite identifier.
-	 * It tells Hibernate not to include the column in SQL INSERTs.
-	 *
-	 * @return {@code true} in case the discriminator value should be included in inserts, {@code false} otherwise.
-	 * Default is {@code true}.
-	 */
-	boolean isInserted();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntityHierarchy.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntityHierarchy.java
deleted file mode 100644
index fdfdf9ec4f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntityHierarchy.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.metamodel.binding.InheritanceType;
-
-/**
- * Models the source-agnostic view of an entity hierarchy.
- *
- * @author Steve Ebersole
- */
-public interface EntityHierarchy {
-	/**
-	 * The inheritance type/strategy for the hierarchy.
-	 * <p/>
-	 * NOTE : The entire hierarchy must comply with the same inheritance strategy.
-	 *
-	 * @return The inheritance type.
-	 */
-	public InheritanceType getHierarchyInheritanceType();
-
-	/**
-	 * Obtain the hierarchy's root entity.
-	 *
-	 * @return THe root entity.
-	 */
-	public RootEntitySource getRootEntitySource();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntitySource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntitySource.java
deleted file mode 100644
index f118d9c49e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/EntitySource.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.List;
-import javax.persistence.Entity;
-import javax.persistence.EntityListeners;
-import javax.persistence.MappedSuperclass;
-
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.source.LocalBindingContext;
-
-/**
- * Contract describing source of an entity
- *
- * @author Steve Ebersole
- */
-public interface EntitySource extends SubclassEntityContainer, AttributeSourceContainer {
-
-	/**
-	 * Obtain the origin of this source.
-	 *
-	 * @return The origin of this source.
-	 */
-	public Origin getOrigin();
-
-	/**
-	 * Obtain the binding context local to this entity source.
-	 *
-	 * @return The local binding context
-	 */
-	public LocalBindingContext getLocalBindingContext();
-
-	/**
-	 * Obtain the entity name
-	 *
-	 * @return The entity name
-	 */
-	public String getEntityName();
-
-	/**
-	 * Obtain the name of the entity {@link Class}
-	 *
-	 * @return THe entity class name
-	 */
-	public String getClassName();
-
-	/**
-	 * Obtain the JPA name of the entity
-	 *
-	 * @return THe JPA-specific entity name
-	 */
-	public String getJpaEntityName();
-
-	/**
-	 * Obtain the primary table for this entity.
-	 *
-	 * @return The primary table.
-	 */
-	public TableSource getPrimaryTable();
-
-	/**
-	 * Obtain the secondary tables for this entity
-	 *
-	 * @return returns an iterator over the secondary tables for this entity
-	 */
-	public Iterable<TableSource> getSecondaryTables();
-
-	/**
-	 * Obtain the name of a custom tuplizer class to be used.
-	 *
-	 * @return The custom tuplizer class name
-	 */
-	public String getCustomTuplizerClassName();
-
-	/**
-	 * Obtain the name of a custom persister class to be used.
-	 *
-	 * @return The custom persister class name
-	 */
-	public String getCustomPersisterClassName();
-
-	/**
-	 * Is this entity lazy (proxyable)?
-	 *
-	 * @return {@code true} indicates the entity is lazy; {@code false} non-lazy.
-	 */
-	public boolean isLazy();
-
-	/**
-	 * For {@link #isLazy() lazy} entities, obtain the interface to use in constructing its proxies.
-	 *
-	 * @return The proxy interface name
-	 */
-	public String getProxy();
-
-	/**
-	 * Obtain the batch-size to be applied when initializing proxies of this entity.
-	 *
-	 * @return returns the the batch-size.
-	 */
-	public int getBatchSize();
-
-	/**
-	 * Is the entity abstract?
-	 * <p/>
-	 * The implication is whether the entity maps to a database table.
-	 *
-	 * @return {@code true} indicates the entity is abstract; {@code false} non-abstract.
-	 */
-	public boolean isAbstract();
-
-	/**
-	 * Did the source specify dynamic inserts?
-	 *
-	 * @return {@code true} indicates dynamic inserts will be used; {@code false} otherwise.
-	 */
-	public boolean isDynamicInsert();
-
-	/**
-	 * Did the source specify dynamic updates?
-	 *
-	 * @return {@code true} indicates dynamic updates will be used; {@code false} otherwise.
-	 */
-	public boolean isDynamicUpdate();
-
-	/**
-	 * Did the source specify to perform selects to decide whether to perform (detached) updates?
-	 *
-	 * @return {@code true} indicates selects will be done; {@code false} otherwise.
-	 */
-	public boolean isSelectBeforeUpdate();
-
-	/**
-	 * Obtain the name of a named-query that will be used for loading this entity
-	 *
-	 * @return THe custom loader query name
-	 */
-	public String getCustomLoaderName();
-
-	/**
-	 * Obtain the custom SQL to be used for inserts for this entity
-	 *
-	 * @return The custom insert SQL
-	 */
-	public CustomSQL getCustomSqlInsert();
-
-	/**
-	 * Obtain the custom SQL to be used for updates for this entity
-	 *
-	 * @return The custom update SQL
-	 */
-	public CustomSQL getCustomSqlUpdate();
-
-	/**
-	 * Obtain the custom SQL to be used for deletes for this entity
-	 *
-	 * @return The custom delete SQL
-	 */
-	public CustomSQL getCustomSqlDelete();
-
-	/**
-	 * Obtain any additional table names on which to synchronize (auto flushing) this entity.
-	 *
-	 * @return Additional synchronized table names.
-	 */
-	public List<String> getSynchronizedTableNames();
-
-	/**
-	 * Obtain the meta-attribute sources associated with this entity.
-	 *
-	 * @return The meta-attribute sources.
-	 */
-	public Iterable<MetaAttributeSource> metaAttributes();
-
-	/**
-	 * Get the actual discriminator value in case of a single table inheritance
-	 *
-	 * @return the actual discriminator value in case of a single table inheritance or {@code null} in case there is no
-	 *         explicit value or a different inheritance scheme
-	 */
-	public String getDiscriminatorMatchValue();
-
-	/**
-	 * @return returns the source information for constraints defined on the table
-	 */
-	public Iterable<ConstraintSource> getConstraints();
-
-    /**
-     * @return the list of classes (this {@link Entity entity}/{@link MappedSuperclass mapped superclass}, or
-     *         {@link EntityListeners entity listeners}) that define JPA callbacks for this entity/mapped superclass.
-     */
-    List<JpaCallbackClass> getJpaCallbackClasses();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ExplicitHibernateTypeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ExplicitHibernateTypeSource.java
deleted file mode 100644
index c64fb0789c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ExplicitHibernateTypeSource.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.Map;
-
-/**
- * Source-agnostic descriptor for explicit user-supplied Hibernate type information
- *
- * @author Steve Ebersole
- */
-public interface ExplicitHibernateTypeSource {
-	/**
-	 * Obtain the supplied Hibernate type name.
-	 *
-	 * @return The Hibernate type name
-	 */
-	public String getName();
-
-	/**
-	 * Obtain any supplied Hibernate type parameters.
-	 *
-	 * @return The Hibernate type parameters.
-	 */
-	public Map<String,String> getParameters();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/IdentifierSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/IdentifierSource.java
deleted file mode 100644
index fe9a33d8e7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/IdentifierSource.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.metamodel.binding.IdGenerator;
-
-/**
- * Contract describing source of identifier information for the entity.
- *
- * @author Steve Ebersole
- */
-public interface IdentifierSource {
-    /**
-     * Obtain the identifier generator source.
-     *
-     * @return The generator source.
-     */
-    IdGenerator getIdentifierGeneratorDescriptor();
-
-    public static enum Nature {
-		/**
-		 * A single, simple identifier.  Equivalent of an {@code <id/>} mapping or a single {@code @Id}
-		 * annotation.  Indicates the {@link IdentifierSource} is castable to {@link SimpleIdentifierSource}.
-		 */
-		SIMPLE,
-
-		/**
-		 * What we used to term an "embedded composite identifier", which is not to be confused with the JPA
-		 * term embedded.  Specifically a composite id where there is no component class, though there may be an
-		 * {@code @IdClass}.
-		 */
-		COMPOSITE,
-
-		/**
-		 * Composite identifier with an actual component class used to aggregate the individual attributes
-		 */
-		AGGREGATED_COMPOSITE
-	}
-
-	/**
-	 * Obtain the nature of this identifier source.
-	 *
-	 * @return The identifier source's nature.
-	 */
-	public Nature getNature();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/JpaCallbackClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/JpaCallbackClass.java
deleted file mode 100644
index 5101befc4a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/JpaCallbackClass.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import javax.persistence.Entity;
-import javax.persistence.EntityListeners;
-import javax.persistence.MappedSuperclass;
-import javax.persistence.PostLoad;
-import javax.persistence.PostPersist;
-import javax.persistence.PostRemove;
-import javax.persistence.PostUpdate;
-import javax.persistence.PrePersist;
-import javax.persistence.PreRemove;
-import javax.persistence.PreUpdate;
-
-public interface JpaCallbackClass {
-
-    /**
-     * @param callbackType {@link PrePersist}, {@link PreRemove}, {@link PreUpdate}, {@link PostLoad},
-     *        {@link PostPersist}, {@link PostRemove}, or {@link PostUpdate}
-     * @return the name of the JPA callback method defined for the associated {@link Entity entity} or {@link MappedSuperclass
-     *         mapped superclass} and for the supplied callback annotation class.
-     */
-    String getCallbackMethod(Class<?> callbackType);
-
-    /**
-     * @return the name of the instantiated container where the JPA callbacks for the associated {@link Entity entity} or
-     *         {@link MappedSuperclass mapped superclass} are defined. This can be either the entity/mapped superclass itself or an
-     *         {@link EntityListeners entity listener}.
-     */
-    String getName();
-
-    /**
-     * @return <code>true</code> if this callback class represents callbacks defined within an {@link EntityListeners entity
-     *         listener}.
-     */
-    boolean isListener();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToAnyPluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToAnyPluralAttributeElementSource.java
deleted file mode 100644
index 89d49a8a05..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToAnyPluralAttributeElementSource.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface ManyToAnyPluralAttributeElementSource extends PluralAttributeElementSource {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToManyPluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToManyPluralAttributeElementSource.java
deleted file mode 100644
index e1c9cfb8ae..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ManyToManyPluralAttributeElementSource.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.List;
-
-import org.hibernate.FetchMode;
-
-/**
- * @author Steve Ebersole
- */
-public interface ManyToManyPluralAttributeElementSource extends PluralAttributeElementSource {
-	public String getReferencedEntityName();
-	public String getReferencedEntityAttributeName();
-
-	public List<RelationalValueSource> getValueSources(); // these describe the "outgoing" link
-
-	public boolean isNotFoundAnException();
-	public String getExplicitForeignKeyName();
-	public boolean isUnique();
-
-	public String getOrderBy();
-	public String getWhere();
-
-	public FetchMode getFetchMode();
-	public boolean fetchImmediately();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/MetaAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/MetaAttributeSource.java
deleted file mode 100644
index ab44fc4a23..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/MetaAttributeSource.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Describes incoming {@link org.hibernate.mapping.MetaAttribute} values.  This is only from {@code hbm} via the
- * {@code <meta/>} element(s).
- *
- * @author Steve Ebersole
- */
-public interface MetaAttributeSource {
-	/**
-	 * Obtain the supplied meta-attribute name
-	 *
-	 * @return The meta-attribute name
-	 */
-	public String getName();
-
-	/**
-	 * Obtain the supplied meta-attribute value.
-	 *
-	 * @return The meta-attribute value
-	 */
-	public String getValue();
-
-	/**
-	 * Is the meta-attribute value inheritable?
-	 *
-	 * @return Is the value inheritable?
-	 */
-	public boolean isInheritable();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/OneToManyPluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/OneToManyPluralAttributeElementSource.java
deleted file mode 100644
index aecc755706..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/OneToManyPluralAttributeElementSource.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface OneToManyPluralAttributeElementSource extends PluralAttributeElementSource {
-	public String getReferencedEntityName();
-	public boolean isNotFoundAnException();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Orderable.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Orderable.java
deleted file mode 100644
index 115f67aef9..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Orderable.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface Orderable {
-	public boolean isOrdered();
-	public String getOrder();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementNature.java
deleted file mode 100644
index 0e063a3b90..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementNature.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Describes the nature of the collection elements as declared by the metadata.
- *
- * @author Steve Ebersole
- */
-public enum PluralAttributeElementNature {
-	BASIC,
-	COMPONENT,
-	ONE_TO_MANY,
-	MANY_TO_MANY,
-	MANY_TO_ANY
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementSource.java
deleted file mode 100644
index aeb60a31ea..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeElementSource.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface PluralAttributeElementSource {
-	public PluralAttributeElementNature getNature();
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeKeySource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeKeySource.java
deleted file mode 100644
index 815a7828fa..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeKeySource.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.List;
-
-import org.hibernate.metamodel.relational.ForeignKey;
-
-/**
- * @author Steve Ebersole
- */
-public interface PluralAttributeKeySource {
-	public List<RelationalValueSource> getValueSources();
-	public String getExplicitForeignKeyName();
-	public ForeignKey.ReferentialAction getOnDeleteAction();
-	public String getReferencedEntityAttributeName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeNature.java
deleted file mode 100644
index 9c766e0735..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeNature.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Describes the nature of the collection itself as declared by the metadata.
- *
- * @author Steve Ebersole
- */
-public enum PluralAttributeNature {
-	BAG( Collection.class ),
-	ID_BAG( Collection.class ),
-	SET( Set.class ),
-	LIST( List.class ),
-	MAP( Map.class );
-
-	private final Class<?> reportedJavaType;
-
-	PluralAttributeNature(Class<?> reportedJavaType) {
-		this.reportedJavaType = reportedJavaType;
-	}
-
-	public Class<?> reportedJavaType() {
-		return reportedJavaType;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeSource.java
deleted file mode 100644
index 2f19b86b61..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/PluralAttributeSource.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.CustomSQL;
-
-/**
- * @author Steve Ebersole
- */
-public interface PluralAttributeSource extends AssociationAttributeSource {
-	public PluralAttributeNature getPluralAttributeNature();
-
-	public PluralAttributeKeySource getKeySource();
-
-	public PluralAttributeElementSource getElementSource();
-
-	public String getExplicitSchemaName();
-	public String getExplicitCatalogName();
-	public String getExplicitCollectionTableName();
-
-	public String getCollectionTableComment();
-	public String getCollectionTableCheck();
-
-	public Caching getCaching();
-
-	/**
-	 * Obtain the name of a custom persister class to be used.
-	 *
-	 * @return The custom persister class name
-	 */
-	public String getCustomPersisterClassName();
-
-	public String getWhere();
-
-	public boolean isInverse();
-
-	public String getCustomLoaderName();
-
-	public CustomSQL getCustomSqlInsert();
-
-	public CustomSQL getCustomSqlUpdate();
-
-	public CustomSQL getCustomSqlDelete();
-
-	public CustomSQL getCustomSqlDeleteAll();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSource.java
deleted file mode 100644
index 8fd839220a..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSource.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Unifying interface for {@link ColumnSource} and {@link DerivedValueSource}.
- *
- * @author Steve Ebersole
- * @see ColumnSource
- * @see DerivedValueSource
- */
-public interface RelationalValueSource {
-	/**
-	 * @return returns the name of the table that contains this value.
-	 */
-	public String getContainingTableName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSourceContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSourceContainer.java
deleted file mode 100644
index 5a167f44e0..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RelationalValueSourceContainer.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import java.util.List;
-
-/**
- * Contract for a container of {@link RelationalValueSource} references.
- *
- * @author Steve Ebersole
- */
-public interface RelationalValueSourceContainer {
-	public boolean areValuesIncludedInInsertByDefault();
-
-	public boolean areValuesIncludedInUpdateByDefault();
-
-	public boolean areValuesNullableByDefault();
-
-	/**
-	 * Obtain the contained {@link RelationalValueSource} references.
-	 *
-	 * @return The contained {@link RelationalValueSource} references.
-	 */
-	public List<RelationalValueSource> relationalValueSources();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RootEntitySource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RootEntitySource.java
deleted file mode 100644
index 6d18eccd02..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/RootEntitySource.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.EntityMode;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.metamodel.binding.Caching;
-
-/**
- * Contract for the entity that is the root of an inheritance hierarchy.
- * <p/>
- * <b>NOTE</b> : I think most of this could be moved to {@link EntityHierarchy} much like was done with
- * {@link org.hibernate.metamodel.binding.HierarchyDetails}
- *
- * @author Steve Ebersole
- *
- * @todo Move these concepts to {@link EntityHierarchy} ?
- */
-public interface RootEntitySource extends EntitySource {
-	/**
-	 * Obtain source information about this entity's identifier.
-	 *
-	 * @return Identifier source information.
-	 */
-	public IdentifierSource getIdentifierSource();
-
-	/**
-	 * Obtain the source information about the attribute used for versioning.
-	 *
-	 * @return the source information about the attribute used for versioning
-	 */
-	public SingularAttributeSource getVersioningAttributeSource();
-
-	/**
-	 * Obtain the source information about the discriminator attribute for single table inheritance
-	 *
-	 * @return the source information about the discriminator attribute for single table inheritance
-	 */
-	public DiscriminatorSource getDiscriminatorSource();
-
-	/**
-	 * Obtain the entity mode for this entity.
-	 *
-	 * @return The entity mode.
-	 */
-	public EntityMode getEntityMode();
-
-	/**
-	 * Is this root entity mutable?
-	 *
-	 * @return {@code true} indicates mutable; {@code false} non-mutable.
-	 */
-	public boolean isMutable();
-
-	/**
-	 * Should explicit polymorphism (querying) be applied to this entity?
-	 *
-	 * @return {@code true} indicates explicit polymorphism; {@code false} implicit.
-	 */
-	public boolean isExplicitPolymorphism();
-
-	/**
-	 * Obtain the specified extra where condition to be applied to this entity.
-	 *
-	 * @return The extra where condition
-	 */
-	public String getWhere();
-
-	/**
-	 * Obtain the row-id name for this entity
-	 *
-	 * @return The row-id name
-	 */
-	public String getRowId();
-
-	/**
-	 * Obtain the optimistic locking style for this entity.
-	 *
-	 * @return The optimistic locking style.
-	 */
-	public OptimisticLockStyle getOptimisticLockStyle();
-
-	/**
-	 * Obtain the caching configuration for this entity.
-	 *
-	 * @return The caching configuration.
-	 */
-	public Caching getCaching();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SimpleIdentifierSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SimpleIdentifierSource.java
deleted file mode 100644
index 90585ae216..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SimpleIdentifierSource.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract describing source of a simple identifier mapping.
- *
- * @author Steve Ebersole
- */
-public interface SimpleIdentifierSource extends IdentifierSource {
-	/**
-	 * Obtain the source descriptor for the identifier attribute.
-	 *
-	 * @return The identifier attribute source.
-	 */
-	public SingularAttributeSource getIdentifierAttributeSource();
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeNature.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeNature.java
deleted file mode 100644
index b620838605..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeNature.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Describes the understood natures of a singular attribute.
- *
- * @author Steve Ebersole
- */
-public enum SingularAttributeNature {
-	BASIC,
-	COMPONENT,
-	MANY_TO_ONE,
-	ONE_TO_ONE,
-	ANY
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeSource.java
deleted file mode 100644
index 33978afb0f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SingularAttributeSource.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-import org.hibernate.mapping.PropertyGeneration;
-
-/**
- * Source-agnostic description of information needed to bind a singular attribute.
- *
- * @author Steve Ebersole
- */
-public interface SingularAttributeSource extends AttributeSource, RelationalValueSourceContainer {
-	/**
-	 * Determine whether this is a virtual attribute or whether it physically exists on the users domain model.
-	 *
-	 * @return {@code true} indicates the attribute is virtual, meaning it does NOT exist on the domain model;
-	 *         {@code false} indicates the attribute physically exists.
-	 */
-	public boolean isVirtualAttribute();
-
-	/**
-	 * Obtain the nature of this attribute type.
-	 *
-	 * @return The attribute type nature
-	 */
-	public SingularAttributeNature getNature();
-
-	/**
-	 * Determine whether this attribute is insertable.
-	 *
-	 * @return {@code true} indicates the attribute value should be used in the {@code SQL INSERT}; {@code false}
-	 *         indicates it should not.
-	 */
-	public boolean isInsertable();
-
-	/**
-	 * Determine whether this attribute is updateable.
-	 *
-	 * @return {@code true} indicates the attribute value should be used in the {@code SQL UPDATE}; {@code false}
-	 *         indicates it should not.
-	 */
-	public boolean isUpdatable();
-
-	/**
-	 * Obtain a description of if/when the attribute value is generated by the database.
-	 *
-	 * @return The attribute value generation information
-	 */
-	public PropertyGeneration getGeneration();
-
-	/**
-	 * Should the attribute be (bytecode enhancement) lazily loaded?
-	 *
-	 * @return {@code true} to indicate the attribute should be lazily loaded.
-	 */
-	public boolean isLazy();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Sortable.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Sortable.java
deleted file mode 100644
index cba0da7996..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/Sortable.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface Sortable {
-	public boolean isSorted();
-	public String getComparatorName();
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntityContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntityContainer.java
deleted file mode 100644
index a73a9ed283..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntityContainer.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract for elements within a {@link EntityHierarchy} which can contain sub elements.  Essentially this
- * abstracts that common aspect away from both root and sub entities.
- *
- * @author Steve Ebersole
- */
-public interface SubclassEntityContainer {
-	public void add(SubclassEntitySource subclassEntitySource);
-	public Iterable<SubclassEntitySource> subclassEntitySources();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntitySource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntitySource.java
deleted file mode 100644
index 636226758e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/SubclassEntitySource.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * @author Steve Ebersole
- */
-public interface SubclassEntitySource extends EntitySource {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/TableSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/TableSource.java
deleted file mode 100644
index ff18012e29..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/TableSource.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Contract describing source of table information
- *
- * @author Steve Ebersole
- */
-public interface TableSource {
-	/**
-	 * Obtain the supplied schema name
-	 *
-	 * @return The schema name. If {@code null}, the binder will apply the default.
-	 */
-	public String getExplicitSchemaName();
-
-	/**
-	 * Obtain the supplied catalog name
-	 *
-	 * @return The catalog name. If {@code null}, the binder will apply the default.
-	 */
-	public String getExplicitCatalogName();
-
-	/**
-	 * Obtain the supplied table name.
-	 *
-	 * @return The table name.
-	 */
-	public String getExplicitTableName();
-
-	/**
-	 * Obtain the logical name of the table.  This value is used to uniquely reference the table when binding
-	 * values to the binding model.
-	 *
-	 * @return The logical name. Can be {@code null} in the case of the "primary table".
-	 *
-	 * @see RelationalValueSource#getContainingTableName()
-	 */
-	public String getLogicalName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ToOneAttributeSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ToOneAttributeSource.java
deleted file mode 100644
index 91d408037d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/ToOneAttributeSource.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Further contract for sources of {@code *-to-one} style associations.
- *
- * @author Steve Ebersole
- */
-public interface ToOneAttributeSource extends SingularAttributeSource, AssociationAttributeSource {
-	/**
-	 * Obtain the name of the referenced entity.
-	 *
-	 * @return The name of the referenced entity
-	 */
-	public String getReferencedEntityName();
-
-	/**
-	 * Obtain the name of the referenced attribute.  Typically the reference is built based on the identifier
-	 * attribute of the {@link #getReferencedEntityName() referenced entity}, but this value allows using a different
-	 * attribute instead.
-	 *
-	 * @return The name of the referenced attribute; {@code null} indicates the identifier attribute.
-	 */
-	public String getReferencedEntityAttributeName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/UniqueConstraintSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/UniqueConstraintSource.java
deleted file mode 100644
index 0a247b09cf..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/binder/UniqueConstraintSource.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.binder;
-
-/**
- * Defining a unique constraint source
- *
- * @author Hardy Ferentschik
- */
-public interface UniqueConstraintSource extends ConstraintSource {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractEntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractEntitySourceImpl.java
deleted file mode 100644
index 32877a0385..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractEntitySourceImpl.java
+++ /dev/null
@@ -1,311 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.EntityMode;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbAnyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbBagElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbComponentElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbIdbagElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbListElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbManyToOneElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbMapElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbOneToOneElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbPropertyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSetElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSynchronizeElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbTuplizerElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.AttributeSource;
-import org.hibernate.metamodel.source.binder.ConstraintSource;
-import org.hibernate.metamodel.source.binder.EntitySource;
-import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-import org.hibernate.metamodel.source.binder.TableSource;
-
-/**
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public abstract class AbstractEntitySourceImpl implements EntitySource {
-	private final MappingDocument sourceMappingDocument;
-	private final EntityElement entityElement;
-
-	private List<SubclassEntitySource> subclassEntitySources = new ArrayList<SubclassEntitySource>();
-
-	protected AbstractEntitySourceImpl(MappingDocument sourceMappingDocument, EntityElement entityElement) {
-		this.sourceMappingDocument = sourceMappingDocument;
-		this.entityElement = entityElement;
-	}
-
-	protected EntityElement entityElement() {
-		return entityElement;
-	}
-
-	protected MappingDocument sourceMappingDocument() {
-		return sourceMappingDocument;
-	}
-
-	@Override
-	public Origin getOrigin() {
-		return sourceMappingDocument.getOrigin();
-	}
-
-	@Override
-	public LocalBindingContext getLocalBindingContext() {
-		return sourceMappingDocument.getMappingLocalBindingContext();
-	}
-
-	@Override
-	public String getEntityName() {
-		return StringHelper.isNotEmpty( entityElement.getEntityName() )
-				? entityElement.getEntityName()
-				: getClassName();
-	}
-
-	@Override
-	public String getClassName() {
-		return getLocalBindingContext().qualifyClassName( entityElement.getName() );
-	}
-
-	@Override
-	public String getJpaEntityName() {
-		return null;
-	}
-
-	@Override
-	public boolean isAbstract() {
-		return Helper.getBooleanValue( entityElement.isAbstract(), false );
-	}
-
-	@Override
-	public boolean isLazy() {
-		return Helper.getBooleanValue( entityElement.isAbstract(), true );
-	}
-
-	@Override
-	public String getProxy() {
-		return entityElement.getProxy();
-	}
-
-	@Override
-	public int getBatchSize() {
-		return Helper.getIntValue( entityElement.getBatchSize(), -1 );
-	}
-
-	@Override
-	public boolean isDynamicInsert() {
-		return entityElement.isDynamicInsert();
-	}
-
-	@Override
-	public boolean isDynamicUpdate() {
-		return entityElement.isDynamicUpdate();
-	}
-
-	@Override
-	public boolean isSelectBeforeUpdate() {
-		return entityElement.isSelectBeforeUpdate();
-	}
-
-	protected EntityMode determineEntityMode() {
-		return StringHelper.isNotEmpty( getClassName() ) ? EntityMode.POJO : EntityMode.MAP;
-	}
-
-	@Override
-	public String getCustomTuplizerClassName() {
-		if ( entityElement.getTuplizer() == null ) {
-			return null;
-		}
-		final EntityMode entityMode = determineEntityMode();
-		for ( JaxbTuplizerElement tuplizerElement : entityElement.getTuplizer() ) {
-			if ( entityMode == EntityMode.parse( tuplizerElement.getEntityMode() ) ) {
-				return tuplizerElement.getClazz();
-			}
-		}
-		return null;
-	}
-
-	@Override
-	public String getCustomPersisterClassName() {
-		return getLocalBindingContext().qualifyClassName( entityElement.getPersister() );
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return entityElement.getLoader() != null ? entityElement.getLoader().getQueryRef() : null;
-	}
-
-	@Override
-	public CustomSQL getCustomSqlInsert() {
-		return Helper.buildCustomSql( entityElement.getSqlInsert() );
-	}
-
-	@Override
-	public CustomSQL getCustomSqlUpdate() {
-		return Helper.buildCustomSql( entityElement.getSqlUpdate() );
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDelete() {
-		return Helper.buildCustomSql( entityElement.getSqlDelete() );
-	}
-
-	@Override
-	public List<String> getSynchronizedTableNames() {
-		List<String> tableNames = new ArrayList<String>();
-		for ( JaxbSynchronizeElement synchronizeElement : entityElement.getSynchronize() ) {
-			tableNames.add( synchronizeElement.getTable() );
-		}
-		return tableNames;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( entityElement.getMeta() );
-	}
-
-	@Override
-	public String getPath() {
-		return sourceMappingDocument.getMappingLocalBindingContext().determineEntityName( entityElement );
-	}
-
-	@Override
-	public Iterable<AttributeSource> attributeSources() {
-		List<AttributeSource> attributeSources = new ArrayList<AttributeSource>();
-		for ( Object attributeElement : entityElement.getPropertyOrManyToOneOrOneToOne() ) {
-			if ( JaxbPropertyElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new PropertyAttributeSourceImpl(
-								JaxbPropertyElement.class.cast( attributeElement ),
-								sourceMappingDocument().getMappingLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbComponentElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new ComponentAttributeSourceImpl(
-								(JaxbComponentElement) attributeElement,
-								this,
-								sourceMappingDocument.getMappingLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbManyToOneElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new ManyToOneAttributeSourceImpl(
-								JaxbManyToOneElement.class.cast( attributeElement ),
-								sourceMappingDocument().getMappingLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbOneToOneElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbAnyElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbBagElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new BagAttributeSourceImpl(
-								JaxbBagElement.class.cast( attributeElement ),
-								this
-						)
-				);
-			}
-			else if ( JaxbIdbagElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbSetElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new SetAttributeSourceImpl(
-								JaxbSetElement.class.cast( attributeElement ),
-								this
-						)
-				);
-			}
-			else if ( JaxbListElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbMapElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else {
-				throw new AssertionFailure( "Unexpected attribute element type encountered : " + attributeElement.getClass() );
-			}
-		}
-		return attributeSources;
-	}
-
-	private EntityHierarchyImpl entityHierarchy;
-
-	public void injectHierarchy(EntityHierarchyImpl entityHierarchy) {
-		this.entityHierarchy = entityHierarchy;
-	}
-
-	@Override
-	public void add(SubclassEntitySource subclassEntitySource) {
-		add( (SubclassEntitySourceImpl) subclassEntitySource );
-	}
-
-	public void add(SubclassEntitySourceImpl subclassEntitySource) {
-		entityHierarchy.processSubclass( subclassEntitySource );
-		subclassEntitySources.add( subclassEntitySource );
-	}
-
-	@Override
-	public Iterable<SubclassEntitySource> subclassEntitySources() {
-		return subclassEntitySources;
-	}
-
-	@Override
-	public String getDiscriminatorMatchValue() {
-		return null;
-	}
-
-	@Override
-	public Iterable<ConstraintSource> getConstraints() {
-		return Collections.emptySet();
-	}
-
-	@Override
-	public Iterable<TableSource> getSecondaryTables() {
-		return Collections.emptySet();
-	}
-
-	@Override
-	public List<JpaCallbackClass> getJpaCallbackClasses() {
-	    return Collections.EMPTY_LIST;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractPluralAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractPluralAttributeSourceImpl.java
deleted file mode 100644
index c39dfc0833..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractPluralAttributeSourceImpl.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.Collections;
-import java.util.Map;
-
-import org.hibernate.FetchMode;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbCacheElement;
-import org.hibernate.internal.jaxb.mapping.hbm.PluralAttributeElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.AttributeSourceContainer;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeElementSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeKeySource;
-import org.hibernate.metamodel.source.binder.PluralAttributeSource;
-
-/**
- * @author Steve Ebersole
- */
-public abstract class AbstractPluralAttributeSourceImpl implements PluralAttributeSource {
-	private final PluralAttributeElement pluralAttributeElement;
-	private final AttributeSourceContainer container;
-
-	private final ExplicitHibernateTypeSource typeInformation;
-
-	private final PluralAttributeKeySource keySource;
-	private final PluralAttributeElementSource elementSource;
-
-	protected AbstractPluralAttributeSourceImpl(
-			final PluralAttributeElement pluralAttributeElement,
-			AttributeSourceContainer container) {
-		this.pluralAttributeElement = pluralAttributeElement;
-		this.container = container;
-
-		this.keySource = new PluralAttributeKeySourceImpl( pluralAttributeElement.getKey(), container );
-		this.elementSource = interpretElementType();
-
-		this.typeInformation = new ExplicitHibernateTypeSource() {
-			@Override
-			public String getName() {
-				return pluralAttributeElement.getCollectionType();
-			}
-
-			@Override
-			public Map<String, String> getParameters() {
-				return Collections.emptyMap();
-			}
-		};
-	}
-
-	private PluralAttributeElementSource interpretElementType() {
-		if ( pluralAttributeElement.getElement() != null ) {
-			return new BasicPluralAttributeElementSourceImpl(
-					pluralAttributeElement.getElement(), container.getLocalBindingContext()
-			);
-		}
-		else if ( pluralAttributeElement.getCompositeElement() != null ) {
-			return new CompositePluralAttributeElementSourceImpl(
-					pluralAttributeElement.getCompositeElement(), container.getLocalBindingContext()
-			);
-		}
-		else if ( pluralAttributeElement.getOneToMany() != null ) {
-			return new OneToManyPluralAttributeElementSourceImpl(
-					pluralAttributeElement.getOneToMany(), container.getLocalBindingContext()
-			);
-		}
-		else if ( pluralAttributeElement.getManyToMany() != null ) {
-			return new ManyToManyPluralAttributeElementSourceImpl(
-					pluralAttributeElement.getManyToMany(), container.getLocalBindingContext()
-			);
-		}
-		else if ( pluralAttributeElement.getManyToAny() != null ) {
-			throw new NotYetImplementedException( "Support for many-to-any not yet implemented" );
-//			return PluralAttributeElementNature.MANY_TO_ANY;
-		}
-		else {
-			throw new MappingException(
-					"Unexpected collection element type : " + pluralAttributeElement.getName(),
-					bindingContext().getOrigin()
-			);
-		}
-	}
-
-	public PluralAttributeElement getPluralAttributeElement() {
-		return pluralAttributeElement;
-	}
-
-	protected AttributeSourceContainer container() {
-		return container;
-	}
-
-	protected LocalBindingContext bindingContext() {
-		return container().getLocalBindingContext();
-	}
-
-	@Override
-	public PluralAttributeKeySource getKeySource() {
-		return keySource;
-	}
-
-	@Override
-	public PluralAttributeElementSource getElementSource() {
-		return elementSource;
-	}
-
-	@Override
-	public String getExplicitSchemaName() {
-		return pluralAttributeElement.getSchema();
-	}
-
-	@Override
-	public String getExplicitCatalogName() {
-		return pluralAttributeElement.getCatalog();
-	}
-
-	@Override
-	public String getExplicitCollectionTableName() {
-		return pluralAttributeElement.getTable();
-	}
-
-	@Override
-	public String getCollectionTableComment() {
-		return pluralAttributeElement.getComment();
-	}
-
-	@Override
-	public String getCollectionTableCheck() {
-		return pluralAttributeElement.getCheck();
-	}
-
-	@Override
-	public Caching getCaching() {
-		final JaxbCacheElement cache = pluralAttributeElement.getCache();
-		if ( cache == null ) {
-			return null;
-		}
-		final String region = cache.getRegion() != null
-				? cache.getRegion()
-				: StringHelper.qualify( container().getPath(), getName() );
-		final AccessType accessType = Enum.valueOf( AccessType.class, cache.getUsage() );
-		final boolean cacheLazyProps = !"non-lazy".equals( cache.getInclude() );
-		return new Caching( region, accessType, cacheLazyProps );
-	}
-
-	@Override
-	public String getWhere() {
-		return pluralAttributeElement.getWhere();
-	}
-
-	@Override
-	public String getName() {
-		return pluralAttributeElement.getName();
-	}
-
-	@Override
-	public boolean isSingular() {
-		return false;
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return typeInformation;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return pluralAttributeElement.getAccess();
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return pluralAttributeElement.isOptimisticLock();
-	}
-
-	@Override
-	public boolean isInverse() {
-		return pluralAttributeElement.isInverse();
-	}
-
-	@Override
-	public String getCustomPersisterClassName() {
-		return pluralAttributeElement.getPersister();
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return pluralAttributeElement.getLoader() == null
-				? null
-				: pluralAttributeElement.getLoader().getQueryRef();
-	}
-
-	@Override
-	public CustomSQL getCustomSqlInsert() {
-		return Helper.buildCustomSql( pluralAttributeElement.getSqlInsert() );
-	}
-
-	@Override
-	public CustomSQL getCustomSqlUpdate() {
-		return Helper.buildCustomSql( pluralAttributeElement.getSqlUpdate() );
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDelete() {
-		return Helper.buildCustomSql( pluralAttributeElement.getSqlDelete() );
-	}
-
-	@Override
-	public CustomSQL getCustomSqlDeleteAll() {
-		return Helper.buildCustomSql( pluralAttributeElement.getSqlDeleteAll() );
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( pluralAttributeElement.getMeta() );
-	}
-
-	@Override
-	public Iterable<CascadeStyle> getCascadeStyles() {
-		return Helper.interpretCascadeStyles( pluralAttributeElement.getCascade(), bindingContext() );
-	}
-
-	@Override
-	public FetchTiming getFetchTiming() {
-		final String fetchSelection = pluralAttributeElement.getFetch() != null ?
-				pluralAttributeElement.getFetch().value() :
-				null;
-		final String lazySelection = pluralAttributeElement.getLazy() != null
-				? pluralAttributeElement.getLazy().value()
-				: null;
-		final String outerJoinSelection = pluralAttributeElement.getOuterJoin() != null
-				? pluralAttributeElement.getOuterJoin().value()
-				: null;
-
-		if ( lazySelection == null ) {
-			if ( "join".equals( fetchSelection ) || "true".equals( outerJoinSelection ) ) {
-				return FetchTiming.IMMEDIATE;
-			}
-			else if ( "false".equals( outerJoinSelection ) ) {
-				return FetchTiming.DELAYED;
-			}
-			else {
-				return bindingContext().getMappingDefaults().areAssociationsLazy()
-						? FetchTiming.DELAYED
-						: FetchTiming.IMMEDIATE;
-			}
-		}
-		else  if ( "extra".equals( lazySelection ) ) {
-			return FetchTiming.EXTRA_LAZY;
-		}
-		else if ( "true".equals( lazySelection ) ) {
-			return FetchTiming.DELAYED;
-		}
-		else if ( "false".equals( lazySelection ) ) {
-			return FetchTiming.IMMEDIATE;
-		}
-
-		throw new MappingException(
-				String.format(
-						"Unexpected lazy selection [%s] on '%s'",
-						lazySelection,
-						pluralAttributeElement.getName()
-				),
-				bindingContext().getOrigin()
-		);
-	}
-
-	@Override
-	public FetchStyle getFetchStyle() {
-		final String fetchSelection = pluralAttributeElement.getFetch() != null ?
-				pluralAttributeElement.getFetch().value() :
-				null;
-		final String outerJoinSelection = pluralAttributeElement.getOuterJoin() != null
-				? pluralAttributeElement.getOuterJoin().value()
-				: null;
-		final int batchSize = Helper.getIntValue( pluralAttributeElement.getBatchSize(), -1 );
-
-		if ( fetchSelection == null ) {
-			if ( outerJoinSelection == null ) {
-				return batchSize > 1 ? FetchStyle.BATCH : FetchStyle.SELECT;
-			}
-			else {
-				if ( "auto".equals( outerJoinSelection ) ) {
-					return bindingContext().getMappingDefaults().areAssociationsLazy()
-							? FetchStyle.SELECT
-							: FetchStyle.JOIN;
-				}
-				else {
-					return "true".equals( outerJoinSelection ) ? FetchStyle.JOIN : FetchStyle.SELECT;
-				}
-			}
-		}
-		else {
-			if ( "subselect".equals( fetchSelection ) ) {
-				return FetchStyle.SUBSELECT;
-			}
-			else {
-				return "join".equals( fetchSelection ) ? FetchStyle.JOIN : FetchStyle.SELECT;
-			}
-		}
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		return pluralAttributeElement.getFetch() == null
-				? FetchMode.DEFAULT
-				: FetchMode.valueOf( pluralAttributeElement.getFetch().value() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BagAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BagAttributeSourceImpl.java
deleted file mode 100644
index 4c29db82ab..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BagAttributeSourceImpl.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbBagElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.binder.AttributeSourceContainer;
-import org.hibernate.metamodel.source.binder.Orderable;
-import org.hibernate.metamodel.source.binder.PluralAttributeNature;
-
-/**
- * @author Steve Ebersole
- */
-public class BagAttributeSourceImpl extends AbstractPluralAttributeSourceImpl implements Orderable {
-	public BagAttributeSourceImpl(JaxbBagElement bagElement, AttributeSourceContainer container) {
-		super( bagElement, container );
-	}
-
-	@Override
-	public PluralAttributeNature getPluralAttributeNature() {
-		return PluralAttributeNature.BAG;
-	}
-
-	@Override
-	public JaxbBagElement getPluralAttributeElement() {
-		return (JaxbBagElement) super.getPluralAttributeElement();
-	}
-
-	@Override
-	public boolean isOrdered() {
-		return StringHelper.isNotEmpty( getOrder() );
-	}
-
-	@Override
-	public String getOrder() {
-		return getPluralAttributeElement().getOrderBy();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BasicPluralAttributeElementSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BasicPluralAttributeElementSourceImpl.java
deleted file mode 100644
index 355117b0c5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BasicPluralAttributeElementSourceImpl.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbElementElement;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.BasicPluralAttributeElementSource;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeElementNature;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-
-/**
- * @author Steve Ebersole
- */
-public class BasicPluralAttributeElementSourceImpl implements BasicPluralAttributeElementSource {
-	private final List<RelationalValueSource> valueSources;
-	private final ExplicitHibernateTypeSource typeSource;
-
-	public BasicPluralAttributeElementSourceImpl(
-			final JaxbElementElement elementElement,
-			LocalBindingContext bindingContext) {
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getContainingTableName() {
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return true;
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return true;
-					}
-
-					@Override
-					public String getColumnAttribute() {
-						return elementElement.getColumn();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return elementElement.getFormula();
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return elementElement.getColumnOrFormula();
-					}
-				},
-				bindingContext
-		);
-
-		this.typeSource = new ExplicitHibernateTypeSource() {
-			@Override
-			public String getName() {
-				if ( elementElement.getTypeAttribute() != null ) {
-					return elementElement.getTypeAttribute();
-				}
-				else if ( elementElement.getType() != null ) {
-					return elementElement.getType().getName();
-				}
-				else {
-					return null;
-				}
-			}
-
-			@Override
-			public Map<String, String> getParameters() {
-				return elementElement.getType() != null
-						? Helper.extractParameters( elementElement.getType().getParam() )
-						: java.util.Collections.<String, String>emptyMap();
-			}
-		};
-	}
-
-	@Override
-	public PluralAttributeElementNature getNature() {
-		return PluralAttributeElementNature.BASIC;
-	}
-
-	@Override
-	public List<RelationalValueSource> getValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getExplicitHibernateTypeSource() {
-		return typeSource;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnAttributeSourceImpl.java
deleted file mode 100644
index 664215c030..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnAttributeSourceImpl.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.Size;
-import org.hibernate.metamodel.source.binder.ColumnSource;
-
-/**
-* @author Steve Ebersole
-*/
-class ColumnAttributeSourceImpl implements ColumnSource {
-	private final String tableName;
-	private final String columnName;
-	private boolean includedInInsert;
-	private boolean includedInUpdate;
-    private boolean isForceNotNull;
-
-	ColumnAttributeSourceImpl(
-			String tableName,
-			String columnName,
-			boolean includedInInsert,
-			boolean includedInUpdate) {
-		this(tableName, columnName, includedInInsert, includedInUpdate, false);
-	}
-
-    ColumnAttributeSourceImpl(
-			String tableName,
-			String columnName,
-			boolean includedInInsert,
-			boolean includedInUpdate,
-            boolean isForceNotNull) {
-		this.tableName = tableName;
-		this.columnName = columnName;
-		this.includedInInsert = includedInInsert;
-		this.includedInUpdate = includedInUpdate;
-        this.isForceNotNull = isForceNotNull;
-	}
-
-	@Override
-	public boolean isIncludedInInsert() {
-		return includedInInsert;
-	}
-
-	@Override
-	public boolean isIncludedInUpdate() {
-		return includedInUpdate;
-	}
-
-	@Override
-	public String getContainingTableName() {
-		return tableName;
-	}
-
-	@Override
-	public String getName() {
-		return columnName;
-	}
-
-	@Override
-	public boolean isNullable() {
-		return !isForceNotNull;
-	}
-
-	@Override
-	public String getDefaultValue() {
-		return null;
-	}
-
-	@Override
-	public String getSqlType() {
-		return null;
-	}
-
-	@Override
-	public Datatype getDatatype() {
-		return null;
-	}
-
-	@Override
-	public Size getSize() {
-		return null;
-	}
-
-	@Override
-	public String getReadFragment() {
-		return null;
-	}
-
-	@Override
-	public String getWriteFragment() {
-		return null;
-	}
-
-	@Override
-	public boolean isUnique() {
-		return false;
-	}
-
-	@Override
-	public String getCheckCondition() {
-		return null;
-	}
-
-	@Override
-	public String getComment() {
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnSourceImpl.java
deleted file mode 100644
index a5cb4737ec..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ColumnSourceImpl.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbColumnElement;
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.Size;
-import org.hibernate.metamodel.source.binder.ColumnSource;
-
-/**
-* @author Steve Ebersole
-*/
-class ColumnSourceImpl implements ColumnSource {
-	private final String tableName;
-	private final JaxbColumnElement columnElement;
-	private boolean includedInInsert;
-	private boolean includedInUpdate;
-    private final boolean isForceNotNull;
-
-	ColumnSourceImpl(
-			String tableName,
-			JaxbColumnElement columnElement,
-			boolean isIncludedInInsert,
-			boolean isIncludedInUpdate) {
-		this(tableName, columnElement, isIncludedInInsert, isIncludedInUpdate, false);
-	}
-    ColumnSourceImpl(
-            String tableName,
-            JaxbColumnElement columnElement,
-            boolean isIncludedInInsert,
-            boolean isIncludedInUpdate,
-            boolean isForceNotNull) {
-        this.tableName = tableName;
-        this.columnElement = columnElement;
-        this.isForceNotNull = isForceNotNull;
-        includedInInsert = isIncludedInInsert;
-        includedInUpdate = isIncludedInUpdate;
-    }
-
-	@Override
-	public String getName() {
-		return columnElement.getName();
-	}
-
-	@Override
-	public boolean isNullable() {
-        if(isForceNotNull)return false;
-		return ! columnElement.isNotNull();
-	}
-
-	@Override
-	public String getDefaultValue() {
-		return columnElement.getDefault();
-	}
-
-	@Override
-	public String getSqlType() {
-		return columnElement.getSqlType();
-	}
-
-	@Override
-	public Datatype getDatatype() {
-		return null;
-	}
-
-	@Override
-	public Size getSize() {
-		return new Size(
-				Helper.getIntValue( columnElement.getPrecision(), -1 ),
-				Helper.getIntValue( columnElement.getScale(), -1 ),
-				Helper.getLongValue( columnElement.getLength(), -1 ),
-				Size.LobMultiplier.NONE
-		);
-	}
-
-	@Override
-	public String getReadFragment() {
-		return columnElement.getRead();
-	}
-
-	@Override
-	public String getWriteFragment() {
-		return columnElement.getWrite();
-	}
-
-	@Override
-	public boolean isUnique() {
-		return columnElement.isUnique();
-	}
-
-	@Override
-	public String getCheckCondition() {
-		return columnElement.getCheck();
-	}
-
-	@Override
-	public String getComment() {
-		return columnElement.getComment();
-	}
-
-	@Override
-	public boolean isIncludedInInsert() {
-		return includedInInsert;
-	}
-
-	@Override
-	public boolean isIncludedInUpdate() {
-		return includedInUpdate;
-	}
-
-	@Override
-	public String getContainingTableName() {
-		return tableName;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ComponentAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ComponentAttributeSourceImpl.java
deleted file mode 100644
index b091df0f2f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ComponentAttributeSourceImpl.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.EntityMode;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbAnyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbComponentElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbManyToManyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbManyToOneElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbOneToManyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbOneToOneElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbPropertyElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbTuplizerElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.AttributeSource;
-import org.hibernate.metamodel.source.binder.AttributeSourceContainer;
-import org.hibernate.metamodel.source.binder.ComponentAttributeSource;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-
-/**
- * @author Steve Ebersole
- */
-public class ComponentAttributeSourceImpl implements ComponentAttributeSource {
-	private final JaxbComponentElement componentElement;
-	private final AttributeSourceContainer parentContainer;
-
-	private final ValueHolder<Class<?>> componentClassReference;
-	private final String path;
-
-	public ComponentAttributeSourceImpl(
-			JaxbComponentElement componentElement,
-			AttributeSourceContainer parentContainer,
-			LocalBindingContext bindingContext) {
-		this.componentElement = componentElement;
-		this.parentContainer = parentContainer;
-
-		this.componentClassReference = bindingContext.makeClassReference(
-				bindingContext.qualifyClassName( componentElement.getClazz() )
-		);
-		this.path = parentContainer.getPath() + '.' + componentElement.getName();
-	}
-
-	@Override
-	public String getClassName() {
-		return componentElement.getClazz();
-	}
-
-	@Override
-	public ValueHolder<Class<?>> getClassReference() {
-		return componentClassReference;
-	}
-
-	@Override
-	public String getPath() {
-		return path;
-	}
-
-	@Override
-	public LocalBindingContext getLocalBindingContext() {
-		return parentContainer.getLocalBindingContext();
-	}
-
-	@Override
-	public String getParentReferenceAttributeName() {
-		return componentElement.getParent() == null ? null : componentElement.getParent().getName();
-	}
-
-	@Override
-	public String getExplicitTuplizerClassName() {
-		if ( componentElement.getTuplizer() == null ) {
-			return null;
-		}
-		final EntityMode entityMode = StringHelper.isEmpty( componentElement.getClazz() ) ? EntityMode.MAP : EntityMode.POJO;
-		for ( JaxbTuplizerElement tuplizerElement : componentElement.getTuplizer() ) {
-			if ( entityMode == EntityMode.parse( tuplizerElement.getEntityMode() ) ) {
-				return tuplizerElement.getClazz();
-			}
-		}
-		return null;
-	}
-
-	@Override
-	public Iterable<AttributeSource> attributeSources() {
-		List<AttributeSource> attributeSources = new ArrayList<AttributeSource>();
-		for ( Object attributeElement : componentElement.getPropertyOrManyToOneOrOneToOne() ) {
-			if ( JaxbPropertyElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new PropertyAttributeSourceImpl(
-								JaxbPropertyElement.class.cast( attributeElement ),
-								getLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbComponentElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new ComponentAttributeSourceImpl(
-								(JaxbComponentElement) attributeElement,
-								this,
-								getLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbManyToOneElement.class.isInstance( attributeElement ) ) {
-				attributeSources.add(
-						new ManyToOneAttributeSourceImpl(
-								JaxbManyToOneElement.class.cast( attributeElement ),
-								getLocalBindingContext()
-						)
-				);
-			}
-			else if ( JaxbOneToOneElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbAnyElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbOneToManyElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-			else if ( JaxbManyToManyElement.class.isInstance( attributeElement ) ) {
-				// todo : implement
-			}
-		}
-		return attributeSources;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.COMPONENT;
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		// <component/> does not support type information.
-		return null;
-	}
-
-	@Override
-	public String getName() {
-		return componentElement.getName();
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return componentElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return componentElement.isInsert();
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return componentElement.isUpdate();
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		// todo : is this correct here?
-		return null;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return componentElement.isLazy();
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return componentElement.isOptimisticLock();
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( componentElement.getMeta() );
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return isInsertable();
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return isUpdatable();
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return true;
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		// none, they are defined on the simple sub-attributes
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/CompositePluralAttributeElementSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/CompositePluralAttributeElementSourceImpl.java
deleted file mode 100644
index 50181f6380..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/CompositePluralAttributeElementSourceImpl.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.EntityMode;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbCompositeElementElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbTuplizerElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.AttributeSource;
-import org.hibernate.metamodel.source.binder.CompositePluralAttributeElementSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeElementNature;
-
-/**
- * @author Steve Ebersole
- */
-public class CompositePluralAttributeElementSourceImpl implements CompositePluralAttributeElementSource {
-	private final JaxbCompositeElementElement compositeElement;
-	private final LocalBindingContext bindingContext;
-
-	public CompositePluralAttributeElementSourceImpl(
-			JaxbCompositeElementElement compositeElement,
-			LocalBindingContext bindingContext) {
-		this.compositeElement = compositeElement;
-		this.bindingContext = bindingContext;
-	}
-
-	@Override
-	public PluralAttributeElementNature getNature() {
-		return PluralAttributeElementNature.COMPONENT;
-	}
-
-	@Override
-	public String getClassName() {
-		return bindingContext.qualifyClassName( compositeElement.getClazz() );
-	}
-
-	@Override
-	public ValueHolder<Class<?>> getClassReference() {
-		return bindingContext.makeClassReference( getClassName() );
-	}
-
-	@Override
-	public String getParentReferenceAttributeName() {
-		return compositeElement.getParent() != null
-				? compositeElement.getParent().getName()
-				: null;
-	}
-
-	@Override
-	public String getExplicitTuplizerClassName() {
-		if ( compositeElement.getTuplizer() == null ) {
-			return null;
-		}
-		final EntityMode entityMode = StringHelper.isEmpty( compositeElement.getClazz() ) ? EntityMode.MAP : EntityMode.POJO;
-		for ( JaxbTuplizerElement tuplizerElement : compositeElement.getTuplizer() ) {
-			if ( entityMode == EntityMode.parse( tuplizerElement.getEntityMode() ) ) {
-				return tuplizerElement.getClazz();
-			}
-		}
-		return null;
-	}
-
-	@Override
-	public String getPath() {
-		// todo : implementing this requires passing in the collection source and being able to resolve the collection's role
-		return null;
-	}
-
-	@Override
-	public Iterable<AttributeSource> attributeSources() {
-		List<AttributeSource> attributeSources = new ArrayList<AttributeSource>();
-		for ( Object attribute : compositeElement.getPropertyOrManyToOneOrAny() ) {
-
-		}
-		return attributeSources;
-	}
-
-	@Override
-	public LocalBindingContext getLocalBindingContext() {
-		return bindingContext;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchyImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchyImpl.java
deleted file mode 100644
index c3acf22596..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchyImpl.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.RootEntitySource;
-
-/**
- * @author Steve Ebersole
- */
-public class EntityHierarchyImpl implements org.hibernate.metamodel.source.binder.EntityHierarchy {
-	private final RootEntitySourceImpl rootEntitySource;
-	private InheritanceType hierarchyInheritanceType = InheritanceType.NO_INHERITANCE;
-
-	public EntityHierarchyImpl(RootEntitySourceImpl rootEntitySource) {
-		this.rootEntitySource = rootEntitySource;
-		this.rootEntitySource.injectHierarchy( this );
-	}
-
-	@Override
-	public InheritanceType getHierarchyInheritanceType() {
-		return hierarchyInheritanceType;
-	}
-
-	@Override
-	public RootEntitySource getRootEntitySource() {
-		return rootEntitySource;
-	}
-
-	public void processSubclass(SubclassEntitySourceImpl subclassEntitySource) {
-		final InheritanceType inheritanceType = Helper.interpretInheritanceType( subclassEntitySource.entityElement() );
-		if ( hierarchyInheritanceType == InheritanceType.NO_INHERITANCE ) {
-			hierarchyInheritanceType = inheritanceType;
-		}
-		else if ( hierarchyInheritanceType != inheritanceType ) {
-			throw new MappingException( "Mixed inheritance strategies not supported", subclassEntitySource.getOrigin() );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/FormulaImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/FormulaImpl.java
deleted file mode 100644
index f452491c0e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/FormulaImpl.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.metamodel.source.binder.DerivedValueSource;
-
-/**
-* @author Steve Ebersole
-*/
-class FormulaImpl implements DerivedValueSource {
-	private String tableName;
-	private final String expression;
-
-	FormulaImpl(String tableName, String expression) {
-		this.tableName = tableName;
-		this.expression = expression;
-	}
-
-	@Override
-	public String getExpression() {
-		return expression;
-	}
-
-	@Override
-	public String getContainingTableName() {
-		return tableName;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java
deleted file mode 100644
index 4b756a69b7..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbFetchProfileElement;
-import org.hibernate.metamodel.source.BindingContext;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-
-/**
- * Defines features specific to the {@code hbm.xml} variety of a {@link BindingContext}
- * 
- * @author Steve Ebersole
- */
-public interface HbmBindingContext extends LocalBindingContext {
-	public boolean isAutoImport();
-
-	public MetaAttributeContext getMetaAttributeContext();
-
-	public String determineEntityName(EntityElement entityElement);
-
-	public void processFetchProfiles(List<JaxbFetchProfileElement> fetchProfiles, String containingEntityName);
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmMetadataSourceProcessorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmMetadataSourceProcessorImpl.java
deleted file mode 100644
index c35775989d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmMetadataSourceProcessorImpl.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.MetadataSourceProcessor;
-import org.hibernate.metamodel.source.binder.Binder;
-
-/**
- * The {@link org.hibernate.metamodel.source.MetadataSourceProcessor} implementation responsible for processing {@code hbm.xml} sources.
- *
- * @author Steve Ebersole
- */
-public class HbmMetadataSourceProcessorImpl implements MetadataSourceProcessor {
-	private final MetadataImplementor metadata;
-
-	private List<HibernateMappingProcessor> processors = new ArrayList<HibernateMappingProcessor>();
-	private List<EntityHierarchyImpl> entityHierarchies;
-
-	public HbmMetadataSourceProcessorImpl(MetadataImplementor metadata) {
-		this.metadata = metadata;
-	}
-
-	@Override
-	@SuppressWarnings( {"unchecked"})
-	public void prepare(MetadataSources sources) {
-		final HierarchyBuilder hierarchyBuilder = new HierarchyBuilder();
-
-		for ( JaxbRoot jaxbRoot : sources.getJaxbRootList() ) {
-			if ( ! JaxbHibernateMapping.class.isInstance( jaxbRoot.getRoot() ) ) {
-				continue;
-			}
-
-			final MappingDocument mappingDocument = new MappingDocument( jaxbRoot, metadata );
-			processors.add( new HibernateMappingProcessor( metadata, mappingDocument ) );
-
-			hierarchyBuilder.processMappingDocument( mappingDocument );
-		}
-
-		this.entityHierarchies = hierarchyBuilder.groupEntityHierarchies();
-	}
-
-	@Override
-	public void processIndependentMetadata(MetadataSources sources) {
-		for ( HibernateMappingProcessor processor : processors ) {
-			processor.processIndependentMetadata();
-		}
-	}
-
-	@Override
-	public void processTypeDependentMetadata(MetadataSources sources) {
-		for ( HibernateMappingProcessor processor : processors ) {
-			processor.processTypeDependentMetadata();
-		}
-	}
-
-	@Override
-	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames) {
-		Binder binder = new Binder( metadata, processedEntityNames );
-		for ( EntityHierarchyImpl entityHierarchy : entityHierarchies ) {
-			binder.processEntityHierarchy( entityHierarchy );
-		}
-	}
-
-	@Override
-	public void processMappingDependentMetadata(MetadataSources sources) {
-		for ( HibernateMappingProcessor processor : processors ) {
-			processor.processMappingDependentMetadata();
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
deleted file mode 100644
index aa10976d26..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.MappingException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
-import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-import org.hibernate.internal.jaxb.mapping.hbm.CustomSqlElement;
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbColumnElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbJoinedSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbMetaElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbParamElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbUnionSubclassElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.binding.MetaAttribute;
-import org.hibernate.metamodel.relational.Identifier;
-import org.hibernate.metamodel.relational.Schema;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.service.ServiceRegistry;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- */
-public class Helper {
-	public static final ExplicitHibernateTypeSource TO_ONE_ATTRIBUTE_TYPE_SOURCE = new ExplicitHibernateTypeSource() {
-		@Override
-		public String getName() {
-			return null;
-		}
-
-		@Override
-		public Map<String, String> getParameters() {
-			return null;
-		}
-	};
-
-	public static InheritanceType interpretInheritanceType(EntityElement entityElement) {
-		if ( JaxbSubclassElement.class.isInstance( entityElement ) ) {
-			return InheritanceType.SINGLE_TABLE;
-		}
-		else if ( JaxbJoinedSubclassElement.class.isInstance( entityElement ) ) {
-			return InheritanceType.JOINED;
-		}
-		else if ( JaxbUnionSubclassElement.class.isInstance( entityElement ) ) {
-			return InheritanceType.TABLE_PER_CLASS;
-		}
-		else {
-			return InheritanceType.NO_INHERITANCE;
-		}
-	}
-
-	/**
-	 * Given a user-specified description of how to perform custom SQL, build the {@link CustomSQL} representation.
-	 *
-	 * @param customSqlElement User-specified description of how to perform custom SQL
-	 *
-	 * @return The {@link CustomSQL} representation
-	 */
-	public static CustomSQL buildCustomSql(CustomSqlElement customSqlElement) {
-		if ( customSqlElement == null ) {
-			return null;
-		}
-		final ExecuteUpdateResultCheckStyle checkStyle = customSqlElement.getCheck() == null
-				? customSqlElement.isCallable()
-						? ExecuteUpdateResultCheckStyle.NONE
-						: ExecuteUpdateResultCheckStyle.COUNT
-				: ExecuteUpdateResultCheckStyle.fromExternalName( customSqlElement.getCheck().value() );
-		return new CustomSQL( customSqlElement.getValue(), customSqlElement.isCallable(), checkStyle );
-	}
-
-	/**
-	 * Given the user-specified entity mapping, determine the appropriate entity name
-	 *
-	 * @param entityElement The user-specified entity mapping
-	 * @param unqualifiedClassPackage The package to use for unqualified class names
-	 *
-	 * @return The appropriate entity name
-	 */
-	public static String determineEntityName(EntityElement entityElement, String unqualifiedClassPackage) {
-		return entityElement.getEntityName() != null
-				? entityElement.getEntityName()
-				: qualifyIfNeeded( entityElement.getName(), unqualifiedClassPackage );
-	}
-
-	/**
-	 * Qualify a (supposed class) name with the unqualified-class package name if it is not already qualified
-	 *
-	 * @param name The name
-	 * @param unqualifiedClassPackage The unqualified-class package name
-	 *
-	 * @return {@code null} if the incoming name was {@code null}; or the qualified name.
-	 */
-	public static String qualifyIfNeeded(String name, String unqualifiedClassPackage) {
-		if ( name == null ) {
-			return null;
-		}
-		if ( name.indexOf( '.' ) < 0 && unqualifiedClassPackage != null ) {
-			return unqualifiedClassPackage + '.' + name;
-		}
-		return name;
-	}
-
-	public static String getPropertyAccessorName(String access, boolean isEmbedded, String defaultAccess) {
-		return getStringValue( access, isEmbedded ? "embedded" : defaultAccess );
-	}
-
-	public static MetaAttributeContext extractMetaAttributeContext(
-			List<JaxbMetaElement> metaElementList,
-			boolean onlyInheritable,
-			MetaAttributeContext parentContext) {
-		final MetaAttributeContext subContext = new MetaAttributeContext( parentContext );
-
-		for ( JaxbMetaElement metaElement : metaElementList ) {
-			if ( onlyInheritable & !metaElement.isInherit() ) {
-				continue;
-			}
-
-			final String name = metaElement.getAttribute();
-			final MetaAttribute inheritedMetaAttribute = parentContext.getMetaAttribute( name );
-			MetaAttribute metaAttribute = subContext.getLocalMetaAttribute( name );
-			if ( metaAttribute == null || metaAttribute == inheritedMetaAttribute ) {
-				metaAttribute = new MetaAttribute( name );
-				subContext.add( metaAttribute );
-			}
-			metaAttribute.addValue( metaElement.getValue() );
-		}
-
-		return subContext;
-	}
-
-	public static String getStringValue(String value, String defaultValue) {
-		return value == null ? defaultValue : value;
-	}
-
-	public static int getIntValue(String value, int defaultValue) {
-		return value == null ? defaultValue : Integer.parseInt( value );
-	}
-
-	public static long getLongValue(String value, long defaultValue) {
-		return value == null ? defaultValue : Long.parseLong( value );
-	}
-
-	public static boolean getBooleanValue(Boolean value, boolean defaultValue) {
-		return value == null ? defaultValue : value;
-	}
-
-	public static Iterable<CascadeStyle> interpretCascadeStyles(String cascades, LocalBindingContext bindingContext) {
-		final Set<CascadeStyle> cascadeStyles = new HashSet<CascadeStyle>();
-		if ( StringHelper.isEmpty( cascades ) ) {
-			cascades = bindingContext.getMappingDefaults().getCascadeStyle();
-		}
-		for ( String cascade : StringHelper.split( ",", cascades ) ) {
-			cascadeStyles.add( CascadeStyles.getCascadeStyle( cascade ) );
-		}
-		return cascadeStyles;
-	}
-
-	public static Map<String, String> extractParameters(List<JaxbParamElement> xmlParamElements) {
-		if ( xmlParamElements == null || xmlParamElements.isEmpty() ) {
-			return null;
-		}
-		final HashMap<String,String> params = new HashMap<String, String>();
-		for ( JaxbParamElement paramElement : xmlParamElements ) {
-			params.put( paramElement.getName(), paramElement.getValue() );
-		}
-		return params;
-	}
-
-	public static Iterable<MetaAttributeSource> buildMetaAttributeSources(List<JaxbMetaElement> metaElements) {
-		ArrayList<MetaAttributeSource> result = new ArrayList<MetaAttributeSource>();
-		if ( metaElements == null || metaElements.isEmpty() ) {
-			// do nothing
-		}
-		else {
-			for ( final JaxbMetaElement metaElement : metaElements ) {
-				result.add(
-						new MetaAttributeSource() {
-							@Override
-							public String getName() {
-								return metaElement.getAttribute();
-							}
-
-							@Override
-							public String getValue() {
-								return metaElement.getValue();
-							}
-
-							@Override
-							public boolean isInheritable() {
-								return metaElement.isInherit();
-							}
-						}
-				);
-			}
-		}
-		return result;
-	}
-
-	public static Schema.Name determineDatabaseSchemaName(
-			String explicitSchemaName,
-			String explicitCatalogName,
-			LocalBindingContext bindingContext) {
-		return new Schema.Name(
-				resolveIdentifier(
-						explicitSchemaName,
-						bindingContext.getMappingDefaults().getSchemaName(),
-						bindingContext.isGloballyQuotedIdentifiers()
-				),
-				resolveIdentifier(
-						explicitCatalogName,
-						bindingContext.getMappingDefaults().getCatalogName(),
-						bindingContext.isGloballyQuotedIdentifiers()
-				)
-		);
-	}
-
-	public static Identifier resolveIdentifier(String explicitName, String defaultName, boolean globalQuoting) {
-		String name = StringHelper.isNotEmpty( explicitName ) ? explicitName : defaultName;
-		if ( globalQuoting ) {
-			name = StringHelper.quote( name );
-		}
-		return Identifier.toIdentifier( name );
-	}
-
-    public static class ValueSourcesAdapter {
-        public String getContainingTableName() {
-            return null;
-        }
-
-        public boolean isIncludedInInsertByDefault() {
-            return false;
-        }
-
-        public boolean isIncludedInUpdateByDefault() {
-            return false;
-        }
-
-        public String getColumnAttribute() {
-            return null;
-        }
-
-        public String getFormulaAttribute() {
-            return null;
-        }
-
-        public List getColumnOrFormulaElements() {
-            return null;
-        }
-
-        public boolean isForceNotNull() {
-            return false;
-        }
-    }
-
-    public static List<RelationalValueSource> buildValueSources(
-			ValueSourcesAdapter valueSourcesAdapter,
-			LocalBindingContext bindingContext) {
-		List<RelationalValueSource> result = new ArrayList<RelationalValueSource>();
-
-		if ( StringHelper.isNotEmpty( valueSourcesAdapter.getColumnAttribute() ) ) {
-			if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
-					&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
-				throw new org.hibernate.metamodel.source.MappingException(
-						"column/formula attribute may not be used together with <column>/<formula> subelement",
-						bindingContext.getOrigin()
-				);
-			}
-			if ( StringHelper.isNotEmpty( valueSourcesAdapter.getFormulaAttribute() ) ) {
-				throw new org.hibernate.metamodel.source.MappingException(
-						"column and formula attributes may not be used together",
-						bindingContext.getOrigin()
-				);
-			}
-			result.add(
-					new ColumnAttributeSourceImpl(
-							valueSourcesAdapter.getContainingTableName(),
-							valueSourcesAdapter.getColumnAttribute(),
-							valueSourcesAdapter.isIncludedInInsertByDefault(),
-							valueSourcesAdapter.isIncludedInUpdateByDefault(),
-                            valueSourcesAdapter.isForceNotNull()
-					)
-			);
-		}
-		else if ( StringHelper.isNotEmpty( valueSourcesAdapter.getFormulaAttribute() ) ) {
-			if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
-					&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
-				throw new org.hibernate.metamodel.source.MappingException(
-						"column/formula attribute may not be used together with <column>/<formula> subelement",
-						bindingContext.getOrigin()
-				);
-			}
-			// column/formula attribute combo checked already
-			result.add(
-					new FormulaImpl(
-							valueSourcesAdapter.getContainingTableName(),
-							valueSourcesAdapter.getFormulaAttribute()
-					)
-			);
-		}
-		else if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
-				&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
-			for ( Object columnOrFormulaElement : valueSourcesAdapter.getColumnOrFormulaElements() ) {
-				if ( JaxbColumnElement.class.isInstance( columnOrFormulaElement ) ) {
-					result.add(
-							new ColumnSourceImpl(
-									valueSourcesAdapter.getContainingTableName(),
-									(JaxbColumnElement) columnOrFormulaElement,
-									valueSourcesAdapter.isIncludedInInsertByDefault(),
-									valueSourcesAdapter.isIncludedInUpdateByDefault(),
-                                    valueSourcesAdapter.isForceNotNull()
-							)
-					);
-				}
-				else {
-					result.add(
-							new FormulaImpl(
-									valueSourcesAdapter.getContainingTableName(),
-									(String) columnOrFormulaElement
-							)
-					);
-				}
-			}
-		}
-		return result;
-	}
-
-	// todo : remove this once the state objects are cleaned up
-
-	public static Class classForName(String className, ServiceRegistry serviceRegistry) {
-		ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
-		try {
-			return classLoaderService.classForName( className );
-		}
-		catch ( ClassLoadingException e ) {
-			throw new MappingException( "Could not find class: " + className );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
deleted file mode 100644
index b03c33ab7b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbFetchProfileElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbParamElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbQueryElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSqlQueryElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.relational.AuxiliaryDatabaseObject;
-import org.hibernate.metamodel.relational.BasicAuxiliaryDatabaseObjectImpl;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.type.Type;
-
-/**
- * Responsible for processing a {@code <hibernate-mapping/>} element.  Allows processing to be coordinated across
- * all hbm files in an ordered fashion.  The order is essentially the same as defined in
- * {@link org.hibernate.metamodel.source.MetadataSourceProcessor}
- *
- * @author Steve Ebersole
- */
-public class HibernateMappingProcessor {
-	private final MetadataImplementor metadata;
-	private final MappingDocument mappingDocument;
-
-	private ValueHolder<ClassLoaderService> classLoaderService = new ValueHolder<ClassLoaderService>(
-			new ValueHolder.DeferredInitializer<ClassLoaderService>() {
-				@Override
-				public ClassLoaderService initialize() {
-					return metadata.getServiceRegistry().getService( ClassLoaderService.class );
-				}
-			}
-	);
-
-	public HibernateMappingProcessor(MetadataImplementor metadata, MappingDocument mappingDocument) {
-		this.metadata = metadata;
-		this.mappingDocument = mappingDocument;
-	}
-
-	private JaxbHibernateMapping mappingRoot() {
-		return mappingDocument.getMappingRoot();
-	}
-
-	private Origin origin() {
-		return mappingDocument.getOrigin();
-	}
-
-	private HbmBindingContext bindingContext() {
-		return mappingDocument.getMappingLocalBindingContext();
-	}
-
-	private <T> Class<T> classForName(String name) {
-		return classLoaderService.getValue().classForName( bindingContext().qualifyClassName( name ) );
-	}
-
-	public void processIndependentMetadata() {
-		processDatabaseObjectDefinitions();
-		processTypeDefinitions();
-	}
-
-	private void processDatabaseObjectDefinitions() {
-		if ( mappingRoot().getDatabaseObject() == null ) {
-			return;
-		}
-
-		for ( JaxbHibernateMapping.JaxbDatabaseObject databaseObjectElement : mappingRoot().getDatabaseObject() ) {
-			final AuxiliaryDatabaseObject auxiliaryDatabaseObject;
-			if ( databaseObjectElement.getDefinition() != null ) {
-				final String className = databaseObjectElement.getDefinition().getClazz();
-				try {
-					auxiliaryDatabaseObject = (AuxiliaryDatabaseObject) classForName( className ).newInstance();
-				}
-				catch (ClassLoadingException e) {
-					throw e;
-				}
-				catch (Exception e) {
-					throw new MappingException(
-							"could not instantiate custom database object class [" + className + "]",
-							origin()
-					);
-				}
-			}
-			else {
-				Set<String> dialectScopes = new HashSet<String>();
-				if ( databaseObjectElement.getDialectScope() != null ) {
-					for ( JaxbHibernateMapping.JaxbDatabaseObject.JaxbDialectScope dialectScope : databaseObjectElement.getDialectScope() ) {
-						dialectScopes.add( dialectScope.getName() );
-					}
-				}
-				auxiliaryDatabaseObject = new BasicAuxiliaryDatabaseObjectImpl(
-						metadata.getDatabase().getDefaultSchema(),
-						databaseObjectElement.getCreate(),
-						databaseObjectElement.getDrop(),
-						dialectScopes
-				);
-			}
-			metadata.getDatabase().addAuxiliaryDatabaseObject( auxiliaryDatabaseObject );
-		}
-	}
-
-	private void processTypeDefinitions() {
-		if ( mappingRoot().getTypedef() == null ) {
-			return;
-		}
-
-		for ( JaxbHibernateMapping.JaxbTypedef typedef : mappingRoot().getTypedef() ) {
-			final Map<String, String> parameters = new HashMap<String, String>();
-			for ( JaxbParamElement paramElement : typedef.getParam() ) {
-				parameters.put( paramElement.getName(), paramElement.getValue() );
-			}
-			metadata.addTypeDefinition(
-					new TypeDef(
-							typedef.getName(),
-							typedef.getClazz(),
-							parameters
-					)
-			);
-		}
-	}
-
-	public void processTypeDependentMetadata() {
-		processFilterDefinitions();
-		processIdentifierGenerators();
-	}
-
-	private void processFilterDefinitions() {
-		if ( mappingRoot().getFilterDef() == null ) {
-			return;
-		}
-
-		for ( JaxbHibernateMapping.JaxbFilterDef filterDefinition : mappingRoot().getFilterDef() ) {
-			final String name = filterDefinition.getName();
-			final Map<String,Type> parameters = new HashMap<String, Type>();
-			String condition = null;
-			for ( Object o : filterDefinition.getContent() ) {
-				if ( o instanceof String ) {
-					// represents the condition
-					if ( condition != null ) {
-						// log?
-					}
-					condition = (String) o;
-				}
-				else if ( o instanceof JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam ) {
-					final JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam paramElement =
-							JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam.class.cast( o );
-					// todo : should really delay this resolution until later to allow typedef names
-					parameters.put(
-							paramElement.getName(),
-							metadata.getTypeResolver().heuristicType( paramElement.getType() )
-					);
-				}
-				else {
-					throw new MappingException( "Unrecognized nested filter content", origin() );
-				}
-			}
-			if ( condition == null ) {
-				condition = filterDefinition.getCondition();
-			}
-			metadata.addFilterDefinition( new FilterDefinition( name, condition, parameters ) );
-		}
-	}
-
-	private void processIdentifierGenerators() {
-		if ( mappingRoot().getIdentifierGenerator() == null ) {
-			return;
-		}
-
-		for ( JaxbHibernateMapping.JaxbIdentifierGenerator identifierGeneratorElement : mappingRoot().getIdentifierGenerator() ) {
-			metadata.registerIdentifierGenerator(
-					identifierGeneratorElement.getName(),
-					identifierGeneratorElement.getClazz()
-			);
-		}
-	}
-
-	public void processMappingDependentMetadata() {
-		processFetchProfiles();
-		processImports();
-		processResultSetMappings();
-		processNamedQueries();
-	}
-
-	private void processFetchProfiles(){
-		if ( mappingRoot().getFetchProfile() == null ) {
-			return;
-		}
-
-		processFetchProfiles( mappingRoot().getFetchProfile(), null );
-	}
-
-	public void processFetchProfiles(List<JaxbFetchProfileElement> fetchProfiles, String containingEntityName) {
-		for ( JaxbFetchProfileElement fetchProfile : fetchProfiles ) {
-			String profileName = fetchProfile.getName();
-			Set<FetchProfile.Fetch> fetches = new HashSet<FetchProfile.Fetch>();
-			for ( JaxbFetchProfileElement.JaxbFetch fetch : fetchProfile.getFetch() ) {
-				String entityName = fetch.getEntity() == null ? containingEntityName : fetch.getEntity();
-				if ( entityName == null ) {
-					throw new MappingException(
-							"could not determine entity for fetch-profile fetch [" + profileName + "]:[" +
-									fetch.getAssociation() + "]",
-							origin()
-					);
-				}
-				fetches.add( new FetchProfile.Fetch( entityName, fetch.getAssociation(), fetch.getStyle() ) );
-			}
-			metadata.addFetchProfile( new FetchProfile( profileName, fetches ) );
-		}
-	}
-
-	private void processImports() {
-		if ( mappingRoot().getImport() == null ) {
-			return;
-		}
-
-		for ( JaxbHibernateMapping.JaxbImport importValue : mappingRoot().getImport() ) {
-			String className = mappingDocument.getMappingLocalBindingContext().qualifyClassName( importValue.getClazz() );
-			String rename = importValue.getRename();
-			rename = ( rename == null ) ? StringHelper.unqualify( className ) : rename;
-			metadata.addImport( className, rename );
-		}
-	}
-
-	private void processResultSetMappings() {
-		if ( mappingRoot().getResultset() == null ) {
-			return;
-		}
-
-//			bindResultSetMappingDefinitions( element, null, mappings );
-	}
-
-	private void processNamedQueries() {
-		if ( mappingRoot().getQueryOrSqlQuery() == null ) {
-			return;
-		}
-
-		for ( Object queryOrSqlQuery : mappingRoot().getQueryOrSqlQuery() ) {
-			if ( JaxbQueryElement.class.isInstance( queryOrSqlQuery ) ) {
-//					bindNamedQuery( element, null, mappings );
-			}
-			else if ( JaxbSqlQueryElement.class.isInstance( queryOrSqlQuery ) ) {
-//				bindNamedSQLQuery( element, null, mappings );
-			}
-			else {
-				throw new MappingException(
-						"unknown type of query: " +
-								queryOrSqlQuery.getClass().getName(), origin()
-				);
-			}
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java
deleted file mode 100644
index 2582a8b32f..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.MappingException;
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbJoinedSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbUnionSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.SubEntityElement;
-import org.hibernate.metamodel.source.binder.SubclassEntityContainer;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-
-/**
- * @author Steve Ebersole
- */
-public class HierarchyBuilder {
-	private final List<EntityHierarchyImpl> entityHierarchies = new ArrayList<EntityHierarchyImpl>();
-
-	// process state
-	private final Map<String,SubclassEntityContainer> subEntityContainerMap = new HashMap<String, SubclassEntityContainer>();
-	private final List<ExtendsQueueEntry> extendsQueue = new ArrayList<ExtendsQueueEntry>();
-
-	// mapping file specific state
-	private MappingDocument currentMappingDocument;
-
-	public void processMappingDocument(MappingDocument mappingDocument) {
-		this.currentMappingDocument = mappingDocument;
-		try {
-			processCurrentMappingDocument();
-		}
-		finally {
-			this.currentMappingDocument = null;
-		}
-	}
-
-	private void processCurrentMappingDocument() {
-		for ( Object entityElementO : currentMappingDocument.getMappingRoot().getClazzOrSubclassOrJoinedSubclass() ) {
-			final EntityElement entityElement = (EntityElement) entityElementO;
-			if ( JaxbHibernateMapping.JaxbClass.class.isInstance( entityElement ) ) {
-				// we can immediately handle <class/> elements in terms of creating the hierarchy entry
-				final JaxbHibernateMapping.JaxbClass jaxbClass = (JaxbHibernateMapping.JaxbClass) entityElement;
-				final RootEntitySourceImpl rootEntitySource = new RootEntitySourceImpl( currentMappingDocument,
-																						jaxbClass
-				);
-				final EntityHierarchyImpl hierarchy = new EntityHierarchyImpl( rootEntitySource );
-
-				entityHierarchies.add( hierarchy );
-				subEntityContainerMap.put( rootEntitySource.getEntityName(), rootEntitySource );
-
-				processSubElements( entityElement, rootEntitySource );
-			}
-			else {
-				// we have to see if this things super-type has been found yet, and if not add it to the
-				// extends queue
-				final SubclassEntitySourceImpl subClassEntitySource = new SubclassEntitySourceImpl( currentMappingDocument, entityElement );
-				final String entityName = subClassEntitySource.getEntityName();
-				subEntityContainerMap.put( entityName, subClassEntitySource );
-				final String entityItExtends = currentMappingDocument.getMappingLocalBindingContext().qualifyClassName(
-						((SubEntityElement) entityElement).getExtends()
-				);
-				processSubElements( entityElement, subClassEntitySource );
-				final SubclassEntityContainer container = subEntityContainerMap.get( entityItExtends );
-				if ( container != null ) {
-					// we already have this entity's super, attach it and continue
-					container.add( subClassEntitySource );
-				}
-				else {
-					// we do not yet have the super and have to wait, so add it fto the extends queue
-					extendsQueue.add( new ExtendsQueueEntry( subClassEntitySource, entityItExtends ) );
-				}
-			}
-		}
-	}
-
-	public List<EntityHierarchyImpl> groupEntityHierarchies() {
-		while ( ! extendsQueue.isEmpty() ) {
-			// set up a pass over the queue
-			int numberOfMappingsProcessed = 0;
-			Iterator<ExtendsQueueEntry> iterator = extendsQueue.iterator();
-			while ( iterator.hasNext() ) {
-				final ExtendsQueueEntry entry = iterator.next();
-				final SubclassEntityContainer container = subEntityContainerMap.get( entry.entityItExtends );
-				if ( container != null ) {
-					// we now have this entity's super, attach it and remove entry from extends queue
-					container.add( entry.subClassEntitySource );
-					iterator.remove();
-					numberOfMappingsProcessed++;
-				}
-			}
-
-			if ( numberOfMappingsProcessed == 0 ) {
-				// todo : we could log the waiting dependencies...
-				throw new MappingException( "Unable to process extends dependencies in hbm files" );
-			}
-		}
-
-		return entityHierarchies;
-	}
-
-	private void processSubElements(EntityElement entityElement, SubclassEntityContainer container) {
-		if ( JaxbHibernateMapping.JaxbClass.class.isInstance( entityElement ) ) {
-			final JaxbHibernateMapping.JaxbClass jaxbClass = (JaxbHibernateMapping.JaxbClass) entityElement;
-			processElements( jaxbClass.getJoinedSubclass(), container );
-			processElements( jaxbClass.getSubclass(), container );
-			processElements( jaxbClass.getUnionSubclass(), container );
-		}
-		else if ( JaxbSubclassElement.class.isInstance( entityElement ) ) {
-			final JaxbSubclassElement jaxbSubclass = (JaxbSubclassElement) entityElement;
-			processElements( jaxbSubclass.getSubclass(), container );
-		}
-		else if ( JaxbJoinedSubclassElement.class.isInstance( entityElement ) ) {
-			final JaxbJoinedSubclassElement jaxbJoinedSubclass = (JaxbJoinedSubclassElement) entityElement;
-			processElements( jaxbJoinedSubclass.getJoinedSubclass(), container );
-		}
-		else if ( JaxbUnionSubclassElement.class.isInstance( entityElement ) ) {
-			final JaxbUnionSubclassElement jaxbUnionSubclass = (JaxbUnionSubclassElement) entityElement;
-			processElements( jaxbUnionSubclass.getUnionSubclass(), container );
-		}
-	}
-
-	private void processElements(List subElements, SubclassEntityContainer container) {
-		for ( Object subElementO : subElements ) {
-			final SubEntityElement subElement = (SubEntityElement) subElementO;
-			final SubclassEntitySourceImpl subclassEntitySource = new SubclassEntitySourceImpl( currentMappingDocument, subElement );
-			container.add( subclassEntitySource );
-			final String subEntityName = subclassEntitySource.getEntityName();
-			subEntityContainerMap.put( subEntityName, subclassEntitySource );
-		}
-	}
-
-	private static class ExtendsQueueEntry {
-		private final SubclassEntitySource subClassEntitySource;
-		private final String entityItExtends;
-
-		private ExtendsQueueEntry(SubclassEntitySource subClassEntitySource, String entityItExtends) {
-			this.subClassEntitySource = subClassEntitySource;
-			this.entityItExtends = entityItExtends;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToManyPluralAttributeElementSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToManyPluralAttributeElementSourceImpl.java
deleted file mode 100644
index e4618e76cf..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToManyPluralAttributeElementSourceImpl.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-
-import org.hibernate.FetchMode;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbManyToManyElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.ManyToManyPluralAttributeElementSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeElementNature;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-
-/**
- * @author Steve Ebersole
- */
-public class ManyToManyPluralAttributeElementSourceImpl implements ManyToManyPluralAttributeElementSource {
-	private final JaxbManyToManyElement manyToManyElement;
-	private final LocalBindingContext bindingContext;
-
-	private final List<RelationalValueSource> valueSources;
-
-	public ManyToManyPluralAttributeElementSourceImpl(
-			final JaxbManyToManyElement manyToManyElement,
-			final LocalBindingContext bindingContext) {
-		this.manyToManyElement = manyToManyElement;
-		this.bindingContext = bindingContext;
-
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getContainingTableName() {
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return true;
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return true;
-					}
-
-					@Override
-					public String getColumnAttribute() {
-						return manyToManyElement.getColumn();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return manyToManyElement.getFormula();
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return manyToManyElement.getColumnOrFormula();
-					}
-				},
-				bindingContext
-		);
-	}
-
-	@Override
-	public PluralAttributeElementNature getNature() {
-		return PluralAttributeElementNature.MANY_TO_MANY;
-	}
-
-	@Override
-	public String getReferencedEntityName() {
-		return StringHelper.isNotEmpty( manyToManyElement.getEntityName() )
-				? manyToManyElement.getEntityName()
-				: bindingContext.qualifyClassName( manyToManyElement.getClazz() );
-	}
-
-	@Override
-	public String getReferencedEntityAttributeName() {
-		return manyToManyElement.getPropertyRef();
-	}
-
-	@Override
-	public List<RelationalValueSource> getValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isNotFoundAnException() {
-		return manyToManyElement.getNotFound() == null
-				|| ! "ignore".equals( manyToManyElement.getNotFound().value() );
-	}
-
-	@Override
-	public String getExplicitForeignKeyName() {
-		return manyToManyElement.getForeignKey();
-	}
-
-	@Override
-	public boolean isUnique() {
-		return manyToManyElement.isUnique();
-	}
-
-	@Override
-	public String getOrderBy() {
-		return manyToManyElement.getOrderBy();
-	}
-
-	@Override
-	public String getWhere() {
-		return manyToManyElement.getWhere();
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		return null;
-	}
-
-	@Override
-	public boolean fetchImmediately() {
-		if ( manyToManyElement.getLazy() != null ) {
-			if ( "false".equals( manyToManyElement.getLazy().value() ) ) {
-				return true;
-			}
-		}
-
-		if ( manyToManyElement.getOuterJoin() == null ) {
-			return ! bindingContext.getMappingDefaults().areAssociationsLazy();
-		}
-		else {
-			final String value = manyToManyElement.getOuterJoin().value();
-			if ( "auto".equals( value ) ) {
-				return ! bindingContext.getMappingDefaults().areAssociationsLazy();
-			}
-			return "true".equals( value );
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToOneAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToOneAttributeSourceImpl.java
deleted file mode 100644
index 902bec8dfd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/ManyToOneAttributeSourceImpl.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-
-import org.hibernate.FetchMode;
-import org.hibernate.engine.FetchStyle;
-import org.hibernate.engine.FetchTiming;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbManyToOneElement;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.ToOneAttributeSource;
-
-/**
- * Implementation for {@code <many-to-one/> mappings}
- *
- * @author Steve Ebersole
- */
-class ManyToOneAttributeSourceImpl implements ToOneAttributeSource {
-	private final JaxbManyToOneElement manyToOneElement;
-	private final LocalBindingContext bindingContext;
-	private final List<RelationalValueSource> valueSources;
-
-	ManyToOneAttributeSourceImpl(final JaxbManyToOneElement manyToOneElement, LocalBindingContext bindingContext) {
-		this.manyToOneElement = manyToOneElement;
-		this.bindingContext = bindingContext;
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getColumnAttribute() {
-						return manyToOneElement.getColumn();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return manyToOneElement.getFormula();
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return manyToOneElement.getColumnOrFormula();
-					}
-
-					@Override
-					public String getContainingTableName() {
-						// todo : need to implement this...
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return manyToOneElement.isInsert();
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return manyToOneElement.isUpdate();
-					}
-				},
-				bindingContext
-		);
-	}
-
-	@Override
-	public String getName() {
-			return manyToOneElement.getName();
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return Helper.TO_ONE_ATTRIBUTE_TYPE_SOURCE;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return manyToOneElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return manyToOneElement.isInsert();
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return manyToOneElement.isUpdate();
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return PropertyGeneration.NEVER;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return false;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return manyToOneElement.isOptimisticLock();
-	}
-
-	@Override
-	public Iterable<CascadeStyle> getCascadeStyles() {
-		return Helper.interpretCascadeStyles( manyToOneElement.getCascade(), bindingContext );
-	}
-
-	@Override
-	public FetchTiming getFetchTiming() {
-		final String fetchSelection = manyToOneElement.getFetch() != null
-				? manyToOneElement.getFetch().value()
-				: null;
-		final String lazySelection = manyToOneElement.getLazy() != null
-				? manyToOneElement.getLazy().value()
-				: null;
-		final String outerJoinSelection = manyToOneElement.getOuterJoin() != null
-				? manyToOneElement.getOuterJoin().value()
-				: null;
-
-		if ( lazySelection == null ) {
-			if ( "join".equals( fetchSelection ) || "true".equals( outerJoinSelection ) ) {
-				return FetchTiming.IMMEDIATE;
-			}
-			else if ( "false".equals( outerJoinSelection ) ) {
-				return FetchTiming.DELAYED;
-			}
-			else {
-				return bindingContext.getMappingDefaults().areAssociationsLazy()
-						? FetchTiming.DELAYED
-						: FetchTiming.IMMEDIATE;
-			}
-		}
-		else  if ( "extra".equals( lazySelection ) ) {
-			return FetchTiming.EXTRA_LAZY;
-		}
-		else if ( "true".equals( lazySelection ) ) {
-			return FetchTiming.DELAYED;
-		}
-		else if ( "false".equals( lazySelection ) ) {
-			return FetchTiming.IMMEDIATE;
-		}
-
-		throw new MappingException(
-				String.format(
-						"Unexpected lazy selection [%s] on '%s'",
-						lazySelection,
-						manyToOneElement.getName()
-				),
-				bindingContext.getOrigin()
-		);
-	}
-
-	@Override
-	public FetchStyle getFetchStyle() {
-		// todo : handle batch fetches?
-
-		final String fetchSelection = manyToOneElement.getFetch() != null
-				? manyToOneElement.getFetch().value()
-				: null;
-		final String outerJoinSelection = manyToOneElement.getOuterJoin() != null
-				? manyToOneElement.getOuterJoin().value()
-				: null;
-
-		if ( fetchSelection == null ) {
-			if ( outerJoinSelection == null ) {
-				return FetchStyle.SELECT;
-			}
-			else {
-				if ( "auto".equals( outerJoinSelection ) ) {
-					return bindingContext.getMappingDefaults().areAssociationsLazy()
-							? FetchStyle.SELECT
-							: FetchStyle.JOIN;
-				}
-				else {
-					return "true".equals( outerJoinSelection ) ? FetchStyle.JOIN : FetchStyle.SELECT;
-				}
-			}
-		}
-		else {
-			return "join".equals( fetchSelection ) ? FetchStyle.JOIN : FetchStyle.SELECT;
-		}
-	}
-
-	@Override
-	public FetchMode getFetchMode() {
-		return manyToOneElement.getFetch() == null
-				? FetchMode.DEFAULT
-				: FetchMode.valueOf( manyToOneElement.getFetch().value() );
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.MANY_TO_ONE;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return manyToOneElement.isInsert();
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return manyToOneElement.isUpdate();
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return ! Helper.getBooleanValue( manyToOneElement.isNotNull(), false );
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( manyToOneElement.getMeta() );
-	}
-
-	@Override
-	public String getReferencedEntityName() {
-		return manyToOneElement.getClazz() != null
-				? manyToOneElement.getClazz()
-				: manyToOneElement.getEntityName();
-	}
-
-	@Override
-	public String getReferencedEntityAttributeName() {
-		return manyToOneElement.getPropertyRef();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java
deleted file mode 100644
index b9d8cb609b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbFetchProfileElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.metamodel.source.MappingDefaults;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.internal.OverriddenMappingDefaults;
-import org.hibernate.service.ServiceRegistry;
-
-/**
- * Aggregates together information about a mapping document.
- * 
- * @author Steve Ebersole
- */
-public class MappingDocument {
-	private final JaxbRoot<JaxbHibernateMapping> hbmJaxbRoot;
-	private final LocalBindingContextImpl mappingLocalBindingContext;
-
-	public MappingDocument(JaxbRoot<JaxbHibernateMapping> hbmJaxbRoot, MetadataImplementor metadata) {
-		this.hbmJaxbRoot = hbmJaxbRoot;
-		this.mappingLocalBindingContext = new LocalBindingContextImpl( metadata );
-
-	}
-
-	public JaxbHibernateMapping getMappingRoot() {
-		return hbmJaxbRoot.getRoot();
-	}
-
-	public Origin getOrigin() {
-		return hbmJaxbRoot.getOrigin();
-	}
-
-	public JaxbRoot<JaxbHibernateMapping> getJaxbRoot() {
-		return hbmJaxbRoot;
-	}
-
-	public HbmBindingContext getMappingLocalBindingContext() {
-		return mappingLocalBindingContext;
-	}
-
-	private class LocalBindingContextImpl implements HbmBindingContext {
-		private final MetadataImplementor metadata;
-		private final MappingDefaults localMappingDefaults;
-		private final MetaAttributeContext metaAttributeContext;
-
-		private LocalBindingContextImpl(MetadataImplementor metadata) {
-			this.metadata = metadata;
-			this.localMappingDefaults = new OverriddenMappingDefaults(
-					metadata.getMappingDefaults(),
-					hbmJaxbRoot.getRoot().getPackage(),
-					hbmJaxbRoot.getRoot().getSchema(),
-					hbmJaxbRoot.getRoot().getCatalog(),
-					null,
-					null,
-					hbmJaxbRoot.getRoot().getDefaultCascade(),
-					hbmJaxbRoot.getRoot().getDefaultAccess(),
-					hbmJaxbRoot.getRoot().isDefaultLazy()
-			);
-			if ( hbmJaxbRoot.getRoot().getMeta() == null || hbmJaxbRoot.getRoot().getMeta().isEmpty() ) {
-				this.metaAttributeContext = new MetaAttributeContext( metadata.getGlobalMetaAttributeContext() );
-			}
-			else {
-				this.metaAttributeContext = Helper.extractMetaAttributeContext(
-						hbmJaxbRoot.getRoot().getMeta(),
-						true,
-						metadata.getGlobalMetaAttributeContext()
-				);
-			}
-		}
-
-		@Override
-		public ServiceRegistry getServiceRegistry() {
-			return metadata.getServiceRegistry();
-		}
-
-		@Override
-		public NamingStrategy getNamingStrategy() {
-			return metadata.getNamingStrategy();
-		}
-
-		@Override
-		public MappingDefaults getMappingDefaults() {
-			return localMappingDefaults;
-		}
-
-		@Override
-		public MetadataImplementor getMetadataImplementor() {
-			return metadata;
-		}
-
-		@Override
-		public <T> Class<T> locateClassByName(String name) {
-			return metadata.locateClassByName( name );
-		}
-
-		@Override
-		public Type makeJavaType(String className) {
-			return metadata.makeJavaType( className );
-		}
-
-		@Override
-		public ValueHolder<Class<?>> makeClassReference(String className) {
-			return metadata.makeClassReference( className );
-		}
-
-		@Override
-		public boolean isAutoImport() {
-			return hbmJaxbRoot.getRoot().isAutoImport();
-		}
-
-		@Override
-		public MetaAttributeContext getMetaAttributeContext() {
-			return metaAttributeContext;
-		}
-
-		@Override
-		public Origin getOrigin() {
-			return hbmJaxbRoot.getOrigin();
-		}
-
-		@Override
-		public String qualifyClassName(String unqualifiedName) {
-			return Helper.qualifyIfNeeded( unqualifiedName, getMappingDefaults().getPackageName() );
-		}
-
-		@Override
-		public String determineEntityName(EntityElement entityElement) {
-			return Helper.determineEntityName( entityElement, getMappingDefaults().getPackageName() );
-		}
-
-		@Override
-		public boolean isGloballyQuotedIdentifiers() {
-			return metadata.isGloballyQuotedIdentifiers();
-		}
-
-		@Override
-		public void processFetchProfiles(List<JaxbFetchProfileElement> fetchProfiles, String containingEntityName) {
-			// todo : this really needs to not be part of the context
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/OneToManyPluralAttributeElementSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/OneToManyPluralAttributeElementSourceImpl.java
deleted file mode 100644
index 8176952c40..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/OneToManyPluralAttributeElementSourceImpl.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbOneToManyElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.OneToManyPluralAttributeElementSource;
-import org.hibernate.metamodel.source.binder.PluralAttributeElementNature;
-
-/**
- * @author Steve Ebersole
- */
-public class OneToManyPluralAttributeElementSourceImpl implements OneToManyPluralAttributeElementSource {
-	private final JaxbOneToManyElement oneToManyElement;
-	private final LocalBindingContext bindingContext;
-
-	public OneToManyPluralAttributeElementSourceImpl(
-			JaxbOneToManyElement oneToManyElement,
-			LocalBindingContext bindingContext) {
-		this.oneToManyElement = oneToManyElement;
-		this.bindingContext = bindingContext;
-	}
-
-	@Override
-	public PluralAttributeElementNature getNature() {
-		return PluralAttributeElementNature.ONE_TO_MANY;
-	}
-
-	@Override
-	public String getReferencedEntityName() {
-		return StringHelper.isNotEmpty( oneToManyElement.getEntityName() )
-				? oneToManyElement.getEntityName()
-				: bindingContext.qualifyClassName( oneToManyElement.getClazz() );
-	}
-
-	@Override
-	public boolean isNotFoundAnException() {
-		return oneToManyElement.getNotFound() == null
-				|| ! "ignore".equals( oneToManyElement.getNotFound().value() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PluralAttributeKeySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PluralAttributeKeySourceImpl.java
deleted file mode 100644
index 1def9cc4ab..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PluralAttributeKeySourceImpl.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbKeyElement;
-import org.hibernate.metamodel.relational.ForeignKey;
-import org.hibernate.metamodel.source.binder.AttributeSourceContainer;
-import org.hibernate.metamodel.source.binder.PluralAttributeKeySource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-
-/**
- * @author Steve Ebersole
- */
-public class PluralAttributeKeySourceImpl implements PluralAttributeKeySource {
-	private final JaxbKeyElement keyElement;
-
-	private final List<RelationalValueSource> valueSources;
-
-	public PluralAttributeKeySourceImpl(
-			final JaxbKeyElement keyElement,
-			final AttributeSourceContainer container) {
-		this.keyElement = keyElement;
-
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getContainingTableName() {
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return true;
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return Helper.getBooleanValue( keyElement.isUpdate(), true );
-					}
-
-					@Override
-					public String getColumnAttribute() {
-						return keyElement.getColumnAttribute();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return null;
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return keyElement.getColumn();
-					}
-				},
-				container.getLocalBindingContext()
-		);
-	}
-
-	@Override
-	public List<RelationalValueSource> getValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public String getExplicitForeignKeyName() {
-		return keyElement.getForeignKey();
-	}
-
-	@Override
-	public ForeignKey.ReferentialAction getOnDeleteAction() {
-		return "cascade".equals( keyElement.getOnDelete() )
-				? ForeignKey.ReferentialAction.CASCADE
-				: ForeignKey.ReferentialAction.NO_ACTION;
-	}
-
-	@Override
-	public String getReferencedEntityAttributeName() {
-		return keyElement.getPropertyRef();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PropertyAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PropertyAttributeSourceImpl.java
deleted file mode 100644
index 815cad8548..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/PropertyAttributeSourceImpl.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbPropertyElement;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * Implementation for {@code <property/>} mappings
- *
- * @author Steve Ebersole
- */
-class PropertyAttributeSourceImpl implements SingularAttributeSource {
-	private final JaxbPropertyElement propertyElement;
-	private final ExplicitHibernateTypeSource typeSource;
-	private final List<RelationalValueSource> valueSources;
-
-	PropertyAttributeSourceImpl(final JaxbPropertyElement propertyElement, LocalBindingContext bindingContext) {
-		this.propertyElement = propertyElement;
-		this.typeSource = new ExplicitHibernateTypeSource() {
-			private final String name = propertyElement.getTypeAttribute() != null
-					? propertyElement.getTypeAttribute()
-					: propertyElement.getType() != null
-							? propertyElement.getType().getName()
-							: null;
-			private final Map<String, String> parameters = ( propertyElement.getType() != null )
-					? Helper.extractParameters( propertyElement.getType().getParam() )
-					: null;
-
-			@Override
-			public String getName() {
-				return name;
-			}
-
-			@Override
-			public Map<String, String> getParameters() {
-				return parameters;
-			}
-		};
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getColumnAttribute() {
-						return propertyElement.getColumn();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return propertyElement.getFormula();
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return propertyElement.getColumnOrFormula();
-					}
-
-					@Override
-					public String getContainingTableName() {
-						// todo : need to implement this...
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return Helper.getBooleanValue( propertyElement.isInsert(), true );
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return Helper.getBooleanValue( propertyElement.isUpdate(), true );
-					}
-				},
-				bindingContext
-		);
-	}
-
-	@Override
-	public String getName() {
-		return propertyElement.getName();
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return typeSource;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return propertyElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return Helper.getBooleanValue( propertyElement.isInsert(), true );
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return Helper.getBooleanValue( propertyElement.isUpdate(), true );
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return PropertyGeneration.parse( propertyElement.getGenerated() );
-	}
-
-	@Override
-	public boolean isLazy() {
-		return Helper.getBooleanValue( propertyElement.isLazy(), false );
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return Helper.getBooleanValue( propertyElement.isOptimisticLock(), true );
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.BASIC;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return Helper.getBooleanValue( propertyElement.isInsert(), true );
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return Helper.getBooleanValue( propertyElement.isUpdate(), true );
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return ! Helper.getBooleanValue( propertyElement.isNotNull(), false );
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( propertyElement.getMeta() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/RootEntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/RootEntitySourceImpl.java
deleted file mode 100644
index d184a4898d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/RootEntitySourceImpl.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.EntityMode;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbCacheElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.DiscriminatorSource;
-import org.hibernate.metamodel.source.binder.IdentifierSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.RootEntitySource;
-import org.hibernate.metamodel.source.binder.SimpleIdentifierSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-import org.hibernate.metamodel.source.binder.TableSource;
-
-/**
- * @author Steve Ebersole
- */
-public class RootEntitySourceImpl extends AbstractEntitySourceImpl implements RootEntitySource {
-	protected RootEntitySourceImpl(MappingDocument sourceMappingDocument, JaxbHibernateMapping.JaxbClass entityElement) {
-		super( sourceMappingDocument, entityElement );
-	}
-
-	@Override
-	protected JaxbHibernateMapping.JaxbClass entityElement() {
-		return (JaxbHibernateMapping.JaxbClass) super.entityElement();
-	}
-
-	@Override
-	public IdentifierSource getIdentifierSource() {
-		if ( entityElement().getId() != null ) {
-			return new SimpleIdentifierSource() {
-				@Override
-				public SingularAttributeSource getIdentifierAttributeSource() {
-					return new SingularIdentifierAttributeSourceImpl(
-							entityElement().getId(),
-							sourceMappingDocument().getMappingLocalBindingContext()
-					);
-				}
-
-				@Override
-				public IdGenerator getIdentifierGeneratorDescriptor() {
-					if ( entityElement().getId().getGenerator() != null ) {
-						final String generatorName = entityElement().getId().getGenerator().getClazz();
-						IdGenerator idGenerator = sourceMappingDocument().getMappingLocalBindingContext()
-								.getMetadataImplementor()
-								.getIdGenerator( generatorName );
-						if ( idGenerator == null ) {
-							idGenerator = new IdGenerator(
-									getEntityName() + generatorName,
-									generatorName,
-									Helper.extractParameters( entityElement().getId().getGenerator().getParam() )
-							);
-						}
-						return idGenerator;
-					}
-					return null;
-				}
-
-				@Override
-				public Nature getNature() {
-					return Nature.SIMPLE;
-				}
-			};
-		}
-		return null;  //To change body of implemented methods use File | Settings | File Templates.
-	}
-
-	@Override
-	public SingularAttributeSource getVersioningAttributeSource() {
-		if ( entityElement().getVersion() != null ) {
-			return new VersionAttributeSourceImpl(
-					entityElement().getVersion(),
-					sourceMappingDocument().getMappingLocalBindingContext()
-			);
-		}
-		else if ( entityElement().getTimestamp() != null ) {
-			return new TimestampAttributeSourceImpl(
-					entityElement().getTimestamp(),
-					sourceMappingDocument().getMappingLocalBindingContext()
-			);
-		}
-		return null;
-	}
-
-	@Override
-	public EntityMode getEntityMode() {
-		return determineEntityMode();
-	}
-
-	@Override
-	public boolean isMutable() {
-		return entityElement().isMutable();
-	}
-
-
-	@Override
-	public boolean isExplicitPolymorphism() {
-		return "explicit".equals( entityElement().getPolymorphism() );
-	}
-
-	@Override
-	public String getWhere() {
-		return entityElement().getWhere();
-	}
-
-	@Override
-	public String getRowId() {
-		return entityElement().getRowid();
-	}
-
-	@Override
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		final String optimisticLockModeString = Helper.getStringValue( entityElement().getOptimisticLock(), "version" );
-		try {
-			return OptimisticLockStyle.valueOf( optimisticLockModeString.toUpperCase() );
-		}
-		catch ( Exception e ) {
-			throw new MappingException(
-					"Unknown optimistic-lock value : " + optimisticLockModeString,
-					sourceMappingDocument().getOrigin()
-			);
-		}
-	}
-
-	@Override
-	public Caching getCaching() {
-		final JaxbCacheElement cache = entityElement().getCache();
-		if ( cache == null ) {
-			return null;
-		}
-		final String region = cache.getRegion() != null ? cache.getRegion() : getEntityName();
-		final AccessType accessType = Enum.valueOf( AccessType.class, cache.getUsage() );
-		final boolean cacheLazyProps = !"non-lazy".equals( cache.getInclude() );
-		return new Caching( region, accessType, cacheLazyProps );
-	}
-
-	@Override
-	public TableSource getPrimaryTable() {
-		return new TableSource() {
-			@Override
-			public String getExplicitSchemaName() {
-				return entityElement().getSchema();
-			}
-
-			@Override
-			public String getExplicitCatalogName() {
-				return entityElement().getCatalog();
-			}
-
-			@Override
-			public String getExplicitTableName() {
-				return entityElement().getTable();
-			}
-
-			@Override
-			public String getLogicalName() {
-				// logical name for the primary table is null
-				return null;
-			}
-		};
-	}
-
-	@Override
-	public String getDiscriminatorMatchValue() {
-		return entityElement().getDiscriminatorValue();
-	}
-
-	@Override
-	public DiscriminatorSource getDiscriminatorSource() {
-		final JaxbHibernateMapping.JaxbClass.JaxbDiscriminator discriminatorElement = entityElement().getDiscriminator();
-		if ( discriminatorElement == null ) {
-			return null;
-		}
-
-		return new DiscriminatorSource() {
-			@Override
-			public RelationalValueSource getDiscriminatorRelationalValueSource() {
-				if ( StringHelper.isNotEmpty( discriminatorElement.getColumnAttribute() ) ) {
-					return new ColumnAttributeSourceImpl(
-							null, // root table
-							discriminatorElement.getColumnAttribute(),
-							discriminatorElement.isInsert(),
-							discriminatorElement.isInsert()
-					);
-				}
-				else if ( StringHelper.isNotEmpty( discriminatorElement.getFormulaAttribute() ) ) {
-					return new FormulaImpl( null, discriminatorElement.getFormulaAttribute() );
-				}
-				else if ( discriminatorElement.getColumn() != null ) {
-					return new ColumnSourceImpl(
-							null, // root table
-							discriminatorElement.getColumn(),
-							discriminatorElement.isInsert(),
-							discriminatorElement.isInsert()
-					);
-				}
-				else if ( StringHelper.isNotEmpty( discriminatorElement.getFormula() ) ) {
-					return new FormulaImpl( null, discriminatorElement.getFormula() );
-				}
-				else {
-					throw new MappingException( "could not determine source of discriminator mapping", getOrigin() );
-				}
-			}
-
-			@Override
-			public String getExplicitHibernateTypeName() {
-				return discriminatorElement.getType();
-			}
-
-			@Override
-			public boolean isForced() {
-				return discriminatorElement.isForce();
-			}
-
-			@Override
-			public boolean isInserted() {
-				return discriminatorElement.isInsert();
-			}
-		};
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SetAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SetAttributeSourceImpl.java
deleted file mode 100644
index 64b4b6398b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SetAttributeSourceImpl.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSetElement;
-import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.source.binder.AttributeSourceContainer;
-import org.hibernate.metamodel.source.binder.Orderable;
-import org.hibernate.metamodel.source.binder.PluralAttributeNature;
-import org.hibernate.metamodel.source.binder.Sortable;
-
-/**
- * @author Steve Ebersole
- */
-public class SetAttributeSourceImpl extends AbstractPluralAttributeSourceImpl implements Orderable, Sortable {
-	public SetAttributeSourceImpl(JaxbSetElement setElement, AttributeSourceContainer container) {
-		super( setElement, container );
-	}
-
-	@Override
-	public JaxbSetElement getPluralAttributeElement() {
-		return (JaxbSetElement) super.getPluralAttributeElement();
-	}
-
-	@Override
-	public PluralAttributeNature getPluralAttributeNature() {
-		return PluralAttributeNature.SET;
-	}
-
-	@Override
-	public boolean isSorted() {
-		return StringHelper.isNotEmpty( getComparatorName() );
-	}
-
-	@Override
-	public String getComparatorName() {
-		return getPluralAttributeElement().getSort();
-	}
-
-	@Override
-	public boolean isOrdered() {
-		return StringHelper.isNotEmpty( getOrder() );
-	}
-
-	@Override
-	public String getOrder() {
-		return getPluralAttributeElement().getOrderBy();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SingularIdentifierAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SingularIdentifierAttributeSourceImpl.java
deleted file mode 100644
index 9a97314783..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SingularIdentifierAttributeSourceImpl.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * Implementation for {@code <id/>} mappings
- *
- * @author Steve Ebersole
- */
-class SingularIdentifierAttributeSourceImpl implements SingularAttributeSource {
-	private final JaxbHibernateMapping.JaxbClass.JaxbId idElement;
-	private final ExplicitHibernateTypeSource typeSource;
-	private final List<RelationalValueSource> valueSources;
-
-	public SingularIdentifierAttributeSourceImpl(
-			final JaxbHibernateMapping.JaxbClass.JaxbId idElement,
-			LocalBindingContext bindingContext) {
-		this.idElement = idElement;
-		this.typeSource = new ExplicitHibernateTypeSource() {
-			private final String name = idElement.getTypeAttribute() != null
-					? idElement.getTypeAttribute()
-					: idElement.getType() != null
-							? idElement.getType().getName()
-							: null;
-			private final Map<String, String> parameters = ( idElement.getType() != null )
-					? Helper.extractParameters( idElement.getType().getParam() )
-					: null;
-
-			@Override
-			public String getName() {
-				return name;
-			}
-
-			@Override
-			public Map<String, String> getParameters() {
-				return parameters;
-			}
-		};
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getColumnAttribute() {
-						return idElement.getColumnAttribute();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return null;
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return idElement.getColumn();
-					}
-
-					@Override
-					public String getContainingTableName() {
-						// by definition, the identifier should be bound to the primary table of the root entity
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return true;
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return false;
-					}
-
-                    @Override
-                    public boolean isForceNotNull() {
-                        return true;
-                    }
-                },
-				bindingContext
-		);
-	}
-
-	@Override
-	public String getName() {
-		return idElement.getName() == null
-				? "id"
-				: idElement.getName();
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return typeSource;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return idElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return true;
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return false;
-	}
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return PropertyGeneration.INSERT;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return false;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return false;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.BASIC;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return false;
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( idElement.getMeta() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubclassEntitySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubclassEntitySourceImpl.java
deleted file mode 100644
index 473d8075fd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubclassEntitySourceImpl.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbJoinedSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbSubclassElement;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbUnionSubclassElement;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-import org.hibernate.metamodel.source.binder.TableSource;
-
-/**
- * @author Steve Ebersole
- */
-public class SubclassEntitySourceImpl extends AbstractEntitySourceImpl implements SubclassEntitySource {
-	protected SubclassEntitySourceImpl(MappingDocument sourceMappingDocument, EntityElement entityElement) {
-		super( sourceMappingDocument, entityElement );
-	}
-
-	@Override
-	public TableSource getPrimaryTable() {
-		if ( JaxbJoinedSubclassElement.class.isInstance( entityElement() ) ) {
-			return new TableSource() {
-				@Override
-				public String getExplicitSchemaName() {
-					return ( (JaxbJoinedSubclassElement) entityElement() ).getSchema();
-				}
-
-				@Override
-				public String getExplicitCatalogName() {
-					return ( (JaxbJoinedSubclassElement) entityElement() ).getCatalog();
-				}
-
-				@Override
-				public String getExplicitTableName() {
-					return ( (JaxbJoinedSubclassElement) entityElement() ).getTable();
-				}
-
-				@Override
-				public String getLogicalName() {
-					// logical name for the primary table is null
-					return null;
-				}
-			};
-		}
-		else if ( JaxbUnionSubclassElement.class.isInstance( entityElement() ) ) {
-			return new TableSource() {
-				@Override
-				public String getExplicitSchemaName() {
-					return ( (JaxbUnionSubclassElement) entityElement() ).getSchema();
-				}
-
-				@Override
-				public String getExplicitCatalogName() {
-					return ( (JaxbUnionSubclassElement) entityElement() ).getCatalog();
-				}
-
-				@Override
-				public String getExplicitTableName() {
-					return ( (JaxbUnionSubclassElement) entityElement() ).getTable();
-				}
-
-				@Override
-				public String getLogicalName() {
-					// logical name for the primary table is null
-					return null;
-				}
-			};
-		}
-		return null;
-	}
-
-	@Override
-	public String getDiscriminatorMatchValue() {
-		return JaxbSubclassElement.class.isInstance( entityElement() )
-				? ( (JaxbSubclassElement) entityElement() ).getDiscriminatorValue()
-				: null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/TimestampAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/TimestampAttributeSourceImpl.java
deleted file mode 100644
index 52ef5eeab6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/TimestampAttributeSourceImpl.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * Implementation for {@code <timestamp/>} mappings
- *
- * @author Steve Ebersole
- */
-class TimestampAttributeSourceImpl implements SingularAttributeSource {
-	private final JaxbHibernateMapping.JaxbClass.JaxbTimestamp timestampElement;
-	private final LocalBindingContext bindingContext;
-	private final List<RelationalValueSource> valueSources;
-
-	TimestampAttributeSourceImpl(
-			final JaxbHibernateMapping.JaxbClass.JaxbTimestamp timestampElement,
-			LocalBindingContext bindingContext) {
-		this.timestampElement = timestampElement;
-		this.bindingContext = bindingContext;
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getColumnAttribute() {
-						return timestampElement.getColumn();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return null;
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return null;
-					}
-
-					@Override
-					public String getContainingTableName() {
-						// by definition the version should come from the primary table of the root entity.
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return true;
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return true;
-					}
-				},
-				bindingContext
-		);
-	}
-
-	private final ExplicitHibernateTypeSource typeSource = new ExplicitHibernateTypeSource() {
-		@Override
-		public String getName() {
-			return "db".equals( timestampElement.getSource() ) ? "dbtimestamp" : "timestamp";
-		}
-
-		@Override
-		public Map<String, String> getParameters() {
-			return null;
-		}
-	};
-
-	@Override
-	public String getName() {
-		return timestampElement.getName();
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return typeSource;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return timestampElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return true;
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return true;
-	}
-
-	private ValueHolder<PropertyGeneration> propertyGenerationValue = new ValueHolder<PropertyGeneration>(
-			new ValueHolder.DeferredInitializer<PropertyGeneration>() {
-				@Override
-				public PropertyGeneration initialize() {
-					final PropertyGeneration propertyGeneration = timestampElement.getGenerated() == null
-							? PropertyGeneration.NEVER
-							: PropertyGeneration.parse( timestampElement.getGenerated().value() );
-					if ( propertyGeneration == PropertyGeneration.INSERT ) {
-						throw new MappingException(
-								"'generated' attribute cannot be 'insert' for versioning property",
-								bindingContext.getOrigin()
-						);
-					}
-					return propertyGeneration;
-				}
-			}
-	);
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return propertyGenerationValue.getValue();
-	}
-
-	@Override
-	public boolean isLazy() {
-		return false;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return false;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.BASIC;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return true;
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( timestampElement.getMeta() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/VersionAttributeSourceImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/VersionAttributeSourceImpl.java
deleted file mode 100644
index 79dc3d42e6..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/VersionAttributeSourceImpl.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.hbm;
-
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.source.LocalBindingContext;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
-import org.hibernate.metamodel.source.binder.MetaAttributeSource;
-import org.hibernate.metamodel.source.binder.RelationalValueSource;
-import org.hibernate.metamodel.source.binder.SingularAttributeNature;
-import org.hibernate.metamodel.source.binder.SingularAttributeSource;
-
-/**
- * Implementation for {@code <version/>} mappings
- *
- * @author Steve Ebersole
- */
-class VersionAttributeSourceImpl implements SingularAttributeSource {
-	private final JaxbHibernateMapping.JaxbClass.JaxbVersion versionElement;
-	private final LocalBindingContext bindingContext;
-	private final List<RelationalValueSource> valueSources;
-
-	VersionAttributeSourceImpl(
-			final JaxbHibernateMapping.JaxbClass.JaxbVersion versionElement,
-			LocalBindingContext bindingContext) {
-		this.versionElement = versionElement;
-		this.bindingContext = bindingContext;
-		this.valueSources = Helper.buildValueSources(
-				new Helper.ValueSourcesAdapter() {
-					@Override
-					public String getColumnAttribute() {
-						return versionElement.getColumnAttribute();
-					}
-
-					@Override
-					public String getFormulaAttribute() {
-						return null;
-					}
-
-					@Override
-					public List getColumnOrFormulaElements() {
-						return versionElement.getColumn();
-					}
-
-					@Override
-					public String getContainingTableName() {
-						// by definition the version should come from the primary table of the root entity.
-						return null;
-					}
-
-					@Override
-					public boolean isIncludedInInsertByDefault() {
-						return Helper.getBooleanValue( versionElement.isInsert(), true );
-					}
-
-					@Override
-					public boolean isIncludedInUpdateByDefault() {
-						return true;
-					}
-				},
-				bindingContext
-		);
-	}
-
-	private final ExplicitHibernateTypeSource typeSource = new ExplicitHibernateTypeSource() {
-		@Override
-		public String getName() {
-			return versionElement.getType() == null ? "integer" : versionElement.getType();
-		}
-
-		@Override
-		public Map<String, String> getParameters() {
-			return null;
-		}
-	};
-
-	@Override
-	public String getName() {
-		return versionElement.getName();
-	}
-
-	@Override
-	public ExplicitHibernateTypeSource getTypeInformation() {
-		return typeSource;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return versionElement.getAccess();
-	}
-
-	@Override
-	public boolean isInsertable() {
-		return Helper.getBooleanValue( versionElement.isInsert(), true );
-	}
-
-	@Override
-	public boolean isUpdatable() {
-		return true;
-	}
-
-	private ValueHolder<PropertyGeneration> propertyGenerationValue = new ValueHolder<PropertyGeneration>(
-			new ValueHolder.DeferredInitializer<PropertyGeneration>() {
-				@Override
-				public PropertyGeneration initialize() {
-					final PropertyGeneration propertyGeneration = versionElement.getGenerated() == null
-							? PropertyGeneration.NEVER
-							: PropertyGeneration.parse( versionElement.getGenerated().value() );
-					if ( propertyGeneration == PropertyGeneration.INSERT ) {
-						throw new MappingException(
-								"'generated' attribute cannot be 'insert' for versioning property",
-								bindingContext.getOrigin()
-						);
-					}
-					return propertyGeneration;
-				}
-			}
-	);
-
-	@Override
-	public PropertyGeneration getGeneration() {
-		return propertyGenerationValue.getValue();
-	}
-
-	@Override
-	public boolean isLazy() {
-		return false;
-	}
-
-	@Override
-	public boolean isIncludedInOptimisticLocking() {
-		return false;
-	}
-
-	@Override
-	public SingularAttributeNature getNature() {
-		return SingularAttributeNature.BASIC;
-	}
-
-	@Override
-	public boolean isVirtualAttribute() {
-		return false;
-	}
-
-	@Override
-	public boolean areValuesIncludedInInsertByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesIncludedInUpdateByDefault() {
-		return true;
-	}
-
-	@Override
-	public boolean areValuesNullableByDefault() {
-		return true;
-	}
-
-	@Override
-	public List<RelationalValueSource> relationalValueSources() {
-		return valueSources;
-	}
-
-	@Override
-	public boolean isSingular() {
-		return true;
-	}
-
-	@Override
-	public Iterable<MetaAttributeSource> metaAttributes() {
-		return Helper.buildMetaAttributeSources( versionElement.getMeta() );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AssociationResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AssociationResolver.java
deleted file mode 100644
index e0af68dd40..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AssociationResolver.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.SingularAssociationAttributeBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
-
-/**
- * @author Gail Badner
- */
-class AssociationResolver {
-	private final MetadataImplementor metadata;
-
-	AssociationResolver(MetadataImplementor metadata) {
-		this.metadata = metadata;
-	}
-
-	void resolve() {
-		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
-			for ( SingularAssociationAttributeBinding attributeBinding : entityBinding.getEntityReferencingAttributeBindings() ) {
-				resolve( attributeBinding );
-			}
-		}
-	}
-
-	private void resolve(SingularAssociationAttributeBinding attributeBinding) {
-		if ( attributeBinding.getReferencedEntityName() == null ) {
-			throw new IllegalArgumentException(
-					"attributeBinding has null entityName: " + attributeBinding.getAttribute().getName()
-			);
-		}
-		EntityBinding entityBinding = metadata.getEntityBinding( attributeBinding.getReferencedEntityName() );
-		if ( entityBinding == null ) {
-			throw new org.hibernate.MappingException(
-					String.format(
-							"Attribute [%s] refers to unknown entity: [%s]",
-							attributeBinding.getAttribute().getName(),
-							attributeBinding.getReferencedEntityName()
-					)
-			);
-		}
-		AttributeBinding referencedAttributeBinding =
-				attributeBinding.isPropertyReference() ?
-						entityBinding.locateAttributeBinding( attributeBinding.getReferencedAttributeName() ) :
-						entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding();
-		if ( referencedAttributeBinding == null ) {
-			// TODO: does attribute name include path w/ entity name?
-			throw new org.hibernate.MappingException(
-					String.format(
-							"Attribute [%s] refers to unknown attribute: [%s]",
-							attributeBinding.getAttribute().getName(),
-							attributeBinding.getReferencedEntityName()
-					)
-			);
-		}
-		attributeBinding.resolveReference( referencedAttributeBinding );
-		referencedAttributeBinding.addEntityReferencingAttributeBinding( attributeBinding );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/HibernateTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/HibernateTypeResolver.java
deleted file mode 100644
index 80572f327b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/HibernateTypeResolver.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import java.util.Properties;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.binding.AbstractCollectionElement;
-import org.hibernate.metamodel.binding.AbstractPluralAttributeBinding;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.BasicCollectionElement;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.EntityDiscriminator;
-import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.Value;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.type.Type;
-import org.hibernate.type.TypeFactory;
-
-/**
- * This is a TEMPORARY way to initialize Hibernate types.
- * This class will be removed when types are resolved properly.
- *
- * @author Gail Badner
- */
-class HibernateTypeResolver {
-
-	private final MetadataImplementor metadata;
-
-	HibernateTypeResolver(MetadataImplementor metadata) {
-		this.metadata = metadata;
-	}
-
-	void resolve() {
-		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
-			if ( entityBinding.getHierarchyDetails().getEntityDiscriminator() != null ) {
-				resolveDiscriminatorTypeInformation( entityBinding.getHierarchyDetails().getEntityDiscriminator() );
-			}
-			for ( AttributeBinding attributeBinding : entityBinding.attributeBindings() ) {
-				if ( SingularAttributeBinding.class.isInstance( attributeBinding ) ) {
-					resolveSingularAttributeTypeInformation(
-							SingularAttributeBinding.class.cast( attributeBinding  )
-					);
-				}
-				else if ( AbstractPluralAttributeBinding.class.isInstance( attributeBinding ) ) {
-					resolvePluralAttributeTypeInformation(
-							AbstractPluralAttributeBinding.class.cast( attributeBinding )
-					);
-				}
-				else {
-					throw new AssertionFailure( "Unknown type of AttributeBinding: " + attributeBinding.getClass().getName() );
-				}
-			}
-		}
-	}
-
-	// perform any needed type resolutions for discriminator
-	private void resolveDiscriminatorTypeInformation(EntityDiscriminator discriminator) {
-		// perform any needed type resolutions for discriminator
-		Type resolvedHibernateType = determineSingularTypeFromDescriptor( discriminator.getExplicitHibernateTypeDescriptor() );
-		if ( resolvedHibernateType != null ) {
-			pushHibernateTypeInformationDownIfNeeded(
-					discriminator.getExplicitHibernateTypeDescriptor(),
-					discriminator.getBoundValue(),
-					resolvedHibernateType
-			);
-		}
-	}
-
-	private Type determineSingularTypeFromDescriptor(HibernateTypeDescriptor hibernateTypeDescriptor) {
-		if ( hibernateTypeDescriptor.getResolvedTypeMapping() != null ) {
-			return hibernateTypeDescriptor.getResolvedTypeMapping();
-		}
-		String typeName = determineTypeName( hibernateTypeDescriptor );
-		Properties typeParameters = getTypeParameters( hibernateTypeDescriptor );
-		return getHeuristicType( typeName, typeParameters );
-	}
-
-	private static String determineTypeName(HibernateTypeDescriptor hibernateTypeDescriptor) {
-		return hibernateTypeDescriptor.getExplicitTypeName() != null
-				? hibernateTypeDescriptor.getExplicitTypeName()
-				: hibernateTypeDescriptor.getJavaTypeName();
-	}
-
-	private static Properties getTypeParameters(HibernateTypeDescriptor hibernateTypeDescriptor) {
-		Properties typeParameters = new Properties( );
-		if ( hibernateTypeDescriptor.getTypeParameters() != null ) {
-			typeParameters.putAll( hibernateTypeDescriptor.getTypeParameters() );
-		}
-		return typeParameters;
-	}
-
-	// perform any needed type resolutions for SingularAttributeBinding
-	private void resolveSingularAttributeTypeInformation(SingularAttributeBinding attributeBinding) {
-		if ( attributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() != null ) {
-			return;
-		}
-		// we can determine the Hibernate Type if either:
-		// 		1) the user explicitly named a Type in a HibernateTypeDescriptor
-		// 		2) we know the java type of the attribute
-		Type resolvedType;
-		resolvedType = determineSingularTypeFromDescriptor( attributeBinding.getHibernateTypeDescriptor() );
-		if ( resolvedType == null ) {
-			if ( ! attributeBinding.getAttribute().isSingular() ) {
-				throw new AssertionFailure( "SingularAttributeBinding object has a plural attribute: " + attributeBinding.getAttribute().getName() );
-			}
-			final SingularAttribute singularAttribute = ( SingularAttribute ) attributeBinding.getAttribute();
-			if ( singularAttribute.getSingularAttributeType() != null ) {
-				resolvedType = getHeuristicType(
-						singularAttribute.getSingularAttributeType().getClassName(), new Properties()
-				);
-			}
-		}
-		if ( resolvedType != null ) {
-			pushHibernateTypeInformationDownIfNeeded( attributeBinding, resolvedType );
-		}
-	}
-
-	// perform any needed type resolutions for PluralAttributeBinding
-	private void resolvePluralAttributeTypeInformation(AbstractPluralAttributeBinding attributeBinding) {
-		if ( attributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() != null ) {
-			return;
-		}
-		Type resolvedType;
-		// do NOT look at java type...
-		//String typeName = determineTypeName( attributeBinding.getHibernateTypeDescriptor() );
-		String typeName = attributeBinding.getHibernateTypeDescriptor().getExplicitTypeName();
-		if ( typeName != null ) {
-			resolvedType =
-					metadata.getTypeResolver()
-							.getTypeFactory()
-							.customCollection(
-									typeName,
-									getTypeParameters( attributeBinding.getHibernateTypeDescriptor() ),
-									attributeBinding.getAttribute().getName(),
-									attributeBinding.getReferencedPropertyName()
-							);
-		}
-		else {
-			resolvedType = determineDefaultCollectionInformation( attributeBinding );
-		}
-		if ( resolvedType != null ) {
-			pushHibernateTypeInformationDownIfNeeded(
-					attributeBinding.getHibernateTypeDescriptor(),
-					null,
-					resolvedType );
-		}
-		resolveCollectionElementTypeInformation( attributeBinding.getCollectionElement() );
-	}
-
-	private Type determineDefaultCollectionInformation(AbstractPluralAttributeBinding attributeBinding) {
-		final TypeFactory typeFactory = metadata.getTypeResolver().getTypeFactory();
-		switch ( attributeBinding.getAttribute().getNature() ) {
-			case SET: {
-				return typeFactory.set(
-						attributeBinding.getAttribute().getName(),
-						attributeBinding.getReferencedPropertyName()
-				);
-			}
-			case BAG: {
-				return typeFactory.bag(
-						attributeBinding.getAttribute().getName(),
-						attributeBinding.getReferencedPropertyName()
-				);
-			}
-			default: {
-				throw new UnsupportedOperationException(
-						"Collection type not supported yet:" + attributeBinding.getAttribute().getNature()
-				);
-			}
-		}
-	}
-
-	private void resolveCollectionElementTypeInformation(AbstractCollectionElement collectionElement) {
-		switch ( collectionElement.getCollectionElementNature() ) {
-			case BASIC: {
-				resolveBasicCollectionElement( BasicCollectionElement.class.cast( collectionElement ) );
-				break;
-			}
-			case COMPOSITE:
-			case ONE_TO_MANY:
-			case MANY_TO_MANY:
-			case MANY_TO_ANY: {
-				throw new UnsupportedOperationException( "Collection element nature not supported yet: " + collectionElement.getCollectionElementNature() );
-			}
-			default: {
-				throw new AssertionFailure( "Unknown collection element nature : " + collectionElement.getCollectionElementNature() );
-			}
-		}
-	}
-
-	private void resolveBasicCollectionElement(BasicCollectionElement basicCollectionElement) {
-		Type resolvedHibernateType = determineSingularTypeFromDescriptor( basicCollectionElement.getHibernateTypeDescriptor() );
-		if ( resolvedHibernateType != null ) {
-			pushHibernateTypeInformationDownIfNeeded(
-					basicCollectionElement.getHibernateTypeDescriptor(),
-					basicCollectionElement.getElementValue(),
-					resolvedHibernateType
-			);
-		}
-	}
-
-	private Type getHeuristicType(String typeName, Properties typeParameters) {
-		if ( typeName != null ) {
-			try {
-				return metadata.getTypeResolver().heuristicType( typeName, typeParameters );
-			}
-			catch (Exception ignore) {
-			}
-		}
-
-		return null;
-	}
-
-	private void pushHibernateTypeInformationDownIfNeeded(SingularAttributeBinding attributeBinding, Type resolvedHibernateType) {
-
-		final HibernateTypeDescriptor hibernateTypeDescriptor = attributeBinding.getHibernateTypeDescriptor();
-		final SingularAttribute singularAttribute = SingularAttribute.class.cast( attributeBinding.getAttribute() );
-		final Value value = attributeBinding.getValue();
-		if ( ! singularAttribute.isTypeResolved() && hibernateTypeDescriptor.getJavaTypeName() != null ) {
-			singularAttribute.resolveType( metadata.makeJavaType( hibernateTypeDescriptor.getJavaTypeName() ) );
-		}
-
-		// sql type information ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-		this.pushHibernateTypeInformationDownIfNeeded(
-				hibernateTypeDescriptor, value, resolvedHibernateType
-		);
-	}
-
-	private void pushHibernateTypeInformationDownIfNeeded(
-			HibernateTypeDescriptor hibernateTypeDescriptor,
-			Value value,
-			Type resolvedHibernateType) {
-		if ( resolvedHibernateType == null ) {
-			return;
-		}
-		if ( hibernateTypeDescriptor.getResolvedTypeMapping() == null ) {
-			hibernateTypeDescriptor.setResolvedTypeMapping( resolvedHibernateType );
-		}
-
-		// java type information ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-		if ( hibernateTypeDescriptor.getJavaTypeName() == null ) {
-			hibernateTypeDescriptor.setJavaTypeName( resolvedHibernateType.getReturnedClass().getName() );
-		}
-
-	   // todo : this can be made a lot smarter, but for now this will suffice.  currently we only handle single value bindings
-
-	   if ( SimpleValue.class.isInstance( value ) ) {
-		   SimpleValue simpleValue = ( SimpleValue ) value;
-		   if ( simpleValue.getDatatype() == null ) {
-			   simpleValue.setDatatype(
-					   new Datatype(
-							   resolvedHibernateType.sqlTypes( metadata )[0],
-							   resolvedHibernateType.getName(),
-							   resolvedHibernateType.getReturnedClass()
-					   )
-			   );
-		   }
-	   }
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java
deleted file mode 100644
index b690c79196..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import java.io.Serializable;
-import java.util.Properties;
-
-import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.cfg.ObjectNameNormalizer;
-import org.hibernate.engine.config.spi.ConfigurationService;
-import org.hibernate.cfg.naming.NamingStrategyDelegator;
-import org.hibernate.id.PersistentIdentifierGenerator;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
-
-/**
- * @author Gail Badner
- */
-public class IdentifierGeneratorResolver {
-
-	private final MetadataImplementor metadata;
-
-	IdentifierGeneratorResolver(MetadataImplementor metadata) {
-		this.metadata = metadata;
-	}
-
-	// IdentifierGeneratorResolver.resolve() must execute after AttributeTypeResolver.resolve()
-	// to ensure that identifier type is resolved.
-	@SuppressWarnings( {"unchecked"} )
-	void resolve() {
-		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
-			if ( entityBinding.isRoot() ) {
-				Properties properties = new Properties( );
-				properties.putAll(
-						metadata.getServiceRegistry()
-								.getService( ConfigurationService.class )
-								.getSettings()
-				);
-				//TODO: where should these be added???
-				if ( ! properties.contains( AvailableSettings.PREFER_POOLED_VALUES_LO ) ) {
-					properties.put( AvailableSettings.PREFER_POOLED_VALUES_LO, "false" );
-				}
-				if ( ! properties.contains( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER ) ) {
-					properties.put(
-							PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER,
-							new ObjectNameNormalizerImpl( metadata )
-					);
-				}
-				entityBinding.getHierarchyDetails().getEntityIdentifier().createIdentifierGenerator(
-						metadata.getIdentifierGeneratorFactory(),
-						properties
-				);
-			}
-		}
-	}
-
-	private static class ObjectNameNormalizerImpl extends ObjectNameNormalizer implements Serializable {
-		private final boolean useQuotedIdentifiersGlobally;
-		private final NamingStrategy namingStrategy;
-
-		private ObjectNameNormalizerImpl(MetadataImplementor metadata ) {
-			this.useQuotedIdentifiersGlobally = metadata.isGloballyQuotedIdentifiers();
-			this.namingStrategy = metadata.getNamingStrategy();
-		}
-
-		@Override
-		protected boolean isUseQuotedIdentifiersGlobally() {
-			return useQuotedIdentifiersGlobally;
-		}
-
-		@Override
-		protected NamingStrategy getNamingStrategy() {
-			return namingStrategy;
-		}
-
-		@Override
-		protected NamingStrategyDelegator getNamingStrategyDelegator() {
-			return null;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
deleted file mode 100644
index 44f9874fcd..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import javax.xml.XMLConstants;
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.ValidationEvent;
-import javax.xml.bind.ValidationEventHandler;
-import javax.xml.bind.ValidationEventLocator;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.events.Attribute;
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.XsdException;
-
-import org.jboss.logging.Logger;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.xml.sax.SAXException;
-
-/**
- * Helper class for unmarshalling xml configuration using StAX and JAXB.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class JaxbHelper {
-	private static final Logger log = Logger.getLogger( JaxbHelper.class );
-
-	public static final String ASSUMED_ORM_XSD_VERSION = "2.0";
-
-	private final MetadataSources metadataSources;
-
-	public JaxbHelper(MetadataSources metadataSources) {
-		this.metadataSources = metadataSources;
-	}
-
-	public JaxbRoot unmarshal(InputStream stream, Origin origin) {
-		try {
-			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
-			try {
-				return unmarshal( staxReader, origin );
-			}
-			finally {
-				try {
-					staxReader.close();
-				}
-				catch ( Exception ignore ) {
-				}
-			}
-		}
-		catch ( XMLStreamException e ) {
-			throw new MappingException( "Unable to create stax reader", e, origin );
-		}
-	}
-
-	private XMLInputFactory staxFactory;
-
-	private XMLInputFactory staxFactory() {
-		if ( staxFactory == null ) {
-			staxFactory = buildStaxFactory();
-		}
-		return staxFactory;
-	}
-
-	@SuppressWarnings( { "UnnecessaryLocalVariable" })
-	private XMLInputFactory buildStaxFactory() {
-		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
-		return staxFactory;
-	}
-
-	private static final QName ORM_VERSION_ATTRIBUTE_QNAME = new QName( "version" );
-
-	@SuppressWarnings( { "unchecked" })
-	private JaxbRoot unmarshal(XMLEventReader staxEventReader, final Origin origin) {
-		XMLEvent event;
-		try {
-			event = staxEventReader.peek();
-			while ( event != null && !event.isStartElement() ) {
-				staxEventReader.nextEvent();
-				event = staxEventReader.peek();
-			}
-		}
-		catch ( Exception e ) {
-			throw new MappingException( "Error accessing stax stream", e, origin );
-		}
-
-		if ( event == null ) {
-			throw new MappingException( "Could not locate root element", origin );
-		}
-
-		final Schema validationSchema;
-		final Class jaxbTarget;
-
-		final String elementName = event.asStartElement().getName().getLocalPart();
-
-		if ( "entity-mappings".equals( elementName ) ) {
-			final Attribute attribute = event.asStartElement().getAttributeByName( ORM_VERSION_ATTRIBUTE_QNAME );
-			final String explicitVersion = attribute == null ? null : attribute.getValue();
-			validationSchema = resolveSupportedOrmXsd( explicitVersion );
-			jaxbTarget = JaxbEntityMappings.class;
-		}
-		else {
-			validationSchema = hbmSchema();
-			jaxbTarget = JaxbHibernateMapping.class;
-		}
-
-		final Object target;
-		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
-		try {
-			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
-			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
-			unmarshaller.setSchema( validationSchema );
-			unmarshaller.setEventHandler( handler );
-			target = unmarshaller.unmarshal( staxEventReader );
-		}
-
-		catch ( JAXBException e ) {
-			StringBuilder builder = new StringBuilder();
-			builder.append( "Unable to perform unmarshalling at line number " );
-			builder.append( handler.getLineNumber() );
-			builder.append( " and column " );
-			builder.append( handler.getColumnNumber() );
-			builder.append( ". Message: " );
-			builder.append( handler.getMessage() );
-			throw new MappingException( builder.toString(), e, origin );
-		}
-
-		return new JaxbRoot( target, origin );
-	}
-
-	@SuppressWarnings( { "unchecked" })
-	public JaxbRoot unmarshal(Document document, Origin origin) {
-		Element rootElement = document.getDocumentElement();
-		if ( rootElement == null ) {
-			throw new MappingException( "No root element found", origin );
-		}
-
-		final Schema validationSchema;
-		final Class jaxbTarget;
-
-		if ( "entity-mappings".equals( rootElement.getNodeName() ) ) {
-			final String explicitVersion = rootElement.getAttribute( "version" );
-			validationSchema = resolveSupportedOrmXsd( explicitVersion );
-			jaxbTarget = JaxbEntityMappings.class;
-		}
-		else {
-			validationSchema = hbmSchema();
-			jaxbTarget = JaxbHibernateMapping.class;
-		}
-
-		final Object target;
-		try {
-			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
-			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
-			unmarshaller.setSchema( validationSchema );
-			target = unmarshaller.unmarshal( new DOMSource( document ) );
-		}
-		catch ( JAXBException e ) {
-			throw new MappingException( "Unable to perform unmarshalling", e, origin );
-		}
-
-		return new JaxbRoot( target, origin );
-	}
-
-	private Schema resolveSupportedOrmXsd(String explicitVersion) {
-		final String xsdVersionString = explicitVersion == null ? ASSUMED_ORM_XSD_VERSION : explicitVersion;
-		if ( "1.0".equals( xsdVersionString ) ) {
-			return orm1Schema();
-		}
-		else if ( "2.0".equals( xsdVersionString ) ) {
-			return orm2Schema();
-		}
-		throw new IllegalArgumentException( "Unsupported orm.xml XSD version encountered [" + xsdVersionString + "]" );
-	}
-
-	public static final String HBM_SCHEMA_NAME = "org/hibernate/hibernate-mapping-4.0.xsd";
-	public static final String ORM_1_SCHEMA_NAME = "org/hibernate/jpa/orm_1_0.xsd";
-	public static final String ORM_2_SCHEMA_NAME = "org/hibernate/jpa/orm_2_0.xsd";
-
-	private Schema hbmSchema;
-
-	private Schema hbmSchema() {
-		if ( hbmSchema == null ) {
-			hbmSchema = resolveLocalSchema( HBM_SCHEMA_NAME );
-		}
-		return hbmSchema;
-	}
-
-	private Schema orm1Schema;
-
-	private Schema orm1Schema() {
-		if ( orm1Schema == null ) {
-			orm1Schema = resolveLocalSchema( ORM_1_SCHEMA_NAME );
-		}
-		return orm1Schema;
-	}
-
-	private Schema orm2Schema;
-
-	private Schema orm2Schema() {
-		if ( orm2Schema == null ) {
-			orm2Schema = resolveLocalSchema( ORM_2_SCHEMA_NAME );
-		}
-		return orm2Schema;
-	}
-
-	private Schema resolveLocalSchema(String schemaName) {
-		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
-	}
-
-	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
-		URL url = metadataSources.getServiceRegistry()
-				.getService( ClassLoaderService.class )
-				.locateResource( schemaName );
-		if ( url == null ) {
-			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
-		}
-		try {
-			InputStream schemaStream = url.openStream();
-			try {
-				StreamSource source = new StreamSource( url.openStream() );
-				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
-				return schemaFactory.newSchema( source );
-			}
-			catch ( SAXException e ) {
-				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
-			}
-			catch ( IOException e ) {
-				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
-			}
-			finally {
-				try {
-					schemaStream.close();
-				}
-				catch ( IOException e ) {
-					log.debugf( "Problem closing schema stream [%s]", e.toString() );
-				}
-			}
-		}
-		catch ( IOException e ) {
-			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
-		}
-	}
-
-	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
-		private int lineNumber;
-		private int columnNumber;
-		private String message;
-
-		@Override
-		public boolean handleEvent(ValidationEvent validationEvent) {
-			ValidationEventLocator locator = validationEvent.getLocator();
-			lineNumber = locator.getLineNumber();
-			columnNumber = locator.getColumnNumber();
-			message = validationEvent.getMessage();
-			return false;
-		}
-
-		public int getLineNumber() {
-			return lineNumber;
-		}
-
-		public int getColumnNumber() {
-			return columnNumber;
-		}
-
-		public String getMessage() {
-			return message;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
deleted file mode 100644
index ae7818fe1e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import javax.persistence.SharedCacheMode;
-
-import org.hibernate.HibernateException;
-import org.hibernate.boot.registry.BootstrapServiceRegistry;
-import org.hibernate.boot.registry.StandardServiceRegistry;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.cfg.EJB3NamingStrategy;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.engine.config.spi.ConfigurationService;
-import org.hibernate.metamodel.Metadata;
-import org.hibernate.metamodel.MetadataBuilder;
-import org.hibernate.metamodel.MetadataSourceProcessingOrder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.service.ServiceRegistry;
-
-import org.jboss.logging.Logger;
-
-/**
- * @author Steve Ebersole
- */
-public class MetadataBuilderImpl implements MetadataBuilder {
-	private static final Logger log = Logger.getLogger( MetadataBuilderImpl.class );
-
-	private final MetadataSources sources;
-	private final OptionsImpl options;
-
-	public MetadataBuilderImpl(MetadataSources sources) {
-		this(
-				sources,
-				getStandardServiceRegistry( sources.getServiceRegistry() )
-		);
-	}
-
-	private static StandardServiceRegistry getStandardServiceRegistry(ServiceRegistry serviceRegistry) {
-		if ( serviceRegistry == null ) {
-			throw new HibernateException( "ServiceRegistry passed to MetadataBuilder cannot be null" );
-		}
-
-		if ( StandardServiceRegistry.class.isInstance( serviceRegistry ) ) {
-			return ( StandardServiceRegistry ) serviceRegistry;
-		}
-		else if ( BootstrapServiceRegistry.class.isInstance( serviceRegistry ) ) {
-			log.debugf(
-					"ServiceRegistry passed to MetadataBuilder was a BootstrapServiceRegistry; this likely wont end well" +
-							"if attempt is made to build SessionFactory"
-			);
-			return new StandardServiceRegistryBuilder( (BootstrapServiceRegistry) serviceRegistry ).build();
-		}
-		else {
-			throw new HibernateException(
-					String.format(
-							"Unexpected type of ServiceRegistry [%s] encountered in attempt to build MetadataBuilder",
-							serviceRegistry.getClass().getName()
-					)
-			);
-		}
-	}
-
-	public MetadataBuilderImpl(MetadataSources sources, StandardServiceRegistry serviceRegistry) {
-		this.sources = sources;
-		this.options = new OptionsImpl( serviceRegistry );
-	}
-
-	@Override
-	public MetadataBuilder with(NamingStrategy namingStrategy) {
-		this.options.namingStrategy = namingStrategy;
-		return this;
-	}
-
-	@Override
-	public MetadataBuilder with(MetadataSourceProcessingOrder metadataSourceProcessingOrder) {
-		this.options.metadataSourceProcessingOrder = metadataSourceProcessingOrder;
-		return this;
-	}
-
-	@Override
-	public MetadataBuilder with(SharedCacheMode sharedCacheMode) {
-		this.options.sharedCacheMode = sharedCacheMode;
-		return this;
-	}
-
-	@Override
-	public MetadataBuilder with(AccessType accessType) {
-		this.options.defaultCacheAccessType = accessType;
-		return this;
-	}
-
-	@Override
-	public MetadataBuilder withNewIdentifierGeneratorsEnabled(boolean enabled) {
-		this.options.useNewIdentifierGenerators = enabled;
-		return this;
-	}
-
-	@Override
-	public Metadata build() {
-		return new MetadataImpl( sources, options );
-	}
-
-	public static class OptionsImpl implements Metadata.Options {
-		private final StandardServiceRegistry serviceRegistry;
-
-		private MetadataSourceProcessingOrder metadataSourceProcessingOrder = MetadataSourceProcessingOrder.HBM_FIRST;
-		private NamingStrategy namingStrategy = EJB3NamingStrategy.INSTANCE;
-		private SharedCacheMode sharedCacheMode = SharedCacheMode.ENABLE_SELECTIVE;
-		private AccessType defaultCacheAccessType;
-        private boolean useNewIdentifierGenerators;
-        private boolean globallyQuotedIdentifiers;
-		private String defaultSchemaName;
-		private String defaultCatalogName;
-
-		public OptionsImpl(StandardServiceRegistry serviceRegistry) {
-			this.serviceRegistry = serviceRegistry;
-
-			ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
-
-			// cache access type
-			defaultCacheAccessType = configService.getSetting(
-					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
-					new ConfigurationService.Converter<AccessType>() {
-						@Override
-						public AccessType convert(Object value) {
-							return AccessType.fromExternalName( value.toString() );
-						}
-					}
-			);
-
-			useNewIdentifierGenerators = configService.getSetting(
-					AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS,
-					new ConfigurationService.Converter<Boolean>() {
-						@Override
-						public Boolean convert(Object value) {
-							return Boolean.parseBoolean( value.toString() );
-						}
-					},
-					false
-			);
-
-			defaultSchemaName = configService.getSetting(
-					AvailableSettings.DEFAULT_SCHEMA,
-					new ConfigurationService.Converter<String>() {
-						@Override
-						public String convert(Object value) {
-							return value.toString();
-						}
-					},
-					null
-			);
-
-			defaultCatalogName = configService.getSetting(
-					AvailableSettings.DEFAULT_CATALOG,
-					new ConfigurationService.Converter<String>() {
-						@Override
-						public String convert(Object value) {
-							return value.toString();
-						}
-					},
-					null
-			);
-
-            globallyQuotedIdentifiers = configService.getSetting(
-                    AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS,
-                    new ConfigurationService.Converter<Boolean>() {
-                        @Override
-                        public Boolean convert(Object value) {
-                            return Boolean.parseBoolean( value.toString() );
-                        }
-                    },
-                    false
-            );
-		}
-
-		@Override
-		public StandardServiceRegistry getServiceRegistry() {
-			return serviceRegistry;
-		}
-
-		@Override
-		public MetadataSourceProcessingOrder getMetadataSourceProcessingOrder() {
-			return metadataSourceProcessingOrder;
-		}
-
-		@Override
-		public NamingStrategy getNamingStrategy() {
-			return namingStrategy;
-		}
-
-		@Override
-		public AccessType getDefaultAccessType() {
-			return defaultCacheAccessType;
-		}
-
-		@Override
-		public SharedCacheMode getSharedCacheMode() {
-			return sharedCacheMode;
-		}
-
-		@Override
-        public boolean useNewIdentifierGenerators() {
-            return useNewIdentifierGenerators;
-        }
-
-        @Override
-        public boolean isGloballyQuotedIdentifiers() {
-            return globallyQuotedIdentifiers;
-        }
-
-        @Override
-		public String getDefaultSchemaName() {
-			return defaultSchemaName;
-		}
-
-		@Override
-		public String getDefaultCatalogName() {
-			return defaultCatalogName;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
deleted file mode 100644
index 6ef5630fde..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.DuplicateMappingException;
-import org.hibernate.MappingException;
-import org.hibernate.SessionFactory;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cache.spi.RegionFactory;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.engine.ResultSetMappingDefinition;
-import org.hibernate.engine.spi.FilterDefinition;
-import org.hibernate.engine.spi.NamedQueryDefinition;
-import org.hibernate.engine.spi.NamedSQLQueryDefinition;
-import org.hibernate.id.factory.IdentifierGeneratorFactory;
-import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.MetadataSourceProcessingOrder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.domain.BasicType;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.metamodel.relational.Database;
-import org.hibernate.metamodel.source.MappingDefaults;
-import org.hibernate.metamodel.source.MetaAttributeContext;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.MetadataSourceProcessor;
-import org.hibernate.metamodel.source.annotations.AnnotationMetadataSourceProcessorImpl;
-import org.hibernate.metamodel.source.hbm.HbmMetadataSourceProcessorImpl;
-import org.hibernate.persister.spi.PersisterClassResolver;
-import org.hibernate.service.ServiceRegistry;
-import org.hibernate.type.TypeResolver;
-
-import org.jboss.logging.Logger;
-
-/**
- * Container for configuration data collected during binding the metamodel.
- *
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- * @author Gail Badner
- */
-public class MetadataImpl implements MetadataImplementor, Serializable {
-
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			MetadataImpl.class.getName()
-	);
-
-	private final ServiceRegistry serviceRegistry;
-	private final Options options;
-
-	private final transient ValueHolder<ClassLoaderService> classLoaderService;
-	private final transient ValueHolder<PersisterClassResolver> persisterClassResolverService;
-
-	private TypeResolver typeResolver = new TypeResolver();
-
-	private final MutableIdentifierGeneratorFactory identifierGeneratorFactory;
-
-	private final Database database;
-
-	private final MappingDefaults mappingDefaults;
-
-	/**
-	 * Maps the fully qualified class name of an entity to its entity binding
-	 */
-	private Map<String, EntityBinding> entityBindingMap = new HashMap<String, EntityBinding>();
-
-	private Map<String, PluralAttributeBinding> collectionBindingMap = new HashMap<String, PluralAttributeBinding>();
-	private Map<String, FetchProfile> fetchProfiles = new HashMap<String, FetchProfile>();
-	private Map<String, String> imports = new HashMap<String, String>();
-	private Map<String, TypeDef> typeDefs = new HashMap<String, TypeDef>();
-	private Map<String, IdGenerator> idGenerators = new HashMap<String, IdGenerator>();
-	private Map<String, NamedQueryDefinition> namedQueryDefs = new HashMap<String, NamedQueryDefinition>();
-	private Map<String, NamedSQLQueryDefinition> namedNativeQueryDefs = new HashMap<String, NamedSQLQueryDefinition>();
-	private Map<String, ResultSetMappingDefinition> resultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
-	private Map<String, FilterDefinition> filterDefs = new HashMap<String, FilterDefinition>();
-
-    private boolean globallyQuotedIdentifiers = false;
-
-	public MetadataImpl(MetadataSources metadataSources, Options options) {
-		this.serviceRegistry =  options.getServiceRegistry();
-		this.options = options;
-		this.identifierGeneratorFactory = serviceRegistry.getService( MutableIdentifierGeneratorFactory.class );
-				//new DefaultIdentifierGeneratorFactory( dialect );
-		this.database = new Database( options );
-
-		this.mappingDefaults = new MappingDefaultsImpl();
-
-		final MetadataSourceProcessor[] metadataSourceProcessors;
-		if ( options.getMetadataSourceProcessingOrder() == MetadataSourceProcessingOrder.HBM_FIRST ) {
-			metadataSourceProcessors = new MetadataSourceProcessor[] {
-					new HbmMetadataSourceProcessorImpl( this ),
-					new AnnotationMetadataSourceProcessorImpl( this )
-			};
-		}
-		else {
-			metadataSourceProcessors = new MetadataSourceProcessor[] {
-					new AnnotationMetadataSourceProcessorImpl( this ),
-					new HbmMetadataSourceProcessorImpl( this )
-			};
-		}
-
-		this.classLoaderService = new ValueHolder<ClassLoaderService>(
-				new ValueHolder.DeferredInitializer<ClassLoaderService>() {
-					@Override
-					public ClassLoaderService initialize() {
-						return serviceRegistry.getService( ClassLoaderService.class );
-					}
-				}
-		);
-		this.persisterClassResolverService = new ValueHolder<PersisterClassResolver>(
-				new ValueHolder.DeferredInitializer<PersisterClassResolver>() {
-					@Override
-					public PersisterClassResolver initialize() {
-						return serviceRegistry.getService( PersisterClassResolver.class );
-					}
-				}
-		);
-
-
-		final ArrayList<String> processedEntityNames = new ArrayList<String>();
-
-		prepare( metadataSourceProcessors, metadataSources );
-		bindIndependentMetadata( metadataSourceProcessors, metadataSources );
-		bindTypeDependentMetadata( metadataSourceProcessors, metadataSources );
-		bindMappingMetadata( metadataSourceProcessors, metadataSources, processedEntityNames );
-		bindMappingDependentMetadata( metadataSourceProcessors, metadataSources );
-
-		// todo : remove this by coordinated ordering of entity processing
-		new AssociationResolver( this ).resolve();
-		new HibernateTypeResolver( this ).resolve();
-		// IdentifierGeneratorResolver.resolve() must execute after AttributeTypeResolver.resolve()
-		new IdentifierGeneratorResolver( this ).resolve();
-	}
-
-	private void prepare(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
-		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
-			metadataSourceProcessor.prepare( metadataSources );
-		}
-	}
-
-	private void bindIndependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
-		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
-			metadataSourceProcessor.processIndependentMetadata( metadataSources );
-		}
-	}
-
-	private void bindTypeDependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
-		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
-			metadataSourceProcessor.processTypeDependentMetadata( metadataSources );
-		}
-	}
-
-	private void bindMappingMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources, List<String> processedEntityNames) {
-		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
-			metadataSourceProcessor.processMappingMetadata( metadataSources, processedEntityNames );
-		}
-	}
-
-	private void bindMappingDependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
-		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
-			metadataSourceProcessor.processMappingDependentMetadata( metadataSources );
-		}
-	}
-
-	@Override
-	public void addFetchProfile(FetchProfile profile) {
-		if ( profile == null || profile.getName() == null ) {
-			throw new IllegalArgumentException( "Fetch profile object or name is null: " + profile );
-		}
-		fetchProfiles.put( profile.getName(), profile );
-	}
-
-	@Override
-	public void addFilterDefinition(FilterDefinition def) {
-		if ( def == null || def.getFilterName() == null ) {
-			throw new IllegalArgumentException( "Filter definition object or name is null: "  + def );
-		}
-		filterDefs.put( def.getFilterName(), def );
-	}
-
-	public Iterable<FilterDefinition> getFilterDefinitions() {
-		return filterDefs.values();
-	}
-
-	@Override
-	public void addIdGenerator(IdGenerator generator) {
-		if ( generator == null || generator.getName() == null ) {
-			throw new IllegalArgumentException( "ID generator object or name is null." );
-		}
-		idGenerators.put( generator.getName(), generator );
-	}
-
-	@Override
-	public IdGenerator getIdGenerator(String name) {
-		if ( name == null ) {
-			throw new IllegalArgumentException( "null is not a valid generator name" );
-		}
-		return idGenerators.get( name );
-	}
-	@Override
-	public void registerIdentifierGenerator(String name, String generatorClassName) {
-		 identifierGeneratorFactory.register( name, classLoaderService().classForName( generatorClassName ) );
-	}
-
-	@Override
-	public void addNamedNativeQuery(NamedSQLQueryDefinition def) {
-		if ( def == null || def.getName() == null ) {
-			throw new IllegalArgumentException( "Named native query definition object or name is null: " + def.getQueryString() );
-		}
-		namedNativeQueryDefs.put( def.getName(), def );
-	}
-
-	public NamedSQLQueryDefinition getNamedNativeQuery(String name) {
-		if ( name == null ) {
-			throw new IllegalArgumentException( "null is not a valid native query name" );
-		}
-		return namedNativeQueryDefs.get( name );
-	}
-
-	@Override
-	public Iterable<NamedSQLQueryDefinition> getNamedNativeQueryDefinitions() {
-		return namedNativeQueryDefs.values();
-	}
-
-	@Override
-	public void addNamedQuery(NamedQueryDefinition def) {
-		if ( def == null ) {
-			throw new IllegalArgumentException( "Named query definition is null" );
-		}
-		else if ( def.getName() == null ) {
-			throw new IllegalArgumentException( "Named query definition name is null: " + def.getQueryString() );
-		}
-		namedQueryDefs.put( def.getName(), def );
-	}
-
-	public NamedQueryDefinition getNamedQuery(String name) {
-		if ( name == null ) {
-			throw new IllegalArgumentException( "null is not a valid query name" );
-		}
-		return namedQueryDefs.get( name );
-	}
-
-	@Override
-	public Iterable<NamedQueryDefinition> getNamedQueryDefinitions() {
-		return namedQueryDefs.values();
-	}
-
-	@Override
-	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition) {
-		if ( resultSetMappingDefinition == null || resultSetMappingDefinition.getName() == null ) {
-			throw new IllegalArgumentException( "Result-set mapping object or name is null: " + resultSetMappingDefinition );
-		}
-		resultSetMappings.put( resultSetMappingDefinition.getName(), resultSetMappingDefinition );
-	}
-
-	@Override
-	public Iterable<ResultSetMappingDefinition> getResultSetMappingDefinitions() {
-		return resultSetMappings.values();
-	}
-
-	@Override
-	public void addTypeDefinition(TypeDef typeDef) {
-		if ( typeDef == null ) {
-			throw new IllegalArgumentException( "Type definition is null" );
-		}
-		else if ( typeDef.getName() == null ) {
-			throw new IllegalArgumentException( "Type definition name is null: " + typeDef.getTypeClass() );
-		}
-		final TypeDef previous = typeDefs.put( typeDef.getName(), typeDef );
-		if ( previous != null ) {
-			LOG.debugf( "Duplicate typedef name [%s] now -> %s", typeDef.getName(), typeDef.getTypeClass() );
-		}
-	}
-
-	@Override
-	public Iterable<TypeDef> getTypeDefinitions() {
-		return typeDefs.values();
-	}
-
-	@Override
-	public TypeDef getTypeDefinition(String name) {
-		return typeDefs.get( name );
-	}
-
-	private ClassLoaderService classLoaderService() {
-		return classLoaderService.getValue();
-	}
-
-	private PersisterClassResolver persisterClassResolverService() {
-		return persisterClassResolverService.getValue();
-	}
-
-	@Override
-	public Options getOptions() {
-		return options;
-	}
-
-	@Override
-	public ServiceRegistry getServiceRegistry() {
-		return serviceRegistry;
-	}
-
-	@Override
-	@SuppressWarnings( {"unchecked"})
-	public <T> Class<T> locateClassByName(String name) {
-		return classLoaderService().classForName( name );
-	}
-
-	@Override
-	public Type makeJavaType(String className) {
-		// todo : have this perform some analysis of the incoming type name to determine appropriate return
-		return new BasicType( className, makeClassReference( className ) );
-	}
-
-	@Override
-	public ValueHolder<Class<?>> makeClassReference(final String className) {
-		return new ValueHolder<Class<?>>(
-				new ValueHolder.DeferredInitializer<Class<?>>() {
-					@Override
-					public Class<?> initialize() {
-						return classLoaderService.getValue().classForName( className );
-					}
-				}
-		);
-	}
-
-	@Override
-	public String qualifyClassName(String name) {
-		return name;
-	}
-
-	@Override
-	public Database getDatabase() {
-		return database;
-	}
-
-	public EntityBinding getEntityBinding(String entityName) {
-		return entityBindingMap.get( entityName );
-	}
-
-	@Override
-	public EntityBinding getRootEntityBinding(String entityName) {
-		EntityBinding binding = entityBindingMap.get( entityName );
-		if ( binding == null ) {
-			throw new IllegalStateException( "Unknown entity binding: " + entityName );
-		}
-
-		do {
-			if ( binding.isRoot() ) {
-				return binding;
-			}
-			binding = binding.getSuperEntityBinding();
-		} while ( binding != null );
-
-		throw new AssertionFailure( "Entity binding has no root: " + entityName );
-	}
-
-	public Iterable<EntityBinding> getEntityBindings() {
-		return entityBindingMap.values();
-	}
-
-	public void addEntity(EntityBinding entityBinding) {
-		final String entityName = entityBinding.getEntity().getName();
-		if ( entityBindingMap.containsKey( entityName ) ) {
-			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, entityName );
-		}
-		entityBindingMap.put( entityName, entityBinding );
-	}
-
-	public PluralAttributeBinding getCollection(String collectionRole) {
-		return collectionBindingMap.get( collectionRole );
-	}
-
-	@Override
-	public Iterable<PluralAttributeBinding> getCollectionBindings() {
-		return collectionBindingMap.values();
-	}
-
-	public void addCollection(PluralAttributeBinding pluralAttributeBinding) {
-		final String owningEntityName = pluralAttributeBinding.getContainer().getPathBase();
-		final String attributeName = pluralAttributeBinding.getAttribute().getName();
-		final String collectionRole = owningEntityName + '.' + attributeName;
-		if ( collectionBindingMap.containsKey( collectionRole ) ) {
-			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, collectionRole );
-		}
-		collectionBindingMap.put( collectionRole, pluralAttributeBinding );
-	}
-
-	public void addImport(String importName, String entityName) {
-		if ( importName == null || entityName == null ) {
-			throw new IllegalArgumentException( "Import name or entity name is null" );
-		}
-		LOG.tracev( "Import: {0} -> {1}", importName, entityName );
-		String old = imports.put( importName, entityName );
-		if ( old != null ) {
-			LOG.debug( "import name [" + importName + "] overrode previous [{" + old + "}]" );
-		}
-	}
-
-	@Override
-	public Iterable<Map.Entry<String, String>> getImports() {
-		return imports.entrySet();
-	}
-
-	@Override
-	public Iterable<FetchProfile> getFetchProfiles() {
-		return fetchProfiles.values();
-	}
-
-	public TypeResolver getTypeResolver() {
-		return typeResolver;
-	}
-
-	@Override
-	public SessionFactoryBuilder getSessionFactoryBuilder() {
-		return new SessionFactoryBuilderImpl( this );
-	}
-
-	@Override
-	public SessionFactory buildSessionFactory() {
-		return getSessionFactoryBuilder().build();
-	}
-
-	@Override
-	public NamingStrategy getNamingStrategy() {
-		return options.getNamingStrategy();
-	}
-
-    @Override
-    public boolean isGloballyQuotedIdentifiers() {
-        return globallyQuotedIdentifiers || getOptions().isGloballyQuotedIdentifiers();
-    }
-
-    public void setGloballyQuotedIdentifiers(boolean globallyQuotedIdentifiers){
-       this.globallyQuotedIdentifiers = globallyQuotedIdentifiers;
-    }
-
-    @Override
-	public MappingDefaults getMappingDefaults() {
-		return mappingDefaults;
-	}
-
-	private final MetaAttributeContext globalMetaAttributeContext = new MetaAttributeContext();
-
-	@Override
-	public MetaAttributeContext getGlobalMetaAttributeContext() {
-		return globalMetaAttributeContext;
-	}
-
-	@Override
-	public MetadataImplementor getMetadataImplementor() {
-		return this;
-	}
-
-	private static final String DEFAULT_IDENTIFIER_COLUMN_NAME = "id";
-	private static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "class";
-	private static final String DEFAULT_CASCADE = "none";
-	private static final String DEFAULT_PROPERTY_ACCESS = "property";
-
-	@Override
-	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
-		return identifierGeneratorFactory;
-	}
-
-	@Override
-	public org.hibernate.type.Type getIdentifierType(String entityName) throws MappingException {
-		EntityBinding entityBinding = getEntityBinding( entityName );
-		if ( entityBinding == null ) {
-			throw new MappingException( "Entity binding not known: " + entityName );
-		}
-		return entityBinding
-				.getHierarchyDetails()
-				.getEntityIdentifier()
-				.getValueBinding()
-				.getHibernateTypeDescriptor()
-				.getResolvedTypeMapping();
-	}
-
-	@Override
-	public String getIdentifierPropertyName(String entityName) throws MappingException {
-		EntityBinding entityBinding = getEntityBinding( entityName );
-		if ( entityBinding == null ) {
-			throw new MappingException( "Entity binding not known: " + entityName );
-		}
-		AttributeBinding idBinding = entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding();
-		return idBinding == null ? null : idBinding.getAttribute().getName();
-	}
-
-	@Override
-	public org.hibernate.type.Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
-		EntityBinding entityBinding = getEntityBinding( entityName );
-		if ( entityBinding == null ) {
-			throw new MappingException( "Entity binding not known: " + entityName );
-		}
-		// TODO: should this call EntityBinding.getReferencedAttributeBindingString), which does not exist yet?
-		AttributeBinding attributeBinding = entityBinding.locateAttributeBinding( propertyName );
-		if ( attributeBinding == null ) {
-			throw new MappingException( "unknown property: " + entityName + '.' + propertyName );
-		}
-		return attributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping();
-	}
-
-	private class MappingDefaultsImpl implements MappingDefaults {
-
-		@Override
-		public String getPackageName() {
-			return null;
-		}
-
-		@Override
-		public String getSchemaName() {
-			return options.getDefaultSchemaName();
-		}
-
-		@Override
-		public String getCatalogName() {
-			return options.getDefaultCatalogName();
-		}
-
-		@Override
-		public String getIdColumnName() {
-			return DEFAULT_IDENTIFIER_COLUMN_NAME;
-		}
-
-		@Override
-		public String getDiscriminatorColumnName() {
-			return DEFAULT_DISCRIMINATOR_COLUMN_NAME;
-		}
-
-		@Override
-		public String getCascadeStyle() {
-			return DEFAULT_CASCADE;
-		}
-
-		@Override
-		public String getPropertyAccessorName() {
-			return DEFAULT_PROPERTY_ACCESS;
-		}
-
-		@Override
-		public boolean areAssociationsLazy() {
-			return true;
-		}
-
-		private final ValueHolder<AccessType> regionFactorySpecifiedDefaultAccessType = new ValueHolder<AccessType>(
-				new ValueHolder.DeferredInitializer<AccessType>() {
-					@Override
-					public AccessType initialize() {
-						final RegionFactory regionFactory = getServiceRegistry().getService( RegionFactory.class );
-						return regionFactory.getDefaultAccessType();
-					}
-				}
-		);
-
-		@Override
-		public AccessType getCacheAccessType() {
-			return options.getDefaultAccessType() != null
-					? options.getDefaultAccessType()
-					: regionFactorySpecifiedDefaultAccessType.getValue();
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java
deleted file mode 100644
index 170361272c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.metamodel.source.MappingDefaults;
-
-/**
- * Represents a "nested level" in the mapping defaults stack.
- *
- * @author Steve Ebersole
- */
-public class OverriddenMappingDefaults implements MappingDefaults {
-	private MappingDefaults overriddenValues;
-
-	private final String packageName;
-	private final String schemaName;
-	private final String catalogName;
-	private final String idColumnName;
-	private final String discriminatorColumnName;
-	private final String cascade;
-	private final String propertyAccess;
-	private final Boolean associationLaziness;
-
-	public OverriddenMappingDefaults(
-			MappingDefaults overriddenValues,
-			String packageName,
-			String schemaName,
-			String catalogName,
-			String idColumnName,
-			String discriminatorColumnName,
-			String cascade,
-			String propertyAccess,
-			Boolean associationLaziness) {
-		if ( overriddenValues == null ) {
-			throw new IllegalArgumentException( "Overridden values cannot be null" );
-		}
-		this.overriddenValues = overriddenValues;
-		this.packageName = packageName;
-		this.schemaName = schemaName;
-		this.catalogName = catalogName;
-		this.idColumnName = idColumnName;
-		this.discriminatorColumnName = discriminatorColumnName;
-		this.cascade = cascade;
-		this.propertyAccess = propertyAccess;
-		this.associationLaziness = associationLaziness;
-	}
-
-	@Override
-	public String getPackageName() {
-		return packageName == null ? overriddenValues.getPackageName() : packageName;
-	}
-
-	@Override
-	public String getSchemaName() {
-		return schemaName == null ? overriddenValues.getSchemaName() : schemaName;
-	}
-
-	@Override
-	public String getCatalogName() {
-		return catalogName == null ? overriddenValues.getCatalogName() : catalogName;
-	}
-
-	@Override
-	public String getIdColumnName() {
-		return idColumnName == null ? overriddenValues.getIdColumnName() : idColumnName;
-	}
-
-	@Override
-	public String getDiscriminatorColumnName() {
-		return discriminatorColumnName == null ? overriddenValues.getDiscriminatorColumnName() : discriminatorColumnName;
-	}
-
-	@Override
-	public String getCascadeStyle() {
-		return cascade == null ? overriddenValues.getCascadeStyle() : cascade;
-	}
-
-	@Override
-	public String getPropertyAccessorName() {
-		return propertyAccess == null ? overriddenValues.getPropertyAccessorName() : propertyAccess;
-	}
-
-	@Override
-	public boolean areAssociationsLazy() {
-		return associationLaziness == null ? overriddenValues.areAssociationsLazy() : associationLaziness;
-	}
-
-	@Override
-	public AccessType getCacheAccessType() {
-		return overriddenValues.getCacheAccessType();
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
deleted file mode 100644
index 85a700a8af..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import java.io.Serializable;
-
-import org.hibernate.EmptyInterceptor;
-import org.hibernate.Interceptor;
-import org.hibernate.ObjectNotFoundException;
-import org.hibernate.SessionFactory;
-import org.hibernate.boot.registry.StandardServiceRegistry;
-import org.hibernate.internal.SessionFactoryImpl;
-import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.proxy.EntityNotFoundDelegate;
-
-/**
- * @author Gail Badner
- */
-public class SessionFactoryBuilderImpl implements SessionFactoryBuilder {
-	SessionFactoryOptionsImpl options;
-
-	private final MetadataImplementor metadata;
-
-	/* package-protected */
-	SessionFactoryBuilderImpl(MetadataImplementor metadata) {
-		this.metadata = metadata;
-		options = new SessionFactoryOptionsImpl( metadata.getOptions().getServiceRegistry() );
-	}
-
-	@Override
-	public SessionFactoryBuilder with(Interceptor interceptor) {
-		this.options.interceptor = interceptor;
-		return this;
-	}
-
-	@Override
-	public SessionFactoryBuilder with(EntityNotFoundDelegate entityNotFoundDelegate) {
-		this.options.entityNotFoundDelegate = entityNotFoundDelegate;
-		return this;
-	}
-
-	@Override
-	public SessionFactory build() {
-		return new SessionFactoryImpl(metadata, options, null );
-	}
-
-	private static class SessionFactoryOptionsImpl implements SessionFactory.SessionFactoryOptions {
-		private final StandardServiceRegistry serviceRegistry;
-		private Interceptor interceptor = EmptyInterceptor.INSTANCE;
-		
-		public SessionFactoryOptionsImpl(StandardServiceRegistry serviceRegistry) {
-			this.serviceRegistry = serviceRegistry;
-		}
-
-		// TODO: should there be a DefaultEntityNotFoundDelegate.INSTANCE?
-		private EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
-				public void handleEntityNotFound(String entityName, Serializable id) {
-					throw new ObjectNotFoundException( id, entityName );
-				}
-		};
-
-		@Override
-		public StandardServiceRegistry getServiceRegistry() {
-			return serviceRegistry;
-		}
-
-		@Override
-		public Interceptor getInterceptor() {
-			return interceptor;
-		}
-
-		@Override
-		public EntityNotFoundDelegate getEntityNotFoundDelegate() {
-			return entityNotFoundDelegate;
-		}
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
index 212e5ac311..9a13029f9f 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
@@ -1,3351 +1,2941 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.cache.spi.entry.ReferenceCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StandardCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StructuredCacheEntry;
 import org.hibernate.cache.spi.entry.UnstructuredCacheEntry;
 import org.hibernate.dialect.lock.LockingStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.internal.CacheHelper;
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.engine.spi.CachedNaturalIdValueSource;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.PersistenceContext.NaturalIdHelper;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.id.PostInsertIdentityPersister;
 import org.hibernate.id.insert.Binder;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.FilterConfiguration;
 import org.hibernate.internal.FilterHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.jdbc.TooManyRowsAffectedException;
 import org.hibernate.loader.entity.BatchingEntityLoaderBuilder;
 import org.hibernate.loader.entity.CascadeEntityLoader;
 import org.hibernate.loader.entity.EntityLoader;
 import org.hibernate.loader.entity.UniqueEntityLoader;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.metadata.ClassMetadata;
-import org.hibernate.metamodel.binding.AssociationAttributeBinding;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.SimpleValueBinding;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
-import org.hibernate.metamodel.relational.DerivedValue;
-import org.hibernate.metamodel.relational.Value;
 import org.hibernate.persister.walking.internal.EntityIdentifierDefinitionHelper;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.property.BackrefPropertyAccessor;
 import org.hibernate.sql.Alias;
 import org.hibernate.sql.Delete;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.JoinType;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.sql.Template;
 import org.hibernate.sql.Update;
 import org.hibernate.tuple.GenerationTiming;
 import org.hibernate.tuple.InDatabaseValueGenerationStrategy;
 import org.hibernate.tuple.InMemoryValueGenerationStrategy;
 import org.hibernate.tuple.NonIdentifierAttribute;
 import org.hibernate.tuple.ValueGeneration;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 import org.hibernate.type.VersionType;
 
 import org.jboss.logging.Logger;
 
 /**
  * Basic functionality for persisting an entity via JDBC
  * through either generated or custom SQL
  *
  * @author Gavin King
  */
 public abstract class AbstractEntityPersister
 		implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
 		SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, AbstractEntityPersister.class.getName() );
 
 	public static final String ENTITY_CLASS = "class";
 
 	// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final SessionFactoryImplementor factory;
 	private final EntityRegionAccessStrategy cacheAccessStrategy;
 	private final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy;
 	private final boolean isLazyPropertiesCacheable;
 	private final CacheEntryHelper cacheEntryHelper;
 	private final EntityMetamodel entityMetamodel;
 	private final EntityTuplizer entityTuplizer;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final String[] rootTableKeyColumnNames;
 	private final String[] rootTableKeyColumnReaders;
 	private final String[] rootTableKeyColumnReaderTemplates;
 	private final String[] identifierAliases;
 	private final int identifierColumnSpan;
 	private final String versionColumnName;
 	private final boolean hasFormulaProperties;
 	private final int batchSize;
 	private final boolean hasSubselectLoadableCollections;
 	protected final String rowIdName;
 
 	private final Set lazyProperties;
 
 	// The optional SQL string defined in the where attribute
 	private final String sqlWhereString;
 	private final String sqlWhereStringTemplate;
 
 	//information about properties of this class,
 	//including inherited properties
 	//(only really needed for updatable/insertable properties)
 	private final int[] propertyColumnSpans;
 	private final String[] propertySubclassNames;
 	private final String[][] propertyColumnAliases;
 	private final String[][] propertyColumnNames;
 	private final String[][] propertyColumnFormulaTemplates;
 	private final String[][] propertyColumnReaderTemplates;
 	private final String[][] propertyColumnWriters;
 	private final boolean[][] propertyColumnUpdateable;
 	private final boolean[][] propertyColumnInsertable;
 	private final boolean[] propertyUniqueness;
 	private final boolean[] propertySelectable;
 	
 	private final List<Integer> lobProperties = new ArrayList<Integer>();
 
 	//information about lazy properties of this class
 	private final String[] lazyPropertyNames;
 	private final int[] lazyPropertyNumbers;
 	private final Type[] lazyPropertyTypes;
 	private final String[][] lazyPropertyColumnAliases;
 
 	//information about all properties in class hierarchy
 	private final String[] subclassPropertyNameClosure;
 	private final String[] subclassPropertySubclassNameClosure;
 	private final Type[] subclassPropertyTypeClosure;
 	private final String[][] subclassPropertyFormulaTemplateClosure;
 	private final String[][] subclassPropertyColumnNameClosure;
 	private final String[][] subclassPropertyColumnReaderClosure;
 	private final String[][] subclassPropertyColumnReaderTemplateClosure;
 	private final FetchMode[] subclassPropertyFetchModeClosure;
 	private final boolean[] subclassPropertyNullabilityClosure;
 	private final boolean[] propertyDefinedOnSubclass;
 	private final int[][] subclassPropertyColumnNumberClosure;
 	private final int[][] subclassPropertyFormulaNumberClosure;
 	private final CascadeStyle[] subclassPropertyCascadeStyleClosure;
 
 	//information about all columns/formulas in class hierarchy
 	private final String[] subclassColumnClosure;
 	private final boolean[] subclassColumnLazyClosure;
 	private final String[] subclassColumnAliasClosure;
 	private final boolean[] subclassColumnSelectableClosure;
 	private final String[] subclassColumnReaderTemplateClosure;
 	private final String[] subclassFormulaClosure;
 	private final String[] subclassFormulaTemplateClosure;
 	private final String[] subclassFormulaAliasClosure;
 	private final boolean[] subclassFormulaLazyClosure;
 
 	// dynamic filters attached to the class-level
 	private final FilterHelper filterHelper;
 
 	private final Set<String> affectingFetchProfileNames = new HashSet<String>();
 
 	private final Map uniqueKeyLoaders = new HashMap();
 	private final Map lockers = new HashMap();
 	private final Map loaders = new HashMap();
 
 	// SQL strings
 	private String sqlVersionSelectString;
 	private String sqlSnapshotSelectString;
 	private String sqlLazySelectString;
 
 	private String sqlIdentityInsertString;
 	private String sqlUpdateByRowIdString;
 	private String sqlLazyUpdateByRowIdString;
 
 	private String[] sqlDeleteStrings;
 	private String[] sqlInsertStrings;
 	private String[] sqlUpdateStrings;
 	private String[] sqlLazyUpdateStrings;
 
 	private String sqlInsertGeneratedValuesSelectString;
 	private String sqlUpdateGeneratedValuesSelectString;
 
 	//Custom SQL (would be better if these were private)
 	protected boolean[] insertCallable;
 	protected boolean[] updateCallable;
 	protected boolean[] deleteCallable;
 	protected String[] customSQLInsert;
 	protected String[] customSQLUpdate;
 	protected String[] customSQLDelete;
 	protected ExecuteUpdateResultCheckStyle[] insertResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] updateResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] deleteResultCheckStyles;
 
 	private InsertGeneratedIdentifierDelegate identityDelegate;
 
 	private boolean[] tableHasColumns;
 
 	private final String loaderName;
 
 	private UniqueEntityLoader queryLoader;
 
 	private final String temporaryIdTableName;
 	private final String temporaryIdTableDDL;
 
 	private final Map subclassPropertyAliases = new HashMap();
 	private final Map subclassPropertyColumnNames = new HashMap();
 
 	protected final BasicEntityPropertyMapping propertyMapping;
 
 	protected void addDiscriminatorToInsert(Insert insert) {}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {}
 
 	protected abstract int[] getSubclassColumnTableNumberClosure();
 
 	protected abstract int[] getSubclassFormulaTableNumberClosure();
 
 	public abstract String getSubclassTableName(int j);
 
 	protected abstract String[] getSubclassTableKeyColumns(int j);
 
 	protected abstract boolean isClassOrSuperclassTable(int j);
 
 	protected abstract int getSubclassTableSpan();
 
 	protected abstract int getTableSpan();
 
 	protected abstract boolean isTableCascadeDeleteEnabled(int j);
 
 	protected abstract String getTableName(int j);
 
 	protected abstract String[] getKeyColumns(int j);
 
 	protected abstract boolean isPropertyOfTable(int property, int j);
 
 	protected abstract int[] getPropertyTableNumbersInSelect();
 
 	protected abstract int[] getPropertyTableNumbers();
 
 	protected abstract int getSubclassPropertyTableNumber(int i);
 
 	protected abstract String filterFragment(String alias) throws MappingException;
 
 	protected abstract String filterFragment(String alias, Set<String> treatAsDeclarations);
 
 	private static final String DISCRIMINATOR_ALIAS = "clazz_";
 
 	public String getDiscriminatorColumnName() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaders() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaderTemplate() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorAlias() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorFormulaTemplate() {
 		return null;
 	}
 
 	protected boolean isInverseTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableSubclassTable(int j) {
 		return false;
 	}
 
 	protected boolean isInverseSubclassTable(int j) {
 		return false;
 	}
 
 	public boolean isSubclassEntityName(String entityName) {
 		return entityMetamodel.getSubclassEntityNames().contains(entityName);
 	}
 
 	private boolean[] getTableHasColumns() {
 		return tableHasColumns;
 	}
 
 	public String[] getRootTableKeyColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	protected String[] getSQLUpdateByRowIdStrings() {
 		if ( sqlUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan() + 1];
 		result[0] = sqlUpdateByRowIdString;
 		System.arraycopy( sqlUpdateStrings, 0, result, 1, getTableSpan() );
 		return result;
 	}
 
 	protected String[] getSQLLazyUpdateByRowIdStrings() {
 		if ( sqlLazyUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan()];
 		result[0] = sqlLazyUpdateByRowIdString;
 		for ( int i = 1; i < getTableSpan(); i++ ) {
 			result[i] = sqlLazyUpdateStrings[i];
 		}
 		return result;
 	}
 
 	protected String getSQLSnapshotSelectString() {
 		return sqlSnapshotSelectString;
 	}
 
 	protected String getSQLLazySelectString() {
 		return sqlLazySelectString;
 	}
 
 	protected String[] getSQLDeleteStrings() {
 		return sqlDeleteStrings;
 	}
 
 	protected String[] getSQLInsertStrings() {
 		return sqlInsertStrings;
 	}
 
 	protected String[] getSQLUpdateStrings() {
 		return sqlUpdateStrings;
 	}
 
 	protected String[] getSQLLazyUpdateStrings() {
 		return sqlLazyUpdateStrings;
 	}
 
 	/**
 	 * The query that inserts a row, letting the database generate an id
 	 *
 	 * @return The IDENTITY-based insertion query.
 	 */
 	protected String getSQLIdentityInsertString() {
 		return sqlIdentityInsertString;
 	}
 
 	protected String getVersionSelectString() {
 		return sqlVersionSelectString;
 	}
 
 	protected boolean isInsertCallable(int j) {
 		return insertCallable[j];
 	}
 
 	protected boolean isUpdateCallable(int j) {
 		return updateCallable[j];
 	}
 
 	protected boolean isDeleteCallable(int j) {
 		return deleteCallable[j];
 	}
 
 	protected boolean isSubclassPropertyDeferred(String propertyName, String entityName) {
 		return false;
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return false;
 	}
 
 	public boolean hasSequentialSelect() {
 		return false;
 	}
 
 	/**
 	 * Decide which tables need to be updated.
 	 * <p/>
 	 * The return here is an array of boolean values with each index corresponding
 	 * to a given table in the scope of this persister.
 	 *
 	 * @param dirtyProperties The indices of all the entity properties considered dirty.
 	 * @param hasDirtyCollection Whether any collections owned by the entity which were considered dirty.
 	 *
 	 * @return Array of booleans indicating which table require updating.
 	 */
 	protected boolean[] getTableUpdateNeeded(final int[] dirtyProperties, boolean hasDirtyCollection) {
 
 		if ( dirtyProperties == null ) {
 			return getTableHasColumns(); // for objects that came in via update()
 		}
 		else {
 			boolean[] updateability = getPropertyUpdateability();
 			int[] propertyTableNumbers = getPropertyTableNumbers();
 			boolean[] tableUpdateNeeded = new boolean[ getTableSpan() ];
 			for ( int i = 0; i < dirtyProperties.length; i++ ) {
 				int property = dirtyProperties[i];
 				int table = propertyTableNumbers[property];
 				tableUpdateNeeded[table] = tableUpdateNeeded[table] ||
 						( getPropertyColumnSpan(property) > 0 && updateability[property] );
 			}
 			if ( isVersioned() ) {
 				tableUpdateNeeded[0] = tableUpdateNeeded[0] ||
 					Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 			}
 			return tableUpdateNeeded;
 		}
 	}
 
 	public boolean hasRowId() {
 		return rowIdName != null;
 	}
 
 	protected boolean[][] getPropertyColumnUpdateable() {
 		return propertyColumnUpdateable;
 	}
 
 	protected boolean[][] getPropertyColumnInsertable() {
 		return propertyColumnInsertable;
 	}
 
 	protected boolean[] getPropertySelectable() {
 		return propertySelectable;
 	}
 
 	public AbstractEntityPersister(
 			final PersistentClass persistentClass,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory) throws HibernateException {
 
 		// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		this.factory = factory;
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		this.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;
 		isLazyPropertiesCacheable = persistentClass.isLazyPropertiesCacheable();
 
 		this.entityMetamodel = new EntityMetamodel( persistentClass, this, factory );
 		this.entityTuplizer = this.entityMetamodel.getTuplizer();
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		int batch = persistentClass.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSettings().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 		hasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();
 
 		propertyMapping = new BasicEntityPropertyMapping( this );
 
 		// IDENTIFIER
 
 		identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
 		rootTableKeyColumnNames = new String[identifierColumnSpan];
 		rootTableKeyColumnReaders = new String[identifierColumnSpan];
 		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
 		identifierAliases = new String[identifierColumnSpan];
 
 		rowIdName = persistentClass.getRootTable().getRowId();
 
 		loaderName = persistentClass.getLoaderName();
 
 		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Column col = ( Column ) iter.next();
 			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
 			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
 			rootTableKeyColumnReaderTemplates[i] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 			i++;
 		}
 
 		// VERSION
 
 		if ( persistentClass.isVersioned() ) {
 			versionColumnName = ( ( Column ) persistentClass.getVersion().getColumnIterator().next() ).getQuotedName( factory.getDialect() );
 		}
 		else {
 			versionColumnName = null;
 		}
 
 		//WHERE STRING
 
 		sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
 		sqlWhereStringTemplate = sqlWhereString == null ?
 				null :
 				Template.renderWhereStringTemplate( sqlWhereString, factory.getDialect(), factory.getSqlFunctionRegistry() );
 
 		// PROPERTIES
 
 		final boolean lazyAvailable = isInstrumented();
 
 		int hydrateSpan = entityMetamodel.getPropertySpan();
 		propertyColumnSpans = new int[hydrateSpan];
 		propertySubclassNames = new String[hydrateSpan];
 		propertyColumnAliases = new String[hydrateSpan][];
 		propertyColumnNames = new String[hydrateSpan][];
 		propertyColumnFormulaTemplates = new String[hydrateSpan][];
 		propertyColumnReaderTemplates = new String[hydrateSpan][];
 		propertyColumnWriters = new String[hydrateSpan][];
 		propertyUniqueness = new boolean[hydrateSpan];
 		propertySelectable = new boolean[hydrateSpan];
 		propertyColumnUpdateable = new boolean[hydrateSpan][];
 		propertyColumnInsertable = new boolean[hydrateSpan][];
 		HashSet thisClassProperties = new HashSet();
 
 		lazyProperties = new HashSet();
 		ArrayList lazyNames = new ArrayList();
 		ArrayList lazyNumbers = new ArrayList();
 		ArrayList lazyTypes = new ArrayList();
 		ArrayList lazyColAliases = new ArrayList();
 
 		iter = persistentClass.getPropertyClosureIterator();
 		i = 0;
 		boolean foundFormula = false;
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			thisClassProperties.add( prop );
 
 			int span = prop.getColumnSpan();
 			propertyColumnSpans[i] = span;
 			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
 			String[] colNames = new String[span];
 			String[] colAliases = new String[span];
 			String[] colReaderTemplates = new String[span];
 			String[] colWriters = new String[span];
 			String[] formulaTemplates = new String[span];
 			Iterator colIter = prop.getColumnIterator();
 			int k = 0;
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
 				if ( thing.isFormula() ) {
 					foundFormula = true;
 					formulaTemplates[k] = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				}
 				else {
 					Column col = (Column)thing;
 					colNames[k] = col.getQuotedName( factory.getDialect() );
 					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					colWriters[k] = col.getWriteExpr();
 				}
 				k++;
 			}
 			propertyColumnNames[i] = colNames;
 			propertyColumnFormulaTemplates[i] = formulaTemplates;
 			propertyColumnReaderTemplates[i] = colReaderTemplates;
 			propertyColumnWriters[i] = colWriters;
 			propertyColumnAliases[i] = colAliases;
 
 			if ( lazyAvailable && prop.isLazy() ) {
 				lazyProperties.add( prop.getName() );
 				lazyNames.add( prop.getName() );
 				lazyNumbers.add( i );
 				lazyTypes.add( prop.getValue().getType() );
 				lazyColAliases.add( colAliases );
 			}
 
 			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
 			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
 
 			propertySelectable[i] = prop.isSelectable();
 
 			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
 			
 			if (prop.isLob() && getFactory().getDialect().forceLobAsLastValue() ) {
 				lobProperties.add( i );
 			}
 
 			i++;
 
 		}
 		hasFormulaProperties = foundFormula;
 		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
 		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
 		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
 		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
 
 		// SUBCLASS PROPERTY CLOSURE
 
 		ArrayList columns = new ArrayList();
 		ArrayList columnsLazy = new ArrayList();
 		ArrayList columnReaderTemplates = new ArrayList();
 		ArrayList aliases = new ArrayList();
 		ArrayList formulas = new ArrayList();
 		ArrayList formulaAliases = new ArrayList();
 		ArrayList formulaTemplates = new ArrayList();
 		ArrayList formulasLazy = new ArrayList();
 		ArrayList types = new ArrayList();
 		ArrayList names = new ArrayList();
 		ArrayList classes = new ArrayList();
 		ArrayList templates = new ArrayList();
 		ArrayList propColumns = new ArrayList();
 		ArrayList propColumnReaders = new ArrayList();
 		ArrayList propColumnReaderTemplates = new ArrayList();
 		ArrayList joinedFetchesList = new ArrayList();
 		ArrayList cascades = new ArrayList();
 		ArrayList definedBySubclass = new ArrayList();
 		ArrayList propColumnNumbers = new ArrayList();
 		ArrayList propFormulaNumbers = new ArrayList();
 		ArrayList columnSelectables = new ArrayList();
 		ArrayList propNullables = new ArrayList();
 
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			names.add( prop.getName() );
 			classes.add( prop.getPersistentClass().getEntityName() );
 			boolean isDefinedBySubclass = !thisClassProperties.contains( prop );
 			definedBySubclass.add( Boolean.valueOf( isDefinedBySubclass ) );
 			propNullables.add( Boolean.valueOf( prop.isOptional() || isDefinedBySubclass ) ); //TODO: is this completely correct?
 			types.add( prop.getType() );
 
 			Iterator colIter = prop.getColumnIterator();
 			String[] cols = new String[prop.getColumnSpan()];
 			String[] readers = new String[prop.getColumnSpan()];
 			String[] readerTemplates = new String[prop.getColumnSpan()];
 			String[] forms = new String[prop.getColumnSpan()];
 			int[] colnos = new int[prop.getColumnSpan()];
 			int[] formnos = new int[prop.getColumnSpan()];
 			int l = 0;
 			Boolean lazy = Boolean.valueOf( prop.isLazy() && lazyAvailable );
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				if ( thing.isFormula() ) {
 					String template = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					formnos[l] = formulaTemplates.size();
 					colnos[l] = -1;
 					formulaTemplates.add( template );
 					forms[l] = template;
 					formulas.add( thing.getText( factory.getDialect() ) );
 					formulaAliases.add( thing.getAlias( factory.getDialect() ) );
 					formulasLazy.add( lazy );
 				}
 				else {
 					Column col = (Column)thing;
 					String colName = col.getQuotedName( factory.getDialect() );
 					colnos[l] = columns.size(); //before add :-)
 					formnos[l] = -1;
 					columns.add( colName );
 					cols[l] = colName;
 					aliases.add( thing.getAlias( factory.getDialect(), prop.getValue().getTable() ) );
 					columnsLazy.add( lazy );
 					columnSelectables.add( Boolean.valueOf( prop.isSelectable() ) );
 
 					readers[l] = col.getReadExpr( factory.getDialect() );
 					String readerTemplate = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					readerTemplates[l] = readerTemplate;
 					columnReaderTemplates.add( readerTemplate );
 				}
 				l++;
 			}
 			propColumns.add( cols );
 			propColumnReaders.add( readers );
 			propColumnReaderTemplates.add( readerTemplates );
 			templates.add( forms );
 			propColumnNumbers.add( colnos );
 			propFormulaNumbers.add( formnos );
 
 			joinedFetchesList.add( prop.getValue().getFetchMode() );
 			cascades.add( prop.getCascadeStyle() );
 		}
 		subclassColumnClosure = ArrayHelper.toStringArray( columns );
 		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
 		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
 		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
 		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
 
 		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
 		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
 		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
 		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
 
 		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
 		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
 		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
 		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
 		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
 		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
 		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
 		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
 		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
 		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
 
 		subclassPropertyCascadeStyleClosure = new CascadeStyle[cascades.size()];
 		iter = cascades.iterator();
 		int j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyCascadeStyleClosure[j++] = ( CascadeStyle ) iter.next();
 		}
 		subclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];
 		iter = joinedFetchesList.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyFetchModeClosure[j++] = ( FetchMode ) iter.next();
 		}
 
 		propertyDefinedOnSubclass = new boolean[definedBySubclass.size()];
 		iter = definedBySubclass.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			propertyDefinedOnSubclass[j++] = (Boolean) iter.next();
 		}
 
 		// Handle any filters applied to the class level
 		filterHelper = new FilterHelper( persistentClass.getFilters(), factory );
 
 		temporaryIdTableName = persistentClass.getTemporaryIdTableName();
 		temporaryIdTableDDL = persistentClass.getTemporaryIdTableDDL();
 
 		this.cacheEntryHelper = buildCacheEntryHelper();
 	}
 
 	protected CacheEntryHelper buildCacheEntryHelper() {
 		if ( cacheAccessStrategy == null ) {
 			// the entity defined no caching...
 			return NoopCacheEntryHelper.INSTANCE;
 		}
 
 		if ( canUseReferenceCacheEntries() ) {
 			entityMetamodel.setLazy( false );
 			// todo : do we also need to unset proxy factory?
 			return new ReferenceCacheEntryHelper( this );
 		}
 
 		return factory.getSettings().isStructuredCacheEntriesEnabled()
 				? new StructuredCacheEntryHelper( this )
 				: new StandardCacheEntryHelper( this );
 	}
 
 	public boolean canUseReferenceCacheEntries() {
 		// todo : should really validate that the cache access type is read-only
 
 		if ( ! factory.getSettings().isDirectReferenceCacheEntriesEnabled() ) {
 			return false;
 		}
 
 		// for now, limit this to just entities that:
 		// 		1) are immutable
 		if ( entityMetamodel.isMutable() ) {
 			return false;
 		}
 
 		//		2)  have no associations.  Eventually we want to be a little more lenient with associations.
 		for ( Type type : getSubclassPropertyTypeClosure() ) {
 			if ( type.isAssociationType() ) {
 				return false;
 			}
 		}
 
 		return true;
 	}
 
-
-	public AbstractEntityPersister(
-			final EntityBinding entityBinding,
-			final EntityRegionAccessStrategy cacheAccessStrategy,
-			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
-			final SessionFactoryImplementor factory) throws HibernateException {
-		this.factory = factory;
-		this.cacheAccessStrategy = cacheAccessStrategy;
-		this.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;
-		this.isLazyPropertiesCacheable =
-				entityBinding.getHierarchyDetails().getCaching() == null ?
-						false :
-						entityBinding.getHierarchyDetails().getCaching().isCacheLazyProperties();
-		this.entityMetamodel = new EntityMetamodel( entityBinding, this, factory );
-		this.entityTuplizer = this.entityMetamodel.getTuplizer();
-		int batch = entityBinding.getBatchSize();
-		if ( batch == -1 ) {
-			batch = factory.getSettings().getDefaultBatchFetchSize();
-		}
-		batchSize = batch;
-		hasSubselectLoadableCollections = entityBinding.hasSubselectLoadableCollections();
-
-		propertyMapping = new BasicEntityPropertyMapping( this );
-
-		// IDENTIFIER
-
-		identifierColumnSpan = entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding().getSimpleValueSpan();
-		rootTableKeyColumnNames = new String[identifierColumnSpan];
-		rootTableKeyColumnReaders = new String[identifierColumnSpan];
-		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
-		identifierAliases = new String[identifierColumnSpan];
-
-		rowIdName = entityBinding.getRowId();
-
-		loaderName = entityBinding.getCustomLoaderName();
-
-		int i = 0;
-		for ( org.hibernate.metamodel.relational.Column col : entityBinding.getPrimaryTable().getPrimaryKey().getColumns() ) {
-			rootTableKeyColumnNames[i] = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-			if ( col.getReadFragment() == null ) {
-				rootTableKeyColumnReaders[i] = rootTableKeyColumnNames[i];
-				rootTableKeyColumnReaderTemplates[i] = getTemplateFromColumn( col, factory );
-			}
-			else {
-				rootTableKeyColumnReaders[i] = col.getReadFragment();
-				rootTableKeyColumnReaderTemplates[i] = getTemplateFromString( rootTableKeyColumnReaders[i], factory );
-			}
-			identifierAliases[i] = col.getAlias( factory.getDialect() );
-			i++;
-		}
-
-		// VERSION
-
-		if ( entityBinding.isVersioned() ) {
-			final Value versioningValue = entityBinding.getHierarchyDetails().getVersioningAttributeBinding().getValue();
-			if ( ! org.hibernate.metamodel.relational.Column.class.isInstance( versioningValue ) ) {
-				throw new AssertionFailure( "Bad versioning attribute binding : " + versioningValue );
-			}
-			org.hibernate.metamodel.relational.Column versionColumn = org.hibernate.metamodel.relational.Column.class.cast( versioningValue );
-			versionColumnName = versionColumn.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-		}
-		else {
-			versionColumnName = null;
-		}
-
-		//WHERE STRING
-
-		sqlWhereString = StringHelper.isNotEmpty( entityBinding.getWhereFilter() ) ? "( " + entityBinding.getWhereFilter() + ") " : null;
-		sqlWhereStringTemplate = getTemplateFromString( sqlWhereString, factory );
-
-		// PROPERTIES
-
-		final boolean lazyAvailable = isInstrumented();
-
-		int hydrateSpan = entityMetamodel.getPropertySpan();
-		propertyColumnSpans = new int[hydrateSpan];
-		propertySubclassNames = new String[hydrateSpan];
-		propertyColumnAliases = new String[hydrateSpan][];
-		propertyColumnNames = new String[hydrateSpan][];
-		propertyColumnFormulaTemplates = new String[hydrateSpan][];
-		propertyColumnReaderTemplates = new String[hydrateSpan][];
-		propertyColumnWriters = new String[hydrateSpan][];
-		propertyUniqueness = new boolean[hydrateSpan];
-		propertySelectable = new boolean[hydrateSpan];
-		propertyColumnUpdateable = new boolean[hydrateSpan][];
-		propertyColumnInsertable = new boolean[hydrateSpan][];
-		HashSet thisClassProperties = new HashSet();
-
-		lazyProperties = new HashSet();
-		ArrayList lazyNames = new ArrayList();
-		ArrayList lazyNumbers = new ArrayList();
-		ArrayList lazyTypes = new ArrayList();
-		ArrayList lazyColAliases = new ArrayList();
-
-		i = 0;
-		boolean foundFormula = false;
-		for ( AttributeBinding attributeBinding : entityBinding.getAttributeBindingClosure() ) {
-			if ( attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
-				// entity identifier is not considered a "normal" property
-				continue;
-			}
-
-			if ( ! attributeBinding.getAttribute().isSingular() ) {
-				// collections handled separately
-				continue;
-			}
-
-			final SingularAttributeBinding singularAttributeBinding = (SingularAttributeBinding) attributeBinding;
-
-			thisClassProperties.add( singularAttributeBinding );
-
-			propertySubclassNames[i] = ( (EntityBinding) singularAttributeBinding.getContainer() ).getEntity().getName();
-
-			int span = singularAttributeBinding.getSimpleValueSpan();
-			propertyColumnSpans[i] = span;
-
-			String[] colNames = new String[span];
-			String[] colAliases = new String[span];
-			String[] colReaderTemplates = new String[span];
-			String[] colWriters = new String[span];
-			String[] formulaTemplates = new String[span];
-			boolean[] propertyColumnInsertability = new boolean[span];
-			boolean[] propertyColumnUpdatability = new boolean[span];
-
-			int k = 0;
-
-			for ( SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings() ) {
-				colAliases[k] = valueBinding.getSimpleValue().getAlias( factory.getDialect() );
-				if ( valueBinding.isDerived() ) {
-					foundFormula = true;
-					formulaTemplates[ k ] = getTemplateFromString( ( (DerivedValue) valueBinding.getSimpleValue() ).getExpression(), factory );
-				}
-				else {
-					org.hibernate.metamodel.relational.Column col = ( org.hibernate.metamodel.relational.Column ) valueBinding.getSimpleValue();
-					colNames[k] = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-					colReaderTemplates[k] = getTemplateFromColumn( col, factory );
-					colWriters[k] = col.getWriteFragment() == null ? "?" : col.getWriteFragment();
-				}
-				propertyColumnInsertability[k] = valueBinding.isIncludeInInsert();
-				propertyColumnUpdatability[k] = valueBinding.isIncludeInUpdate();
-				k++;
-			}
-			propertyColumnNames[i] = colNames;
-			propertyColumnFormulaTemplates[i] = formulaTemplates;
-			propertyColumnReaderTemplates[i] = colReaderTemplates;
-			propertyColumnWriters[i] = colWriters;
-			propertyColumnAliases[i] = colAliases;
-
-			propertyColumnUpdateable[i] = propertyColumnUpdatability;
-			propertyColumnInsertable[i] = propertyColumnInsertability;
-
-			if ( lazyAvailable && singularAttributeBinding.isLazy() ) {
-				lazyProperties.add( singularAttributeBinding.getAttribute().getName() );
-				lazyNames.add( singularAttributeBinding.getAttribute().getName() );
-				lazyNumbers.add( i );
-				lazyTypes.add( singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping());
-				lazyColAliases.add( colAliases );
-			}
-
-
-			// TODO: fix this when backrefs are working
-			//propertySelectable[i] = singularAttributeBinding.isBackRef();
-			propertySelectable[i] = true;
-
-			propertyUniqueness[i] = singularAttributeBinding.isAlternateUniqueKey();
-			
-			// TODO: Does this need AttributeBindings wired into lobProperties?  Currently in Property only.
-
-			i++;
-
-		}
-		hasFormulaProperties = foundFormula;
-		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
-		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
-		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
-		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
-
-		// SUBCLASS PROPERTY CLOSURE
-
-		List<String> columns = new ArrayList<String>();
-		List<Boolean> columnsLazy = new ArrayList<Boolean>();
-		List<String> columnReaderTemplates = new ArrayList<String>();
-		List<String> aliases = new ArrayList<String>();
-		List<String> formulas = new ArrayList<String>();
-		List<String> formulaAliases = new ArrayList<String>();
-		List<String> formulaTemplates = new ArrayList<String>();
-		List<Boolean> formulasLazy = new ArrayList<Boolean>();
-		List<Type> types = new ArrayList<Type>();
-		List<String> names = new ArrayList<String>();
-		List<String> classes = new ArrayList<String>();
-		List<String[]> templates = new ArrayList<String[]>();
-		List<String[]> propColumns = new ArrayList<String[]>();
-		List<String[]> propColumnReaders = new ArrayList<String[]>();
-		List<String[]> propColumnReaderTemplates = new ArrayList<String[]>();
-		List<FetchMode> joinedFetchesList = new ArrayList<FetchMode>();
-		List<CascadeStyle> cascades = new ArrayList<CascadeStyle>();
-		List<Boolean> definedBySubclass = new ArrayList<Boolean>();
-		List<int[]> propColumnNumbers = new ArrayList<int[]>();
-		List<int[]> propFormulaNumbers = new ArrayList<int[]>();
-		List<Boolean> columnSelectables = new ArrayList<Boolean>();
-		List<Boolean> propNullables = new ArrayList<Boolean>();
-
-		for ( AttributeBinding attributeBinding : entityBinding.getSubEntityAttributeBindingClosure() ) {
-			if ( attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
-				// entity identifier is not considered a "normal" property
-				continue;
-			}
-
-			if ( ! attributeBinding.getAttribute().isSingular() ) {
-				// collections handled separately
-				continue;
-			}
-
-			final SingularAttributeBinding singularAttributeBinding = (SingularAttributeBinding) attributeBinding;
-
-			names.add( singularAttributeBinding.getAttribute().getName() );
-			classes.add( ( (EntityBinding) singularAttributeBinding.getContainer() ).getEntity().getName() );
-			boolean isDefinedBySubclass = ! thisClassProperties.contains( singularAttributeBinding );
-			definedBySubclass.add( isDefinedBySubclass );
-			propNullables.add( singularAttributeBinding.isNullable() || isDefinedBySubclass ); //TODO: is this completely correct?
-			types.add( singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
-
-			final int span = singularAttributeBinding.getSimpleValueSpan();
-			String[] cols = new String[ span ];
-			String[] readers = new String[ span ];
-			String[] readerTemplates = new String[ span ];
-			String[] forms = new String[ span ];
-			int[] colnos = new int[ span ];
-			int[] formnos = new int[ span ];
-			int l = 0;
-			Boolean lazy = singularAttributeBinding.isLazy() && lazyAvailable;
-			for ( SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings() ) {
-				if ( valueBinding.isDerived() ) {
-					DerivedValue derivedValue = DerivedValue.class.cast( valueBinding.getSimpleValue() );
-					String template = getTemplateFromString( derivedValue.getExpression(), factory );
-					formnos[l] = formulaTemplates.size();
-					colnos[l] = -1;
-					formulaTemplates.add( template );
-					forms[l] = template;
-					formulas.add( derivedValue.getExpression() );
-					formulaAliases.add( derivedValue.getAlias( factory.getDialect() ) );
-					formulasLazy.add( lazy );
-				}
-				else {
-					org.hibernate.metamodel.relational.Column col = org.hibernate.metamodel.relational.Column.class.cast( valueBinding.getSimpleValue() );
-					String colName = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-					colnos[l] = columns.size(); //before add :-)
-					formnos[l] = -1;
-					columns.add( colName );
-					cols[l] = colName;
-					aliases.add( col.getAlias( factory.getDialect() ) );
-					columnsLazy.add( lazy );
-					// TODO: properties only selectable if they are non-plural???
-					columnSelectables.add( singularAttributeBinding.getAttribute().isSingular() );
-
-					readers[l] =
-							col.getReadFragment() == null ?
-									col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() ) :
-									col.getReadFragment();
-					String readerTemplate = getTemplateFromColumn( col, factory );
-					readerTemplates[l] = readerTemplate;
-					columnReaderTemplates.add( readerTemplate );
-				}
-				l++;
-			}
-			propColumns.add( cols );
-			propColumnReaders.add( readers );
-			propColumnReaderTemplates.add( readerTemplates );
-			templates.add( forms );
-			propColumnNumbers.add( colnos );
-			propFormulaNumbers.add( formnos );
-
-			if ( singularAttributeBinding.isAssociation() ) {
-				AssociationAttributeBinding associationAttributeBinding =
-						( AssociationAttributeBinding ) singularAttributeBinding;
-				cascades.add( associationAttributeBinding.getCascadeStyle() );
-				joinedFetchesList.add( associationAttributeBinding.getFetchMode() );
-			}
-			else {
-				cascades.add( CascadeStyles.NONE );
-				joinedFetchesList.add( FetchMode.SELECT );
-			}
-		}
-
-		subclassColumnClosure = ArrayHelper.toStringArray( columns );
-		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
-		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
-		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
-		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
-
-		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
-		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
-		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
-		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
-
-		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
-		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
-		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
-		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
-		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
-		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
-		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
-		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
-		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
-		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
-
-		subclassPropertyCascadeStyleClosure = cascades.toArray( new CascadeStyle[ cascades.size() ] );
-		subclassPropertyFetchModeClosure = joinedFetchesList.toArray( new FetchMode[ joinedFetchesList.size() ] );
-
-		propertyDefinedOnSubclass = ArrayHelper.toBooleanArray( definedBySubclass );
-
-		List<FilterConfiguration> filterDefaultConditions = new ArrayList<FilterConfiguration>();
-		for ( FilterDefinition filterDefinition : entityBinding.getFilterDefinitions() ) {
-			filterDefaultConditions.add(new FilterConfiguration(filterDefinition.getFilterName(), 
-						filterDefinition.getDefaultFilterCondition(), true, null, null, null));
-		}
-		filterHelper = new FilterHelper( filterDefaultConditions, factory);
-
-		temporaryIdTableName = null;
-		temporaryIdTableDDL = null;
-
-		this.cacheEntryHelper = buildCacheEntryHelper();
-	}
-
 	protected static String getTemplateFromString(String string, SessionFactoryImplementor factory) {
 		return string == null ?
 				null :
 				Template.renderWhereStringTemplate( string, factory.getDialect(), factory.getSqlFunctionRegistry() );
 	}
 
-	public String getTemplateFromColumn(org.hibernate.metamodel.relational.Column column, SessionFactoryImplementor factory) {
-		String templateString;
-		if ( column.getReadFragment() != null ) {
-			templateString = getTemplateFromString( column.getReadFragment(), factory );
-		}
-		else {
-			String columnName = column.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-			templateString = Template.TEMPLATE + '.' + columnName;
-		}
-		return templateString;
-	}
-
 	protected String generateLazySelectString() {
 
 		if ( !entityMetamodel.hasLazyProperties() ) {
 			return null;
 		}
 
 		HashSet tableNumbers = new HashSet();
 		ArrayList columnNumbers = new ArrayList();
 		ArrayList formulaNumbers = new ArrayList();
 		for ( int i = 0; i < lazyPropertyNames.length; i++ ) {
 			// all this only really needs to consider properties
 			// of this class, not its subclasses, but since we
 			// are reusing code used for sequential selects, we
 			// use the subclass closure
 			int propertyNumber = getSubclassPropertyIndex( lazyPropertyNames[i] );
 
 			int tableNumber = getSubclassPropertyTableNumber( propertyNumber );
 			tableNumbers.add(  tableNumber );
 
 			int[] colNumbers = subclassPropertyColumnNumberClosure[propertyNumber];
 			for ( int j = 0; j < colNumbers.length; j++ ) {
 				if ( colNumbers[j]!=-1 ) {
 					columnNumbers.add( colNumbers[j] );
 				}
 			}
 			int[] formNumbers = subclassPropertyFormulaNumberClosure[propertyNumber];
 			for ( int j = 0; j < formNumbers.length; j++ ) {
 				if ( formNumbers[j]!=-1 ) {
 					formulaNumbers.add( formNumbers[j] );
 				}
 			}
 		}
 
 		if ( columnNumbers.size()==0 && formulaNumbers.size()==0 ) {
 			// only one-to-one is lazy fetched
 			return null;
 		}
 
 		return renderSelect( ArrayHelper.toIntArray( tableNumbers ),
 				ArrayHelper.toIntArray( columnNumbers ),
 				ArrayHelper.toIntArray( formulaNumbers ) );
 
 	}
 
 	public Object initializeLazyProperty(String fieldName, Object entity, SessionImplementor session)
 			throws HibernateException {
 
 		final Serializable id = session.getContextEntityIdentifier( entity );
 
 		final EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			throw new HibernateException( "entity is not associated with the session: " + id );
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Initializing lazy properties of: {0}, field access: {1}", MessageHelper.infoString( this, id, getFactory() ), fieldName );
 		}
 
 		if ( session.getCacheMode().isGetEnabled() && hasCache() ) {
 			final CacheKey cacheKey = session.generateCacheKey( id, getIdentifierType(), getEntityName() );
 			final Object ce = CacheHelper.fromSharedCache( session, cacheKey, getCacheAccessStrategy() );
 			if ( ce != null ) {
 				final CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure(ce, factory);
 				if ( !cacheEntry.areLazyPropertiesUnfetched() ) {
 					//note early exit here:
 					return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
 				}
 			}
 		}
 
 		return initializeLazyPropertiesFromDatastore( fieldName, entity, session, id, entry );
 
 	}
 
 	private Object initializeLazyPropertiesFromDatastore(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Serializable id,
 			final EntityEntry entry) {
 
 		if ( !hasLazyProperties() ) throw new AssertionFailure( "no lazy properties" );
 
 		LOG.trace( "Initializing lazy properties from datastore" );
 
 		try {
 
 			Object result = null;
 			PreparedStatement ps = null;
 			try {
 				final String lazySelect = getSQLLazySelectString();
 				ResultSet rs = null;
 				try {
 					if ( lazySelect != null ) {
 						// null sql means that the only lazy properties
 						// are shared PK one-to-one associations which are
 						// handled differently in the Type#nullSafeGet code...
 						ps = session.getTransactionCoordinator()
 								.getJdbcCoordinator()
 								.getStatementPreparer()
 								.prepareStatement( lazySelect );
 						getIdentifierType().nullSafeSet( ps, id, 1, session );
 						rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 						rs.next();
 					}
 					final Object[] snapshot = entry.getLoadedState();
 					for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 						Object propValue = lazyPropertyTypes[j].nullSafeGet( rs, lazyPropertyColumnAliases[j], session, entity );
 						if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 							result = propValue;
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 					}
 				}
 			}
 			finally {
 				if ( ps != null ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 				}
 			}
 
 			LOG.trace( "Done initializing lazy properties" );
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize lazy properties: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					getSQLLazySelectString()
 				);
 		}
 	}
 
 	private Object initializeLazyPropertiesFromCache(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final EntityEntry entry,
 			final CacheEntry cacheEntry
 	) {
 
 		LOG.trace( "Initializing lazy properties from second-level cache" );
 
 		Object result = null;
 		Serializable[] disassembledValues = cacheEntry.getDisassembledState();
 		final Object[] snapshot = entry.getLoadedState();
 		for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 			final Object propValue = lazyPropertyTypes[j].assemble(
 					disassembledValues[ lazyPropertyNumbers[j] ],
 					session,
 					entity
 				);
 			if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 				result = propValue;
 			}
 		}
 
 		LOG.trace( "Done initializing lazy properties" );
 
 		return result;
 	}
 
 	private boolean initializeLazyProperty(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Object[] snapshot,
 			final int j,
 			final Object propValue) {
 		setPropertyValue( entity, lazyPropertyNumbers[j], propValue );
 		if ( snapshot != null ) {
 			// object have been loaded with setReadOnly(true); HHH-2236
 			snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
 		}
 		return fieldName.equals( lazyPropertyNames[j] );
 	}
 
 	public boolean isBatchable() {
 		return optimisticLockStyle() == OptimisticLockStyle.NONE
 				|| ( !isVersioned() && optimisticLockStyle() == OptimisticLockStyle.VERSION )
 				|| getFactory().getSettings().isJdbcBatchVersionedData();
 	}
 
 	public Serializable[] getQuerySpaces() {
 		return getPropertySpaces();
 	}
 
 	protected Set getLazyProperties() {
 		return lazyProperties;
 	}
 
 	public boolean isBatchLoadable() {
 		return batchSize > 1;
 	}
 
 	public String[] getIdentifierColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	public String[] getIdentifierColumnReaders() {
 		return rootTableKeyColumnReaders;
 	}
 
 	public String[] getIdentifierColumnReaderTemplates() {
 		return rootTableKeyColumnReaderTemplates;
 	}
 
 	protected int getIdentifierColumnSpan() {
 		return identifierColumnSpan;
 	}
 
 	protected String[] getIdentifierAliases() {
 		return identifierAliases;
 	}
 
 	public String getVersionColumnName() {
 		return versionColumnName;
 	}
 
 	protected String getVersionedTableName() {
 		return getTableName( 0 );
 	}
 
 	protected boolean[] getSubclassColumnLazyiness() {
 		return subclassColumnLazyClosure;
 	}
 
 	protected boolean[] getSubclassFormulaLazyiness() {
 		return subclassFormulaLazyClosure;
 	}
 
 	/**
 	 * We can't immediately add to the cache if we have formulas
 	 * which must be evaluated, or if we have the possibility of
 	 * two concurrent updates to the same item being merged on
 	 * the database. This can happen if (a) the item is not
 	 * versioned and either (b) we have dynamic update enabled
 	 * or (c) we have multiple tables holding the state of the
 	 * item.
 	 */
 	public boolean isCacheInvalidationRequired() {
 		return hasFormulaProperties() ||
 				( !isVersioned() && ( entityMetamodel.isDynamicUpdate() || getTableSpan() > 1 ) );
 	}
 
 	public boolean isLazyPropertiesCacheable() {
 		return isLazyPropertiesCacheable;
 	}
 
 	public String selectFragment(String alias, String suffix) {
 		return identifierSelectFragment( alias, suffix ) +
 				propertySelectFragment( alias, suffix, false );
 	}
 
 	public String[] getIdentifierAliases(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );
 	}
 
 	public String[] getPropertyAliases(String suffix, int i) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		return new Alias( suffix ).toUnquotedAliasStrings( propertyColumnAliases[i] );
 	}
 
 	public String getDiscriminatorAlias(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return entityMetamodel.hasSubclasses() ?
 				new Alias( suffix ).toAliasString( getDiscriminatorAlias() ) :
 				null;
 	}
 
 	public String identifierSelectFragment(String name, String suffix) {
 		return new SelectFragment()
 				.setSuffix( suffix )
 				.addColumns( name, getIdentifierColumnNames(), getIdentifierAliases() )
 				.toFragmentString()
 				.substring( 2 ); //strip leading ", "
 	}
 
 
 	public String propertySelectFragment(String tableAlias, String suffix, boolean allProperties) {
 		return propertySelectFragmentFragment( tableAlias, suffix, allProperties ).toFragmentString();
 	}
 
 	public SelectFragment propertySelectFragmentFragment(
 			String tableAlias,
 			String suffix,
 			boolean allProperties) {
 		SelectFragment select = new SelectFragment()
 				.setSuffix( suffix )
 				.setUsedAliases( getIdentifierAliases() );
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < getSubclassColumnClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassColumnLazyClosure[i] ) &&
 				!isSubclassTableSequentialSelect( columnTableNumbers[i] ) &&
 				subclassColumnSelectableClosure[i];
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, columnTableNumbers[i] );
 				select.addColumnTemplate( subalias, columnReaderTemplates[i], columnAliases[i] );
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < getSubclassFormulaTemplateClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassFormulaLazyClosure[i] )
 				&& !isSubclassTableSequentialSelect( formulaTableNumbers[i] );
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, formulaTableNumbers[i] );
 				select.addFormula( subalias, formulaTemplates[i], formulaAliases[i] );
 			}
 		}
 
 		if ( entityMetamodel.hasSubclasses() ) {
 			addDiscriminatorToSelect( select, tableAlias, suffix );
 		}
 
 		if ( hasRowId() ) {
 			select.addColumn( tableAlias, rowIdName, ROWID_ALIAS );
 		}
 
 		return select;
 	}
 
 	public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Getting current persistent state for: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( getSQLSnapshotSelectString() );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				//if ( isVersioned() ) getVersionType().nullSafeSet( ps, version, getIdentifierColumnSpan()+1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					//otherwise return the "hydrated" state (ie. associations are not resolved)
 					Type[] types = getPropertyTypes();
 					Object[] values = new Object[types.length];
 					boolean[] includeProperty = getPropertyUpdateability();
 					for ( int i = 0; i < types.length; i++ ) {
 						if ( includeProperty[i] ) {
 							values[i] = types[i].hydrate( rs, getPropertyAliases( "", i ), session, null ); //null owner ok??
 						}
 					}
 					return values;
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        getSQLSnapshotSelectString()
 			);
 		}
 
 	}
 
 	@Override
 	public Serializable getIdByUniqueKey(Serializable key, String uniquePropertyName, SessionImplementor session) throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracef(
 					"resolving unique key [%s] to identifier for entity [%s]",
 					key,
 					getEntityName()
 			);
 		}
 
 		int propertyIndex = getSubclassPropertyIndex( uniquePropertyName );
 		if ( propertyIndex < 0 ) {
 			throw new HibernateException(
 					"Could not determine Type for property [" + uniquePropertyName + "] on entity [" + getEntityName() + "]"
 			);
 		}
 		Type propertyType = getSubclassPropertyType( propertyIndex );
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( generateIdByUniqueKeySelectString( uniquePropertyName ) );
 			try {
 				propertyType.nullSafeSet( ps, key, 1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					return (Serializable) getIdentifierType().nullSafeGet( rs, getIdentifierAliases(), session, null );
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					String.format(
 							"could not resolve unique property [%s] to identifier for entity [%s]",
 							uniquePropertyName,
 							getEntityName()
 					),
 					getSQLSnapshotSelectString()
 			);
 		}
 
 	}
 
 	protected String generateIdByUniqueKeySelectString(String uniquePropertyName) {
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "resolve id by unique property [" + getEntityName() + "." + uniquePropertyName + "]" );
 		}
 
 		final String rooAlias = getRootAlias();
 
 		select.setFromClause( fromTableFragment( rooAlias ) + fromJoinFragment( rooAlias, true, false ) );
 
 		SelectFragment selectFragment = new SelectFragment();
 		selectFragment.addColumns( rooAlias, getIdentifierColumnNames(), getIdentifierAliases() );
 		select.setSelectClause( selectFragment );
 
 		StringBuilder whereClauseBuffer = new StringBuilder();
 		final int uniquePropertyIndex = getSubclassPropertyIndex( uniquePropertyName );
 		final String uniquePropertyTableAlias = generateTableAlias(
 				rooAlias,
 				getSubclassPropertyTableNumber( uniquePropertyIndex )
 		);
 		String sep = "";
 		for ( String columnTemplate : getSubclassPropertyColumnReaderTemplateClosure()[uniquePropertyIndex] ) {
 			if ( columnTemplate == null ) {
 				continue;
 			}
 			final String columnReference = StringHelper.replace( columnTemplate, Template.TEMPLATE, uniquePropertyTableAlias );
 			whereClauseBuffer.append( sep ).append( columnReference ).append( "=?" );
 			sep = " and ";
 		}
 		for ( String formulaTemplate : getSubclassPropertyFormulaTemplateClosure()[uniquePropertyIndex] ) {
 			if ( formulaTemplate == null ) {
 				continue;
 			}
 			final String formulaReference = StringHelper.replace( formulaTemplate, Template.TEMPLATE, uniquePropertyTableAlias );
 			whereClauseBuffer.append( sep ).append( formulaReference ).append( "=?" );
 			sep = " and ";
 		}
 		whereClauseBuffer.append( whereJoinFragment( rooAlias, true, false ) );
 
 		select.setWhereClause( whereClauseBuffer.toString() );
 
 		return select.setOuterJoins( "", "" ).toStatementString();
 	}
 
 
 	/**
 	 * Generate the SQL that selects the version number by id
 	 */
 	protected String generateSelectVersionString() {
 		SimpleSelect select = new SimpleSelect( getFactory().getDialect() )
 				.setTableName( getVersionedTableName() );
 		if ( isVersioned() ) {
 			select.addColumn( versionColumnName );
 		}
 		else {
 			select.addColumns( rootTableKeyColumnNames );
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get version " + getEntityName() );
 		}
 		return select.addCondition( rootTableKeyColumnNames, "=?" ).toStatementString();
 	}
 
 	public boolean[] getPropertyUniqueness() {
 		return propertyUniqueness;
 	}
 
 	protected String generateInsertGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( GenerationTiming.INSERT );
 	}
 
 	protected String generateUpdateGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( GenerationTiming.ALWAYS );
 	}
 
 	private String generateGeneratedValuesSelectString(final GenerationTiming generationTimingToMatch) {
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get generated state " + getEntityName() );
 		}
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 
 		// Here we render the select column list based on the properties defined as being generated.
 		// For partial component generation, we currently just re-select the whole component
 		// rather than trying to handle the individual generated portions.
 		String selectClause = concretePropertySelectFragment(
 				getRootAlias(),
 				new InclusionChecker() {
 					@Override
 					public boolean includeProperty(int propertyNumber) {
 						final InDatabaseValueGenerationStrategy generationStrategy
 								= entityMetamodel.getInDatabaseValueGenerationStrategies()[propertyNumber];
 						return generationStrategy != null
 								&& timingsMatch( generationStrategy.getGenerationTiming(), generationTimingToMatch );
 					}
 				}
 		);
 		selectClause = selectClause.substring( 2 );
 
 		String fromClause = fromTableFragment( getRootAlias() ) +
 				fromJoinFragment( getRootAlias(), true, false );
 
 		String whereClause = new StringBuilder()
 				.append( StringHelper.join( "=? and ", aliasedIdColumns ) )
 				.append( "=?" )
 				.append( whereJoinFragment( getRootAlias(), true, false ) )
 				.toString();
 
 		return select.setSelectClause( selectClause )
 				.setFromClause( fromClause )
 				.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 	}
 
 	protected static interface InclusionChecker {
 		public boolean includeProperty(int propertyNumber);
 	}
 
 	protected String concretePropertySelectFragment(String alias, final boolean[] includeProperty) {
 		return concretePropertySelectFragment(
 				alias,
 				new InclusionChecker() {
 					public boolean includeProperty(int propertyNumber) {
 						return includeProperty[propertyNumber];
 					}
 				}
 		);
 	}
 
 	protected String concretePropertySelectFragment(String alias, InclusionChecker inclusionChecker) {
 		int propertyCount = getPropertyNames().length;
 		int[] propertyTableNumbers = getPropertyTableNumbersInSelect();
 		SelectFragment frag = new SelectFragment();
 		for ( int i = 0; i < propertyCount; i++ ) {
 			if ( inclusionChecker.includeProperty( i ) ) {
 				frag.addColumnTemplates(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnReaderTemplates[i],
 						propertyColumnAliases[i]
 				);
 				frag.addFormulas(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnFormulaTemplates[i],
 						propertyColumnAliases[i]
 				);
 			}
 		}
 		return frag.toFragmentString();
 	}
 
 	protected String generateSnapshotSelectString() {
 
 		//TODO: should we use SELECT .. FOR UPDATE?
 
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current state " + getEntityName() );
 		}
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 		String selectClause = StringHelper.join( ", ", aliasedIdColumns ) +
 				concretePropertySelectFragment( getRootAlias(), getPropertyUpdateability() );
 
 		String fromClause = fromTableFragment( getRootAlias() ) +
 				fromJoinFragment( getRootAlias(), true, false );
 
 		String whereClause = new StringBuilder()
 			.append( StringHelper.join( "=? and ",
 					aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		/*if ( isVersioned() ) {
 			where.append(" and ")
 				.append( getVersionColumnName() )
 				.append("=?");
 		}*/
 
 		return select.setSelectClause( selectClause )
 				.setFromClause( fromClause )
 				.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 	}
 
 	public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session) {
 		if ( !isVersioned() ) {
 			throw new AssertionFailure( "cannot force version increment on non-versioned entity" );
 		}
 
 		if ( isVersionPropertyGenerated() ) {
 			// the difficulty here is exactly what do we update in order to
 			// force the version to be incremented in the db...
 			throw new HibernateException( "LockMode.FORCE is currently not supported for generated version properties" );
 		}
 
 		Object nextVersion = getVersionType().next( currentVersion, session );
         if (LOG.isTraceEnabled()) LOG.trace("Forcing version increment [" + MessageHelper.infoString(this, id, getFactory()) + "; "
                                             + getVersionType().toLoggableString(currentVersion, getFactory()) + " -> "
                                             + getVersionType().toLoggableString(nextVersion, getFactory()) + "]");
 
 		// todo : cache this sql...
 		String versionIncrementString = generateVersionIncrementUpdateString();
 		PreparedStatement st = null;
 		try {
 			st = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( versionIncrementString, false );
 			try {
 				getVersionType().nullSafeSet( st, nextVersion, 1, session );
 				getIdentifierType().nullSafeSet( st, id, 2, session );
 				getVersionType().nullSafeSet( st, currentVersion, 2 + getIdentifierColumnSpan(), session );
 				int rows = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( st );
 				if ( rows != 1 ) {
 					throw new StaleObjectStateException( getEntityName(), id );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( st );
 			}
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not retrieve version: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					getVersionSelectString()
 				);
 		}
 
 		return nextVersion;
 	}
 
 	private String generateVersionIncrementUpdateString() {
 		Update update = new Update( getFactory().getDialect() );
 		update.setTableName( getTableName( 0 ) );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "forced version increment" );
 		}
 		update.addColumn( getVersionColumnName() );
 		update.addPrimaryKeyColumns( getIdentifierColumnNames() );
 		update.setVersionColumnName( getVersionColumnName() );
 		return update.toStatementString();
 	}
 
 	/**
 	 * Retrieve the version number
 	 */
 	public Object getCurrentVersion(Serializable id, SessionImplementor session) throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Getting version: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		try {
 			PreparedStatement st = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( getVersionSelectString() );
 			try {
 				getIdentifierType().nullSafeSet( st, id, 1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );
 				try {
 					if ( !rs.next() ) {
 						return null;
 					}
 					if ( !isVersioned() ) {
 						return this;
 					}
 					return getVersionType().nullSafeGet( rs, getVersionColumnName(), session, null );
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, st );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( st );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not retrieve version: " + MessageHelper.infoString( this, id, getFactory() ),
 					getVersionSelectString()
 			);
 		}
 	}
 
 	protected void initLockers() {
 		lockers.put( LockMode.READ, generateLocker( LockMode.READ ) );
 		lockers.put( LockMode.UPGRADE, generateLocker( LockMode.UPGRADE ) );
 		lockers.put( LockMode.UPGRADE_NOWAIT, generateLocker( LockMode.UPGRADE_NOWAIT ) );
 		lockers.put( LockMode.UPGRADE_SKIPLOCKED, generateLocker( LockMode.UPGRADE_SKIPLOCKED ) );
 		lockers.put( LockMode.FORCE, generateLocker( LockMode.FORCE ) );
 		lockers.put( LockMode.PESSIMISTIC_READ, generateLocker( LockMode.PESSIMISTIC_READ ) );
 		lockers.put( LockMode.PESSIMISTIC_WRITE, generateLocker( LockMode.PESSIMISTIC_WRITE ) );
 		lockers.put( LockMode.PESSIMISTIC_FORCE_INCREMENT, generateLocker( LockMode.PESSIMISTIC_FORCE_INCREMENT ) );
 		lockers.put( LockMode.OPTIMISTIC, generateLocker( LockMode.OPTIMISTIC ) );
 		lockers.put( LockMode.OPTIMISTIC_FORCE_INCREMENT, generateLocker( LockMode.OPTIMISTIC_FORCE_INCREMENT ) );
 	}
 
 	protected LockingStrategy generateLocker(LockMode lockMode) {
 		return factory.getDialect().getLockingStrategy( this, lockMode );
 	}
 
 	private LockingStrategy getLocker(LockMode lockMode) {
 		return ( LockingStrategy ) lockers.get( lockMode );
 	}
 
 	public void lock(
 			Serializable id,
 	        Object version,
 	        Object object,
 	        LockMode lockMode,
 	        SessionImplementor session) throws HibernateException {
 		getLocker( lockMode ).lock( id, version, object, LockOptions.WAIT_FOREVER, session );
 	}
 
 	public void lock(
 			Serializable id,
 	        Object version,
 	        Object object,
 	        LockOptions lockOptions,
 	        SessionImplementor session) throws HibernateException {
 		getLocker( lockOptions.getLockMode() ).lock( id, version, object, lockOptions.getTimeOut(), session );
 	}
 
 	public String getRootTableName() {
 		return getSubclassTableName( 0 );
 	}
 
 	public String getRootTableAlias(String drivingAlias) {
 		return drivingAlias;
 	}
 
 	public String[] getRootTableIdentifierColumnNames() {
 		return getRootTableKeyColumnNames();
 	}
 
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		return propertyMapping.toColumns( alias, propertyName );
 	}
 
 	public String[] toColumns(String propertyName) throws QueryException {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	public Type toType(String propertyName) throws QueryException {
 		return propertyMapping.toType( propertyName );
 	}
 
 	public String[] getPropertyColumnNames(String propertyName) {
 		return propertyMapping.getColumnNames( propertyName );
 	}
 
 	/**
 	 * Warning:
 	 * When there are duplicated property names in the subclasses
 	 * of the class, this method may return the wrong table
 	 * number for the duplicated subclass property (note that
 	 * SingleTableEntityPersister defines an overloaded form
 	 * which takes the entity name.
 	 */
 	public int getSubclassPropertyTableNumber(String propertyPath) {
 		String rootPropertyName = StringHelper.root(propertyPath);
 		Type type = propertyMapping.toType(rootPropertyName);
 		if ( type.isAssociationType() ) {
 			AssociationType assocType = ( AssociationType ) type;
 			if ( assocType.useLHSPrimaryKey() ) {
 				// performance op to avoid the array search
 				return 0;
 			}
 			else if ( type.isCollectionType() ) {
 				// properly handle property-ref-based associations
 				rootPropertyName = assocType.getLHSPropertyName();
 			}
 		}
 		//Enable for HHH-440, which we don't like:
 		/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {
 			String unrooted = StringHelper.unroot(propertyName);
 			int idx = ArrayHelper.indexOf( getSubclassColumnClosure(), unrooted );
 			if ( idx != -1 ) {
 				return getSubclassColumnTableNumberClosure()[idx];
 			}
 		}*/
 		int index = ArrayHelper.indexOf( getSubclassPropertyNameClosure(), rootPropertyName); //TODO: optimize this better!
 		return index==-1 ? 0 : getSubclassPropertyTableNumber(index);
 	}
 
 	public Declarer getSubclassPropertyDeclarer(String propertyPath) {
 		int tableIndex = getSubclassPropertyTableNumber( propertyPath );
 		if ( tableIndex == 0 ) {
 			return Declarer.CLASS;
 		}
 		else if ( isClassOrSuperclassTable( tableIndex ) ) {
 			return Declarer.SUPERCLASS;
 		}
 		else {
 			return Declarer.SUBCLASS;
 		}
 	}
 
 	private DiscriminatorMetadata discriminatorMetadata;
 
 	public DiscriminatorMetadata getTypeDiscriminatorMetadata() {
 		if ( discriminatorMetadata == null ) {
 			discriminatorMetadata = buildTypeDiscriminatorMetadata();
 		}
 		return discriminatorMetadata;
 	}
 
 	private DiscriminatorMetadata buildTypeDiscriminatorMetadata() {
 		return new DiscriminatorMetadata() {
 			public String getSqlFragment(String sqlQualificationAlias) {
 				return toColumns( sqlQualificationAlias, ENTITY_CLASS )[0];
 			}
 
 			public Type getResolutionType() {
 				return new DiscriminatorType( getDiscriminatorType(), AbstractEntityPersister.this );
 			}
 		};
 	}
 
 	public static String generateTableAlias(String rootAlias, int tableNumber) {
 		if ( tableNumber == 0 ) {
 			return rootAlias;
 		}
 		StringBuilder buf = new StringBuilder().append( rootAlias );
 		if ( !rootAlias.endsWith( "_" ) ) {
 			buf.append( '_' );
 		}
 		return buf.append( tableNumber ).append( '_' ).toString();
 	}
 
 	public String[] toColumns(String name, final int i) {
 		final String alias = generateTableAlias( name, getSubclassPropertyTableNumber( i ) );
 		String[] cols = getSubclassPropertyColumnNames( i );
 		String[] templates = getSubclassPropertyFormulaTemplateClosure()[i];
 		String[] result = new String[cols.length];
 		for ( int j = 0; j < cols.length; j++ ) {
 			if ( cols[j] == null ) {
 				result[j] = StringHelper.replace( templates[j], Template.TEMPLATE, alias );
 			}
 			else {
 				result[j] = StringHelper.qualify( alias, cols[j] );
 			}
 		}
 		return result;
 	}
 
 	private int getSubclassPropertyIndex(String propertyName) {
 		return ArrayHelper.indexOf(subclassPropertyNameClosure, propertyName);
 	}
 
 	protected String[] getPropertySubclassNames() {
 		return propertySubclassNames;
 	}
 
 	public String[] getPropertyColumnNames(int i) {
 		return propertyColumnNames[i];
 	}
 
 	public String[] getPropertyColumnWriters(int i) {
 		return propertyColumnWriters[i];
 	}
 
 	protected int getPropertyColumnSpan(int i) {
 		return propertyColumnSpans[i];
 	}
 
 	protected boolean hasFormulaProperties() {
 		return hasFormulaProperties;
 	}
 
 	public FetchMode getFetchMode(int i) {
 		return subclassPropertyFetchModeClosure[i];
 	}
 
 	public CascadeStyle getCascadeStyle(int i) {
 		return subclassPropertyCascadeStyleClosure[i];
 	}
 
 	public Type getSubclassPropertyType(int i) {
 		return subclassPropertyTypeClosure[i];
 	}
 
 	public String getSubclassPropertyName(int i) {
 		return subclassPropertyNameClosure[i];
 	}
 
 	public int countSubclassProperties() {
 		return subclassPropertyTypeClosure.length;
 	}
 
 	public String[] getSubclassPropertyColumnNames(int i) {
 		return subclassPropertyColumnNameClosure[i];
 	}
 
 	public boolean isDefinedOnSubclass(int i) {
 		return propertyDefinedOnSubclass[i];
 	}
 
 	@Override
 	public String[][] getSubclassPropertyFormulaTemplateClosure() {
 		return subclassPropertyFormulaTemplateClosure;
 	}
 
 	protected Type[] getSubclassPropertyTypeClosure() {
 		return subclassPropertyTypeClosure;
 	}
 
 	protected String[][] getSubclassPropertyColumnNameClosure() {
 		return subclassPropertyColumnNameClosure;
 	}
 
 	public String[][] getSubclassPropertyColumnReaderClosure() {
 		return subclassPropertyColumnReaderClosure;
 	}
 
 	public String[][] getSubclassPropertyColumnReaderTemplateClosure() {
 		return subclassPropertyColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassPropertyNameClosure() {
 		return subclassPropertyNameClosure;
 	}
 
 	@Override
 	public int[] resolveAttributeIndexes(Set<String> properties) {
 		Iterator<String> iter = properties.iterator();
 		int[] fields = new int[properties.size()];
 		int counter = 0;
 		while(iter.hasNext()) {
 			Integer index = entityMetamodel.getPropertyIndexOrNull( iter.next() );
 			if ( index != null )
 				fields[counter++] = index;
 		}
 		return fields;
 	}
 
 	protected String[] getSubclassPropertySubclassNameClosure() {
 		return subclassPropertySubclassNameClosure;
 	}
 
 	protected String[] getSubclassColumnClosure() {
 		return subclassColumnClosure;
 	}
 
 	protected String[] getSubclassColumnAliasClosure() {
 		return subclassColumnAliasClosure;
 	}
 
 	public String[] getSubclassColumnReaderTemplateClosure() {
 		return subclassColumnReaderTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaClosure() {
 		return subclassFormulaClosure;
 	}
 
 	protected String[] getSubclassFormulaTemplateClosure() {
 		return subclassFormulaTemplateClosure;
 	}
 
 	protected String[] getSubclassFormulaAliasClosure() {
 		return subclassFormulaAliasClosure;
 	}
 
 	public String[] getSubclassPropertyColumnAliases(String propertyName, String suffix) {
 		String[] rawAliases = ( String[] ) subclassPropertyAliases.get( propertyName );
 
 		if ( rawAliases == null ) {
 			return null;
 		}
 
 		String[] result = new String[rawAliases.length];
 		for ( int i = 0; i < rawAliases.length; i++ ) {
 			result[i] = new Alias( suffix ).toUnquotedAliasString( rawAliases[i] );
 		}
 		return result;
 	}
 
 	public String[] getSubclassPropertyColumnNames(String propertyName) {
 		//TODO: should we allow suffixes on these ?
 		return ( String[] ) subclassPropertyColumnNames.get( propertyName );
 	}
 
 
 
 	//This is really ugly, but necessary:
 	/**
 	 * Must be called by subclasses, at the end of their constructors
 	 */
 	protected void initSubclassPropertyAliasesMap(PersistentClass model) throws MappingException {
 
 		// ALIASES
 		internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
 
 		// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'
 		if ( ! entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			subclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );
 			subclassPropertyColumnNames.put( ENTITY_ID, getIdentifierColumnNames() );
 		}
 
 		// aliases named identifier ( alias.idname )
 		if ( hasIdentifierProperty() ) {
 			subclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );
 			subclassPropertyColumnNames.put( getIdentifierPropertyName(), getIdentifierColumnNames() );
 		}
 
 		// aliases for composite-id's
 		if ( getIdentifierType().isComponentType() ) {
 			// Fetch embedded identifiers propertynames from the "virtual" identifier component
 			CompositeType componentId = ( CompositeType ) getIdentifierType();
 			String[] idPropertyNames = componentId.getPropertyNames();
 			String[] idAliases = getIdentifierAliases();
 			String[] idColumnNames = getIdentifierColumnNames();
 
 			for ( int i = 0; i < idPropertyNames.length; i++ ) {
 				if ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 					subclassPropertyAliases.put(
 							ENTITY_ID + "." + idPropertyNames[i],
 							new String[] { idAliases[i] }
 					);
 					subclassPropertyColumnNames.put(
 							ENTITY_ID + "." + getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idColumnNames[i] }
 					);
 				}
 //				if (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyName() ) ) {
 				if ( hasIdentifierProperty() ) {
 					subclassPropertyAliases.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idAliases[i] }
 					);
 					subclassPropertyColumnNames.put(
 							getIdentifierPropertyName() + "." + idPropertyNames[i],
 							new String[] { idColumnNames[i] }
 					);
 				}
 				else {
 					// embedded composite ids ( alias.idname1, alias.idname2 )
 					subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );
 					subclassPropertyColumnNames.put( idPropertyNames[i],  new String[] { idColumnNames[i] } );
 				}
 			}
 		}
 
 		if ( entityMetamodel.isPolymorphic() ) {
 			subclassPropertyAliases.put( ENTITY_CLASS, new String[] { getDiscriminatorAlias() } );
 			subclassPropertyColumnNames.put( ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
 		}
 
 	}
 
-	/**
-	 * Must be called by subclasses, at the end of their constructors
-	 */
-	protected void initSubclassPropertyAliasesMap(EntityBinding model) throws MappingException {
-
-		// ALIASES
-
-		// TODO: Fix when subclasses are working (HHH-6337)
-		//internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
-
-		// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'
-		if ( ! entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
-			subclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );
-			subclassPropertyColumnNames.put( ENTITY_ID, getIdentifierColumnNames() );
-		}
-
-		// aliases named identifier ( alias.idname )
-		if ( hasIdentifierProperty() ) {
-			subclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );
-			subclassPropertyColumnNames.put( getIdentifierPropertyName(), getIdentifierColumnNames() );
-		}
-
-		// aliases for composite-id's
-		if ( getIdentifierType().isComponentType() ) {
-			// Fetch embedded identifiers propertynames from the "virtual" identifier component
-			CompositeType componentId = ( CompositeType ) getIdentifierType();
-			String[] idPropertyNames = componentId.getPropertyNames();
-			String[] idAliases = getIdentifierAliases();
-			String[] idColumnNames = getIdentifierColumnNames();
-
-			for ( int i = 0; i < idPropertyNames.length; i++ ) {
-				if ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
-					subclassPropertyAliases.put(
-							ENTITY_ID + "." + idPropertyNames[i],
-							new String[] { idAliases[i] }
-					);
-					subclassPropertyColumnNames.put(
-							ENTITY_ID + "." + getIdentifierPropertyName() + "." + idPropertyNames[i],
-							new String[] { idColumnNames[i] }
-					);
-				}
-//				if (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyName() ) ) {
-				if ( hasIdentifierProperty() ) {
-					subclassPropertyAliases.put(
-							getIdentifierPropertyName() + "." + idPropertyNames[i],
-							new String[] { idAliases[i] }
-					);
-					subclassPropertyColumnNames.put(
-							getIdentifierPropertyName() + "." + idPropertyNames[i],
-							new String[] { idColumnNames[i] }
-					);
-				}
-				else {
-					// embedded composite ids ( alias.idname1, alias.idname2 )
-					subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );
-					subclassPropertyColumnNames.put( idPropertyNames[i],  new String[] { idColumnNames[i] } );
-				}
-			}
-		}
-
-		if ( entityMetamodel.isPolymorphic() ) {
-			subclassPropertyAliases.put( ENTITY_CLASS, new String[] { getDiscriminatorAlias() } );
-			subclassPropertyColumnNames.put( ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
-		}
-
-	}
-
 	private void internalInitSubclassPropertyAliasesMap(String path, Iterator propertyIterator) {
 		while ( propertyIterator.hasNext() ) {
 
 			Property prop = ( Property ) propertyIterator.next();
 			String propname = path == null ? prop.getName() : path + "." + prop.getName();
 			if ( prop.isComposite() ) {
 				Component component = ( Component ) prop.getValue();
 				Iterator compProps = component.getPropertyIterator();
 				internalInitSubclassPropertyAliasesMap( propname, compProps );
 			}
 			else {
 				String[] aliases = new String[prop.getColumnSpan()];
 				String[] cols = new String[prop.getColumnSpan()];
 				Iterator colIter = prop.getColumnIterator();
 				int l = 0;
 				while ( colIter.hasNext() ) {
 					Selectable thing = ( Selectable ) colIter.next();
 					aliases[l] = thing.getAlias( getFactory().getDialect(), prop.getValue().getTable() );
 					cols[l] = thing.getText( getFactory().getDialect() ); // TODO: skip formulas?
 					l++;
 				}
 
 				subclassPropertyAliases.put( propname, aliases );
 				subclassPropertyColumnNames.put( propname, cols );
 			}
 		}
 
 	}
 
 	public Object loadByUniqueKey(
 			String propertyName,
 			Object uniqueKey,
 			SessionImplementor session) throws HibernateException {
 		return getAppropriateUniqueKeyLoader( propertyName, session ).loadByUniqueKey( session, uniqueKey );
 	}
 
 	private EntityLoader getAppropriateUniqueKeyLoader(String propertyName, SessionImplementor session) {
 		final boolean useStaticLoader = !session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& !session.getLoadQueryInfluencers().hasEnabledFetchProfiles()
 				&& propertyName.indexOf('.')<0; //ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties
 
 		if ( useStaticLoader ) {
 			return ( EntityLoader ) uniqueKeyLoaders.get( propertyName );
 		}
 		else {
 			return createUniqueKeyLoader(
 					propertyMapping.toType( propertyName ),
 					propertyMapping.toColumns( propertyName ),
 					session.getLoadQueryInfluencers()
 			);
 		}
 	}
 
 	public int getPropertyIndex(String propertyName) {
 		return entityMetamodel.getPropertyIndex(propertyName);
 	}
 
 	protected void createUniqueKeyLoaders() throws MappingException {
 		Type[] propertyTypes = getPropertyTypes();
 		String[] propertyNames = getPropertyNames();
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( propertyUniqueness[i] ) {
 				//don't need filters for the static loaders
 				uniqueKeyLoaders.put(
 						propertyNames[i],
 						createUniqueKeyLoader(
 								propertyTypes[i],
 								getPropertyColumnNames( i ),
 								LoadQueryInfluencers.NONE
 						)
 				);
 				//TODO: create uk loaders for component properties
 			}
 		}
 	}
 
 	private EntityLoader createUniqueKeyLoader(
 			Type uniqueKeyType,
 			String[] columns,
 			LoadQueryInfluencers loadQueryInfluencers) {
 		if ( uniqueKeyType.isEntityType() ) {
 			String className = ( ( EntityType ) uniqueKeyType ).getAssociatedEntityName();
 			uniqueKeyType = getFactory().getEntityPersister( className ).getIdentifierType();
 		}
 		return new EntityLoader(
 				this,
 				columns,
 				uniqueKeyType,
 				1,
 				LockMode.NONE,
 				getFactory(),
 				loadQueryInfluencers
 		);
 	}
 
 	protected String getSQLWhereString(String alias) {
 		return StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );
 	}
 
 	protected boolean hasWhere() {
 		return sqlWhereString != null;
 	}
 
 	private void initOrdinaryPropertyPaths(Mapping mapping) throws MappingException {
 		for ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {
 			propertyMapping.initPropertyPaths( getSubclassPropertyNameClosure()[i],
 					getSubclassPropertyTypeClosure()[i],
 					getSubclassPropertyColumnNameClosure()[i],
 					getSubclassPropertyColumnReaderClosure()[i],
 					getSubclassPropertyColumnReaderTemplateClosure()[i],
 					getSubclassPropertyFormulaTemplateClosure()[i],
 					mapping );
 		}
 	}
 
 	private void initIdentifierPropertyPaths(Mapping mapping) throws MappingException {
 		String idProp = getIdentifierPropertyName();
 		if ( idProp != null ) {
 			propertyMapping.initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			propertyMapping.initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 		if ( ! entityMetamodel.hasNonIdentifierPropertyNamedId() ) {
 			propertyMapping.initPropertyPaths( ENTITY_ID, getIdentifierType(), getIdentifierColumnNames(),
 					getIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping );
 		}
 	}
 
 	private void initDiscriminatorPropertyPath(Mapping mapping) throws MappingException {
 		propertyMapping.initPropertyPaths( ENTITY_CLASS,
 				getDiscriminatorType(),
 				new String[]{getDiscriminatorColumnName()},
 				new String[]{getDiscriminatorColumnReaders()},
 				new String[]{getDiscriminatorColumnReaderTemplate()},
 				new String[]{getDiscriminatorFormulaTemplate()},
 				getFactory() );
 	}
 
 	protected void initPropertyPaths(Mapping mapping) throws MappingException {
 		initOrdinaryPropertyPaths(mapping);
 		initOrdinaryPropertyPaths(mapping); //do two passes, for collection property-ref!
 		initIdentifierPropertyPaths(mapping);
 		if ( entityMetamodel.isPolymorphic() ) {
 			initDiscriminatorPropertyPath( mapping );
 		}
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockMode lockMode,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
 				.buildLoader( this, batchSize, lockMode, getFactory(), loadQueryInfluencers );
 	}
 
 	protected UniqueEntityLoader createEntityLoader(
 			LockOptions lockOptions,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		//TODO: disable batch loading if lockMode > READ?
 		return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
 				.buildLoader( this, batchSize, lockOptions, getFactory(), loadQueryInfluencers );
 	}
 
 	/**
 	 * Used internally to create static loaders.  These are the default set of loaders used to handle get()/load()
 	 * processing.  lock() handling is done by the LockingStrategy instances (see {@link #getLocker})
 	 *
 	 * @param lockMode The lock mode to apply to the thing being loaded.
 	 * @return
 	 *
 	 * @throws MappingException
 	 */
 	protected UniqueEntityLoader createEntityLoader(LockMode lockMode) throws MappingException {
 		return createEntityLoader( lockMode, LoadQueryInfluencers.NONE );
 	}
 
 	protected boolean check(int rows, Serializable id, int tableNumber, Expectation expectation, PreparedStatement statement) throws HibernateException {
 		try {
 			expectation.verifyOutcome( rows, statement, -1 );
 		}
 		catch( StaleStateException e ) {
 			if ( !isNullableTable( tableNumber ) ) {
 				if ( getFactory().getStatistics().isStatisticsEnabled() ) {
 					getFactory().getStatisticsImplementor()
 							.optimisticFailure( getEntityName() );
 				}
 				throw new StaleObjectStateException( getEntityName(), id );
 			}
 			return false;
 		}
 		catch( TooManyRowsAffectedException e ) {
 			throw new HibernateException(
 					"Duplicate identifier in table for: " +
 					MessageHelper.infoString( this, id, getFactory() )
 			);
 		}
 		catch ( Throwable t ) {
 			return false;
 		}
 		return true;
 	}
 
 	protected String generateUpdateString(boolean[] includeProperty, int j, boolean useRowId) {
 		return generateUpdateString( includeProperty, j, null, useRowId );
 	}
 
 	/**
 	 * Generate the SQL that updates a row by id (and version)
 	 */
 	protected String generateUpdateString(final boolean[] includeProperty,
 										  final int j,
 										  final Object[] oldFields,
 										  final boolean useRowId) {
 
 		Update update = new Update( getFactory().getDialect() ).setTableName( getTableName( j ) );
 
 		// select the correct row by either pk or rowid
 		if ( useRowId ) {
 			update.addPrimaryKeyColumns( new String[]{rowIdName} ); //TODO: eventually, rowIdName[j]
 		}
 		else {
 			update.addPrimaryKeyColumns( getKeyColumns( j ) );
 		}
 
 		boolean hasColumns = false;
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) 
 					&& !lobProperties.contains( i ) ) {
 				// this is a property of the table, which we are updating
 				update.addColumns( getPropertyColumnNames(i),
 						propertyColumnUpdateable[i], propertyColumnWriters[i] );
 				hasColumns = hasColumns || getPropertyColumnSpan( i ) > 0;
 			}
 		}
 		
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this property belongs on the table and is to be inserted
 				update.addColumns( getPropertyColumnNames(i),
 						propertyColumnUpdateable[i], propertyColumnWriters[i] );
 				hasColumns = true;
 			}
 		}
 
 		if ( j == 0 && isVersioned() && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
 			// this is the root (versioned) table, and we are using version-based
 			// optimistic locking;  if we are not updating the version, also don't
 			// check it (unless this is a "generated" version column)!
 			if ( checkVersion( includeProperty ) ) {
 				update.setVersionColumnName( getVersionColumnName() );
 				hasColumns = true;
 			}
 		}
 		else if ( isAllOrDirtyOptLocking() && oldFields != null ) {
 			// we are using "all" or "dirty" property-based optimistic locking
 
 			boolean[] includeInWhere = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
 					? getPropertyUpdateability() //optimistic-lock="all", include all updatable properties
 					: includeProperty; 			 //optimistic-lock="dirty", include all properties we are updating this time
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				boolean include = includeInWhere[i] &&
 						isPropertyOfTable( i, j ) &&
 						versionability[i];
 				if ( include ) {
 					// this property belongs to the table, and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					String[] propertyColumnWriters = getPropertyColumnWriters( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( oldFields[i], getFactory() );
 					for ( int k=0; k<propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							update.addWhereColumn( propertyColumnNames[k], "=" + propertyColumnWriters[k] );
 						}
 						else {
 							update.addWhereColumn( propertyColumnNames[k], " is null" );
 						}
 					}
 				}
 			}
 
 		}
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			update.setComment( "update " + getEntityName() );
 		}
 
 		return hasColumns ? update.toStatementString() : null;
 	}
 
 	private boolean checkVersion(final boolean[] includeProperty) {
 		return includeProperty[ getVersionProperty() ]
 				|| entityMetamodel.isVersionGenerated();
 	}
 
 	protected String generateInsertString(boolean[] includeProperty, int j) {
 		return generateInsertString( false, includeProperty, j );
 	}
 
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty) {
 		return generateInsertString( identityInsert, includeProperty, 0 );
 	}
 
 	/**
 	 * Generate the SQL that inserts a row
 	 */
 	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty, int j) {
 
 		// todo : remove the identityInsert param and variations;
 		//   identity-insert strings are now generated from generateIdentityInsertString()
 
 		Insert insert = new Insert( getFactory().getDialect() )
 				.setTableName( getTableName( j ) );
 
 		// add normal properties
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			// the incoming 'includeProperty' array only accounts for insertable defined at the root level, it
 			// does not account for partially generated composites etc.  We also need to account for generation
 			// values
 			if ( isPropertyOfTable( i, j ) ) {
 				if ( !lobProperties.contains( i ) ) {
 					final InDatabaseValueGenerationStrategy generationStrategy = entityMetamodel.getInDatabaseValueGenerationStrategies()[i];
 					if ( generationStrategy != null && generationStrategy.getGenerationTiming().includesInsert() ) {
 						if ( generationStrategy.referenceColumnsInSql() ) {
 							final String[] values;
 							if ( generationStrategy.getReferencedColumnValues() == null ) {
 								values = propertyColumnWriters[i];
 							}
 							else {
 								final int numberOfColumns = propertyColumnWriters[i].length;
 								values = new String[ numberOfColumns ];
 								for ( int x = 0; x < numberOfColumns; x++ ) {
 									if ( generationStrategy.getReferencedColumnValues()[x] != null ) {
 										values[x] = generationStrategy.getReferencedColumnValues()[x];
 									}
 									else {
 										values[x] = propertyColumnWriters[i][x];
 									}
 								}
 							}
 							insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], values );
 						}
 					}
 					else if ( includeProperty[i] ) {
 						insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
 					}
 				}
 			}
 		}
 
 		// add the discriminator
 		if ( j == 0 ) {
 			addDiscriminatorToInsert( insert );
 		}
 
 		// add the primary key
 		if ( j == 0 && identityInsert ) {
 			insert.addIdentityColumn( getKeyColumns( 0 )[0] );
 		}
 		else {
 			insert.addColumns( getKeyColumns( j ) );
 		}
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 		
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns(
 						getPropertyColumnNames(i),
 						propertyColumnInsertable[i],
 						propertyColumnWriters[i]
 				);
 			}
 		}
 
 		String result = insert.toStatementString();
 
 		// append the SQL to return the generated identifier
 		if ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert
 			result = getFactory().getDialect().appendIdentitySelectToInsert( result );
 		}
 
 		return result;
 	}
 
 	/**
 	 * Used to generate an insery statement against the root table in the
 	 * case of identifier generation strategies where the insert statement
 	 * executions actually generates the identifier value.
 	 *
 	 * @param includeProperty indices of the properties to include in the
 	 * insert statement.
 	 * @return The insert SQL statement string
 	 */
 	protected String generateIdentityInsertString(boolean[] includeProperty) {
 		Insert insert = identityDelegate.prepareIdentifierGeneratingInsert();
 		insert.setTableName( getTableName( 0 ) );
 
 		// add normal properties except lobs
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, 0 ) && !lobProperties.contains( i ) ) {
 				// this property belongs on the table and is to be inserted
 				insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// HHH-4635 & HHH-8103
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, 0 ) ) {
 				insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
 			}
 		}
 
 		// add the discriminator
 		addDiscriminatorToInsert( insert );
 
 		// delegate already handles PK columns
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert " + getEntityName() );
 		}
 
 		return insert.toStatementString();
 	}
 
 	/**
 	 * Generate the SQL that deletes a row by id (and version)
 	 */
 	protected String generateDeleteString(int j) {
 		Delete delete = new Delete()
 				.setTableName( getTableName( j ) )
 				.addPrimaryKeyColumns( getKeyColumns( j ) );
 		if ( j == 0 ) {
 			delete.setVersionColumnName( getVersionColumnName() );
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			delete.setComment( "delete " + getEntityName() );
 		}
 		return delete.toStatementString();
 	}
 
 	protected int dehydrate(
 			Serializable id,
 			Object[] fields,
 			boolean[] includeProperty,
 			boolean[][] includeColumns,
 			int j,
 			PreparedStatement st,
 			SessionImplementor session,
 			boolean isUpdate) throws HibernateException, SQLException {
 		return dehydrate( id, fields, null, includeProperty, includeColumns, j, st, session, 1, isUpdate );
 	}
 
 	/**
 	 * Marshall the fields of a persistent instance to a prepared statement
 	 */
 	protected int dehydrate(
 			final Serializable id,
 			final Object[] fields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final boolean[][] includeColumns,
 			final int j,
 			final PreparedStatement ps,
 			final SessionImplementor session,
 			int index,
 			boolean isUpdate ) throws SQLException, HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Dehydrating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j )
 					&& !lobProperties.contains( i )) {
 				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
 				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
 			}
 		}
 		
 		if ( !isUpdate ) {
 			index += dehydrateId( id, rowId, ps, session, index );
 		}
 		
 		// HHH-4635
 		// Oracle expects all Lob properties to be last in inserts
 		// and updates.  Insert them at the end.
 		for ( int i : lobProperties ) {
 			if ( includeProperty[i] && isPropertyOfTable( i, j ) ) {
 				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
 				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
 			}
 		}
 		
 		if ( isUpdate ) {
 			index += dehydrateId( id, rowId, ps, session, index );
 		}
 
 		return index;
 
 	}
 	
 	private int dehydrateId( 
 			final Serializable id,
 			final Object rowId,
 			final PreparedStatement ps,
 			final SessionImplementor session,
 			int index ) throws SQLException {
 		if ( rowId != null ) {
 			ps.setObject( index, rowId );
 			return 1;
 		} else if ( id != null ) {
 			getIdentifierType().nullSafeSet( ps, id, index, session );
 			return getIdentifierColumnSpan();
 		}
 		return 0;
 	}
 
 	/**
 	 * Unmarshall the fields of a persistent instance from a result set,
 	 * without resolving associations or collections. Question: should
 	 * this really be here, or should it be sent back to Loader?
 	 */
 	public Object[] hydrate(
 			final ResultSet rs,
 			final Serializable id,
 			final Object object,
 			final Loadable rootLoadable,
 			final String[][] suffixedPropertyColumns,
 			final boolean allProperties,
 			final SessionImplementor session) throws SQLException, HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Hydrating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		final AbstractEntityPersister rootPersister = (AbstractEntityPersister) rootLoadable;
 
 		final boolean hasDeferred = rootPersister.hasSequentialSelect();
 		PreparedStatement sequentialSelect = null;
 		ResultSet sequentialResultSet = null;
 		boolean sequentialSelectEmpty = false;
 		try {
 
 			if ( hasDeferred ) {
 				final String sql = rootPersister.getSequentialSelect( getEntityName() );
 				if ( sql != null ) {
 					//TODO: I am not so sure about the exception handling in this bit!
 					sequentialSelect = session.getTransactionCoordinator()
 							.getJdbcCoordinator()
 							.getStatementPreparer()
 							.prepareStatement( sql );
 					rootPersister.getIdentifierType().nullSafeSet( sequentialSelect, id, 1, session );
 					sequentialResultSet = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( sequentialSelect );
 					if ( !sequentialResultSet.next() ) {
 						// TODO: Deal with the "optional" attribute in the <join> mapping;
 						// this code assumes that optional defaults to "true" because it
 						// doesn't actually seem to work in the fetch="join" code
 						//
 						// Note that actual proper handling of optional-ality here is actually
 						// more involved than this patch assumes.  Remember that we might have
 						// multiple <join/> mappings associated with a single entity.  Really
 						// a couple of things need to happen to properly handle optional here:
 						//  1) First and foremost, when handling multiple <join/>s, we really
 						//      should be using the entity root table as the driving table;
 						//      another option here would be to choose some non-optional joined
 						//      table to use as the driving table.  In all likelihood, just using
 						//      the root table is much simplier
 						//  2) Need to add the FK columns corresponding to each joined table
 						//      to the generated select list; these would then be used when
 						//      iterating the result set to determine whether all non-optional
 						//      data is present
 						// My initial thoughts on the best way to deal with this would be
 						// to introduce a new SequentialSelect abstraction that actually gets
 						// generated in the persisters (ok, SingleTable...) and utilized here.
 						// It would encapsulated all this required optional-ality checking...
 						sequentialSelectEmpty = true;
 					}
 				}
 			}
 
 			final String[] propNames = getPropertyNames();
 			final Type[] types = getPropertyTypes();
 			final Object[] values = new Object[types.length];
 			final boolean[] laziness = getPropertyLaziness();
 			final String[] propSubclassNames = getSubclassPropertySubclassNameClosure();
 
 			for ( int i = 0; i < types.length; i++ ) {
 				if ( !propertySelectable[i] ) {
 					values[i] = BackrefPropertyAccessor.UNKNOWN;
 				}
 				else if ( allProperties || !laziness[i] ) {
 					//decide which ResultSet to get the property value from:
 					final boolean propertyIsDeferred = hasDeferred &&
 							rootPersister.isSubclassPropertyDeferred( propNames[i], propSubclassNames[i] );
 					if ( propertyIsDeferred && sequentialSelectEmpty ) {
 						values[i] = null;
 					}
 					else {
 						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
 						final String[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];
 						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );
 					}
 				}
 				else {
 					values[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 				}
 			}
 
 			if ( sequentialResultSet != null ) {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( sequentialResultSet, sequentialSelect );
 			}
 
 			return values;
 
 		}
 		finally {
 			if ( sequentialSelect != null ) {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( sequentialSelect );
 			}
 		}
 	}
 
 	protected boolean useInsertSelectIdentity() {
 		return !useGetGeneratedKeys() && getFactory().getDialect().supportsInsertSelectIdentity();
 	}
 
 	protected boolean useGetGeneratedKeys() {
 		return getFactory().getSettings().isGetGeneratedKeysEnabled();
 	}
 
 	protected String getSequentialSelect(String entityName) {
 		throw new UnsupportedOperationException("no sequential selects");
 	}
 
 	/**
 	 * Perform an SQL INSERT, and then retrieve a generated identifier.
 	 * <p/>
 	 * This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY,
 	 * select, etc).
 	 */
 	protected Serializable insert(
 			final Object[] fields,
 			final boolean[] notNull,
 			String sql,
 			final Object object,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Inserting entity: {0} (native id)", getEntityName() );
 			if ( isVersioned() ) {
 				LOG.tracev( "Version: {0}", Versioning.getVersion( fields, this ) );
 			}
 		}
 
 		Binder binder = new Binder() {
 			public void bindValues(PreparedStatement ps) throws SQLException {
 				dehydrate( null, fields, notNull, propertyColumnInsertable, 0, ps, session, false );
 			}
 			public Object getEntity() {
 				return object;
 			}
 		};
 
 		return identityDelegate.performInsert( sql, session, binder );
 	}
 
 	public String getIdentitySelectString() {
 		//TODO: cache this in an instvar
 		return getFactory().getDialect().getIdentitySelectString(
 				getTableName(0),
 				getKeyColumns(0)[0],
 				getIdentifierType().sqlTypes( getFactory() )[0]
 		);
 	}
 
 	public String getSelectByUniqueKeyString(String propertyName) {
 		return new SimpleSelect( getFactory().getDialect() )
 			.setTableName( getTableName(0) )
 			.addColumns( getKeyColumns(0) )
 			.addCondition( getPropertyColumnNames(propertyName), "=?" )
 			.toStatementString();
 	}
 
 	private BasicBatchKey inserBatchKey;
 
 	/**
 	 * Perform an SQL INSERT.
 	 * <p/>
 	 * This for is used for all non-root tables as well as the root table
 	 * in cases where the identifier value is known before the insert occurs.
 	 */
 	protected void insert(
 			final Serializable id,
 			final Object[] fields,
 			final boolean[] notNull,
 			final int j,
 			final String sql,
 			final Object object,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		//note: it is conceptually possible that a UserType could map null to
 		//	  a non-null value, so the following is arguable:
 		if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 			return;
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Inserting entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( j == 0 && isVersioned() )
 				LOG.tracev( "Version: {0}", Versioning.getVersion( fields, this ) );
 		}
 
 		// TODO : shouldn't inserts be Expectations.NONE?
 		final Expectation expectation = Expectations.appropriateExpectation( insertResultCheckStyles[j] );
 		// we can't batch joined inserts, *especially* not if it is an identity insert;
 		// nor can we batch statements where the expectation is based on an output param
 		final boolean useBatch = j == 0 && expectation.canBeBatched();
 		if ( useBatch && inserBatchKey == null ) {
 			inserBatchKey = new BasicBatchKey(
 					getEntityName() + "#INSERT",
 					expectation
 			);
 		}
 		final boolean callable = isInsertCallable( j );
 
 		try {
 			// Render the SQL query
 			final PreparedStatement insert;
 			if ( useBatch ) {
 				insert = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getBatch( inserBatchKey )
 						.getBatchStatement( sql, callable );
 			}
 			else {
 				insert = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getStatementPreparer()
 						.prepareStatement( sql, callable );
 			}
 
 			try {
 				int index = 1;
 				index += expectation.prepare( insert );
 
 				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
 				// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
 
 				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
 
 				if ( useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
 				}
 				else {
 					expectation.verifyOutcome( session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( insert ), insert, -1 );
 				}
 
 			}
 			catch ( SQLException e ) {
 				if ( useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 				}
 				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( insert );
 				}
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not insert: " + MessageHelper.infoString( this ),
 					sql
 			);
 		}
 
 	}
 
 	/**
 	 * Perform an SQL UPDATE or SQL INSERT
 	 */
 	protected void updateOrInsert(
 			final Serializable id,
 			final Object[] fields,
 			final Object[] oldFields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final int j,
 			final Object oldVersion,
 			final Object object,
 			final String sql,
 			final SessionImplementor session) throws HibernateException {
 
 		if ( !isInverseTable( j ) ) {
 
 			final boolean isRowToUpdate;
 			if ( isNullableTable( j ) && oldFields != null && isAllNull( oldFields, j ) ) {
 				//don't bother trying to update, we know there is no row there yet
 				isRowToUpdate = false;
 			}
 			else if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
 				//if all fields are null, we might need to delete existing row
 				isRowToUpdate = true;
 				delete( id, oldVersion, j, object, getSQLDeleteStrings()[j], session, null );
 			}
 			else {
 				//there is probably a row there, so try to update
 				//if no rows were updated, we will find out
 				isRowToUpdate = update( id, fields, oldFields, rowId, includeProperty, j, oldVersion, object, sql, session );
 			}
 
 			if ( !isRowToUpdate && !isAllNull( fields, j ) ) {
 				// assume that the row was not there since it previously had only null
 				// values, so do an INSERT instead
 				//TODO: does not respect dynamic-insert
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 
 		}
 
 	}
 
 	private BasicBatchKey updateBatchKey;
 
 	protected boolean update(
 			final Serializable id,
 			final Object[] fields,
 			final Object[] oldFields,
 			final Object rowId,
 			final boolean[] includeProperty,
 			final int j,
 			final Object oldVersion,
 			final Object object,
 			final String sql,
 			final SessionImplementor session) throws HibernateException {
 
 		final Expectation expectation = Expectations.appropriateExpectation( updateResultCheckStyles[j] );
 		final boolean useBatch = j == 0 && expectation.canBeBatched() && isBatchable(); //note: updates to joined tables can't be batched...
 		if ( useBatch && updateBatchKey == null ) {
 			updateBatchKey = new BasicBatchKey(
 					getEntityName() + "#UPDATE",
 					expectation
 			);
 		}
 		final boolean callable = isUpdateCallable( j );
 		final boolean useVersion = j == 0 && isVersioned();
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Updating entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion )
 				LOG.tracev( "Existing version: {0} -> New version:{1}", oldVersion, fields[getVersionProperty()] );
 		}
 
 		try {
 			int index = 1; // starting index
 			final PreparedStatement update;
 			if ( useBatch ) {
 				update = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getBatch( updateBatchKey )
 						.getBatchStatement( sql, callable );
 			}
 			else {
 				update = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getStatementPreparer()
 						.prepareStatement( sql, callable );
 			}
 
 			try {
 				index+= expectation.prepare( update );
 
 				//Now write the values of fields onto the prepared statement
 				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );
 
 				// Write any appropriate versioning conditional parameters
 				if ( useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
 					if ( checkVersion( includeProperty ) ) {
 						getVersionType().nullSafeSet( update, oldVersion, index, session );
 					}
 				}
 				else if ( isAllOrDirtyOptLocking() && oldFields != null ) {
 					boolean[] versionability = getPropertyVersionability(); //TODO: is this really necessary????
 					boolean[] includeOldField = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
 							? getPropertyUpdateability()
 							: includeProperty;
 					Type[] types = getPropertyTypes();
 					for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 						boolean include = includeOldField[i] &&
 								isPropertyOfTable( i, j ) &&
 								versionability[i]; //TODO: is this really necessary????
 						if ( include ) {
 							boolean[] settable = types[i].toColumnNullness( oldFields[i], getFactory() );
 							types[i].nullSafeSet(
 									update,
 									oldFields[i],
 									index,
 									settable,
 									session
 								);
 							index += ArrayHelper.countTrue(settable);
 						}
 					}
 				}
 
 				if ( useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( updateBatchKey ).addToBatch();
 					return true;
 				}
 				else {
 					return check( session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( update ), id, j, expectation, update );
 				}
 
 			}
 			catch ( SQLException e ) {
 				if ( useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
 				}
 				throw e;
 			}
 			finally {
 				if ( !useBatch ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( update );
 				}
 			}
 
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not update: " + MessageHelper.infoString( this, id, getFactory() ),
 					sql
 				);
 		}
 	}
 
 	private BasicBatchKey deleteBatchKey;
 
 	/**
 	 * Perform an SQL DELETE
 	 */
 	protected void delete(
 			final Serializable id,
 			final Object version,
 			final int j,
 			final Object object,
 			final String sql,
 			final SessionImplementor session,
 			final Object[] loadedState) throws HibernateException {
 
 		if ( isInverseTable( j ) ) {
 			return;
 		}
 
 		final boolean useVersion = j == 0 && isVersioned();
 		final boolean callable = isDeleteCallable( j );
 		final Expectation expectation = Expectations.appropriateExpectation( deleteResultCheckStyles[j] );
 		final boolean useBatch = j == 0 && isBatchable() && expectation.canBeBatched();
 		if ( useBatch && deleteBatchKey == null ) {
 			deleteBatchKey = new BasicBatchKey(
 					getEntityName() + "#DELETE",
 					expectation
 			);
 		}
 
 		final boolean traceEnabled = LOG.isTraceEnabled();
 		if ( traceEnabled ) {
 			LOG.tracev( "Deleting entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 			if ( useVersion )
 				LOG.tracev( "Version: {0}", version );
 		}
 
 		if ( isTableCascadeDeleteEnabled( j ) ) {
 			if ( traceEnabled ) {
 				LOG.tracev( "Delete handled by foreign key constraint: {0}", getTableName( j ) );
 			}
 			return; //EARLY EXIT!
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/DiscriminatorType.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/DiscriminatorType.java
index 61357afdac..a0a9b983d1 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/DiscriminatorType.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/DiscriminatorType.java
@@ -1,166 +1,166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.compare.EqualsHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.type.AbstractType;
 import org.hibernate.type.Type;
 
 import org.dom4j.Node;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class DiscriminatorType extends AbstractType {
 	private final Type underlyingType;
 	private final Loadable persister;
 
 	public DiscriminatorType(Type underlyingType, Loadable persister) {
 		this.underlyingType = underlyingType;
 		this.persister = persister;
 	}
 
 	public Class getReturnedClass() {
 		return Class.class;
 	}
 
 	public String getName() {
 		return getClass().getName();
 	}
 
 	public boolean isMutable() {
 		return false;
 	}
 
 	public Object nullSafeGet(
 			ResultSet rs,
 			String[] names,
 			SessionImplementor session,
 			Object owner) throws HibernateException, SQLException {
 		return nullSafeGet( rs, names[0], session, owner );
 	}
 
 	public Object nullSafeGet(
 			ResultSet rs,
 			String name,
 			SessionImplementor session,
 			Object owner) throws HibernateException, SQLException {
 		final Object discriminatorValue = underlyingType.nullSafeGet( rs, name, session, owner );
 		final String entityName = persister.getSubclassForDiscriminatorValue( discriminatorValue );
 		if ( entityName == null ) {
 			throw new HibernateException( "Unable to resolve discriminator value [" + discriminatorValue + "] to entity name" );
 		}
 		final EntityPersister entityPersister = session.getEntityPersister( entityName, null );
         return ( EntityMode.POJO == entityPersister.getEntityMode() ) ? entityPersister.getMappedClass() : entityName;
 	}
 
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			boolean[] settable,
 			SessionImplementor session) throws HibernateException, SQLException {
 		nullSafeSet( st, value, index, session );
 	}
 
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			SessionImplementor session) throws HibernateException, SQLException {
 		String entityName = session.getFactory().getClassMetadata((Class) value).getEntityName();
 		Loadable entityPersister = (Loadable) session.getFactory().getEntityPersister(entityName);
 		underlyingType.nullSafeSet(st, entityPersister.getDiscriminatorValue(), index, session);
 	}
 
 	public String toLoggableString(Object value, SessionFactoryImplementor factory) throws HibernateException {
 		return value == null ? "[null]" : value.toString();
 	}
 
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		return value;
 	}
 
 	public Object replace(Object original, Object target, SessionImplementor session, Object owner, Map copyCache)
 			throws HibernateException {
 		return original;
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		return value == null
 				? ArrayHelper.FALSE
 				: ArrayHelper.TRUE;
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		return EqualsHelper.equals( old, current );
 	}
 
 
 	// simple delegation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		return underlyingType.sqlTypes( mapping );
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return underlyingType.dictatedSizes( mapping );
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return underlyingType.defaultSizes( mapping );
 	}
 
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		return underlyingType.getColumnSpan( mapping );
 	}
 
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory) throws HibernateException {
 	}
 
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		// todo : ???
 		return null;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java
index d90331606e..3212011bda 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java
@@ -1,1191 +1,1145 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.DynamicFilterAliasGenerator;
 import org.hibernate.internal.FilterAliasGenerator;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Formula;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.MappedSuperclass;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.Value;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.sql.CaseFragment;
 import org.hibernate.sql.InFragment;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.type.*;
 import org.hibernate.type.DiscriminatorType;
 
 import org.jboss.logging.Logger;
 
 /**
  * An <tt>EntityPersister</tt> implementing the normalized "table-per-subclass"
  * mapping strategy
  *
  * @author Gavin King
  */
 public class JoinedSubclassEntityPersister extends AbstractEntityPersister {
 	private static final Logger log = Logger.getLogger( JoinedSubclassEntityPersister.class );
 
 	private static final String IMPLICIT_DISCRIMINATOR_ALIAS = "clazz_";
 	private static final Object NULL_DISCRIMINATOR = new MarkerObject("<null discriminator>");
 	private static final Object NOT_NULL_DISCRIMINATOR = new MarkerObject("<not null discriminator>");
 	private static final String NULL_STRING = "null";
 	private static final String NOT_NULL_STRING = "not null";
 
 	// the class hierarchy structure
 	private final int tableSpan;
 	private final String[] tableNames;
 	private final String[] naturalOrderTableNames;
 	private final String[][] tableKeyColumns;
 	private final String[][] tableKeyColumnReaders;
 	private final String[][] tableKeyColumnReaderTemplates;
 	private final String[][] naturalOrderTableKeyColumns;
 	private final String[][] naturalOrderTableKeyColumnReaders;
 	private final String[][] naturalOrderTableKeyColumnReaderTemplates;
 	private final boolean[] naturalOrderCascadeDeleteEnabled;
 
 	private final String[] spaces;
 
 	private final String[] subclassClosure;
 
 	private final String[] subclassTableNameClosure;
 	private final String[][] subclassTableKeyColumnClosure;
 	private final boolean[] isClassOrSuperclassTable;
 
 	// properties of this class, including inherited properties
 	private final int[] naturalOrderPropertyTableNumbers;
 	private final int[] propertyTableNumbers;
 
 	// the closure of all properties in the entire hierarchy including
 	// subclasses and superclasses of this class
 	private final int[] subclassPropertyTableNumberClosure;
 
 	// the closure of all columns used by the entire hierarchy including
 	// subclasses and superclasses of this class
 	private final int[] subclassColumnTableNumberClosure;
 	private final int[] subclassFormulaTableNumberClosure;
 
 	private final boolean[] subclassTableSequentialSelect;
 	private final boolean[] subclassTableIsLazyClosure;
 
 	// subclass discrimination works by assigning particular
 	// values to certain combinations of null primary key
 	// values in the outer join using an SQL CASE
 	private final Map subclassesByDiscriminatorValue = new HashMap();
 	private final String[] discriminatorValues;
 	private final String[] notNullColumnNames;
 	private final int[] notNullColumnTableNumbers;
 
 	private final String[] constraintOrderedTableNames;
 	private final String[][] constraintOrderedKeyColumnNames;
 
 	private final Object discriminatorValue;
 	private final String discriminatorSQLString;
 	private final DiscriminatorType discriminatorType;
 	private final String explicitDiscriminatorColumnName;
 	private final String discriminatorAlias;
 
 	// Span of the tables directly mapped by this entity and super-classes, if any
 	private final int coreTableSpan;
 	// only contains values for SecondaryTables, ie. not tables part of the "coreTableSpan"
 	private final boolean[] isNullableTable;
 
 	//INITIALIZATION:
 
 	public JoinedSubclassEntityPersister(
 			final PersistentClass persistentClass,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory,
 			final Mapping mapping) throws HibernateException {
 
 		super( persistentClass, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
 
 		// DISCRIMINATOR
 
 		if ( persistentClass.isPolymorphic() ) {
 			final Value discriminatorMapping = persistentClass.getDiscriminator();
 			if ( discriminatorMapping != null ) {
 				log.debug( "Encountered explicit discriminator mapping for joined inheritance" );
 
 				final Selectable selectable = discriminatorMapping.getColumnIterator().next();
 				if ( Formula.class.isInstance( selectable ) ) {
 					throw new MappingException( "Discriminator formulas on joined inheritance hierarchies not supported at this time" );
 				}
 				else {
 					final Column column = (Column) selectable;
 					explicitDiscriminatorColumnName = column.getQuotedName( factory.getDialect() );
 					discriminatorAlias = column.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 				}
 				discriminatorType = (DiscriminatorType) persistentClass.getDiscriminator().getType();
 				if ( persistentClass.isDiscriminatorValueNull() ) {
 					discriminatorValue = NULL_DISCRIMINATOR;
 					discriminatorSQLString = InFragment.NULL;
 				}
 				else if ( persistentClass.isDiscriminatorValueNotNull() ) {
 					discriminatorValue = NOT_NULL_DISCRIMINATOR;
 					discriminatorSQLString = InFragment.NOT_NULL;
 				}
 				else {
 					try {
 						discriminatorValue = discriminatorType.stringToObject( persistentClass.getDiscriminatorValue() );
 						discriminatorSQLString = discriminatorType.objectToSQLString( discriminatorValue, factory.getDialect() );
 					}
 					catch (ClassCastException cce) {
 						throw new MappingException("Illegal discriminator type: " + discriminatorType.getName() );
 					}
 					catch (Exception e) {
 						throw new MappingException("Could not format discriminator value to SQL string", e);
 					}
 				}
 			}
 			else {
 				explicitDiscriminatorColumnName = null;
 				discriminatorAlias = IMPLICIT_DISCRIMINATOR_ALIAS;
 				discriminatorType = StandardBasicTypes.INTEGER;
 				try {
 					discriminatorValue = persistentClass.getSubclassId();
 					discriminatorSQLString = discriminatorValue.toString();
 				}
 				catch ( Exception e ) {
 					throw new MappingException( "Could not format discriminator value to SQL string", e );
 				}
 			}
 		}
 		else {
 			explicitDiscriminatorColumnName = null;
 			discriminatorAlias = IMPLICIT_DISCRIMINATOR_ALIAS;
 			discriminatorType = StandardBasicTypes.INTEGER;
 			discriminatorValue = null;
 			discriminatorSQLString = null;
 		}
 
 		if ( optimisticLockStyle() == OptimisticLockStyle.ALL || optimisticLockStyle() == OptimisticLockStyle.DIRTY ) {
 			throw new MappingException( "optimistic-lock=all|dirty not supported for joined-subclass mappings [" + getEntityName() + "]" );
 		}
 
 		//MULTITABLES
 
 		final int idColumnSpan = getIdentifierColumnSpan();
 
 		ArrayList tables = new ArrayList();
 		ArrayList keyColumns = new ArrayList();
 		ArrayList keyColumnReaders = new ArrayList();
 		ArrayList keyColumnReaderTemplates = new ArrayList();
 		ArrayList cascadeDeletes = new ArrayList();
 		Iterator titer = persistentClass.getTableClosureIterator();
 		Iterator kiter = persistentClass.getKeyClosureIterator();
 		while ( titer.hasNext() ) {
 			Table tab = (Table) titer.next();
 			KeyValue key = (KeyValue) kiter.next();
 			String tabname = tab.getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			tables.add( tabname );
 			String[] keyCols = new String[idColumnSpan];
 			String[] keyColReaders = new String[idColumnSpan];
 			String[] keyColReaderTemplates = new String[idColumnSpan];
 			Iterator citer = key.getColumnIterator();
 			for ( int k = 0; k < idColumnSpan; k++ ) {
 				Column column = (Column) citer.next();
 				keyCols[k] = column.getQuotedName( factory.getDialect() );
 				keyColReaders[k] = column.getReadExpr( factory.getDialect() );
 				keyColReaderTemplates[k] = column.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 			}
 			keyColumns.add( keyCols );
 			keyColumnReaders.add( keyColReaders );
 			keyColumnReaderTemplates.add( keyColReaderTemplates );
 			cascadeDeletes.add( key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete() );
 		}
 
 		//Span of the tables directly mapped by this entity and super-classes, if any
 		coreTableSpan = tables.size();
 
 		isNullableTable = new boolean[persistentClass.getJoinClosureSpan()];
 
 		int tableIndex = 0;
 		Iterator joinIter = persistentClass.getJoinClosureIterator();
 		while ( joinIter.hasNext() ) {
 			Join join = (Join) joinIter.next();
 
 			isNullableTable[tableIndex++] = join.isOptional();
 
 			Table table = join.getTable();
 
 			String tableName = table.getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			tables.add( tableName );
 
 			KeyValue key = join.getKey();
 			int joinIdColumnSpan = key.getColumnSpan();
 
 			String[] keyCols = new String[joinIdColumnSpan];
 			String[] keyColReaders = new String[joinIdColumnSpan];
 			String[] keyColReaderTemplates = new String[joinIdColumnSpan];
 
 			Iterator citer = key.getColumnIterator();
 
 			for ( int k = 0; k < joinIdColumnSpan; k++ ) {
 				Column column = (Column) citer.next();
 				keyCols[k] = column.getQuotedName( factory.getDialect() );
 				keyColReaders[k] = column.getReadExpr( factory.getDialect() );
 				keyColReaderTemplates[k] = column.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 			}
 			keyColumns.add( keyCols );
 			keyColumnReaders.add( keyColReaders );
 			keyColumnReaderTemplates.add( keyColReaderTemplates );
 			cascadeDeletes.add( key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete() );
 		}
 
 		naturalOrderTableNames = ArrayHelper.toStringArray( tables );
 		naturalOrderTableKeyColumns = ArrayHelper.to2DStringArray( keyColumns );
 		naturalOrderTableKeyColumnReaders = ArrayHelper.to2DStringArray( keyColumnReaders );
 		naturalOrderTableKeyColumnReaderTemplates = ArrayHelper.to2DStringArray( keyColumnReaderTemplates );
 		naturalOrderCascadeDeleteEnabled = ArrayHelper.toBooleanArray( cascadeDeletes );
 
 		ArrayList subtables = new ArrayList();
 		ArrayList isConcretes = new ArrayList();
 		ArrayList isDeferreds = new ArrayList();
 		ArrayList isLazies = new ArrayList();
 
 		keyColumns = new ArrayList();
 		titer = persistentClass.getSubclassTableClosureIterator();
 		while ( titer.hasNext() ) {
 			Table tab = (Table) titer.next();
 			isConcretes.add( persistentClass.isClassOrSuperclassTable( tab ) );
 			isDeferreds.add( Boolean.FALSE );
 			isLazies.add( Boolean.FALSE );
 			String tabname = tab.getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			subtables.add( tabname );
 			String[] key = new String[idColumnSpan];
 			Iterator citer = tab.getPrimaryKey().getColumnIterator();
 			for ( int k = 0; k < idColumnSpan; k++ ) {
 				key[k] = ( (Column) citer.next() ).getQuotedName( factory.getDialect() );
 			}
 			keyColumns.add( key );
 		}
 
 		//Add joins
 		joinIter = persistentClass.getSubclassJoinClosureIterator();
 		while ( joinIter.hasNext() ) {
 			Join join = (Join) joinIter.next();
 
 			Table tab = join.getTable();
 
 			isConcretes.add( persistentClass.isClassOrSuperclassTable( tab ) );
 			isDeferreds.add( join.isSequentialSelect() );
 			isLazies.add( join.isLazy() );
 
 			String tabname = tab.getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			subtables.add( tabname );
 			String[] key = new String[idColumnSpan];
 			Iterator citer = tab.getPrimaryKey().getColumnIterator();
 			for ( int k = 0; k < idColumnSpan; k++ ) {
 				key[k] = ( (Column) citer.next() ).getQuotedName( factory.getDialect() );
 			}
 			keyColumns.add( key );
 		}
 
 		String[] naturalOrderSubclassTableNameClosure = ArrayHelper.toStringArray( subtables );
 		String[][] naturalOrderSubclassTableKeyColumnClosure = ArrayHelper.to2DStringArray( keyColumns );
 		isClassOrSuperclassTable = ArrayHelper.toBooleanArray( isConcretes );
 		subclassTableSequentialSelect = ArrayHelper.toBooleanArray( isDeferreds );
 		subclassTableIsLazyClosure = ArrayHelper.toBooleanArray( isLazies );
 
 		constraintOrderedTableNames = new String[naturalOrderSubclassTableNameClosure.length];
 		constraintOrderedKeyColumnNames = new String[naturalOrderSubclassTableNameClosure.length][];
 		int currentPosition = 0;
 		for ( int i = naturalOrderSubclassTableNameClosure.length - 1; i >= 0; i--, currentPosition++ ) {
 			constraintOrderedTableNames[currentPosition] = naturalOrderSubclassTableNameClosure[i];
 			constraintOrderedKeyColumnNames[currentPosition] = naturalOrderSubclassTableKeyColumnClosure[i];
 		}
 
 		/**
 		 * Suppose an entity Client extends Person, mapped to the tables CLIENT and PERSON respectively.
 		 * For the Client entity:
 		 * naturalOrderTableNames -> PERSON, CLIENT; this reflects the sequence in which the tables are 
 		 * added to the meta-data when the annotated entities are processed.
 		 * However, in some instances, for example when generating joins, the CLIENT table needs to be 
 		 * the first table as it will the driving table.
 		 * tableNames -> CLIENT, PERSON
 		 */
 
 		tableSpan = naturalOrderTableNames.length;
 		tableNames = reverse( naturalOrderTableNames, coreTableSpan );
 		tableKeyColumns = reverse( naturalOrderTableKeyColumns, coreTableSpan );
 		tableKeyColumnReaders = reverse( naturalOrderTableKeyColumnReaders, coreTableSpan );
 		tableKeyColumnReaderTemplates = reverse( naturalOrderTableKeyColumnReaderTemplates, coreTableSpan );
 		subclassTableNameClosure = reverse( naturalOrderSubclassTableNameClosure, coreTableSpan );
 		subclassTableKeyColumnClosure = reverse( naturalOrderSubclassTableKeyColumnClosure, coreTableSpan );
 
 		spaces = ArrayHelper.join(
 				tableNames,
 				ArrayHelper.toStringArray( persistentClass.getSynchronizedTables() )
 		);
 
 		// Custom sql
 		customSQLInsert = new String[tableSpan];
 		customSQLUpdate = new String[tableSpan];
 		customSQLDelete = new String[tableSpan];
 		insertCallable = new boolean[tableSpan];
 		updateCallable = new boolean[tableSpan];
 		deleteCallable = new boolean[tableSpan];
 		insertResultCheckStyles = new ExecuteUpdateResultCheckStyle[tableSpan];
 		updateResultCheckStyles = new ExecuteUpdateResultCheckStyle[tableSpan];
 		deleteResultCheckStyles = new ExecuteUpdateResultCheckStyle[tableSpan];
 
 		PersistentClass pc = persistentClass;
 		int jk = coreTableSpan - 1;
 		while ( pc != null ) {
 			customSQLInsert[jk] = pc.getCustomSQLInsert();
 			insertCallable[jk] = customSQLInsert[jk] != null && pc.isCustomInsertCallable();
 			insertResultCheckStyles[jk] = pc.getCustomSQLInsertCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault(
 					customSQLInsert[jk], insertCallable[jk]
 			)
 					: pc.getCustomSQLInsertCheckStyle();
 			customSQLUpdate[jk] = pc.getCustomSQLUpdate();
 			updateCallable[jk] = customSQLUpdate[jk] != null && pc.isCustomUpdateCallable();
 			updateResultCheckStyles[jk] = pc.getCustomSQLUpdateCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( customSQLUpdate[jk], updateCallable[jk] )
 					: pc.getCustomSQLUpdateCheckStyle();
 			customSQLDelete[jk] = pc.getCustomSQLDelete();
 			deleteCallable[jk] = customSQLDelete[jk] != null && pc.isCustomDeleteCallable();
 			deleteResultCheckStyles[jk] = pc.getCustomSQLDeleteCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( customSQLDelete[jk], deleteCallable[jk] )
 					: pc.getCustomSQLDeleteCheckStyle();
 			jk--;
 			pc = pc.getSuperclass();
 		}
 
 		if ( jk != -1 ) {
 			throw new AssertionFailure( "Tablespan does not match height of joined-subclass hiearchy." );
 		}
 
 		joinIter = persistentClass.getJoinClosureIterator();
 		int j = coreTableSpan;
 		while ( joinIter.hasNext() ) {
 			Join join = (Join) joinIter.next();
 
 			customSQLInsert[j] = join.getCustomSQLInsert();
 			insertCallable[j] = customSQLInsert[j] != null && join.isCustomInsertCallable();
 			insertResultCheckStyles[j] = join.getCustomSQLInsertCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( customSQLInsert[j], insertCallable[j] )
 					: join.getCustomSQLInsertCheckStyle();
 			customSQLUpdate[j] = join.getCustomSQLUpdate();
 			updateCallable[j] = customSQLUpdate[j] != null && join.isCustomUpdateCallable();
 			updateResultCheckStyles[j] = join.getCustomSQLUpdateCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( customSQLUpdate[j], updateCallable[j] )
 					: join.getCustomSQLUpdateCheckStyle();
 			customSQLDelete[j] = join.getCustomSQLDelete();
 			deleteCallable[j] = customSQLDelete[j] != null && join.isCustomDeleteCallable();
 			deleteResultCheckStyles[j] = join.getCustomSQLDeleteCheckStyle() == null
 					? ExecuteUpdateResultCheckStyle.determineDefault( customSQLDelete[j], deleteCallable[j] )
 					: join.getCustomSQLDeleteCheckStyle();
 			j++;
 		}
 
 		// PROPERTIES
 		int hydrateSpan = getPropertySpan();
 		naturalOrderPropertyTableNumbers = new int[hydrateSpan];
 		propertyTableNumbers = new int[hydrateSpan];
 		Iterator iter = persistentClass.getPropertyClosureIterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			String tabname = prop.getValue().getTable().getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			propertyTableNumbers[i] = getTableId( tabname, tableNames );
 			naturalOrderPropertyTableNumbers[i] = getTableId( tabname, naturalOrderTableNames );
 			i++;
 		}
 
 		// subclass closure properties
 
 		//TODO: code duplication with SingleTableEntityPersister
 
 		ArrayList columnTableNumbers = new ArrayList();
 		ArrayList formulaTableNumbers = new ArrayList();
 		ArrayList propTableNumbers = new ArrayList();
 
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			Table tab = prop.getValue().getTable();
 			String tabname = tab.getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			Integer tabnum = getTableId( tabname, subclassTableNameClosure );
 			propTableNumbers.add( tabnum );
 
 			Iterator citer = prop.getColumnIterator();
 			while ( citer.hasNext() ) {
 				Selectable thing = (Selectable) citer.next();
 				if ( thing.isFormula() ) {
 					formulaTableNumbers.add( tabnum );
 				}
 				else {
 					columnTableNumbers.add( tabnum );
 				}
 			}
 
 		}
 
 		subclassColumnTableNumberClosure = ArrayHelper.toIntArray( columnTableNumbers );
 		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray( propTableNumbers );
 		subclassFormulaTableNumberClosure = ArrayHelper.toIntArray( formulaTableNumbers );
 
 		// SUBCLASSES
 
 		int subclassSpan = persistentClass.getSubclassSpan() + 1;
 		subclassClosure = new String[subclassSpan];
 		subclassClosure[subclassSpan - 1] = getEntityName();
 		if ( persistentClass.isPolymorphic() ) {
 			subclassesByDiscriminatorValue.put( discriminatorValue, getEntityName() );
 			discriminatorValues = new String[subclassSpan];
 			discriminatorValues[subclassSpan - 1] = discriminatorSQLString;
 			notNullColumnTableNumbers = new int[subclassSpan];
 			final int id = getTableId(
 					persistentClass.getTable().getQualifiedName(
 							factory.getDialect(),
 							factory.getSettings().getDefaultCatalogName(),
 							factory.getSettings().getDefaultSchemaName()
 					),
 					subclassTableNameClosure
 			);
 			notNullColumnTableNumbers[subclassSpan - 1] = id;
 			notNullColumnNames = new String[subclassSpan];
 			notNullColumnNames[subclassSpan - 1] = subclassTableKeyColumnClosure[id][0]; //( (Column) model.getTable().getPrimaryKey().getColumnIterator().next() ).getName();
 		}
 		else {
 			discriminatorValues = null;
 			notNullColumnTableNumbers = null;
 			notNullColumnNames = null;
 		}
 
 		iter = persistentClass.getSubclassIterator();
 		int k = 0;
 		while ( iter.hasNext() ) {
 			Subclass sc = (Subclass) iter.next();
 			subclassClosure[k] = sc.getEntityName();
 			try {
 				if ( persistentClass.isPolymorphic() ) {
 					final Object discriminatorValue;
 					if ( explicitDiscriminatorColumnName != null ) {
 						if ( sc.isDiscriminatorValueNull() ) {
 							discriminatorValue = NULL_DISCRIMINATOR;
 						}
 						else if ( sc.isDiscriminatorValueNotNull() ) {
 							discriminatorValue = NOT_NULL_DISCRIMINATOR;
 						}
 						else {
 							try {
 								discriminatorValue = discriminatorType.stringToObject( sc.getDiscriminatorValue() );
 							}
 							catch (ClassCastException cce) {
 								throw new MappingException( "Illegal discriminator type: " + discriminatorType.getName() );
 							}
 							catch (Exception e) {
 								throw new MappingException( "Could not format discriminator value to SQL string", e);
 							}
 						}
 					}
 					else {
 						// we now use subclass ids that are consistent across all
 						// persisters for a class hierarchy, so that the use of
 						// "foo.class = Bar" works in HQL
 						discriminatorValue = sc.getSubclassId();
 					}
 
 					subclassesByDiscriminatorValue.put( discriminatorValue, sc.getEntityName() );
 					discriminatorValues[k] = discriminatorValue.toString();
 					int id = getTableId(
 							sc.getTable().getQualifiedName(
 									factory.getDialect(),
 									factory.getSettings().getDefaultCatalogName(),
 									factory.getSettings().getDefaultSchemaName()
 							),
 							subclassTableNameClosure
 					);
 					notNullColumnTableNumbers[k] = id;
 					notNullColumnNames[k] = subclassTableKeyColumnClosure[id][0]; //( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();
 				}
 			}
 			catch ( Exception e ) {
 				throw new MappingException( "Error parsing discriminator value", e );
 			}
 			k++;
 		}
 
 		subclassNamesBySubclassTable = buildSubclassNamesBySubclassTableMapping( persistentClass, factory );
 
 		initLockers();
 
 		initSubclassPropertyAliasesMap( persistentClass );
 
 		postConstruct( mapping );
 
 	}
 
 
 	/**
 	 * Used to hold the name of subclasses that each "subclass table" is part of.  For example, given a hierarchy like:
 	 * {@code JoinedEntity <- JoinedEntitySubclass <- JoinedEntitySubSubclass}..
 	 * <p/>
 	 * For the persister for JoinedEntity, we'd have:
 	 * <pre>
 	 *     subclassClosure[0] = "JoinedEntitySubSubclass"
 	 *     subclassClosure[1] = "JoinedEntitySubclass"
 	 *     subclassClosure[2] = "JoinedEntity"
 	 *
 	 *     subclassTableNameClosure[0] = "T_JoinedEntity"
 	 *     subclassTableNameClosure[1] = "T_JoinedEntitySubclass"
 	 *     subclassTableNameClosure[2] = "T_JoinedEntitySubSubclass"
 	 *
 	 *     subclassNameClosureBySubclassTable[0] = ["JoinedEntitySubSubclass", "JoinedEntitySubclass"]
 	 *     subclassNameClosureBySubclassTable[1] = ["JoinedEntitySubSubclass"]
 	 * </pre>
 	 * Note that there are only 2 entries in subclassNameClosureBySubclassTable.  That is because there are really only
 	 * 2 tables here that make up the subclass mapping, the others make up the class/superclass table mappings.  We
 	 * do not need to account for those here.  The "offset" is defined by the value of {@link #getTableSpan()}.
 	 * Therefore the corresponding row in subclassNameClosureBySubclassTable for a given row in subclassTableNameClosure
 	 * is calculated as {@code subclassTableNameClosureIndex - getTableSpan()}.
 	 * <p/>
 	 * As we consider each subclass table we can look into this array based on the subclass table's index and see
 	 * which subclasses would require it to be included.  E.g., given {@code TREAT( x AS JoinedEntitySubSubclass )},
 	 * when trying to decide whether to include join to "T_JoinedEntitySubclass" (subclassTableNameClosureIndex = 1),
 	 * we'd look at {@code subclassNameClosureBySubclassTable[0]} and see if the TREAT-AS subclass name is included in
 	 * its values.  Since {@code subclassNameClosureBySubclassTable[1]} includes "JoinedEntitySubSubclass", we'd
 	 * consider it included.
 	 * <p/>
 	 * {@link #subclassTableNameClosure} also accounts for secondary tables and we properly handle those as we
 	 * build the subclassNamesBySubclassTable array and they are therefore properly handled when we use it
 	 */
 	private final String[][] subclassNamesBySubclassTable;
 
 	/**
 	 * Essentially we are building a mapping that we can later use to determine whether a given "subclass table"
 	 * should be included in joins when JPA TREAT-AS is used.
 	 *
 	 * @param persistentClass
 	 * @param factory
 	 * @return
 	 */
 	private String[][] buildSubclassNamesBySubclassTableMapping(PersistentClass persistentClass, SessionFactoryImplementor factory) {
 		// this value represents the number of subclasses (and not the class itself)
 		final int numberOfSubclassTables = subclassTableNameClosure.length - coreTableSpan;
 		if ( numberOfSubclassTables == 0 ) {
 			return new String[0][];
 		}
 
 		final String[][] mapping = new String[numberOfSubclassTables][];
 		processPersistentClassHierarchy( persistentClass, true, factory, mapping );
 		return mapping;
 	}
 
 	private Set<String> processPersistentClassHierarchy(
 			PersistentClass persistentClass,
 			boolean isBase,
 			SessionFactoryImplementor factory,
 			String[][] mapping) {
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// collect all the class names that indicate that the "main table" of the given PersistentClass should be
 		// included when one of the collected class names is used in TREAT
 		final Set<String> classNames = new HashSet<String>();
 
 		final Iterator itr = persistentClass.getDirectSubclasses();
 		while ( itr.hasNext() ) {
 			final Subclass subclass = (Subclass) itr.next();
 			final Set<String> subclassSubclassNames = processPersistentClassHierarchy(
 					subclass,
 					false,
 					factory,
 					mapping
 			);
 			classNames.addAll( subclassSubclassNames );
 		}
 
 		classNames.add( persistentClass.getEntityName() );
 
 		if ( ! isBase ) {
 			MappedSuperclass msc = persistentClass.getSuperMappedSuperclass();
 			while ( msc != null ) {
 				classNames.add( msc.getMappedClass().getName() );
 				msc = msc.getSuperMappedSuperclass();
 			}
 
 			associateSubclassNamesToSubclassTableIndexes( persistentClass, classNames, mapping, factory );
 		}
 
 		return classNames;
 	}
 
 	private void associateSubclassNamesToSubclassTableIndexes(
 			PersistentClass persistentClass,
 			Set<String> classNames,
 			String[][] mapping,
 			SessionFactoryImplementor factory) {
 
 		final String tableName = persistentClass.getTable().getQualifiedName(
 				factory.getDialect(),
 				factory.getSettings().getDefaultCatalogName(),
 				factory.getSettings().getDefaultSchemaName()
 		);
 
 		associateSubclassNamesToSubclassTableIndex( tableName, classNames, mapping );
 
 		Iterator itr = persistentClass.getJoinIterator();
 		while ( itr.hasNext() ) {
 			final Join join = (Join) itr.next();
 			final String secondaryTableName = join.getTable().getQualifiedName(
 					factory.getDialect(),
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName()
 			);
 			associateSubclassNamesToSubclassTableIndex( secondaryTableName, classNames, mapping );
 		}
 	}
 
 	private void associateSubclassNamesToSubclassTableIndex(
 			String tableName,
 			Set<String> classNames,
 			String[][] mapping) {
 		// find the table's entry in the subclassTableNameClosure array
 		boolean found = false;
 		for ( int i = 0; i < subclassTableNameClosure.length; i++ ) {
 			if ( subclassTableNameClosure[i].equals( tableName ) ) {
 				found = true;
 				final int index = i - coreTableSpan;
 				if ( index < 0 || index >= mapping.length ) {
 					throw new IllegalStateException(
 							String.format(
 									"Encountered 'subclass table index' [%s] was outside expected range ( [%s] < i < [%s] )",
 									index,
 									0,
 									mapping.length
 							)
 					);
 				}
 				mapping[index] = classNames.toArray( new String[ classNames.size() ] );
 				break;
 			}
 		}
 		if ( !found ) {
 			throw new IllegalStateException(
 					String.format(
 							"Was unable to locate subclass table [%s] in 'subclassTableNameClosure'",
 							tableName
 					)
 			);
 		}
 	}
 
-	public JoinedSubclassEntityPersister(
-			final EntityBinding entityBinding,
-			final EntityRegionAccessStrategy cacheAccessStrategy,
-			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
-			final SessionFactoryImplementor factory,
-			final Mapping mapping) throws HibernateException {
-		super( entityBinding, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
-		// TODO: implement!!! initializing final fields to null to make compiler happy
-		tableSpan = -1;
-		tableNames = null;
-		naturalOrderTableNames = null;
-		tableKeyColumns = null;
-		tableKeyColumnReaders = null;
-		tableKeyColumnReaderTemplates = null;
-		naturalOrderTableKeyColumns = null;
-		naturalOrderTableKeyColumnReaders = null;
-		naturalOrderTableKeyColumnReaderTemplates = null;
-		naturalOrderCascadeDeleteEnabled = null;
-		spaces = null;
-		subclassClosure = null;
-		subclassTableNameClosure = null;
-		subclassTableKeyColumnClosure = null;
-		isClassOrSuperclassTable = null;
-		naturalOrderPropertyTableNumbers = null;
-		propertyTableNumbers = null;
-		subclassPropertyTableNumberClosure = null;
-		subclassColumnTableNumberClosure = null;
-		subclassFormulaTableNumberClosure = null;
-		subclassTableSequentialSelect = null;
-		subclassTableIsLazyClosure = null;
-		discriminatorValues = null;
-		notNullColumnNames = null;
-		notNullColumnTableNumbers = null;
-		constraintOrderedTableNames = null;
-		constraintOrderedKeyColumnNames = null;
-		discriminatorValue = null;
-		discriminatorSQLString = null;
-		discriminatorType = StandardBasicTypes.INTEGER;
-		explicitDiscriminatorColumnName = null;
-		discriminatorAlias = IMPLICIT_DISCRIMINATOR_ALIAS;
-		coreTableSpan = -1;
-		isNullableTable = null;
-		subclassNamesBySubclassTable = null;
-	}
-
 	protected boolean isNullableTable(int j) {
 		if ( j < coreTableSpan ) {
 			return false;
 		}
 		return isNullableTable[j - coreTableSpan];
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return subclassTableSequentialSelect[j] && !isClassOrSuperclassTable[j];
 	}
 
 	/*public void postInstantiate() throws MappingException {
 		super.postInstantiate();
 		//TODO: other lock modes?
 		loader = createEntityLoader(LockMode.NONE, CollectionHelper.EMPTY_MAP);
 	}*/
 
 	public String getSubclassPropertyTableName(int i) {
 		return subclassTableNameClosure[subclassPropertyTableNumberClosure[i]];
 	}
 
 	public Type getDiscriminatorType() {
 		return discriminatorType;
 	}
 
 	public Object getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	@Override
 	public String getDiscriminatorSQLValue() {
 		return discriminatorSQLString;
 	}
 
 	@Override
 	public String getDiscriminatorColumnName() {
 		return explicitDiscriminatorColumnName == null
 				? super.getDiscriminatorColumnName()
 				: explicitDiscriminatorColumnName;
 	}
 
 	@Override
 	public String getDiscriminatorColumnReaders() {
 		return getDiscriminatorColumnName();
 	}
 
 	@Override
 	public String getDiscriminatorColumnReaderTemplate() {
 		return getDiscriminatorColumnName();
 	}
 
 	protected String getDiscriminatorAlias() {
 		return discriminatorAlias;
 	}
 
 	public String getSubclassForDiscriminatorValue(Object value) {
 		return (String) subclassesByDiscriminatorValue.get( value );
 	}
 
 	@Override
 	protected void addDiscriminatorToInsert(Insert insert) {
 		if ( explicitDiscriminatorColumnName != null ) {
 			insert.addColumn( explicitDiscriminatorColumnName, getDiscriminatorSQLValue() );
 		}
 	}
 
 	public Serializable[] getPropertySpaces() {
 		return spaces; // don't need subclass tables, because they can't appear in conditions
 	}
 
 
 	protected String getTableName(int j) {
 		return naturalOrderTableNames[j];
 	}
 
 	protected String[] getKeyColumns(int j) {
 		return naturalOrderTableKeyColumns[j];
 	}
 
 	protected boolean isTableCascadeDeleteEnabled(int j) {
 		return naturalOrderCascadeDeleteEnabled[j];
 	}
 
 	protected boolean isPropertyOfTable(int property, int j) {
 		return naturalOrderPropertyTableNumbers[property] == j;
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	/*public Object load(Serializable id,	Object optionalObject, LockMode lockMode, SessionImplementor session)
 	throws HibernateException {
 
 		if ( log.isTraceEnabled() ) log.trace( "Materializing entity: " + MessageHelper.infoString(this, id) );
 
 		final UniqueEntityLoader loader = hasQueryLoader() ?
 				getQueryLoader() :
 				this.loader;
 		try {
 
 			final Object result = loader.load(id, optionalObject, session);
 
 			if (result!=null) lock(id, getVersion(result), result, lockMode, session);
 
 			return result;
 
 		}
 		catch (SQLException sqle) {
 			throw new JDBCException( "could not load by id: " +  MessageHelper.infoString(this, id), sqle );
 		}
 	}*/
 	private static final void reverse(Object[] objects, int len) {
 		Object[] temp = new Object[len];
 		for ( int i = 0; i < len; i++ ) {
 			temp[i] = objects[len - i - 1];
 		}
 		for ( int i = 0; i < len; i++ ) {
 			objects[i] = temp[i];
 		}
 	}
 
 
 	/**
 	 * Reverse the first n elements of the incoming array
 	 *
 	 * @param objects
 	 * @param n
 	 *
 	 * @return New array with the first n elements in reversed order
 	 */
 	private static String[] reverse(String[] objects, int n) {
 
 		int size = objects.length;
 		String[] temp = new String[size];
 
 		for ( int i = 0; i < n; i++ ) {
 			temp[i] = objects[n - i - 1];
 		}
 
 		for ( int i = n; i < size; i++ ) {
 			temp[i] = objects[i];
 		}
 
 		return temp;
 	}
 
 	/**
 	 * Reverse the first n elements of the incoming array
 	 *
 	 * @param objects
 	 * @param n
 	 *
 	 * @return New array with the first n elements in reversed order
 	 */
 	private static String[][] reverse(String[][] objects, int n) {
 		int size = objects.length;
 		String[][] temp = new String[size][];
 		for ( int i = 0; i < n; i++ ) {
 			temp[i] = objects[n - i - 1];
 		}
 
 		for ( int i = n; i < size; i++ ) {
 			temp[i] = objects[i];
 		}
 
 		return temp;
 	}
 
 
 	public String fromTableFragment(String alias) {
 		return getTableName() + ' ' + alias;
 	}
 
 	public String getTableName() {
 		return tableNames[0];
 	}
 
 	public void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {
 		if ( hasSubclasses() ) {
 			if ( explicitDiscriminatorColumnName == null ) {
 				select.setExtraSelectList( discriminatorFragment( name ), getDiscriminatorAlias() );
 			}
 			else {
 				select.addColumn( name, explicitDiscriminatorColumnName, discriminatorAlias );
 			}
 		}
 	}
 
 	private CaseFragment discriminatorFragment(String alias) {
 		CaseFragment cases = getFactory().getDialect().createCaseFragment();
 
 		for ( int i = 0; i < discriminatorValues.length; i++ ) {
 			cases.addWhenColumnNotNull(
 					generateTableAlias( alias, notNullColumnTableNumbers[i] ),
 					notNullColumnNames[i],
 					discriminatorValues[i]
 			);
 		}
 
 		return cases;
 	}
 
 	@Override
 	public String filterFragment(String alias) {
 		return hasWhere()
 				? " and " + getSQLWhereString( generateFilterConditionAlias( alias ) )
 				: "";
 	}
 
 	@Override
 	public String filterFragment(String alias, Set<String> treatAsDeclarations) {
 		return filterFragment( alias );
 	}
 
 	public String generateFilterConditionAlias(String rootAlias) {
 		return generateTableAlias( rootAlias, tableSpan - 1 );
 	}
 
 	public String[] getIdentifierColumnNames() {
 		return tableKeyColumns[0];
 	}
 
 	public String[] getIdentifierColumnReaderTemplates() {
 		return tableKeyColumnReaderTemplates[0];
 	}
 
 	public String[] getIdentifierColumnReaders() {
 		return tableKeyColumnReaders[0];
 	}
 
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		if ( ENTITY_CLASS.equals( propertyName ) ) {
 			// This doesn't actually seem to work but it *might*
 			// work on some dbs. Also it doesn't work if there
 			// are multiple columns of results because it
 			// is not accounting for the suffix:
 			// return new String[] { getDiscriminatorColumnName() };
 
 			return new String[] { discriminatorFragment( alias ).toFragmentString() };
 		}
 		else {
 			return super.toColumns( alias, propertyName );
 		}
 	}
 
 	protected int[] getPropertyTableNumbersInSelect() {
 		return propertyTableNumbers;
 	}
 
 	protected int getSubclassPropertyTableNumber(int i) {
 		return subclassPropertyTableNumberClosure[i];
 	}
 
 	public int getTableSpan() {
 		return tableSpan;
 	}
 
 	public boolean isMultiTable() {
 		return true;
 	}
 
 	protected int[] getSubclassColumnTableNumberClosure() {
 		return subclassColumnTableNumberClosure;
 	}
 
 	protected int[] getSubclassFormulaTableNumberClosure() {
 		return subclassFormulaTableNumberClosure;
 	}
 
 	protected int[] getPropertyTableNumbers() {
 		return naturalOrderPropertyTableNumbers;
 	}
 
 	protected String[] getSubclassTableKeyColumns(int j) {
 		return subclassTableKeyColumnClosure[j];
 	}
 
 	public String getSubclassTableName(int j) {
 		return subclassTableNameClosure[j];
 	}
 
 	public int getSubclassTableSpan() {
 		return subclassTableNameClosure.length;
 	}
 
 	protected boolean isSubclassTableLazy(int j) {
 		return subclassTableIsLazyClosure[j];
 	}
 
 
 	protected boolean isClassOrSuperclassTable(int j) {
 		return isClassOrSuperclassTable[j];
 	}
 
 	@Override
 	protected boolean isSubclassTableIndicatedByTreatAsDeclarations(
 			int subclassTableNumber,
 			Set<String> treatAsDeclarations) {
 		if ( treatAsDeclarations == null || treatAsDeclarations.isEmpty() ) {
 			return false;
 		}
 
 		final String[] inclusionSubclassNameClosure = getSubclassNameClosureBySubclassTable( subclassTableNumber );
 
 		// NOTE : we assume the entire hierarchy is joined-subclass here
 		for ( String subclassName : treatAsDeclarations ) {
 			for ( String inclusionSubclassName : inclusionSubclassNameClosure ) {
 				if ( inclusionSubclassName.equals( subclassName ) ) {
 					return true;
 				}
 			}
 		}
 
 		return false;
 	}
 
 	private String[] getSubclassNameClosureBySubclassTable(int subclassTableNumber) {
 		final int index = subclassTableNumber - getTableSpan();
 
 		if ( index > subclassNamesBySubclassTable.length ) {
 			throw new IllegalArgumentException(
 					"Given subclass table number is outside expected range [" + subclassNamesBySubclassTable.length
 							+ "] as defined by subclassTableNameClosure/subclassClosure"
 			);
 		}
 
 		return subclassNamesBySubclassTable[index];
 	}
 
 	public String getPropertyTableName(String propertyName) {
 		Integer index = getEntityMetamodel().getPropertyIndexOrNull( propertyName );
 		if ( index == null ) {
 			return null;
 		}
 		return tableNames[propertyTableNumbers[index]];
 	}
 
 	public String[] getConstraintOrderedTableNameClosure() {
 		return constraintOrderedTableNames;
 	}
 
 	public String[][] getContraintOrderedTableKeyColumnClosure() {
 		return constraintOrderedKeyColumnNames;
 	}
 
 	public String getRootTableName() {
 		return naturalOrderTableNames[0];
 	}
 
 	public String getRootTableAlias(String drivingAlias) {
 		return generateTableAlias( drivingAlias, getTableId( getRootTableName(), tableNames ) );
 	}
 
 	public Declarer getSubclassPropertyDeclarer(String propertyPath) {
 		if ( "class".equals( propertyPath ) ) {
 			// special case where we need to force include all subclass joins
 			return Declarer.SUBCLASS;
 		}
 		return super.getSubclassPropertyDeclarer( propertyPath );
 	}
 
 	@Override
 	public int determineTableNumberForColumn(String columnName) {
 		// HHH-7630: In case the naturalOrder/identifier column is explicitly given in the ordering, check here.
 		for ( int i = 0, max = naturalOrderTableKeyColumns.length; i < max; i++ ) {
 			final String[] keyColumns = naturalOrderTableKeyColumns[i];
 			if ( ArrayHelper.contains( keyColumns, columnName ) ) {
 				return naturalOrderPropertyTableNumbers[i];
 			}
 		}
 		
 		final String[] subclassColumnNameClosure = getSubclassColumnClosure();
 		for ( int i = 0, max = subclassColumnNameClosure.length; i < max; i++ ) {
 			final boolean quoted = subclassColumnNameClosure[i].startsWith( "\"" )
 					&& subclassColumnNameClosure[i].endsWith( "\"" );
 			if ( quoted ) {
 				if ( subclassColumnNameClosure[i].equals( columnName ) ) {
 					return getSubclassColumnTableNumberClosure()[i];
 				}
 			}
 			else {
 				if ( subclassColumnNameClosure[i].equalsIgnoreCase( columnName ) ) {
 					return getSubclassColumnTableNumberClosure()[i];
 				}
 			}
 		}
 		throw new HibernateException( "Could not locate table which owns column [" + columnName + "] referenced in order-by mapping" );
 	}
 
 
 	@Override
 	public FilterAliasGenerator getFilterAliasGenerator(String rootAlias) {
 		return new DynamicFilterAliasGenerator(subclassTableNameClosure, rootAlias);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/SingleTableEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/SingleTableEntityPersister.java
index 8196261aaa..0d9ed53e2d 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/SingleTableEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/SingleTableEntityPersister.java
@@ -1,1105 +1,823 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.entity;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.DynamicFilterAliasGenerator;
 import org.hibernate.internal.FilterAliasGenerator;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Formula;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.Value;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.SimpleValueBinding;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
-import org.hibernate.metamodel.relational.DerivedValue;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.TableSpecification;
 import org.hibernate.sql.InFragment;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.DiscriminatorType;
 import org.hibernate.type.Type;
 
 /**
  * The default implementation of the <tt>EntityPersister</tt> interface.
  * Implements the "table-per-class-hierarchy" or "roll-up" mapping strategy
  * for an entity class and its inheritence hierarchy.  This is implemented
  * as a single table holding all classes in the hierarchy with a discrimator
  * column used to determine which concrete class is referenced.
  *
  * @author Gavin King
  */
 public class SingleTableEntityPersister extends AbstractEntityPersister {
 
 	// the class hierarchy structure
 	private final int joinSpan;
 	private final String[] qualifiedTableNames;
 	private final boolean[] isInverseTable;
 	private final boolean[] isNullableTable;
 	private final String[][] keyColumnNames;
 	private final boolean[] cascadeDeleteEnabled;
 	private final boolean hasSequentialSelects;
 	
 	private final String[] spaces;
 
 	private final String[] subclassClosure;
 
 	private final String[] subclassTableNameClosure;
 	private final boolean[] subclassTableIsLazyClosure;
 	private final boolean[] isInverseSubclassTable;
 	private final boolean[] isNullableSubclassTable;
 	private final boolean[] subclassTableSequentialSelect;
 	private final String[][] subclassTableKeyColumnClosure;
 	private final boolean[] isClassOrSuperclassTable;
 
 	// properties of this class, including inherited properties
 	private final int[] propertyTableNumbers;
 
 	// the closure of all columns used by the entire hierarchy including
 	// subclasses and superclasses of this class
 	private final int[] subclassPropertyTableNumberClosure;
 
 	private final int[] subclassColumnTableNumberClosure;
 	private final int[] subclassFormulaTableNumberClosure;
 
 	// discriminator column
 	private final Map subclassesByDiscriminatorValue = new HashMap();
 	private final boolean forceDiscriminator;
 	private final String discriminatorColumnName;
 	private final String discriminatorColumnReaders;
 	private final String discriminatorColumnReaderTemplate;
 	private final String discriminatorFormula;
 	private final String discriminatorFormulaTemplate;
 	private final String discriminatorAlias;
 	private final Type discriminatorType;
 	private final Object discriminatorValue;
 	private final String discriminatorSQLValue;
 	private final boolean discriminatorInsertable;
 
 	private final String[] constraintOrderedTableNames;
 	private final String[][] constraintOrderedKeyColumnNames;
 
 	//private final Map propertyTableNumbersByName = new HashMap();
 	private final Map propertyTableNumbersByNameAndSubclass = new HashMap();
 	
 	private final Map sequentialSelectStringsByEntityName = new HashMap();
 
 	private static final Object NULL_DISCRIMINATOR = new MarkerObject("<null discriminator>");
 	private static final Object NOT_NULL_DISCRIMINATOR = new MarkerObject("<not null discriminator>");
 	private static final String NULL_STRING = "null";
 	private static final String NOT_NULL_STRING = "not null";
 
 	//INITIALIZATION:
 
 	public SingleTableEntityPersister(
 			final PersistentClass persistentClass, 
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory,
 			final Mapping mapping) throws HibernateException {
 
 		super( persistentClass, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
 
 		// CLASS + TABLE
 
 		joinSpan = persistentClass.getJoinClosureSpan()+1;
 		qualifiedTableNames = new String[joinSpan];
 		isInverseTable = new boolean[joinSpan];
 		isNullableTable = new boolean[joinSpan];
 		keyColumnNames = new String[joinSpan][];
 		final Table table = persistentClass.getRootTable();
 		qualifiedTableNames[0] = table.getQualifiedName( 
 				factory.getDialect(), 
 				factory.getSettings().getDefaultCatalogName(), 
 				factory.getSettings().getDefaultSchemaName() 
 		);
 		isInverseTable[0] = false;
 		isNullableTable[0] = false;
 		keyColumnNames[0] = getIdentifierColumnNames();
 		cascadeDeleteEnabled = new boolean[joinSpan];
 
 		// Custom sql
 		customSQLInsert = new String[joinSpan];
 		customSQLUpdate = new String[joinSpan];
 		customSQLDelete = new String[joinSpan];
 		insertCallable = new boolean[joinSpan];
 		updateCallable = new boolean[joinSpan];
 		deleteCallable = new boolean[joinSpan];
 		insertResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
 		updateResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
 		deleteResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
 
 		customSQLInsert[0] = persistentClass.getCustomSQLInsert();
 		insertCallable[0] = customSQLInsert[0] != null && persistentClass.isCustomInsertCallable();
 		insertResultCheckStyles[0] = persistentClass.getCustomSQLInsertCheckStyle() == null
 									  ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLInsert[0], insertCallable[0] )
 									  : persistentClass.getCustomSQLInsertCheckStyle();
 		customSQLUpdate[0] = persistentClass.getCustomSQLUpdate();
 		updateCallable[0] = customSQLUpdate[0] != null && persistentClass.isCustomUpdateCallable();
 		updateResultCheckStyles[0] = persistentClass.getCustomSQLUpdateCheckStyle() == null
 									  ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLUpdate[0], updateCallable[0] )
 									  : persistentClass.getCustomSQLUpdateCheckStyle();
 		customSQLDelete[0] = persistentClass.getCustomSQLDelete();
 		deleteCallable[0] = customSQLDelete[0] != null && persistentClass.isCustomDeleteCallable();
 		deleteResultCheckStyles[0] = persistentClass.getCustomSQLDeleteCheckStyle() == null
 									  ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLDelete[0], deleteCallable[0] )
 									  : persistentClass.getCustomSQLDeleteCheckStyle();
 
 		// JOINS
 
 		Iterator joinIter = persistentClass.getJoinClosureIterator();
 		int j = 1;
 		while ( joinIter.hasNext() ) {
 			Join join = (Join) joinIter.next();
 			qualifiedTableNames[j] = join.getTable().getQualifiedName( 
 					factory.getDialect(), 
 					factory.getSettings().getDefaultCatalogName(), 
 					factory.getSettings().getDefaultSchemaName() 
 			);
 			isInverseTable[j] = join.isInverse();
 			isNullableTable[j] = join.isOptional();
 			cascadeDeleteEnabled[j] = join.getKey().isCascadeDeleteEnabled() && 
 				factory.getDialect().supportsCascadeDelete();
 
 			customSQLInsert[j] = join.getCustomSQLInsert();
 			insertCallable[j] = customSQLInsert[j] != null && join.isCustomInsertCallable();
 			insertResultCheckStyles[j] = join.getCustomSQLInsertCheckStyle() == null
 			                              ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLInsert[j], insertCallable[j] )
 		                                  : join.getCustomSQLInsertCheckStyle();
 			customSQLUpdate[j] = join.getCustomSQLUpdate();
 			updateCallable[j] = customSQLUpdate[j] != null && join.isCustomUpdateCallable();
 			updateResultCheckStyles[j] = join.getCustomSQLUpdateCheckStyle() == null
 			                              ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLUpdate[j], updateCallable[j] )
 		                                  : join.getCustomSQLUpdateCheckStyle();
 			customSQLDelete[j] = join.getCustomSQLDelete();
 			deleteCallable[j] = customSQLDelete[j] != null && join.isCustomDeleteCallable();
 			deleteResultCheckStyles[j] = join.getCustomSQLDeleteCheckStyle() == null
 			                              ? ExecuteUpdateResultCheckStyle.determineDefault( customSQLDelete[j], deleteCallable[j] )
 		                                  : join.getCustomSQLDeleteCheckStyle();
 
 			Iterator iter = join.getKey().getColumnIterator();
 			keyColumnNames[j] = new String[ join.getKey().getColumnSpan() ];
 			int i = 0;
 			while ( iter.hasNext() ) {
 				Column col = (Column) iter.next();
 				keyColumnNames[j][i++] = col.getQuotedName( factory.getDialect() );
 			}
 
 			j++;
 		}
 
 		constraintOrderedTableNames = new String[qualifiedTableNames.length];
 		constraintOrderedKeyColumnNames = new String[qualifiedTableNames.length][];
 		for ( int i = qualifiedTableNames.length - 1, position = 0; i >= 0; i--, position++ ) {
 			constraintOrderedTableNames[position] = qualifiedTableNames[i];
 			constraintOrderedKeyColumnNames[position] = keyColumnNames[i];
 		}
 
 		spaces = ArrayHelper.join(
 				qualifiedTableNames, 
 				ArrayHelper.toStringArray( persistentClass.getSynchronizedTables() )
 		);
 		
 		final boolean lazyAvailable = isInstrumented();
 
 		boolean hasDeferred = false;
 		ArrayList subclassTables = new ArrayList();
 		ArrayList joinKeyColumns = new ArrayList();
 		ArrayList<Boolean> isConcretes = new ArrayList<Boolean>();
 		ArrayList<Boolean> isDeferreds = new ArrayList<Boolean>();
 		ArrayList<Boolean> isInverses = new ArrayList<Boolean>();
 		ArrayList<Boolean> isNullables = new ArrayList<Boolean>();
 		ArrayList<Boolean> isLazies = new ArrayList<Boolean>();
 		subclassTables.add( qualifiedTableNames[0] );
 		joinKeyColumns.add( getIdentifierColumnNames() );
 		isConcretes.add(Boolean.TRUE);
 		isDeferreds.add(Boolean.FALSE);
 		isInverses.add(Boolean.FALSE);
 		isNullables.add(Boolean.FALSE);
 		isLazies.add(Boolean.FALSE);
 		joinIter = persistentClass.getSubclassJoinClosureIterator();
 		while ( joinIter.hasNext() ) {
 			Join join = (Join) joinIter.next();
 			isConcretes.add( persistentClass.isClassOrSuperclassJoin(join) );
 			isDeferreds.add( join.isSequentialSelect() );
 			isInverses.add( join.isInverse() );
 			isNullables.add( join.isOptional() );
 			isLazies.add( lazyAvailable && join.isLazy() );
 			if ( join.isSequentialSelect() && !persistentClass.isClassOrSuperclassJoin(join) ) hasDeferred = true;
 			subclassTables.add( join.getTable().getQualifiedName( 
 					factory.getDialect(), 
 					factory.getSettings().getDefaultCatalogName(), 
 					factory.getSettings().getDefaultSchemaName() 
 			) );
 			Iterator iter = join.getKey().getColumnIterator();
 			String[] keyCols = new String[ join.getKey().getColumnSpan() ];
 			int i = 0;
 			while ( iter.hasNext() ) {
 				Column col = (Column) iter.next();
 				keyCols[i++] = col.getQuotedName( factory.getDialect() );
 			}
 			joinKeyColumns.add(keyCols);
 		}
 		
 		subclassTableSequentialSelect = ArrayHelper.toBooleanArray(isDeferreds);
 		subclassTableNameClosure = ArrayHelper.toStringArray(subclassTables);
 		subclassTableIsLazyClosure = ArrayHelper.toBooleanArray(isLazies);
 		subclassTableKeyColumnClosure = ArrayHelper.to2DStringArray( joinKeyColumns );
 		isClassOrSuperclassTable = ArrayHelper.toBooleanArray(isConcretes);
 		isInverseSubclassTable = ArrayHelper.toBooleanArray(isInverses);
 		isNullableSubclassTable = ArrayHelper.toBooleanArray(isNullables);
 		hasSequentialSelects = hasDeferred;
 
 		// DISCRIMINATOR
 
 		if ( persistentClass.isPolymorphic() ) {
 			Value discrimValue = persistentClass.getDiscriminator();
 			if (discrimValue==null) {
 				throw new MappingException("discriminator mapping required for single table polymorphic persistence");
 			}
 			forceDiscriminator = persistentClass.isForceDiscriminator();
 			Selectable selectable = (Selectable) discrimValue.getColumnIterator().next();
 			if ( discrimValue.hasFormula() ) {
 				Formula formula = (Formula) selectable;
 				discriminatorFormula = formula.getFormula();
 				discriminatorFormulaTemplate = formula.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				discriminatorColumnName = null;
 				discriminatorColumnReaders = null;
 				discriminatorColumnReaderTemplate = null;
 				discriminatorAlias = "clazz_";
 			}
 			else {
 				Column column = (Column) selectable;
 				discriminatorColumnName = column.getQuotedName( factory.getDialect() );
 				discriminatorColumnReaders = column.getReadExpr( factory.getDialect() );
 				discriminatorColumnReaderTemplate = column.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				discriminatorAlias = column.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 				discriminatorFormula = null;
 				discriminatorFormulaTemplate = null;
 			}
 			discriminatorType = persistentClass.getDiscriminator().getType();
 			if ( persistentClass.isDiscriminatorValueNull() ) {
 				discriminatorValue = NULL_DISCRIMINATOR;
 				discriminatorSQLValue = InFragment.NULL;
 				discriminatorInsertable = false;
 			}
 			else if ( persistentClass.isDiscriminatorValueNotNull() ) {
 				discriminatorValue = NOT_NULL_DISCRIMINATOR;
 				discriminatorSQLValue = InFragment.NOT_NULL;
 				discriminatorInsertable = false;
 			}
 			else {
 				discriminatorInsertable = persistentClass.isDiscriminatorInsertable() && !discrimValue.hasFormula();
 				try {
 					DiscriminatorType dtype = (DiscriminatorType) discriminatorType;
 					discriminatorValue = dtype.stringToObject( persistentClass.getDiscriminatorValue() );
 					discriminatorSQLValue = dtype.objectToSQLString( discriminatorValue, factory.getDialect() );
 				}
 				catch (ClassCastException cce) {
 					throw new MappingException("Illegal discriminator type: " + discriminatorType.getName() );
 				}
 				catch (Exception e) {
 					throw new MappingException("Could not format discriminator value to SQL string", e);
 				}
 			}
 		}
 		else {
 			forceDiscriminator = false;
 			discriminatorInsertable = false;
 			discriminatorColumnName = null;
 			discriminatorColumnReaders = null;
 			discriminatorColumnReaderTemplate = null;
 			discriminatorAlias = null;
 			discriminatorType = null;
 			discriminatorValue = null;
 			discriminatorSQLValue = null;
 			discriminatorFormula = null;
 			discriminatorFormulaTemplate = null;
 		}
 
 		// PROPERTIES
 
 		propertyTableNumbers = new int[ getPropertySpan() ];
 		Iterator iter = persistentClass.getPropertyClosureIterator();
 		int i=0;
 		while( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			propertyTableNumbers[i++] = persistentClass.getJoinNumber(prop);
 
 		}
 
 		//TODO: code duplication with JoinedSubclassEntityPersister
 		
 		ArrayList columnJoinNumbers = new ArrayList();
 		ArrayList formulaJoinedNumbers = new ArrayList();
 		ArrayList propertyJoinNumbers = new ArrayList();
 		
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			Integer join = persistentClass.getJoinNumber(prop);
 			propertyJoinNumbers.add(join);
 
 			//propertyTableNumbersByName.put( prop.getName(), join );
 			propertyTableNumbersByNameAndSubclass.put( 
 					prop.getPersistentClass().getEntityName() + '.' + prop.getName(), 
 					join 
 			);
 
 			Iterator citer = prop.getColumnIterator();
 			while ( citer.hasNext() ) {
 				Selectable thing = (Selectable) citer.next();
 				if ( thing.isFormula() ) {
 					formulaJoinedNumbers.add(join);
 				}
 				else {
 					columnJoinNumbers.add(join);
 				}
 			}
 		}
 		subclassColumnTableNumberClosure = ArrayHelper.toIntArray(columnJoinNumbers);
 		subclassFormulaTableNumberClosure = ArrayHelper.toIntArray(formulaJoinedNumbers);
 		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray(propertyJoinNumbers);
 
 		int subclassSpan = persistentClass.getSubclassSpan() + 1;
 		subclassClosure = new String[subclassSpan];
 		subclassClosure[0] = getEntityName();
 		if ( persistentClass.isPolymorphic() ) {
 			addSubclassByDiscriminatorValue( discriminatorValue, getEntityName() );
 		}
 
 		// SUBCLASSES
 		if ( persistentClass.isPolymorphic() ) {
 			iter = persistentClass.getSubclassIterator();
 			int k=1;
 			while ( iter.hasNext() ) {
 				Subclass sc = (Subclass) iter.next();
 				subclassClosure[k++] = sc.getEntityName();
 				if ( sc.isDiscriminatorValueNull() ) {
 					addSubclassByDiscriminatorValue( NULL_DISCRIMINATOR, sc.getEntityName() );
 				}
 				else if ( sc.isDiscriminatorValueNotNull() ) {
 					addSubclassByDiscriminatorValue( NOT_NULL_DISCRIMINATOR, sc.getEntityName() );
 				}
 				else {
 					try {
 						DiscriminatorType dtype = (DiscriminatorType) discriminatorType;
 						addSubclassByDiscriminatorValue(
 							dtype.stringToObject( sc.getDiscriminatorValue() ),
 							sc.getEntityName()
 						);
 					}
 					catch (ClassCastException cce) {
 						throw new MappingException("Illegal discriminator type: " + discriminatorType.getName() );
 					}
 					catch (Exception e) {
 						throw new MappingException("Error parsing discriminator value", e);
 					}
 				}
 			}
 		}
 
 		initLockers();
 
 		initSubclassPropertyAliasesMap(persistentClass);
 		
 		postConstruct(mapping);
 
 	}
 
 	private void addSubclassByDiscriminatorValue(Object discriminatorValue, String entityName) {
 		String mappedEntityName = (String) subclassesByDiscriminatorValue.put( discriminatorValue, entityName );
 		if ( mappedEntityName != null ) {
 			throw new MappingException(
 					"Entities [" + entityName + "] and [" + mappedEntityName
 							+ "] are mapped with the same discriminator value '" + discriminatorValue + "'."
 			);
 		}
 	}
 
-	public SingleTableEntityPersister(
-			final EntityBinding entityBinding,
-			final EntityRegionAccessStrategy cacheAccessStrategy,
-			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
-			final SessionFactoryImplementor factory,
-			final Mapping mapping) throws HibernateException {
-
-		super( entityBinding, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
-
-		// CLASS + TABLE
-
-		// TODO: fix when joins are working (HHH-6391)
-		//joinSpan = entityBinding.getJoinClosureSpan() + 1;
-		joinSpan = 1;
-		qualifiedTableNames = new String[joinSpan];
-		isInverseTable = new boolean[joinSpan];
-		isNullableTable = new boolean[joinSpan];
-		keyColumnNames = new String[joinSpan][];
-
-		final TableSpecification table = entityBinding.getPrimaryTable();
-		qualifiedTableNames[0] = table.getQualifiedName( factory.getDialect() );
-		isInverseTable[0] = false;
-		isNullableTable[0] = false;
-		keyColumnNames[0] = getIdentifierColumnNames();
-		cascadeDeleteEnabled = new boolean[joinSpan];
-
-		// Custom sql
-		customSQLInsert = new String[joinSpan];
-		customSQLUpdate = new String[joinSpan];
-		customSQLDelete = new String[joinSpan];
-		insertCallable = new boolean[joinSpan];
-		updateCallable = new boolean[joinSpan];
-		deleteCallable = new boolean[joinSpan];
-		insertResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
-		updateResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
-		deleteResultCheckStyles = new ExecuteUpdateResultCheckStyle[joinSpan];
-
-		initializeCustomSql( entityBinding.getCustomInsert(), 0, customSQLInsert, insertCallable, insertResultCheckStyles );
-		initializeCustomSql( entityBinding.getCustomUpdate(), 0, customSQLUpdate, updateCallable, updateResultCheckStyles );
-		initializeCustomSql( entityBinding.getCustomDelete(), 0, customSQLDelete, deleteCallable, deleteResultCheckStyles );
-
-		// JOINS
-
-		// TODO: add join stuff when HHH-6391 is working
-
-		constraintOrderedTableNames = new String[qualifiedTableNames.length];
-		constraintOrderedKeyColumnNames = new String[qualifiedTableNames.length][];
-		for ( int i = qualifiedTableNames.length - 1, position = 0; i >= 0; i--, position++ ) {
-			constraintOrderedTableNames[position] = qualifiedTableNames[i];
-			constraintOrderedKeyColumnNames[position] = keyColumnNames[i];
-		}
-
-		spaces = ArrayHelper.join(
-				qualifiedTableNames,
-				ArrayHelper.toStringArray( entityBinding.getSynchronizedTableNames() )
-		);
-
-		final boolean lazyAvailable = isInstrumented();
-
-		boolean hasDeferred = false;
-		ArrayList subclassTables = new ArrayList();
-		ArrayList joinKeyColumns = new ArrayList();
-		ArrayList<Boolean> isConcretes = new ArrayList<Boolean>();
-		ArrayList<Boolean> isDeferreds = new ArrayList<Boolean>();
-		ArrayList<Boolean> isInverses = new ArrayList<Boolean>();
-		ArrayList<Boolean> isNullables = new ArrayList<Boolean>();
-		ArrayList<Boolean> isLazies = new ArrayList<Boolean>();
-		subclassTables.add( qualifiedTableNames[0] );
-		joinKeyColumns.add( getIdentifierColumnNames() );
-		isConcretes.add(Boolean.TRUE);
-		isDeferreds.add(Boolean.FALSE);
-		isInverses.add(Boolean.FALSE);
-		isNullables.add(Boolean.FALSE);
-		isLazies.add(Boolean.FALSE);
-
-		// TODO: add join stuff when HHH-6391 is working
-
-
-		subclassTableSequentialSelect = ArrayHelper.toBooleanArray(isDeferreds);
-		subclassTableNameClosure = ArrayHelper.toStringArray(subclassTables);
-		subclassTableIsLazyClosure = ArrayHelper.toBooleanArray(isLazies);
-		subclassTableKeyColumnClosure = ArrayHelper.to2DStringArray( joinKeyColumns );
-		isClassOrSuperclassTable = ArrayHelper.toBooleanArray(isConcretes);
-		isInverseSubclassTable = ArrayHelper.toBooleanArray(isInverses);
-		isNullableSubclassTable = ArrayHelper.toBooleanArray(isNullables);
-		hasSequentialSelects = hasDeferred;
-
-		// DISCRIMINATOR
-
-		if ( entityBinding.isPolymorphic() ) {
-			SimpleValue discriminatorRelationalValue = entityBinding.getHierarchyDetails().getEntityDiscriminator().getBoundValue();
-			if ( discriminatorRelationalValue == null ) {
-				throw new MappingException("discriminator mapping required for single table polymorphic persistence");
-			}
-			forceDiscriminator = entityBinding.getHierarchyDetails().getEntityDiscriminator().isForced();
-			if ( DerivedValue.class.isInstance( discriminatorRelationalValue ) ) {
-				DerivedValue formula = ( DerivedValue ) discriminatorRelationalValue;
-				discriminatorFormula = formula.getExpression();
-				discriminatorFormulaTemplate = getTemplateFromString( formula.getExpression(), factory );
-				discriminatorColumnName = null;
-				discriminatorColumnReaders = null;
-				discriminatorColumnReaderTemplate = null;
-				discriminatorAlias = "clazz_";
-			}
-			else {
-				org.hibernate.metamodel.relational.Column column = ( org.hibernate.metamodel.relational.Column ) discriminatorRelationalValue;
-				discriminatorColumnName = column.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
-				discriminatorColumnReaders =
-						column.getReadFragment() == null ?
-								column.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() ) :
-								column.getReadFragment();
-				discriminatorColumnReaderTemplate = getTemplateFromColumn( column, factory );
-				discriminatorAlias = column.getAlias( factory.getDialect() );
-				discriminatorFormula = null;
-				discriminatorFormulaTemplate = null;
-			}
-
-			discriminatorType = entityBinding.getHierarchyDetails()
-					.getEntityDiscriminator()
-					.getExplicitHibernateTypeDescriptor()
-					.getResolvedTypeMapping();
-			if ( entityBinding.getDiscriminatorMatchValue() == null ) {
-				discriminatorValue = NULL_DISCRIMINATOR;
-				discriminatorSQLValue = InFragment.NULL;
-				discriminatorInsertable = false;
-			}
-			else if ( entityBinding.getDiscriminatorMatchValue().equals( NULL_STRING ) ) {
-				discriminatorValue = NOT_NULL_DISCRIMINATOR;
-				discriminatorSQLValue = InFragment.NOT_NULL;
-				discriminatorInsertable = false;
-			}
-			else if ( entityBinding.getDiscriminatorMatchValue().equals( NOT_NULL_STRING ) ) {
-				discriminatorValue = NOT_NULL_DISCRIMINATOR;
-				discriminatorSQLValue = InFragment.NOT_NULL;
-				discriminatorInsertable = false;
-			}
-			else {
-				discriminatorInsertable = entityBinding.getHierarchyDetails().getEntityDiscriminator().isInserted()
-						&& ! DerivedValue.class.isInstance( discriminatorRelationalValue );
-				try {
-					DiscriminatorType dtype = ( DiscriminatorType ) discriminatorType;
-					discriminatorValue = dtype.stringToObject( entityBinding.getDiscriminatorMatchValue() );
-					discriminatorSQLValue = dtype.objectToSQLString( discriminatorValue, factory.getDialect() );
-				}
-				catch (ClassCastException cce) {
-					throw new MappingException("Illegal discriminator type: " + discriminatorType.getName() );
-				}
-				catch (Exception e) {
-					throw new MappingException("Could not format discriminator value to SQL string", e);
-				}
-			}
-		}
-		else {
-			forceDiscriminator = false;
-			discriminatorInsertable = false;
-			discriminatorColumnName = null;
-			discriminatorColumnReaders = null;
-			discriminatorColumnReaderTemplate = null;
-			discriminatorAlias = null;
-			discriminatorType = null;
-			discriminatorValue = null;
-			discriminatorSQLValue = null;
-			discriminatorFormula = null;
-			discriminatorFormulaTemplate = null;
-		}
-
-		// PROPERTIES
-
-		propertyTableNumbers = new int[ getPropertySpan() ];
-		int i=0;
-		for( AttributeBinding attributeBinding : entityBinding.getAttributeBindingClosure() ) {
-			// TODO: fix when joins are working (HHH-6391)
-			//propertyTableNumbers[i++] = entityBinding.getJoinNumber( attributeBinding);
-			if ( attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
-				continue; // skip identifier binding
-			}
-			if ( ! attributeBinding.getAttribute().isSingular() ) {
-				continue;
-			}
-			propertyTableNumbers[ i++ ] = 0;
-		}
-
-		//TODO: code duplication with JoinedSubclassEntityPersister
-
-		ArrayList columnJoinNumbers = new ArrayList();
-		ArrayList formulaJoinedNumbers = new ArrayList();
-		ArrayList propertyJoinNumbers = new ArrayList();
-
-		for ( AttributeBinding attributeBinding : entityBinding.getSubEntityAttributeBindingClosure() ) {
-			if ( ! attributeBinding.getAttribute().isSingular() ) {
-				continue;
-			}
-			SingularAttributeBinding singularAttributeBinding = (SingularAttributeBinding) attributeBinding;
-
-			// TODO: fix when joins are working (HHH-6391)
-			//int join = entityBinding.getJoinNumber(singularAttributeBinding);
-			int join = 0;
-			propertyJoinNumbers.add(join);
-
-			//propertyTableNumbersByName.put( singularAttributeBinding.getName(), join );
-			propertyTableNumbersByNameAndSubclass.put(
-					singularAttributeBinding.getContainer().getPathBase() + '.' + singularAttributeBinding.getAttribute().getName(),
-					join
-			);
-
-			for ( SimpleValueBinding simpleValueBinding : singularAttributeBinding.getSimpleValueBindings() ) {
-				if ( DerivedValue.class.isInstance( simpleValueBinding.getSimpleValue() ) ) {
-					formulaJoinedNumbers.add( join );
-				}
-				else {
-					columnJoinNumbers.add( join );
-				}
-			}
-		}
-		subclassColumnTableNumberClosure = ArrayHelper.toIntArray(columnJoinNumbers);
-		subclassFormulaTableNumberClosure = ArrayHelper.toIntArray(formulaJoinedNumbers);
-		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray(propertyJoinNumbers);
-
-		int subclassSpan = entityBinding.getSubEntityBindingClosureSpan() + 1;
-		subclassClosure = new String[subclassSpan];
-		subclassClosure[0] = getEntityName();
-		if ( entityBinding.isPolymorphic() ) {
-			addSubclassByDiscriminatorValue( discriminatorValue, getEntityName() );
-		}
-
-		// SUBCLASSES
-		if ( entityBinding.isPolymorphic() ) {
-			int k=1;
-			for ( EntityBinding subEntityBinding : entityBinding.getPostOrderSubEntityBindingClosure() ) {
-				subclassClosure[k++] = subEntityBinding.getEntity().getName();
-				if ( subEntityBinding.isDiscriminatorMatchValueNull() ) {
-					addSubclassByDiscriminatorValue( NULL_DISCRIMINATOR, subEntityBinding.getEntity().getName() );
-				}
-				else if ( subEntityBinding.isDiscriminatorMatchValueNotNull() ) {
-					addSubclassByDiscriminatorValue( NOT_NULL_DISCRIMINATOR, subEntityBinding.getEntity().getName() );
-				}
-				else {
-					try {
-						DiscriminatorType dtype = (DiscriminatorType) discriminatorType;
-						addSubclassByDiscriminatorValue(
-							dtype.stringToObject( subEntityBinding.getDiscriminatorMatchValue() ),
-							subEntityBinding.getEntity().getName()
-						);
-					}
-					catch (ClassCastException cce) {
-						throw new MappingException("Illegal discriminator type: " + discriminatorType.getName() );
-					}
-					catch (Exception e) {
-						throw new MappingException("Error parsing discriminator value", e);
-					}
-				}
-			}
-		}
-
-		initLockers();
-
-		initSubclassPropertyAliasesMap( entityBinding );
-
-		postConstruct( mapping );
-	}
-
-	private static void initializeCustomSql(
-			CustomSQL customSql,
-			int i,
-			String[] sqlStrings,
-			boolean[] callable,
-			ExecuteUpdateResultCheckStyle[] checkStyles) {
-		sqlStrings[i] = customSql != null ?  customSql.getSql(): null;
-		callable[i] = sqlStrings[i] != null && customSql.isCallable();
-		checkStyles[i] = customSql != null && customSql.getCheckStyle() != null ?
-				customSql.getCheckStyle() :
-				ExecuteUpdateResultCheckStyle.determineDefault( sqlStrings[i], callable[i] );
-	}
-
 	protected boolean isInverseTable(int j) {
 		return isInverseTable[j];
 	}
 
 	protected boolean isInverseSubclassTable(int j) {
 		return isInverseSubclassTable[j];
 	}
 
 	public String getDiscriminatorColumnName() {
 		return discriminatorColumnName;
 	}
 
 	public String getDiscriminatorColumnReaders() {
 		return discriminatorColumnReaders;
 	}			
 	
 	public String getDiscriminatorColumnReaderTemplate() {
 		return discriminatorColumnReaderTemplate;
 	}	
 	
 	protected String getDiscriminatorAlias() {
 		return discriminatorAlias;
 	}
 
 	protected String getDiscriminatorFormulaTemplate() {
 		return discriminatorFormulaTemplate;
 	}
 
 	public String getTableName() {
 		return qualifiedTableNames[0];
 	}
 
 	public Type getDiscriminatorType() {
 		return discriminatorType;
 	}
 
 	public Object getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	public String getDiscriminatorSQLValue() {
 		return discriminatorSQLValue;
 	}
 
 	public String[] getSubclassClosure() {
 		return subclassClosure;
 	}
 
 	public String getSubclassForDiscriminatorValue(Object value) {
 		if (value==null) {
 			return (String) subclassesByDiscriminatorValue.get(NULL_DISCRIMINATOR);
 		}
 		else {
 			String result = (String) subclassesByDiscriminatorValue.get(value);
 			if (result==null) result = (String) subclassesByDiscriminatorValue.get(NOT_NULL_DISCRIMINATOR);
 			return result;
 		}
 	}
 
 	public Serializable[] getPropertySpaces() {
 		return spaces;
 	}
 
 	//Access cached SQL
 
 	protected boolean isDiscriminatorFormula() {
 		return discriminatorColumnName==null;
 	}
 
 	protected String getDiscriminatorFormula() {
 		return discriminatorFormula;
 	}
 
 	protected String getTableName(int j) {
 		return qualifiedTableNames[j];
 	}
 	
 	protected String[] getKeyColumns(int j) {
 		return keyColumnNames[j];
 	}
 	
 	protected boolean isTableCascadeDeleteEnabled(int j) {
 		return cascadeDeleteEnabled[j];
 	}
 	
 	protected boolean isPropertyOfTable(int property, int j) {
 		return propertyTableNumbers[property]==j;
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return subclassTableSequentialSelect[j] && !isClassOrSuperclassTable[j];
 	}
 	
 	// Execute the SQL:
 
 	public String fromTableFragment(String name) {
 		return getTableName() + ' ' + name;
 	}
 
 	@Override
 	public String filterFragment(String alias) throws MappingException {
 		String result = discriminatorFilterFragment(alias);
 		if ( hasWhere() ) result += " and " + getSQLWhereString(alias);
 		return result;
 	}
 
 	private String discriminatorFilterFragment(String alias) throws MappingException {
 		return discriminatorFilterFragment( alias, null );
 	}
 	
 	public String oneToManyFilterFragment(String alias) throws MappingException {
 		return forceDiscriminator
 				? discriminatorFilterFragment( alias, null )
 				: "";
 	}
 
 	@Override
 	public String oneToManyFilterFragment(String alias, Set<String> treatAsDeclarations) {
 		return needsDiscriminator()
 				? discriminatorFilterFragment( alias, treatAsDeclarations )
 				: "";
 	}
 
 	@Override
 	public String filterFragment(String alias, Set<String> treatAsDeclarations) {
 		String result = discriminatorFilterFragment( alias, treatAsDeclarations );
 		if ( hasWhere() ) {
 			result += " and " + getSQLWhereString( alias );
 		}
 		return result;
 	}
 
 	private String discriminatorFilterFragment(String alias, Set<String> treatAsDeclarations)  {
 		final boolean hasTreatAs = treatAsDeclarations != null && !treatAsDeclarations.isEmpty();
 
 		if ( !needsDiscriminator() && !hasTreatAs) {
 			return "";
 		}
 
 		final InFragment frag = new InFragment();
 		if ( isDiscriminatorFormula() ) {
 			frag.setFormula( alias, getDiscriminatorFormulaTemplate() );
 		}
 		else {
 			frag.setColumn( alias, getDiscriminatorColumnName() );
 		}
 
 		if ( hasTreatAs ) {
 			frag.addValues( decodeTreatAsRequests( treatAsDeclarations ) );
 		}
 		else {
 			frag.addValues( fullDiscriminatorValues() );
 		}
 
 		return " and " + frag.toFragmentString();
 	}
 
 	private boolean needsDiscriminator() {
 		return forceDiscriminator || isInherited();
 	}
 
 	private String[] decodeTreatAsRequests(Set<String> treatAsDeclarations) {
 		final List<String> values = new ArrayList<String>();
 		for ( String subclass : treatAsDeclarations ) {
 			final Queryable queryable = (Queryable) getFactory().getEntityPersister( subclass );
 			if ( !queryable.isAbstract() ) {
 				values.add( queryable.getDiscriminatorSQLValue() );
 			}
 		}
 		return values.toArray( new String[ values.size() ] );
 	}
 
 	private String[] fullDiscriminatorValues;
 
 	private String[] fullDiscriminatorValues() {
 		if ( fullDiscriminatorValues == null ) {
 			// first access; build it
 			final List<String> values = new ArrayList<String>();
 			for ( String subclass : getSubclassClosure() ) {
 				final Queryable queryable = (Queryable) getFactory().getEntityPersister( subclass );
 				if ( !queryable.isAbstract() ) {
 					values.add( queryable.getDiscriminatorSQLValue() );
 				}
 			}
 			fullDiscriminatorValues = values.toArray( new String[values.size() ] );
 		}
 
 		return fullDiscriminatorValues;
 	}
 
 	public String getSubclassPropertyTableName(int i) {
 		return subclassTableNameClosure[ subclassPropertyTableNumberClosure[i] ];
 	}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {
 		if ( isDiscriminatorFormula() ) {
 			select.addFormula( name, getDiscriminatorFormulaTemplate(), getDiscriminatorAlias() );
 		}
 		else {
 			select.addColumn( name, getDiscriminatorColumnName(),  getDiscriminatorAlias() );
 		}
 	}
 	
 	protected int[] getPropertyTableNumbersInSelect() {
 		return propertyTableNumbers;
 	}
 
 	protected int getSubclassPropertyTableNumber(int i) {
 		return subclassPropertyTableNumberClosure[i];
 	}
 
 	public int getTableSpan() {
 		return joinSpan;
 	}
 
 	protected void addDiscriminatorToInsert(Insert insert) {
 
 		if (discriminatorInsertable) {
 			insert.addColumn( getDiscriminatorColumnName(), discriminatorSQLValue );
 		}
 
 	}
 
 	protected int[] getSubclassColumnTableNumberClosure() {
 		return subclassColumnTableNumberClosure;
 	}
 
 	protected int[] getSubclassFormulaTableNumberClosure() {
 		return subclassFormulaTableNumberClosure;
 	}
 
 	protected int[] getPropertyTableNumbers() {
 		return propertyTableNumbers;
 	}
 		
 	protected boolean isSubclassPropertyDeferred(String propertyName, String entityName) {
 		return hasSequentialSelects && 
 			isSubclassTableSequentialSelect( getSubclassPropertyTableNumber(propertyName, entityName) );
 	}
 	
 	public boolean hasSequentialSelect() {
 		return hasSequentialSelects;
 	}
 	
 	private int getSubclassPropertyTableNumber(String propertyName, String entityName) {
 		Type type = propertyMapping.toType(propertyName);
 		if ( type.isAssociationType() && ( (AssociationType) type ).useLHSPrimaryKey() ) return 0;
 		final Integer tabnum = (Integer) propertyTableNumbersByNameAndSubclass.get(entityName + '.' + propertyName);
 		return tabnum==null ? 0 : tabnum;
 	}
 	
 	protected String getSequentialSelect(String entityName) {
 		return (String) sequentialSelectStringsByEntityName.get(entityName);
 	}
 
 	private String generateSequentialSelect(Loadable persister) {
 		//if ( this==persister || !hasSequentialSelects ) return null;
 
 		//note that this method could easily be moved up to BasicEntityPersister,
 		//if we ever needed to reuse it from other subclasses
 		
 		//figure out which tables need to be fetched
 		AbstractEntityPersister subclassPersister = (AbstractEntityPersister) persister;
 		HashSet tableNumbers = new HashSet();
 		String[] props = subclassPersister.getPropertyNames();
 		String[] classes = subclassPersister.getPropertySubclassNames();
 		for ( int i=0; i<props.length; i++ ) {
 			int propTableNumber = getSubclassPropertyTableNumber( props[i], classes[i] );
 			if ( isSubclassTableSequentialSelect(propTableNumber) && !isSubclassTableLazy(propTableNumber) ) {
 				tableNumbers.add( propTableNumber);
 			}
 		}
 		if ( tableNumbers.isEmpty() ) return null;
 		
 		//figure out which columns are needed
 		ArrayList columnNumbers = new ArrayList();
 		final int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		for ( int i=0; i<getSubclassColumnClosure().length; i++ ) {
 			if ( tableNumbers.contains( columnTableNumbers[i] ) ) {
 				columnNumbers.add( i );
 			}
 		}
 		
 		//figure out which formulas are needed
 		ArrayList formulaNumbers = new ArrayList();
 		final int[] formulaTableNumbers = getSubclassColumnTableNumberClosure();
 		for ( int i=0; i<getSubclassFormulaTemplateClosure().length; i++ ) {
 			if ( tableNumbers.contains( formulaTableNumbers[i] ) ) {
 				formulaNumbers.add( i );
 			}
 		}
 		
 		//render the SQL
 		return renderSelect( 
 			ArrayHelper.toIntArray(tableNumbers),
 			ArrayHelper.toIntArray(columnNumbers),
 			ArrayHelper.toIntArray(formulaNumbers)
 		);
 	}
 		
 		
 	protected String[] getSubclassTableKeyColumns(int j) {
 		return subclassTableKeyColumnClosure[j];
 	}
 
 	public String getSubclassTableName(int j) {
 		return subclassTableNameClosure[j];
 	}
 
 	public int getSubclassTableSpan() {
 		return subclassTableNameClosure.length;
 	}
 
 	protected boolean isClassOrSuperclassTable(int j) {
 		return isClassOrSuperclassTable[j];
 	}
 
 	protected boolean isSubclassTableLazy(int j) {
 		return subclassTableIsLazyClosure[j];
 	}
 	
 	protected boolean isNullableTable(int j) {
 		return isNullableTable[j];
 	}
 	
 	protected boolean isNullableSubclassTable(int j) {
 		return isNullableSubclassTable[j];
 	}
 
 	public String getPropertyTableName(String propertyName) {
 		Integer index = getEntityMetamodel().getPropertyIndexOrNull(propertyName);
 		if (index==null) return null;
 		return qualifiedTableNames[ propertyTableNumbers[index] ];
 	}
 	
 	protected void doPostInstantiate() {
 		if (hasSequentialSelects) {
 			String[] entityNames = getSubclassClosure();
 			for ( int i=1; i<entityNames.length; i++ ) {
 				Loadable loadable = (Loadable) getFactory().getEntityPersister( entityNames[i] );
 				if ( !loadable.isAbstract() ) { //perhaps not really necessary...
 					String sequentialSelect = generateSequentialSelect(loadable);
 					sequentialSelectStringsByEntityName.put( entityNames[i], sequentialSelect );
 				}
 			}
 		}
 	}
 
 	public boolean isMultiTable() {
 		return getTableSpan() > 1;
 	}
 
 	public String[] getConstraintOrderedTableNameClosure() {
 		return constraintOrderedTableNames;
 	}
 
 	public String[][] getContraintOrderedTableKeyColumnClosure() {
 		return constraintOrderedKeyColumnNames;
 	}
 
 	@Override
 	public FilterAliasGenerator getFilterAliasGenerator(String rootAlias) {
 		return new DynamicFilterAliasGenerator(qualifiedTableNames, rootAlias);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/UnionSubclassEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/UnionSubclassEntityPersister.java
index 1569254186..746e6b108e 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/UnionSubclassEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/UnionSubclassEntityPersister.java
@@ -1,524 +1,504 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.MappingException;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cfg.Settings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.internal.FilterAliasGenerator;
 import org.hibernate.internal.StaticFilterAliasGenerator;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.collections.SingletonIterator;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.mapping.Table;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Implementation of the "table-per-concrete-class" or "roll-down" mapping 
  * strategy for an entity and its inheritence hierarchy.
  *
  * @author Gavin King
  */
 public class UnionSubclassEntityPersister extends AbstractEntityPersister {
 
 	// the class hierarchy structure
 	private final String subquery;
 	private final String tableName;
 	//private final String rootTableName;
 	private final String[] subclassClosure;
 	private final String[] spaces;
 	private final String[] subclassSpaces;
 	private final Object discriminatorValue;
 	private final String discriminatorSQLValue;
 	private final Map subclassByDiscriminatorValue = new HashMap();
 
 	private final String[] constraintOrderedTableNames;
 	private final String[][] constraintOrderedKeyColumnNames;
 
 	//INITIALIZATION:
 
 	public UnionSubclassEntityPersister(
 			final PersistentClass persistentClass, 
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory,
 			final Mapping mapping) throws HibernateException {
 
 		super( persistentClass, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
 		
 		if ( getIdentifierGenerator() instanceof IdentityGenerator ) {
 			throw new MappingException(
 					"Cannot use identity column key generation with <union-subclass> mapping for: " + 
 					getEntityName() 
 			);
 		}
 
 		// TABLE
 
 		tableName = persistentClass.getTable().getQualifiedName( 
 				factory.getDialect(), 
 				factory.getSettings().getDefaultCatalogName(), 
 				factory.getSettings().getDefaultSchemaName() 
 		);
 		/*rootTableName = persistentClass.getRootTable().getQualifiedName( 
 				factory.getDialect(), 
 				factory.getDefaultCatalog(), 
 				factory.getDefaultSchema() 
 		);*/
 
 		//Custom SQL
 
 		String sql;
 		boolean callable = false;
 		ExecuteUpdateResultCheckStyle checkStyle = null;
 		sql = persistentClass.getCustomSQLInsert();
 		callable = sql != null && persistentClass.isCustomInsertCallable();
 		checkStyle = sql == null
 				? ExecuteUpdateResultCheckStyle.COUNT
 	            : persistentClass.getCustomSQLInsertCheckStyle() == null
 						? ExecuteUpdateResultCheckStyle.determineDefault( sql, callable )
 	                    : persistentClass.getCustomSQLInsertCheckStyle();
 		customSQLInsert = new String[] { sql };
 		insertCallable = new boolean[] { callable };
 		insertResultCheckStyles = new ExecuteUpdateResultCheckStyle[] { checkStyle };
 
 		sql = persistentClass.getCustomSQLUpdate();
 		callable = sql != null && persistentClass.isCustomUpdateCallable();
 		checkStyle = sql == null
 				? ExecuteUpdateResultCheckStyle.COUNT
 	            : persistentClass.getCustomSQLUpdateCheckStyle() == null
 						? ExecuteUpdateResultCheckStyle.determineDefault( sql, callable )
 	                    : persistentClass.getCustomSQLUpdateCheckStyle();
 		customSQLUpdate = new String[] { sql };
 		updateCallable = new boolean[] { callable };
 		updateResultCheckStyles = new ExecuteUpdateResultCheckStyle[] { checkStyle };
 
 		sql = persistentClass.getCustomSQLDelete();
 		callable = sql != null && persistentClass.isCustomDeleteCallable();
 		checkStyle = sql == null
 				? ExecuteUpdateResultCheckStyle.COUNT
 	            : persistentClass.getCustomSQLDeleteCheckStyle() == null
 						? ExecuteUpdateResultCheckStyle.determineDefault( sql, callable )
 	                    : persistentClass.getCustomSQLDeleteCheckStyle();
 		customSQLDelete = new String[] { sql };
 		deleteCallable = new boolean[] { callable };
 		deleteResultCheckStyles = new ExecuteUpdateResultCheckStyle[] { checkStyle };
 
 		discriminatorValue = persistentClass.getSubclassId();
 		discriminatorSQLValue = String.valueOf( persistentClass.getSubclassId() );
 
 		// PROPERTIES
 
 		int subclassSpan = persistentClass.getSubclassSpan() + 1;
 		subclassClosure = new String[subclassSpan];
 		subclassClosure[0] = getEntityName();
 
 		// SUBCLASSES
 		subclassByDiscriminatorValue.put( 
 				persistentClass.getSubclassId(),
 				persistentClass.getEntityName() 
 		);
 		if ( persistentClass.isPolymorphic() ) {
 			Iterator iter = persistentClass.getSubclassIterator();
 			int k=1;
 			while ( iter.hasNext() ) {
 				Subclass sc = (Subclass) iter.next();
 				subclassClosure[k++] = sc.getEntityName();
 				subclassByDiscriminatorValue.put( sc.getSubclassId(), sc.getEntityName() );
 			}
 		}
 		
 		//SPACES
 		//TODO: i'm not sure, but perhaps we should exclude
 		//      abstract denormalized tables?
 		
 		int spacesSize = 1 + persistentClass.getSynchronizedTables().size();
 		spaces = new String[spacesSize];
 		spaces[0] = tableName;
 		Iterator iter = persistentClass.getSynchronizedTables().iterator();
 		for ( int i=1; i<spacesSize; i++ ) {
 			spaces[i] = (String) iter.next();
 		}
 		
 		HashSet subclassTables = new HashSet();
 		iter = persistentClass.getSubclassTableClosureIterator();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			subclassTables.add( table.getQualifiedName(
 					factory.getDialect(), 
 					factory.getSettings().getDefaultCatalogName(), 
 					factory.getSettings().getDefaultSchemaName() 
 			) );
 		}
 		subclassSpaces = ArrayHelper.toStringArray(subclassTables);
 
 		subquery = generateSubquery(persistentClass, mapping);
 
 		if ( isMultiTable() ) {
 			int idColumnSpan = getIdentifierColumnSpan();
 			ArrayList tableNames = new ArrayList();
 			ArrayList keyColumns = new ArrayList();
 			if ( !isAbstract() ) {
 				tableNames.add( tableName );
 				keyColumns.add( getIdentifierColumnNames() );
 			}
 			iter = persistentClass.getSubclassTableClosureIterator();
 			while ( iter.hasNext() ) {
 				Table tab = ( Table ) iter.next();
 				if ( !tab.isAbstractUnionTable() ) {
 					String tableName = tab.getQualifiedName(
 							factory.getDialect(),
 							factory.getSettings().getDefaultCatalogName(),
 							factory.getSettings().getDefaultSchemaName()
 					);
 					tableNames.add( tableName );
 					String[] key = new String[idColumnSpan];
 					Iterator citer = tab.getPrimaryKey().getColumnIterator();
 					for ( int k=0; k<idColumnSpan; k++ ) {
 						key[k] = ( ( Column ) citer.next() ).getQuotedName( factory.getDialect() );
 					}
 					keyColumns.add( key );
 				}
 			}
 
 			constraintOrderedTableNames = ArrayHelper.toStringArray( tableNames );
 			constraintOrderedKeyColumnNames = ArrayHelper.to2DStringArray( keyColumns );
 		}
 		else {
 			constraintOrderedTableNames = new String[] { tableName };
 			constraintOrderedKeyColumnNames = new String[][] { getIdentifierColumnNames() };
 		}
 
 		initLockers();
 
 		initSubclassPropertyAliasesMap(persistentClass);
 		
 		postConstruct(mapping);
 
 	}
 
-	public UnionSubclassEntityPersister(
-			final EntityBinding entityBinding,
-			final EntityRegionAccessStrategy cacheAccessStrategy,
-			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
-			final SessionFactoryImplementor factory,
-			final Mapping mapping) throws HibernateException {
-		super(entityBinding, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
-		// TODO: implement!!! initializing final fields to null to make compiler happy.
-		subquery = null;
-		tableName = null;
-		subclassClosure = null;
-		spaces = null;
-		subclassSpaces = null;
-		discriminatorValue = null;
-		discriminatorSQLValue = null;
-		constraintOrderedTableNames = null;
-		constraintOrderedKeyColumnNames = null;
-	}
-
 	public Serializable[] getQuerySpaces() {
 		return subclassSpaces;
 	}
 	
 	public String getTableName() {
 		return subquery;
 	}
 
 	public Type getDiscriminatorType() {
 		return StandardBasicTypes.INTEGER;
 	}
 
 	public Object getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	public String getDiscriminatorSQLValue() {
 		return discriminatorSQLValue;
 	}
 
 	public String[] getSubclassClosure() {
 		return subclassClosure;
 	}
 
 	public String getSubclassForDiscriminatorValue(Object value) {
 		return (String) subclassByDiscriminatorValue.get(value);
 	}
 
 	public Serializable[] getPropertySpaces() {
 		return spaces;
 	}
 
 	protected boolean isDiscriminatorFormula() {
 		return false;
 	}
 
 	/**
 	 * Generate the SQL that selects a row by id
 	 */
 	protected String generateSelectString(LockMode lockMode) {
 		SimpleSelect select = new SimpleSelect( getFactory().getDialect() )
 			.setLockMode(lockMode)
 			.setTableName( getTableName() )
 			.addColumns( getIdentifierColumnNames() )
 			.addColumns( 
 					getSubclassColumnClosure(), 
 					getSubclassColumnAliasClosure(),
 					getSubclassColumnLazyiness()
 			)
 			.addColumns( 
 					getSubclassFormulaClosure(), 
 					getSubclassFormulaAliasClosure(),
 					getSubclassFormulaLazyiness()
 			);
 		//TODO: include the rowids!!!!
 		if ( hasSubclasses() ) {
 			if ( isDiscriminatorFormula() ) {
 				select.addColumn( getDiscriminatorFormula(), getDiscriminatorAlias() );
 			}
 			else {
 				select.addColumn( getDiscriminatorColumnName(), getDiscriminatorAlias() );
 			}
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "load " + getEntityName() );
 		}
 		return select.addCondition( getIdentifierColumnNames(), "=?" ).toStatementString();
 	}
 
 	protected String getDiscriminatorFormula() {
 		return null;
 	}
 
 	protected String getTableName(int j) {
 		return tableName;
 	}
 
 	protected String[] getKeyColumns(int j) {
 		return getIdentifierColumnNames();
 	}
 	
 	protected boolean isTableCascadeDeleteEnabled(int j) {
 		return false;
 	}
 	
 	protected boolean isPropertyOfTable(int property, int j) {
 		return true;
 	}
 
 	// Execute the SQL:
 
 	public String fromTableFragment(String name) {
 		return getTableName() + ' '  + name;
 	}
 
 	@Override
 	public String filterFragment(String name) {
 		return hasWhere()
 				? " and " + getSQLWhereString( name )
 				: "";
 	}
 
 	@Override
 	protected String filterFragment(String alias, Set<String> treatAsDeclarations) {
 		return filterFragment( alias );
 	}
 
 	public String getSubclassPropertyTableName(int i) {
 		return getTableName();//ie. the subquery! yuck!
 	}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {
 		select.addColumn( name, getDiscriminatorColumnName(),  getDiscriminatorAlias() );
 	}
 	
 	protected int[] getPropertyTableNumbersInSelect() {
 		return new int[ getPropertySpan() ];
 	}
 
 	protected int getSubclassPropertyTableNumber(int i) {
 		return 0;
 	}
 
 	public int getSubclassPropertyTableNumber(String propertyName) {
 		return 0;
 	}
 
 	public boolean isMultiTable() {
 		// This could also just be true all the time...
 		return isAbstract() || hasSubclasses();
 	}
 
 	public int getTableSpan() {
 		return 1;
 	}
 
 	protected int[] getSubclassColumnTableNumberClosure() {
 		return new int[ getSubclassColumnClosure().length ];
 	}
 
 	protected int[] getSubclassFormulaTableNumberClosure() {
 		return new int[ getSubclassFormulaClosure().length ];
 	}
 
 	protected boolean[] getTableHasColumns() {
 		return new boolean[] { true };
 	}
 
 	protected int[] getPropertyTableNumbers() {
 		return new int[ getPropertySpan() ];
 	}
 
 	protected String generateSubquery(PersistentClass model, Mapping mapping) {
 
 		Dialect dialect = getFactory().getDialect();
 		Settings settings = getFactory().getSettings();
 		
 		if ( !model.hasSubclasses() ) {
 			return model.getTable().getQualifiedName(
 					dialect,
 					settings.getDefaultCatalogName(),
 					settings.getDefaultSchemaName()
 				);
 		}
 
 		HashSet columns = new LinkedHashSet();
 		Iterator titer = model.getSubclassTableClosureIterator();
 		while ( titer.hasNext() ) {
 			Table table = (Table) titer.next();
 			if ( !table.isAbstractUnionTable() ) {
 				Iterator citer = table.getColumnIterator();
 				while ( citer.hasNext() ) columns.add( citer.next() );
 			}
 		}
 
 		StringBuilder buf = new StringBuilder()
 			.append("( ");
 
 		Iterator siter = new JoinedIterator(
 			new SingletonIterator(model),
 			model.getSubclassIterator()
 		);
 
 		while ( siter.hasNext() ) {
 			PersistentClass clazz = (PersistentClass) siter.next();
 			Table table = clazz.getTable();
 			if ( !table.isAbstractUnionTable() ) {
 				//TODO: move to .sql package!!
 				buf.append("select ");
 				Iterator citer = columns.iterator();
 				while ( citer.hasNext() ) {
 					Column col = (Column) citer.next();
 					if ( !table.containsColumn(col) ) {
 						int sqlType = col.getSqlTypeCode(mapping);
 						buf.append( dialect.getSelectClauseNullString(sqlType) )
 							.append(" as ");
 					}
 					buf.append( col.getQuotedName(dialect) );
 					buf.append(", ");
 				}
 				buf.append( clazz.getSubclassId() )
 					.append(" as clazz_");
 				buf.append(" from ")
 					.append( table.getQualifiedName(
 							dialect,
 							settings.getDefaultCatalogName(),
 							settings.getDefaultSchemaName()
 					) );
 				buf.append(" union ");
 				if ( dialect.supportsUnionAll() ) {
 					buf.append("all ");
 				}
 			}
 		}
 		
 		if ( buf.length() > 2 ) {
 			//chop the last union (all)
 			buf.setLength( buf.length() - ( dialect.supportsUnionAll() ? 11 : 7 ) );
 		}
 
 		return buf.append(" )").toString();
 	}
 
 	protected String[] getSubclassTableKeyColumns(int j) {
 		if (j!=0) throw new AssertionFailure("only one table");
 		return getIdentifierColumnNames();
 	}
 
 	public String getSubclassTableName(int j) {
 		if (j!=0) throw new AssertionFailure("only one table");
 		return tableName;
 	}
 
 	public int getSubclassTableSpan() {
 		return 1;
 	}
 
 	protected boolean isClassOrSuperclassTable(int j) {
 		if (j!=0) throw new AssertionFailure("only one table");
 		return true;
 	}
 
 	public String getPropertyTableName(String propertyName) {
 		//TODO: check this....
 		return getTableName();
 	}
 
 	public String[] getConstraintOrderedTableNameClosure() {
 			return constraintOrderedTableNames;
 	}
 
 	public String[][] getContraintOrderedTableKeyColumnClosure() {
 		return constraintOrderedKeyColumnNames;
 	}
 
 	@Override
 	public FilterAliasGenerator getFilterAliasGenerator(String rootAlias) {
 		return new StaticFilterAliasGenerator(rootAlias);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
index 41550e06bf..d820e7da98 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
@@ -1,256 +1,189 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.internal;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.AbstractPluralAttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * The standard Hibernate {@link PersisterFactory} implementation
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public final class PersisterFactoryImpl implements PersisterFactory, ServiceRegistryAwareService {
 
 	/**
 	 * The constructor signature for {@link EntityPersister} implementations
 	 *
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 */
 	public static final Class[] ENTITY_PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
 			PersistentClass.class,
 			EntityRegionAccessStrategy.class,
 			NaturalIdRegionAccessStrategy.class,
 			SessionFactoryImplementor.class,
 			Mapping.class
 	};
 
 	/**
-	 * The constructor signature for {@link EntityPersister} implementations using
-	 * an {@link EntityBinding}.
-	 *
-	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
-	 * @todo change ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW to ENTITY_PERSISTER_CONSTRUCTOR_ARGS
-	 * when new metamodel is integrated
-	 */
-	public static final Class[] ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW = new Class[] {
-			EntityBinding.class,
-			EntityRegionAccessStrategy.class,
-			NaturalIdRegionAccessStrategy.class,
-			SessionFactoryImplementor.class,
-			Mapping.class
-	};
-
-	/**
 	 * The constructor signature for {@link CollectionPersister} implementations
 	 *
 	 * @todo still need to make collection persisters EntityMode-aware
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 */
 	private static final Class[] COLLECTION_PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
 			Collection.class,
 			CollectionRegionAccessStrategy.class,
 			Configuration.class,
 			SessionFactoryImplementor.class
 	};
 
-	/**
-	 * The constructor signature for {@link CollectionPersister} implementations using
-	 * a {@link org.hibernate.metamodel.binding.AbstractPluralAttributeBinding}
-	 *
-	 * @todo still need to make collection persisters EntityMode-aware
-	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
-	 * @todo change COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW to COLLECTION_PERSISTER_CONSTRUCTOR_ARGS
-	 * when new metamodel is integrated
-	 */
-	private static final Class[] COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW = new Class[] {
-			AbstractPluralAttributeBinding.class,
-			CollectionRegionAccessStrategy.class,
-			MetadataImplementor.class,
-			SessionFactoryImplementor.class
-	};
-
 	private ServiceRegistryImplementor serviceRegistry;
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public EntityPersister createEntityPersister(
 			PersistentClass metadata,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) {
 		Class<? extends EntityPersister> persisterClass = metadata.getEntityPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getEntityPersisterClass( metadata );
 		}
 		return create( persisterClass, ENTITY_PERSISTER_CONSTRUCTOR_ARGS, metadata, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory, cfg );
 	}
 
-	@Override
-	@SuppressWarnings( {"unchecked"})
-	public EntityPersister createEntityPersister(EntityBinding metadata,
-												 EntityRegionAccessStrategy cacheAccessStrategy,
-												 SessionFactoryImplementor factory,
-												 Mapping cfg) {
-		Class<? extends EntityPersister> persisterClass = metadata.getCustomEntityPersisterClass();
-		if ( persisterClass == null ) {
-			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getEntityPersisterClass( metadata );
-		}
-		return create( persisterClass, ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW, metadata, cacheAccessStrategy, null, factory, cfg );
-	}
-
-	// TODO: change metadata arg type to EntityBinding when new metadata is integrated
 	private static EntityPersister create(
 			Class<? extends EntityPersister> persisterClass,
 			Class[] persisterConstructorArgs,
 			Object metadata,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) throws HibernateException {
 		try {
 			Constructor<? extends EntityPersister> constructor = persisterClass.getConstructor( persisterConstructorArgs );
 			try {
 				return constructor.newInstance( metadata, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory, cfg );
 			}
 			catch (MappingException e) {
 				throw e;
 			}
 			catch (InvocationTargetException e) {
 				Throwable target = e.getTargetException();
 				if ( target instanceof HibernateException ) {
 					throw (HibernateException) target;
 				}
 				else {
 					throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), target );
 				}
 			}
 			catch (Exception e) {
 				throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
 			}
 		}
 		catch (MappingException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public CollectionPersister createCollectionPersister(
 			Configuration cfg,
 			Collection collectionMetadata,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException {
 		Class<? extends CollectionPersister> persisterClass = collectionMetadata.getCollectionPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getCollectionPersisterClass( collectionMetadata );
 		}
 
 		return create( persisterClass, COLLECTION_PERSISTER_CONSTRUCTOR_ARGS, cfg, collectionMetadata, cacheAccessStrategy, factory );
 	}
 
-	@Override
-	@SuppressWarnings( {"unchecked"})
-	public CollectionPersister createCollectionPersister(
-			MetadataImplementor metadata,
-			PluralAttributeBinding collectionMetadata,
-			CollectionRegionAccessStrategy cacheAccessStrategy,
-			SessionFactoryImplementor factory) throws HibernateException {
-		Class<? extends CollectionPersister> persisterClass = collectionMetadata.getCollectionPersisterClass();
-		if ( persisterClass == null ) {
-			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getCollectionPersisterClass( collectionMetadata );
-		}
-
-		return create( persisterClass, COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW, metadata, collectionMetadata, cacheAccessStrategy, factory );
-	}
-
-	// TODO: change collectionMetadata arg type to AbstractPluralAttributeBinding when new metadata is integrated
-	// TODO: change metadata arg type to MetadataImplementor when new metadata is integrated
 	private static CollectionPersister create(
 			Class<? extends CollectionPersister> persisterClass,
 			Class[] persisterConstructorArgs,
 			Object cfg,
 			Object collectionMetadata,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException {
 		try {
 			Constructor<? extends CollectionPersister> constructor = persisterClass.getConstructor( persisterConstructorArgs );
 			try {
 				return constructor.newInstance( collectionMetadata, cacheAccessStrategy, cfg, factory );
 			}
 			catch (MappingException e) {
 				throw e;
 			}
 			catch (InvocationTargetException e) {
 				Throwable target = e.getTargetException();
 				if ( target instanceof HibernateException ) {
 					throw (HibernateException) target;
 				}
 				else {
 					throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), target );
 				}
 			}
 			catch (Exception e) {
 				throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), e );
 			}
 		}
 		catch (MappingException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/internal/StandardPersisterClassResolver.java b/hibernate-core/src/main/java/org/hibernate/persister/internal/StandardPersisterClassResolver.java
index 8c7118a2b4..4c296a040f 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/internal/StandardPersisterClassResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/internal/StandardPersisterClassResolver.java
@@ -1,141 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.internal;
 
-import java.util.Iterator;
-
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.UnionSubclass;
-import org.hibernate.metamodel.binding.CollectionElementNature;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.BasicCollectionPersister;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.OneToManyPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.JoinedSubclassEntityPersister;
 import org.hibernate.persister.entity.SingleTableEntityPersister;
 import org.hibernate.persister.entity.UnionSubclassEntityPersister;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.persister.spi.UnknownPersisterException;
 
 /**
  * @author Steve Ebersole
  */
 public class StandardPersisterClassResolver implements PersisterClassResolver {
 
-	public Class<? extends EntityPersister> getEntityPersisterClass(EntityBinding metadata) {
-		if ( metadata.isRoot() ) {
-            Iterator<EntityBinding> subEntityBindingIterator = metadata.getDirectSubEntityBindings().iterator();
-            if ( subEntityBindingIterator.hasNext() ) {
-                //If the class has children, we need to find of which kind
-                metadata = subEntityBindingIterator.next();
-            }
-            else {
-			    return singleTableEntityPersister();
-            }
-		}
-		switch ( metadata.getHierarchyDetails().getInheritanceType() ) {
-			case JOINED: {
-				return joinedSubclassEntityPersister();
-			}
-			case SINGLE_TABLE: {
-				return singleTableEntityPersister();
-			}
-			case TABLE_PER_CLASS: {
-				return unionSubclassEntityPersister();
-			}
-			default: {
-				throw new UnknownPersisterException(
-						"Could not determine persister implementation for entity [" + metadata.getEntity().getName() + "]"
-				);
-			}
-
-		}
-	}
-
 	@Override
 	public Class<? extends EntityPersister> getEntityPersisterClass(PersistentClass metadata) {
 		// todo : make sure this is based on an attribute kept on the metamodel in the new code, not the concrete PersistentClass impl found!
 		if ( RootClass.class.isInstance( metadata ) ) {
             if ( metadata.hasSubclasses() ) {
                 //If the class has children, we need to find of which kind
                 metadata = (PersistentClass) metadata.getDirectSubclasses().next();
             }
             else {
 			    return singleTableEntityPersister();
             }
 		}
 		if ( JoinedSubclass.class.isInstance( metadata ) ) {
 			return joinedSubclassEntityPersister();
 		}
 		else if ( UnionSubclass.class.isInstance( metadata ) ) {
 			return unionSubclassEntityPersister();
 		}
         else if ( SingleTableSubclass.class.isInstance( metadata ) ) {
 			return singleTableEntityPersister();
 		}
 		else {
 			throw new UnknownPersisterException(
 					"Could not determine persister implementation for entity [" + metadata.getEntityName() + "]"
 			);
 		}
 	}
 
     public Class<? extends EntityPersister> singleTableEntityPersister() {
 		return SingleTableEntityPersister.class;
 	}
 
 	public Class<? extends EntityPersister> joinedSubclassEntityPersister() {
 		return JoinedSubclassEntityPersister.class;
 	}
 
 	public Class<? extends EntityPersister> unionSubclassEntityPersister() {
 		return UnionSubclassEntityPersister.class;
 	}
 
 	@Override
 	public Class<? extends CollectionPersister> getCollectionPersisterClass(Collection metadata) {
 		return metadata.isOneToMany() ? oneToManyPersister() : basicCollectionPersister();
 	}
 
-	@Override
-	public Class<? extends CollectionPersister> getCollectionPersisterClass(PluralAttributeBinding metadata) {
-		return metadata.getCollectionElement().getCollectionElementNature() == CollectionElementNature.ONE_TO_MANY
-				? oneToManyPersister()
-				: basicCollectionPersister();
-	}
-
 	private Class<OneToManyPersister> oneToManyPersister() {
 		return OneToManyPersister.class;
 	}
 
 	private Class<BasicCollectionPersister> basicCollectionPersister() {
 		return BasicCollectionPersister.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterClassResolver.java b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterClassResolver.java
index 3ce6e660a0..290c4463a7 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterClassResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterClassResolver.java
@@ -1,86 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.spi;
 
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.Service;
 
 /**
  * Given an entity or collection mapping, resolve the appropriate persister class to use.
  * <p/>
  * The persister class is chosen according to the following rules:<ol>
  *     <li>the persister class defined explicitly via annotation or XML</li>
  *     <li>the persister class returned by the installed {@link PersisterClassResolver}</li>
  *     <li>the default provider as chosen by Hibernate Core (best choice most of the time)</li>
  * </ol>
  *
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  * @author Steve Ebersole
  */
 public interface PersisterClassResolver extends Service {
 	/**
 	 * Returns the entity persister class for a given entityName or null
 	 * if the entity persister class should be the default.
 	 *
 	 * @param metadata The entity metadata
 	 *
 	 * @return The entity persister class to use
 	 */
 	Class<? extends EntityPersister> getEntityPersisterClass(PersistentClass metadata);
 
 	/**
-	 * Returns the entity persister class for a given entityName or null
-	 * if the entity persister class should be the default.
-	 *
-	 * @param metadata The entity metadata
-	 *
-	 * @return The entity persister class to use
-	 */
-	Class<? extends EntityPersister> getEntityPersisterClass(EntityBinding metadata);
-
-	/**
 	 * Returns the collection persister class for a given collection role or null
 	 * if the collection persister class should be the default.
 	 *
 	 * @param metadata The collection metadata
 	 *
 	 * @return The collection persister class to use
 	 */
 	Class<? extends CollectionPersister> getCollectionPersisterClass(Collection metadata);
-
-	/**
-	 * Returns the collection persister class for a given collection role or null
-	 * if the collection persister class should be the default.
-	 *
-	 * @param metadata The collection metadata
-	 *
-	 * @return The collection persister class to use
-	 */
-	Class<? extends CollectionPersister> getCollectionPersisterClass(PluralAttributeBinding metadata);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
index d03b20816a..d42dbe6823 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
@@ -1,131 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.spi;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.Service;
 
 /**
  * Contract for creating persister instances (both {@link EntityPersister} and {@link CollectionPersister} varieties).
  *
  * @author Steve Ebersole
  */
 public interface PersisterFactory extends Service {
 
 	// TODO: is it really necessary to provide Configuration to CollectionPersisters ?
 	// Should it not be enough with associated class ? or why does EntityPersister's not get access to configuration ?
 	//
 	// The only reason I could see that Configuration gets passed to collection persisters
 	// is so that they can look up the dom4j node name of the entity element in case
 	// no explicit node name was applied at the collection element level.  Are you kidding me?
 	// Trivial to fix then.  Just store and expose the node name on the entity persister
 	// (which the collection persister looks up anyway via other means...).
 
 	/**
 	 * Create an entity persister instance.
 	 *
 	 * @param model The O/R mapping metamodel definition for the entity
 	 * @param cacheAccessStrategy The caching strategy for this entity
 	 * @param factory The session factory
 	 * @param cfg The overall mapping
 	 *
 	 * @return An appropriate entity persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public EntityPersister createEntityPersister(
 			PersistentClass model,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			NaturalIdRegionAccessStrategy naturalIdAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) throws HibernateException;
 
 	/**
-	 * Create an entity persister instance.
-	 *
-	 * @param model The O/R mapping metamodel definition for the entity
-	 * @param cacheAccessStrategy The caching strategy for this entity
-	 * @param factory The session factory
-	 * @param cfg The overall mapping
-	 *
-	 * @return An appropriate entity persister instance.
-	 *
-	 * @throws HibernateException Indicates a problem building the persister.
-	 */
-	public EntityPersister createEntityPersister(
-			EntityBinding model,
-			EntityRegionAccessStrategy cacheAccessStrategy,
-			SessionFactoryImplementor factory,
-			Mapping cfg) throws HibernateException;
-
-	/**
 	 * Create a collection persister instance.
 	 *
 	 * @param cfg The configuration
 	 * @param model The O/R mapping metamodel definition for the collection
 	 * @param cacheAccessStrategy The caching strategy for this collection
 	 * @param factory The session factory
 	 *
 	 * @return An appropriate collection persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public CollectionPersister createCollectionPersister(
 			Configuration cfg,
 			Collection model,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException;
 
-	/**
-	 * Create a collection persister instance.
-	 *
-	 * @param metadata The metadata
-	 * @param model The O/R mapping metamodel definition for the collection
-	 * @param cacheAccessStrategy The caching strategy for this collection
-	 * @param factory The session factory
-	 *
-	 * @return An appropriate collection persister instance.
-	 *
-	 * @throws HibernateException Indicates a problem building the persister.
-	 */
-	public CollectionPersister createCollectionPersister(
-			MetadataImplementor metadata,
-			PluralAttributeBinding model,
-			CollectionRegionAccessStrategy cacheAccessStrategy,
-			SessionFactoryImplementor factory) throws HibernateException;
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java b/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java
index bc5969935a..08b061a3ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/property/PropertyAccessorFactory.java
@@ -1,168 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.property;
 
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.binding.AttributeBinding;
 
 /**
  * A factory for building/retrieving PropertyAccessor instances.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public final class PropertyAccessorFactory {
 
 	private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();
 	private static final PropertyAccessor DIRECT_PROPERTY_ACCESSOR = new DirectPropertyAccessor();
 	private static final PropertyAccessor MAP_ACCESSOR = new MapAccessor();
 	private static final PropertyAccessor NOOP_ACCESSOR = new NoopAccessor();
 	private static final PropertyAccessor EMBEDDED_PROPERTY_ACCESSOR = new EmbeddedPropertyAccessor();
 
 	//TODO: ideally we need the construction of PropertyAccessor to take the following:
 	//      1) EntityMode
 	//      2) EntityMode-specific data (i.e., the classname for pojo entities)
 	//      3) Property-specific data based on the EntityMode (i.e., property-name or dom4j-node-name)
 	// The easiest way, with the introduction of the new runtime-metamodel classes, would be the
 	// the following predicates:
 	//      1) PropertyAccessorFactory.getPropertyAccessor() takes references to both a
 	//          org.hibernate.metadata.EntityModeMetadata and org.hibernate.metadata.Property
 	//      2) What is now termed a "PropertyAccessor" stores any values needed from those two
 	//          pieces of information
 	//      3) Code can then simply call PropertyAccess.getGetter() with no parameters; likewise with
 	//          PropertyAccessor.getSetter()
 
     /**
      * Retrieves a PropertyAccessor instance based on the given property definition and
      * entity mode.
      *
      * @param property The property for which to retrieve an accessor.
      * @param mode The mode for the resulting entity.
      * @return An appropriate accessor.
      * @throws MappingException
      */
 	public static PropertyAccessor getPropertyAccessor(Property property, EntityMode mode) throws MappingException {
 		//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
 	    if ( null == mode || EntityMode.POJO.equals( mode ) ) {
 		    return getPojoPropertyAccessor( property.getPropertyAccessorName() );
 	    }
 	    else if ( EntityMode.MAP.equals( mode ) ) {
 		    return getDynamicMapPropertyAccessor();
 	    }
 	    else {
 		    throw new MappingException( "Unknown entity mode [" + mode + "]" );
 	    }
 	}
 
-	/**
-     * Retrieves a PropertyAccessor instance based on the given property definition and
-     * entity mode.
-     *
-     * @param property The property for which to retrieve an accessor.
-     * @param mode The mode for the resulting entity.
-     * @return An appropriate accessor.
-     * @throws MappingException
-     */
-	public static PropertyAccessor getPropertyAccessor(AttributeBinding property, EntityMode mode) throws MappingException {
-		//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
-	    if ( null == mode || EntityMode.POJO.equals( mode ) ) {
-		    return getPojoPropertyAccessor( property.getPropertyAccessorName() );
-	    }
-	    else if ( EntityMode.MAP.equals( mode ) ) {
-		    return getDynamicMapPropertyAccessor();
-	    }
-	    else {
-		    throw new MappingException( "Unknown entity mode [" + mode + "]" );
-	    }
-	}
 
 	/**
 	 * Retreives a PropertyAccessor specific for a PojoRepresentation with the given access strategy.
 	 *
 	 * @param pojoAccessorStrategy The access strategy.
 	 * @return An appropriate accessor.
 	 */
 	private static PropertyAccessor getPojoPropertyAccessor(String pojoAccessorStrategy) {
 		if ( StringHelper.isEmpty( pojoAccessorStrategy ) || "property".equals( pojoAccessorStrategy ) ) {
 			return BASIC_PROPERTY_ACCESSOR;
 		}
 		else if ( "field".equals( pojoAccessorStrategy ) ) {
 			return DIRECT_PROPERTY_ACCESSOR;
 		}
 		else if ( "embedded".equals( pojoAccessorStrategy ) ) {
 			return EMBEDDED_PROPERTY_ACCESSOR;
 		}
 		else if ( "noop".equals(pojoAccessorStrategy) ) {
 			return NOOP_ACCESSOR;
 		}
 		else {
 			return resolveCustomAccessor( pojoAccessorStrategy );
 		}
 	}
 
 	public static PropertyAccessor getDynamicMapPropertyAccessor() throws MappingException {
 		return MAP_ACCESSOR;
 	}
 
 	private static PropertyAccessor resolveCustomAccessor(String accessorName) {
 		Class accessorClass;
 		try {
 			accessorClass = ReflectHelper.classForName( accessorName );
 		}
 		catch (ClassNotFoundException cnfe) {
 			throw new MappingException("could not find PropertyAccessor class: " + accessorName, cnfe);
 		}
 		try {
 			return (PropertyAccessor) accessorClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new MappingException("could not instantiate PropertyAccessor class: " + accessorName, e);
 		}
 	}
 
 	private PropertyAccessorFactory() {}
 
 	// todo : this eventually needs to be removed
 	public static PropertyAccessor getPropertyAccessor(Class optionalClass, String type) throws MappingException {
 		if ( type==null ) type = optionalClass==null || optionalClass==Map.class ? "map" : "property";
 		return getPropertyAccessor(type);
 	}
 
 	// todo : this eventually needs to be removed
 	public static PropertyAccessor getPropertyAccessor(String type) throws MappingException {
 		if ( type==null || "property".equals(type) ) return BASIC_PROPERTY_ACCESSOR;
 		if ( "field".equals(type) ) return DIRECT_PROPERTY_ACCESSOR;
 		if ( "map".equals(type) ) return MAP_ACCESSOR;
 		if ( "embedded".equals(type) ) return EMBEDDED_PROPERTY_ACCESSOR;
 		if ( "noop".equals(type)) return NOOP_ACCESSOR;
 
 		return resolveCustomAccessor(type);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/spi/JaccIntegrator.java b/hibernate-core/src/main/java/org/hibernate/secure/spi/JaccIntegrator.java
index c16c9b04b8..3814aa9ae4 100644
--- a/hibernate-core/src/main/java/org/hibernate/secure/spi/JaccIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/spi/JaccIntegrator.java
@@ -1,131 +1,122 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.secure.spi;
 
 import java.util.Map;
 
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.ServiceContributingIntegrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.secure.internal.DisabledJaccServiceImpl;
 import org.hibernate.secure.internal.JaccPreDeleteEventListener;
 import org.hibernate.secure.internal.JaccPreInsertEventListener;
 import org.hibernate.secure.internal.JaccPreLoadEventListener;
 import org.hibernate.secure.internal.JaccPreUpdateEventListener;
 import org.hibernate.secure.internal.JaccSecurityListener;
 import org.hibernate.secure.internal.StandardJaccServiceImpl;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * Integrator for setting up JACC integration
  *
  * @author Steve Ebersole
  */
 public class JaccIntegrator implements ServiceContributingIntegrator {
 	private static final Logger log = Logger.getLogger( JaccIntegrator.class );
 
 	private static final DuplicationStrategy DUPLICATION_STRATEGY = new DuplicationStrategy() {
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			return listener.getClass().equals( original.getClass() ) &&
 					JaccSecurityListener.class.isInstance( original );
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	};
 
 	@Override
 	public void prepareServices(StandardServiceRegistryBuilder serviceRegistryBuilder) {
 		boolean isSecurityEnabled = serviceRegistryBuilder.getSettings().containsKey( AvailableSettings.JACC_ENABLED );
 		final JaccService jaccService = isSecurityEnabled ? new StandardJaccServiceImpl() : new DisabledJaccServiceImpl();
 		serviceRegistryBuilder.addService( JaccService.class, jaccService );
 	}
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		doIntegration( configuration.getProperties(), configuration.getJaccPermissionDeclarations(), serviceRegistry );
 	}
 
 	private void doIntegration(
 			Map properties,
 			JaccPermissionDeclarations permissionDeclarations,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		boolean isSecurityEnabled = properties.containsKey( AvailableSettings.JACC_ENABLED );
 		if ( ! isSecurityEnabled ) {
 			log.debug( "Skipping JACC integration as it was not enabled" );
 			return;
 		}
 
 		final String contextId = (String) properties.get( AvailableSettings.JACC_CONTEXT_ID );
 		if ( contextId == null ) {
 			throw new IntegrationException( "JACC context id must be specified" );
 		}
 
 		final JaccService jaccService = serviceRegistry.getService( JaccService.class );
 		if ( jaccService == null ) {
 			throw new IntegrationException( "JaccService was not set up" );
 		}
 
 		if ( permissionDeclarations != null ) {
 			for ( GrantedPermission declaration : permissionDeclarations.getPermissionDeclarations() ) {
 				jaccService.addPermission( declaration );
 			}
 		}
 
 		final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		eventListenerRegistry.addDuplicationStrategy( DUPLICATION_STRATEGY );
 
 		eventListenerRegistry.prependListeners( EventType.PRE_DELETE, new JaccPreDeleteEventListener() );
 		eventListenerRegistry.prependListeners( EventType.PRE_INSERT, new JaccPreInsertEventListener() );
 		eventListenerRegistry.prependListeners( EventType.PRE_UPDATE, new JaccPreUpdateEventListener() );
 		eventListenerRegistry.prependListeners( EventType.PRE_LOAD, new JaccPreLoadEventListener() );
 	}
 
 	@Override
-	public void integrate(
-			MetadataImplementor metadata,
-			SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		doIntegration( sessionFactory.getProperties(), null, serviceRegistry );
-	}
-
-	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java b/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
index 898ede4efc..9aa288345d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
@@ -1,283 +1,283 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.ValidationEventHandler;
 import javax.xml.bind.ValidationEventLocator;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Namespace;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.EventReaderDelegate;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
+import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
 import org.hibernate.internal.util.config.ConfigurationException;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.XsdException;
+import org.hibernate.internal.util.xml.XsdException;
 
 import org.jboss.logging.Logger;
 
 import org.xml.sax.SAXException;
 
 /**
  * @author Steve Ebersole
  */
 public class JaxbProcessor {
 	private static final Logger log = Logger.getLogger( JaxbProcessor.class );
 
 	public static final String HIBERNATE_CONFIGURATION_URI = "http://www.hibernate.org/xsd/hibernate-configuration";
 
 	private final ClassLoaderService classLoaderService;
 
 	public JaxbProcessor(ClassLoaderService classLoaderService) {
 		this.classLoaderService = classLoaderService;
 	}
 
 	public JaxbHibernateConfiguration unmarshal(InputStream stream, Origin origin) {
 		try {
 			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			try {
 				return unmarshal( staxReader, origin );
 			}
 			finally {
 				try {
 					staxReader.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( XMLStreamException e ) {
-			throw new MappingException( "Unable to create stax reader", e, origin );
+			throw new HibernateException( "Unable to create stax reader", e );
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "unchecked" })
 	private JaxbHibernateConfiguration unmarshal(XMLEventReader staxEventReader, final Origin origin) {
 		XMLEvent event;
 		try {
 			event = staxEventReader.peek();
 			while ( event != null && !event.isStartElement() ) {
 				staxEventReader.nextEvent();
 				event = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
-			throw new MappingException( "Error accessing stax stream", e, origin );
+			throw new HibernateException( "Error accessing stax stream", e );
 		}
 
 		if ( event == null ) {
-			throw new MappingException( "Could not locate root element", origin );
+			throw new HibernateException( "Could not locate root element" );
 		}
 
 		if ( !isNamespaced( event.asStartElement() ) ) {
 			// if the elements are not namespaced, wrap the reader in a reader which will namespace them as pulled.
 			log.debug( "cfg.xml document did not define namespaces; wrapping in custom event reader to introduce namespace information" );
 			staxEventReader = new NamespaceAddingEventReader( staxEventReader, HIBERNATE_CONFIGURATION_URI );
 		}
 
 		final Object target;
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( JaxbHibernateConfiguration.class );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( schema() );
 			unmarshaller.setEventHandler( handler );
 			target = unmarshaller.unmarshal( staxEventReader );
 			return (JaxbHibernateConfiguration) target;
 		}
 		catch ( JAXBException e ) {
 			StringBuilder builder = new StringBuilder();
 			builder.append( "Unable to perform unmarshalling at line number " )
 					.append( handler.getLineNumber() )
 					.append( " and column " )
 					.append( handler.getColumnNumber() )
 					.append( " in " ).append( origin.getType().name() ).append( " " ).append( origin.getName() )
 					.append( ". Message: " )
 					.append( handler.getMessage() );
 			throw new ConfigurationException( builder.toString(), e );
 		}
 	}
 
 	private boolean isNamespaced(StartElement startElement) {
 		return ! "".equals( startElement.getName().getNamespaceURI() );
 	}
 
 	private Schema schema;
 
 	private Schema schema() {
 		if ( schema == null ) {
 			schema = resolveLocalSchema( "org/hibernate/hibernate-configuration-4.0.xsd" );
 		}
 		return schema;
 	}
 
 	private Schema resolveLocalSchema(String schemaName) {
 		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
 	}
 
 	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
 		URL url = classLoaderService.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					log.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
 		private int lineNumber;
 		private int columnNumber;
 		private String message;
 
 		@Override
 		public boolean handleEvent(ValidationEvent validationEvent) {
 			ValidationEventLocator locator = validationEvent.getLocator();
 			lineNumber = locator.getLineNumber();
 			columnNumber = locator.getColumnNumber();
 			message = validationEvent.getMessage();
 			return false;
 		}
 
 		public int getLineNumber() {
 			return lineNumber;
 		}
 
 		public int getColumnNumber() {
 			return columnNumber;
 		}
 
 		public String getMessage() {
 			return message;
 		}
 	}
 
 	public class NamespaceAddingEventReader extends EventReaderDelegate {
 		private final XMLEventFactory xmlEventFactory;
 		private final String namespaceUri;
 
 		public NamespaceAddingEventReader(XMLEventReader reader, String namespaceUri) {
 			this( reader, XMLEventFactory.newInstance(), namespaceUri );
 		}
 
 		public NamespaceAddingEventReader(XMLEventReader reader, XMLEventFactory xmlEventFactory, String namespaceUri) {
 			super( reader );
 			this.xmlEventFactory = xmlEventFactory;
 			this.namespaceUri = namespaceUri;
 		}
 
 		private StartElement withNamespace(StartElement startElement) {
 			// otherwise, wrap the start element event to provide a default namespace mapping
 			final List<Namespace> namespaces = new ArrayList<Namespace>();
 			namespaces.add( xmlEventFactory.createNamespace( "", namespaceUri ) );
 			Iterator<?> originalNamespaces = startElement.getNamespaces();
 			while ( originalNamespaces.hasNext() ) {
 				namespaces.add( (Namespace) originalNamespaces.next() );
 			}
 			return xmlEventFactory.createStartElement(
 					new QName( namespaceUri, startElement.getName().getLocalPart() ),
 					startElement.getAttributes(),
 					namespaces.iterator()
 			);
 		}
 
 		@Override
 		public XMLEvent nextEvent() throws XMLStreamException {
 			XMLEvent event = super.nextEvent();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			return event;
 		}
 
 		@Override
 		public XMLEvent peek() throws XMLStreamException {
 			XMLEvent event = super.peek();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			else {
 				return event;
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
index ab12132940..53d4447c08 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
@@ -1,60 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 
 /**
  * Acts as a {@link Service} in the {@link org.hibernate.boot.registry.internal.StandardServiceRegistryImpl} whose function is as a factory for
  * {@link SessionFactoryServiceRegistryImpl} implementations.
  *
  * @author Steve Ebersole
  */
 public class SessionFactoryServiceRegistryFactoryImpl implements SessionFactoryServiceRegistryFactory {
 	private final ServiceRegistryImplementor theBasicServiceRegistry;
 
 	public SessionFactoryServiceRegistryFactoryImpl(ServiceRegistryImplementor theBasicServiceRegistry) {
 		this.theBasicServiceRegistry = theBasicServiceRegistry;
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration) {
 		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, configuration );
 	}
-
-	@Override
-	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata) {
-		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, metadata );
-	}
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
index 2f0dd5ae04..feb3e6614d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
@@ -1,102 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.ServiceBinding;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class SessionFactoryServiceRegistryImpl extends AbstractServiceRegistryImpl implements SessionFactoryServiceRegistry  {
 
 	// for now we need to hold on to the Configuration... :(
 	private final Configuration configuration;
-	private final MetadataImplementor metadata;
 	private final SessionFactoryImplementor sessionFactory;
 
 	@SuppressWarnings( {"unchecked"})
 	public SessionFactoryServiceRegistryImpl(
 			ServiceRegistryImplementor parent,
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration) {
 		super( parent );
 
 		this.sessionFactory = sessionFactory;
 		this.configuration = configuration;
-		this.metadata = null;
-
-		// for now, just use the standard initiator list
-		for ( SessionFactoryServiceInitiator initiator : StandardSessionFactoryServiceInitiators.LIST ) {
-			// create the bindings up front to help identify to which registry services belong
-			createServiceBinding( initiator );
-		}
-	}
-
-	@SuppressWarnings( {"unchecked"})
-	public SessionFactoryServiceRegistryImpl(
-			ServiceRegistryImplementor parent,
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata) {
-		super( parent );
-
-		this.sessionFactory = sessionFactory;
-		this.configuration = null;
-		this.metadata = metadata;
 
 		// for now, just use the standard initiator list
 		for ( SessionFactoryServiceInitiator initiator : StandardSessionFactoryServiceInitiators.LIST ) {
 			// create the bindings up front to help identify to which registry services belong
 			createServiceBinding( initiator );
 		}
 	}
 
 	@Override
 	public <R extends Service> R initiateService(ServiceInitiator<R> serviceInitiator) {
 		// todo : add check/error for unexpected initiator types?
 		SessionFactoryServiceInitiator<R> sessionFactoryServiceInitiator =
 				(SessionFactoryServiceInitiator<R>) serviceInitiator;
-		if ( metadata != null ) {
-			return sessionFactoryServiceInitiator.initiateService( sessionFactory, metadata, this );
-		}
-		else if ( configuration != null ) {
+		if ( configuration != null ) {
 			return sessionFactoryServiceInitiator.initiateService( sessionFactory, configuration, this );
 		}
 		else {
-			throw new IllegalStateException( "Both metadata and configuration are null." );
+			throw new IllegalStateException( "Configuration was null." );
 		}
 	}
 
 	@Override
 	public <R extends Service> void configureService(ServiceBinding<R> serviceBinding) {
 		//TODO nothing to do here or should we inject SessionFactory properties?
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
index 9e169360aa..f01a3ee1ab 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
@@ -1,66 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 
 /**
  * Contract for an initiator of services that target the specialized service registry
  * {@link SessionFactoryServiceRegistry}
  *
  * @author Steve Ebersole
  */
 public interface SessionFactoryServiceInitiator<R extends Service> extends ServiceInitiator<R>{
 	/**
 	 * Initiates the managed service.
 	 * <p/>
 	 * Note for implementors: signature is guaranteed to change once redesign of SessionFactory building is complete
 	 *
 	 * @param sessionFactory The session factory.  Note the the session factory is still in flux; care needs to be taken
 	 * in regards to what you call.
 	 * @param configuration The configuration.
 	 * @param registry The service registry.  Can be used to locate services needed to fulfill initiation.
 	 *
 	 * @return The initiated service.
 	 */
 	public R initiateService(SessionFactoryImplementor sessionFactory, Configuration configuration, ServiceRegistryImplementor registry);
 
-	/**
-	 * Initiates the managed service.
-	 * <p/>
-	 * Note for implementors: signature is guaranteed to change once redesign of SessionFactory building is complete
-	 *
-	 * @param sessionFactory The session factory.  Note the the session factory is still in flux; care needs to be taken
-	 * in regards to what you call.
-	 * @param metadata The configuration.
-	 * @param registry The service registry.  Can be used to locate services needed to fulfill initiation.
-	 *
-	 * @return The initiated service.
-	 */
-	public R initiateService(SessionFactoryImplementor sessionFactory, MetadataImplementor metadata, ServiceRegistryImplementor registry);
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
index dbf86a1ab4..c58f7f3253 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
@@ -1,71 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.internal.SessionFactoryServiceRegistryImpl;
 
 /**
  * Contract for builder of {@link SessionFactoryServiceRegistry} instances.
  * <p/>
  * Is itself a service within the standard service registry.
  *
  * @author Steve Ebersole
  */
 public interface SessionFactoryServiceRegistryFactory extends Service {
 	/**
 	 * Create the registry.
 	 *
 	 * @todo : fully expect this signature to change!
 	 *
 	 * @param sessionFactory The (in flux) session factory.  Generally this is useful for grabbing a reference for later
 	 * 		use.  However, care should be taken when invoking on the session factory until after it has been fully
 	 * 		initialized.
 	 * @param configuration The configuration object.
 	 *
 	 * @return The registry
 	 */
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration);
 
-	/**
-	 * Create the registry.
-	 *
-	 * @todo : fully expect this signature to change!
-	 *
-	 * @param sessionFactory The (in flux) session factory.  Generally this is useful for grabbing a reference for later
-	 * 		use.  However, care should be taken when invoking on the session factory until after it has been fully
-	 * 		initialized.
-	 * @param metadata The configuration object.
-	 *
-	 * @return The registry
-	 */
-	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
index 067d479a59..2e9eb5eca7 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
@@ -1,120 +1,108 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.internal;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 import org.hibernate.stat.spi.StatisticsFactory;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Steve Ebersole
  */
 public class StatisticsInitiator implements SessionFactoryServiceInitiator<StatisticsImplementor> {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, StatisticsInitiator.class.getName() );
 
 	public static final StatisticsInitiator INSTANCE = new StatisticsInitiator();
 
 	/**
 	 * Names the {@link StatisticsFactory} to use.  Recognizes both a class name as well as an instance of
 	 * {@link StatisticsFactory}.
 	 */
 	public static final String STATS_BUILDER = "hibernate.stats.factory";
 
 	@Override
 	public Class<StatisticsImplementor> getServiceInitiated() {
 		return StatisticsImplementor.class;
 	}
 
 	@Override
 	public StatisticsImplementor initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		final Object configValue = configuration.getProperties().get( STATS_BUILDER );
 		return initiateServiceInternal( sessionFactory, configValue, registry );
 	}
 
-	@Override
-	public StatisticsImplementor initiateService(
-			SessionFactoryImplementor sessionFactory,
-			MetadataImplementor metadata,
-			ServiceRegistryImplementor registry) {
-		ConfigurationService configurationService =  registry.getService( ConfigurationService.class );
-		final Object configValue = configurationService.getSetting( STATS_BUILDER, null );
-		return initiateServiceInternal( sessionFactory, configValue, registry );
-	}
-
 	private StatisticsImplementor initiateServiceInternal(
 			SessionFactoryImplementor sessionFactory,
 			Object configValue,
 			ServiceRegistryImplementor registry) {
 
 		StatisticsFactory statisticsFactory;
 		if ( configValue == null ) {
 			statisticsFactory = DEFAULT_STATS_BUILDER;
 		}
 		else if ( StatisticsFactory.class.isInstance( configValue ) ) {
 			statisticsFactory = (StatisticsFactory) configValue;
 		}
 		else {
 			// assume it names the factory class
 			final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 			try {
 				statisticsFactory = (StatisticsFactory) classLoaderService.classForName( configValue.toString() ).newInstance();
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException(
 						"Unable to instantiate specified StatisticsFactory implementation [" + configValue.toString() + "]",
 						e
 				);
 			}
 		}
 
 		StatisticsImplementor statistics = statisticsFactory.buildStatistics( sessionFactory );
 		final boolean enabled = sessionFactory.getSettings().isStatisticsEnabled();
 		statistics.setStatisticsEnabled( enabled );
 		LOG.debugf( "Statistics initialized [enabled=%s]", enabled );
 		return statistics;
 	}
 
 	private static StatisticsFactory DEFAULT_STATS_BUILDER = new StatisticsFactory() {
 		@Override
 		public StatisticsImplementor buildStatistics(SessionFactoryImplementor sessionFactory) {
 			return new ConcurrentStatisticsImpl( sessionFactory );
 		}
 	};
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
index 407659fd18..6bd83e380d 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
@@ -1,627 +1,604 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.Writer;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.internal.Formatter;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.ServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * Commandline tool to export table schema to the database. This class may also be called from inside an application.
  *
  * @author Daniel Bradby
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class SchemaExport {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SchemaExport.class.getName());
 	private static final String DEFAULT_IMPORT_FILE = "/import.sql";
 
 	public static enum Type {
 		CREATE,
 		DROP,
 		NONE,
 		BOTH;
 
 		public boolean doCreate() {
 			return this == BOTH || this == CREATE;
 		}
 
 		public boolean doDrop() {
 			return this == BOTH || this == DROP;
 		}
 	}
 
 	private final ConnectionHelper connectionHelper;
 	private final SqlStatementLogger sqlStatementLogger;
 	private final SqlExceptionHelper sqlExceptionHelper;
 	private final String[] dropSQL;
 	private final String[] createSQL;
 	private final String importFiles;
 
 	private final List<Exception> exceptions = new ArrayList<Exception>();
 
 	private Formatter formatter;
 	private ImportSqlCommandExtractor importSqlCommandExtractor = ImportSqlCommandExtractorInitiator.DEFAULT_EXTRACTOR;
 
 	private String outputFile;
 	private String delimiter;
 	private boolean haltOnError;
 
 	public SchemaExport(ServiceRegistry serviceRegistry, Configuration configuration) {
 		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper(
 				serviceRegistry.getService( ConnectionProvider.class )
 		);
 		this.sqlStatementLogger = serviceRegistry.getService( JdbcServices.class ).getSqlStatementLogger();
 		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		this.sqlExceptionHelper = serviceRegistry.getService( JdbcServices.class ).getSqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				configuration.getProperties(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
-	public SchemaExport(MetadataImplementor metadata) {
-		ServiceRegistry serviceRegistry = metadata.getServiceRegistry();
-		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper(
-				serviceRegistry.getService( ConnectionProvider.class )
-		);
-        JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
-		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
-		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
-		this.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();
-
-		this.importFiles = ConfigurationHelper.getString(
-				AvailableSettings.HBM2DDL_IMPORT_FILES,
-				serviceRegistry.getService( ConfigurationService.class ).getSettings(),
-				DEFAULT_IMPORT_FILE
-		);
-
-		final Dialect dialect = jdbcServices.getDialect();
-		this.dropSQL = metadata.getDatabase().generateDropSchemaScript( dialect );
-		this.createSQL = metadata.getDatabase().generateSchemaCreationScript( dialect );
-	}
-
 	/**
 	 * Create a schema exporter for the given Configuration
 	 *
 	 * @param configuration The configuration from which to build a schema export.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 */
 	public SchemaExport(Configuration configuration) {
 		this( configuration, configuration.getProperties() );
 	}
 
 	/**
 	 * Create a schema exporter for the given Configuration, with the given
 	 * database connection properties.
 	 *
 	 * @param configuration The configuration from which to build a schema export.
 	 * @param properties The properties from which to configure connectivity etc.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 *
 	 * @deprecated properties may be specified via the Configuration object
 	 */
 	@Deprecated
     public SchemaExport(Configuration configuration, Properties properties) throws HibernateException {
 		final Dialect dialect = Dialect.getDialect( properties );
 
 		Properties props = new Properties();
 		props.putAll( dialect.getDefaultProperties() );
 		props.putAll( properties );
 		this.connectionHelper = new ManagedProviderConnectionHelper( props );
 
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.formatter = FormatStyle.DDL.getFormatter();
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				properties,
 				DEFAULT_IMPORT_FILE
 		);
 
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
 	/**
 	 * Create a schema exporter for the given Configuration, using the supplied connection for connectivity.
 	 *
 	 * @param configuration The configuration to use.
 	 * @param connection The JDBC connection to use.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 */
 	public SchemaExport(Configuration configuration, Connection connection) throws HibernateException {
 		this.connectionHelper = new SuppliedConnectionHelper( connection );
 
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.formatter = FormatStyle.DDL.getFormatter();
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				configuration.getProperties(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		final Dialect dialect = Dialect.getDialect( configuration.getProperties() );
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
 	public SchemaExport(
 			ConnectionHelper connectionHelper,
 			String[] dropSql,
 			String[] createSql) {
 		this.connectionHelper = connectionHelper;
 		this.dropSQL = dropSql;
 		this.createSQL = createSql;
 		this.importFiles = "";
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 		this.formatter = FormatStyle.DDL.getFormatter();
 	}
 
 	/**
 	 * For generating a export script file, this is the file which will be written.
 	 *
 	 * @param filename The name of the file to which to write the export script.
 	 * @return this
 	 */
 	public SchemaExport setOutputFile(String filename) {
 		outputFile = filename;
 		return this;
 	}
 
 	/**
 	 * Set the end of statement delimiter
 	 *
 	 * @param delimiter The delimiter
 	 * @return this
 	 */
 	public SchemaExport setDelimiter(String delimiter) {
 		this.delimiter = delimiter;
 		return this;
 	}
 
 	/**
 	 * Should we format the sql strings?
 	 *
 	 * @param format Should we format SQL strings
 	 * @return this
 	 */
 	public SchemaExport setFormat(boolean format) {
 		this.formatter = ( format ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		return this;
 	}
 
 	/**
 	 * Set <i>import.sql</i> command extractor. By default {@link SingleLineSqlCommandExtractor} is used.
 	 *
 	 * @param importSqlCommandExtractor <i>import.sql</i> command extractor.
 	 * @return this
 	 */
 	public SchemaExport setImportSqlCommandExtractor(ImportSqlCommandExtractor importSqlCommandExtractor) {
 		this.importSqlCommandExtractor = importSqlCommandExtractor;
 		return this;
 	}
 
 	/**
 	 * Should we stop once an error occurs?
 	 *
 	 * @param haltOnError True if export should stop after error.
 	 * @return this
 	 */
 	public SchemaExport setHaltOnError(boolean haltOnError) {
 		this.haltOnError = haltOnError;
 		return this;
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void create(boolean script, boolean export) {
 		create( Target.interpret( script, export ) );
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param output the target of the script.
 	 */
 	public void create(Target output) {
 		// need to drop tables before creating so need to specify Type.BOTH
 		execute( output, Type.BOTH );
 	}
 
 	/**
 	 * Run the drop schema script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void drop(boolean script, boolean export) {
 		drop( Target.interpret( script, export ) );
 	}
 
 	public void drop(Target output) {
 		execute( output, Type.DROP );
 	}
 
 	public void execute(boolean script, boolean export, boolean justDrop, boolean justCreate) {
 		execute( Target.interpret( script, export ), interpretType( justDrop, justCreate ) );
 	}
 
 	private Type interpretType(boolean justDrop, boolean justCreate) {
 		if ( justDrop ) {
 			return Type.DROP;
 		}
 		else if ( justCreate ) {
 			return Type.CREATE;
 		}
 		else {
 			return Type.BOTH;
 		}
 	}
 
 	public void execute(Target output, Type type) {
 		if ( (outputFile == null && output == Target.NONE) || type == SchemaExport.Type.NONE ) {
 			return;
 		}
 		exceptions.clear();
 
 		LOG.runningHbm2ddlSchemaExport();
 
 		final List<NamedReader> importFileReaders = new ArrayList<NamedReader>();
 		for ( String currentFile : importFiles.split(",") ) {
 			try {
 				final String resourceName = currentFile.trim();
 				InputStream stream = ConfigHelper.getResourceAsStream( resourceName );
 				importFileReaders.add( new NamedReader( resourceName, stream ) );
 			}
 			catch ( HibernateException e ) {
 				LOG.debugf("Import file not found: %s", currentFile);
 			}
 		}
 
 		final List<Exporter> exporters = new ArrayList<Exporter>();
 		try {
 			// prepare exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( output.doScript() ) {
 				exporters.add( new ScriptExporter() );
 			}
 			if ( outputFile != null ) {
 				exporters.add( new FileExporter( outputFile ) );
 			}
 			if ( output.doExport() ) {
 				exporters.add( new DatabaseExporter( connectionHelper, sqlExceptionHelper ) );
 			}
 
 			// perform exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( type.doDrop() ) {
 				perform( dropSQL, exporters );
 			}
 			if ( type.doCreate() ) {
 				perform( createSQL, exporters );
 				if ( ! importFileReaders.isEmpty() ) {
 					for ( NamedReader namedReader : importFileReaders ) {
 						importScript( namedReader, exporters );
 					}
 				}
 			}
 		}
 		catch (Exception e) {
 			exceptions.add( e );
 			LOG.schemaExportUnsuccessful( e );
 		}
 		finally {
 			// release exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.release();
 				}
 				catch (Exception ignore) {
 				}
 			}
 
 			// release the named readers from import scripts
 			for ( NamedReader namedReader : importFileReaders ) {
 				try {
 					namedReader.getReader().close();
 				}
 				catch (Exception ignore) {
 				}
 			}
             LOG.schemaExportComplete();
 		}
 	}
 
 	private void perform(String[] sqlCommands, List<Exporter> exporters) {
 		for ( String sqlCommand : sqlCommands ) {
 			String formatted = formatter.format( sqlCommand );
 	        if ( delimiter != null ) {
 				formatted += delimiter;
 			}
 			sqlStatementLogger.logStatement( sqlCommand, formatter );
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.export( formatted );
 				}
 				catch (Exception e) {
 					if ( haltOnError ) {
 						throw new HibernateException( "Error during DDL export", e );
 					}
 					exceptions.add( e );
 					LOG.unsuccessfulCreate( sqlCommand );
 					LOG.error( e.getMessage() );
 				}
 			}
 		}
 	}
 
 	private void importScript(NamedReader namedReader, List<Exporter> exporters) throws Exception {
 		BufferedReader reader = new BufferedReader( namedReader.getReader() );
 		String[] statements = importSqlCommandExtractor.extractCommands( reader );
 		if (statements != null) {
 			for ( String statement : statements ) {
 				if ( statement != null ) {
 					String trimmedSql = statement.trim();
 					if ( trimmedSql.endsWith( ";" )) {
 						trimmedSql = trimmedSql.substring( 0, statement.length() - 1 );
 					}
 					if ( !StringHelper.isEmpty( trimmedSql ) ) {
 						try {
 							for ( Exporter exporter : exporters ) {
 								if ( exporter.acceptsImportScripts() ) {
 									exporter.export( trimmedSql );
 								}
 							}
 						}
 						catch ( Exception e ) {
 						  	if (haltOnError) {
 						  		throw new ImportScriptException( "Error during statement execution (file: '"
 						  				+ namedReader.getName() + "'): " + trimmedSql, e );
 							}
 						  	exceptions.add(e);
 						  	LOG.unsuccessful(trimmedSql);
 						  	LOG.error(e.getMessage());
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private static class NamedReader {
 		private final Reader reader;
 		private final String name;
 
 		public NamedReader(String name, InputStream stream) {
 			this.name = name;
 			this.reader = new InputStreamReader( stream );
 		}
 
 		public Reader getReader() {
 			return reader;
 		}
 
 		public String getName() {
 			return name;
 		}
 	}
 
 	private void execute(boolean script, boolean export, Writer fileOutput, Statement statement, final String sql)
 			throws IOException, SQLException {
 		final SqlExceptionHelper sqlExceptionHelper = new SqlExceptionHelper();
 
 		String formatted = formatter.format( sql );
         if (delimiter != null) formatted += delimiter;
         if (script) System.out.println(formatted);
         LOG.debug(formatted);
 		if ( outputFile != null ) {
 			fileOutput.write( formatted + "\n" );
 		}
 		if ( export ) {
 
 			statement.executeUpdate( sql );
 			try {
 				SQLWarning warnings = statement.getWarnings();
 				if ( warnings != null) {
 					sqlExceptionHelper.logAndClearWarnings( connectionHelper.getConnection() );
 				}
 			}
 			catch( SQLException sqle ) {
                 LOG.unableToLogSqlWarnings(sqle);
 			}
 		}
 
 	}
 
 	private static StandardServiceRegistryImpl createServiceRegistry(Properties properties) {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
 		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().applySettings( properties ).build();
 	}
 
 	public static void main(String[] args) {
 		try {
 			Configuration cfg = new Configuration();
 
 			boolean script = true;
 			boolean drop = false;
 			boolean create = false;
 			boolean halt = false;
 			boolean export = true;
 			String outFile = null;
 			String importFile = DEFAULT_IMPORT_FILE;
 			String propFile = null;
 			boolean format = false;
 			String delim = null;
 
 			for ( int i = 0; i < args.length; i++ ) {
 				if ( args[i].startsWith( "--" ) ) {
 					if ( args[i].equals( "--quiet" ) ) {
 						script = false;
 					}
 					else if ( args[i].equals( "--drop" ) ) {
 						drop = true;
 					}
 					else if ( args[i].equals( "--create" ) ) {
 						create = true;
 					}
 					else if ( args[i].equals( "--haltonerror" ) ) {
 						halt = true;
 					}
 					else if ( args[i].equals( "--text" ) ) {
 						export = false;
 					}
 					else if ( args[i].startsWith( "--output=" ) ) {
 						outFile = args[i].substring( 9 );
 					}
 					else if ( args[i].startsWith( "--import=" ) ) {
 						importFile = args[i].substring( 9 );
 					}
 					else if ( args[i].startsWith( "--properties=" ) ) {
 						propFile = args[i].substring( 13 );
 					}
 					else if ( args[i].equals( "--format" ) ) {
 						format = true;
 					}
 					else if ( args[i].startsWith( "--delimiter=" ) ) {
 						delim = args[i].substring( 12 );
 					}
 					else if ( args[i].startsWith( "--config=" ) ) {
 						cfg.configure( args[i].substring( 9 ) );
 					}
 					else if ( args[i].startsWith( "--naming=" ) ) {
 						cfg.setNamingStrategy(
 								( NamingStrategy ) ReflectHelper.classForName( args[i].substring( 9 ) )
 										.newInstance()
 						);
 					}
 				}
 				else {
 					String filename = args[i];
 					if ( filename.endsWith( ".jar" ) ) {
 						cfg.addJar( new File( filename ) );
 					}
 					else {
 						cfg.addFile( filename );
 					}
 				}
 
 			}
 
 			if ( propFile != null ) {
 				Properties props = new Properties();
 				props.putAll( cfg.getProperties() );
 				props.load( new FileInputStream( propFile ) );
 				cfg.setProperties( props );
 			}
 
 			if (importFile != null) {
 				cfg.setProperty( AvailableSettings.HBM2DDL_IMPORT_FILES, importFile );
 			}
 
 			StandardServiceRegistryImpl serviceRegistry = createServiceRegistry( cfg.getProperties() );
 			try {
 				SchemaExport se = new SchemaExport( serviceRegistry, cfg )
 						.setHaltOnError( halt )
 						.setOutputFile( outFile )
 						.setDelimiter( delim )
 						.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
 				if ( format ) {
 					se.setFormat( true );
 				}
 				se.execute( script, export, drop, create );
 			}
 			finally {
 				serviceRegistry.destroy();
 			}
 		}
 		catch ( Exception e ) {
             LOG.unableToCreateSchema(e);
 			e.printStackTrace();
 		}
 	}
 
 	/**
 	 * Returns a List of all Exceptions which occured during the export.
 	 *
 	 * @return A List containig the Exceptions occured during the export
 	 */
 	public List getExceptions() {
 		return exceptions;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
index 2b3b7ad8a2..6493019beb 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
@@ -1,95 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
-
 
 public class DynamicMapInstantiator implements Instantiator {
 	public static final String KEY = "$type$";
 
 	private String entityName;
 	private Set isInstanceEntityNames = new HashSet();
 
 	public DynamicMapInstantiator() {
 		this.entityName = null;
 	}
 
 	public DynamicMapInstantiator(PersistentClass mappingInfo) {
 		this.entityName = mappingInfo.getEntityName();
 		isInstanceEntityNames.add( entityName );
 		if ( mappingInfo.hasSubclasses() ) {
 			Iterator itr = mappingInfo.getSubclassClosureIterator();
 			while ( itr.hasNext() ) {
 				final PersistentClass subclassInfo = ( PersistentClass ) itr.next();
 				isInstanceEntityNames.add( subclassInfo.getEntityName() );
 			}
 		}
 	}
 
-	public DynamicMapInstantiator(EntityBinding mappingInfo) {
-		this.entityName = mappingInfo.getEntity().getName();
-		isInstanceEntityNames.add( entityName );
-		for ( EntityBinding subEntityBinding : mappingInfo.getPostOrderSubEntityBindingClosure() ) {
-			isInstanceEntityNames.add( subEntityBinding.getEntity().getName() );
-		}
-	}
-
 	public final Object instantiate(Serializable id) {
 		return instantiate();
 	}
 
 	public final Object instantiate() {
 		Map map = generateMap();
 		if ( entityName!=null ) {
 			map.put( KEY, entityName );
 		}
 		return map;
 	}
 
 	public final boolean isInstance(Object object) {
 		if ( object instanceof Map ) {
 			if ( entityName == null ) {
 				return true;
 			}
 			String type = ( String ) ( ( Map ) object ).get( KEY );
 			return type == null || isInstanceEntityNames.contains( type );
 		}
 		else {
 			return false;
 		}
 	}
 
 	protected Map generateMap() {
 		return new HashMap();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
index 7ebf894a05..9822fce88c 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
@@ -1,143 +1,125 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 
 import java.io.IOException;
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
 import org.hibernate.InstantiationException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
 
 import org.jboss.logging.Logger;
 
 /**
  * Defines a POJO-based instantiator for use from the tuplizers.
  */
 public class PojoInstantiator implements Instantiator, Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PojoInstantiator.class.getName());
 
 	private transient Constructor constructor;
 
 	private final Class mappedClass;
 	private final transient ReflectionOptimizer.InstantiationOptimizer optimizer;
 	private final boolean embeddedIdentifier;
 	private final Class proxyInterface;
 	private final boolean isAbstract;
 
 	public PojoInstantiator(Component component, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = component.getComponentClass();
 		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
 		this.optimizer = optimizer;
 
 		this.proxyInterface = null;
 		this.embeddedIdentifier = false;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor(mappedClass);
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	public PojoInstantiator(PersistentClass persistentClass, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = persistentClass.getMappedClass();
 		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
 		this.proxyInterface = persistentClass.getProxyInterface();
 		this.embeddedIdentifier = persistentClass.hasEmbeddedIdentifier();
 		this.optimizer = optimizer;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
-	public PojoInstantiator(EntityBinding entityBinding, ReflectionOptimizer.InstantiationOptimizer optimizer) {
-		this.mappedClass = entityBinding.getEntity().getClassReference();
-		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
-		this.proxyInterface = entityBinding.getProxyInterfaceType().getValue();
-		this.embeddedIdentifier = entityBinding.getHierarchyDetails().getEntityIdentifier().isEmbedded();
-		this.optimizer = optimizer;
-
-		try {
-			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
-		}
-		catch ( PropertyNotFoundException pnfe ) {
-			LOG.noDefaultConstructor(mappedClass.getName());
-			constructor = null;
-		}
-	}
-
-	private void readObject(java.io.ObjectInputStream stream)
-	throws ClassNotFoundException, IOException {
+	private void readObject(java.io.ObjectInputStream stream) throws ClassNotFoundException, IOException {
 		stream.defaultReadObject();
 		constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 	}
 
 	public Object instantiate() {
 		if ( isAbstract ) {
 			throw new InstantiationException( "Cannot instantiate abstract class or interface: ", mappedClass );
 		}
 		else if ( optimizer != null ) {
 			return optimizer.newInstance();
 		}
 		else if ( constructor == null ) {
 			throw new InstantiationException( "No default constructor for entity: ", mappedClass );
 		}
 		else {
 			try {
 				return constructor.newInstance( (Object[]) null );
 			}
 			catch ( Exception e ) {
 				throw new InstantiationException( "Could not instantiate entity: ", mappedClass, e );
 			}
 		}
 	}
 
 	public Object instantiate(Serializable id) {
 		final boolean useEmbeddedIdentifierInstanceAsEntity = embeddedIdentifier &&
 				id != null &&
 				id.getClass().equals(mappedClass);
 		return useEmbeddedIdentifierInstanceAsEntity ? id : instantiate();
 	}
 
 	public boolean isInstance(Object object) {
 		return mappedClass.isInstance(object) ||
 				( proxyInterface!=null && proxyInterface.isInstance(object) ); //this one needed only for guessEntityMode()
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
index c9b5d50990..52992816dc 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
@@ -1,513 +1,328 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple;
 
 import java.lang.reflect.Constructor;
 
 import org.hibernate.EntityMode;
-import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
-import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.internal.UnsavedValueFactory;
-import org.hibernate.engine.spi.CascadeStyle;
-import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.IdentifierValue;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.VersionValue;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.binding.AbstractPluralAttributeBinding;
-import org.hibernate.metamodel.binding.AssociationAttributeBinding;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.BasicAttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.SimpleValueBinding;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.property.Getter;
 import org.hibernate.property.PropertyAccessor;
 import org.hibernate.property.PropertyAccessorFactory;
 import org.hibernate.tuple.entity.EntityBasedAssociationAttribute;
 import org.hibernate.tuple.entity.EntityBasedBasicAttribute;
 import org.hibernate.tuple.entity.EntityBasedCompositionAttribute;
 import org.hibernate.tuple.entity.VersionProperty;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Responsible for generation of runtime metamodel {@link Property} representations.
  * Makes distinction between identifier, version, and other (standard) properties.
  *
  * @author Steve Ebersole
  */
 public final class PropertyFactory {
 	private PropertyFactory() {
 	}
 
 	/**
 	 * Generates the attribute representation of the identifier for a given entity mapping.
 	 *
 	 * @param mappedEntity The mapping definition of the entity.
 	 * @param generator The identifier value generator to use for this identifier.
 	 * @return The appropriate IdentifierProperty definition.
 	 */
 	public static IdentifierProperty buildIdentifierAttribute(
 			PersistentClass mappedEntity,
 			IdentifierGenerator generator) {
 		String mappedUnsavedValue = mappedEntity.getIdentifier().getNullValue();
 		Type type = mappedEntity.getIdentifier().getType();
 		Property property = mappedEntity.getIdentifierProperty();
 		
 		IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				type,
 				getConstructor(mappedEntity)
 			);
 
 		if ( property == null ) {
 			// this is a virtual id property...
 			return new IdentifierProperty(
 			        type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					mappedEntity.hasIdentifierMapper(),
 					unsavedValue,
 					generator
 				);
 		}
 		else {
 			return new IdentifierProperty(
 					property.getName(),
 					property.getNodeName(),
 					type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					unsavedValue,
 					generator
 				);
 		}
 	}
 
 	/**
-	 * Generates an IdentifierProperty representation of the for a given entity mapping.
-	 *
-	 * @param mappedEntity The mapping definition of the entity.
-	 * @param generator The identifier value generator to use for this identifier.
-	 * @return The appropriate IdentifierProperty definition.
-	 */
-	public static IdentifierProperty buildIdentifierProperty(
-			EntityBinding mappedEntity,
-			IdentifierGenerator generator) {
-
-		final BasicAttributeBinding property = mappedEntity.getHierarchyDetails().getEntityIdentifier().getValueBinding();
-
-		// TODO: the following will cause an NPE with "virtual" IDs; how should they be set?
-		// (steve) virtual attributes will still be attributes, they will simply be marked as virtual.
-		//		see org.hibernate.metamodel.domain.AbstractAttributeContainer.locateOrCreateVirtualAttribute()
-
-		final String mappedUnsavedValue = property.getUnsavedValue();
-		final Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping();
-
-		IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(
-				mappedUnsavedValue,
-				getGetter( property ),
-				type,
-				getConstructor( mappedEntity )
-			);
-
-		if ( property == null ) {
-			// this is a virtual id property...
-			return new IdentifierProperty(
-			        type,
-					mappedEntity.getHierarchyDetails().getEntityIdentifier().isEmbedded(),
-					mappedEntity.getHierarchyDetails().getEntityIdentifier().isIdentifierMapper(),
-					unsavedValue,
-					generator
-				);
-		}
-		else {
-			return new IdentifierProperty(
-					property.getAttribute().getName(),
-					null,
-					type,
-					mappedEntity.getHierarchyDetails().getEntityIdentifier().isEmbedded(),
-					unsavedValue,
-					generator
-				);
-		}
-	}
-
-	/**
 	 * Generates a VersionProperty representation for an entity mapping given its
 	 * version mapping Property.
 	 *
 	 * @param property The version mapping Property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate VersionProperty definition.
 	 */
 	public static VersionProperty buildVersionProperty(
 			EntityPersister persister,
 			SessionFactoryImplementor sessionFactory,
 			int attributeNumber,
 			Property property,
 			boolean lazyAvailable) {
 		String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();
 		
 		VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				(VersionType) property.getType(),
 				getConstructor( property.getPersistentClass() )
 		);
 
 		boolean lazy = lazyAvailable && property.isLazy();
 
 		return new VersionProperty(
 				persister,
 				sessionFactory,
 				attributeNumber,
 		        property.getName(),
 		        property.getValue().getType(),
 				new BaselineAttributeInformation.Builder()
 						.setLazy( lazy )
 						.setInsertable( property.isInsertable() )
 						.setUpdateable( property.isUpdateable() )
 						.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 						.setNullable( property.isOptional() )
 						.setDirtyCheckable( property.isUpdateable() && !lazy )
 						.setVersionable( property.isOptimisticLocked() )
 						.setCascadeStyle( property.getCascadeStyle() )
 						.createInformation(),
 		        unsavedValue
 			);
 	}
 
-	/**
-	 * Generates a VersionProperty representation for an entity mapping given its
-	 * version mapping Property.
-	 *
-	 * @param property The version mapping Property.
-	 * @param lazyAvailable Is property lazy loading currently available.
-	 * @return The appropriate VersionProperty definition.
-	 */
-	public static VersionProperty buildVersionProperty(
-			EntityPersister persister,
-			BasicAttributeBinding property,
-			boolean lazyAvailable) {
-		throw new NotYetImplementedException();
-	}
-
 	public static enum NonIdentifierAttributeNature {
 		BASIC,
 		COMPOSITE,
 		ANY,
 		ENTITY,
 		COLLECTION
 	}
 
 	/**
 	 * Generate a non-identifier (and non-version) attribute based on the given mapped property from the given entity
 	 *
 	 * @param property The mapped property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate NonIdentifierProperty definition.
 	 */
 	public static NonIdentifierAttribute buildEntityBasedAttribute(
 			EntityPersister persister,
 			SessionFactoryImplementor sessionFactory,
 			int attributeNumber,
 			Property property,
 			boolean lazyAvailable) {
 		final Type type = property.getValue().getType();
 
 		final NonIdentifierAttributeNature nature = decode( type );
 
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 		
 		// we need to dirty check many-to-ones with not-found="ignore" in order 
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 		
 		boolean alwaysDirtyCheck = type.isAssociationType() && 
 				( (AssociationType) type ).isAlwaysDirtyChecked(); 
 
 		switch ( nature ) {
 			case BASIC: {
 				return new EntityBasedBasicAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			case COMPOSITE: {
 				return new EntityBasedCompositionAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						(CompositeType) type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			case ENTITY:
 			case ANY:
 			case COLLECTION: {
 				return new EntityBasedAssociationAttribute(
 						persister,
 						sessionFactory,
 						attributeNumber,
 						property.getName(),
 						(AssociationType) type,
 						new BaselineAttributeInformation.Builder()
 								.setLazy( lazyAvailable && property.isLazy() )
 								.setInsertable( property.isInsertable() )
 								.setUpdateable( property.isUpdateable() )
 								.setValueGenerationStrategy( property.getValueGenerationStrategy() )
 								.setNullable( property.isOptional() )
 								.setDirtyCheckable( alwaysDirtyCheck || property.isUpdateable() )
 								.setVersionable( property.isOptimisticLocked() )
 								.setCascadeStyle( property.getCascadeStyle() )
 								.setFetchMode( property.getValue().getFetchMode() )
 								.createInformation()
 				);
 			}
 			default: {
 				throw new HibernateException( "Internal error" );
 			}
 		}
 	}
 
 	private static NonIdentifierAttributeNature decode(Type type) {
 		if ( type.isAssociationType() ) {
 			AssociationType associationType = (AssociationType) type;
 
 			if ( type.isComponentType() ) {
 				// an any type is both an association and a composite...
 				return NonIdentifierAttributeNature.ANY;
 			}
 
 			return type.isCollectionType()
 					? NonIdentifierAttributeNature.COLLECTION
 					: NonIdentifierAttributeNature.ENTITY;
 		}
 		else {
 			if ( type.isComponentType() ) {
 				return NonIdentifierAttributeNature.COMPOSITE;
 			}
 
 			return NonIdentifierAttributeNature.BASIC;
 		}
 	}
 
 	@Deprecated
 	public static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {
 		final Type type = property.getValue().getType();
 
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 
 		// we need to dirty check many-to-ones with not-found="ignore" in order
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 
 		boolean alwaysDirtyCheck = type.isAssociationType() &&
 				( (AssociationType) type ).isAlwaysDirtyChecked();
 
 		return new StandardProperty(
 				property.getName(),
 				type,
 				lazyAvailable && property.isLazy(),
 				property.isInsertable(),
 				property.isUpdateable(),
 				property.getValueGenerationStrategy(),
 				property.isOptional(),
 				alwaysDirtyCheck || property.isUpdateable(),
 				property.isOptimisticLocked(),
 				property.getCascadeStyle(),
 				property.getValue().getFetchMode()
 		);
 	}
 
 
-	/**
-	 * Generate a "standard" (i.e., non-identifier and non-version) based on the given
-	 * mapped property.
-	 *
-	 * @param property The mapped property.
-	 * @param lazyAvailable Is property lazy loading currently available.
-	 * @return The appropriate NonIdentifierProperty definition.
-	 */
-	public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) {
-
-		final Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping();
-
-		// we need to dirty check collections, since they can cause an owner
-		// version number increment
-
-		// we need to dirty check many-to-ones with not-found="ignore" in order
-		// to update the cache (not the database), since in this case a null
-		// entity reference can lose information
-
-		final boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked();
-
-		if ( property.getAttribute().isSingular() ) {
-			final SingularAttributeBinding singularAttributeBinding = ( SingularAttributeBinding ) property;
-			final CascadeStyle cascadeStyle = singularAttributeBinding.isAssociation()
-					? ( (AssociationAttributeBinding) singularAttributeBinding ).getCascadeStyle()
-					: CascadeStyles.NONE;
-			final FetchMode fetchMode = singularAttributeBinding.isAssociation()
-					? ( (AssociationAttributeBinding) singularAttributeBinding ).getFetchMode()
-					: FetchMode.DEFAULT;
-
-			return new StandardProperty(
-					singularAttributeBinding.getAttribute().getName(),
-					type,
-					lazyAvailable && singularAttributeBinding.isLazy(),
-					true, // insertable
-					true, // updatable
-					null,
-					singularAttributeBinding.isNullable(),
-					alwaysDirtyCheck || areAllValuesIncludedInUpdate( singularAttributeBinding ),
-					singularAttributeBinding.isIncludedInOptimisticLocking(),
-					cascadeStyle,
-					fetchMode
-			);
-		}
-		else {
-			final AbstractPluralAttributeBinding pluralAttributeBinding = (AbstractPluralAttributeBinding) property;
-			final CascadeStyle cascadeStyle = pluralAttributeBinding.isAssociation()
-					? pluralAttributeBinding.getCascadeStyle()
-					: CascadeStyles.NONE;
-			final FetchMode fetchMode = pluralAttributeBinding.isAssociation()
-					? pluralAttributeBinding.getFetchMode()
-					: FetchMode.DEFAULT;
-
-			return new StandardProperty(
-					pluralAttributeBinding.getAttribute().getName(),
-					type,
-					lazyAvailable && pluralAttributeBinding.isLazy(),
-					// TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable
-					true, // pluralAttributeBinding.isInsertable(),
-					true, //pluralAttributeBinding.isUpdatable(),
-					null,
-					false, // nullable - not sure what that means for a collection
-					// TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable
-					//alwaysDirtyCheck || pluralAttributeBinding.isUpdatable(),
-					true,
-					pluralAttributeBinding.isIncludedInOptimisticLocking(),
-					cascadeStyle,
-					fetchMode
-				);
-		}
-	}
-
-	private static boolean areAllValuesIncludedInUpdate(SingularAttributeBinding attributeBinding) {
-		if ( attributeBinding.hasDerivedValue() ) {
-			return false;
-		}
-		for ( SimpleValueBinding valueBinding : attributeBinding.getSimpleValueBindings() ) {
-			if ( ! valueBinding.isIncludeInUpdate() ) {
-				return false;
-			}
-		}
-		return true;
-	}
-
 	private static Constructor getConstructor(PersistentClass persistentClass) {
 		if ( persistentClass == null || !persistentClass.hasPojoRepresentation() ) {
 			return null;
 		}
 
 		try {
 			return ReflectHelper.getDefaultConstructor( persistentClass.getMappedClass() );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
-	private static Constructor getConstructor(EntityBinding entityBinding) {
-		if ( entityBinding == null || entityBinding.getEntity() == null ) {
-			return null;
-		}
-
-		try {
-			return ReflectHelper.getDefaultConstructor( entityBinding.getEntity().getClassReference() );
-		}
-		catch( Throwable t ) {
-			return null;
-		}
-	}
-
 	private static Getter getGetter(Property mappingProperty) {
 		if ( mappingProperty == null || !mappingProperty.getPersistentClass().hasPojoRepresentation() ) {
 			return null;
 		}
 
 		PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( mappingProperty, EntityMode.POJO );
 		return pa.getGetter( mappingProperty.getPersistentClass().getMappedClass(), mappingProperty.getName() );
 	}
 
-	private static Getter getGetter(AttributeBinding mappingProperty) {
-		if ( mappingProperty == null || mappingProperty.getContainer().getClassReference() == null ) {
-			return null;
-		}
-
-		PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( mappingProperty, EntityMode.POJO );
-		return pa.getGetter(
-				mappingProperty.getContainer().getClassReference(),
-				mappingProperty.getAttribute().getName()
-		);
-	}
-
-
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
index 67ec5d9791..c05ffb7832 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
@@ -1,817 +1,710 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PersistEvent;
 import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.id.Assigned;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.NonIdentifierAttribute;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 
 /**
  * Support for tuplizers relating to entities.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public abstract class AbstractEntityTuplizer implements EntityTuplizer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractEntityTuplizer.class.getName()
 	);
 
 	//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!
 
 	private final EntityMetamodel entityMetamodel;
 
 	private final Getter idGetter;
 	private final Setter idSetter;
 
 	protected final Getter[] getters;
 	protected final Setter[] setters;
 	protected final int propertySpan;
 	protected final boolean hasCustomAccessors;
 	private final Instantiator instantiator;
 	private final ProxyFactory proxyFactory;
 	private final CompositeType identifierMapperType;
 
 	public Type getIdentifierMapperType() {
 		return identifierMapperType;
 	}
 
 	/**
 	 * Build an appropriate Getter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Getter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Getter instance.
 	 */
 	protected abstract Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Setter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Setter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Setter instance.
 	 */
 	protected abstract Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Instantiator for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @return An appropriate Instantiator instance.
 	 */
 	protected abstract Instantiator buildInstantiator(PersistentClass mappingInfo);
 
 	/**
 	 * Build an appropriate ProxyFactory for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @param idGetter The constructed Getter relating to the entity's id property.
 	 * @param idSetter The constructed Setter relating to the entity's id property.
 	 * @return An appropriate ProxyFactory instance.
 	 */
 	protected abstract ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter);
 
 	/**
-	 * Build an appropriate Getter for the given property.
-	 *
-	 *
-	 * @param mappedProperty The property to be accessed via the built Getter.
-	 * @return An appropriate Getter instance.
-	 */
-	protected abstract Getter buildPropertyGetter(AttributeBinding mappedProperty);
-
-	/**
-	 * Build an appropriate Setter for the given property.
-	 *
-	 *
-	 * @param mappedProperty The property to be accessed via the built Setter.
-	 * @return An appropriate Setter instance.
-	 */
-	protected abstract Setter buildPropertySetter(AttributeBinding mappedProperty);
-
-	/**
-	 * Build an appropriate Instantiator for the given mapped entity.
-	 *
-	 * @param mappingInfo The mapping information regarding the mapped entity.
-	 * @return An appropriate Instantiator instance.
-	 */
-	protected abstract Instantiator buildInstantiator(EntityBinding mappingInfo);
-
-	/**
-	 * Build an appropriate ProxyFactory for the given mapped entity.
-	 *
-	 * @param mappingInfo The mapping information regarding the mapped entity.
-	 * @param idGetter The constructed Getter relating to the entity's id property.
-	 * @param idSetter The constructed Setter relating to the entity's id property.
-	 * @return An appropriate ProxyFactory instance.
-	 */
-	protected abstract ProxyFactory buildProxyFactory(EntityBinding mappingInfo, Getter idGetter, Setter idSetter);
-
-	/**
 	 * Constructs a new AbstractEntityTuplizer instance.
 	 *
 	 * @param entityMetamodel The "interpreted" information relating to the mapped entity.
 	 * @param mappingInfo The parsed "raw" mapping data relating to the given entity.
 	 */
 	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
 		this.entityMetamodel = entityMetamodel;
 
 		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
 			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 		}
 		else {
 			idGetter = null;
 			idSetter = null;
 		}
 
 		propertySpan = entityMetamodel.getPropertySpan();
 
         getters = new Getter[propertySpan];
 		setters = new Setter[propertySpan];
 
 		Iterator itr = mappingInfo.getPropertyClosureIterator();
 		boolean foundCustomAccessor=false;
 		int i=0;
 		while ( itr.hasNext() ) {
 			//TODO: redesign how PropertyAccessors are acquired...
 			Property property = (Property) itr.next();
 			getters[i] = buildPropertyGetter(property, mappingInfo);
 			setters[i] = buildPropertySetter(property, mappingInfo);
 			if ( !property.isBasicPropertyAccessor() ) {
 				foundCustomAccessor = true;
 			}
 			i++;
 		}
 		hasCustomAccessors = foundCustomAccessor;
 
         instantiator = buildInstantiator( mappingInfo );
 
 		if ( entityMetamodel.isLazy() ) {
 			proxyFactory = buildProxyFactory( mappingInfo, idGetter, idSetter );
 			if (proxyFactory == null) {
 				entityMetamodel.setLazy( false );
 			}
 		}
 		else {
 			proxyFactory = null;
 		}
 
 		Component mapper = mappingInfo.getIdentifierMapper();
 		if ( mapper == null ) {
 			identifierMapperType = null;
 			mappedIdentifierValueMarshaller = null;
 		}
 		else {
 			identifierMapperType = (CompositeType) mapper.getType();
 			mappedIdentifierValueMarshaller = buildMappedIdentifierValueMarshaller(
 					(ComponentType) entityMetamodel.getIdentifierProperty().getType(),
 					(ComponentType) identifierMapperType
 			);
 		}
 	}
 
-	/**
-	 * Constructs a new AbstractEntityTuplizer instance.
-	 *
-	 * @param entityMetamodel The "interpreted" information relating to the mapped entity.
-	 * @param mappingInfo The parsed "raw" mapping data relating to the given entity.
-	 */
-	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappingInfo) {
-		this.entityMetamodel = entityMetamodel;
-
-		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
-			idGetter = buildPropertyGetter( mappingInfo.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
-			idSetter = buildPropertySetter( mappingInfo.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
-		}
-		else {
-			idGetter = null;
-			idSetter = null;
-		}
-
-		propertySpan = entityMetamodel.getPropertySpan();
-
-		getters = new Getter[ propertySpan ];
-		setters = new Setter[ propertySpan ];
-
-		boolean foundCustomAccessor = false;
-		int i = 0;
-		for ( AttributeBinding property : mappingInfo.getAttributeBindingClosure() ) {
-			if ( property == mappingInfo.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
-				continue; // ID binding processed above
-			}
-
-			//TODO: redesign how PropertyAccessors are acquired...
-			getters[ i ] = buildPropertyGetter( property );
-			setters[ i ] = buildPropertySetter( property );
-			if ( ! property.isBasicPropertyAccessor() ) {
-				foundCustomAccessor = true;
-			}
-			i++;
-		}
-		hasCustomAccessors = foundCustomAccessor;
-
-		instantiator = buildInstantiator( mappingInfo );
-
-		if ( entityMetamodel.isLazy() ) {
-			proxyFactory = buildProxyFactory( mappingInfo, idGetter, idSetter );
-			if ( proxyFactory == null ) {
-				entityMetamodel.setLazy( false );
-			}
-		}
-		else {
-			proxyFactory = null;
-		}
-
-
-		// TODO: Fix this when components are working (HHH-6173)
-		//Component mapper = mappingInfo.getEntityIdentifier().getIdentifierMapper();
-		Component mapper = null;
-		if ( mapper == null ) {
-			identifierMapperType = null;
-			mappedIdentifierValueMarshaller = null;
-		}
-		else {
-			identifierMapperType = ( CompositeType ) mapper.getType();
-			mappedIdentifierValueMarshaller = buildMappedIdentifierValueMarshaller(
-					( ComponentType ) entityMetamodel.getIdentifierProperty().getType(),
-					( ComponentType ) identifierMapperType
-			);
-		}
-	}
-
 	/** Retreives the defined entity-name for the tuplized entity.
 	 *
 	 * @return The entity-name.
 	 */
 	protected String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	/**
 	 * Retrieves the defined entity-names for any subclasses defined for this
 	 * entity.
 	 *
 	 * @return Any subclass entity-names.
 	 */
 	protected Set getSubclassEntityNames() {
 		return entityMetamodel.getSubclassEntityNames();
 	}
 
 	@Override
 	public Serializable getIdentifier(Object entity) throws HibernateException {
 		return getIdentifier( entity, null );
 	}
 
 	@Override
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		final Object id;
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			id = entity;
 		}
 		else if ( HibernateProxy.class.isInstance( entity ) ) {
 			id = ( (HibernateProxy) entity ).getHibernateLazyInitializer().getIdentifier();
 		}
 		else {
 			if ( idGetter == null ) {
 				if (identifierMapperType==null) {
 					throw new HibernateException( "The class has no identifier property: " + getEntityName() );
 				}
 				else {
 					id = mappedIdentifierValueMarshaller.getIdentifier( entity, getEntityMode(), session );
 				}
 			}
 			else {
                 id = idGetter.get( entity );
             }
         }
 
 		try {
 			return (Serializable) id;
 		}
 		catch ( ClassCastException cce ) {
 			StringBuilder msg = new StringBuilder( "Identifier classes must be serializable. " );
 			if ( id != null ) {
 				msg.append( id.getClass().getName() ).append( " is not serializable. " );
 			}
 			if ( cce.getMessage() != null ) {
 				msg.append( cce.getMessage() );
 			}
 			throw new ClassCastException( msg.toString() );
 		}
 	}
 
 	@Override
 	public void setIdentifier(Object entity, Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		setIdentifier( entity, id, null );
 	}
 
 	@Override
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			if ( entity != id ) {
 				CompositeType copier = (CompositeType) entityMetamodel.getIdentifierProperty().getType();
 				copier.setPropertyValues( entity, copier.getPropertyValues( id, getEntityMode() ), getEntityMode() );
 			}
 		}
 		else if ( idSetter != null ) {
 			idSetter.set( entity, id, getFactory() );
 		}
 		else if ( identifierMapperType != null ) {
 			mappedIdentifierValueMarshaller.setIdentifier( entity, id, getEntityMode(), session );
 		}
 	}
 
 	private static interface MappedIdentifierValueMarshaller {
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session);
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session);
 	}
 
 	private final MappedIdentifierValueMarshaller mappedIdentifierValueMarshaller;
 
 	private static MappedIdentifierValueMarshaller buildMappedIdentifierValueMarshaller(
 			ComponentType mappedIdClassComponentType,
 			ComponentType virtualIdComponent) {
 		// so basically at this point we know we have a "mapped" composite identifier
 		// which is an awful way to say that the identifier is represented differently
 		// in the entity and in the identifier value.  The incoming value should
 		// be an instance of the mapped identifier class (@IdClass) while the incoming entity
 		// should be an instance of the entity class as defined by metamodel.
 		//
 		// However, even within that we have 2 potential scenarios:
 		//		1) @IdClass types and entity @Id property types match
 		//			- return a NormalMappedIdentifierValueMarshaller
 		//		2) They do not match
 		//			- return a IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller
 		boolean wereAllEquivalent = true;
 		// the sizes being off is a much bigger problem that should have been caught already...
 		for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 			if ( virtualIdComponent.getSubtypes()[i].isEntityType()
 					&& ! mappedIdClassComponentType.getSubtypes()[i].isEntityType() ) {
 				wereAllEquivalent = false;
 				break;
 			}
 		}
 
 		return wereAllEquivalent
 				? new NormalMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType )
 				: new IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType );
 	}
 
 	private static class NormalMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private NormalMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		@Override
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			virtualIdComponent.setPropertyValues(
 					entity,
 					mappedIdentifierType.getPropertyValues( id, session ),
 					entityMode
 			);
 		}
 	}
 
 	private static class IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		@Override
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			final Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			final Type[] subTypes = virtualIdComponent.getSubtypes();
 			final Type[] copierSubTypes = mappedIdentifierType.getSubtypes();
 			final Iterable<PersistEventListener> persistEventListeners = persistEventListeners( session );
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			final int length = subTypes.length;
 			for ( int i = 0 ; i < length; i++ ) {
 				if ( propertyValues[i] == null ) {
 					throw new HibernateException( "No part of a composite identifier may be null" );
 				}
 				//JPA 2 @MapsId + @IdClass points to the pk of the entity
 				if ( subTypes[i].isAssociationType() && ! copierSubTypes[i].isAssociationType() ) {
 					// we need a session to handle this use case
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final Object subId;
 					if ( HibernateProxy.class.isInstance( propertyValues[i] ) ) {
 						subId = ( (HibernateProxy) propertyValues[i] ).getHibernateLazyInitializer().getIdentifier();
 					}
 					else {
 						EntityEntry pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 						if ( pcEntry != null ) {
 							subId = pcEntry.getId();
 						}
 						else {
 							LOG.debug( "Performing implicit derived identity cascade" );
 							final PersistEvent event = new PersistEvent( null, propertyValues[i], (EventSource) session );
 							for ( PersistEventListener listener : persistEventListeners ) {
 								listener.onPersist( event );
 							}
 							pcEntry = persistenceContext.getEntry( propertyValues[i] );
 							if ( pcEntry == null || pcEntry.getId() == null ) {
 								throw new HibernateException( "Unable to process implicit derived identity cascade" );
 							}
 							else {
 								subId = pcEntry.getId();
 							}
 						}
 					}
 					propertyValues[i] = subId;
 				}
 			}
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			final Object[] extractedValues = mappedIdentifierType.getPropertyValues( id, entityMode );
 			final Object[] injectionValues = new Object[ extractedValues.length ];
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 				final Type virtualPropertyType = virtualIdComponent.getSubtypes()[i];
 				final Type idClassPropertyType = mappedIdentifierType.getSubtypes()[i];
 				if ( virtualPropertyType.isEntityType() && ! idClassPropertyType.isEntityType() ) {
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final String associatedEntityName = ( (EntityType) virtualPropertyType ).getAssociatedEntityName();
 					final EntityKey entityKey = session.generateEntityKey(
 							(Serializable) extractedValues[i],
 							session.getFactory().getEntityPersister( associatedEntityName )
 					);
 					// it is conceivable there is a proxy, so check that first
 					Object association = persistenceContext.getProxy( entityKey );
 					if ( association == null ) {
 						// otherwise look for an initialized version
 						association = persistenceContext.getEntity( entityKey );
 					}
 					injectionValues[i] = association;
 				}
 				else {
 					injectionValues[i] = extractedValues[i];
 				}
 			}
 			virtualIdComponent.setPropertyValues( entity, injectionValues, entityMode );
 		}
 	}
 
 	private static Iterable<PersistEventListener> persistEventListeners(SessionImplementor session) {
 		return session
 				.getFactory()
 				.getServiceRegistry()
 				.getService( EventListenerRegistry.class )
 				.getEventListenerGroup( EventType.PERSIST )
 				.listeners();
 	}
 
 	@Override
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion) {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	@Override
 	public void resetIdentifier(
 			Object entity,
 			Serializable currentId,
 			Object currentVersion,
 			SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().getIdentifierGenerator() instanceof Assigned ) {
 		}
 		else {
 			//reset the id
 			Serializable result = entityMetamodel.getIdentifierProperty()
 					.getUnsavedValue()
 					.getDefaultValue( currentId );
 			setIdentifier( entity, result, session );
 			//reset the version
 			VersionProperty versionProperty = entityMetamodel.getVersionProperty();
 			if ( entityMetamodel.isVersioned() ) {
 				setPropertyValue(
 				        entity,
 				        entityMetamodel.getVersionPropertyIndex(),
 						versionProperty.getUnsavedValue().getDefaultValue( currentVersion )
 				);
 			}
 		}
 	}
 
 	@Override
 	public Object getVersion(Object entity) throws HibernateException {
 		if ( !entityMetamodel.isVersioned() ) return null;
 		return getters[ entityMetamodel.getVersionPropertyIndex() ].get( entity );
 	}
 
 	protected boolean shouldGetAllProperties(Object entity) {
 		return !hasUninitializedLazyProperties( entity );
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object entity) throws HibernateException {
 		boolean getAll = shouldGetAllProperties( entity );
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
 			if ( getAll || !property.isLazy() ) {
 				result[j] = getters[j].get( entity );
 			}
 			else {
 				result[j] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 			}
 		}
 		return result;
 	}
 
 	@Override
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 			throws HibernateException {
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			result[j] = getters[j].getForInsert( entity, mergeMap, session );
 		}
 		return result;
 	}
 
 	@Override
 	public Object getPropertyValue(Object entity, int i) throws HibernateException {
 		return getters[i].get( entity );
 	}
 
 	@Override
 	public Object getPropertyValue(Object entity, String propertyPath) throws HibernateException {
 		int loc = propertyPath.indexOf('.');
 		String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		//final int index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		Integer index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		if (index == null) {
 			propertyPath = PropertyPath.IDENTIFIER_MAPPER_PROPERTY + "." + propertyPath;
 			loc = propertyPath.indexOf('.');
 			basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		}
 		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		final Object baseValue = getPropertyValue( entity, index );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) entityMetamodel.getPropertyTypes()[index],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 	}
 
 	/**
 	 * Extract a component property value.
 	 *
 	 * @param type The component property types.
 	 * @param component The component instance itself.
 	 * @param propertyPath The property path for the property to be extracted.
 	 * @return The property value extracted.
 	 */
 	protected Object getComponentValue(ComponentType type, Object component, String propertyPath) {
 		final int loc = propertyPath.indexOf( '.' );
 		final String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		final int index = findSubPropertyIndex( type, basePropertyName );
 		final Object baseValue = type.getPropertyValue( component, index );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) type.getSubtypes()[index],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 
 	}
 
 	private int findSubPropertyIndex(ComponentType type, String subPropertyName) {
 		final String[] propertyNames = type.getPropertyNames();
 		for ( int index = 0; index<propertyNames.length; index++ ) {
 			if ( subPropertyName.equals( propertyNames[index] ) ) {
 				return index;
 			}
 		}
 		throw new MappingException( "component property not found: " + subPropertyName );
 	}
 
 	@Override
 	public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		boolean setAll = !entityMetamodel.hasLazyProperties();
 
 		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
 			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 				setters[j].set( entity, values[j], getFactory() );
 			}
 		}
 	}
 
 	@Override
 	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException {
 		setters[i].set( entity, value, getFactory() );
 	}
 
 	@Override
 	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException {
 		setters[ entityMetamodel.getPropertyIndex( propertyName ) ].set( entity, value, getFactory() );
 	}
 
 	@Override
 	public final Object instantiate(Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		return instantiate( id, null );
 	}
 
 	@Override
 	public final Object instantiate(Serializable id, SessionImplementor session) {
 		Object result = getInstantiator().instantiate( id );
 		if ( id != null ) {
 			setIdentifier( result, id, session );
 		}
 		return result;
 	}
 
 	@Override
 	public final Object instantiate() throws HibernateException {
 		return instantiate( null, null );
 	}
 
 	@Override
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {}
 
 	@Override
 	public boolean hasUninitializedLazyProperties(Object entity) {
 		// the default is to simply not lazy fetch properties for now...
 		return false;
 	}
 
 	@Override
 	public final boolean isInstance(Object object) {
         return getInstantiator().isInstance( object );
 	}
 
 	@Override
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	@Override
 	public final Object createProxy(Serializable id, SessionImplementor session)
 	throws HibernateException {
 		return getProxyFactory().getProxy( id, session );
 	}
 
 	@Override
 	public boolean isLifecycleImplementor() {
 		return false;
 	}
 
 	protected final EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	protected final SessionFactoryImplementor getFactory() {
 		return entityMetamodel.getSessionFactory();
 	}
 
 	protected final Instantiator getInstantiator() {
 		return instantiator;
 	}
 
 	protected final ProxyFactory getProxyFactory() {
 		return proxyFactory;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getEntityMetamodel().getName() + ')';
 	}
 
 	@Override
 	public Getter getIdentifierGetter() {
 		return idGetter;
 	}
 
 	@Override
 	public Getter getVersionGetter() {
 		if ( getEntityMetamodel().isVersioned() ) {
 			return getGetter( getEntityMetamodel().getVersionPropertyIndex() );
 		}
 		return null;
 	}
 
 	@Override
 	public Getter getGetter(int i) {
 		return getters[i];
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
index 7e376d62b5..7433c5ba4d 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/DynamicMapEntityTuplizer.java
@@ -1,216 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.PropertyAccessor;
 import org.hibernate.property.PropertyAccessorFactory;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.proxy.map.MapProxyFactory;
 import org.hibernate.tuple.DynamicMapInstantiator;
 import org.hibernate.tuple.Instantiator;
 
 /**
  * An {@link EntityTuplizer} specific to the dynamic-map entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class DynamicMapEntityTuplizer extends AbstractEntityTuplizer {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DynamicMapEntityTuplizer.class );
 
 	DynamicMapEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super(entityMetamodel, mappedEntity);
 	}
 
-	DynamicMapEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappedEntity) {
-		super(entityMetamodel, mappedEntity);
-	}
-
 	@Override
 	public EntityMode getEntityMode() {
 		return EntityMode.MAP;
 	}
 
 	private PropertyAccessor buildPropertyAccessor(Property mappedProperty) {
 		if ( mappedProperty.isBackRef() ) {
 			return mappedProperty.getPropertyAccessor(null);
 		}
 		else {
 			return PropertyAccessorFactory.getDynamicMapPropertyAccessor();
 		}
 	}
 
 	@Override
     protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return buildPropertyAccessor(mappedProperty).getGetter( null, mappedProperty.getName() );
 	}
 
 	@Override
     protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return buildPropertyAccessor(mappedProperty).getSetter( null, mappedProperty.getName() );
 	}
 
 	@Override
     protected Instantiator buildInstantiator(PersistentClass mappingInfo) {
         return new DynamicMapInstantiator( mappingInfo );
 	}
 
 	@Override
     protected ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter) {
 
 		ProxyFactory pf = new MapProxyFactory();
 		try {
 			//TODO: design new lifecycle for ProxyFactory
 			pf.postInstantiate(
 					getEntityName(),
 					null,
 					null,
 					null,
 					null,
 					null
 			);
 		}
 		catch ( HibernateException he ) {
 			LOG.unableToCreateProxyFactory( getEntityName(), he );
 			pf = null;
 		}
 		return pf;
 	}
 
-	private PropertyAccessor buildPropertyAccessor(AttributeBinding mappedProperty) {
-		// TODO: fix when backrefs are working in new metamodel
-		//if ( mappedProperty.isBackRef() ) {
-		//	return mappedProperty.getPropertyAccessor( null );
-		//}
-		//else {
-			return PropertyAccessorFactory.getDynamicMapPropertyAccessor();
-		//}
-	}
-
-	@Override
-	protected Getter buildPropertyGetter(AttributeBinding mappedProperty) {
-		return buildPropertyAccessor( mappedProperty ).getGetter( null, mappedProperty.getAttribute().getName() );
-	}
-
-	@Override
-	protected Setter buildPropertySetter(AttributeBinding mappedProperty) {
-		return buildPropertyAccessor( mappedProperty ).getSetter( null, mappedProperty.getAttribute().getName() );
-	}
-
-	@Override
-	protected Instantiator buildInstantiator(EntityBinding mappingInfo) {
-		return new DynamicMapInstantiator( mappingInfo );
-	}
-
-	@Override
-	protected ProxyFactory buildProxyFactory(EntityBinding mappingInfo, Getter idGetter, Setter idSetter) {
-
-		ProxyFactory pf = new MapProxyFactory();
-		try {
-			//TODO: design new lifecycle for ProxyFactory
-			pf.postInstantiate(
-					getEntityName(),
-					null,
-					null,
-					null,
-					null,
-					null
-			);
-		}
-		catch ( HibernateException he ) {
-			LOG.unableToCreateProxyFactory(getEntityName(), he);
-			pf = null;
-		}
-		return pf;
-	}
-
 	@Override
 	public Class getMappedClass() {
 		return Map.class;
 	}
 
 	@Override
 	public Class getConcreteProxyClass() {
 		return Map.class;
 	}
 
 	@Override
 	public boolean isInstrumented() {
 		return false;
 	}
 
 	@Override
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return new EntityNameResolver[] { BasicEntityNameResolver.INSTANCE };
 	}
 
 	@Override
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		return extractEmbeddedEntityName( ( Map ) entityInstance );
 	}
 
 	public static String extractEmbeddedEntityName(Map entity) {
 		return ( String ) entity.get( DynamicMapInstantiator.KEY );
 	}
 
 	public static class BasicEntityNameResolver implements EntityNameResolver {
 		public static final BasicEntityNameResolver INSTANCE = new BasicEntityNameResolver();
 
 		@Override
 		public String resolveEntityName(Object entity) {
 			if ( ! Map.class.isInstance( entity ) ) {
 				return null;
 			}
 			final String entityName = extractEmbeddedEntityName( ( Map ) entity );
 			if ( entityName == null ) {
 				throw new HibernateException( "Could not determine type of dynamic map entity" );
 			}
 			return entityName;
 		}
 
 		@Override
         public boolean equals(Object obj) {
 			return getClass().equals( obj.getClass() );
 		}
 
 		@Override
         public int hashCode() {
 			return getClass().hashCode();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityMetamodel.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityMetamodel.java
index a0fc8724c2..dc62d1c2ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityMetamodel.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityMetamodel.java
@@ -1,1394 +1,1115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.BasicAttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.domain.Attribute;
-import org.hibernate.metamodel.domain.SingularAttribute;
 import org.hibernate.persister.entity.AbstractEntityPersister;
 import org.hibernate.tuple.GenerationTiming;
 import org.hibernate.tuple.IdentifierProperty;
 import org.hibernate.tuple.InDatabaseValueGenerationStrategy;
 import org.hibernate.tuple.InMemoryValueGenerationStrategy;
 import org.hibernate.tuple.NonIdentifierAttribute;
 import org.hibernate.tuple.PropertyFactory;
 import org.hibernate.tuple.ValueGeneration;
 import org.hibernate.tuple.ValueGenerator;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 /**
  * Centralizes metamodel information about an entity.
  *
  * @author Steve Ebersole
  */
 public class EntityMetamodel implements Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, EntityMetamodel.class.getName());
 
 	private static final int NO_VERSION_INDX = -66;
 
 	private final SessionFactoryImplementor sessionFactory;
 	private final AbstractEntityPersister persister;
 
 	private final String name;
 	private final String rootName;
 	private final EntityType entityType;
 
 	private final IdentifierProperty identifierAttribute;
 	private final boolean versioned;
 
 	private final int propertySpan;
 	private final int versionPropertyIndex;
 	private final NonIdentifierAttribute[] properties;
 	// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final String[] propertyNames;
 	private final Type[] propertyTypes;
 	private final boolean[] propertyLaziness;
 	private final boolean[] propertyUpdateability;
 	private final boolean[] nonlazyPropertyUpdateability;
 	private final boolean[] propertyCheckability;
 	private final boolean[] propertyInsertability;
 	private final boolean[] propertyNullability;
 	private final boolean[] propertyVersionability;
 	private final CascadeStyle[] cascadeStyles;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	// value generations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final boolean hasPreInsertGeneratedValues;
 	private final boolean hasPreUpdateGeneratedValues;
 	private final boolean hasInsertGeneratedValues;
 	private final boolean hasUpdateGeneratedValues;
 
 	private final InMemoryValueGenerationStrategy[] inMemoryValueGenerationStrategies;
 	private final InDatabaseValueGenerationStrategy[] inDatabaseValueGenerationStrategies;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final Map<String, Integer> propertyIndexes = new HashMap<String, Integer>();
 	private final boolean hasCollections;
 	private final boolean hasMutableProperties;
 	private final boolean hasLazyProperties;
 	private final boolean hasNonIdentifierPropertyNamedId;
 
 	private final int[] naturalIdPropertyNumbers;
 	private final boolean hasImmutableNaturalId;
 	private final boolean hasCacheableNaturalId;
 
 	private boolean lazy; //not final because proxy factory creation can fail
 	private final boolean hasCascades;
 	private final boolean mutable;
 	private final boolean isAbstract;
 	private final boolean selectBeforeUpdate;
 	private final boolean dynamicUpdate;
 	private final boolean dynamicInsert;
 	private final OptimisticLockStyle optimisticLockStyle;
 
 	private final boolean polymorphic;
 	private final String superclass;  // superclass entity-name
 	private final boolean explicitPolymorphism;
 	private final boolean inherited;
 	private final boolean hasSubclasses;
 	private final Set subclassEntityNames = new HashSet();
 	private final Map entityNameByInheritenceClassMap = new HashMap();
 
 	private final EntityMode entityMode;
 	private final EntityTuplizer entityTuplizer;
 	private final EntityInstrumentationMetadata instrumentationMetadata;
 
 	public EntityMetamodel(
 			PersistentClass persistentClass,
 			AbstractEntityPersister persister,
 			SessionFactoryImplementor sessionFactory) {
 		this.sessionFactory = sessionFactory;
 		this.persister = persister;
 
 		name = persistentClass.getEntityName();
 		rootName = persistentClass.getRootClass().getEntityName();
 		entityType = sessionFactory.getTypeResolver().getTypeFactory().manyToOne( name );
 
 		identifierAttribute = PropertyFactory.buildIdentifierAttribute(
 				persistentClass,
 				sessionFactory.getIdentifierGenerator( rootName )
 		);
 
 		versioned = persistentClass.isVersioned();
 
 		instrumentationMetadata = persistentClass.hasPojoRepresentation()
 				? Environment.getBytecodeProvider().getEntityInstrumentationMetadata( persistentClass.getMappedClass() )
 				: new NonPojoInstrumentationMetadata( persistentClass.getEntityName() );
 
 		boolean hasLazy = false;
 
 		propertySpan = persistentClass.getPropertyClosureSpan();
 		properties = new NonIdentifierAttribute[propertySpan];
 		List<Integer> naturalIdNumbers = new ArrayList<Integer>();
 		// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		propertyNames = new String[propertySpan];
 		propertyTypes = new Type[propertySpan];
 		propertyUpdateability = new boolean[propertySpan];
 		propertyInsertability = new boolean[propertySpan];
 		nonlazyPropertyUpdateability = new boolean[propertySpan];
 		propertyCheckability = new boolean[propertySpan];
 		propertyNullability = new boolean[propertySpan];
 		propertyVersionability = new boolean[propertySpan];
 		propertyLaziness = new boolean[propertySpan];
 		cascadeStyles = new CascadeStyle[propertySpan];
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		// generated value strategies ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		this.inMemoryValueGenerationStrategies = new InMemoryValueGenerationStrategy[propertySpan];
 		this.inDatabaseValueGenerationStrategies = new InDatabaseValueGenerationStrategy[propertySpan];
 
 		boolean foundPreInsertGeneratedValues = false;
 		boolean foundPreUpdateGeneratedValues = false;
 		boolean foundPostInsertGeneratedValues = false;
 		boolean foundPostUpdateGeneratedValues = false;
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		Iterator iter = persistentClass.getPropertyClosureIterator();
 		int i = 0;
 		int tempVersionProperty = NO_VERSION_INDX;
 		boolean foundCascade = false;
 		boolean foundCollection = false;
 		boolean foundMutable = false;
 		boolean foundNonIdentifierPropertyNamedId = false;
 		boolean foundInsertGeneratedValue = false;
 		boolean foundUpdateGeneratedValue = false;
 		boolean foundUpdateableNaturalIdProperty = false;
 
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 
 			if ( prop == persistentClass.getVersion() ) {
 				tempVersionProperty = i;
 				properties[i] = PropertyFactory.buildVersionProperty(
 						persister,
 						sessionFactory,
 						i,
 						prop,
 						instrumentationMetadata.isInstrumented()
 				);
 			}
 			else {
 				properties[i] = PropertyFactory.buildEntityBasedAttribute(
 						persister,
 						sessionFactory,
 						i,
 						prop,
 						instrumentationMetadata.isInstrumented()
 				);
 			}
 
 			if ( prop.isNaturalIdentifier() ) {
 				naturalIdNumbers.add( i );
 				if ( prop.isUpdateable() ) {
 					foundUpdateableNaturalIdProperty = true;
 				}
 			}
 
 			if ( "id".equals( prop.getName() ) ) {
 				foundNonIdentifierPropertyNamedId = true;
 			}
 
 			// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			boolean lazy = prop.isLazy() && instrumentationMetadata.isInstrumented();
 			if ( lazy ) hasLazy = true;
 			propertyLaziness[i] = lazy;
 
 			propertyNames[i] = properties[i].getName();
 			propertyTypes[i] = properties[i].getType();
 			propertyNullability[i] = properties[i].isNullable();
 			propertyUpdateability[i] = properties[i].isUpdateable();
 			propertyInsertability[i] = properties[i].isInsertable();
 			propertyVersionability[i] = properties[i].isVersionable();
 			nonlazyPropertyUpdateability[i] = properties[i].isUpdateable() && !lazy;
 			propertyCheckability[i] = propertyUpdateability[i] ||
 					( propertyTypes[i].isAssociationType() && ( (AssociationType) propertyTypes[i] ).isAlwaysDirtyChecked() );
 
 			cascadeStyles[i] = properties[i].getCascadeStyle();
 			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 			// generated value strategies ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			GenerationStrategyPair pair = buildGenerationStrategyPair( sessionFactory, prop );
 			inMemoryValueGenerationStrategies[i] = pair.getInMemoryStrategy();
 			inDatabaseValueGenerationStrategies[i] = pair.getInDatabaseStrategy();
 
 			if ( pair.getInMemoryStrategy() != null ) {
 				final GenerationTiming timing = pair.getInMemoryStrategy().getGenerationTiming();
 				if ( timing != GenerationTiming.NEVER ) {
 					final ValueGenerator generator = pair.getInMemoryStrategy().getValueGenerator();
 					if ( generator != null ) {
 						// we have some level of generation indicated
 						if ( timing == GenerationTiming.INSERT ) {
 							foundPreInsertGeneratedValues = true;
 						}
 						else if ( timing == GenerationTiming.ALWAYS ) {
 							foundPreInsertGeneratedValues = true;
 							foundPreUpdateGeneratedValues = true;
 						}
 					}
 				}
 			}
 			if (  pair.getInDatabaseStrategy() != null ) {
 				final GenerationTiming timing =  pair.getInDatabaseStrategy().getGenerationTiming();
 				if ( timing == GenerationTiming.INSERT ) {
 					foundPostInsertGeneratedValues = true;
 				}
 				else if ( timing == GenerationTiming.ALWAYS ) {
 					foundPostInsertGeneratedValues = true;
 					foundPostUpdateGeneratedValues = true;
 				}
 			}
 			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 			if ( properties[i].isLazy() ) {
 				hasLazy = true;
 			}
 
 			if ( properties[i].getCascadeStyle() != CascadeStyles.NONE ) {
 				foundCascade = true;
 			}
 
 			if ( indicatesCollection( properties[i].getType() ) ) {
 				foundCollection = true;
 			}
 
 			if ( propertyTypes[i].isMutable() && propertyCheckability[i] ) {
 				foundMutable = true;
 			}
 
 			mapPropertyToIndex(prop, i);
 			i++;
 		}
 
 		if (naturalIdNumbers.size()==0) {
 			naturalIdPropertyNumbers = null;
 			hasImmutableNaturalId = false;
 			hasCacheableNaturalId = false;
 		}
 		else {
 			naturalIdPropertyNumbers = ArrayHelper.toIntArray(naturalIdNumbers);
 			hasImmutableNaturalId = !foundUpdateableNaturalIdProperty;
 			hasCacheableNaturalId = persistentClass.getNaturalIdCacheRegionName() != null;
 		}
 
 		this.hasPreInsertGeneratedValues = foundPreInsertGeneratedValues;
 		this.hasPreUpdateGeneratedValues = foundPreUpdateGeneratedValues;
 		this.hasInsertGeneratedValues = foundPostInsertGeneratedValues;
 		this.hasUpdateGeneratedValues = foundPostUpdateGeneratedValues;
 
 		hasCascades = foundCascade;
 		hasNonIdentifierPropertyNamedId = foundNonIdentifierPropertyNamedId;
 		versionPropertyIndex = tempVersionProperty;
 		hasLazyProperties = hasLazy;
         if (hasLazyProperties) LOG.lazyPropertyFetchingAvailable(name);
 
 		lazy = persistentClass.isLazy() && (
 				// TODO: this disables laziness even in non-pojo entity modes:
 				!persistentClass.hasPojoRepresentation() ||
 				!ReflectHelper.isFinalClass( persistentClass.getProxyInterface() )
 		);
 		mutable = persistentClass.isMutable();
 		if ( persistentClass.isAbstract() == null ) {
 			// legacy behavior (with no abstract attribute specified)
 			isAbstract = persistentClass.hasPojoRepresentation() &&
 			             ReflectHelper.isAbstractClass( persistentClass.getMappedClass() );
 		}
 		else {
 			isAbstract = persistentClass.isAbstract().booleanValue();
 			if ( !isAbstract && persistentClass.hasPojoRepresentation() &&
 			     ReflectHelper.isAbstractClass( persistentClass.getMappedClass() ) ) {
                 LOG.entityMappedAsNonAbstract(name);
 			}
 		}
 		selectBeforeUpdate = persistentClass.hasSelectBeforeUpdate();
 		dynamicUpdate = persistentClass.useDynamicUpdate();
 		dynamicInsert = persistentClass.useDynamicInsert();
 
 		polymorphic = persistentClass.isPolymorphic();
 		explicitPolymorphism = persistentClass.isExplicitPolymorphism();
 		inherited = persistentClass.isInherited();
 		superclass = inherited ?
 				persistentClass.getSuperclass().getEntityName() :
 				null;
 		hasSubclasses = persistentClass.hasSubclasses();
 
 		optimisticLockStyle = persistentClass.getOptimisticLockStyle();
 		final boolean isAllOrDirty =
 				optimisticLockStyle == OptimisticLockStyle.ALL
 						|| optimisticLockStyle == OptimisticLockStyle.DIRTY;
 		if ( isAllOrDirty && !dynamicUpdate ) {
 			throw new MappingException( "optimistic-lock=all|dirty requires dynamic-update=\"true\": " + name );
 		}
 		if ( versionPropertyIndex != NO_VERSION_INDX && isAllOrDirty ) {
 			throw new MappingException( "version and optimistic-lock=all|dirty are not a valid combination : " + name );
 		}
 
 		hasCollections = foundCollection;
 		hasMutableProperties = foundMutable;
 
 		iter = persistentClass.getSubclassIterator();
 		while ( iter.hasNext() ) {
 			subclassEntityNames.add( ( (PersistentClass) iter.next() ).getEntityName() );
 		}
 		subclassEntityNames.add( name );
 
 		if ( persistentClass.hasPojoRepresentation() ) {
 			entityNameByInheritenceClassMap.put( persistentClass.getMappedClass(), persistentClass.getEntityName() );
 			iter = persistentClass.getSubclassIterator();
 			while ( iter.hasNext() ) {
 				final PersistentClass pc = ( PersistentClass ) iter.next();
 				entityNameByInheritenceClassMap.put( pc.getMappedClass(), pc.getEntityName() );
 			}
 		}
 
 		entityMode = persistentClass.hasPojoRepresentation() ? EntityMode.POJO : EntityMode.MAP;
 		final EntityTuplizerFactory entityTuplizerFactory = sessionFactory.getSettings().getEntityTuplizerFactory();
 		final String tuplizerClassName = persistentClass.getTuplizerImplClassName( entityMode );
 		if ( tuplizerClassName == null ) {
 			entityTuplizer = entityTuplizerFactory.constructDefaultTuplizer( entityMode, this, persistentClass );
 		}
 		else {
 			entityTuplizer = entityTuplizerFactory.constructTuplizer( tuplizerClassName, this, persistentClass );
 		}
 	}
 
 	private static GenerationStrategyPair buildGenerationStrategyPair(
 			final SessionFactoryImplementor sessionFactory,
 			final Property mappingProperty) {
 		final ValueGeneration valueGeneration = mappingProperty.getValueGenerationStrategy();
 		if ( valueGeneration != null && valueGeneration.getGenerationTiming() != GenerationTiming.NEVER ) {
 			// the property is generated in full. build the generation strategy pair.
 			if ( valueGeneration.getValueGenerator() != null ) {
 				// in-memory generation
 				return new GenerationStrategyPair(
 						FullInMemoryValueGenerationStrategy.create( valueGeneration )
 				);
 			}
 			else {
 				// in-db generation
 				return new GenerationStrategyPair(
 						create(
 								sessionFactory,
 								mappingProperty,
 								valueGeneration
 						)
 				);
 			}
 		}
 		else if ( mappingProperty.getValue() instanceof Component ) {
 			final CompositeGenerationStrategyPairBuilder builder = new CompositeGenerationStrategyPairBuilder( mappingProperty );
 			interpretPartialCompositeValueGeneration( sessionFactory, (Component) mappingProperty.getValue(), builder );
 			return builder.buildPair();
 		}
 
 		return NO_GEN_PAIR;
 	}
 
 	private static final GenerationStrategyPair NO_GEN_PAIR = new GenerationStrategyPair();
 
 	private static void interpretPartialCompositeValueGeneration(
 			SessionFactoryImplementor sessionFactory,
 			Component composite,
 			CompositeGenerationStrategyPairBuilder builder) {
 		Iterator subProperties = composite.getPropertyIterator();
 		while ( subProperties.hasNext() ) {
 			final Property subProperty = (Property) subProperties.next();
 			builder.addPair( buildGenerationStrategyPair( sessionFactory, subProperty ) );
 		}
 	}
 
 	public static InDatabaseValueGenerationStrategyImpl create(
 			SessionFactoryImplementor sessionFactoryImplementor,
 			Property mappingProperty,
 			ValueGeneration valueGeneration) {
 		final int numberOfMappedColumns = mappingProperty.getType().getColumnSpan( sessionFactoryImplementor );
 		if ( numberOfMappedColumns == 1 ) {
 			return new InDatabaseValueGenerationStrategyImpl(
 					valueGeneration.getGenerationTiming(),
 					valueGeneration.referenceColumnInSql(),
 					new String[] { valueGeneration.getDatabaseGeneratedReferencedColumnValue() }
 
 			);
 		}
 		else {
 			if ( valueGeneration.getDatabaseGeneratedReferencedColumnValue() != null ) {
 				LOG.debugf(
 						"Value generator specified column value in reference to multi-column attribute [%s -> %s]; ignoring",
 						mappingProperty.getPersistentClass(),
 						mappingProperty.getName()
 				);
 			}
 			return new InDatabaseValueGenerationStrategyImpl(
 					valueGeneration.getGenerationTiming(),
 					valueGeneration.referenceColumnInSql(),
 					new String[numberOfMappedColumns]
 			);
 		}
 	}
 
 	public static class GenerationStrategyPair {
 		private final InMemoryValueGenerationStrategy inMemoryStrategy;
 		private final InDatabaseValueGenerationStrategy inDatabaseStrategy;
 
 		public GenerationStrategyPair() {
 			this( NoInMemoryValueGenerationStrategy.INSTANCE, NoInDatabaseValueGenerationStrategy.INSTANCE );
 		}
 
 		public GenerationStrategyPair(FullInMemoryValueGenerationStrategy inMemoryStrategy) {
 			this( inMemoryStrategy, NoInDatabaseValueGenerationStrategy.INSTANCE );
 		}
 
 		public GenerationStrategyPair(InDatabaseValueGenerationStrategyImpl inDatabaseStrategy) {
 			this( NoInMemoryValueGenerationStrategy.INSTANCE, inDatabaseStrategy );
 		}
 
 		public GenerationStrategyPair(
 				InMemoryValueGenerationStrategy inMemoryStrategy,
 				InDatabaseValueGenerationStrategy inDatabaseStrategy) {
 			// perform some normalization.  Also check that only one (if any) strategy is specified
 			if ( inMemoryStrategy == null ) {
 				inMemoryStrategy = NoInMemoryValueGenerationStrategy.INSTANCE;
 			}
 			if ( inDatabaseStrategy == null ) {
 				inDatabaseStrategy = NoInDatabaseValueGenerationStrategy.INSTANCE;
 			}
 
 			if ( inMemoryStrategy.getGenerationTiming() != GenerationTiming.NEVER
 					&& inDatabaseStrategy.getGenerationTiming() != GenerationTiming.NEVER ) {
 				throw new ValueGenerationStrategyException(
 						"in-memory and in-database value generation are mutually exclusive"
 				);
 			}
 
 			this.inMemoryStrategy = inMemoryStrategy;
 			this.inDatabaseStrategy = inDatabaseStrategy;
 		}
 
 		public InMemoryValueGenerationStrategy getInMemoryStrategy() {
 			return inMemoryStrategy;
 		}
 
 		public InDatabaseValueGenerationStrategy getInDatabaseStrategy() {
 			return inDatabaseStrategy;
 		}
 	}
 
 	public static class ValueGenerationStrategyException extends HibernateException {
 		public ValueGenerationStrategyException(String message) {
 			super( message );
 		}
 
 		public ValueGenerationStrategyException(String message, Throwable cause) {
 			super( message, cause );
 		}
 	}
 
 	private static class CompositeGenerationStrategyPairBuilder {
 		private final Property mappingProperty;
 
 		private boolean hadInMemoryGeneration;
 		private boolean hadInDatabaseGeneration;
 
 		private List<InMemoryValueGenerationStrategy> inMemoryStrategies;
 		private List<InDatabaseValueGenerationStrategy> inDatabaseStrategies;
 
 		public CompositeGenerationStrategyPairBuilder(Property mappingProperty) {
 			this.mappingProperty = mappingProperty;
 		}
 
 		public void addPair(GenerationStrategyPair generationStrategyPair) {
 			add( generationStrategyPair.getInMemoryStrategy() );
 			add( generationStrategyPair.getInDatabaseStrategy() );
 		}
 
 		private void add(InMemoryValueGenerationStrategy inMemoryStrategy) {
 			if ( inMemoryStrategies == null ) {
 				inMemoryStrategies = new ArrayList<InMemoryValueGenerationStrategy>();
 			}
 			inMemoryStrategies.add( inMemoryStrategy );
 
 			if ( inMemoryStrategy.getGenerationTiming() != GenerationTiming.NEVER ) {
 				hadInMemoryGeneration = true;
 			}
 		}
 
 		private void add(InDatabaseValueGenerationStrategy inDatabaseStrategy) {
 			if ( inDatabaseStrategies == null ) {
 				inDatabaseStrategies = new ArrayList<InDatabaseValueGenerationStrategy>();
 			}
 			inDatabaseStrategies.add( inDatabaseStrategy );
 
 			if ( inDatabaseStrategy.getGenerationTiming() != GenerationTiming.NEVER ) {
 				hadInDatabaseGeneration = true;
 			}
 		}
 
 		public GenerationStrategyPair buildPair() {
 			if ( hadInMemoryGeneration && hadInDatabaseGeneration ) {
 				throw new ValueGenerationStrategyException(
 						"Composite attribute [" + mappingProperty.getName() + "] contained both in-memory"
 								+ " and in-database value generation"
 				);
 			}
 			else if ( hadInMemoryGeneration ) {
 				throw new NotYetImplementedException( "Still need to wire in composite in-memory value generation" );
 
 			}
 			else if ( hadInDatabaseGeneration ) {
 				final Component composite = (Component) mappingProperty.getValue();
 
 				// we need the numbers to match up so we can properly handle 'referenced sql column values'
 				if ( inDatabaseStrategies.size() != composite.getPropertySpan() ) {
 					throw new ValueGenerationStrategyException(
 							"Internal error : mismatch between number of collected in-db generation strategies" +
 									" and number of attributes for composite attribute : " + mappingProperty.getName()
 					);
 				}
 
 				// the base-line values for the aggregated InDatabaseValueGenerationStrategy we will build here.
 				GenerationTiming timing = GenerationTiming.INSERT;
 				boolean referenceColumns = false;
 				String[] columnValues = new String[ composite.getColumnSpan() ];
 
 				// start building the aggregate values
 				int propertyIndex = -1;
 				int columnIndex = 0;
 				Iterator subProperties = composite.getPropertyIterator();
 				while ( subProperties.hasNext() ) {
 					propertyIndex++;
 					final Property subProperty = (Property) subProperties.next();
 					final InDatabaseValueGenerationStrategy subStrategy = inDatabaseStrategies.get( propertyIndex );
 
 					if ( subStrategy.getGenerationTiming() == GenerationTiming.ALWAYS ) {
 						// override the base-line to the more often "ALWAYS"...
 						timing = GenerationTiming.ALWAYS;
 
 					}
 					if ( subStrategy.referenceColumnsInSql() ) {
 						// override base-line value
 						referenceColumns = true;
 					}
 					if ( subStrategy.getReferencedColumnValues() != null ) {
 						if ( subStrategy.getReferencedColumnValues().length != subProperty.getColumnSpan() ) {
 							throw new ValueGenerationStrategyException(
 									"Internal error : mismatch between number of collected 'referenced column values'" +
 											" and number of columns for composite attribute : " + mappingProperty.getName() +
 											'.' + subProperty.getName()
 							);
 						}
 						System.arraycopy(
 								subStrategy.getReferencedColumnValues(),
 								0,
 								columnValues,
 								columnIndex,
 								subProperty.getColumnSpan()
 						);
 					}
 				}
 
 				// then use the aggregated values to build the InDatabaseValueGenerationStrategy
 				return new GenerationStrategyPair(
 						new InDatabaseValueGenerationStrategyImpl( timing, referenceColumns, columnValues )
 				);
 			}
 			else {
 				return NO_GEN_PAIR;
 			}
 		}
 	}
 
 	private static class NoInMemoryValueGenerationStrategy implements InMemoryValueGenerationStrategy {
 		/**
 		 * Singleton access
 		 */
 		public static final NoInMemoryValueGenerationStrategy INSTANCE = new NoInMemoryValueGenerationStrategy();
 
 		@Override
 		public GenerationTiming getGenerationTiming() {
 			return GenerationTiming.NEVER;
 		}
 
 		@Override
 		public ValueGenerator getValueGenerator() {
 			return null;
 		}
 	}
 
 	private static class FullInMemoryValueGenerationStrategy implements InMemoryValueGenerationStrategy {
 		private final GenerationTiming timing;
 		private final ValueGenerator generator;
 
 		private FullInMemoryValueGenerationStrategy(GenerationTiming timing, ValueGenerator generator) {
 			this.timing = timing;
 			this.generator = generator;
 		}
 
 		public static FullInMemoryValueGenerationStrategy create(ValueGeneration valueGeneration) {
 			return new FullInMemoryValueGenerationStrategy(
 					valueGeneration.getGenerationTiming(),
 					valueGeneration.getValueGenerator()
 			);
 		}
 
 		@Override
 		public GenerationTiming getGenerationTiming() {
 			return timing;
 		}
 
 		@Override
 		public ValueGenerator getValueGenerator() {
 			return generator;
 		}
 	}
 
 	private static class NoInDatabaseValueGenerationStrategy implements InDatabaseValueGenerationStrategy {
 		/**
 		 * Singleton access
 		 */
 		public static final NoInDatabaseValueGenerationStrategy INSTANCE = new NoInDatabaseValueGenerationStrategy();
 
 		@Override
 		public GenerationTiming getGenerationTiming() {
 			return GenerationTiming.NEVER;
 		}
 
 		@Override
 		public boolean referenceColumnsInSql() {
 			return true;
 		}
 
 		@Override
 		public String[] getReferencedColumnValues() {
 			return null;
 		}
 	}
 
 	private static class InDatabaseValueGenerationStrategyImpl implements InDatabaseValueGenerationStrategy {
 		private final GenerationTiming timing;
 		private final boolean referenceColumnInSql;
 		private final String[] referencedColumnValues;
 
 		private InDatabaseValueGenerationStrategyImpl(
 				GenerationTiming timing,
 				boolean referenceColumnInSql,
 				String[] referencedColumnValues) {
 			this.timing = timing;
 			this.referenceColumnInSql = referenceColumnInSql;
 			this.referencedColumnValues = referencedColumnValues;
 		}
 
 		@Override
 		public GenerationTiming getGenerationTiming() {
 			return timing;
 		}
 
 		@Override
 		public boolean referenceColumnsInSql() {
 			return referenceColumnInSql;
 		}
 
 		@Override
 		public String[] getReferencedColumnValues() {
 			return referencedColumnValues;
 		}
 	}
 
 	private ValueInclusion determineInsertValueGenerationType(Property mappingProperty, NonIdentifierAttribute runtimeProperty) {
 		if ( isInsertGenerated( runtimeProperty ) ) {
 			return ValueInclusion.FULL;
 		}
 		else if ( mappingProperty.getValue() instanceof Component ) {
 			if ( hasPartialInsertComponentGeneration( ( Component ) mappingProperty.getValue() ) ) {
 				return ValueInclusion.PARTIAL;
 			}
 		}
 		return ValueInclusion.NONE;
 	}
 
 	private boolean isInsertGenerated(NonIdentifierAttribute property) {
 		return property.getValueGenerationStrategy() != null
 				&& property.getValueGenerationStrategy().getGenerationTiming() != GenerationTiming.NEVER;
 	}
 
 	private boolean isInsertGenerated(Property property) {
 		return property.getValueGenerationStrategy() != null
 				&& property.getValueGenerationStrategy().getGenerationTiming() != GenerationTiming.NEVER;
 	}
 
-	public EntityMetamodel(
-			EntityBinding entityBinding,
-			AbstractEntityPersister persister,
-			SessionFactoryImplementor sessionFactory) {
-		this.sessionFactory = sessionFactory;
-		this.persister = persister;
-
-		name = entityBinding.getEntity().getName();
-
-		rootName = entityBinding.getHierarchyDetails().getRootEntityBinding().getEntity().getName();
-		entityType = sessionFactory.getTypeResolver().getTypeFactory().manyToOne( name );
-
-		identifierAttribute = PropertyFactory.buildIdentifierProperty(
-				entityBinding,
-				sessionFactory.getIdentifierGenerator( rootName )
-		);
-
-		versioned = entityBinding.isVersioned();
-
-		boolean hasPojoRepresentation = false;
-		Class<?> mappedClass = null;
-		Class<?> proxyInterfaceClass = null;
-		if ( entityBinding.getEntity().getClassReferenceUnresolved() != null ) {
-			hasPojoRepresentation = true;
-			mappedClass = entityBinding.getEntity().getClassReference();
-			proxyInterfaceClass = entityBinding.getProxyInterfaceType().getValue();
-		}
-		instrumentationMetadata = Environment.getBytecodeProvider().getEntityInstrumentationMetadata( mappedClass );
-
-		boolean hasLazy = false;
-
-		// TODO: Fix after HHH-6337 is fixed; for now assume entityBinding is the root binding
-		BasicAttributeBinding rootEntityIdentifier = entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding();
-		// entityBinding.getAttributeClosureSpan() includes the identifier binding;
-		// "properties" here excludes the ID, so subtract 1 if the identifier binding is non-null
-		propertySpan = rootEntityIdentifier == null ?
-				entityBinding.getAttributeBindingClosureSpan() :
-				entityBinding.getAttributeBindingClosureSpan() - 1;
-
-		properties = new NonIdentifierAttribute[propertySpan];
-		List naturalIdNumbers = new ArrayList();
-		// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-		propertyNames = new String[propertySpan];
-		propertyTypes = new Type[propertySpan];
-		propertyUpdateability = new boolean[propertySpan];
-		propertyInsertability = new boolean[propertySpan];
-		nonlazyPropertyUpdateability = new boolean[propertySpan];
-		propertyCheckability = new boolean[propertySpan];
-		propertyNullability = new boolean[propertySpan];
-		propertyVersionability = new boolean[propertySpan];
-		propertyLaziness = new boolean[propertySpan];
-		cascadeStyles = new CascadeStyle[propertySpan];
-		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-
-		// todo : handle value generations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-		this.hasPreInsertGeneratedValues = false;
-		this.hasPreUpdateGeneratedValues = false;
-		this.hasInsertGeneratedValues = false;
-		this.hasUpdateGeneratedValues = false;
-		this.inMemoryValueGenerationStrategies = new InMemoryValueGenerationStrategy[propertySpan];
-		Arrays.fill( this.inMemoryValueGenerationStrategies, NoInMemoryValueGenerationStrategy.INSTANCE );
-		this.inDatabaseValueGenerationStrategies = new InDatabaseValueGenerationStrategy[propertySpan];
-		Arrays.fill( this.inDatabaseValueGenerationStrategies, NoInDatabaseValueGenerationStrategy.INSTANCE );
-		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-		int i = 0;
-		int tempVersionProperty = NO_VERSION_INDX;
-		boolean foundCascade = false;
-		boolean foundCollection = false;
-		boolean foundMutable = false;
-		boolean foundNonIdentifierPropertyNamedId = false;
-		boolean foundInsertGeneratedValue = false;
-		boolean foundUpdateGeneratedValue = false;
-		boolean foundUpdateableNaturalIdProperty = false;
-
-		for ( AttributeBinding attributeBinding : entityBinding.getAttributeBindingClosure() ) {
-			if ( attributeBinding == rootEntityIdentifier ) {
-				// skip the identifier attribute binding
-				continue;
-			}
-
-			if ( attributeBinding == entityBinding.getHierarchyDetails().getVersioningAttributeBinding() ) {
-				tempVersionProperty = i;
-				properties[i] = PropertyFactory.buildVersionProperty(
-						persister,
-						entityBinding.getHierarchyDetails().getVersioningAttributeBinding(),
-						instrumentationMetadata.isInstrumented()
-				);
-			}
-			else {
-				properties[i] = PropertyFactory.buildStandardProperty( attributeBinding, instrumentationMetadata.isInstrumented() );
-			}
-
-			// TODO: fix when natural IDs are added (HHH-6354)
-			//if ( attributeBinding.isNaturalIdentifier() ) {
-			//	naturalIdNumbers.add( i );
-			//	if ( attributeBinding.isUpdateable() ) {
-			//		foundUpdateableNaturalIdProperty = true;
-			//	}
-			//}
-
-			if ( "id".equals( attributeBinding.getAttribute().getName() ) ) {
-				foundNonIdentifierPropertyNamedId = true;
-			}
-
-			// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-			boolean lazy = attributeBinding.isLazy() && instrumentationMetadata.isInstrumented();
-			if ( lazy ) hasLazy = true;
-			propertyLaziness[i] = lazy;
-
-			propertyNames[i] = properties[i].getName();
-			propertyTypes[i] = properties[i].getType();
-			propertyNullability[i] = properties[i].isNullable();
-			propertyUpdateability[i] = properties[i].isUpdateable();
-			propertyInsertability[i] = properties[i].isInsertable();
-			propertyVersionability[i] = properties[i].isVersionable();
-			nonlazyPropertyUpdateability[i] = properties[i].isUpdateable() && !lazy;
-			propertyCheckability[i] = propertyUpdateability[i] ||
-					( propertyTypes[i].isAssociationType() && ( (AssociationType) propertyTypes[i] ).isAlwaysDirtyChecked() );
-
-			cascadeStyles[i] = properties[i].getCascadeStyle();
-			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-			if ( properties[i].isLazy() ) {
-				hasLazy = true;
-			}
-
-			if ( properties[i].getCascadeStyle() != CascadeStyles.NONE ) {
-				foundCascade = true;
-			}
-
-			if ( indicatesCollection( properties[i].getType() ) ) {
-				foundCollection = true;
-			}
-
-			if ( propertyTypes[i].isMutable() && propertyCheckability[i] ) {
-				foundMutable = true;
-			}
-
-			mapPropertyToIndex(attributeBinding.getAttribute(), i);
-			i++;
-		}
-
-		if (naturalIdNumbers.size()==0) {
-			naturalIdPropertyNumbers = null;
-			hasImmutableNaturalId = false;
-			hasCacheableNaturalId = false;
-		}
-		else {
-			naturalIdPropertyNumbers = ArrayHelper.toIntArray(naturalIdNumbers);
-			hasImmutableNaturalId = !foundUpdateableNaturalIdProperty;
-			hasCacheableNaturalId = false; //See previous TODO and HHH-6354
-		}
-
-		hasCascades = foundCascade;
-		hasNonIdentifierPropertyNamedId = foundNonIdentifierPropertyNamedId;
-		versionPropertyIndex = tempVersionProperty;
-		hasLazyProperties = hasLazy;
-		if (hasLazyProperties) {
-			LOG.lazyPropertyFetchingAvailable( name );
-		}
-
-		lazy = entityBinding.isLazy() && (
-				// TODO: this disables laziness even in non-pojo entity modes:
-				! hasPojoRepresentation ||
-				! ReflectHelper.isFinalClass( proxyInterfaceClass )
-		);
-		mutable = entityBinding.isMutable();
-		if ( entityBinding.isAbstract() == null ) {
-			// legacy behavior (with no abstract attribute specified)
-			isAbstract = hasPojoRepresentation &&
-			             ReflectHelper.isAbstractClass( mappedClass );
-		}
-		else {
-			isAbstract = entityBinding.isAbstract().booleanValue();
-			if ( !isAbstract && hasPojoRepresentation &&
-					ReflectHelper.isAbstractClass( mappedClass ) ) {
-				LOG.entityMappedAsNonAbstract(name);
-			}
-		}
-		selectBeforeUpdate = entityBinding.isSelectBeforeUpdate();
-		dynamicUpdate = entityBinding.isDynamicUpdate();
-		dynamicInsert = entityBinding.isDynamicInsert();
-
-		hasSubclasses = entityBinding.hasSubEntityBindings();
-		polymorphic = entityBinding.isPolymorphic();
-
-		explicitPolymorphism = entityBinding.getHierarchyDetails().isExplicitPolymorphism();
-		inherited = ! entityBinding.isRoot();
-		superclass = inherited ?
-				entityBinding.getEntity().getSuperType().getName() :
-				null;
-
-		optimisticLockStyle = entityBinding.getHierarchyDetails().getOptimisticLockStyle();
-		final boolean isAllOrDirty =
-				optimisticLockStyle == OptimisticLockStyle.ALL
-						|| optimisticLockStyle == OptimisticLockStyle.DIRTY;
-		if ( isAllOrDirty && !dynamicUpdate ) {
-			throw new MappingException( "optimistic-lock=all|dirty requires dynamic-update=\"true\": " + name );
-		}
-		if ( versionPropertyIndex != NO_VERSION_INDX && isAllOrDirty ) {
-			throw new MappingException( "version and optimistic-lock=all|dirty are not a valid combination : " + name );
-		}
-
-		hasCollections = foundCollection;
-		hasMutableProperties = foundMutable;
-
-		for ( EntityBinding subEntityBinding : entityBinding.getPostOrderSubEntityBindingClosure() ) {
-			subclassEntityNames.add( subEntityBinding.getEntity().getName() );
-			if ( subEntityBinding.getEntity().getClassReference() != null ) {
-				entityNameByInheritenceClassMap.put(
-						subEntityBinding.getEntity().getClassReference(),
-						subEntityBinding.getEntity().getName() );
-			}
-		}
-		subclassEntityNames.add( name );
-		if ( mappedClass != null ) {
-			entityNameByInheritenceClassMap.put( mappedClass, name );
-		}
-
-		entityMode = hasPojoRepresentation ? EntityMode.POJO : EntityMode.MAP;
-		final EntityTuplizerFactory entityTuplizerFactory = sessionFactory.getSettings().getEntityTuplizerFactory();
-		Class<? extends EntityTuplizer> tuplizerClass = entityBinding.getCustomEntityTuplizerClass();
-
-		if ( tuplizerClass == null ) {
-			entityTuplizer = entityTuplizerFactory.constructDefaultTuplizer( entityMode, this, entityBinding );
-		}
-		else {
-			entityTuplizer = entityTuplizerFactory.constructTuplizer( tuplizerClass, this, entityBinding );
-		}
-	}
-
-	private ValueInclusion determineInsertValueGenerationType(AttributeBinding mappingProperty, NonIdentifierAttribute runtimeProperty) {
-		if ( isInsertGenerated( runtimeProperty ) ) {
-			return ValueInclusion.FULL;
-		}
-		// TODO: fix the following when components are working (HHH-6173)
-		//else if ( mappingProperty.getValue() instanceof ComponentAttributeBinding ) {
-		//	if ( hasPartialInsertComponentGeneration( ( ComponentAttributeBinding ) mappingProperty.getValue() ) ) {
-		//		return ValueInclusion.PARTIAL;
-		//	}
-		//}
-		return ValueInclusion.NONE;
-	}
-
 	private boolean hasPartialInsertComponentGeneration(Component component) {
 		Iterator subProperties = component.getPropertyIterator();
 		while ( subProperties.hasNext() ) {
 			final Property prop = ( Property ) subProperties.next();
 			if ( isInsertGenerated( prop ) ) {
 				return true;
 			}
 			else if ( prop.getValue() instanceof Component ) {
 				if ( hasPartialInsertComponentGeneration( (Component) prop.getValue() ) ) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	private ValueInclusion determineUpdateValueGenerationType(Property mappingProperty, NonIdentifierAttribute runtimeProperty) {
 		if ( isUpdateGenerated( runtimeProperty ) ) {
 			return ValueInclusion.FULL;
 		}
 		else if ( mappingProperty.getValue() instanceof Component ) {
 			if ( hasPartialUpdateComponentGeneration( ( Component ) mappingProperty.getValue() ) ) {
 				return ValueInclusion.PARTIAL;
 			}
 		}
 		return ValueInclusion.NONE;
 	}
 
 	private static boolean isUpdateGenerated(Property property) {
 		return property.getValueGenerationStrategy() != null
 				&& property.getValueGenerationStrategy().getGenerationTiming() == GenerationTiming.ALWAYS;
 	}
 
 	private static boolean isUpdateGenerated(NonIdentifierAttribute property) {
 		return property.getValueGenerationStrategy() != null
 				&& property.getValueGenerationStrategy().getGenerationTiming() == GenerationTiming.ALWAYS;
 	}
 
-	private ValueInclusion determineUpdateValueGenerationType(AttributeBinding mappingProperty, NonIdentifierAttribute runtimeProperty) {
-		if ( isUpdateGenerated( runtimeProperty ) ) {
-			return ValueInclusion.FULL;
-		}
-		// TODO: fix the following when components are working (HHH-6173)
-		//else if ( mappingProperty.getValue() instanceof ComponentAttributeBinding ) {
-		//	if ( hasPartialUpdateComponentGeneration( ( ComponentAttributeBinding ) mappingProperty.getValue() ) ) {
-		//		return ValueInclusion.PARTIAL;
-		//	}
-		//}
-		return ValueInclusion.NONE;
-	}
-
 	private boolean hasPartialUpdateComponentGeneration(Component component) {
 		Iterator subProperties = component.getPropertyIterator();
 		while ( subProperties.hasNext() ) {
 			Property prop = (Property) subProperties.next();
 			if ( isUpdateGenerated( prop ) ) {
 				return true;
 			}
 			else if ( prop.getValue() instanceof Component ) {
 				if ( hasPartialUpdateComponentGeneration( ( Component ) prop.getValue() ) ) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	private void mapPropertyToIndex(Property prop, int i) {
 		propertyIndexes.put( prop.getName(), i );
 		if ( prop.getValue() instanceof Component ) {
 			Iterator iter = ( (Component) prop.getValue() ).getPropertyIterator();
 			while ( iter.hasNext() ) {
 				Property subprop = (Property) iter.next();
 				propertyIndexes.put(
 						prop.getName() + '.' + subprop.getName(),
 						i
 					);
 			}
 		}
 	}
 
-	private void mapPropertyToIndex(Attribute attribute, int i) {
-		propertyIndexes.put( attribute.getName(), i );
-		if ( attribute.isSingular() &&
-				( ( SingularAttribute ) attribute ).getSingularAttributeType().isComponent() ) {
-			org.hibernate.metamodel.domain.Component component =
-					( org.hibernate.metamodel.domain.Component ) ( ( SingularAttribute ) attribute ).getSingularAttributeType();
-			for ( Attribute subAttribute : component.attributes() ) {
-				propertyIndexes.put(
-						attribute.getName() + '.' + subAttribute.getName(),
-						i
-					);
-			}
-		}
-	}
-
 	public EntityTuplizer getTuplizer() {
 		return entityTuplizer;
 	}
 
 	public boolean isNaturalIdentifierInsertGenerated() {
 		// the intention is for this call to replace the usage of the old ValueInclusion stuff (as exposed from
 		// persister) in SelectGenerator to determine if it is safe to use the natural identifier to find the
 		// insert-generated identifier.  That wont work if the natural-id is also insert-generated.
 		//
 		// Assumptions:
 		//		* That code checks that there is a natural identifier before making this call, so we assume the same here
 		// 		* That code assumes a non-composite natural-id, so we assume the same here
 		final InDatabaseValueGenerationStrategy strategy = inDatabaseValueGenerationStrategies[ naturalIdPropertyNumbers[0] ];
 		return strategy != null && strategy.getGenerationTiming() != GenerationTiming.NEVER;
 	}
 
 	public boolean isVersionGenerated() {
 		final InDatabaseValueGenerationStrategy strategy = inDatabaseValueGenerationStrategies[ versionPropertyIndex ];
 		return strategy != null && strategy.getGenerationTiming() != GenerationTiming.NEVER;
 	}
 
 	public int[] getNaturalIdentifierProperties() {
 		return naturalIdPropertyNumbers;
 	}
 
 	public boolean hasNaturalIdentifier() {
 		return naturalIdPropertyNumbers!=null;
 	}
 	
 	public boolean isNaturalIdentifierCached() {
 		return hasNaturalIdentifier() && hasCacheableNaturalId;
 	}
 
 	public boolean hasImmutableNaturalId() {
 		return hasImmutableNaturalId;
 	}
 
 	public Set getSubclassEntityNames() {
 		return subclassEntityNames;
 	}
 
 	private boolean indicatesCollection(Type type) {
 		if ( type.isCollectionType() ) {
 			return true;
 		}
 		else if ( type.isComponentType() ) {
 			Type[] subtypes = ( (CompositeType) type ).getSubtypes();
 			for ( int i = 0; i < subtypes.length; i++ ) {
 				if ( indicatesCollection( subtypes[i] ) ) {
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	public SessionFactoryImplementor getSessionFactory() {
 		return sessionFactory;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public String getRootName() {
 		return rootName;
 	}
 
 	public EntityType getEntityType() {
 		return entityType;
 	}
 
 	public IdentifierProperty getIdentifierProperty() {
 		return identifierAttribute;
 	}
 
 	public int getPropertySpan() {
 		return propertySpan;
 	}
 
 	public int getVersionPropertyIndex() {
 		return versionPropertyIndex;
 	}
 
 	public VersionProperty getVersionProperty() {
 		if ( NO_VERSION_INDX == versionPropertyIndex ) {
 			return null;
 		}
 		else {
 			return ( VersionProperty ) properties[ versionPropertyIndex ];
 		}
 	}
 
 	public NonIdentifierAttribute[] getProperties() {
 		return properties;
 	}
 
 	public int getPropertyIndex(String propertyName) {
 		Integer index = getPropertyIndexOrNull(propertyName);
 		if ( index == null ) {
 			throw new HibernateException("Unable to resolve property: " + propertyName);
 		}
 		return index;
 	}
 
 	public Integer getPropertyIndexOrNull(String propertyName) {
 		return propertyIndexes.get( propertyName );
 	}
 
 	public boolean hasCollections() {
 		return hasCollections;
 	}
 
 	public boolean hasMutableProperties() {
 		return hasMutableProperties;
 	}
 
 	public boolean hasNonIdentifierPropertyNamedId() {
 		return hasNonIdentifierPropertyNamedId;
 	}
 
 	public boolean hasLazyProperties() {
 		return hasLazyProperties;
 	}
 
 	public boolean hasCascades() {
 		return hasCascades;
 	}
 
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	public boolean isSelectBeforeUpdate() {
 		return selectBeforeUpdate;
 	}
 
 	public boolean isDynamicUpdate() {
 		return dynamicUpdate;
 	}
 
 	public boolean isDynamicInsert() {
 		return dynamicInsert;
 	}
 
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return optimisticLockStyle;
 	}
 
 	public boolean isPolymorphic() {
 		return polymorphic;
 	}
 
 	public String getSuperclass() {
 		return superclass;
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return explicitPolymorphism;
 	}
 
 	public boolean isInherited() {
 		return inherited;
 	}
 
 	public boolean hasSubclasses() {
 		return hasSubclasses;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public boolean isVersioned() {
 		return versioned;
 	}
 
 	public boolean isAbstract() {
 		return isAbstract;
 	}
 
 	/**
 	 * Return the entity-name mapped to the given class within our inheritance hierarchy, if any.
 	 *
 	 * @param inheritenceClass The class for which to resolve the entity-name.
 	 * @return The mapped entity-name, or null if no such mapping was found.
 	 */
 	public String findEntityNameByEntityClass(Class inheritenceClass) {
 		return ( String ) entityNameByInheritenceClassMap.get( inheritenceClass );
 	}
 
 	@Override
     public String toString() {
 		return "EntityMetamodel(" + name + ':' + ArrayHelper.toString(properties) + ')';
 	}
 
 	// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	public String[] getPropertyNames() {
 		return propertyNames;
 	}
 
 	public Type[] getPropertyTypes() {
 		return propertyTypes;
 	}
 
 	public boolean[] getPropertyLaziness() {
 		return propertyLaziness;
 	}
 
 	public boolean[] getPropertyUpdateability() {
 		return propertyUpdateability;
 	}
 
 	public boolean[] getPropertyCheckability() {
 		return propertyCheckability;
 	}
 
 	public boolean[] getNonlazyPropertyUpdateability() {
 		return nonlazyPropertyUpdateability;
 	}
 
 	public boolean[] getPropertyInsertability() {
 		return propertyInsertability;
 	}
 
 	public boolean[] getPropertyNullability() {
 		return propertyNullability;
 	}
 
 	public boolean[] getPropertyVersionability() {
 		return propertyVersionability;
 	}
 
 	public CascadeStyle[] getCascadeStyles() {
 		return cascadeStyles;
 	}
 
 	public boolean hasPreInsertGeneratedValues() {
 		return hasPreInsertGeneratedValues;
 	}
 
 	public boolean hasPreUpdateGeneratedValues() {
 		return hasPreUpdateGeneratedValues;
 	}
 
 	public boolean hasInsertGeneratedValues() {
 		return hasInsertGeneratedValues;
 	}
 
 	public boolean hasUpdateGeneratedValues() {
 		return hasUpdateGeneratedValues;
 	}
 
 	public InMemoryValueGenerationStrategy[] getInMemoryValueGenerationStrategies() {
 		return inMemoryValueGenerationStrategies;
 	}
 
 	public InDatabaseValueGenerationStrategy[] getInDatabaseValueGenerationStrategies() {
 		return inDatabaseValueGenerationStrategies;
 	}
 
 	public EntityMode getEntityMode() {
 		return entityMode;
 	}
 
 	/**
 	 * Whether or not this class can be lazy (ie intercepted)
 	 */
 	public boolean isInstrumented() {
 		return instrumentationMetadata.isInstrumented();
 	}
 
 	public EntityInstrumentationMetadata getInstrumentationMetadata() {
 		return instrumentationMetadata;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizerFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizerFactory.java
index 8be52bd0c8..c8a4f1bb6c 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizerFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizerFactory.java
@@ -1,249 +1,170 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
 
 /**
  * A registry allowing users to define the default {@link EntityTuplizer} class to use per {@link EntityMode}.
  *
  * @author Steve Ebersole
  */
 public class EntityTuplizerFactory implements Serializable {
 	public static final Class[] ENTITY_TUP_CTOR_SIG = new Class[] { EntityMetamodel.class, PersistentClass.class };
-	public static final Class[] ENTITY_TUP_CTOR_SIG_NEW = new Class[] { EntityMetamodel.class, EntityBinding.class };
 
 	private Map<EntityMode,Class<? extends EntityTuplizer>> defaultImplClassByMode = buildBaseMapping();
 
 	/**
 	 * Method allowing registration of the tuplizer class to use as default for a particular entity-mode.
 	 *
 	 * @param entityMode The entity-mode for which to register the tuplizer class
 	 * @param tuplizerClass The class to use as the default tuplizer for the given entity-mode.
 	 */
 	public void registerDefaultTuplizerClass(EntityMode entityMode, Class<? extends EntityTuplizer> tuplizerClass) {
 		assert isEntityTuplizerImplementor( tuplizerClass )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] does not implement " + EntityTuplizer.class.getName();
 		// TODO: for now we need constructors for both PersistentClass and EntityBinding
 		assert hasProperConstructor( tuplizerClass, ENTITY_TUP_CTOR_SIG )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] is not properly instantiatable";
-		assert hasProperConstructor( tuplizerClass, ENTITY_TUP_CTOR_SIG_NEW )
-				: "Specified tuplizer class [" + tuplizerClass.getName() + "] is not properly instantiatable";
 		defaultImplClassByMode.put( entityMode, tuplizerClass );
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
 	 * @param tuplizerClassName The name of the tuplizer class to instantiate
 	 * @param metamodel The metadata for the entity.
 	 * @param persistentClass The mapping info for the entity.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If class name cannot be resolved to a class reference, or if the
 	 * {@link Constructor#newInstance} call fails.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public EntityTuplizer constructTuplizer(
 			String tuplizerClassName,
 			EntityMetamodel metamodel,
 			PersistentClass persistentClass) {
 		try {
 			Class<? extends EntityTuplizer> tuplizerClass = ReflectHelper.classForName( tuplizerClassName );
 			return constructTuplizer( tuplizerClass, metamodel, persistentClass );
 		}
 		catch ( ClassNotFoundException e ) {
 			throw new HibernateException( "Could not locate specified tuplizer class [" + tuplizerClassName + "]" );
 		}
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
-	 * @param tuplizerClassName The name of the tuplizer class to instantiate
-	 * @param metamodel The metadata for the entity.
-	 * @param entityBinding The mapping info for the entity.
-	 *
-	 * @return The instantiated tuplizer
-	 *
-	 * @throws HibernateException If class name cannot be resolved to a class reference, or if the
-	 * {@link Constructor#newInstance} call fails.
-	 */
-	@SuppressWarnings({ "unchecked" })
-	public EntityTuplizer constructTuplizer(
-			String tuplizerClassName,
-			EntityMetamodel metamodel,
-			EntityBinding entityBinding) {
-		try {
-			Class<? extends EntityTuplizer> tuplizerClass = ReflectHelper.classForName( tuplizerClassName );
-			return constructTuplizer( tuplizerClass, metamodel, entityBinding );
-		}
-		catch ( ClassNotFoundException e ) {
-			throw new HibernateException( "Could not locate specified tuplizer class [" + tuplizerClassName + "]" );
-		}
-	}
-
-	/**
-	 * Construct an instance of the given tuplizer class.
-	 *
 	 * @param tuplizerClass The tuplizer class to instantiate
 	 * @param metamodel The metadata for the entity.
 	 * @param persistentClass The mapping info for the entity.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException if the {@link Constructor#newInstance} call fails.
 	 */
 	public EntityTuplizer constructTuplizer(
 			Class<? extends EntityTuplizer> tuplizerClass,
 			EntityMetamodel metamodel,
 			PersistentClass persistentClass) {
 		Constructor<? extends EntityTuplizer> constructor = getProperConstructor( tuplizerClass, ENTITY_TUP_CTOR_SIG );
 		assert constructor != null : "Unable to locate proper constructor for tuplizer [" + tuplizerClass.getName() + "]";
 		try {
 			return constructor.newInstance( metamodel, persistentClass );
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Unable to instantiate default tuplizer [" + tuplizerClass.getName() + "]", t );
 		}
 	}
 
 	/**
-	 * Construct an instance of the given tuplizer class.
-	 *
-	 * @param tuplizerClass The tuplizer class to instantiate
-	 * @param metamodel The metadata for the entity.
-	 * @param entityBinding The mapping info for the entity.
-	 *
-	 * @return The instantiated tuplizer
-	 *
-	 * @throws HibernateException if the {@link Constructor#newInstance} call fails.
-	 */
-	public EntityTuplizer constructTuplizer(
-			Class<? extends EntityTuplizer> tuplizerClass,
-			EntityMetamodel metamodel,
-			EntityBinding entityBinding) {
-		Constructor<? extends EntityTuplizer> constructor = getProperConstructor( tuplizerClass, ENTITY_TUP_CTOR_SIG_NEW );
-		assert constructor != null : "Unable to locate proper constructor for tuplizer [" + tuplizerClass.getName() + "]";
-		try {
-			return constructor.newInstance( metamodel, entityBinding );
-		}
-		catch ( Throwable t ) {
-			throw new HibernateException( "Unable to instantiate default tuplizer [" + tuplizerClass.getName() + "]", t );
-		}
-	}
-
-	/**
 	 * Construct am instance of the default tuplizer for the given entity-mode.
 	 *
 	 * @param entityMode The entity mode for which to build a default tuplizer.
 	 * @param metamodel The entity metadata.
 	 * @param persistentClass The entity mapping info.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If no default tuplizer found for that entity-mode; may be re-thrown from
 	 * {@link #constructTuplizer} too.
 	 */
 	public EntityTuplizer constructDefaultTuplizer(
 			EntityMode entityMode,
 			EntityMetamodel metamodel,
 			PersistentClass persistentClass) {
 		Class<? extends EntityTuplizer> tuplizerClass = defaultImplClassByMode.get( entityMode );
 		if ( tuplizerClass == null ) {
 			throw new HibernateException( "could not determine default tuplizer class to use [" + entityMode + "]" );
 		}
 
 		return constructTuplizer( tuplizerClass, metamodel, persistentClass );
 	}
 
-	/**
-	 * Construct am instance of the default tuplizer for the given entity-mode.
-	 *
-	 * @param entityMode The entity mode for which to build a default tuplizer.
-	 * @param metamodel The entity metadata.
-	 * @param entityBinding The entity mapping info.
-	 *
-	 * @return The instantiated tuplizer
-	 *
-	 * @throws HibernateException If no default tuplizer found for that entity-mode; may be re-thrown from
-	 * {@link #constructTuplizer} too.
-	 */
-	public EntityTuplizer constructDefaultTuplizer(
-			EntityMode entityMode,
-			EntityMetamodel metamodel,
-			EntityBinding entityBinding) {
-		Class<? extends EntityTuplizer> tuplizerClass = defaultImplClassByMode.get( entityMode );
-		if ( tuplizerClass == null ) {
-			throw new HibernateException( "could not determine default tuplizer class to use [" + entityMode + "]" );
-		}
-
-		return constructTuplizer( tuplizerClass, metamodel, entityBinding );
-	}
-
 	private boolean isEntityTuplizerImplementor(Class tuplizerClass) {
 		return ReflectHelper.implementsInterface( tuplizerClass, EntityTuplizer.class );
 	}
 
 	private boolean hasProperConstructor(Class<? extends EntityTuplizer> tuplizerClass, Class[] constructorArgs) {
 		return getProperConstructor( tuplizerClass, constructorArgs ) != null
 				&& ! ReflectHelper.isAbstractClass( tuplizerClass );
 	}
 
 	private Constructor<? extends EntityTuplizer> getProperConstructor(
 			Class<? extends EntityTuplizer> clazz,
 			Class[] constructorArgs) {
 		Constructor<? extends EntityTuplizer> constructor = null;
 		try {
 			constructor = clazz.getDeclaredConstructor( constructorArgs );
 			try {
 				constructor.setAccessible( true );
 			}
 			catch ( SecurityException e ) {
 				constructor = null;
 			}
 		}
 		catch ( NoSuchMethodException ignore ) {
 		}
 
 		return constructor;
 	}
 
 	private static Map<EntityMode,Class<? extends EntityTuplizer>> buildBaseMapping() {
 		Map<EntityMode,Class<? extends EntityTuplizer>> map = new ConcurrentHashMap<EntityMode,Class<? extends EntityTuplizer>>();
 		map.put( EntityMode.POJO, PojoEntityTuplizer.class );
 		map.put( EntityMode.MAP, DynamicMapEntityTuplizer.class );
 		return map;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
index 41945c3436..4d4aed4bd4 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
@@ -1,512 +1,340 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
-import org.hibernate.PropertyNotFoundException;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.cfg.Environment;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Subclass;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
-import org.hibernate.property.PropertyAccessor;
-import org.hibernate.property.PropertyAccessorFactory;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.PojoInstantiator;
 import org.hibernate.type.CompositeType;
 
 /**
  * An {@link EntityTuplizer} specific to the pojo entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class PojoEntityTuplizer extends AbstractEntityTuplizer {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( PojoEntityTuplizer.class );
 
 	private final Class mappedClass;
 	private final Class proxyInterface;
 	private final boolean lifecycleImplementor;
 	private final Set lazyPropertyNames = new HashSet();
 	private final ReflectionOptimizer optimizer;
 	private final boolean isInstrumented;
 
 	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 		this.mappedClass = mappedEntity.getMappedClass();
 		this.proxyInterface = mappedEntity.getProxyInterface();
 		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
 		this.isInstrumented = entityMetamodel.isInstrumented();
 
 		Iterator iter = mappedEntity.getPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property property = (Property) iter.next();
 			if ( property.isLazy() ) {
 				lazyPropertyNames.add( property.getName() );
 			}
 		}
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[i].getMethodName();
 			setterNames[i] = setters[i].getMethodName();
 			propTypes[i] = getters[i].getReturnType();
 		}
 
 		if ( hasCustomAccessors || !Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// todo : YUCK!!!
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );
 //			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
 //					mappedClass, getterNames, setterNames, propTypes
 //			);
 		}
-
-	}
-
-	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappedEntity) {
-		super( entityMetamodel, mappedEntity );
-		this.mappedClass = mappedEntity.getEntity().getClassReference();
-		this.proxyInterface = mappedEntity.getProxyInterfaceType().getValue();
-		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
-		this.isInstrumented = entityMetamodel.isInstrumented();
-
-		for ( AttributeBinding property : mappedEntity.getAttributeBindingClosure() ) {
-			if ( property.isLazy() ) {
-				lazyPropertyNames.add( property.getAttribute().getName() );
-			}
-		}
-
-		String[] getterNames = new String[propertySpan];
-		String[] setterNames = new String[propertySpan];
-		Class[] propTypes = new Class[propertySpan];
-		for ( int i = 0; i < propertySpan; i++ ) {
-			getterNames[i] = getters[ i ].getMethodName();
-			setterNames[i] = setters[ i ].getMethodName();
-			propTypes[i] = getters[ i ].getReturnType();
-		}
-
-		if ( hasCustomAccessors || ! Environment.useReflectionOptimizer() ) {
-			optimizer = null;
-		}
-		else {
-			// todo : YUCK!!!
-			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
-					mappedClass, getterNames, setterNames, propTypes
-			);
-//			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
-//					mappedClass, getterNames, setterNames, propTypes
-//			);
-		}
 	}
 
 	@Override
     protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// determine the id getter and setter methods from the proxy interface (if any)
         // determine all interfaces needed by the resulting proxy
 		
 		/*
 		 * We need to preserve the order of the interfaces they were put into the set, since javassist will choose the
 		 * first one's class-loader to construct the proxy class with. This is also the reason why HibernateProxy.class
 		 * should be the last one in the order (on JBossAS7 its class-loader will be org.hibernate module's class-
 		 * loader, which will not see the classes inside deployed apps.  See HHH-3078
 		 */
 		Set<Class> proxyInterfaces = new java.util.LinkedHashSet<Class>();
 
 		Class mappedClass = persistentClass.getMappedClass();
 		Class proxyInterface = persistentClass.getProxyInterface();
 
 		if ( proxyInterface!=null && !mappedClass.equals( proxyInterface ) ) {
 			if ( !proxyInterface.isInterface() ) {
 				throw new MappingException(
 						"proxy must be either an interface, or the class itself: " + getEntityName()
 				);
 			}
 			proxyInterfaces.add( proxyInterface );
 		}
 
 		if ( mappedClass.isInterface() ) {
 			proxyInterfaces.add( mappedClass );
 		}
 
 		Iterator subclasses = persistentClass.getSubclassIterator();
 		while ( subclasses.hasNext() ) {
 			final Subclass subclass = ( Subclass ) subclasses.next();
 			final Class subclassProxy = subclass.getProxyInterface();
 			final Class subclassClass = subclass.getMappedClass();
 			if ( subclassProxy!=null && !subclassClass.equals( subclassProxy ) ) {
 				if ( !subclassProxy.isInterface() ) {
 					throw new MappingException(
 							"proxy must be either an interface, or the class itself: " + subclass.getEntityName()
 					);
 				}
 				proxyInterfaces.add( subclassProxy );
 			}
 		}
 
 		proxyInterfaces.add( HibernateProxy.class );
 
 		Iterator properties = persistentClass.getPropertyIterator();
 		Class clazz = persistentClass.getMappedClass();
 		while ( properties.hasNext() ) {
 			Property property = (Property) properties.next();
 			Method method = property.getGetter(clazz).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.gettersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 			method = property.getSetter(clazz).getMethod();
             if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.settersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 		}
 
 		Method idGetterMethod = idGetter==null ? null : idGetter.getMethod();
 		Method idSetterMethod = idSetter==null ? null : idSetter.getMethod();
 
 		Method proxyGetIdentifierMethod = idGetterMethod==null || proxyInterface==null ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idGetterMethod);
 		Method proxySetIdentifierMethod = idSetterMethod==null || proxyInterface==null  ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idSetterMethod);
 
 		ProxyFactory pf = buildProxyFactoryInternal( persistentClass, idGetter, idSetter );
 		try {
 			pf.postInstantiate(
 					getEntityName(),
 					mappedClass,
 					proxyInterfaces,
 					proxyGetIdentifierMethod,
 					proxySetIdentifierMethod,
 					persistentClass.hasEmbeddedIdentifier() ?
 			                (CompositeType) persistentClass.getIdentifier().getType() :
 			                null
 			);
 		}
 		catch ( HibernateException he ) {
             LOG.unableToCreateProxyFactory(getEntityName(), he);
 			pf = null;
 		}
 		return pf;
 	}
 
 	protected ProxyFactory buildProxyFactoryInternal(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// TODO : YUCK!!!  fix after HHH-1907 is complete
 		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 //		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 	}
 
 	@Override
     protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		if ( optimizer == null ) {
 			return new PojoInstantiator( persistentClass, null );
 		}
 		else {
 			return new PojoInstantiator( persistentClass, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	@Override
-	protected ProxyFactory buildProxyFactory(EntityBinding entityBinding, Getter idGetter, Setter idSetter) {
-		// determine the id getter and setter methods from the proxy interface (if any)
-		// determine all interfaces needed by the resulting proxy
-		HashSet<Class> proxyInterfaces = new HashSet<Class>();
-		proxyInterfaces.add( HibernateProxy.class );
-
-		Class mappedClass = entityBinding.getEntity().getClassReference();
-		Class proxyInterface = entityBinding.getProxyInterfaceType().getValue();
-
-		if ( proxyInterface!=null && !mappedClass.equals( proxyInterface ) ) {
-			if ( ! proxyInterface.isInterface() ) {
-				throw new MappingException(
-						"proxy must be either an interface, or the class itself: " + getEntityName()
-				);
-			}
-			proxyInterfaces.add( proxyInterface );
-		}
-
-		if ( mappedClass.isInterface() ) {
-			proxyInterfaces.add( mappedClass );
-		}
-
-		for ( EntityBinding subEntityBinding : entityBinding.getPostOrderSubEntityBindingClosure() ) {
-			final Class subclassProxy = subEntityBinding.getProxyInterfaceType().getValue();
-			final Class subclassClass = subEntityBinding.getClassReference();
-			if ( subclassProxy!=null && !subclassClass.equals( subclassProxy ) ) {
-				if ( ! subclassProxy.isInterface() ) {
-					throw new MappingException(
-							"proxy must be either an interface, or the class itself: " + subEntityBinding.getEntity().getName()
-					);
-				}
-				proxyInterfaces.add( subclassProxy );
-			}
-		}
-
-		for ( AttributeBinding property : entityBinding.attributeBindings() ) {
-			Method method = getGetter( property ).getMethod();
-			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
-				LOG.gettersOfLazyClassesCannotBeFinal(entityBinding.getEntity().getName(), property.getAttribute().getName());
-			}
-			method = getSetter( property ).getMethod();
-			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
-				LOG.settersOfLazyClassesCannotBeFinal(entityBinding.getEntity().getName(), property.getAttribute().getName());
-			}
-		}
-
-		Method idGetterMethod = idGetter==null ? null : idGetter.getMethod();
-		Method idSetterMethod = idSetter==null ? null : idSetter.getMethod();
-
-		Method proxyGetIdentifierMethod = idGetterMethod==null || proxyInterface==null ?
-				null :
-		        ReflectHelper.getMethod(proxyInterface, idGetterMethod);
-		Method proxySetIdentifierMethod = idSetterMethod==null || proxyInterface==null  ?
-				null :
-		        ReflectHelper.getMethod(proxyInterface, idSetterMethod);
-
-		ProxyFactory pf = buildProxyFactoryInternal( entityBinding, idGetter, idSetter );
-		try {
-			pf.postInstantiate(
-					getEntityName(),
-					mappedClass,
-					proxyInterfaces,
-					proxyGetIdentifierMethod,
-					proxySetIdentifierMethod,
-					entityBinding.getHierarchyDetails().getEntityIdentifier().isEmbedded()
-							? ( CompositeType ) entityBinding
-									.getHierarchyDetails()
-									.getEntityIdentifier()
-									.getValueBinding()
-									.getHibernateTypeDescriptor()
-									.getResolvedTypeMapping()
-							: null
-			);
-		}
-		catch ( HibernateException he ) {
-			LOG.unableToCreateProxyFactory(getEntityName(), he);
-			pf = null;
-		}
-		return pf;
-	}
-
-	protected ProxyFactory buildProxyFactoryInternal(EntityBinding entityBinding, Getter idGetter, Setter idSetter) {
-		// TODO : YUCK!!!  fix after HHH-1907 is complete
-		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
-//		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
-	}
-
-	@Override
-	protected Instantiator buildInstantiator(EntityBinding entityBinding) {
-		if ( optimizer == null ) {
-			return new PojoInstantiator( entityBinding, null );
-		}
-		else {
-			return new PojoInstantiator( entityBinding, optimizer.getInstantiationOptimizer() );
-		}
-	}
-
-	@Override
     public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		if ( !getEntityMetamodel().hasLazyProperties() && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			setPropertyValuesWithOptimizer( entity, values );
 		}
 		else {
 			super.setPropertyValues( entity, values );
 		}
 	}
 
 	@Override
     public Object[] getPropertyValues(Object entity) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValues( entity );
 		}
 	}
 
 	@Override
     public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValuesToInsert( entity, mergeMap, session );
 		}
 	}
 
 	protected void setPropertyValuesWithOptimizer(Object object, Object[] values) {
 		optimizer.getAccessOptimizer().setPropertyValues( object, values );
 	}
 
 	protected Object[] getPropertyValuesWithOptimizer(Object object) {
 		return optimizer.getAccessOptimizer().getPropertyValues( object );
 	}
 
 	@Override
 	public EntityMode getEntityMode() {
 		return EntityMode.POJO;
 	}
 
 	@Override
 	public Class getMappedClass() {
 		return mappedClass;
 	}
 
 	@Override
     public boolean isLifecycleImplementor() {
 		return lifecycleImplementor;
 	}
 
 	@Override
     protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getGetter( mappedEntity.getMappedClass() );
 	}
 
 	@Override
     protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getSetter( mappedEntity.getMappedClass() );
 	}
 
 	@Override
-	protected Getter buildPropertyGetter(AttributeBinding mappedProperty) {
-		return getGetter( mappedProperty );
-	}
-
-	@Override
-	protected Setter buildPropertySetter(AttributeBinding mappedProperty) {
-		return getSetter( mappedProperty );
-	}
-
-	private Getter getGetter(AttributeBinding mappedProperty)  throws PropertyNotFoundException, MappingException {
-		return getPropertyAccessor( mappedProperty ).getGetter(
-				mappedProperty.getContainer().getClassReference(),
-				mappedProperty.getAttribute().getName()
-		);
-	}
-
-	private Setter getSetter(AttributeBinding mappedProperty) throws PropertyNotFoundException, MappingException {
-		return getPropertyAccessor( mappedProperty ).getSetter(
-				mappedProperty.getContainer().getClassReference(),
-				mappedProperty.getAttribute().getName()
-		);
-	}
-
-	private PropertyAccessor getPropertyAccessor(AttributeBinding mappedProperty) throws MappingException {
-		// TODO: Fix this then backrefs are working in new metamodel
-		return PropertyAccessorFactory.getPropertyAccessor(
-				mappedProperty.getContainer().getClassReference(),
-				mappedProperty.getPropertyAccessorName()
-		);
-	}
-
-	@Override
 	public Class getConcreteProxyClass() {
 		return proxyInterface;
 	}
 
     //TODO: need to make the majority of this functionality into a top-level support class for custom impl support
 
 	@Override
     public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		if ( isInstrumented() ) {
 			Set lazyProps = lazyPropertiesAreUnfetched && getEntityMetamodel().hasLazyProperties() ?
 					lazyPropertyNames : null;
 			//TODO: if we support multiple fetch groups, we would need
 			//      to clone the set of lazy properties!
 			FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
 
             //also clear the fields that are marked as dirty in the dirtyness tracker
             if(entity instanceof org.hibernate.engine.spi.SelfDirtinessTracker) {
                 ((org.hibernate.engine.spi.SelfDirtinessTracker) entity).$$_hibernate_clearDirtyAttributes();
             }
 		}
 	}
 
 	@Override
     public boolean hasUninitializedLazyProperties(Object entity) {
 		if ( getEntityMetamodel().hasLazyProperties() ) {
 			FieldInterceptor callback = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			return callback != null && !callback.isInitialized();
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	public boolean isInstrumented() {
 		return isInstrumented;
 	}
 
 	@Override
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		final Class concreteEntityClass = entityInstance.getClass();
 		if ( concreteEntityClass == getMappedClass() ) {
 			return getEntityName();
 		}
 		else {
 			String entityName = getEntityMetamodel().findEntityNameByEntityClass( concreteEntityClass );
 			if ( entityName == null ) {
 				throw new HibernateException(
 						"Unable to resolve entity name from Class [" + concreteEntityClass.getName() + "]"
 								+ " expected instance/subclass of [" + getEntityName() + "]"
 				);
 			}
 			return entityName;
 		}
 	}
 
 	@Override
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractLobType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractLobType.java
index 49b9cc8d28..d039e82a28 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractLobType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractLobType.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 /**
  * @author Emmanuel Bernard
  * @deprecated
  */
 @Deprecated
 public abstract class AbstractLobType extends AbstractType implements Serializable {
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		return checkable[0] ? ! isEqual( old, current ) : false;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return new Size[] { LEGACY_DICTATED_SIZE };
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return new Size[] { LEGACY_DEFAULT_SIZE };
 	}
 
 	@Override
 	public boolean isEqual(Object x, Object y) {
 		return isEqual( x, y, null );
 	}
 
 	@Override
 	public int getHashCode(Object x) {
 		return getHashCode( x, null );
 	}
 
 	public String getName() {
 		return this.getClass().getName();
 	}
 
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		return 1;
 	}
 
 	protected abstract Object get(ResultSet rs, String name) throws SQLException;
 
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return get( rs, names[0] );
 	}
 
 	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return get( rs, name );
 	}
 
 	public void nullSafeSet(
 			PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session
 	) throws HibernateException, SQLException {
 		if ( settable[0] ) set( st, value, index, session );
 	}
 
 	protected abstract void set(PreparedStatement st, Object value, int index, SessionImplementor session)
 			throws SQLException;
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 			throws HibernateException, SQLException {
 		set( st, value, index, session );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractStandardBasicType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractStandardBasicType.java
index 26305cb152..7565eef267 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractStandardBasicType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractStandardBasicType.java
@@ -1,412 +1,412 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.type.descriptor.WrapperOptions;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 import org.hibernate.type.descriptor.java.MutabilityPlan;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 
 import org.dom4j.Node;
 
 /**
  * Convenience base class for {@link BasicType} implementations
  *
  * @author Steve Ebersole
  * @author Brett Meyer
  */
 public abstract class AbstractStandardBasicType<T>
 		implements BasicType, StringRepresentableType<T>, XmlRepresentableType<T>, ProcedureParameterExtractionAware<T> {
 
 	private static final Size DEFAULT_SIZE = new Size( 19, 2, 255, Size.LobMultiplier.NONE ); // to match legacy behavior
 	private final Size dictatedSize = new Size();
 
 	// Don't use final here.  Need to initialize after-the-fact
 	// by DynamicParameterizedTypes.
 	private SqlTypeDescriptor sqlTypeDescriptor;
 	private JavaTypeDescriptor<T> javaTypeDescriptor;
 	// sqlTypes need always to be in sync with sqlTypeDescriptor
 	private int[] sqlTypes;
 
 	public AbstractStandardBasicType(SqlTypeDescriptor sqlTypeDescriptor, JavaTypeDescriptor<T> javaTypeDescriptor) {
 		this.sqlTypeDescriptor = sqlTypeDescriptor;
 		this.sqlTypes = new int[] { sqlTypeDescriptor.getSqlType() };
 		this.javaTypeDescriptor = javaTypeDescriptor;
 	}
 
 	public T fromString(String string) {
 		return javaTypeDescriptor.fromString( string );
 	}
 
 	public String toString(T value) {
 		return javaTypeDescriptor.toString( value );
 	}
 
 	public T fromStringValue(String xml) throws HibernateException {
 		return fromString( xml );
 	}
 
 	public String toXMLString(T value, SessionFactoryImplementor factory) throws HibernateException {
 		return toString( value );
 	}
 
 	public T fromXMLString(String xml, Mapping factory) throws HibernateException {
 		return StringHelper.isEmpty( xml ) ? null : fromStringValue( xml );
 	}
 
 	protected MutabilityPlan<T> getMutabilityPlan() {
 		return javaTypeDescriptor.getMutabilityPlan();
 	}
 
 	protected T getReplacement(T original, T target, SessionImplementor session) {
 		if ( !isMutable() ) {
 			return original;
 		}
 		else if ( isEqual( original, target ) ) {
 			return original;
 		}
 		else {
 			return deepCopy( original );
 		}
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		return value == null ? ArrayHelper.FALSE : ArrayHelper.TRUE;
 	}
 
 	public String[] getRegistrationKeys() {
 		return registerUnderJavaType()
 				? new String[] { getName(), javaTypeDescriptor.getJavaTypeClass().getName() }
 				: new String[] { getName() };
 	}
 
 	protected boolean registerUnderJavaType() {
 		return false;
 	}
 
 	protected static Size getDefaultSize() {
 		return DEFAULT_SIZE;
 	}
 
 	protected Size getDictatedSize() {
 		return dictatedSize;
 	}
 	
 	// final implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public final JavaTypeDescriptor<T> getJavaTypeDescriptor() {
 		return javaTypeDescriptor;
 	}
 	
 	public final void setJavaTypeDescriptor( JavaTypeDescriptor<T> javaTypeDescriptor ) {
 		this.javaTypeDescriptor = javaTypeDescriptor;
 	}
 
 	public final SqlTypeDescriptor getSqlTypeDescriptor() {
 		return sqlTypeDescriptor;
 	}
 
 	public final void setSqlTypeDescriptor( SqlTypeDescriptor sqlTypeDescriptor ) {
 		this.sqlTypeDescriptor = sqlTypeDescriptor;
 		this.sqlTypes = new int[] { sqlTypeDescriptor.getSqlType() };
 	}
 
 	public final Class getReturnedClass() {
 		return javaTypeDescriptor.getJavaTypeClass();
 	}
 
 	public final int getColumnSpan(Mapping mapping) throws MappingException {
 		return 1;
 	}
 
 	public final int[] sqlTypes(Mapping mapping) throws MappingException {
 		return sqlTypes;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return new Size[] { getDictatedSize() };
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return new Size[] { getDefaultSize() };
 	}
 
 	public final boolean isAssociationType() {
 		return false;
 	}
 
 	public final boolean isCollectionType() {
 		return false;
 	}
 
 	public final boolean isComponentType() {
 		return false;
 	}
 
 	public final boolean isEntityType() {
 		return false;
 	}
 
 	public final boolean isAnyType() {
 		return false;
 	}
 
 	public final boolean isXMLElement() {
 		return false;
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final boolean isSame(Object x, Object y) {
 		return isEqual( x, y );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final boolean isEqual(Object x, Object y, SessionFactoryImplementor factory) {
 		return isEqual( x, y );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final boolean isEqual(Object one, Object another) {
 		return javaTypeDescriptor.areEqual( (T) one, (T) another );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final int getHashCode(Object x) {
 		return javaTypeDescriptor.extractHashCode( (T) x );
 	}
 
 	public final int getHashCode(Object x, SessionFactoryImplementor factory) {
 		return getHashCode( x );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final int compare(Object x, Object y) {
 		return javaTypeDescriptor.getComparator().compare( (T) x, (T) y );
 	}
 
 	public final boolean isDirty(Object old, Object current, SessionImplementor session) {
 		return isDirty( old, current );
 	}
 
 	public final boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session) {
 		return checkable[0] && isDirty( old, current );
 	}
 
 	protected final boolean isDirty(Object old, Object current) {
 		return !isSame( old, current );
 	}
 
 	public final boolean isModified(
 			Object oldHydratedState,
 			Object currentState,
 			boolean[] checkable,
 			SessionImplementor session) {
 		return isDirty( oldHydratedState, currentState );
 	}
 
 	public final Object nullSafeGet(
 			ResultSet rs,
 			String[] names,
 			SessionImplementor session,
 			Object owner) throws SQLException {
 		return nullSafeGet( rs, names[0], session );
 	}
 
 	public final Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)
 			throws SQLException {
 		return nullSafeGet( rs, name, session );
 	}
 
 	public final T nullSafeGet(ResultSet rs, String name, final SessionImplementor session) throws SQLException {
 		final WrapperOptions options = getOptions(session);
 		return nullSafeGet( rs, name, options );
 	}
 
 	protected final T nullSafeGet(ResultSet rs, String name, WrapperOptions options) throws SQLException {
 		return remapSqlTypeDescriptor( options ).getExtractor( javaTypeDescriptor ).extract( rs, name, options );
 	}
 
 	public Object get(ResultSet rs, String name, SessionImplementor session) throws HibernateException, SQLException {
 		return nullSafeGet( rs, name, session );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			final SessionImplementor session) throws SQLException {
 		final WrapperOptions options = getOptions(session);
 		nullSafeSet( st, value, index, options );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	protected final void nullSafeSet(PreparedStatement st, Object value, int index, WrapperOptions options) throws SQLException {
 		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
 	}
 
 	protected SqlTypeDescriptor remapSqlTypeDescriptor(WrapperOptions options) {
 		return options.remapSqlTypeDescriptor( sqlTypeDescriptor );
 	}
 
 	public void set(PreparedStatement st, T value, int index, SessionImplementor session) throws HibernateException, SQLException {
 		nullSafeSet( st, value, index, session );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final String toLoggableString(Object value, SessionFactoryImplementor factory) {
 		return javaTypeDescriptor.extractLoggableRepresentation( (T) value );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory) {
 		node.setText( toString( (T) value ) );
 	}
 
 	public final Object fromXMLNode(Node xml, Mapping factory) {
 		return fromString( xml.getText() );
 	}
 
 	public final boolean isMutable() {
 		return getMutabilityPlan().isMutable();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final Object deepCopy(Object value, SessionFactoryImplementor factory) {
 		return deepCopy( (T) value );
 	}
 
 	protected final T deepCopy(T value) {
 		return getMutabilityPlan().deepCopy( value );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final Serializable disassemble(Object value, SessionImplementor session, Object owner) throws HibernateException {
 		return getMutabilityPlan().disassemble( (T) value );
 	}
 
 	public final Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException {
 		return getMutabilityPlan().assemble( cached );
 	}
 
 	public final void beforeAssemble(Serializable cached, SessionImplementor session) {
 	}
 
 	public final Object hydrate(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return nullSafeGet(rs, names, session, owner);
 	}
 
 	public final Object resolve(Object value, SessionImplementor session, Object owner) throws HibernateException {
 		return value;
 	}
 
 	public final Object semiResolve(Object value, SessionImplementor session, Object owner) throws HibernateException {
 		return value;
 	}
 
 	public final Type getSemiResolvedType(SessionFactoryImplementor factory) {
 		return this;
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public final Object replace(Object original, Object target, SessionImplementor session, Object owner, Map copyCache) {
 		return getReplacement( (T) original, (T) target, session );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public Object replace(
 			Object original,
 			Object target,
 			SessionImplementor session,
 			Object owner,
 			Map copyCache,
 			ForeignKeyDirection foreignKeyDirection) {
 		return ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT == foreignKeyDirection
 				? getReplacement( (T) original, (T) target, session )
 				: target;
 	}
 
 	@Override
 	public boolean canDoExtraction() {
 		return true;
 	}
 
 	@Override
 	public T extract(CallableStatement statement, int startIndex, final SessionImplementor session) throws SQLException {
 		final WrapperOptions options = getOptions(session);
 		return remapSqlTypeDescriptor( options ).getExtractor( javaTypeDescriptor ).extract(
 				statement,
 				startIndex,
 				options
 		);
 	}
 
 	@Override
 	public T extract(CallableStatement statement, String[] paramNames, final SessionImplementor session) throws SQLException {
 		final WrapperOptions options = getOptions(session);
 		return remapSqlTypeDescriptor( options ).getExtractor( javaTypeDescriptor ).extract( statement, paramNames, options );
 	}
 	
 	// TODO : have SessionImplementor extend WrapperOptions
 	private WrapperOptions getOptions(final SessionImplementor session) {
 		return new WrapperOptions() {
 			public boolean useStreamForLobBinding() {
 				return Environment.useStreamsForBinary()
 						|| session.getFactory().getDialect().useInputStreamToInsertBlob();
 			}
 
 			public LobCreator getLobCreator() {
 				return Hibernate.getLobCreator( session );
 			}
 
 			public SqlTypeDescriptor remapSqlTypeDescriptor(SqlTypeDescriptor sqlTypeDescriptor) {
 				final SqlTypeDescriptor remapped = sqlTypeDescriptor.canBeRemapped()
 						? session.getFactory().getDialect().remapSqlTypeDescriptor( sqlTypeDescriptor )
 						: sqlTypeDescriptor;
 				return remapped == null ? sqlTypeDescriptor : remapped;
 			}
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractType.java
index fdd7aba4e4..10ff153485 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractType.java
@@ -1,189 +1,189 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.compare.EqualsHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 import org.dom4j.Element;
 import org.dom4j.Node;
 
 /**
  * Abstract superclass of the built in Type hierarchy.
  * 
  * @author Gavin King
  */
 public abstract class AbstractType implements Type {
 	protected static final Size LEGACY_DICTATED_SIZE = new Size();
 	protected static final Size LEGACY_DEFAULT_SIZE = new Size( 19, 2, 255, Size.LobMultiplier.NONE ); // to match legacy behavior
 
 	public boolean isAssociationType() {
 		return false;
 	}
 
 	public boolean isCollectionType() {
 		return false;
 	}
 
 	public boolean isComponentType() {
 		return false;
 	}
 
 	public boolean isEntityType() {
 		return false;
 	}
 	
 	public boolean isXMLElement() {
 		return false;
 	}
 
 	public int compare(Object x, Object y) {
 		return ( (Comparable) x ).compareTo(y);
 	}
 
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 	throws HibernateException {
 
 		if (value==null) {
 			return null;
 		}
 		else {
 			return (Serializable) deepCopy( value, session.getFactory() );
 		}
 	}
 
 	public Object assemble(Serializable cached, SessionImplementor session, Object owner)
 	throws HibernateException {
 		if ( cached==null ) {
 			return null;
 		}
 		else {
 			return deepCopy( cached, session.getFactory() );
 		}
 	}
 
 	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException {
 		return !isSame( old, current );
 	}
 
 	public Object hydrate(
 		ResultSet rs,
 		String[] names,
 		SessionImplementor session,
 		Object owner)
 	throws HibernateException, SQLException {
 		// TODO: this is very suboptimal for some subclasses (namely components),
 		// since it does not take advantage of two-phase-load
 		return nullSafeGet(rs, names, session, owner);
 	}
 
 	public Object resolve(Object value, SessionImplementor session, Object owner)
 	throws HibernateException {
 		return value;
 	}
 
 	public Object semiResolve(Object value, SessionImplementor session, Object owner) 
 	throws HibernateException {
 		return value;
 	}
 	
 	public boolean isAnyType() {
 		return false;
 	}
 
 	public boolean isModified(Object old, Object current, boolean[] checkable, SessionImplementor session)
 	throws HibernateException {
 		return isDirty(old, current, session);
 	}
 	
 	public boolean isSame(Object x, Object y) throws HibernateException {
 		return isEqual(x, y );
 	}
 
 	public boolean isEqual(Object x, Object y) {
 		return EqualsHelper.equals(x, y);
 	}
 	
 	public int getHashCode(Object x) {
 		return x.hashCode();
 	}
 
 	public boolean isEqual(Object x, Object y, SessionFactoryImplementor factory) {
 		return isEqual(x, y );
 	}
 	
 	public int getHashCode(Object x, SessionFactoryImplementor factory) {
 		return getHashCode(x );
 	}
 	
 	protected static void replaceNode(Node container, Element value) {
 		if ( container!=value ) { //not really necessary, I guess...
 			Element parent = container.getParent();
 			container.detach();
 			value.setName( container.getName() );
 			value.detach();
 			parent.add(value);
 		}
 	}
 	
 	public Type getSemiResolvedType(SessionFactoryImplementor factory) {
 		return this;
 	}
 
 	public Object replace(
 			Object original, 
 			Object target, 
 			SessionImplementor session, 
 			Object owner, 
 			Map copyCache, 
 			ForeignKeyDirection foreignKeyDirection) 
 	throws HibernateException {
 		boolean include;
 		if ( isAssociationType() ) {
 			AssociationType atype = (AssociationType) this;
 			include = atype.getForeignKeyDirection()==foreignKeyDirection;
 		}
 		else {
 			include = ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT==foreignKeyDirection;
 		}
 		return include ? replace(original, target, session, owner, copyCache) : target;
 	}
 
 	public void beforeAssemble(Serializable cached, SessionImplementor session) {}
 
 	/*public Object copy(Object original, Object target, SessionImplementor session, Object owner, Map copyCache)
 	throws HibernateException {
 		if (original==null) return null;
 		return assemble( disassemble(original, session), session, owner );
 	}*/
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AnyType.java b/hibernate-core/src/main/java/org/hibernate/type/AnyType.java
index 582d65adc3..31d67f626f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AnyType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AnyType.java
@@ -1,536 +1,536 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.HibernateProxyHelper;
 import org.hibernate.proxy.LazyInitializer;
 
 import org.dom4j.Node;
 
 /**
  * Handles "any" mappings
  * 
  * @author Gavin King
  */
 public class AnyType extends AbstractType implements CompositeType, AssociationType {
 	private final TypeFactory.TypeScope scope;
 	private final Type identifierType;
 	private final Type discriminatorType;
 
 	/**
 	 * Intended for use only from legacy {@link ObjectType} type definition
 	 *
 	 * @param discriminatorType
 	 * @param identifierType
 	 */
 	protected AnyType(Type discriminatorType, Type identifierType) {
 		this( null, discriminatorType, identifierType );
 	}
 
 	public AnyType(TypeFactory.TypeScope scope, Type discriminatorType, Type identifierType) {
 		this.scope = scope;
 		this.discriminatorType = discriminatorType;
 		this.identifierType = identifierType;
 	}
 
 	public Type getIdentifierType() {
 		return identifierType;
 	}
 
 	public Type getDiscriminatorType() {
 		return discriminatorType;
 	}
 
 
 	// general Type metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public String getName() {
 		return "object";
 	}
 
 	@Override
 	public Class getReturnedClass() {
 		return Object.class;
 	}
 
 	@Override
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		return ArrayHelper.join( discriminatorType.sqlTypes( mapping ), identifierType.sqlTypes( mapping ) );
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return ArrayHelper.join( discriminatorType.dictatedSizes( mapping ), identifierType.dictatedSizes( mapping ) );
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return ArrayHelper.join( discriminatorType.defaultSizes( mapping ), identifierType.defaultSizes( mapping ) );
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object component, EntityMode entityMode) {
 		throw new UnsupportedOperationException();
 	}
 
 	@Override
 	public boolean isAnyType() {
 		return true;
 	}
 
 	@Override
 	public boolean isAssociationType() {
 		return true;
 	}
 
 	@Override
 	public boolean isComponentType() {
 		return true;
 	}
 
 	@Override
 	public boolean isEmbedded() {
 		return false;
 	}
 
 	@Override
 	public boolean isMutable() {
 		return false;
 	}
 
 	@Override
 	public Object deepCopy(Object value, SessionFactoryImplementor factory) {
 		return value;
 	}
 
 
 	// general Type functionality ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public int compare(Object x, Object y) {
 		if ( x == null ) {
 			// if y is also null, return that they are the same (no option for "UNKNOWN")
 			// if y is not null, return that y is "greater" (-1 because the result is from the perspective of
 			// 		the first arg: x)
 			return y == null ? 0 : -1;
 		}
 		else if ( y == null ) {
 			// x is not null, but y is.  return that x is "greater"
 			return 1;
 		}
 
 		// At this point we know both are non-null.
 		final Object xId = extractIdentifier( x );
 		final Object yId = extractIdentifier( y );
 
 		return getIdentifierType().compare( xId, yId );
 	}
 
 	private Object extractIdentifier(Object entity) {
 		final EntityPersister concretePersister = guessEntityPersister( entity );
 		return concretePersister == null
 				? null
 				: concretePersister.getEntityTuplizer().getIdentifier( entity, null );
 	}
 
 	private EntityPersister guessEntityPersister(Object object) {
 		if ( scope == null ) {
 			return null;
 		}
 
 		String entityName = null;
 
 		// this code is largely copied from Session's bestGuessEntityName
 		Object entity = object;
 		if ( entity instanceof HibernateProxy ) {
 			final LazyInitializer initializer = ( (HibernateProxy) entity ).getHibernateLazyInitializer();
 			if ( initializer.isUninitialized() ) {
 				entityName = initializer.getEntityName();
 			}
 			entity = initializer.getImplementation();
 		}
 
 		if ( entityName == null ) {
 			for ( EntityNameResolver resolver : scope.resolveFactory().iterateEntityNameResolvers() ) {
 				entityName = resolver.resolveEntityName( entity );
 				if ( entityName != null ) {
 					break;
 				}
 			}
 		}
 
 		if ( entityName == null ) {
 			// the old-time stand-by...
 			entityName = object.getClass().getName();
 		}
 
 		return scope.resolveFactory().getEntityPersister( entityName );
 	}
 
 	@Override
 	public boolean isSame(Object x, Object y) throws HibernateException {
 		return x == y;
 	}
 
 	@Override
 	public boolean isModified(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		if ( current == null ) {
 			return old != null;
 		}
 		else if ( old == null ) {
 			return true;
 		}
 
 		final ObjectTypeCacheEntry holder = (ObjectTypeCacheEntry) old;
 		final boolean[] idCheckable = new boolean[checkable.length-1];
 		System.arraycopy( checkable, 1, idCheckable, 0, idCheckable.length );
 		return ( checkable[0] && !holder.entityName.equals( session.bestGuessEntityName( current ) ) )
 				|| identifierType.isModified( holder.id, getIdentifier( current, session ), idCheckable, session );
 	}
 
 	@Override
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		final boolean[] result = new boolean[ getColumnSpan( mapping ) ];
 		if ( value != null ) {
 			Arrays.fill( result, true );
 		}
 		return result;
 	}
 
 	@Override
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		return isDirty( old, current, session );
 	}
 
 	@Override
 	public int getColumnSpan(Mapping session) {
 		return 2;
 	}
 
 	@Override
 	public Object nullSafeGet(ResultSet rs,	String[] names,	SessionImplementor session,	Object owner)
 			throws HibernateException, SQLException {
 		return resolveAny(
 				(String) discriminatorType.nullSafeGet( rs, names[0], session, owner ),
 				(Serializable) identifierType.nullSafeGet( rs, names[1], session, owner ),
 				session
 		);
 	}
 
 	@Override
 	public Object hydrate(ResultSet rs,	String[] names,	SessionImplementor session,	Object owner)
 			throws HibernateException, SQLException {
 		final String entityName = (String) discriminatorType.nullSafeGet( rs, names[0], session, owner );
 		final Serializable id = (Serializable) identifierType.nullSafeGet( rs, names[1], session, owner );
 		return new ObjectTypeCacheEntry( entityName, id );
 	}
 
 	@Override
 	public Object resolve(Object value, SessionImplementor session, Object owner) throws HibernateException {
 		final ObjectTypeCacheEntry holder = (ObjectTypeCacheEntry) value;
 		return resolveAny( holder.entityName, holder.id, session );
 	}
 
 	private Object resolveAny(String entityName, Serializable id, SessionImplementor session)
 			throws HibernateException {
 		return entityName==null || id==null
 				? null
 				: session.internalLoad( entityName, id, false, false );
 	}
 
 	@Override
 	public void nullSafeSet(PreparedStatement st, Object value,	int index, SessionImplementor session)
 			throws HibernateException, SQLException {
 		nullSafeSet( st, value, index, null, session );
 	}
 
 	@Override
 	public void nullSafeSet(PreparedStatement st, Object value,	int index, boolean[] settable, SessionImplementor session)
 			throws HibernateException, SQLException {
 		Serializable id;
 		String entityName;
 		if ( value == null ) {
 			id = null;
 			entityName = null;
 		}
 		else {
 			entityName = session.bestGuessEntityName( value );
 			id = ForeignKeys.getEntityIdentifierIfNotUnsaved( entityName, value, session );
 		}
 
 		// discriminatorType is assumed to be single-column type
 		if ( settable == null || settable[0] ) {
 			discriminatorType.nullSafeSet( st, entityName, index, session );
 		}
 		if ( settable == null ) {
 			identifierType.nullSafeSet( st, id, index+1, session );
 		}
 		else {
 			final boolean[] idSettable = new boolean[ settable.length-1 ];
 			System.arraycopy( settable, 1, idSettable, 0, idSettable.length );
 			identifierType.nullSafeSet( st, id, index+1, idSettable, session );
 		}
 	}
 
 	@Override
 	public String toLoggableString(Object value, SessionFactoryImplementor factory) throws HibernateException {
 		//TODO: terrible implementation!
 		return value == null
 				? "null"
 				: factory.getTypeHelper()
 				.entity( HibernateProxyHelper.getClassWithoutInitializingProxy( value ) )
 				.toLoggableString( value, factory );
 	}
 
 	@Override
 	public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException {
 		final ObjectTypeCacheEntry e = (ObjectTypeCacheEntry) cached;
 		return e == null ? null : session.internalLoad( e.entityName, e.id, false, false );
 	}
 
 	@Override
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner) throws HibernateException {
 		if ( value == null ) {
 			return null;
 		}
 		else {
 			return new ObjectTypeCacheEntry(
 					session.bestGuessEntityName( value ),
 					ForeignKeys.getEntityIdentifierIfNotUnsaved(
 							session.bestGuessEntityName( value ),
 							value,
 							session
 					)
 			);
 		}
 	}
 
 	@Override
 	public Object replace(Object original, Object target, SessionImplementor session, Object owner, Map copyCache)
 			throws HibernateException {
 		if ( original == null ) {
 			return null;
 		}
 		else {
 			final String entityName = session.bestGuessEntityName( original );
 			final Serializable id = ForeignKeys.getEntityIdentifierIfNotUnsaved( entityName, original, session );
 			return session.internalLoad( entityName, id, false, false );
 		}
 	}
 
 	@Override
 	public Object nullSafeGet(ResultSet rs,	String name, SessionImplementor session, Object owner) {
 		throw new UnsupportedOperationException( "object is a multicolumn type" );
 	}
 
 	@Override
 	public Object semiResolve(Object value, SessionImplementor session, Object owner) {
 		throw new UnsupportedOperationException( "any mappings may not form part of a property-ref" );
 	}
 
 	@Override
 	public void setToXMLNode(Node xml, Object value, SessionFactoryImplementor factory) {
 		throw new UnsupportedOperationException("any types cannot be stringified");
 	}
 
 	@Override
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		throw new UnsupportedOperationException();
 	}
 
 
 
 	// CompositeType implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public boolean isMethodOf(Method method) {
 		return false;
 	}
 
 	private static final String[] PROPERTY_NAMES = new String[] { "class", "id" };
 
 	@Override
 	public String[] getPropertyNames() {
 		return PROPERTY_NAMES;
 	}
 
 	@Override
 	public Object getPropertyValue(Object component, int i, SessionImplementor session) throws HibernateException {
 		return i==0
 				? session.bestGuessEntityName( component )
 				: getIdentifier( component, session );
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object component, SessionImplementor session) throws HibernateException {
 		return new Object[] {
 				session.bestGuessEntityName( component ),
 				getIdentifier( component, session )
 		};
 	}
 
 	private Serializable getIdentifier(Object value, SessionImplementor session) throws HibernateException {
 		try {
 			return ForeignKeys.getEntityIdentifierIfNotUnsaved(
 					session.bestGuessEntityName( value ),
 					value,
 					session
 			);
 		}
 		catch (TransientObjectException toe) {
 			return null;
 		}
 	}
 
 	@Override
 	public void setPropertyValues(Object component, Object[] values, EntityMode entityMode) {
 		throw new UnsupportedOperationException();
 	}
 
 	private static final boolean[] NULLABILITY = new boolean[] { false, false };
 
 	@Override
 	public boolean[] getPropertyNullability() {
 		return NULLABILITY;
 	}
 
 	@Override
 	public Type[] getSubtypes() {
 		return new Type[] {discriminatorType, identifierType };
 	}
 
 	@Override
 	public CascadeStyle getCascadeStyle(int i) {
 		return CascadeStyles.NONE;
 	}
 
 	@Override
 	public FetchMode getFetchMode(int i) {
 		return FetchMode.SELECT;
 	}
 
 
 	// AssociationType implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public ForeignKeyDirection getForeignKeyDirection() {
 		return ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT;
 	}
 
 	@Override
 	public boolean useLHSPrimaryKey() {
 		return false;
 	}
 
 	@Override
 	public String getLHSPropertyName() {
 		return null;
 	}
 
 	public boolean isReferenceToPrimaryKey() {
 		return true;
 	}
 
 	@Override
 	public String getRHSUniqueKeyPropertyName() {
 		return null;
 	}
 
 	@Override
 	public boolean isAlwaysDirtyChecked() {
 		return false;
 	}
 
 	@Override
 	public boolean isEmbeddedInXML() {
 		return false;
 	}
 
 	@Override
 	public Joinable getAssociatedJoinable(SessionFactoryImplementor factory) {
 		throw new UnsupportedOperationException("any types do not have a unique referenced persister");
 	}
 
 	@Override
 	public String getAssociatedEntityName(SessionFactoryImplementor factory) {
 		throw new UnsupportedOperationException("any types do not have a unique referenced persister");
 	}
 
 	@Override
 	public String getOnCondition(String alias, SessionFactoryImplementor factory, Map enabledFilters) {
 		throw new UnsupportedOperationException();
 	}
 
 	@Override
 	public String getOnCondition(
 			String alias,
 			SessionFactoryImplementor factory,
 			Map enabledFilters,
 			Set<String> treatAsDeclarations) {
 		throw new UnsupportedOperationException();
 	}
 
 	/**
 	 * Used to externalize discrimination per a given identifier.  For example, when writing to
 	 * second level cache we write the discrimination resolved concrete type for each entity written.
 	 */
 	public static final class ObjectTypeCacheEntry implements Serializable {
 		final String entityName;
 		final Serializable id;
 
 		ObjectTypeCacheEntry(String entityName, Serializable id) {
 			this.entityName = entityName;
 			this.id = id;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/CollectionType.java b/hibernate-core/src/main/java/org/hibernate/type/CollectionType.java
index 3a76e13f9b..2c654cc91f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/CollectionType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/CollectionType.java
@@ -1,843 +1,843 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
 import org.hibernate.EntityMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.CollectionKey;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Element;
 import org.dom4j.Node;
 
 /**
  * A type that handles Hibernate <tt>PersistentCollection</tt>s (including arrays).
  * 
  * @author Gavin King
  */
 public abstract class CollectionType extends AbstractType implements AssociationType {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, CollectionType.class.getName());
 
 	private static final Object NOT_NULL_COLLECTION = new MarkerObject( "NOT NULL COLLECTION" );
 	public static final Object UNFETCHED_COLLECTION = new MarkerObject( "UNFETCHED COLLECTION" );
 
 	private final TypeFactory.TypeScope typeScope;
 	private final String role;
 	private final String foreignKeyPropertyName;
 	private final boolean isEmbeddedInXML;
 
 	/**
 	 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope, String, String)} instead
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public CollectionType(TypeFactory.TypeScope typeScope, String role, String foreignKeyPropertyName, boolean isEmbeddedInXML) {
 		this.typeScope = typeScope;
 		this.role = role;
 		this.foreignKeyPropertyName = foreignKeyPropertyName;
 		this.isEmbeddedInXML = isEmbeddedInXML;
 	}
 
 	public CollectionType(TypeFactory.TypeScope typeScope, String role, String foreignKeyPropertyName) {
 		this.typeScope = typeScope;
 		this.role = role;
 		this.foreignKeyPropertyName = foreignKeyPropertyName;
 		this.isEmbeddedInXML = true;
 	}
 
 	@Override
 	public boolean isEmbeddedInXML() {
 		return isEmbeddedInXML;
 	}
 
 	public String getRole() {
 		return role;
 	}
 
 	public Object indexOf(Object collection, Object element) {
 		throw new UnsupportedOperationException( "generic collections don't have indexes" );
 	}
 
 	public boolean contains(Object collection, Object childObject, SessionImplementor session) {
 		// we do not have to worry about queued additions to uninitialized
 		// collections, since they can only occur for inverse collections!
 		Iterator elems = getElementsIterator( collection, session );
 		while ( elems.hasNext() ) {
 			Object element = elems.next();
 			// worrying about proxies is perhaps a little bit of overkill here...
 			if ( element instanceof HibernateProxy ) {
 				LazyInitializer li = ( (HibernateProxy) element ).getHibernateLazyInitializer();
 				if ( !li.isUninitialized() ) element = li.getImplementation();
 			}
 			if ( element == childObject ) return true;
 		}
 		return false;
 	}
 
 	@Override
 	public boolean isCollectionType() {
 		return true;
 	}
 
 	@Override
 	public final boolean isEqual(Object x, Object y) {
 		return x == y
 			|| ( x instanceof PersistentCollection && ( (PersistentCollection) x ).isWrapper( y ) )
 			|| ( y instanceof PersistentCollection && ( (PersistentCollection) y ).isWrapper( x ) );
 	}
 
 	@Override
 	public int compare(Object x, Object y) {
 		return 0; // collections cannot be compared
 	}
 
 	@Override
 	public int getHashCode(Object x) {
 		throw new UnsupportedOperationException( "cannot doAfterTransactionCompletion lookups on collections" );
 	}
 
 	/**
 	 * Instantiate an uninitialized collection wrapper or holder. Callers MUST add the holder to the
 	 * persistence context!
 	 *
 	 * @param session The session from which the request is originating.
 	 * @param persister The underlying collection persister (metadata)
 	 * @param key The owner key.
 	 * @return The instantiated collection.
 	 */
 	public abstract PersistentCollection instantiate(SessionImplementor session, CollectionPersister persister, Serializable key);
 
 	@Override
 	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {
 		return nullSafeGet( rs, new String[] { name }, session, owner );
 	}
 
 	@Override
 	public Object nullSafeGet(ResultSet rs, String[] name, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return resolve( null, session, owner );
 	}
 
 	@Override
 	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable,
 			SessionImplementor session) throws HibernateException, SQLException {
 		//NOOP
 	}
 
 	@Override
 	public void nullSafeSet(PreparedStatement st, Object value, int index,
 			SessionImplementor session) throws HibernateException, SQLException {
 	}
 
 	@Override
 	public int[] sqlTypes(Mapping session) throws MappingException {
 		return ArrayHelper.EMPTY_INT_ARRAY;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return new Size[] { LEGACY_DICTATED_SIZE };
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return new Size[] { LEGACY_DEFAULT_SIZE };
 	}
 
 	@Override
 	public int getColumnSpan(Mapping session) throws MappingException {
 		return 0;
 	}
 
 	@Override
 	public String toLoggableString(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		if ( value == null ) {
 			return "null";
 		}
 		else if ( !Hibernate.isInitialized( value ) ) {
 			return "<uninitialized>";
 		}
 		else {
 			return renderLoggableString( value, factory );
 		}
 	}
 
 	protected String renderLoggableString(Object value, SessionFactoryImplementor factory) throws HibernateException {
 		final List<String> list = new ArrayList<String>();
 		Type elemType = getElementType( factory );
 		Iterator itr = getElementsIterator( value );
 		while ( itr.hasNext() ) {
 			list.add( elemType.toLoggableString( itr.next(), factory ) );
 		}
 		return list.toString();
 	}
 
 	@Override
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		return value;
 	}
 
 	@Override
 	public String getName() {
 		return getReturnedClass().getName() + '(' + getRole() + ')';
 	}
 
 	/**
 	 * Get an iterator over the element set of the collection, which may not yet be wrapped
 	 *
 	 * @param collection The collection to be iterated
 	 * @param session The session from which the request is originating.
 	 * @return The iterator.
 	 */
 	public Iterator getElementsIterator(Object collection, SessionImplementor session) {
 		return getElementsIterator(collection);
 	}
 
 	/**
 	 * Get an iterator over the element set of the collection in POJO mode
 	 *
 	 * @param collection The collection to be iterated
 	 * @return The iterator.
 	 */
 	protected Iterator getElementsIterator(Object collection) {
 		return ( (Collection) collection ).iterator();
 	}
 
 	@Override
 	public boolean isMutable() {
 		return false;
 	}
 
 	@Override
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 		//remember the uk value
 		
 		//This solution would allow us to eliminate the owner arg to disassemble(), but
 		//what if the collection was null, and then later had elements added? seems unsafe
 		//session.getPersistenceContext().getCollectionEntry( (PersistentCollection) value ).getKey();
 		
 		final Serializable key = getKeyOfOwner(owner, session);
 		if (key==null) {
 			return null;
 		}
 		else {
 			return getPersister(session)
 					.getKeyType()
 					.disassemble( key, session, owner );
 		}
 	}
 
 	@Override
 	public Object assemble(Serializable cached, SessionImplementor session, Object owner)
 			throws HibernateException {
 		//we must use the "remembered" uk value, since it is 
 		//not available from the EntityEntry during assembly
 		if (cached==null) {
 			return null;
 		}
 		else {
 			final Serializable key = (Serializable) getPersister(session)
 					.getKeyType()
 					.assemble( cached, session, owner);
 			return resolveKey( key, session, owner );
 		}
 	}
 
 	/**
 	 * Is the owning entity versioned?
 	 *
 	 * @param session The session from which the request is originating.
 	 * @return True if the collection owner is versioned; false otherwise.
 	 * @throws org.hibernate.MappingException Indicates our persister could not be located.
 	 */
 	private boolean isOwnerVersioned(SessionImplementor session) throws MappingException {
 		return getPersister( session ).getOwnerEntityPersister().isVersioned();
 	}
 
 	/**
 	 * Get our underlying collection persister (using the session to access the
 	 * factory).
 	 *
 	 * @param session The session from which the request is originating.
 	 * @return The underlying collection persister
 	 */
 	private CollectionPersister getPersister(SessionImplementor session) {
 		return session.getFactory().getCollectionPersister( role );
 	}
 
 	@Override
 	public boolean isDirty(Object old, Object current, SessionImplementor session)
 			throws HibernateException {
 
 		// collections don't dirty an unversioned parent entity
 
 		// TODO: I don't really like this implementation; it would be better if
 		// this was handled by searchForDirtyCollections()
 		return isOwnerVersioned( session ) && super.isDirty( old, current, session );
 		// return false;
 
 	}
 
 	@Override
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		return isDirty(old, current, session);
 	}
 
 	/**
 	 * Wrap the naked collection instance in a wrapper, or instantiate a
 	 * holder. Callers <b>MUST</b> add the holder to the persistence context!
 	 *
 	 * @param session The session from which the request is originating.
 	 * @param collection The bare collection to be wrapped.
 	 * @return The wrapped collection.
 	 */
 	public abstract PersistentCollection wrap(SessionImplementor session, Object collection);
 
 	/**
 	 * Note: return true because this type is castable to <tt>AssociationType</tt>. Not because
 	 * all collections are associations.
 	 */
 	@Override
 	public boolean isAssociationType() {
 		return true;
 	}
 
 	@Override
 	public ForeignKeyDirection getForeignKeyDirection() {
 		return ForeignKeyDirection.FOREIGN_KEY_TO_PARENT;
 	}
 
 	/**
 	 * Get the key value from the owning entity instance, usually the identifier, but might be some
 	 * other unique key, in the case of property-ref
 	 *
 	 * @param owner The collection owner
 	 * @param session The session from which the request is originating.
 	 * @return The collection owner's key
 	 */
 	public Serializable getKeyOfOwner(Object owner, SessionImplementor session) {
 		
 		EntityEntry entityEntry = session.getPersistenceContext().getEntry( owner );
 		if ( entityEntry == null ) return null; // This just handles a particular case of component
 									  // projection, perhaps get rid of it and throw an exception
 		
 		if ( foreignKeyPropertyName == null ) {
 			return entityEntry.getId();
 		}
 		else {
 			// TODO: at the point where we are resolving collection references, we don't
 			// know if the uk value has been resolved (depends if it was earlier or
 			// later in the mapping document) - now, we could try and use e.getStatus()
 			// to decide to semiResolve(), trouble is that initializeEntity() reuses
 			// the same array for resolved and hydrated values
 			Object id;
 			if ( entityEntry.getLoadedState() != null ) {
 				id = entityEntry.getLoadedValue( foreignKeyPropertyName );
 			}
 			else {
 				id = entityEntry.getPersister().getPropertyValue( owner, foreignKeyPropertyName );
 			}
 
 			// NOTE VERY HACKISH WORKAROUND!!
 			// TODO: Fix this so it will work for non-POJO entity mode
 			Type keyType = getPersister( session ).getKeyType();
 			if ( !keyType.getReturnedClass().isInstance( id ) ) {
 				id = keyType.semiResolve(
 						entityEntry.getLoadedValue( foreignKeyPropertyName ),
 						session,
 						owner 
 					);
 			}
 
 			return (Serializable) id;
 		}
 	}
 
 	/**
 	 * Get the id value from the owning entity key, usually the same as the key, but might be some
 	 * other property, in the case of property-ref
 	 *
 	 * @param key The collection owner key
 	 * @param session The session from which the request is originating.
 	 * @return The collection owner's id, if it can be obtained from the key;
 	 * otherwise, null is returned
 	 */
 	public Serializable getIdOfOwnerOrNull(Serializable key, SessionImplementor session) {
 		Serializable ownerId = null;
 		if ( foreignKeyPropertyName == null ) {
 			ownerId = key;
 		}
 		else {
 			Type keyType = getPersister( session ).getKeyType();
 			EntityPersister ownerPersister = getPersister( session ).getOwnerEntityPersister();
 			// TODO: Fix this so it will work for non-POJO entity mode
 			Class ownerMappedClass = ownerPersister.getMappedClass();
 			if ( ownerMappedClass.isAssignableFrom( keyType.getReturnedClass() ) &&
 					keyType.getReturnedClass().isInstance( key ) ) {
 				// the key is the owning entity itself, so get the ID from the key
 				ownerId = ownerPersister.getIdentifier( key, session );
 			}
 			else {
 				// TODO: check if key contains the owner ID
 			}
 		}
 		return ownerId;
 	}
 
 	@Override
 	public Object hydrate(ResultSet rs, String[] name, SessionImplementor session, Object owner) {
 		// can't just return null here, since that would
 		// cause an owning component to become null
 		return NOT_NULL_COLLECTION;
 	}
 
 	@Override
 	public Object resolve(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 		
 		return resolveKey( getKeyOfOwner( owner, session ), session, owner );
 	}
 	
 	private Object resolveKey(Serializable key, SessionImplementor session, Object owner) {
 		// if (key==null) throw new AssertionFailure("owner identifier unknown when re-assembling
 		// collection reference");
 		return key == null ? null : // TODO: can this case really occur??
 			getCollection( key, session, owner );
 	}
 
 	@Override
 	public Object semiResolve(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 		throw new UnsupportedOperationException(
 			"collection mappings may not form part of a property-ref" );
 	}
 
 	public boolean isArrayType() {
 		return false;
 	}
 
 	@Override
 	public boolean useLHSPrimaryKey() {
 		return foreignKeyPropertyName == null;
 	}
 
 	@Override
 	public String getRHSUniqueKeyPropertyName() {
 		return null;
 	}
 
 	@Override
 	public Joinable getAssociatedJoinable(SessionFactoryImplementor factory)
 			throws MappingException {
 		return (Joinable) factory.getCollectionPersister( role );
 	}
 
 	@Override
 	public boolean isModified(Object old, Object current, boolean[] checkable, SessionImplementor session) throws HibernateException {
 		return false;
 	}
 
 	@Override
 	public String getAssociatedEntityName(SessionFactoryImplementor factory)
 			throws MappingException {
 		try {
 			
 			QueryableCollection collectionPersister = (QueryableCollection) factory
 					.getCollectionPersister( role );
 			
 			if ( !collectionPersister.getElementType().isEntityType() ) {
 				throw new MappingException( 
 						"collection was not an association: " + 
 						collectionPersister.getRole() 
 					);
 			}
 			
 			return collectionPersister.getElementPersister().getEntityName();
 			
 		}
 		catch (ClassCastException cce) {
 			throw new MappingException( "collection role is not queryable " + role );
 		}
 	}
 
 	/**
 	 * Replace the elements of a collection with the elements of another collection.
 	 *
 	 * @param original The 'source' of the replacement elements (where we copy from)
 	 * @param target The target of the replacement elements (where we copy to)
 	 * @param owner The owner of the collection being merged
 	 * @param copyCache The map of elements already replaced.
 	 * @param session The session from which the merge event originated.
 	 * @return The merged collection.
 	 */
 	public Object replaceElements(
 			Object original,
 			Object target,
 			Object owner,
 			Map copyCache,
 			SessionImplementor session) {
 		// TODO: does not work for EntityMode.DOM4J yet!
 		java.util.Collection result = ( java.util.Collection ) target;
 		result.clear();
 
 		// copy elements into newly empty target collection
 		Type elemType = getElementType( session.getFactory() );
 		Iterator iter = ( (java.util.Collection) original ).iterator();
 		while ( iter.hasNext() ) {
 			result.add( elemType.replace( iter.next(), null, session, owner, copyCache ) );
 		}
 
 		// if the original is a PersistentCollection, and that original
 		// was not flagged as dirty, then reset the target's dirty flag
 		// here after the copy operation.
 		// </p>
 		// One thing to be careful of here is a "bare" original collection
 		// in which case we should never ever ever reset the dirty flag
 		// on the target because we simply do not know...
 		if ( original instanceof PersistentCollection ) {
 			if ( result instanceof PersistentCollection ) {
 				final PersistentCollection originalPersistentCollection = (PersistentCollection) original;
 				final PersistentCollection resultPersistentCollection = (PersistentCollection) result;
 
 				preserveSnapshot( originalPersistentCollection, resultPersistentCollection, elemType, owner, copyCache, session );
 
 				if ( ! originalPersistentCollection.isDirty() ) {
 					resultPersistentCollection.clearDirty();
 				}
 			}
 		}
 
 		return result;
 	}
 
 	private void preserveSnapshot(
 			PersistentCollection original,
 			PersistentCollection result,
 			Type elemType,
 			Object owner,
 			Map copyCache,
 			SessionImplementor session) {
 		Serializable originalSnapshot = original.getStoredSnapshot();
 		Serializable resultSnapshot = result.getStoredSnapshot();
 		Serializable targetSnapshot;
 
 		if ( originalSnapshot instanceof List ) {
 			targetSnapshot = new ArrayList(
 					( (List) originalSnapshot ).size() );
 			for ( Object obj : (List) originalSnapshot ) {
 				( (List) targetSnapshot ).add( elemType.replace( obj, null, session, owner, copyCache ) );
 			}
 
 		}
 		else if ( originalSnapshot instanceof Map ) {
 			if ( originalSnapshot instanceof SortedMap ) {
 				targetSnapshot = new TreeMap( ( (SortedMap) originalSnapshot ).comparator() );
 			}
 			else {
 				targetSnapshot = new HashMap(
 						CollectionHelper.determineProperSizing( ( (Map) originalSnapshot ).size() ),
 						CollectionHelper.LOAD_FACTOR
 				);
 			}
 
 			for ( Map.Entry<Object, Object> entry : ( (Map<Object, Object>) originalSnapshot ).entrySet() ) {
 				Object key = entry.getKey();
 				Object value = entry.getValue();
 				Object resultSnapshotValue = ( resultSnapshot == null )
 						? null
 						: ( (Map<Object, Object>) resultSnapshot ).get( key );
 
 				Object newValue = elemType.replace( value, resultSnapshotValue, session, owner, copyCache );
 
 				if ( key == value ) {
 					( (Map) targetSnapshot ).put( newValue, newValue );
 
 				}
 				else {
 					( (Map) targetSnapshot ).put( key, newValue );
 				}
 
 			}
 
 		}
 		else if ( originalSnapshot instanceof Object[] ) {
 			Object[] arr = (Object[]) originalSnapshot;
 			for ( int i = 0; i < arr.length; i++ ) {
 				arr[i] = elemType.replace( arr[i], null, session, owner, copyCache );
 			}
 			targetSnapshot = originalSnapshot;
 
 		}
 		else {
 			// retain the same snapshot
 			targetSnapshot = resultSnapshot;
 
 		}
 
 		CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( result );
 		if ( ce != null ) {
 			ce.resetStoredSnapshot( result, targetSnapshot );
 		}
 
 	}
 
 	/**
 	 * Instantiate a new "underlying" collection exhibiting the same capacity
 	 * charactersitcs and the passed "original".
 	 *
 	 * @param original The original collection.
 	 * @return The newly instantiated collection.
 	 */
 	protected Object instantiateResult(Object original) {
 		// by default just use an unanticipated capacity since we don't
 		// know how to extract the capacity to use from original here...
 		return instantiate( -1 );
 	}
 
 	/**
 	 * Instantiate an empty instance of the "underlying" collection (not a wrapper),
 	 * but with the given anticipated size (i.e. accounting for initial capacity
 	 * and perhaps load factor).
 	 *
 	 * @param anticipatedSize The anticipated size of the instaniated collection
 	 * after we are done populating it.
 	 * @return A newly instantiated collection to be wrapped.
 	 */
 	public abstract Object instantiate(int anticipatedSize);
 
 	@Override
 	public Object replace(
 			final Object original,
 			final Object target,
 			final SessionImplementor session,
 			final Object owner,
 			final Map copyCache) throws HibernateException {
 		if ( original == null ) {
 			return null;
 		}
 		if ( !Hibernate.isInitialized( original ) ) {
 			return target;
 		}
 
 		// for a null target, or a target which is the same as the original, we
 		// need to put the merged elements in a new collection
 		Object result = target == null || target == original ? instantiateResult( original ) : target;
 		
 		//for arrays, replaceElements() may return a different reference, since
 		//the array length might not match
 		result = replaceElements( original, result, owner, copyCache, session );
 
 		if ( original == target ) {
 			// get the elements back into the target making sure to handle dirty flag
 			boolean wasClean = PersistentCollection.class.isInstance( target ) && !( ( PersistentCollection ) target ).isDirty();
 			//TODO: this is a little inefficient, don't need to do a whole
 			//      deep replaceElements() call
 			replaceElements( result, target, owner, copyCache, session );
 			if ( wasClean ) {
 				( ( PersistentCollection ) target ).clearDirty();
 			}
 			result = target;
 		}
 
 		return result;
 	}
 
 	/**
 	 * Get the Hibernate type of the collection elements
 	 *
 	 * @param factory The session factory.
 	 * @return The type of the collection elements
 	 * @throws MappingException Indicates the underlying persister could not be located.
 	 */
 	public final Type getElementType(SessionFactoryImplementor factory) throws MappingException {
 		return factory.getCollectionPersister( getRole() ).getElementType();
 	}
 
 	@Override
 	public String toString() {
 		return getClass().getName() + '(' + getRole() + ')';
 	}
 
 	@Override
 	public String getOnCondition(String alias, SessionFactoryImplementor factory, Map enabledFilters)
 			throws MappingException {
 		return getAssociatedJoinable( factory ).filterFragment( alias, enabledFilters );
 	}
 
 	@Override
 	public String getOnCondition(
 			String alias,
 			SessionFactoryImplementor factory,
 			Map enabledFilters,
 			Set<String> treatAsDeclarations) {
 		return getAssociatedJoinable( factory ).filterFragment( alias, enabledFilters, treatAsDeclarations );
 	}
 
 	/**
 	 * instantiate a collection wrapper (called when loading an object)
 	 *
 	 * @param key The collection owner key
 	 * @param session The session from which the request is originating.
 	 * @param owner The collection owner
 	 * @return The collection
 	 */
 	public Object getCollection(Serializable key, SessionImplementor session, Object owner) {
 
 		CollectionPersister persister = getPersister( session );
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();
 
 		// check if collection is currently being loaded
 		PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );
 		
 		if ( collection == null ) {
 			
 			// check if it is already completely loaded, but unowned
 			collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );
 			
 			if ( collection == null ) {
 				// create a new collection wrapper, to be initialized later
 				collection = instantiate( session, persister, key );
 				
 				collection.setOwner(owner);
 	
 				persistenceContext.addUninitializedCollection( persister, collection, key );
 	
 				// some collections are not lazy:
 				if ( initializeImmediately() ) {
 					session.initializeCollection( collection, false );
 				}
 				else if ( !persister.isLazy() ) {
 					persistenceContext.addNonLazyCollection( collection );
 				}
 	
 				if ( hasHolder() ) {
 					session.getPersistenceContext().addCollectionHolder( collection );
 				}
 				
 			}
 			
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracef( "Created collection wrapper: %s",
 						MessageHelper.collectionInfoString( persister, collection,
 								key, session ) );
 			}
 			
 		}
 		
 		collection.setOwner(owner);
 
 		return collection.getValue();
 	}
 
 	public boolean hasHolder() {
 		return false;
 	}
 
 	protected boolean initializeImmediately() {
 		return false;
 	}
 
 	@Override
 	public String getLHSPropertyName() {
 		return foreignKeyPropertyName;
 	}
 
 	@Override
 	public boolean isXMLElement() {
 		return true;
 	}
 
 	@Override
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return xml;
 	}
 
 	@Override
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		if ( !isEmbeddedInXML ) {
 			node.detach();
 		}
 		else {
 			replaceNode( node, (Element) value );
 		}
 	}
 	
 	/**
 	 * We always need to dirty check the collection because we sometimes 
 	 * need to incremement version number of owner and also because of 
 	 * how assemble/disassemble is implemented for uks
 	 */
 	@Override
 	public boolean isAlwaysDirtyChecked() {
 		return true; 
 	}
 
 	@Override
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java b/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java
index b584dd98ce..ae7beaa20b 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java
@@ -1,816 +1,816 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.tuple.StandardProperty;
 import org.hibernate.tuple.component.ComponentMetamodel;
 import org.hibernate.tuple.component.ComponentTuplizer;
 
 import org.dom4j.Element;
 import org.dom4j.Node;
 
 /**
  * Handles "component" mappings
  *
  * @author Gavin King
  */
 public class ComponentType extends AbstractType implements CompositeType, ProcedureParameterExtractionAware {
 
 	private final TypeFactory.TypeScope typeScope;
 	private final String[] propertyNames;
 	private final Type[] propertyTypes;
 	private final boolean[] propertyNullability;
 	protected final int propertySpan;
 	private final CascadeStyle[] cascade;
 	private final FetchMode[] joinedFetch;
 	private final boolean isKey;
 	private boolean hasNotNullProperty;
 
 	protected final EntityMode entityMode;
 	protected final ComponentTuplizer componentTuplizer;
 
 	public ComponentType(TypeFactory.TypeScope typeScope, ComponentMetamodel metamodel) {
 		this.typeScope = typeScope;
 		// for now, just "re-flatten" the metamodel since this is temporary stuff anyway (HHH-1907)
 		this.isKey = metamodel.isKey();
 		this.propertySpan = metamodel.getPropertySpan();
 		this.propertyNames = new String[ propertySpan ];
 		this.propertyTypes = new Type[ propertySpan ];
 		this.propertyNullability = new boolean[ propertySpan ];
 		this.cascade = new CascadeStyle[ propertySpan ];
 		this.joinedFetch = new FetchMode[ propertySpan ];
 
 		for ( int i = 0; i < propertySpan; i++ ) {
 			StandardProperty prop = metamodel.getProperty( i );
 			this.propertyNames[i] = prop.getName();
 			this.propertyTypes[i] = prop.getType();
 			this.propertyNullability[i] = prop.isNullable();
 			this.cascade[i] = prop.getCascadeStyle();
 			this.joinedFetch[i] = prop.getFetchMode();
 			if (!prop.isNullable()) {
 				hasNotNullProperty = true;
 			}
 		}
 
 		this.entityMode = metamodel.getEntityMode();
 		this.componentTuplizer = metamodel.getComponentTuplizer();
 	}
 
 	public boolean isKey() {
 		return isKey;
 	}
 
 	public EntityMode getEntityMode() {
 		return entityMode;
 	}
 
 	public ComponentTuplizer getComponentTuplizer() {
 		return componentTuplizer;
 	}
 	@Override
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		int span = 0;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			span += propertyTypes[i].getColumnSpan( mapping );
 		}
 		return span;
 	}
 	@Override
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		//Not called at runtime so doesn't matter if its slow :)
 		int[] sqlTypes = new int[getColumnSpan( mapping )];
 		int n = 0;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int[] subtypes = propertyTypes[i].sqlTypes( mapping );
 			for ( int subtype : subtypes ) {
 				sqlTypes[n++] = subtype;
 			}
 		}
 		return sqlTypes;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		//Not called at runtime so doesn't matter if its slow :)
 		final Size[] sizes = new Size[ getColumnSpan( mapping ) ];
 		int soFar = 0;
 		for ( Type propertyType : propertyTypes ) {
 			final Size[] propertySizes = propertyType.dictatedSizes( mapping );
 			System.arraycopy( propertySizes, 0, sizes, soFar, propertySizes.length );
 			soFar += propertySizes.length;
 		}
 		return sizes;
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		//Not called at runtime so doesn't matter if its slow :)
 		final Size[] sizes = new Size[ getColumnSpan( mapping ) ];
 		int soFar = 0;
 		for ( Type propertyType : propertyTypes ) {
 			final Size[] propertySizes = propertyType.defaultSizes( mapping );
 			System.arraycopy( propertySizes, 0, sizes, soFar, propertySizes.length );
 			soFar += propertySizes.length;
 		}
 		return sizes;
 	}
 
 
 	@Override
     public final boolean isComponentType() {
 		return true;
 	}
 
 	public Class getReturnedClass() {
 		return componentTuplizer.getMappedClass();
 	}
 
 	@Override
     public boolean isSame(Object x, Object y) throws HibernateException {
 		if ( x == y ) {
 			return true;
 		}
 		if ( x == null || y == null ) {
 			return false;
 		}
 		Object[] xvalues = getPropertyValues( x, entityMode );
 		Object[] yvalues = getPropertyValues( y, entityMode );
 		for ( int i = 0; i < propertySpan; i++ ) {
 			if ( !propertyTypes[i].isSame( xvalues[i], yvalues[i] ) ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean isEqual(final Object x, final Object y) throws HibernateException {
 		if ( x == y ) {
 			return true;
 		}
 		if ( x == null || y == null ) {
 			return false;
 		}
 		for ( int i = 0; i < propertySpan; i++ ) {
 			if ( !propertyTypes[i].isEqual( getPropertyValue( x, i ), getPropertyValue( y, i ) ) ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean isEqual(final Object x, final Object y, final SessionFactoryImplementor factory) throws HibernateException {
 		if ( x == y ) {
 			return true;
 		}
 		if ( x == null || y == null ) {
 			return false;
 		}
 		for ( int i = 0; i < propertySpan; i++ ) {
 			if ( !propertyTypes[i].isEqual( getPropertyValue( x, i ), getPropertyValue( y, i ), factory ) ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public int compare(final Object x, final Object y) {
 		if ( x == y ) {
 			return 0;
 		}
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int propertyCompare = propertyTypes[i].compare( getPropertyValue( x, i ), getPropertyValue( y, i ) );
 			if ( propertyCompare != 0 ) {
 				return propertyCompare;
 			}
 		}
 		return 0;
 	}
 
 	public boolean isMethodOf(Method method) {
 		return false;
 	}
 
 	@Override
 	public int getHashCode(final Object x) {
 		int result = 17;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			Object y = getPropertyValue( x, i );
 			result *= 37;
 			if ( y != null ) {
 				result += propertyTypes[i].getHashCode( y );
 			}
 		}
 		return result;
 	}
 
 	@Override
 	public int getHashCode(final Object x, final SessionFactoryImplementor factory) {
 		int result = 17;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			Object y = getPropertyValue( x, i );
 			result *= 37;
 			if ( y != null ) {
 				result += propertyTypes[i].getHashCode( y, factory );
 			}
 		}
 		return result;
 	}
 
 	@Override
 	public boolean isDirty(final Object x, final Object y, final SessionImplementor session) throws HibernateException {
 		if ( x == y ) {
 			return false;
 		}
 		if ( x == null || y == null ) {
 			return true;
 		}
 		for ( int i = 0; i < propertySpan; i++ ) {
 			if ( propertyTypes[i].isDirty( getPropertyValue( x, i ), getPropertyValue( y, i ), session ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	public boolean isDirty(final Object x, final Object y, final boolean[] checkable, final SessionImplementor session) throws HibernateException {
 		if ( x == y ) {
 			return false;
 		}
 		if ( x == null || y == null ) {
 			return true;
 		}
 		int loc = 0;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int len = propertyTypes[i].getColumnSpan( session.getFactory() );
 			if ( len <= 1 ) {
 				final boolean dirty = ( len == 0 || checkable[loc] ) &&
 				                      propertyTypes[i].isDirty( getPropertyValue( x, i ), getPropertyValue( y, i ), session );
 				if ( dirty ) {
 					return true;
 				}
 			}
 			else {
 				boolean[] subcheckable = new boolean[len];
 				System.arraycopy( checkable, loc, subcheckable, 0, len );
 				final boolean dirty = propertyTypes[i].isDirty( getPropertyValue( x, i ), getPropertyValue( y, i ), subcheckable, session );
 				if ( dirty ) {
 					return true;
 				}
 			}
 			loc += len;
 		}
 		return false;
 	}
 
 	@Override
 	public boolean isModified(final Object old, final Object current, final boolean[] checkable, final SessionImplementor session) throws HibernateException {
 		if ( current == null ) {
 			return old != null;
 		}
 		if ( old == null ) {
 			return true;
 		}
 		Object[] oldValues = ( Object[] ) old;
 		int loc = 0;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int len = propertyTypes[i].getColumnSpan( session.getFactory() );
 			boolean[] subcheckable = new boolean[len];
 			System.arraycopy( checkable, loc, subcheckable, 0, len );
 			if ( propertyTypes[i].isModified( oldValues[i], getPropertyValue( current, i ), subcheckable, session ) ) {
 				return true;
 			}
 			loc += len;
 		}
 		return false;
 
 	}
 	@Override
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return resolve( hydrate( rs, names, session, owner ), session, owner );
 	}
 	@Override
 	public void nullSafeSet(PreparedStatement st, Object value, int begin, SessionImplementor session)
 			throws HibernateException, SQLException {
 
 		Object[] subvalues = nullSafeGetValues( value, entityMode );
 
 		for ( int i = 0; i < propertySpan; i++ ) {
 			propertyTypes[i].nullSafeSet( st, subvalues[i], begin, session );
 			begin += propertyTypes[i].getColumnSpan( session.getFactory() );
 		}
 	}
 	@Override
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int begin,
 			boolean[] settable,
 			SessionImplementor session)
 			throws HibernateException, SQLException {
 
 		Object[] subvalues = nullSafeGetValues( value, entityMode );
 
 		int loc = 0;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int len = propertyTypes[i].getColumnSpan( session.getFactory() );
 			if ( len == 0 ) {
 				//noop
 			}
 			else if ( len == 1 ) {
 				if ( settable[loc] ) {
 					propertyTypes[i].nullSafeSet( st, subvalues[i], begin, session );
 					begin++;
 				}
 			}
 			else {
 				boolean[] subsettable = new boolean[len];
 				System.arraycopy( settable, loc, subsettable, 0, len );
 				propertyTypes[i].nullSafeSet( st, subvalues[i], begin, subsettable, session );
 				begin += ArrayHelper.countTrue( subsettable );
 			}
 			loc += len;
 		}
 	}
 
 	private Object[] nullSafeGetValues(Object value, EntityMode entityMode) throws HibernateException {
 		if ( value == null ) {
 			return new Object[propertySpan];
 		}
 		else {
 			return getPropertyValues( value, entityMode );
 		}
 	}
 	@Override
 	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 
 		return nullSafeGet( rs, new String[] {name}, session, owner );
 	}
 	@Override
 	public Object getPropertyValue(Object component, int i, SessionImplementor session)
 			throws HibernateException {
 		return getPropertyValue( component, i );
 	}
 	public Object getPropertyValue(Object component, int i, EntityMode entityMode)
 			throws HibernateException {
 		return getPropertyValue( component, i );
 	}
 
 	public Object getPropertyValue(Object component, int i)
 			throws HibernateException {
 		if ( component instanceof Object[] ) {
 			// A few calls to hashCode pass the property values already in an
 			// Object[] (ex: QueryKey hash codes for cached queries).
 			// It's easiest to just check for the condition here prior to
 			// trying reflection.
 			return (( Object[] ) component)[i];
 		} else {
 			return componentTuplizer.getPropertyValue( component, i );
 		}
 	}
 
 	@Override
 	public Object[] getPropertyValues(Object component, SessionImplementor session)
 			throws HibernateException {
 		return getPropertyValues( component, entityMode );
 	}
 	@Override
 	public Object[] getPropertyValues(Object component, EntityMode entityMode)
 			throws HibernateException {
 		if ( component instanceof Object[] ) {
 			// A few calls to hashCode pass the property values already in an 
 			// Object[] (ex: QueryKey hash codes for cached queries).
 			// It's easiest to just check for the condition here prior to
 			// trying reflection.
 			return ( Object[] ) component;
 		} else {
 			return componentTuplizer.getPropertyValues( component );
 		}
 	}
 	@Override
 	public void setPropertyValues(Object component, Object[] values, EntityMode entityMode)
 			throws HibernateException {
 		componentTuplizer.setPropertyValues( component, values );
 	}
 	@Override
 	public Type[] getSubtypes() {
 		return propertyTypes;
 	}
 	@Override
 	public String getName() {
 		return "component" + ArrayHelper.toString( propertyNames );
 	}
 	@Override
 	public String toLoggableString(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		if ( value == null ) {
 			return "null";
 		}
 
 		if ( entityMode == null ) {
 			throw new ClassCastException( value.getClass().getName() );
 		}
 		Map<String,String> result = new HashMap<String, String>();
 		Object[] values = getPropertyValues( value, entityMode );
 		for ( int i = 0; i < propertyTypes.length; i++ ) {
 			result.put( propertyNames[i], propertyTypes[i].toLoggableString( values[i], factory ) );
 		}
 		return StringHelper.unqualify( getName() ) + result.toString();
 	}
 	@Override
 	public String[] getPropertyNames() {
 		return propertyNames;
 	}
 	@Override
 	public Object deepCopy(Object component, SessionFactoryImplementor factory)
 			throws HibernateException {
 		if ( component == null ) {
 			return null;
 		}
 
 		Object[] values = getPropertyValues( component, entityMode );
 		for ( int i = 0; i < propertySpan; i++ ) {
 			values[i] = propertyTypes[i].deepCopy( values[i], factory );
 		}
 
 		Object result = instantiate( entityMode );
 		setPropertyValues( result, values, entityMode );
 
 		//not absolutely necessary, but helps for some
 		//equals()/hashCode() implementations
 		if ( componentTuplizer.hasParentProperty() ) {
 			componentTuplizer.setParent( result, componentTuplizer.getParent( component ), factory );
 		}
 
 		return result;
 	}
 	@Override
 	public Object replace(
 			Object original,
 			Object target,
 			SessionImplementor session,
 			Object owner,
 			Map copyCache)
 			throws HibernateException {
 
 		if ( original == null ) {
 			return null;
 		}
 		//if ( original == target ) return target;
 
 		final Object result = target == null
 				? instantiate( owner, session )
 				: target;
 
 		Object[] values = TypeHelper.replace(
 				getPropertyValues( original, entityMode ),
 				getPropertyValues( result, entityMode ),
 				propertyTypes,
 				session,
 				owner,
 				copyCache
 		);
 
 		setPropertyValues( result, values, entityMode );
 		return result;
 	}
 
 	@Override
     public Object replace(
 			Object original,
 			Object target,
 			SessionImplementor session,
 			Object owner,
 			Map copyCache,
 			ForeignKeyDirection foreignKeyDirection)
 			throws HibernateException {
 
 		if ( original == null ) {
 			return null;
 		}
 		//if ( original == target ) return target;
 
 		final Object result = target == null ?
 				instantiate( owner, session ) :
 				target;
 
 		Object[] values = TypeHelper.replace(
 				getPropertyValues( original, entityMode ),
 				getPropertyValues( result, entityMode ),
 				propertyTypes,
 				session,
 				owner,
 				copyCache,
 				foreignKeyDirection
 		);
 
 		setPropertyValues( result, values, entityMode );
 		return result;
 	}
 
 	/**
 	 * This method does not populate the component parent
 	 */
 	public Object instantiate(EntityMode entityMode) throws HibernateException {
 		return componentTuplizer.instantiate();
 	}
 
 	public Object instantiate(Object parent, SessionImplementor session)
 			throws HibernateException {
 
 		Object result = instantiate( entityMode );
 
 		if ( componentTuplizer.hasParentProperty() && parent != null ) {
 			componentTuplizer.setParent(
 					result,
 					session.getPersistenceContext().proxyFor( parent ),
 					session.getFactory()
 			);
 		}
 
 		return result;
 	}
 	@Override
 	public CascadeStyle getCascadeStyle(int i) {
 		return cascade[i];
 	}
 	@Override
 	public boolean isMutable() {
 		return true;
 	}
 
 	@Override
     public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 
 		if ( value == null ) {
 			return null;
 		}
 		else {
 			Object[] values = getPropertyValues( value, entityMode );
 			for ( int i = 0; i < propertyTypes.length; i++ ) {
 				values[i] = propertyTypes[i].disassemble( values[i], session, owner );
 			}
 			return values;
 		}
 	}
 
 	@Override
     public Object assemble(Serializable object, SessionImplementor session, Object owner)
 			throws HibernateException {
 
 		if ( object == null ) {
 			return null;
 		}
 		else {
 			Object[] values = ( Object[] ) object;
 			Object[] assembled = new Object[values.length];
 			for ( int i = 0; i < propertyTypes.length; i++ ) {
 				assembled[i] = propertyTypes[i].assemble( ( Serializable ) values[i], session, owner );
 			}
 			Object result = instantiate( owner, session );
 			setPropertyValues( result, assembled, entityMode );
 			return result;
 		}
 	}
 	@Override
 	public FetchMode getFetchMode(int i) {
 		return joinedFetch[i];
 	}
 
 	@Override
     public Object hydrate(
 			final ResultSet rs,
 			final String[] names,
 			final SessionImplementor session,
 			final Object owner)
 			throws HibernateException, SQLException {
 
 		int begin = 0;
 		boolean notNull = false;
 		Object[] values = new Object[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			int length = propertyTypes[i].getColumnSpan( session.getFactory() );
 			String[] range = ArrayHelper.slice( names, begin, length ); //cache this
 			Object val = propertyTypes[i].hydrate( rs, range, session, owner );
 			if ( val == null ) {
 				if ( isKey ) {
 					return null; //different nullability rules for pk/fk
 				}
 			}
 			else {
 				notNull = true;
 			}
 			values[i] = val;
 			begin += length;
 		}
 
 		return notNull ? values : null;
 	}
 
 	@Override
     public Object resolve(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 
 		if ( value != null ) {
 			Object result = instantiate( owner, session );
 			Object[] values = ( Object[] ) value;
 			Object[] resolvedValues = new Object[values.length]; //only really need new array during semiresolve!
 			for ( int i = 0; i < values.length; i++ ) {
 				resolvedValues[i] = propertyTypes[i].resolve( values[i], session, owner );
 			}
 			setPropertyValues( result, resolvedValues, entityMode );
 			return result;
 		}
 		else {
 			return null;
 		}
 	}
 
 	@Override
     public Object semiResolve(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 		//note that this implementation is kinda broken
 		//for components with many-to-one associations
 		return resolve( value, session, owner );
 	}
 	@Override
 	public boolean[] getPropertyNullability() {
 		return propertyNullability;
 	}
 
 	@Override
     public boolean isXMLElement() {
 		return true;
 	}
 	@Override
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return xml;
 	}
 	@Override
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory) throws HibernateException {
 		replaceNode( node, ( Element ) value );
 	}
 	@Override
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		boolean[] result = new boolean[ getColumnSpan( mapping ) ];
 		if ( value == null ) {
 			return result;
 		}
 		Object[] values = getPropertyValues( value, EntityMode.POJO ); //TODO!!!!!!!
 		int loc = 0;
 		for ( int i = 0; i < propertyTypes.length; i++ ) {
 			boolean[] propertyNullness = propertyTypes[i].toColumnNullness( values[i], mapping );
 			System.arraycopy( propertyNullness, 0, result, loc, propertyNullness.length );
 			loc += propertyNullness.length;
 		}
 		return result;
 	}
 	@Override
 	public boolean isEmbedded() {
 		return false;
 	}
 
 	public int getPropertyIndex(String name) {
 		String[] names = getPropertyNames();
 		for ( int i = 0, max = names.length; i < max; i++ ) {
 			if ( names[i].equals( name ) ) {
 				return i;
 			}
 		}
 		throw new PropertyNotFoundException(
 				"Unable to locate property named " + name + " on " + getReturnedClass().getName()
 		);
 	}
 
 	private Boolean canDoExtraction;
 
 	@Override
 	public boolean canDoExtraction() {
 		if ( canDoExtraction == null ) {
 			canDoExtraction = determineIfProcedureParamExtractionCanBePerformed();
 		}
 		return canDoExtraction;
 	}
 
 	private boolean determineIfProcedureParamExtractionCanBePerformed() {
 		for ( Type propertyType : propertyTypes ) {
 			if ( ! ProcedureParameterExtractionAware.class.isInstance( propertyType ) ) {
 				return false;
 			}
 			if ( ! ( (ProcedureParameterExtractionAware) propertyType ).canDoExtraction() ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public Object extract(CallableStatement statement, int startIndex, SessionImplementor session) throws SQLException {
 		Object[] values = new Object[propertySpan];
 
 		int currentIndex = startIndex;
 		boolean notNull = false;
 		for ( int i = 0; i < propertySpan; i++ ) {
 			// we know this cast is safe from canDoExtraction
 			final ProcedureParameterExtractionAware propertyType = (ProcedureParameterExtractionAware) propertyTypes[i];
 			final Object value = propertyType.extract( statement, currentIndex, session );
 			if ( value == null ) {
 				if ( isKey ) {
 					return null; //different nullability rules for pk/fk
 				}
 			}
 			else {
 				notNull = true;
 			}
 			values[i] = value;
 			currentIndex += propertyType.getColumnSpan( session.getFactory() );
 		}
 
 		if ( ! notNull ) {
 			values = null;
 		}
 
 		return resolve( values, session, null );
 	}
 
 	@Override
 	public Object extract(CallableStatement statement, String[] paramNames, SessionImplementor session) throws SQLException {
 		// for this form to work all sub-property spans must be one (1)...
 
 		Object[] values = new Object[propertySpan];
 
 		int indx = 0;
 		boolean notNull = false;
 		for ( String paramName : paramNames ) {
 			// we know this cast is safe from canDoExtraction
 			final ProcedureParameterExtractionAware propertyType = (ProcedureParameterExtractionAware) propertyTypes[indx];
 			final Object value = propertyType.extract( statement, new String[] { paramName }, session );
 			if ( value == null ) {
 				if ( isKey ) {
 					return null; //different nullability rules for pk/fk
 				}
 			}
 			else {
 				notNull = true;
 			}
 			values[indx] = value;
 		}
 
 		if ( ! notNull ) {
 			values = null;
 		}
 
 		return resolve( values, session, null );
 	}
 	
 	public boolean hasNotNullProperty() {
 		return hasNotNullProperty;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/CompositeCustomType.java b/hibernate-core/src/main/java/org/hibernate/type/CompositeCustomType.java
index 146f4fe127..958d43ad80 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/CompositeCustomType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/CompositeCustomType.java
@@ -1,320 +1,320 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.LoggableUserType;
 
 import org.dom4j.Element;
 import org.dom4j.Node;
 
 /**
  * Adapts {@link CompositeUserType} to the {@link Type} interface
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class CompositeCustomType extends AbstractType implements CompositeType, BasicType {
 	private final CompositeUserType userType;
 	private final String[] registrationKeys;
 	private final String name;
 	private final boolean customLogging;
 
 	public CompositeCustomType(CompositeUserType userType) {
 		this( userType, ArrayHelper.EMPTY_STRING_ARRAY );
 	}
 
 	public CompositeCustomType(CompositeUserType userType, String[] registrationKeys) {
 		this.userType = userType;
 		this.name = userType.getClass().getName();
 		this.customLogging = LoggableUserType.class.isInstance( userType );
 		this.registrationKeys = registrationKeys;
 	}
 
 	public String[] getRegistrationKeys() {
 		return registrationKeys;
 	}
 
 	public CompositeUserType getUserType() {
 		return userType;
 	}
 
 	public boolean isMethodOf(Method method) {
 		return false;
 	}
 
 	public Type[] getSubtypes() {
 		return userType.getPropertyTypes();
 	}
 
 	public String[] getPropertyNames() {
 		return userType.getPropertyNames();
 	}
 
 	public Object[] getPropertyValues(Object component, SessionImplementor session) throws HibernateException {
 		return getPropertyValues( component, EntityMode.POJO );
 	}
 
 	public Object[] getPropertyValues(Object component, EntityMode entityMode) throws HibernateException {
 
 		int len = getSubtypes().length;
 		Object[] result = new Object[len];
 		for ( int i=0; i<len; i++ ) {
 			result[i] = getPropertyValue(component, i);
 		}
 		return result;
 	}
 
 	public void setPropertyValues(Object component, Object[] values, EntityMode entityMode)
 		throws HibernateException {
 
 		for (int i=0; i<values.length; i++) {
 			userType.setPropertyValue( component, i, values[i] );
 		}
 	}
 
 	public Object getPropertyValue(Object component, int i, SessionImplementor session)
 		throws HibernateException {
 		return getPropertyValue(component, i);
 	}
 
 	public Object getPropertyValue(Object component, int i) throws HibernateException {
 		return userType.getPropertyValue( component, i );
 	}
 
 	public CascadeStyle getCascadeStyle(int i) {
 		return CascadeStyles.NONE;
 	}
 
 	public FetchMode getFetchMode(int i) {
 		return FetchMode.DEFAULT;
 	}
 
 	public boolean isComponentType() {
 		return true;
 	}
 
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 	throws HibernateException {
 		return userType.deepCopy( value );
 	}
 
 	public Object assemble(
 		Serializable cached,
 		SessionImplementor session,
 		Object owner)
 		throws HibernateException {
 
 		return userType.assemble( cached, session, owner );
 	}
 
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 	throws HibernateException {
 		return userType.disassemble(value, session);
 	}
 
 	public Object replace(
 			Object original, 
 			Object target,
 			SessionImplementor session, 
 			Object owner, 
 			Map copyCache)
 	throws HibernateException {
 		return userType.replace(original, target, session, owner);
 	}
 	
 	public boolean isEqual(Object x, Object y)
 	throws HibernateException {
 		return userType.equals(x, y);
 	}
 
 	public int getHashCode(Object x) {
 		return userType.hashCode(x);
 	}
 	
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		Type[] types = userType.getPropertyTypes();
 		int n=0;
 		for ( Type type : types ) {
 			n += type.getColumnSpan( mapping );
 		}
 		return n;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public Class getReturnedClass() {
 		return userType.returnedClass();
 	}
 
 	public boolean isMutable() {
 		return userType.isMutable();
 	}
 
 	public Object nullSafeGet(
 		ResultSet rs,
 		String columnName,
 		SessionImplementor session,
 		Object owner)
 		throws HibernateException, SQLException {
 
 		return userType.nullSafeGet( rs, new String[] {columnName}, session, owner );
 	}
 
 	public Object nullSafeGet(
 		ResultSet rs,
 		String[] names,
 		SessionImplementor session,
 		Object owner)
 		throws HibernateException, SQLException {
 
 		return userType.nullSafeGet(rs, names, session, owner);
 	}
 
 	public void nullSafeSet(
 		PreparedStatement st,
 		Object value,
 		int index,
 		SessionImplementor session)
 		throws HibernateException, SQLException {
 
 		userType.nullSafeSet(st, value, index, session);
 
 	}
 
 	public void nullSafeSet(
 		PreparedStatement st,
 		Object value,
 		int index,
 		boolean[] settable, 
 		SessionImplementor session)
 		throws HibernateException, SQLException {
 
 		userType.nullSafeSet(st, value, index, session);
 	}
 
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		int[] result = new int[ getColumnSpan(mapping) ];
 		int n=0;
 		for ( Type type : userType.getPropertyTypes() ) {
 			for ( int sqlType : type.sqlTypes( mapping ) ) {
 				result[n++] = sqlType;
 			}
 		}
 		return result;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		//Not called at runtime so doesn't matter if its slow :)
 		final Size[] sizes = new Size[ getColumnSpan( mapping ) ];
 		int soFar = 0;
 		for ( Type propertyType : userType.getPropertyTypes() ) {
 			final Size[] propertySizes = propertyType.dictatedSizes( mapping );
 			System.arraycopy( propertySizes, 0, sizes, soFar, propertySizes.length );
 			soFar += propertySizes.length;
 		}
 		return sizes;
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		//Not called at runtime so doesn't matter if its slow :)
 		final Size[] sizes = new Size[ getColumnSpan( mapping ) ];
 		int soFar = 0;
 		for ( Type propertyType : userType.getPropertyTypes() ) {
 			final Size[] propertySizes = propertyType.defaultSizes( mapping );
 			System.arraycopy( propertySizes, 0, sizes, soFar, propertySizes.length );
 			soFar += propertySizes.length;
 		}
 		return sizes;
 	}
 	
 	public String toLoggableString(Object value, SessionFactoryImplementor factory) throws HibernateException {
 		if ( value == null ) {
 			return "null";
 		}
 		else if ( customLogging ) {
 			return ( (LoggableUserType) userType ).toLoggableString( value, factory );
 		}
 		else {
 			return value.toString();
 		}
 	}
 
 	public boolean[] getPropertyNullability() {
 		return null;
 	}
 
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return xml;
 	}
 
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory)
 	throws HibernateException {
 		replaceNode( node, (Element) value );
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		boolean[] result = new boolean[ getColumnSpan(mapping) ];
 		if (value==null) return result;
 		Object[] values = getPropertyValues(value, EntityMode.POJO); //TODO!!!!!!!
 		int loc = 0;
 		Type[] propertyTypes = getSubtypes();
 		for ( int i=0; i<propertyTypes.length; i++ ) {
 			boolean[] propertyNullness = propertyTypes[i].toColumnNullness( values[i], mapping );
 			System.arraycopy(propertyNullness, 0, result, loc, propertyNullness.length);
 			loc += propertyNullness.length;
 		}
 		return result;
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session) throws HibernateException {
 		return isDirty(old, current, session);
 	}
 	
 	public boolean isEmbedded() {
 		return false;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/CustomType.java b/hibernate-core/src/main/java/org/hibernate/type/CustomType.java
index 552bd24a84..2e30849de0 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/CustomType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/CustomType.java
@@ -1,279 +1,279 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.usertype.EnhancedUserType;
 import org.hibernate.usertype.LoggableUserType;
 import org.hibernate.usertype.Sized;
 import org.hibernate.usertype.UserType;
 import org.hibernate.usertype.UserVersionType;
 
 import org.dom4j.Node;
 
 /**
  * Adapts {@link UserType} to the generic {@link Type} interface, in order
  * to isolate user code from changes in the internal Type contracts.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class CustomType
 		extends AbstractType
 		implements IdentifierType, DiscriminatorType, VersionType, BasicType, StringRepresentableType {
 
 	private final UserType userType;
 	private final String name;
 	private final int[] types;
 	private final Size[] dictatedSizes;
 	private final Size[] defaultSizes;
 	private final boolean customLogging;
 	private final String[] registrationKeys;
 
 	public CustomType(UserType userType) throws MappingException {
 		this( userType, ArrayHelper.EMPTY_STRING_ARRAY );
 	}
 
 	public CustomType(UserType userType, String[] registrationKeys) throws MappingException {
 		this.userType = userType;
 		this.name = userType.getClass().getName();
 		this.types = userType.sqlTypes();
 		this.dictatedSizes = Sized.class.isInstance( userType )
 				? ( (Sized) userType ).dictatedSizes()
 				: new Size[ types.length ];
 		this.defaultSizes = Sized.class.isInstance( userType )
 				? ( (Sized) userType ).defaultSizes()
 				: new Size[ types.length ];
 		this.customLogging = LoggableUserType.class.isInstance( userType );
 		this.registrationKeys = registrationKeys;
 	}
 
 	public UserType getUserType() {
 		return userType;
 	}
 
 	public String[] getRegistrationKeys() {
 		return registrationKeys;
 	}
 
 	public int[] sqlTypes(Mapping pi) {
 		return types;
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return dictatedSizes;
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return defaultSizes;
 	}
 
 	public int getColumnSpan(Mapping session) {
 		return types.length;
 	}
 
 	public Class getReturnedClass() {
 		return userType.returnedClass();
 	}
 
 	public boolean isEqual(Object x, Object y) throws HibernateException {
 		return userType.equals( x, y );
 	}
 
 	public int getHashCode(Object x) {
 		return userType.hashCode(x);
 	}
 
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return userType.nullSafeGet(rs, names, session, owner);
 	}
 
 	public Object nullSafeGet(ResultSet rs, String columnName, SessionImplementor session, Object owner)
 			throws HibernateException, SQLException {
 		return nullSafeGet(rs, new String[] { columnName }, session, owner);
 	}
 
 
 	public Object assemble(Serializable cached, SessionImplementor session, Object owner)
 			throws HibernateException {
 		return userType.assemble(cached, owner);
 	}
 
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 			throws HibernateException {
 		return userType.disassemble(value);
 	}
 
 	public Object replace(
 			Object original,
 			Object target,
 			SessionImplementor session,
 			Object owner,
 			Map copyCache) throws HibernateException {
 		return userType.replace( original, target, owner );
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session)
 			throws HibernateException, SQLException {
 		if ( settable[0] ) {
 			userType.nullSafeSet( st, value, index, session );
 		}
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 			throws HibernateException, SQLException {
 		userType.nullSafeSet( st, value, index, session );
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public String toXMLString(Object value, SessionFactoryImplementor factory) {
 		return toString( value );
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public Object fromXMLString(String xml, Mapping factory) {
 		return fromStringValue( xml );
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		return userType.deepCopy(value);
 	}
 
 	public boolean isMutable() {
 		return userType.isMutable();
 	}
 
 	public Object stringToObject(String xml) {
 		return fromStringValue( xml );
 	}
 
 	public String objectToSQLString(Object value, Dialect dialect) throws Exception {
 		return ( (EnhancedUserType) userType ).objectToSQLString(value);
 	}
 
 	public Comparator getComparator() {
 		return (Comparator) userType;
 	}
 
 	public Object next(Object current, SessionImplementor session) {
 		return ( (UserVersionType) userType ).next( current, session );
 	}
 
 	public Object seed(SessionImplementor session) {
 		return ( (UserVersionType) userType ).seed( session );
 	}
 
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return fromXMLString( xml.getText(), factory );
 	}
 
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		node.setText( toXMLString(value, factory) );
 	}
 
 	public String toLoggableString(Object value, SessionFactoryImplementor factory)
 			throws HibernateException {
 		if ( value == null ) {
 			return "null";
 		}
 		else if ( customLogging ) {
 			return ( ( LoggableUserType ) userType ).toLoggableString( value, factory );
 		}
 		else {
 			return toXMLString( value, factory );
 		}
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		boolean[] result = new boolean[ getColumnSpan(mapping) ];
 		if ( value != null ) {
 			Arrays.fill(result, true);
 		}
 		return result;
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 			throws HibernateException {
 		return checkable[0] && isDirty(old, current, session);
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public String toString(Object value) throws HibernateException {
 		if ( StringRepresentableType.class.isInstance( userType ) ) {
 			return ( (StringRepresentableType) userType ).toString( value );
 		}
 		if ( value == null ) {
 			return null;
 		}
 		if ( EnhancedUserType.class.isInstance( userType ) ) {
 			//noinspection deprecation
 			return ( (EnhancedUserType) userType ).toXMLString( value );
 		}
 		return value.toString();
 	}
 
 	@Override
 	public Object fromStringValue(String string) throws HibernateException {
 		if ( StringRepresentableType.class.isInstance( userType ) ) {
 			return ( (StringRepresentableType) userType ).fromStringValue( string );
 		}
 		if ( EnhancedUserType.class.isInstance( userType ) ) {
 			//noinspection deprecation
 			return ( (EnhancedUserType) userType ).fromXMLString( string );
 		}
 		throw new HibernateException(
 				String.format(
 						"Could not process #fromStringValue, UserType class [%s] did not implement %s or %s",
 						name,
 						StringRepresentableType.class.getName(),
 						EnhancedUserType.class.getName()
 				)
 		);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/ManyToOneType.java b/hibernate-core/src/main/java/org/hibernate/type/ManyToOneType.java
index 3b2bae54d2..ce3d6c73ac 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/ManyToOneType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/ManyToOneType.java
@@ -1,334 +1,334 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * A many-to-one association to an entity.
  *
  * @author Gavin King
  */
 public class ManyToOneType extends EntityType {
 	private final boolean ignoreNotFound;
 	private boolean isLogicalOneToOne;
 
 	/**
 	 * Creates a many-to-one association type with the given referenced entity.
 	 *
 	 * @param scope The scope for this instance.
 	 * @param referencedEntityName The name iof the referenced entity
 	 */
 	public ManyToOneType(TypeFactory.TypeScope scope, String referencedEntityName) {
 		this( scope, referencedEntityName, false );
 	}
 
 	/**
 	 * Creates a many-to-one association type with the given referenced entity and the
 	 * given laziness characteristic
 	 *
 	 * @param scope The scope for this instance.
 	 * @param referencedEntityName The name iof the referenced entity
 	 * @param lazy Should the association be handled lazily
 	 */
 	public ManyToOneType(TypeFactory.TypeScope scope, String referencedEntityName, boolean lazy) {
 		this( scope, referencedEntityName, true, null, lazy, true, false, false );
 	}
 
 
 	/**
 	 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope, String, boolean, String, boolean, boolean, boolean, boolean ) } instead.
 	 */
 	@Deprecated
 	public ManyToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean isEmbeddedInXML,
 			boolean ignoreNotFound,
 			boolean isLogicalOneToOne) {
 		this( scope, referencedEntityName, uniqueKeyPropertyName == null, uniqueKeyPropertyName, lazy, unwrapProxy, ignoreNotFound, isLogicalOneToOne );
 	}
 
 	/**
 	 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope, String, boolean, String, boolean, boolean, boolean, boolean ) } instead.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public ManyToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean ignoreNotFound,
 			boolean isLogicalOneToOne) {
 		this( scope, referencedEntityName, uniqueKeyPropertyName == null, uniqueKeyPropertyName, lazy, unwrapProxy, ignoreNotFound, isLogicalOneToOne );
 	}
 
 	public ManyToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			boolean referenceToPrimaryKey,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean ignoreNotFound,
 			boolean isLogicalOneToOne) {
 		super( scope, referencedEntityName, referenceToPrimaryKey, uniqueKeyPropertyName, !lazy, unwrapProxy );
 		this.ignoreNotFound = ignoreNotFound;
 		this.isLogicalOneToOne = isLogicalOneToOne;
 	}
 
 	protected boolean isNullable() {
 		return ignoreNotFound;
 	}
 
 	public boolean isAlwaysDirtyChecked() {
 		// always need to dirty-check, even when non-updateable;
 		// this ensures that when the association is updated,
 		// the entity containing this association will be updated
 		// in the cache
 		return true;
 	}
 
 	public boolean isOneToOne() {
 		return false;
 	}
 
 	public boolean isLogicalOneToOne() {
 		return isLogicalOneToOne;
 	}
 
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		// our column span is the number of columns in the PK
 		return getIdentifierOrUniqueKeyType( mapping ).getColumnSpan( mapping );
 	}
 
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		return getIdentifierOrUniqueKeyType( mapping ).sqlTypes( mapping );
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return getIdentifierOrUniqueKeyType( mapping ).dictatedSizes( mapping );
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return getIdentifierOrUniqueKeyType( mapping ).defaultSizes( mapping );
 	}
 
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			boolean[] settable,
 			SessionImplementor session) throws HibernateException, SQLException {
 		getIdentifierOrUniqueKeyType( session.getFactory() )
 				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );
 	}
 
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			SessionImplementor session) throws HibernateException, SQLException {
 		getIdentifierOrUniqueKeyType( session.getFactory() )
 				.nullSafeSet( st, getIdentifier( value, session ), index, session );
 	}
 
 	public ForeignKeyDirection getForeignKeyDirection() {
 		return ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT;
 	}
 
 	public Object hydrate(
 			ResultSet rs,
 			String[] names,
 			SessionImplementor session,
 			Object owner) throws HibernateException, SQLException {
 		// return the (fully resolved) identifier value, but do not resolve
 		// to the actual referenced entity instance
 		// NOTE: the owner of the association is not really the owner of the id!
 		final Serializable id = (Serializable) getIdentifierOrUniqueKeyType( session.getFactory() )
 				.nullSafeGet( rs, names, session, null );
 		scheduleBatchLoadIfNeeded( id, session );
 		return id;
 	}
 
 	/**
 	 * Register the entity as batch loadable, if enabled
 	 */
 	@SuppressWarnings({ "JavaDoc" })
 	private void scheduleBatchLoadIfNeeded(Serializable id, SessionImplementor session) throws MappingException {
 		//cannot batch fetch by unique key (property-ref associations)
 		if ( uniqueKeyPropertyName == null && id != null ) {
 			final EntityPersister persister = getAssociatedEntityPersister( session.getFactory() );
 			if ( persister.isBatchLoadable() ) {
 				final EntityKey entityKey = session.generateEntityKey( id, persister );
 				if ( !session.getPersistenceContext().containsEntity( entityKey ) ) {
 					session.getPersistenceContext().getBatchFetchQueue().addBatchLoadableEntityKey( entityKey );
 				}
 			}
 		}
 	}
 
 	public boolean useLHSPrimaryKey() {
 		return false;
 	}
 
 	public boolean isModified(
 			Object old,
 			Object current,
 			boolean[] checkable,
 			SessionImplementor session) throws HibernateException {
 		if ( current == null ) {
 			return old!=null;
 		}
 		if ( old == null ) {
 			// we already know current is not null...
 			return true;
 		}
 		// the ids are fully resolved, so compare them with isDirty(), not isModified()
 		return getIdentifierOrUniqueKeyType( session.getFactory() )
 				.isDirty( old, getIdentifier( current, session ), session );
 	}
 
 	public Serializable disassemble(
 			Object value,
 			SessionImplementor session,
 			Object owner) throws HibernateException {
 
 		if ( isNotEmbedded( session ) ) {
 			return getIdentifierType( session ).disassemble( value, session, owner );
 		}
 		
 		if ( value == null ) {
 			return null;
 		}
 		else {
 			// cache the actual id of the object, not the value of the
 			// property-ref, which might not be initialized
 			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
 					getAssociatedEntityName(),
 					value,
 					session
 			);
 			if ( id == null ) {
 				throw new AssertionFailure(
 						"cannot cache a reference to an object with a null id: " + 
 						getAssociatedEntityName()
 				);
 			}
 			return getIdentifierType( session ).disassemble( id, session, owner );
 		}
 	}
 
 	public Object assemble(
 			Serializable oid,
 			SessionImplementor session,
 			Object owner) throws HibernateException {
 		
 		//TODO: currently broken for unique-key references (does not detect
 		//      change to unique key property of the associated object)
 		
 		Serializable id = assembleId( oid, session );
 
 		if ( isNotEmbedded( session ) ) {
 			return id;
 		}
 		
 		if ( id == null ) {
 			return null;
 		}
 		else {
 			return resolveIdentifier( id, session );
 		}
 	}
 
 	private Serializable assembleId(Serializable oid, SessionImplementor session) {
 		//the owner of the association is not the owner of the id
 		return ( Serializable ) getIdentifierType( session ).assemble( oid, session, null );
 	}
 
 	public void beforeAssemble(Serializable oid, SessionImplementor session) {
 		scheduleBatchLoadIfNeeded( assembleId( oid, session ), session );
 	}
 	
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		boolean[] result = new boolean[ getColumnSpan( mapping ) ];
 		if ( value != null ) {
 			Arrays.fill( result, true );
 		}
 		return result;
 	}
 	
 	public boolean isDirty(
 			Object old,
 			Object current,
 			SessionImplementor session) throws HibernateException {
 		if ( isSame( old, current ) ) {
 			return false;
 		}
 		Object oldid = getIdentifier( old, session );
 		Object newid = getIdentifier( current, session );
 		return getIdentifierType( session ).isDirty( oldid, newid, session );
 	}
 
 	public boolean isDirty(
 			Object old,
 			Object current,
 			boolean[] checkable,
 			SessionImplementor session) throws HibernateException {
 		if ( isAlwaysDirtyChecked() ) {
 			return isDirty( old, current, session );
 		}
 		else {
 			if ( isSame( old, current ) ) {
 				return false;
 			}
 			Object oldid = getIdentifier( old, session );
 			Object newid = getIdentifier( current, session );
 			return getIdentifierType( session ).isDirty( oldid, newid, checkable, session );
 		}
 		
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/MetaType.java b/hibernate-core/src/main/java/org/hibernate/type/MetaType.java
index da7d9e385e..4f25c20eae 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/MetaType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/MetaType.java
@@ -1,178 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 import org.dom4j.Node;
 
 /**
  * @author Gavin King
  */
 public class MetaType extends AbstractType {
 	public static final String[] REGISTRATION_KEYS = new String[0];
 
 	private final Type baseType;
 	private final Map<Object,String> discriminatorValuesToEntityNameMap;
 	private final Map<String,Object> entityNameToDiscriminatorValueMap;
 
 	public MetaType(Map<Object,String> discriminatorValuesToEntityNameMap, Type baseType) {
 		this.baseType = baseType;
 		this.discriminatorValuesToEntityNameMap = discriminatorValuesToEntityNameMap;
 		this.entityNameToDiscriminatorValueMap = new HashMap<String,Object>();
 		for ( Map.Entry<Object,String> entry : discriminatorValuesToEntityNameMap.entrySet() ) {
 			entityNameToDiscriminatorValueMap.put( entry.getValue(), entry.getKey() );
 		}
 	}
 
 	public String[] getRegistrationKeys() {
 		return REGISTRATION_KEYS;
 	}
 
 	public Map<Object, String> getDiscriminatorValuesToEntityNameMap() {
 		return discriminatorValuesToEntityNameMap;
 	}
 
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		return baseType.sqlTypes(mapping);
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return baseType.dictatedSizes( mapping );
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return baseType.defaultSizes( mapping );
 	}
 
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		return baseType.getColumnSpan(mapping);
 	}
 
 	public Class getReturnedClass() {
 		return String.class;
 	}
 
 	public Object nullSafeGet(
 		ResultSet rs,
 		String[] names,
 		SessionImplementor session,
 		Object owner)
 	throws HibernateException, SQLException {
 		Object key = baseType.nullSafeGet(rs, names, session, owner);
 		return key==null ? null : discriminatorValuesToEntityNameMap.get(key);
 	}
 
 	public Object nullSafeGet(
 		ResultSet rs,
 		String name,
 		SessionImplementor session,
 		Object owner)
 	throws HibernateException, SQLException {
 		Object key = baseType.nullSafeGet(rs, name, session, owner);
 		return key==null ? null : discriminatorValuesToEntityNameMap.get(key);
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 	throws HibernateException, SQLException {
 		baseType.nullSafeSet(st, value==null ? null : entityNameToDiscriminatorValueMap.get(value), index, session);
 	}
 	
 	public void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			boolean[] settable, 
 			SessionImplementor session)
 	throws HibernateException, SQLException {
 		if ( settable[0] ) nullSafeSet(st, value, index, session);
 	}
 
 	public String toLoggableString(Object value, SessionFactoryImplementor factory) throws HibernateException {
 		return toXMLString(value, factory);
 	}
 	
 	public String toXMLString(Object value, SessionFactoryImplementor factory)
 		throws HibernateException {
 		return (String) value; //value is the entity name
 	}
 
 	public Object fromXMLString(String xml, Mapping factory)
 		throws HibernateException {
 		return xml; //xml is the entity name
 	}
 
 	public String getName() {
 		return baseType.getName(); //TODO!
 	}
 
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 	throws HibernateException {
 		return value;
 	}
 
 	public Object replace(
 			Object original, 
 			Object target,
 			SessionImplementor session, 
 			Object owner, 
 			Map copyCache
 	) {
 		return original;
 	}
 	
 	public boolean isMutable() {
 		return false;
 	}
 
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return fromXMLString( xml.getText(), factory );
 	}
 
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory) throws HibernateException {
 		node.setText( toXMLString(value, factory) );
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		throw new UnsupportedOperationException();
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session) throws HibernateException {
 		return checkable[0] && isDirty(old, current, session);
 	}
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/NullableType.java b/hibernate-core/src/main/java/org/hibernate/type/NullableType.java
index a8c4efcf7e..70eabb6a6f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/NullableType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/NullableType.java
@@ -1,264 +1,264 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.compare.EqualsHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Node;
 
 /**
  * Superclass of single-column nullable types.
  *
  * @author Gavin King
  *
  * @deprecated Use the {@link AbstractStandardBasicType} approach instead
  */
 @Deprecated
 public abstract class NullableType extends AbstractType implements StringRepresentableType, XmlRepresentableType {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, NullableType.class.getName());
 
 	private final Size dictatedSize = new Size();
 
 	/**
 	 * A convenience form of {@link #sqlTypes(org.hibernate.engine.spi.Mapping)}, returning
 	 * just a single type value since these are explicitly dealing with single column
 	 * mappings.
 	 *
 	 * @return The {@link java.sql.Types} mapping value.
 	 */
 	public abstract int sqlType();
 
 	/**
 	 * A convenience form of {@link #dictatedSizes}, returning just a single size since we are explicitly dealing with
 	 * single column mappings here.
 	 *
 	 * @return The {@link java.sql.Types} mapping value.
 	 */
 	public Size dictatedSize() {
 		return dictatedSize;
 	}
 
 	/**
 	 * A convenience form of {@link #defaultSizes}, returning just a single size since we are explicitly dealing with
 	 * single column mappings here.
 	 *
 	 * @return The {@link java.sql.Types} mapping value.
 	 */
 	public Size defaultSize() {
 		return LEGACY_DEFAULT_SIZE;
 	}
 
 	/**
 	 * Get a column value from a result set, without worrying about the
 	 * possibility of null values.  Called from {@link #nullSafeGet} after
 	 * nullness checks have been performed.
 	 *
 	 * @param rs The result set from which to extract the value.
 	 * @param name The name of the value to extract.
 	 *
 	 * @return The extracted value.
 	 *
 	 * @throws org.hibernate.HibernateException Generally some form of mismatch error.
 	 * @throws java.sql.SQLException Indicates problem making the JDBC call(s).
 	 */
 	public abstract Object get(ResultSet rs, String name) throws HibernateException, SQLException;
 
 	/**
 	 * Set a parameter value without worrying about the possibility of null
 	 * values.  Called from {@link #nullSafeSet} after nullness checks have
 	 * been performed.
 	 *
 	 * @param st The statement into which to bind the parameter value.
 	 * @param value The parameter value to bind.
 	 * @param index The position or index at which to bind the param value.
 	 *
 	 * @throws org.hibernate.HibernateException Generally some form of mismatch error.
 	 * @throws java.sql.SQLException Indicates problem making the JDBC call(s).
 	 */
 	public abstract void set(PreparedStatement st, Object value, int index) throws HibernateException, SQLException;
 
 	/**
 	 * A null-safe version of {@link #toString(Object)}.  Specifically we are
 	 * worried about null safeness in regards to the incoming value parameter,
 	 * not the return.
 	 *
 	 * @param value The value to convert to a string representation; may be null.
 	 * @return The string representation; may be null.
 	 * @throws HibernateException Thrown by {@link #toString(Object)}, which this calls.
 	 */
 	public String nullSafeToString(Object value) throws HibernateException {
 		return value == null ? null : toString( value );
 	}
 
 	public abstract String toString(Object value) throws HibernateException;
 
 	public abstract Object fromStringValue(String xml) throws HibernateException;
 
 	public final void nullSafeSet(
 			PreparedStatement st,
 			Object value,
 			int index,
 			boolean[] settable,
 			SessionImplementor session)
 	throws HibernateException, SQLException {
 		if ( settable[0] ) nullSafeSet(st, value, index);
 	}
 
 	public final void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 	throws HibernateException, SQLException {
 		nullSafeSet(st, value, index);
 	}
 
 	public final void nullSafeSet(PreparedStatement st, Object value, int index)
 	throws HibernateException, SQLException {
 		try {
 			if ( value == null ) {
 				LOG.tracev("Binding null to parameter: {0}", index);
 
 				st.setNull( index, sqlType() );
 			}
 			else {
 				if (LOG.isTraceEnabled()) LOG.tracev("Binding '{0}' to parameter: {1}", toString(value), index);
 
 				set( st, value, index );
 			}
 		}
 		catch ( RuntimeException re ) {
 			LOG.unableToBindValueToParameter( nullSafeToString( value ), index, re.getMessage() );
 			throw re;
 		}
 		catch ( SQLException se ) {
 			LOG.unableToBindValueToParameter( nullSafeToString( value ), index, se.getMessage() );
 			throw se;
 		}
 	}
 
 	public final Object nullSafeGet(
 			ResultSet rs,
 			String[] names,
 			SessionImplementor session,
 			Object owner)
 	throws HibernateException, SQLException {
 		return nullSafeGet(rs, names[0]);
 	}
 
 	public final Object nullSafeGet(ResultSet rs, String[] names)
 	throws HibernateException, SQLException {
 		return nullSafeGet(rs, names[0]);
 	}
 
 	public final Object nullSafeGet(ResultSet rs, String name)
 	throws HibernateException, SQLException {
 		try {
 			Object value = get(rs, name);
 			if ( value == null || rs.wasNull() ) {
 				LOG.tracev( "Returning null as column {0}", name );
 				return null;
 			}
 			if ( LOG.isTraceEnabled() ) LOG.trace( "Returning '" + toString( value ) + "' as column " + name );
 			return value;
 		}
 		catch ( RuntimeException re ) {
 			LOG.unableToReadColumnValueFromResultSet( name, re.getMessage() );
 			throw re;
 		}
 		catch ( SQLException se ) {
 			LOG.unableToReadColumnValueFromResultSet( name, se.getMessage() );
 			throw se;
 		}
 	}
 
 	public final Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)
 	throws HibernateException, SQLException {
 		return nullSafeGet( rs, name );
 	}
 
 	public final String toXMLString(Object value, SessionFactoryImplementor pc)
 	throws HibernateException {
 		return toString(value);
 	}
 
 	public final Object fromXMLString(String xml, Mapping factory) throws HibernateException {
 		return xml==null || xml.length()==0 ? null : fromStringValue(xml);
 	}
 
 	public final int getColumnSpan(Mapping session) {
 		return 1;
 	}
 
 	public final int[] sqlTypes(Mapping session) {
 		return new int[] { sqlType() };
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return new Size[] { dictatedSize() };
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return new Size[] { defaultSize() };
 	}
 
 	@Override
 	public boolean isEqual(Object x, Object y) {
 		return EqualsHelper.equals(x, y);
 	}
 
 	public String toLoggableString(Object value, SessionFactoryImplementor factory) {
 		return value == null ? "null" : toString(value);
 	}
 
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {
 		return fromXMLString( xml.getText(), factory );
 	}
 
 	public void setToXMLNode(Node xml, Object value, SessionFactoryImplementor factory)
 	throws HibernateException {
 		xml.setText( toXMLString(value, factory) );
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		return value==null ? ArrayHelper.FALSE : ArrayHelper.TRUE;
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session)
 	throws HibernateException {
 		return checkable[0] && isDirty(old, current, session);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/OneToOneType.java b/hibernate-core/src/main/java/org/hibernate/type/OneToOneType.java
index 960adf18d8..98ec2f59ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/OneToOneType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/OneToOneType.java
@@ -1,212 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.collections.ArrayHelper;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * A one-to-one association to an entity
  * @author Gavin King
  */
 public class OneToOneType extends EntityType {
 
 	private final ForeignKeyDirection foreignKeyType;
 	private final String propertyName;
 	private final String entityName;
 
 	/**
 	 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope, String, ForeignKeyDirection, boolean, String, boolean, boolean, String, String)}
 	 *  instead.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public OneToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			ForeignKeyDirection foreignKeyType,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean isEmbeddedInXML,
 			String entityName,
 			String propertyName) {
 		this( scope, referencedEntityName, foreignKeyType, uniqueKeyPropertyName == null, uniqueKeyPropertyName, lazy, unwrapProxy, entityName, propertyName );
 	}
 
 	/**
 	 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope, String, ForeignKeyDirection, boolean, String, boolean, boolean, String, String)}
 	 *  instead.
 	 */
 	@Deprecated
 	public OneToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			ForeignKeyDirection foreignKeyType,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			String entityName,
 			String propertyName) {
 		this( scope, referencedEntityName, foreignKeyType, uniqueKeyPropertyName == null, uniqueKeyPropertyName, lazy, unwrapProxy, entityName, propertyName );
 	}
 
 	public OneToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			ForeignKeyDirection foreignKeyType,
 			boolean referenceToPrimaryKey,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			String entityName,
 			String propertyName) {
 		super( scope, referencedEntityName, referenceToPrimaryKey, uniqueKeyPropertyName, !lazy, unwrapProxy );
 		this.foreignKeyType = foreignKeyType;
 		this.propertyName = propertyName;
 		this.entityName = entityName;
 	}
 
 	public String getPropertyName() {
 		return propertyName;
 	}
 	
 	public boolean isNull(Object owner, SessionImplementor session) {
 		if ( propertyName != null ) {
 			final EntityPersister ownerPersister = session.getFactory().getEntityPersister( entityName );
 			final Serializable id = session.getContextEntityIdentifier( owner );
 			final EntityKey entityKey = session.generateEntityKey( id, ownerPersister );
 			return session.getPersistenceContext().isPropertyNull( entityKey, getPropertyName() );
 		}
 		else {
 			return false;
 		}
 	}
 
 	public int getColumnSpan(Mapping session) throws MappingException {
 		return 0;
 	}
 
 	public int[] sqlTypes(Mapping session) throws MappingException {
 		return ArrayHelper.EMPTY_INT_ARRAY;
 	}
 
 	private static final Size[] SIZES = new Size[0];
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return SIZES;
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return SIZES;
 	}
 
 	public boolean[] toColumnNullness(Object value, Mapping mapping) {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session) {
 		//nothing to do
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session) {
 		//nothing to do
 	}
 
 	public boolean isOneToOne() {
 		return true;
 	}
 
 	public boolean isDirty(Object old, Object current, SessionImplementor session) {
 		return false;
 	}
 
 	public boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session) {
 		return false;
 	}
 
 	public boolean isModified(Object old, Object current, boolean[] checkable, SessionImplementor session) {
 		return false;
 	}
 
 	public ForeignKeyDirection getForeignKeyDirection() {
 		return foreignKeyType;
 	}
 
 	public Object hydrate(
 		ResultSet rs,
 		String[] names,
 		SessionImplementor session,
 		Object owner)
 	throws HibernateException, SQLException {
 
 		return session.getContextEntityIdentifier(owner);
 	}
 
 	protected boolean isNullable() {
 		return foreignKeyType==ForeignKeyDirection.FOREIGN_KEY_TO_PARENT;
 	}
 
 	public boolean useLHSPrimaryKey() {
 		return true;
 	}
 
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 	throws HibernateException {
 		return null;
 	}
 
 	public Object assemble(Serializable oid, SessionImplementor session, Object owner)
 	throws HibernateException {
 		//this should be a call to resolve(), not resolveIdentifier(), 
 		//'cos it might be a property-ref, and we did not cache the
 		//referenced value
 		return resolve( session.getContextEntityIdentifier(owner), session, owner );
 	}
 	
 	/**
 	 * We don't need to dirty check one-to-one because of how 
 	 * assemble/disassemble is implemented and because a one-to-one 
 	 * association is never dirty
 	 */
 	public boolean isAlwaysDirtyChecked() {
 		//TODO: this is kinda inconsistent with CollectionType
 		return false; 
 	}
 	
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/type/SpecialOneToOneType.java b/hibernate-core/src/main/java/org/hibernate/type/SpecialOneToOneType.java
index 70c86b3f6a..26b777e844 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/SpecialOneToOneType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/SpecialOneToOneType.java
@@ -1,157 +1,157 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 /**
  * A one-to-one association that maps to specific formula(s)
  * instead of the primary key column of the owning entity.
  * 
  * @author Gavin King
  */
 public class SpecialOneToOneType extends OneToOneType {
 	
 	/**
 	 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope, String, ForeignKeyDirection, boolean, String, boolean, boolean, String, String)} instead.
 	 */
 	@Deprecated
 	public SpecialOneToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			ForeignKeyDirection foreignKeyType, 
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			String entityName,
 			String propertyName) {
 		this( scope, referencedEntityName, foreignKeyType, uniqueKeyPropertyName == null, uniqueKeyPropertyName, lazy, unwrapProxy, entityName, propertyName );
 	}
 	
 	public SpecialOneToOneType(
 			TypeFactory.TypeScope scope,
 			String referencedEntityName,
 			ForeignKeyDirection foreignKeyType,
 			boolean referenceToPrimaryKey, 
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			String entityName,
 			String propertyName) {
 		super(
 				scope,
 				referencedEntityName, 
 				foreignKeyType,
 				referenceToPrimaryKey, 
 				uniqueKeyPropertyName, 
 				lazy,
 				unwrapProxy,
 				entityName, 
 				propertyName
 			);
 	}
 	
 	public int getColumnSpan(Mapping mapping) throws MappingException {
 		return super.getIdentifierOrUniqueKeyType( mapping ).getColumnSpan( mapping );
 	}
 	
 	public int[] sqlTypes(Mapping mapping) throws MappingException {
 		return super.getIdentifierOrUniqueKeyType( mapping ).sqlTypes( mapping );
 	}
 
 	@Override
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException {
 		return super.getIdentifierOrUniqueKeyType( mapping ).dictatedSizes( mapping );
 	}
 
 	@Override
 	public Size[] defaultSizes(Mapping mapping) throws MappingException {
 		return super.getIdentifierOrUniqueKeyType( mapping ).defaultSizes( mapping );
 	}
 
 	public boolean useLHSPrimaryKey() {
 		return false;
 	}
 	
 	public Object hydrate(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 	throws HibernateException, SQLException {
 		return super.getIdentifierOrUniqueKeyType( session.getFactory() )
 			.nullSafeGet(rs, names, session, owner);
 	}
 	
 	// TODO: copy/paste from ManyToOneType
 
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner)
 	throws HibernateException {
 
 		if ( isNotEmbedded(session) ) {
 			return getIdentifierType(session).disassemble(value, session, owner);
 		}
 		
 		if (value==null) {
 			return null;
 		}
 		else {
 			// cache the actual id of the object, not the value of the
 			// property-ref, which might not be initialized
 			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session );
 			if (id==null) {
 				throw new AssertionFailure(
 						"cannot cache a reference to an object with a null id: " + 
 						getAssociatedEntityName() 
 				);
 			}
 			return getIdentifierType(session).disassemble(id, session, owner);
 		}
 	}
 
 	public Object assemble(Serializable oid, SessionImplementor session, Object owner)
 	throws HibernateException {
 		//TODO: currently broken for unique-key references (does not detect
 		//      change to unique key property of the associated object)
 		Serializable id = (Serializable) getIdentifierType(session).assemble(oid, session, null); //the owner of the association is not the owner of the id
 
 		if ( isNotEmbedded(session) ) return id;
 		
 		if (id==null) {
 			return null;
 		}
 		else {
 			return resolveIdentifier(id, session);
 		}
 	}
 	
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/Type.java b/hibernate-core/src/main/java/org/hibernate/type/Type.java
index e486934784..1f79a4b20d 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/Type.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/Type.java
@@ -1,618 +1,618 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 import org.dom4j.Node;
 
 /**
  * Defines a mapping between a Java type and one or more JDBC {@linkplain java.sql.Types types}, as well
  * as describing the in-memory semantics of the given java type (how do we check it for 'dirtiness', how do
  * we copy values, etc).
  * <p/>
  * Application developers needing custom types can implement this interface (either directly or via subclassing an
  * existing impl) or by the (slightly more stable, though more limited) {@link org.hibernate.usertype.UserType}
  * interface.
  * <p/>
  * Implementations of this interface must certainly be thread-safe.  It is recommended that they be immutable as
  * well, though that is difficult to achieve completely given the no-arg constructor requirement for custom types.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface Type extends Serializable {
 	/**
 	 * Return true if the implementation is castable to {@link AssociationType}. This does not necessarily imply that
 	 * the type actually represents an association.  Essentially a polymorphic version of
 	 * {@code (type instanceof AssociationType.class)}
 	 *
 	 * @return True if this type is also an {@link AssociationType} implementor; false otherwise.
 	 */
 	public boolean isAssociationType();
 
 	/**
 	 * Return true if the implementation is castable to {@link CollectionType}. Essentially a polymorphic version of
 	 * {@code (type instanceof CollectionType.class)}
 	 * <p/>
 	 * A {@link CollectionType} is additionally an {@link AssociationType}; so if this method returns true,
 	 * {@link #isAssociationType()} should also return true.
 	 *
 	 * @return True if this type is also an {@link CollectionType} implementor; false otherwise.
 	 */
 	public boolean isCollectionType();
 
 	/**
 	 * Return true if the implementation is castable to {@link EntityType}. Essentially a polymorphic
 	 * version of {@code (type instanceof EntityType.class)}.
 	 * <p/>
 	 * An {@link EntityType} is additionally an {@link AssociationType}; so if this method returns true,
 	 * {@link #isAssociationType()} should also return true.
 	 *
 	 * @return True if this type is also an {@link EntityType} implementor; false otherwise.
 	 */
 	public boolean isEntityType();
 
 	/**
 	 * Return true if the implementation is castable to {@link AnyType}. Essentially a polymorphic
 	 * version of {@code (type instanceof AnyType.class)}.
 	 * <p/>
 	 * An {@link AnyType} is additionally an {@link AssociationType}; so if this method returns true,
 	 * {@link #isAssociationType()} should also return true.
 	 *
 	 * @return True if this type is also an {@link AnyType} implementor; false otherwise.
 	 */
 	public boolean isAnyType();
 
 	/**
 	 * Return true if the implementation is castable to {@link CompositeType}. Essentially a polymorphic
 	 * version of {@code (type instanceof CompositeType.class)}.  A component type may own collections or
 	 * associations and hence must provide certain extra functionality.
 	 *
 	 * @return True if this type is also an {@link CompositeType} implementor; false otherwise.
 	 */
 	public boolean isComponentType();
 
 	/**
 	 * How many columns are used to persist this type.  Always the same as {@code sqlTypes(mapping).length}
 	 *
 	 * @param mapping The mapping object :/
 	 *
 	 * @return The number of columns
 	 *
 	 * @throws MappingException Generally indicates an issue accessing the passed mapping object.
 	 */
 	public int getColumnSpan(Mapping mapping) throws MappingException;
 
 	/**
 	 * Return the JDBC types codes (per {@link java.sql.Types}) for the columns mapped by this type.
 	 * <p/>
 	 * NOTE: The number of elements in this array matches the return from {@link #getColumnSpan}.
 	 *
 	 * @param mapping The mapping object :/
 	 *
 	 * @return The JDBC type codes.
 	 *
 	 * @throws MappingException Generally indicates an issue accessing the passed mapping object.
 	 */
 	public int[] sqlTypes(Mapping mapping) throws MappingException;
 
 	/**
 	 * Return the column sizes dictated by this type.  For example, the mapping for a {@code char}/{@link Character} would
 	 * have a dictated length limit of 1; for a string-based {@link java.util.UUID} would have a size limit of 36; etc.
 	 * <p/>
 	 * NOTE: The number of elements in this array matches the return from {@link #getColumnSpan}.
 	 *
 	 * @param mapping The mapping object :/
 	 * @todo Would be much much better to have this aware of Dialect once the service/metamodel split is done
 	 *
 	 * @return The dictated sizes.
 	 *
 	 * @throws MappingException Generally indicates an issue accessing the passed mapping object.
 	 */
 	public Size[] dictatedSizes(Mapping mapping) throws MappingException;
 
 	/**
 	 * Defines the column sizes to use according to this type if the user did not explicitly say (and if no
 	 * {@link #dictatedSizes} were given).
 	 * <p/>
 	 * NOTE: The number of elements in this array matches the return from {@link #getColumnSpan}.
 	 *
 	 * @param mapping The mapping object :/
 	 * @todo Would be much much better to have this aware of Dialect once the service/metamodel split is done
 	 *
 	 * @return The default sizes.
 	 *
 	 * @throws MappingException Generally indicates an issue accessing the passed mapping object.
 	 */
 	public Size[] defaultSizes(Mapping mapping) throws MappingException;
 
 	/**
 	 * The class returned by {@link #nullSafeGet} methods. This is used to  establish the class of an array of
 	 * this type.
 	 *
 	 * @return The java type class handled by this type.
 	 */
 	public Class getReturnedClass();
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	@Deprecated
 	public boolean isXMLElement();
 
 	/**
 	 * Compare two instances of the class mapped by this type for persistence "equality" (equality of persistent
 	 * state) taking a shortcut for entity references.
 	 * <p/>
 	 * For most types this should equate to an {@link Object#equals equals} check on the values.  For associations
 	 * the implication is a bit different.  For most types it is conceivable to simply delegate to {@link #isEqual}
 	 *
 	 * @param x The first value
 	 * @param y The second value
 	 *
 	 * @return True if there are considered the same (see discussion above).
 	 *
 	 * @throws HibernateException A problem occurred performing the comparison
 	 */
 	public boolean isSame(Object x, Object y) throws HibernateException;
 
 	/**
 	 * Compare two instances of the class mapped by this type for persistence "equality" (equality of persistent
 	 * state).
 	 * <p/>
 	 * This should always equate to some form of comparison of the value's internal state.  As an example, for
 	 * something like a date the comparison should be based on its internal "time" state based on the specific portion
 	 * it is meant to represent (timestamp, date, time).
 	 *
 	 * @param x The first value
 	 * @param y The second value
 	 *
 	 * @return True if there are considered equal (see discussion above).
 	 *
 	 * @throws HibernateException A problem occurred performing the comparison
 	 */
 	public boolean isEqual(Object x, Object y) throws HibernateException;
 
 	/**
 	 * Compare two instances of the class mapped by this type for persistence "equality" (equality of persistent
 	 * state).
 	 * <p/>
 	 * This should always equate to some form of comparison of the value's internal state.  As an example, for
 	 * something like a date the comparison should be based on its internal "time" state based on the specific portion
 	 * it is meant to represent (timestamp, date, time).
 	 *
 	 * @param x The first value
 	 * @param y The second value
 	 * @param factory The session factory
 	 *
 	 * @return True if there are considered equal (see discussion above).
 	 *
 	 * @throws HibernateException A problem occurred performing the comparison
 	 */
 	public boolean isEqual(Object x, Object y, SessionFactoryImplementor factory) throws HibernateException;
 
 	/**
 	 * Get a hash code, consistent with persistence "equality".  Again for most types the normal usage is to
 	 * delegate to the value's {@link Object#hashCode hashCode}.
 	 *
 	 * @param x The value for which to retrieve a hash code
 	 * @return The hash code
 	 *
 	 * @throws HibernateException A problem occurred calculating the hash code
 	 */
 	public int getHashCode(Object x) throws HibernateException;
 
 	/**
 	 * Get a hash code, consistent with persistence "equality".  Again for most types the normal usage is to
 	 * delegate to the value's {@link Object#hashCode hashCode}.
 	 *
 	 * @param x The value for which to retrieve a hash code
 	 * @param factory The session factory
 	 *
 	 * @return The hash code
 	 *
 	 * @throws HibernateException A problem occurred calculating the hash code
 	 */
 	public int getHashCode(Object x, SessionFactoryImplementor factory) throws HibernateException;
 	
 	/**
 	 * Perform a {@link java.util.Comparator} style comparison between values
 	 *
 	 * @param x The first value
 	 * @param y The second value
 	 *
 	 * @return The comparison result.  See {@link java.util.Comparator#compare} for a discussion.
 	 */
 	public int compare(Object x, Object y);
 
 	/**
 	 * Should the parent be considered dirty, given both the old and current value?
 	 * 
 	 * @param old the old value
 	 * @param current the current value
 	 * @param session The session from which the request originated.
 	 *
 	 * @return true if the field is dirty
 	 *
 	 * @throws HibernateException A problem occurred performing the checking
 	 */
 	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Should the parent be considered dirty, given both the old and current value?
 	 *
 	 * @param oldState the old value
 	 * @param currentState the current value
 	 * @param checkable An array of booleans indicating which columns making up the value are actually checkable
 	 * @param session The session from which the request originated.
 	 *
 	 * @return true if the field is dirty
 	 *
 	 * @throws HibernateException A problem occurred performing the checking
 	 */
 	public boolean isDirty(Object oldState, Object currentState, boolean[] checkable, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Has the value been modified compared to the current database state?  The difference between this
 	 * and the {@link #isDirty} methods is that here we need to account for "partially" built values.  This is really
 	 * only an issue with association types.  For most type implementations it is enough to simply delegate to
 	 * {@link #isDirty} here/
 	 *
 	 * @param dbState the database state, in a "hydrated" form, with identifiers unresolved
 	 * @param currentState the current state of the object
 	 * @param checkable which columns are actually updatable
 	 * @param session The session from which the request originated.
 	 *
 	 * @return true if the field has been modified
 	 *
 	 * @throws HibernateException A problem occurred performing the checking
 	 */
 	public boolean isModified(Object dbState, Object currentState, boolean[] checkable, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Extract a value of the {@link #getReturnedClass() mapped class} from the JDBC result set. Implementors
 	 * should handle possibility of null values.
 	 *
 	 * @param rs The result set from which to extract value.
 	 * @param names the column names making up this type value (use to read from result set)
 	 * @param session The originating session
 	 * @param owner the parent entity
 	 *
 	 * @return The extracted value
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 * @throws SQLException An error from the JDBC driver
 	 *
 	 * @see Type#hydrate(ResultSet, String[], SessionImplementor, Object) alternative, 2-phase property initialization
 	 */
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 	throws HibernateException, SQLException;
 
 	/**
 	 * Extract a value of the {@link #getReturnedClass() mapped class} from the JDBC result set. Implementors
 	 * should handle possibility of null values.  This form might be called if the type is known to be a
 	 * single-column type.
 	 *
 	 * @param rs The result set from which to extract value.
 	 * @param name the column name making up this type value (use to read from result set)
 	 * @param session The originating session
 	 * @param owner the parent entity
 	 *
 	 * @return The extracted value
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 * @throws SQLException An error from the JDBC driver
 	 */
 	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)
 	throws HibernateException, SQLException;
 
 	/**
 	 * Bind a value represented by an instance of the {@link #getReturnedClass() mapped class} to the JDBC prepared
 	 * statement, ignoring some columns as dictated by the 'settable' parameter.  Implementors should handle the
 	 * possibility of null values.  A multi-column type should bind parameters starting from <tt>index</tt>.
 	 *
 	 * @param st The JDBC prepared statement to which to bind
 	 * @param value the object to write
 	 * @param index starting parameter bind index
 	 * @param settable an array indicating which columns to bind/ignore
 	 * @param session The originating session
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 * @throws SQLException An error from the JDBC driver
 	 */
 	public void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session)
 	throws HibernateException, SQLException;
 
 	/**
 	 * Bind a value represented by an instance of the {@link #getReturnedClass() mapped class} to the JDBC prepared
 	 * statement.  Implementors should handle possibility of null values.  A multi-column type should bind parameters
 	 * starting from <tt>index</tt>.
 	 *
 	 * @param st The JDBC prepared statement to which to bind
 	 * @param value the object to write
 	 * @param index starting parameter bind index
 	 * @param session The originating session
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 * @throws SQLException An error from the JDBC driver
 	 */
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 	throws HibernateException, SQLException;
 
 	/**
 	 * Generate a representation of the value for logging purposes.
 	 *
 	 * @param value The value to be logged
 	 * @param factory The session factory
 	 *
 	 * @return The loggable representation
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public String toLoggableString(Object value, SessionFactoryImplementor factory)
 	throws HibernateException;
 
 	/**
 	 * A representation of the value to be embedded in an XML element.
 	 *
 	 * @param node The XML node to which to write the value
 	 * @param value The value to write
 	 * @param factory The session factory
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 *
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory)
 	throws HibernateException;
 
 	/**
 	 * Parse the XML representation of an instance.
 	 *
 	 * @param xml The XML node from which to read the value
 	 * @param factory The session factory
 	 *
 	 * @return an instance of the {@link #getReturnedClass() mapped class}
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 *
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public Object fromXMLNode(Node xml, Mapping factory) throws HibernateException;
 
 	/**
 	 * Returns the abbreviated name of the type.
 	 *
 	 * @return String the Hibernate type name
 	 */
 	public String getName();
 
 	/**
 	 * Return a deep copy of the persistent state, stopping at entities and at collections.
 	 *
 	 * @param value The value to be copied
 	 * @param factory The session factory
 	 *
 	 * @return The deep copy
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Object deepCopy(Object value, SessionFactoryImplementor factory)
 	throws HibernateException;
 
 	/**
 	 * Are objects of this type mutable. (With respect to the referencing object ...
 	 * entities and collections are considered immutable because they manage their
 	 * own internal state.)
 	 *
 	 * @return boolean
 	 */
 	public boolean isMutable();
 
 	/**
 	 * Return a disassembled representation of the object.  This is the value Hibernate will use in second level
 	 * caching, so care should be taken to break values down to their simplest forms; for entities especially, this
 	 * means breaking them down into their constituent parts.
 	 *
 	 * @param value the value to cache
 	 * @param session the originating session
 	 * @param owner optional parent entity object (needed for collections)
 	 *
 	 * @return the disassembled, deep cloned state
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Serializable disassemble(Object value, SessionImplementor session, Object owner) throws HibernateException;
 
 	/**
 	 * Reconstruct the object from its disassembled state.  This method is the reciprocal of {@link #disassemble}
 	 *
 	 * @param cached the disassembled state from the cache
 	 * @param session the originating session
 	 * @param owner the parent entity object
 	 *
 	 * @return the (re)assembled object
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Object assemble(Serializable cached, SessionImplementor session, Object owner)
 	throws HibernateException;
 	
 	/**
 	 * Called before assembling a query result set from the query cache, to allow batch fetching
 	 * of entities missing from the second-level cache.
 	 *
 	 * @param cached The key
 	 * @param session The originating session
 	 */
 	public void beforeAssemble(Serializable cached, SessionImplementor session);
 
 	/**
 	 * Extract a value from the JDBC result set.  This is useful for 2-phase property initialization - the second
 	 * phase is a call to {@link #resolve}
 	 * This hydrated value will be either:<ul>
 	 *     <li>in the case of an entity or collection type, the key</li>
 	 *     <li>otherwise, the value itself</li>
 	 * </ul>
 	 * 
 	 * @param rs The JDBC result set
 	 * @param names the column names making up this type value (use to read from result set)
 	 * @param session The originating session
 	 * @param owner the parent entity
 	 *
 	 * @return An entity or collection key, or an actual value.
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 * @throws SQLException An error from the JDBC driver
 	 *
 	 * @see #resolve
 	 */
 	public Object hydrate(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 	throws HibernateException, SQLException;
 
 	/**
 	 * The second phase of 2-phase loading.  Only really pertinent for entities and collections.  Here we resolve the
 	 * identifier to an entity or collection instance
 	 * 
 	 * @param value an identifier or value returned by <tt>hydrate()</tt>
 	 * @param owner the parent entity
 	 * @param session the session
 	 * 
 	 * @return the given value, or the value associated with the identifier
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 *
 	 * @see #hydrate
 	 */
 	public Object resolve(Object value, SessionImplementor session, Object owner)
 	throws HibernateException;
 	
 	/**
 	 * Given a hydrated, but unresolved value, return a value that may be used to reconstruct property-ref
 	 * associations.
 	 *
 	 * @param value The unresolved, hydrated value
 	 * @param session THe originating session
 	 * @param owner The value owner
 	 *
 	 * @return The semi-resolved value
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Object semiResolve(Object value, SessionImplementor session, Object owner)
 	throws HibernateException;
 	
 	/**
 	 * As part of 2-phase loading, when we perform resolving what is the resolved type for this type?  Generally
 	 * speaking the type and its semi-resolved type will be the same.  The main deviation from this is in the
 	 * case of an entity where the type would be the entity type and semi-resolved type would be its identifier type
 	 *
 	 * @param factory The session factory
 	 *
 	 * @return The semi-resolved type
 	 */
 	public Type getSemiResolvedType(SessionFactoryImplementor factory);
 
 	/**
 	 * During merge, replace the existing (target) value in the entity we are merging to
 	 * with a new (original) value from the detached entity we are merging. For immutable
 	 * objects, or null values, it is safe to simply return the first parameter. For
 	 * mutable objects, it is safe to return a copy of the first parameter. For objects
 	 * with component values, it might make sense to recursively replace component values.
 	 *
 	 * @param original the value from the detached entity being merged
 	 * @param target the value in the managed entity
 	 * @param session The originating session
 	 * @param owner The owner of the value
 	 * @param copyCache The cache of already copied/replaced values
 	 *
 	 * @return the value to be merged
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Object replace(
 			Object original, 
 			Object target, 
 			SessionImplementor session, 
 			Object owner, 
 			Map copyCache) throws HibernateException;
 	
 	/**
 	 * During merge, replace the existing (target) value in the entity we are merging to
 	 * with a new (original) value from the detached entity we are merging. For immutable
 	 * objects, or null values, it is safe to simply return the first parameter. For
 	 * mutable objects, it is safe to return a copy of the first parameter. For objects
 	 * with component values, it might make sense to recursively replace component values.
 	 *
 	 * @param original the value from the detached entity being merged
 	 * @param target the value in the managed entity
 	 * @param session The originating session
 	 * @param owner The owner of the value
 	 * @param copyCache The cache of already copied/replaced values
 	 * @param foreignKeyDirection For associations, which direction does the foreign key point?
 	 *
 	 * @return the value to be merged
 	 *
 	 * @throws HibernateException An error from Hibernate
 	 */
 	public Object replace(
 			Object original, 
 			Object target, 
 			SessionImplementor session, 
 			Object owner, 
 			Map copyCache, 
 			ForeignKeyDirection foreignKeyDirection) throws HibernateException;
 	
 	/**
 	 * Given an instance of the type, return an array of boolean, indicating
 	 * which mapped columns would be null.
 	 * 
 	 * @param value an instance of the type
 	 * @param mapping The mapping abstraction
 	 *
 	 * @return array indicating column nullness for a value instance
 	 */
 	public boolean[] toColumnNullness(Object value, Mapping mapping);
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/usertype/Sized.java b/hibernate-core/src/main/java/org/hibernate/usertype/Sized.java
index 3f3e63080f..4b29a8cc35 100644
--- a/hibernate-core/src/main/java/org/hibernate/usertype/Sized.java
+++ b/hibernate-core/src/main/java/org/hibernate/usertype/Sized.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.usertype;
 
-import org.hibernate.metamodel.relational.Size;
+import org.hibernate.engine.jdbc.Size;
 
 /**
  * Extends dictated/default column size declarations from {@link org.hibernate.type.Type} to the {@link UserType}
  * hierarchy as well via an optional interface.
  *
  * @author Steve Ebersole
  */
 public interface Sized {
 	/**
 	 * Return the column sizes dictated by this type.  For example, the mapping for a {@code char}/{@link Character} would
 	 * have a dictated length limit of 1; for a string-based {@link java.util.UUID} would have a size limit of 36; etc.
 	 *
 	 * @todo Would be much much better to have this aware of Dialect once the service/metamodel split is done
 	 *
 	 * @return The dictated sizes.
 	 *
 	 * @see org.hibernate.type.Type#dictatedSizes
 	 */
 	public Size[] dictatedSizes();
 
 	/**
 	 * Defines the column sizes to use according to this type if the user did not explicitly say (and if no
 	 * {@link #dictatedSizes} were given).
 	 *
 	 * @todo Would be much much better to have this aware of Dialect once the service/metamodel split is done
 	 *
 	 * @return The default sizes.
 	 *
 	 * @see org.hibernate.type.Type#defaultSizes
 	 */
 	public Size[] defaultSizes();
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
deleted file mode 100644
index 2598e426dd..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.sql.Types;
-import java.util.Iterator;
-import java.util.Set;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.domain.BasicType;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistry;
-import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.type.LongType;
-import org.hibernate.type.StringType;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Basic tests of {@code hbm.xml} and annotation binding code
- *
- * @author Steve Ebersole
- */
-public abstract class AbstractBasicBindingTests extends BaseUnitTestCase {
-
-	private StandardServiceRegistryImpl serviceRegistry;
-
-	@Before
-	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().build();
-	}
-
-	@After
-	public void tearDown() {
-		serviceRegistry.destroy();
-	}
-
-	protected ServiceRegistry basicServiceRegistry() {
-		return serviceRegistry;
-	}
-
-	@Test
-	public void testSimpleEntityMapping() {
-		MetadataSources sources = new MetadataSources( serviceRegistry );
-		addSourcesForSimpleEntityBinding( sources );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-		EntityBinding entityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
-		assertRoot( metadata, entityBinding );
-		assertIdAndSimpleProperty( entityBinding );
-
-		assertNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding() );
-	}
-
-	@Test
-	public void testSimpleVersionedEntityMapping() {
-		MetadataSources sources = new MetadataSources( serviceRegistry );
-		addSourcesForSimpleVersionedEntityBinding( sources );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-		EntityBinding entityBinding = metadata.getEntityBinding( SimpleVersionedEntity.class.getName() );
-		assertIdAndSimpleProperty( entityBinding );
-
-		assertNotNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding() );
-		assertNotNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding().getAttribute() );
-	}
-
-	@Test
-	public void testEntityWithManyToOneMapping() {
-		MetadataSources sources = new MetadataSources( serviceRegistry );
-		addSourcesForSimpleEntityBinding( sources );
-		addSourcesForManyToOne( sources );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-
-		EntityBinding simpleEntityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
-		assertIdAndSimpleProperty( simpleEntityBinding );
-
-		Set<SingularAssociationAttributeBinding> referenceBindings = simpleEntityBinding.locateAttributeBinding( "id" )
-				.getEntityReferencingAttributeBindings();
-		assertEquals( "There should be only one reference binding", 1, referenceBindings.size() );
-
-		SingularAssociationAttributeBinding referenceBinding = referenceBindings.iterator().next();
-		EntityBinding referencedEntityBinding = referenceBinding.getReferencedEntityBinding();
-		// TODO - Is this assertion correct (HF)?
-		assertEquals( "Should be the same entity binding", referencedEntityBinding, simpleEntityBinding );
-
-		EntityBinding entityWithManyToOneBinding = metadata.getEntityBinding( ManyToOneEntity.class.getName() );
-		Iterator<SingularAssociationAttributeBinding> it = entityWithManyToOneBinding.getEntityReferencingAttributeBindings()
-				.iterator();
-		assertTrue( it.hasNext() );
-		assertSame( entityWithManyToOneBinding.locateAttributeBinding( "simpleEntity" ), it.next() );
-		assertFalse( it.hasNext() );
-	}
-
-	@Test
-	public void testSimpleEntityWithSimpleComponentMapping() {
-		MetadataSources sources = new MetadataSources( serviceRegistry );
-		addSourcesForComponentBinding( sources );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-		EntityBinding entityBinding = metadata.getEntityBinding( SimpleEntityWithSimpleComponent.class.getName() );
-		assertRoot( metadata, entityBinding );
-		assertIdAndSimpleProperty( entityBinding );
-
-		ComponentAttributeBinding componentAttributeBinding = (ComponentAttributeBinding) entityBinding.locateAttributeBinding( "simpleComponent" );
-		assertNotNull( componentAttributeBinding );
-		assertSame( componentAttributeBinding.getAttribute().getSingularAttributeType(), componentAttributeBinding.getAttributeContainer() );
-		assertEquals( SimpleEntityWithSimpleComponent.class.getName() + ".simpleComponent", componentAttributeBinding.getPathBase() );
-		assertSame( entityBinding, componentAttributeBinding.seekEntityBinding() );
-		assertNotNull( componentAttributeBinding.getComponent() );
-	}
-
-	public abstract void addSourcesForSimpleVersionedEntityBinding(MetadataSources sources);
-
-	public abstract void addSourcesForSimpleEntityBinding(MetadataSources sources);
-
-	public abstract void addSourcesForManyToOne(MetadataSources sources);
-
-	public abstract void addSourcesForComponentBinding(MetadataSources sources);
-
-	protected void assertIdAndSimpleProperty(EntityBinding entityBinding) {
-		assertNotNull( entityBinding );
-		assertNotNull( entityBinding.getHierarchyDetails().getEntityIdentifier() );
-		assertNotNull( entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
-
-		AttributeBinding idAttributeBinding = entityBinding.locateAttributeBinding( "id" );
-		assertNotNull( idAttributeBinding );
-		assertSame( idAttributeBinding, entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
-		assertSame( LongType.INSTANCE, idAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
-
-		assertTrue( idAttributeBinding.getAttribute().isSingular() );
-		assertNotNull( idAttributeBinding.getAttribute() );
-		SingularAttributeBinding singularIdAttributeBinding = (SingularAttributeBinding) idAttributeBinding;
-		assertFalse( singularIdAttributeBinding.isNullable() );
-		SingularAttribute singularIdAttribute =  ( SingularAttribute ) idAttributeBinding.getAttribute();
-		BasicType basicIdAttributeType = ( BasicType ) singularIdAttribute.getSingularAttributeType();
-		assertSame( Long.class, basicIdAttributeType.getClassReference() );
-
-		assertNotNull( singularIdAttributeBinding.getValue() );
-		assertTrue( singularIdAttributeBinding.getValue() instanceof Column );
-		Datatype idDataType = ( (Column) singularIdAttributeBinding.getValue() ).getDatatype();
-		assertSame( Long.class, idDataType.getJavaType() );
-		assertSame( Types.BIGINT, idDataType.getTypeCode() );
-		assertSame( LongType.INSTANCE.getName(), idDataType.getTypeName() );
-
-		assertNotNull( entityBinding.locateAttributeBinding( "name" ) );
-		assertNotNull( entityBinding.locateAttributeBinding( "name" ).getAttribute() );
-		assertTrue( entityBinding.locateAttributeBinding( "name" ).getAttribute().isSingular() );
-
-		SingularAttributeBinding nameBinding = (SingularAttributeBinding) entityBinding.locateAttributeBinding( "name" );
-		assertTrue( nameBinding.isNullable() );
-		assertSame( StringType.INSTANCE, nameBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
-		assertNotNull( nameBinding.getAttribute() );
-		assertNotNull( nameBinding.getValue() );
-		SingularAttribute singularNameAttribute =  ( SingularAttribute ) nameBinding.getAttribute();
-		BasicType basicNameAttributeType = ( BasicType ) singularNameAttribute.getSingularAttributeType();
-		assertSame( String.class, basicNameAttributeType.getClassReference() );
-
-		assertNotNull( nameBinding.getValue() );
-		SimpleValue nameValue = (SimpleValue) nameBinding.getValue();
-		assertTrue( nameValue instanceof Column );
-		Datatype nameDataType = nameValue.getDatatype();
-		assertSame( String.class, nameDataType.getJavaType() );
-		assertSame( Types.VARCHAR, nameDataType.getTypeCode() );
-		assertSame( StringType.INSTANCE.getName(), nameDataType.getTypeName() );
-	}
-
-	protected void assertRoot(MetadataImplementor metadata, EntityBinding entityBinding) {
-		assertTrue( entityBinding.isRoot() );
-		assertSame( entityBinding, metadata.getRootEntityBinding( entityBinding.getEntity().getName() ) );
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java
deleted file mode 100644
index 50d9a9068e..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.metamodel.MetadataSources;
-
-/**
- * Basic tests of annotation based binding code
- *
- * @author Hardy Ferentschik
- */
-public class BasicAnnotationBindingTests extends AbstractBasicBindingTests {
-	@Override
-	public void addSourcesForSimpleEntityBinding(MetadataSources sources) {
-		sources.addAnnotatedClass( SimpleEntity.class );
-	}
-
-	@Override
-	public void addSourcesForSimpleVersionedEntityBinding(MetadataSources sources) {
-		sources.addAnnotatedClass( SimpleVersionedEntity.class );
-	}
-
-	@Override
-	public void addSourcesForManyToOne(MetadataSources sources) {
-		sources.addAnnotatedClass( ManyToOneEntity.class );
-	}
-
-	@Override
-	public void addSourcesForComponentBinding(MetadataSources sources) {
-		sources.addAnnotatedClass( SimpleEntityWithSimpleComponent.class );
-		sources.addAnnotatedClass( SimpleEntityWithSimpleComponent.SimpleComponent.class );
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java
deleted file mode 100644
index 2deb0afe3f..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.hibernate.metamodel.MetadataSourceProcessingOrder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-
-/**
- * @author Steve Ebersole
- */
-public class BasicCollectionBindingTests extends BaseUnitTestCase {
-	private StandardServiceRegistryImpl serviceRegistry;
-
-	@Before
-	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().build();
-	}
-
-	@After
-	public void tearDown() {
-		serviceRegistry.destroy();
-	}
-
-//	@Test
-//	public void testAnnotations() {
-//		doTest( MetadataSourceProcessingOrder.ANNOTATIONS_FIRST );
-//	}
-
-	@Test
-	public void testHbm() {
-		doTest( MetadataSourceProcessingOrder.HBM_FIRST );
-	}
-
-	private void doTest(MetadataSourceProcessingOrder processingOrder) {
-		MetadataSources sources = new MetadataSources( serviceRegistry );
-//		sources.addAnnotatedClass( EntityWithBasicCollections.class );
-		sources.addResource( "org/hibernate/metamodel/binding/EntityWithBasicCollections.hbm.xml" );
-		MetadataImpl metadata = (MetadataImpl) sources.getMetadataBuilder().with( processingOrder ).build();
-
-		final EntityBinding entityBinding = metadata.getEntityBinding( EntityWithBasicCollections.class.getName() );
-		assertNotNull( entityBinding );
-
-		PluralAttributeBinding bagBinding = metadata.getCollection( EntityWithBasicCollections.class.getName() + ".theBag" );
-		assertNotNull( bagBinding );
-		assertSame( bagBinding, entityBinding.locateAttributeBinding( "theBag" ) );
-		assertNotNull( bagBinding.getCollectionTable() );
-		assertEquals( CollectionElementNature.BASIC, bagBinding.getCollectionElement().getCollectionElementNature() );
-		assertEquals( String.class.getName(), ( (BasicCollectionElement) bagBinding.getCollectionElement() ).getHibernateTypeDescriptor().getJavaTypeName() );
-
-		PluralAttributeBinding setBinding = metadata.getCollection( EntityWithBasicCollections.class.getName() + ".theSet" );
-		assertNotNull( setBinding );
-		assertSame( setBinding, entityBinding.locateAttributeBinding( "theSet" ) );
-		assertNotNull( setBinding.getCollectionTable() );
-		assertEquals( CollectionElementNature.BASIC, setBinding.getCollectionElement().getCollectionElementNature() );
-		assertEquals( String.class.getName(), ( (BasicCollectionElement) setBinding.getCollectionElement() ).getHibernateTypeDescriptor().getJavaTypeName() );
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java
deleted file mode 100644
index 7f2b63ae8c..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.MetadataSources;
-
-/**
- * Basic tests of {@code hbm.xml} binding code
- *
- * @author Steve Ebersole
- */
-public class BasicHbmBindingTests extends AbstractBasicBindingTests {
-	public void addSourcesForSimpleEntityBinding(MetadataSources sources) {
-		sources.addResource( "org/hibernate/metamodel/binding/SimpleEntity.hbm.xml" );
-	}
-
-	public void addSourcesForSimpleVersionedEntityBinding(MetadataSources sources) {
-		sources.addResource( "org/hibernate/metamodel/binding/SimpleVersionedEntity.hbm.xml" );
-	}
-
-	public void addSourcesForManyToOne(MetadataSources sources) {
-		sources.addResource( "org/hibernate/metamodel/binding/ManyToOneEntity.hbm.xml" );
-	}
-
-	public void addSourcesForComponentBinding(MetadataSources sources) {
-		sources.addResource( "org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.hbm.xml" );
-	}
-
-	@Test
-	public void testSimpleEntityWithSimpleComponentMapping() {
-		super.testSimpleEntityWithSimpleComponentMapping();
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.hbm.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.hbm.xml
deleted file mode 100644
index 3eb4ca7633..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.hbm.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0"?>
-<hibernate-mapping
-        xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-        package="org.hibernate.metamodel.binding" >
-
-    <class name="EntityWithBasicCollections">
-
-    	<id name="id">
-    		<generator class="increment"/>
-    	</id>
-        <property name="name"/>
-
-        <bag name="theBag">
-            <key column="owner_id"/>
-            <element column="bag_stuff" type="string"/>
-        </bag>
-
-        <set name="theSet">
-            <key column="pid"/>
-            <element column="set_stuff" type="string"/>
-        </set>
-	</class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.java
deleted file mode 100644
index af2001320b..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/EntityWithBasicCollections.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-import javax.persistence.ElementCollection;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-/**
- * @author Gail Badner
- * @author Steve Ebersole
- */
-@Entity
-public class EntityWithBasicCollections {
-	private Long id;
-	private String name;
-	private Collection<String> theBag = new ArrayList<String>();
-	private Set<String> theSet = new HashSet<String>();
-
-	public EntityWithBasicCollections() {
-	}
-
-	public EntityWithBasicCollections(String name) {
-		this.name = name;
-	}
-
-	@Id
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	@ElementCollection
-	public Collection<String> getTheBag() {
-		return theBag;
-	}
-
-	public void setTheBag(Collection<String> theBag) {
-		this.theBag = theBag;
-	}
-
-	@ElementCollection
-	public Set<String> getTheSet() {
-		return theSet;
-	}
-
-	public void setTheSet(Set<String> theSet) {
-		this.theSet = theSet;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.hbm.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.hbm.xml
deleted file mode 100644
index dc6baf6321..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.hbm.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<?xml version="1.0"?>
-<hibernate-mapping package="org.hibernate.metamodel.binding"
-                       xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                       xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-
-    <class name="ManyToOneEntity">
-        <id name="id">
-            <generator class="increment"/>
-        </id>
-        <property name="name"/>
-        <many-to-one name="simpleEntity"/>
-    </class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.java
deleted file mode 100644
index 709d769e20..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/ManyToOneEntity.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.ManyToOne;
-
-/**
- * @author Gail Badner
- */
-@Entity
-public class ManyToOneEntity {
-	@Id
-	private Long id;
-	private String theName;
-	@ManyToOne
-	SimpleEntity simpleEntity;
-
-	public ManyToOneEntity() {
-	}
-
-	public ManyToOneEntity(String name) {
-		this.theName = name;
-	}
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return theName;
-	}
-
-	public void setName(String name) {
-		this.theName = name;
-	}
-
-	public SimpleEntity getSimpleEntity() {
-		return simpleEntity;
-	}
-
-	public void setSimpleEntity(SimpleEntity simpleEntity) {
-		this.simpleEntity = simpleEntity;
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder sb = new StringBuilder();
-		sb.append( "EntityWithManyToOne" );
-		sb.append( "{id=" ).append( id );
-		sb.append( ", theName='" ).append( theName ).append( '\'' );
-		sb.append( ", simpleEntity=" ).append( simpleEntity );
-		sb.append( '}' );
-		return sb.toString();
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.hbm.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.hbm.xml
deleted file mode 100644
index 14f88143aa..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.hbm.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0"?>
-<hibernate-mapping package="org.hibernate.metamodel.binding" xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                   xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-
-    <class name="SimpleEntity">
-
-    	<id name="id">
-    		<generator class="increment"/>
-    	</id>
-        <property name="name"/>
-	</class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.java
deleted file mode 100644
index 227dc31cf4..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntity.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-/**
- * @author Steve Ebersole
- */
-@Entity
-public class SimpleEntity {
-	@Id
-	private Long id;
-	private String name;
-
-	public SimpleEntity() {
-	}
-
-	public SimpleEntity(String name) {
-		this.name = name;
-	}
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntitySubClass.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntitySubClass.java
deleted file mode 100644
index 29c6c31491..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntitySubClass.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import javax.persistence.Entity;
-
-/**
- * @author Steve Ebersole
- */
-@Entity
-public class SimpleEntitySubClass extends SimpleEntity {
-
-	public SimpleEntitySubClass() {
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.hbm.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.hbm.xml
deleted file mode 100644
index af62001456..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.hbm.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0"?>
-<hibernate-mapping
-        xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-        xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        package="org.hibernate.metamodel.binding">
-
-    <class name="SimpleEntityWithSimpleComponent">
-    	<id name="id">
-    		<generator class="increment"/>
-    	</id>
-        <property name="name"/>
-        <component name="simpleComponent" class="SimpleEntityWithSimpleComponent$SimpleComponent">
-            <property name="value1"/>
-            <property name="value2"/>
-        </component>
-	</class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.java
deleted file mode 100644
index 1fb5ec9854..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleEntityWithSimpleComponent.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import javax.persistence.Embeddable;
-import javax.persistence.Embedded;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-/**
- * @author Steve Ebersole
- */
-@Entity
-public class SimpleEntityWithSimpleComponent {
-	@Id
-	private Long id;
-	private String name;
-	@Embedded
-	private SimpleComponent simpleComponent;
-
-	public SimpleEntityWithSimpleComponent() {
-	}
-
-	public SimpleEntityWithSimpleComponent(String name) {
-		this.name = name;
-	}
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	public SimpleComponent getSimpleComponent() {
-		return simpleComponent;
-	}
-
-	public void setSimpleComponent(SimpleComponent simpleComponent) {
-		this.simpleComponent = simpleComponent;
-	}
-
-	@Embeddable
-	public static class SimpleComponent {
-		private String value1;
-		private String value2;
-
-		public String getValue1() {
-			return value1;
-		}
-
-		public void setValue1(String value1) {
-			this.value1 = value1;
-		}
-
-		public String getValue2() {
-			return value2;
-		}
-
-		public void setValue2(String value2) {
-			this.value2 = value2;
-		}
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java
deleted file mode 100644
index bf7c6d177c..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import java.sql.Types;
-
-import org.junit.Test;
-
-import org.hibernate.EntityMode;
-import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.metamodel.domain.Entity;
-import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.Datatype;
-import org.hibernate.metamodel.relational.Schema;
-import org.hibernate.metamodel.relational.Size;
-import org.hibernate.metamodel.relational.Table;
-import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static org.junit.Assert.assertSame;
-
-/**
- * Basic binding "smoke" tests
- *
- * @author Steve Ebersole
- */
-public class SimpleValueBindingTests extends BaseUnitTestCase {
-	public static final Datatype BIGINT = new Datatype( Types.BIGINT, "BIGINT", Long.class );
-	public static final Datatype VARCHAR = new Datatype( Types.VARCHAR, "VARCHAR", String.class );
-
-
-	@Test
-	public void testBasicMiddleOutBuilding() {
-		Table table = new Table( new Schema( null, null ), "the_table" );
-		Entity entity = new Entity( "TheEntity", "NoSuchClass", makeJavaType( "NoSuchClass" ), null );
-		EntityBinding entityBinding = new EntityBinding( InheritanceType.NO_INHERITANCE, EntityMode.POJO );
-		entityBinding.setEntity( entity );
-		entityBinding.setPrimaryTable( table );
-
-		SingularAttribute idAttribute = entity.createSingularAttribute( "id" );
-		BasicAttributeBinding attributeBinding = entityBinding.makeBasicAttributeBinding( idAttribute );
-		attributeBinding.getHibernateTypeDescriptor().setExplicitTypeName( "long" );
-		assertSame( idAttribute, attributeBinding.getAttribute() );
-
-		entityBinding.getHierarchyDetails().getEntityIdentifier().setValueBinding( attributeBinding );
-
-		Column idColumn = table.locateOrCreateColumn( "id" );
-		idColumn.setDatatype( BIGINT );
-		idColumn.setSize( Size.precision( 18, 0 ) );
-		table.getPrimaryKey().addColumn( idColumn );
-		table.getPrimaryKey().setName( "my_table_pk" );
-		//attributeBinding.setValue( idColumn );
-	}
-
-	ValueHolder<Class<?>> makeJavaType(final String name) {
-		return new ValueHolder<Class<?>>(
-				new ValueHolder.DeferredInitializer<Class<?>>() {
-					@Override
-					public Class<?> initialize() {
-						try {
-							return Class.forName( name );
-						}
-						catch ( Exception e ) {
-							throw new ClassLoadingException( "Could not load class : " + name, e );
-						}
-					}
-				}
-		);
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.hbm.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.hbm.xml
deleted file mode 100644
index 13425bf8d8..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.hbm.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0"?>
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ Copyright (c) 2010, Red Hat Inc. or third-party contributors as
-  ~ indicated by the @author tags or express copyright attribution
-  ~ statements applied by the authors.  All third-party contributions are
-  ~ distributed under license by Red Hat Inc.
-  ~
-  ~ This copyrighted material is made available to anyone wishing to use, modify,
-  ~ copy, or redistribute it subject to the terms and conditions of the GNU
-  ~ Lesser General Public License, as published by the Free Software Foundation.
-  ~
-  ~ This program is distributed in the hope that it will be useful,
-  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-  ~ for more details.
-  ~
-  ~ You should have received a copy of the GNU Lesser General Public License
-  ~ along with this distribution; if not, write to:
-  ~ Free Software Foundation, Inc.
-  ~ 51 Franklin Street, Fifth Floor
-  ~ Boston, MA  02110-1301  USA
-  -->
-<hibernate-mapping package="org.hibernate.metamodel.binding" xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                   xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-
-    <class name="SimpleVersionedEntity">
-
-    	<id name="id">
-    		<generator class="increment"/>
-    	</id>
-        <version name="version"/>
-        <property name="name"/>
-	</class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.java
deleted file mode 100644
index 2c7eacd515..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binding;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.Version;
-
-/**
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-@Entity
-public class SimpleVersionedEntity {
-	private Long id;
-	private String name;
-	private long version;
-
-	public SimpleVersionedEntity() {
-	}
-
-	public SimpleVersionedEntity(String name) {
-		this.name = name;
-	}
-
-	@Id
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	@Version
-	public long getVersion() {
-		return version;
-	}
-
-	public void setVersion(long version) {
-		this.version = version;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.xml b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.xml
deleted file mode 100644
index 24882262d1..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleVersionedEntity.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0"?>
-<!--
-  ~ Hibernate, Relational Persistence for Idiomatic Java
-  ~
-  ~ Copyright (c) 2011, Red Hat Inc. or third-party contributors as
-  ~ indicated by the @author tags or express copyright attribution
-  ~ statements applied by the authors.  All third-party contributions are
-  ~ distributed under license by Red Hat Inc.
-  ~
-  ~ This copyrighted material is made available to anyone wishing to use, modify,
-  ~ copy, or redistribute it subject to the terms and conditions of the GNU
-  ~ Lesser General Public License, as published by the Free Software Foundation.
-  ~
-  ~ This program is distributed in the hope that it will be useful,
-  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-  ~ for more details.
-  ~
-  ~ You should have received a copy of the GNU Lesser General Public License
-  ~ along with this distribution; if not, write to:
-  ~ Free Software Foundation, Inc.
-  ~ 51 Franklin Street, Fifth Floor
-  ~ Boston, MA  02110-1301  USA
-  -->
-<hibernate-mapping package="org.hibernate.metamodel.binding" xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                   xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-
-    <class name="SimpleVersionedEntity">
-
-        <id name="id">
-            <generator class="increment"/>
-        </id>
-        <version name="version"/>
-        <property name="name"/>
-    </class>
-
-</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java
deleted file mode 100644
index 95b316c2d1..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java
+++ /dev/null
@@ -1,4 +0,0 @@
-@GenericGenerator(name = "myGenerator", strategy = "sequence")
-package org.hibernate.metamodel.binding;
-
-import org.hibernate.annotations.GenericGenerator;
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/relational/ObjectNameTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/relational/ObjectNameTests.java
deleted file mode 100644
index d974b8d942..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/relational/ObjectNameTests.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import org.junit.Test;
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.dialect.H2Dialect;
-import org.hibernate.testing.env.TestingDatabaseInfo;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * @author Steve Ebersole
- */
-public class ObjectNameTests extends BaseUnitTestCase {
-	@Test
-	public void testMissingName() {
-		try {
-			new ObjectName( (String)null, null, null );
-			fail();
-		}
-		catch ( IllegalIdentifierException ignore ) {
-		}
-
-		try {
-			new ObjectName( "schema", "catalog", null );
-			fail();
-		}
-		catch ( IllegalIdentifierException ignore ) {
-		}
-	}
-
-	@Test
-	public void testIdentifierBuilding() {
-		Dialect dialect = TestingDatabaseInfo.DIALECT;
-		ObjectName on = new ObjectName( "schema", "catalog", "name" );
-		assertEquals( "schema.catalog.name", on.toText() );
-		on = new ObjectName( "schema", null, "name" );
-		assertEquals( "schema.name", on.toText() );
-		assertEquals( "schema.name", on.toText( dialect ) );
-		on = new ObjectName( "`schema`", "`catalog`", "`name`" );
-		assertEquals( "`schema`.`catalog`.`name`", on.toText() );
-		assertEquals( "\"schema\".\"catalog\".\"name\"", on.toText( dialect ) );
-		on = new ObjectName( "`schema`", null, "`name`" );
-		assertEquals( "`schema`.`name`", on.toText() );
-		assertEquals( "\"schema\".\"name\"", on.toText( dialect ) );
-	}
-}
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/relational/TableManipulationTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/relational/TableManipulationTests.java
deleted file mode 100644
index 69fdc683b4..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/relational/TableManipulationTests.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.relational;
-
-import java.sql.Types;
-
-import org.junit.Test;
-
-import org.hibernate.dialect.Dialect;
-import org.hibernate.dialect.H2Dialect;
-import org.hibernate.testing.env.TestingDatabaseInfo;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Steve Ebersole
- */
-public class TableManipulationTests extends BaseUnitTestCase {
-	public static final Datatype VARCHAR = new Datatype( Types.VARCHAR, "VARCHAR", String.class );
-	public static final Datatype INTEGER = new Datatype( Types.INTEGER, "INTEGER", Long.class );
-
-	@Test
-	public void testTableCreation() {
-		Schema schema = new Schema( null, null );
-		Table table = schema.createTable( Identifier.toIdentifier( "my_table" ) );
-		assertNull( table.getSchema().getName().getSchema() );
-		assertNull( table.getSchema().getName().getCatalog() );
-		assertEquals( "my_table", table.getTableName().toString() );
-		assertEquals( "my_table", table.getExportIdentifier() );
-		assertNull( table.getPrimaryKey().getName() );
-		assertFalse( table.values().iterator().hasNext() );
-
-		Column idColumn = table.locateOrCreateColumn( "id" );
-		idColumn.setDatatype( INTEGER );
-		idColumn.setSize( Size.precision( 18, 0 ) );
-		table.getPrimaryKey().addColumn( idColumn );
-		table.getPrimaryKey().setName( "my_table_pk" );
-		assertEquals( "my_table_pk", table.getPrimaryKey().getName() );
-		assertEquals( "my_table.PK", table.getPrimaryKey().getExportIdentifier() );
-
-		Column col_1 = table.locateOrCreateColumn( "col_1" );
-		col_1.setDatatype( VARCHAR );
-		col_1.setSize( Size.length( 512 ) );
-
-		for ( Value value : table.values() ) {
-			assertTrue( Column.class.isInstance( value ) );
-			Column column = ( Column ) value;
-			if ( column.getColumnName().getName().equals( "id" ) ) {
-				assertEquals( INTEGER, column.getDatatype() );
-				assertEquals( 18, column.getSize().getPrecision() );
-				assertEquals( 0, column.getSize().getScale() );
-				assertEquals( -1, column.getSize().getLength() );
-				assertNull( column.getSize().getLobMultiplier() );
-			}
-			else {
-				assertEquals( "col_1", column.getColumnName().getName() );
-				assertEquals( VARCHAR, column.getDatatype() );
-				assertEquals( -1, column.getSize().getPrecision() );
-				assertEquals( -1, column.getSize().getScale() );
-				assertEquals( 512, column.getSize().getLength() );
-				assertNull( column.getSize().getLobMultiplier() );
-			}
-		}
-	}
-
-	@Test
-	public void testTableSpecificationCounter() {
-		Schema schema = new Schema( null, null );
-		Table table = schema.createTable( Identifier.toIdentifier( "my_table" ) );
-		InLineView inLineView = schema.createInLineView( "my_inlineview", "subselect" );
-		InLineView otherInLineView = schema.createInLineView( "my_other_inlineview", "other subselect" );
-		Table otherTable = schema.createTable( Identifier.toIdentifier( "my_other_table" ) );
-
-		int firstTableNumber = table.getTableNumber();
-		assertEquals( firstTableNumber, table.getTableNumber() );
-		assertEquals( firstTableNumber + 1, inLineView.getTableNumber() );
-		assertEquals( firstTableNumber + 2, otherInLineView.getTableNumber() );
-		assertEquals( firstTableNumber + 3, otherTable.getTableNumber() );
-	}
-
-	@Test
-	public void testBasicForeignKeyDefinition() {
-		Schema schema = new Schema( null, null );
-		Table book = schema.createTable( Identifier.toIdentifier( "BOOK" ) );
-
-		Column bookId = book.locateOrCreateColumn( "id" );
-		bookId.setDatatype( INTEGER );
-		bookId.setSize( Size.precision( 18, 0 ) );
-		book.getPrimaryKey().addColumn( bookId );
-		book.getPrimaryKey().setName( "BOOK_PK" );
-
-		Table page = schema.createTable( Identifier.toIdentifier( "PAGE" ) );
-
-		Column pageId = page.locateOrCreateColumn( "id" );
-		pageId.setDatatype( INTEGER );
-		pageId.setSize( Size.precision( 18, 0 ) );
-		page.getPrimaryKey().addColumn( pageId );
-		page.getPrimaryKey().setName( "PAGE_PK" );
-
-		Column pageBookId = page.locateOrCreateColumn( "BOOK_ID" );
-		pageId.setDatatype( INTEGER );
-		pageId.setSize( Size.precision( 18, 0 ) );
-		ForeignKey pageBookFk = page.createForeignKey( book, "PAGE_BOOK_FK" );
-		pageBookFk.addColumn( pageBookId );
-
-		assertEquals( page, pageBookFk.getSourceTable() );
-		assertEquals( book, pageBookFk.getTargetTable() );
-	}
-
-	@Test
-	public void testQualifiedName() {
-		Dialect dialect = TestingDatabaseInfo.DIALECT;
-		Schema schema = new Schema( Identifier.toIdentifier( "schema" ), Identifier.toIdentifier( "`catalog`" ) );
-		Table table = schema.createTable( Identifier.toIdentifier( "my_table" ) );
-		assertEquals( "my_table", table.getTableName().getName() );
-		assertEquals( "my_table", table.getTableName().toString() );
-		assertEquals( "schema.\"catalog\".my_table", table.getQualifiedName( dialect ) );
-
-		table = schema.createTable( Identifier.toIdentifier( "`my_table`" ) );
-		assertEquals( "my_table", table.getTableName().getName() );
-		assertEquals( "`my_table`", table.getTableName().toString() );
-		assertEquals( "schema.\"catalog\".\"my_table\"", table.getQualifiedName( dialect ) );
-
-		InLineView inLineView = schema.createInLineView( "my_inlineview", "select ..." );
-		assertEquals( "( select ... )", inLineView.getQualifiedName( dialect ) );
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/AccessBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/AccessBindingTest.java
deleted file mode 100644
index bfbe32b9f3..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/AccessBindingTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Access;
-import javax.persistence.AccessType;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-
-/**
- * Tests for different types of attribute access
- *
- * @author Hardy Ferentschik
- */
-
-public class AccessBindingTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	class FieldAccess {
-		@Id
-		private int id;
-	}
-
-	@Test
-	@Resources(annotatedClasses = { FieldAccess.class })
-	public void testDefaultFieldAccess() {
-		EntityBinding binding = getEntityBinding( FieldAccess.class );
-		assertEquals( "Wrong access type", "field", binding.locateAttributeBinding( "id" ).getPropertyAccessorName() );
-	}
-
-	@Entity
-	class PropertyAccess {
-		private int id;
-
-		@Id
-		public int getId() {
-			return id;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = { PropertyAccess.class })
-	public void testDefaultPropertyAccess() {
-		EntityBinding binding = getEntityBinding( PropertyAccess.class );
-		assertEquals( "Wrong access type", "property", binding.locateAttributeBinding( "id" ).getPropertyAccessorName() );
-	}
-
-
-	@Entity
-	class NoAccess {
-		private int id;
-
-		public int getId() {
-			return id;
-		}
-	}
-
-	@Test(expected = AnnotationException.class)
-	@Resources(annotatedClasses = { NoAccess.class })
-	public void testNoAccess() {
-		// actual error happens when the binding gets created
-	}
-
-	@Entity
-	class MixedAccess {
-		@Id
-		private int id;
-
-		private String name;
-
-		@Access(AccessType.PROPERTY)
-		public String getName() {
-			return name;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = { MixedAccess.class })
-	public void testMixedAccess() {
-		EntityBinding binding = getEntityBinding( MixedAccess.class );
-		assertEquals( "Wrong access type", "field", binding.locateAttributeBinding( "id" ).getPropertyAccessorName() );
-		assertEquals(
-				"Wrong access type",
-				"property",
-				binding.locateAttributeBinding( "name" ).getPropertyAccessorName()
-		);
-	}
-
-	@Entity
-	class Base {
-		@Id
-		int id;
-	}
-
-	@Entity
-	@Access(AccessType.PROPERTY)
-	class ClassConfiguredAccess extends Base {
-		private String name;
-
-		public String getName() {
-			return name;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = { ClassConfiguredAccess.class, Base.class })
-	public void testExplicitClassConfiguredAccess() {
-		EntityBinding binding = getEntityBinding( Base.class );
-		assertEquals(
-				"Wrong access type",
-				"field",
-				binding.locateAttributeBinding( "id" ).getPropertyAccessorName()
-		);
-
-
-		binding = getEntityBinding( ClassConfiguredAccess.class );
-		assertEquals(
-				"Wrong access type",
-				"property",
-				binding.locateAttributeBinding( "name" ).getPropertyAccessorName()
-		);
-	}
-
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
deleted file mode 100644
index 52a040af39..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.MethodRule;
-import org.junit.runners.model.FrameworkMethod;
-import org.junit.runners.model.Statement;
-
-/**
- * @author Hardy Ferentschik
- */
-public abstract class BaseAnnotationBindingTestCase extends BaseUnitTestCase {
-	protected MetadataSources sources;
-	protected MetadataImpl meta;
-
-	@Rule
-	public MethodRule buildMetaData = new MethodRule() {
-		@Override
-		public Statement apply(final Statement statement, FrameworkMethod frameworkMethod, Object o) {
-			return new KeepSetupFailureStatement( statement, frameworkMethod );
-		}
-	};
-
-	@After
-	public void tearDown() {
-		sources = null;
-		meta = null;
-	}
-
-	public EntityBinding getEntityBinding(Class<?> clazz) {
-		return meta.getEntityBinding( clazz.getName() );
-	}
-
-	public EntityBinding getRootEntityBinding(Class<?> clazz) {
-		return meta.getRootEntityBinding( clazz.getName() );
-	}
-
-	class KeepSetupFailureStatement extends Statement {
-		private final Statement origStatement;
-		private final FrameworkMethod origFrameworkMethod;
-		private Throwable setupError;
-		private boolean expectedException;
-
-		KeepSetupFailureStatement(Statement statement, FrameworkMethod frameworkMethod) {
-			this.origStatement = statement;
-			this.origFrameworkMethod = frameworkMethod;
-		}
-
-		@Override
-		public void evaluate() throws Throwable {
-			try {
-				createBindings();
-				origStatement.evaluate();
-				if ( setupError != null ) {
-					throw setupError;
-				}
-			}
-			catch ( Throwable t ) {
-				if ( setupError == null ) {
-					throw t;
-				}
-				else {
-					if ( !expectedException ) {
-						throw setupError;
-					}
-				}
-			}
-		}
-
-		private void createBindings() {
-			try {
-				sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-				MetadataBuilder metadataBuilder = sources.getMetadataBuilder();
-				Resources resourcesAnnotation = origFrameworkMethod.getAnnotation( Resources.class );
-				if ( resourcesAnnotation != null ) {
-					metadataBuilder.with( resourcesAnnotation.cacheMode() );
-
-					for ( Class<?> annotatedClass : resourcesAnnotation.annotatedClasses() ) {
-						sources.addAnnotatedClass( annotatedClass );
-					}
-					if ( !resourcesAnnotation.ormXmlPath().isEmpty() ) {
-						sources.addResource( resourcesAnnotation.ormXmlPath() );
-					}
-				}
-
-				meta = ( MetadataImpl ) metadataBuilder.build();
-			}
-			catch ( final Throwable t ) {
-				setupError = t;
-				Test testAnnotation = origFrameworkMethod.getAnnotation( Test.class );
-				Class<?> expected = testAnnotation.expected();
-				if ( t.getClass().equals( expected ) ) {
-					expectedException = true;
-				}
-			}
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BatchSizeBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BatchSizeBindingTest.java
deleted file mode 100644
index b94774e9be..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BatchSizeBindingTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.BatchSize;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-
-/**
- * Tests for {@code o.h.a.BatchSize}.
- *
- * @author Hardy Ferentschik
- */
-public class BatchSizeBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = NoBatchSizeEntity.class)
-	public void testNoBatchSize() {
-		EntityBinding binding = getEntityBinding( NoBatchSizeEntity.class );
-		assertEquals( "Wrong batch size", -1, binding.getBatchSize() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = BatchSizeEntity.class)
-	public void testBatchSize() {
-		EntityBinding binding = getEntityBinding( BatchSizeEntity.class );
-		assertEquals( "Wrong batch size", 100, binding.getBatchSize() );
-	}
-
-	@Entity
-	class NoBatchSizeEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@BatchSize(size = 100)
-	class BatchSizeEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CacheBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CacheBindingTest.java
deleted file mode 100644
index 4b6bf54199..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CacheBindingTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Cacheable;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.SharedCacheMode;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Cache;
-import org.hibernate.annotations.CacheConcurrencyStrategy;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-
-/**
- * Tests for {@code o.h.a.Cache} and {@code j.p.Cacheable}.
- *
- * @author Hardy Ferentschik
- */
-public class CacheBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = HibernateCacheEntity.class, cacheMode = SharedCacheMode.ALL)
-	public void testHibernateCaching() {
-		EntityBinding binding = getEntityBinding( HibernateCacheEntity.class );
-		assertNotNull( "There should be a cache binding", binding.getHierarchyDetails().getCaching() );
-		Caching caching = binding.getHierarchyDetails().getCaching();
-		assertEquals( "Wrong region", "foo", caching.getRegion() );
-		assertEquals( "Wrong strategy", AccessType.READ_WRITE, caching.getAccessType() );
-		assertEquals( "Wrong lazy properties configuration", false, caching.isCacheLazyProperties() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = JpaCacheEntity.class, cacheMode = SharedCacheMode.ALL)
-	public void testJpaCaching() {
-		EntityBinding binding = getEntityBinding( JpaCacheEntity.class );
-		assertNotNull( "There should be a cache binding", binding.getHierarchyDetails().getCaching() );
-		Caching caching = binding.getHierarchyDetails().getCaching();
-		assertEquals(
-				"Wrong region",
-				this.getClass().getName() + "$" + JpaCacheEntity.class.getSimpleName(),
-				caching.getRegion()
-		);
-		assertEquals( "Wrong lazy properties configuration", true, caching.isCacheLazyProperties() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = NoCacheEntity.class, cacheMode = SharedCacheMode.NONE)
-	public void testNoCaching() {
-		EntityBinding binding = getEntityBinding( NoCacheEntity.class );
-		assertNull( "There should be no cache binding", binding.getHierarchyDetails().getCaching() );
-	}
-
-	@Entity
-	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "foo", include = "non-lazy")
-	class HibernateCacheEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Cacheable
-	class JpaCacheEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Cacheable
-	class NoCacheEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CustomSQLBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CustomSQLBindingTest.java
deleted file mode 100644
index 935fa511b2..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/CustomSQLBindingTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.ResultCheckStyle;
-import org.hibernate.annotations.SQLDelete;
-import org.hibernate.annotations.SQLDeleteAll;
-import org.hibernate.annotations.SQLInsert;
-import org.hibernate.annotations.SQLUpdate;
-import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-
-/**
- * Tests for {@code o.h.a.SQLInsert}, {@code o.h.a.SQLUpdate}, {@code o.h.a.Delete} and {@code o.h.a.SQLDeleteAll}.
- *
- * @author Hardy Ferentschik
- */
-public class CustomSQLBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = NoCustomSQLEntity.class)
-	public void testNoCustomSqlAnnotations() {
-		EntityBinding binding = getEntityBinding( NoCustomSQLEntity.class );
-		assertNull( binding.getCustomDelete() );
-		assertNull( binding.getCustomInsert() );
-		assertNull( binding.getCustomUpdate() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = CustomSQLEntity.class)
-	public void testCustomSqlAnnotations() {
-		EntityBinding binding = getEntityBinding( CustomSQLEntity.class );
-
-		CustomSQL customSql = binding.getCustomInsert();
-		assertCustomSql( customSql, "INSERT INTO FOO", true, ExecuteUpdateResultCheckStyle.NONE );
-
-		customSql = binding.getCustomDelete();
-		assertCustomSql( customSql, "DELETE FROM FOO", false, ExecuteUpdateResultCheckStyle.COUNT );
-
-		customSql = binding.getCustomUpdate();
-		assertCustomSql( customSql, "UPDATE FOO", false, ExecuteUpdateResultCheckStyle.PARAM );
-	}
-
-// not so sure about the validity of this one
-//	@Test
-//	public void testDeleteAllWins() {
-//		buildMetadataSources( CustomDeleteAllEntity.class );
-//		EntityBinding binding = getEntityBinding( CustomDeleteAllEntity.class );
-//		assertEquals( "Wrong sql", "DELETE ALL", binding.getCustomDelete().getSql() );
-//	}
-
-	private void assertCustomSql(CustomSQL customSql, String sql, boolean isCallable, ExecuteUpdateResultCheckStyle style) {
-		assertNotNull( customSql );
-		assertEquals( "Wrong sql", sql, customSql.getSql() );
-		assertEquals( isCallable, customSql.isCallable() );
-		assertEquals( style, customSql.getCheckStyle() );
-	}
-
-	@Entity
-	class NoCustomSQLEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@SQLInsert(sql = "INSERT INTO FOO", callable = true)
-	@SQLDelete(sql = "DELETE FROM FOO", check = ResultCheckStyle.COUNT)
-	@SQLUpdate(sql = "UPDATE FOO", check = ResultCheckStyle.PARAM)
-	class CustomSQLEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@SQLDelete(sql = "DELETE")
-	@SQLDeleteAll(sql = "DELETE ALL")
-	class CustomDeleteAllEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableBindingTest.java
deleted file mode 100644
index 6a0099d3c0..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableBindingTest.java
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.AttributeOverride;
-import javax.persistence.AttributeOverrides;
-import javax.persistence.Column;
-import javax.persistence.Embeddable;
-import javax.persistence.Embedded;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Parent;
-import org.hibernate.annotations.Target;
-import org.hibernate.metamodel.binding.BasicAttributeBinding;
-import org.hibernate.metamodel.binding.ComponentAttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * Tests for {@code javax.persistence.Embeddable}.
- *
- * @author Hardy Ferentschik
- */
-public class EmbeddableBindingTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	class User {
-		@Id
-		private int id;
-
-		@Embedded
-		private Phone phone;
-	}
-
-	@Embeddable
-	class Phone {
-		String countryCode;
-		String areaCode;
-		String number;
-	}
-
-	@Test
-	@Resources(annotatedClasses = { User.class, Phone.class })
-	public void testEmbeddable() {
-		EntityBinding binding = getEntityBinding( User.class );
-
-		final String componentName = "phone";
-		assertNotNull( binding.locateAttributeBinding( componentName ) );
-		assertTrue( binding.locateAttributeBinding( componentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding componentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				componentName
-		);
-
-		// todo - is this really correct? Does the path start w/ the class name
-		assertEquals(
-				"Wrong path",
-				"org.hibernate.metamodel.source.annotations.entity.EmbeddableBindingTest$User.phone",
-				componentBinding.getPathBase()
-		);
-
-		assertNotNull( componentBinding.locateAttributeBinding( "countryCode" ) );
-		assertNotNull( componentBinding.locateAttributeBinding( "areaCode" ) );
-		assertNotNull( componentBinding.locateAttributeBinding( "number" ) );
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	@Entity
-	@AttributeOverride(name = "embedded.name", column = @Column(name = "FUBAR", length = 42))
-	class BaseEntity {
-		@Id
-		private int id;
-
-		@Embedded
-		private EmbeddedEntity embedded;
-	}
-
-	@Embeddable
-	class EmbeddedEntity {
-		String name;
-	}
-
-	@Test
-	@Resources(annotatedClasses = { BaseEntity.class, EmbeddedEntity.class })
-	public void testEmbeddableWithAttributeOverride() {
-		EntityBinding binding = getEntityBinding( BaseEntity.class );
-
-		final String componentName = "embedded";
-		assertNotNull( binding.locateAttributeBinding( componentName ) );
-		assertTrue( binding.locateAttributeBinding( componentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding componentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				componentName
-		);
-
-		assertNotNull( componentBinding.locateAttributeBinding( "name" ) );
-		BasicAttributeBinding nameAttribute = (BasicAttributeBinding) componentBinding.locateAttributeBinding( "name" );
-		org.hibernate.metamodel.relational.Column column = (org.hibernate.metamodel.relational.Column) nameAttribute.getValue();
-		assertEquals( "Attribute override specifies a custom column name", "FUBAR", column.getColumnName().getName() );
-		assertEquals( "Attribute override specifies a custom size", 42, column.getSize().getLength() );
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	@Embeddable
-	public class Address {
-		protected String street;
-		protected String city;
-		protected String state;
-		@Embedded
-		protected Zipcode zipcode;
-	}
-
-	@Embeddable
-	public class Zipcode {
-		protected String zip;
-		protected String plusFour;
-	}
-
-	@Entity
-	public class Customer {
-		@Id
-		protected Integer id;
-		protected String name;
-		@AttributeOverrides( {
-				@AttributeOverride(name = "state",
-						column = @Column(name = "ADDR_STATE")),
-				@AttributeOverride(name = "zipcode.zip",
-						column = @Column(name = "ADDR_ZIP"))
-		})
-		@Embedded
-		protected Address address;
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	@Test
-	@Resources(annotatedClasses = { Zipcode.class, Address.class, Customer.class })
-	public void testNestedEmbeddable() {
-		EntityBinding binding = getEntityBinding( Customer.class );
-
-		final String addressComponentName = "address";
-		assertNotNull( binding.locateAttributeBinding( addressComponentName ) );
-		assertTrue( binding.locateAttributeBinding( addressComponentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding attributeComponentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				addressComponentName
-		);
-
-		assertNotNull( attributeComponentBinding.locateAttributeBinding( "street" ) );
-		assertNotNull( attributeComponentBinding.locateAttributeBinding( "city" ) );
-		assertNotNull( attributeComponentBinding.locateAttributeBinding( "state" ) );
-
-		BasicAttributeBinding stateAttribute = (BasicAttributeBinding) attributeComponentBinding.locateAttributeBinding(
-				"state"
-		);
-		org.hibernate.metamodel.relational.Column column = (org.hibernate.metamodel.relational.Column) stateAttribute.getValue();
-		assertEquals(
-				"Attribute override specifies a custom column name",
-				"ADDR_STATE",
-				column.getColumnName().getName()
-		);
-
-
-		final String zipComponentName = "zipcode";
-		assertNotNull( attributeComponentBinding.locateAttributeBinding( zipComponentName ) );
-		assertTrue( attributeComponentBinding.locateAttributeBinding( zipComponentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding zipComponentBinding = (ComponentAttributeBinding) attributeComponentBinding.locateAttributeBinding(
-				zipComponentName
-		);
-
-		BasicAttributeBinding nameAttribute = (BasicAttributeBinding) zipComponentBinding.locateAttributeBinding( "zip" );
-		column = (org.hibernate.metamodel.relational.Column) nameAttribute.getValue();
-		assertEquals(
-				"Attribute override specifies a custom column name",
-				"ADDR_ZIP",
-				column.getColumnName().getName()
-		);
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	@Embeddable
-	public class A {
-		@Embedded
-		@AttributeOverrides( {
-				@AttributeOverride(name = "foo", column = @Column(name = "BAR")),
-				@AttributeOverride(name = "fubar", column = @Column(name = "A_WINS"))
-		})
-		private B b;
-
-		public B getB() {
-			return b;
-		}
-	}
-
-	@Embeddable
-	public class B {
-		private String foo;
-		private String fubar;
-
-		public String getFoo() {
-			return foo;
-		}
-
-		public String getFubar() {
-			return fubar;
-		}
-	}
-
-	@Entity
-	public class C {
-		@Id
-		int id;
-
-		@Embedded
-		@AttributeOverride(name = "b.fubar", column = @Column(name = "C_WINS"))
-		protected A a;
-
-		public int getId() {
-			return id;
-		}
-
-		public A getA() {
-			return a;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = { A.class, B.class, C.class })
-	public void testAttributeOverrideInEmbeddable() {
-		EntityBinding binding = getEntityBinding( C.class );
-
-		final String aComponentName = "a";
-		assertNotNull( binding.locateAttributeBinding( aComponentName ) );
-		assertTrue( binding.locateAttributeBinding( aComponentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding aComponentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				aComponentName
-		);
-
-		final String bComponentName = "b";
-		assertNotNull( aComponentBinding.locateAttributeBinding( bComponentName ) );
-		assertTrue( aComponentBinding.locateAttributeBinding( bComponentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding bComponentBinding = (ComponentAttributeBinding) aComponentBinding.locateAttributeBinding(
-				bComponentName
-		);
-
-		BasicAttributeBinding attribute = (BasicAttributeBinding) bComponentBinding.locateAttributeBinding( "foo" );
-		org.hibernate.metamodel.relational.Column column = (org.hibernate.metamodel.relational.Column) attribute.getValue();
-		assertEquals(
-				"Attribute override specifies a custom column name",
-				"BAR",
-				column.getColumnName().getName()
-		);
-
-		attribute = (BasicAttributeBinding) bComponentBinding.locateAttributeBinding( "fubar" );
-		column = (org.hibernate.metamodel.relational.Column) attribute.getValue();
-		assertEquals(
-				"Attribute override specifies a custom column name",
-				"C_WINS",
-				column.getColumnName().getName()
-		);
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	@Embeddable
-	public class EmbeddableEntity {
-		private String test;
-		@Parent
-		private MainEntity parent;
-	}
-
-	@Entity
-	public class MainEntity {
-		@Id
-		private int id;
-
-		@Embedded
-		private EmbeddableEntity embedded;
-	}
-
-	@Test
-	@Resources(annotatedClasses = { MainEntity.class, EmbeddableEntity.class })
-	public void testParentReferencingAttributeName() {
-		EntityBinding binding = getEntityBinding( MainEntity.class );
-
-		final String componentName = "embedded";
-		assertNotNull( binding.locateAttributeBinding( componentName ) );
-		assertTrue( binding.locateAttributeBinding( componentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding componentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				componentName
-		);
-
-		assertEquals( "Wrong parent reference name", "parent", componentBinding.getParentReference().getName() );
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-	public interface Car {
-		int getHorsePower();
-	}
-
-	@Embeddable
-	public class CarImpl implements Car {
-		@Override
-		public int getHorsePower() {
-			return 0;
-		}
-	}
-
-	@Entity
-	public class Owner {
-		private int id;
-		private Car car;
-
-		@Id
-		public int getId() {
-			return id;
-		}
-
-		@Embedded
-		@Target(CarImpl.class)
-		public Car getCar() {
-			return car;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = { Owner.class, CarImpl.class, Car.class })
-	public void testTargetAnnotationWithEmbeddable() {
-		EntityBinding binding = getEntityBinding( Owner.class );
-
-		final String componentName = "car";
-		assertNotNull( binding.locateAttributeBinding( componentName ) );
-		assertTrue( binding.locateAttributeBinding( componentName ) instanceof ComponentAttributeBinding );
-		ComponentAttributeBinding componentBinding = (ComponentAttributeBinding) binding.locateAttributeBinding(
-				componentName
-		);
-
-		BasicAttributeBinding attribute = (BasicAttributeBinding) componentBinding.locateAttributeBinding( "horsePower" );
-		assertTrue( attribute.getAttribute().isTypeResolved() );
-		assertEquals(
-				"Wrong resolved type",
-				"int",
-				attribute.getAttribute().getSingularAttributeType().getClassName()
-		);
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddedIdTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddedIdTest.java
deleted file mode 100644
index 7ec16508b5..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EmbeddedIdTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Access;
-import javax.persistence.AccessType;
-import javax.persistence.Embeddable;
-import javax.persistence.EmbeddedId;
-import javax.persistence.Entity;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.EntityIdentifier;
-import org.hibernate.testing.FailureExpected;
-
-import static junit.framework.Assert.assertTrue;
-
-/**
- * @author Strong Liu
- */
-@FailureExpected(jiraKey = "HHH-6447", message = "Work in progress")
-public class EmbeddedIdTest extends BaseAnnotationBindingTestCase {
-    @Test
-//	@Resources(annotatedClasses = { User.class, Address.class })
-    public void testEmbeddable() {
-        EntityBinding binding = getEntityBinding( User.class );
-        EntityIdentifier identifier = binding.getHierarchyDetails().getEntityIdentifier();
-        assertTrue( identifier.isEmbedded() );
-    }
-
-    @Entity
-    @Access( AccessType.FIELD )
-    class User {
-        private String name;
-        @EmbeddedId
-        private Address address;
-    }
-
-    @Embeddable
-    class Address {
-        String street;
-        String city;
-        String postCode;
-    }
-}
-
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EnumeratedBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EnumeratedBindingTest.java
deleted file mode 100644
index 9049e08c60..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/EnumeratedBindingTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.sql.Types;
-import java.util.Date;
-import javax.persistence.Entity;
-import javax.persistence.EnumType;
-import javax.persistence.Enumerated;
-import javax.persistence.Id;
-import javax.persistence.Temporal;
-import javax.persistence.TemporalType;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-
-/**
- * @author Strong Liu
- */
-public class EnumeratedBindingTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	class Item {
-		@Id
-		long id;
-		@Temporal(TemporalType.TIMESTAMP)
-		Date orderDate;
-		String name;
-		@Enumerated(EnumType.STRING)
-		OrderType orderType;
-		CustomerType customerType;
-	}
-
-	enum CustomerType {
-		PROGRAMMER, BOSS;
-	}
-
-	enum OrderType {
-		B2C, C2C, MAIL, DIRECT;
-	}
-
-	@Test
-	@Resources(annotatedClasses = Item.class)
-	public void testEnumeratedTypeAttribute() {
-		EntityBinding binding = getEntityBinding( Item.class );
-
-		AttributeBinding attributeBinding = binding.locateAttributeBinding( "customerType" );
-		HibernateTypeDescriptor descriptor = attributeBinding.getHibernateTypeDescriptor();
-		assertEquals( org.hibernate.type.EnumType.class.getName(), descriptor.getExplicitTypeName() );
-		assertEquals( CustomerType.class.getName(), descriptor.getJavaTypeName() );
-		assertNotNull( descriptor.getResolvedTypeMapping() );
-		assertFalse( descriptor.getTypeParameters().isEmpty() );
-		assertEquals(
-				CustomerType.class.getName(),
-				descriptor.getTypeParameters().get( org.hibernate.type.EnumType.ENUM )
-		);
-		assertEquals(
-				String.valueOf( Types.INTEGER ),
-				descriptor.getTypeParameters().get( org.hibernate.type.EnumType.TYPE )
-		);
-
-
-		attributeBinding = binding.locateAttributeBinding( "orderType" );
-		descriptor = attributeBinding.getHibernateTypeDescriptor();
-		assertEquals( org.hibernate.type.EnumType.class.getName(), descriptor.getExplicitTypeName() );
-		assertEquals( OrderType.class.getName(), descriptor.getJavaTypeName() );
-		assertNotNull( descriptor.getResolvedTypeMapping() );
-		assertFalse( descriptor.getTypeParameters().isEmpty() );
-		assertEquals(
-				OrderType.class.getName(),
-				descriptor.getTypeParameters().get( org.hibernate.type.EnumType.ENUM )
-		);
-		assertEquals(
-				String.valueOf( Types.VARCHAR ),
-				descriptor.getTypeParameters().get( org.hibernate.type.EnumType.TYPE )
-		);
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java
deleted file mode 100644
index c5f0afbbf0..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.GenerationType;
-import javax.persistence.Id;
-
-import org.hibernate.annotations.GenericGenerator;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.dialect.H2Dialect;
-import org.hibernate.id.Assigned;
-import org.hibernate.id.IdentifierGenerator;
-import org.hibernate.id.IdentityGenerator;
-import org.hibernate.id.MultipleHiLoPerTableGenerator;
-import org.hibernate.id.SequenceHiLoGenerator;
-import org.hibernate.id.UUIDHexGenerator;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.EntityIdentifier;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.testing.RequiresDialect;
-import org.junit.Test;
-
-/**
- * @author Hardy Ferentschik
- */
-@RequiresDialect(H2Dialect.class)
-public class IdentifierGeneratorTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	class NoGenerationEntity {
-		@Id
-		private long id;
-	}
-
-	@Test
-	@Resources(annotatedClasses = NoGenerationEntity.class)
-	public void testNoIdGeneration() {
-		EntityBinding binding = getEntityBinding( NoGenerationEntity.class );
-        EntityIdentifier identifier = binding.getHierarchyDetails().getEntityIdentifier();
-		IdentifierGenerator generator =identifier.getIdentifierGenerator();
-        assertNotNull( generator );
-        assertEquals( "Wrong generator", Assigned.class, generator.getClass() );
-        assertFalse( identifier.isEmbedded() );
-
-	}
-
-	@Entity
-	class AutoEntity {
-		@Id
-		@GeneratedValue
-		private long id;
-
-		public long getId() {
-			return id;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = AutoEntity.class)
-	public void testAutoGenerationType() {
-		EntityBinding binding = getEntityBinding( AutoEntity.class );
-		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
-
-		assertEquals( "Wrong generator", IdentityGenerator.class, generator.getClass() );
-	}
-
-	@Entity
-	class TableEntity {
-		@Id
-		@GeneratedValue(strategy = GenerationType.TABLE)
-		private long id;
-
-		public long getId() {
-			return id;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = TableEntity.class)
-	public void testTableGenerationType() {
-		EntityBinding binding = getEntityBinding( TableEntity.class );
-		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
-
-		assertEquals( "Wrong generator", MultipleHiLoPerTableGenerator.class, generator.getClass() );
-	}
-
-	@Entity
-	class SequenceEntity {
-		@Id
-		@GeneratedValue(strategy = GenerationType.SEQUENCE)
-		private long id;
-
-		public long getId() {
-			return id;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = SequenceEntity.class)
-	public void testSequenceGenerationType() {
-		EntityBinding binding = getEntityBinding( SequenceEntity.class );
-		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
-
-		assertEquals( "Wrong generator", SequenceHiLoGenerator.class, generator.getClass() );
-	}
-
-
-	@Entity
-	class NamedGeneratorEntity {
-		@Id
-		@GeneratedValue(generator = "my-generator")
-		private long id;
-
-		public long getId() {
-			return id;
-		}
-	}
-
-	@Test
-	public void testUndefinedGenerator() {
-		try {
-			sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-			sources.addAnnotatedClass( NamedGeneratorEntity.class );
-			sources.buildMetadata();
-			fail();
-		}
-		catch ( MappingException e ) {
-			assertTrue( e.getMessage().startsWith( "Unable to find named generator" ) );
-		}
-	}
-
-	@Entity
-	@GenericGenerator(name = "my-generator", strategy = "uuid")
-	class NamedGeneratorEntity2 {
-		@Id
-		@GeneratedValue(generator = "my-generator")
-		private long id;
-
-		public long getId() {
-			return id;
-		}
-	}
-
-	@Test
-	@Resources(annotatedClasses = NamedGeneratorEntity2.class)
-	public void testNamedGenerator() {
-		EntityBinding binding = getEntityBinding( NamedGeneratorEntity2.class );
-		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
-
-		assertEquals( "Wrong generator", UUIDHexGenerator.class, generator.getClass() );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/InheritanceBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/InheritanceBindingTest.java
deleted file mode 100644
index 6ba182dd8d..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/InheritanceBindingTest.java
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-import javax.persistence.DiscriminatorColumn;
-import javax.persistence.DiscriminatorType;
-import javax.persistence.DiscriminatorValue;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.DiscriminatorFormula;
-import org.hibernate.annotations.DiscriminatorOptions;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.EntityDiscriminator;
-import org.hibernate.metamodel.relational.DerivedValue;
-import org.hibernate.metamodel.relational.SimpleValue;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertSame;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * @author Hardy Ferentschik
- */
-public class InheritanceBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = SingleEntity.class)
-	public void testNoInheritance() {
-		EntityBinding entityBinding = getEntityBinding( SingleEntity.class );
-		assertNull( entityBinding.getHierarchyDetails().getEntityDiscriminator() );
-		assertFalse( entityBinding.isPolymorphic() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { RootOfSingleTableInheritance.class, SubclassOfSingleTableInheritance.class })
-	public void testDiscriminatorValue() {
-		EntityBinding entityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		assertEquals( "Wrong discriminator value", "foo1", entityBinding.getDiscriminatorMatchValue() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { RootOfSingleTableInheritance.class, SubclassOfSingleTableInheritance.class })
-	public void testSubclassEntitySuperType() {
-		EntityBinding entityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		assertNotNull( entityBinding.getEntity().getSuperType() );
-		assertSame( RootOfSingleTableInheritance.class, entityBinding.getEntity().getSuperType().getClassReference() );
-		assertEquals( RootOfSingleTableInheritance.class.getName(), entityBinding.getEntity().getSuperType().getClassName() );
-		assertNull( entityBinding.getEntity().getSuperType().getSuperType() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { RootOfSingleTableInheritance.class, SubclassOfSingleTableInheritance.class })
-	public void testRootEntitySuperType() {
-		EntityBinding entityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		assertNull( entityBinding.getEntity().getSuperType() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class
-	})
-	public void testRootEntityBinding() {
-		EntityBinding noInheritanceEntityBinding = getEntityBinding( SingleEntity.class );
-		assertTrue( "SingleEntity should be a root entity", noInheritanceEntityBinding.isRoot() );
-		assertSame( noInheritanceEntityBinding, getRootEntityBinding( SingleEntity.class ) );
-
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		assertFalse( subclassEntityBinding.isRoot() );
-		assertSame( rootEntityBinding, getRootEntityBinding( SubclassOfSingleTableInheritance.class ) );
-
-		assertTrue( rootEntityBinding.isRoot() );
-		assertSame( rootEntityBinding, getRootEntityBinding( RootOfSingleTableInheritance.class ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testNoPolymorphism() {
-		EntityBinding noInheritanceEntityBinding = getEntityBinding( SingleEntity.class );
-		assertTrue( "SingleEntity should be a root entity", noInheritanceEntityBinding.isRoot() );
-		assertNull( noInheritanceEntityBinding.getSuperEntityBinding() );
-		assertSame( noInheritanceEntityBinding, getRootEntityBinding( SingleEntity.class ) );
-		assertFalse( noInheritanceEntityBinding.isPolymorphic() );
-		assertFalse( noInheritanceEntityBinding.hasSubEntityBindings() );
-		assertEquals( 0, noInheritanceEntityBinding.getSubEntityBindingClosureSpan() );
-		assertFalse( noInheritanceEntityBinding.getPostOrderSubEntityBindingClosure().iterator().hasNext() );
-		assertFalse( noInheritanceEntityBinding.getPreOrderSubEntityBindingClosure().iterator().hasNext() );
-		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : noInheritanceEntityBinding.attributeBindings() ) {
-			assertTrue( directAttributeBindings.add( attributeBinding ) );
-		}
-		assertEquals( 1, directAttributeBindings.size() );
-		assertSame(
-				noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(),
-				directAttributeBindings.iterator().next()
-		);
-		assertEquals( 1, noInheritanceEntityBinding.getAttributeBindingClosureSpan() );
-		Iterator<AttributeBinding> iterator = noInheritanceEntityBinding.attributeBindings().iterator();
-		assertTrue( iterator.hasNext() );
-		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
-		assertFalse( iterator.hasNext() );
-		iterator = noInheritanceEntityBinding.getAttributeBindingClosure().iterator();
-		assertTrue( iterator.hasNext() );
-		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
-		assertFalse( iterator.hasNext() );
-		iterator =  noInheritanceEntityBinding.getSubEntityAttributeBindingClosure().iterator();
-		assertTrue( iterator.hasNext() );
-		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
-		assertFalse( iterator.hasNext() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testRootPolymporhism() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-
-		assertTrue( rootEntityBinding.isRoot() );
-		assertNull( rootEntityBinding.getDiscriminatorMatchValue() );
-		assertNull( rootEntityBinding.getSuperEntityBinding() );
-		assertSame( rootEntityBinding, getRootEntityBinding( RootOfSingleTableInheritance.class ) );
-		assertTrue( rootEntityBinding.isPolymorphic() );
-		assertTrue( rootEntityBinding.hasSubEntityBindings() );
-		Iterator<EntityBinding> directEntityBindingIterator = rootEntityBinding.getDirectSubEntityBindings().iterator();
-		assertTrue( directEntityBindingIterator.hasNext() );
-		EntityBinding directSubEntityBinding1 = directEntityBindingIterator.next();
-		assertTrue( directEntityBindingIterator.hasNext() );
-		EntityBinding directSubEntityBinding2 = directEntityBindingIterator.next();
-		assertFalse( directEntityBindingIterator.hasNext() );
-		boolean isSubclassEntityBindingFirst =  directSubEntityBinding1 == subclassEntityBinding;
-		if ( isSubclassEntityBindingFirst ) {
-			assertSame( otherSubclassEntityBinding, directSubEntityBinding2 );
-		}
-		else {
-			assertSame( otherSubclassEntityBinding, directSubEntityBinding1 );
-			assertSame( subclassEntityBinding, directSubEntityBinding2 );
-		}
-		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : rootEntityBinding.attributeBindings() ) {
-			assertTrue( directAttributeBindings.add( attributeBinding ) );
-		}
-		assertEquals( 1, directAttributeBindings.size() );
-		assertTrue( directAttributeBindings.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertEquals( 1, rootEntityBinding.getAttributeBindingClosureSpan() );
-		Set<AttributeBinding> attributeBindingClosure = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : rootEntityBinding.getAttributeBindingClosure() ) {
-			assertTrue( attributeBindingClosure.add( attributeBinding ) );
-		}
-		assertEquals( 1, attributeBindingClosure.size() );
-		assertTrue( attributeBindingClosure.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		Set<AttributeBinding> subAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding subAttributeBinding : rootEntityBinding.getSubEntityAttributeBindingClosure() ) {
-			assertTrue( subAttributeBindings.add( subAttributeBinding ) );
-		}
-		assertEquals( 4, subAttributeBindings.size() );
-		assertTrue( subAttributeBindings.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassOfSubclassEntityBinding.locateAttributeBinding( "otherOtherName" ) ) );
-		assertTrue( subAttributeBindings.contains( otherSubclassEntityBinding.locateAttributeBinding( "otherName" ) ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testPreOrderRootSubEntityClosure() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-		// need to figure out the order of direct subclasses, since it's indeterminate
-		Iterator<EntityBinding> directEntityBindingIterator = rootEntityBinding.getDirectSubEntityBindings().iterator();
-		boolean isSubclassEntityBindingFirst = subclassEntityBinding == directEntityBindingIterator.next();
-		assertEquals( 3, rootEntityBinding.getSubEntityBindingClosureSpan() );
-		Iterator<EntityBinding> subEntityBindingIterator = rootEntityBinding.getPreOrderSubEntityBindingClosure().iterator();
-		assertTrue( subEntityBindingIterator.hasNext() );
-		if ( isSubclassEntityBindingFirst ) {
-			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
-			assertTrue( subEntityBindingIterator.hasNext() );
-			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
-			assertTrue( subEntityBindingIterator.hasNext() );
-			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
-		}
-		else {
-			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
-			assertTrue( subEntityBindingIterator.hasNext() );
-			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
-			assertTrue( subEntityBindingIterator.hasNext() );
-			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
-		}
-		assertFalse( subEntityBindingIterator.hasNext() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testPostOrderRootSubEntityClosure() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-		// need to figure out the order of direct subclasses, since it's indeterminate
-		Iterator<EntityBinding> directEntityBindingIterator = rootEntityBinding.getDirectSubEntityBindings().iterator();
-		boolean isSubclassEntityBindingFirst = subclassEntityBinding == directEntityBindingIterator.next();
-		assertEquals( 3, rootEntityBinding.getSubEntityBindingClosureSpan() );
-		Iterator<EntityBinding> subEntityBindingIterator = rootEntityBinding.getPostOrderSubEntityBindingClosure().iterator();
-		assertTrue( subEntityBindingIterator.hasNext() );
-		if ( isSubclassEntityBindingFirst ) {
-			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
-			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
-			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
-		}
-		else {
-			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
-			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
-			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
-		}
-		assertFalse( subEntityBindingIterator.hasNext() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testLeafSubclassOfRoot() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-
-		assertEquals( "Wrong discriminator value", "foo2", otherSubclassEntityBinding.getDiscriminatorMatchValue() );
-		assertFalse( otherSubclassEntityBinding.isRoot() );
-		assertSame( rootEntityBinding, otherSubclassEntityBinding.getSuperEntityBinding() );
-		assertSame( rootEntityBinding, getRootEntityBinding( OtherSubclassOfSingleTableInheritance.class) );
-		assertTrue( otherSubclassEntityBinding.isPolymorphic() );
-		assertFalse( otherSubclassEntityBinding.hasSubEntityBindings() );
-		assertEquals( 0, otherSubclassEntityBinding.getSubEntityBindingClosureSpan() );
-		assertFalse( otherSubclassEntityBinding.getPostOrderSubEntityBindingClosure().iterator().hasNext() );
-		assertFalse( otherSubclassEntityBinding.getPreOrderSubEntityBindingClosure().iterator().hasNext() );
-		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : otherSubclassEntityBinding.attributeBindings() ) {
-			assertTrue( directAttributeBindings.add( attributeBinding ) );
-		}
-		assertEquals( 1, directAttributeBindings.size() );
-		assertTrue( directAttributeBindings.contains( otherSubclassEntityBinding.locateAttributeBinding( "otherName" ) ) );
-		assertEquals( 2, otherSubclassEntityBinding.getAttributeBindingClosureSpan() );
-		Set<AttributeBinding> attributeBindingClosure = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : otherSubclassEntityBinding.getAttributeBindingClosure() ) {
-			assertTrue( attributeBindingClosure.add( attributeBinding ) );
-		}
-		assertEquals(2, attributeBindingClosure.size() );
-		assertTrue( attributeBindingClosure.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( attributeBindingClosure.contains( otherSubclassEntityBinding.locateAttributeBinding( "otherName" ) ) );
-		Set<AttributeBinding> subAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding subAttributeBinding : otherSubclassEntityBinding.getSubEntityAttributeBindingClosure() ) {
-			assertTrue( subAttributeBindings.add( subAttributeBinding ) );
-		}
-		assertEquals( 2, subAttributeBindings.size() );
-		assertTrue( subAttributeBindings.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( subAttributeBindings.contains( otherSubclassEntityBinding.locateAttributeBinding( "otherName" ) ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testNonLeafSubclassOfRootPolymporhism() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-
-		assertEquals( "Wrong discriminator value", "foo1", subclassEntityBinding.getDiscriminatorMatchValue() );
-		assertFalse( subclassEntityBinding.isRoot() );
-		assertSame( rootEntityBinding, subclassEntityBinding.getSuperEntityBinding() );
-		assertSame( rootEntityBinding, getRootEntityBinding( SubclassOfSingleTableInheritance.class ) );
-		assertTrue( subclassEntityBinding.isPolymorphic() );
-		assertTrue( subclassEntityBinding.hasSubEntityBindings() );
-		assertEquals( 1, subclassEntityBinding.getSubEntityBindingClosureSpan() );
-		Iterator<EntityBinding> itSubEntityBindings = subclassEntityBinding.getPostOrderSubEntityBindingClosure().iterator();
-		assertTrue( itSubEntityBindings.hasNext() );
-		assertSame( subclassOfSubclassEntityBinding, itSubEntityBindings.next() );
-		assertFalse( itSubEntityBindings.hasNext() );
-		itSubEntityBindings = subclassEntityBinding.getPreOrderSubEntityBindingClosure().iterator();
-		assertTrue( itSubEntityBindings.hasNext() );
-		assertSame( subclassOfSubclassEntityBinding, itSubEntityBindings.next() );
-		assertFalse( itSubEntityBindings.hasNext() );
-		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : subclassEntityBinding.attributeBindings() ) {
-			assertTrue( directAttributeBindings.add( attributeBinding ) );
-		}
-		assertEquals( 1, directAttributeBindings.size() );
-		assertTrue( directAttributeBindings.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		assertEquals( 2, subclassEntityBinding.getAttributeBindingClosureSpan() );
-		Set<AttributeBinding> attributeBindingClosure = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : subclassEntityBinding.getAttributeBindingClosure() ) {
-			assertTrue( attributeBindingClosure.add( attributeBinding ) );
-		}
-		assertEquals( 2, attributeBindingClosure.size() );
-		assertTrue( attributeBindingClosure.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( attributeBindingClosure.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		Set<AttributeBinding> subAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding subAttributeBinding : subclassEntityBinding.getSubEntityAttributeBindingClosure() ) {
-			assertTrue( subAttributeBindings.add( subAttributeBinding ) );
-		}
-		assertEquals( 3, subAttributeBindings.size() );
-		assertTrue( subAttributeBindings.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassOfSubclassEntityBinding.locateAttributeBinding( "otherOtherName" ) ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = {
-			SubclassOfSingleTableInheritance.class,
-			SingleEntity.class,
-			RootOfSingleTableInheritance.class,
-			OtherSubclassOfSingleTableInheritance.class,
-			SubclassOfSubclassOfSingleTableInheritance.class
-	})
-	public void testLeafSubclassOfSubclassOfRootPolymporhism() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
-		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
-		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
-
-		assertEquals( "Wrong discriminator value", "foo1_1", subclassOfSubclassEntityBinding.getDiscriminatorMatchValue() );
-		assertFalse( subclassOfSubclassEntityBinding.isRoot() );
-		assertSame( subclassEntityBinding, subclassOfSubclassEntityBinding.getSuperEntityBinding() );
-		assertSame( rootEntityBinding, getRootEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class ) );
-		assertTrue( subclassOfSubclassEntityBinding.isPolymorphic() );
-		assertFalse( subclassOfSubclassEntityBinding.hasSubEntityBindings() );
-		assertEquals( 0, subclassOfSubclassEntityBinding.getSubEntityBindingClosureSpan() );
-		assertFalse( subclassOfSubclassEntityBinding.getPostOrderSubEntityBindingClosure().iterator().hasNext() );
-		assertFalse( subclassOfSubclassEntityBinding.getPreOrderSubEntityBindingClosure().iterator().hasNext() );
-		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : subclassOfSubclassEntityBinding.attributeBindings() ) {
-			assertTrue( directAttributeBindings.add( attributeBinding ) );
-		}
-		assertEquals( 1, directAttributeBindings.size() );
-		assertTrue( directAttributeBindings.contains( subclassOfSubclassEntityBinding.locateAttributeBinding( "otherOtherName" ) ) );
-		assertEquals( 3, subclassOfSubclassEntityBinding.getAttributeBindingClosureSpan() );
-		Set<AttributeBinding> attributeBindingClosure = new HashSet<AttributeBinding>();
-		for ( AttributeBinding attributeBinding : subclassOfSubclassEntityBinding.getAttributeBindingClosure() ) {
-			assertTrue( attributeBindingClosure.add( attributeBinding ) );
-		}
-		assertEquals( 3, attributeBindingClosure.size() );
-		assertTrue( attributeBindingClosure.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( attributeBindingClosure.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		assertTrue( attributeBindingClosure.contains( subclassOfSubclassEntityBinding.locateAttributeBinding( "otherOtherName" ) ) );
-		Set<AttributeBinding> subAttributeBindings = new HashSet<AttributeBinding>();
-		for ( AttributeBinding subAttributeBinding : subclassOfSubclassEntityBinding.getSubEntityAttributeBindingClosure() ) {
-			assertTrue( subAttributeBindings.add( subAttributeBinding ) );
-		}
-		assertEquals( 3, subAttributeBindings.size() );
-		assertTrue( subAttributeBindings.contains( rootEntityBinding.locateAttributeBinding( "id" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassEntityBinding.locateAttributeBinding( "name" ) ) );
-		assertTrue( subAttributeBindings.contains( subclassOfSubclassEntityBinding.locateAttributeBinding( "otherOtherName" ) ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { RootOfSingleTableInheritance.class, SubclassOfSingleTableInheritance.class })
-	public void testDefaultDiscriminatorOptions() {
-		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
-		EntityDiscriminator discriminator = rootEntityBinding.getHierarchyDetails().getEntityDiscriminator();
-		assertFalse( "Wrong default value", discriminator.isForced() );
-		assertTrue( "Wrong default value", discriminator.isInserted() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { Base.class, Jump.class })
-	public void testExplicitDiscriminatorOptions() {
-		EntityBinding rootEntityBinding = getEntityBinding( Base.class );
-		EntityDiscriminator discriminator = rootEntityBinding.getHierarchyDetails().getEntityDiscriminator();
-		assertTrue( "Wrong default value", discriminator.isForced() );
-		assertFalse( "Wrong default value", discriminator.isInserted() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = { Base.class, Jump.class })
-	public void testRootDiscriminatorMatchValue() {
-		EntityBinding rootEntityBinding = getEntityBinding( Base.class );
-		assertEquals( "base", rootEntityBinding.getDiscriminatorMatchValue() );
-	}
-
-    @Test
-    @Resources(annotatedClasses = { Fruit.class, Apple.class })
-    public void testDiscriminatorFormula() {
-        EntityBinding rootEntityBinding = getEntityBinding( Fruit.class );
-        assertTrue( rootEntityBinding.isRoot() );
-        EntityBinding entityBinding = getEntityBinding( Apple.class );
-        assertFalse( entityBinding.isRoot() );
-		EntityDiscriminator discriminator = rootEntityBinding.getHierarchyDetails().getEntityDiscriminator();
-        SimpleValue simpleValue = discriminator.getBoundValue();
-        assertTrue( simpleValue instanceof DerivedValue);
-        DerivedValue derivedValue = (DerivedValue)simpleValue;
-        assertEquals( "case when zik_type is null then 0 else zik_type end", derivedValue.getExpression() );
-		assertTrue( "Wrong default value", discriminator.isForced() );
-		assertFalse( "Wrong default value", discriminator.isInserted() );
-    }
-
-    @Entity
-	class SingleEntity {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	class RootOfSingleTableInheritance {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	@DiscriminatorValue("foo1")
-	public class SubclassOfSingleTableInheritance extends RootOfSingleTableInheritance {
-		private String name;
-	}
-
-	@Entity
-	@DiscriminatorValue("foo2")
-	public class OtherSubclassOfSingleTableInheritance extends RootOfSingleTableInheritance {
-		private String otherName;
-	}
-
-	@Entity
-	@DiscriminatorValue("foo1_1")
-	public class SubclassOfSubclassOfSingleTableInheritance extends SubclassOfSingleTableInheritance {
-		private String otherOtherName;
-	}
-
-	@Entity
-	@DiscriminatorValue("base")
-	@DiscriminatorOptions(force = true, insert = false)
-	class Base {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	class Jump extends Base {
-	}
-
-    @Entity
-    @DiscriminatorColumn(discriminatorType = DiscriminatorType.INTEGER)
-    @DiscriminatorFormula("case when zik_type is null then 0 else zik_type end")
-    @DiscriminatorOptions(force = true, insert = false)
-    class Fruit {
-        @Id
-        private int id;
-    }
-
-    @Entity
-    class Apple extends Fruit {
-
-    }
-
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/LobBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/LobBindingTests.java
deleted file mode 100644
index 6069d63048..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/LobBindingTests.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.io.Serializable;
-import java.sql.Blob;
-import java.sql.Clob;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.Lob;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
-import org.hibernate.type.BlobType;
-import org.hibernate.type.CharacterArrayClobType;
-import org.hibernate.type.ClobType;
-import org.hibernate.type.MaterializedBlobType;
-import org.hibernate.type.MaterializedClobType;
-import org.hibernate.type.PrimitiveCharacterArrayClobType;
-import org.hibernate.type.SerializableToBlobType;
-import org.hibernate.type.StandardBasicTypes;
-import org.hibernate.type.WrappedMaterializedBlobType;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Strong Liu
- */
-public class LobBindingTests extends BaseAnnotationBindingTestCase {
-    @Entity
-    class Item {
-        @Id
-        long id;
-        @Lob
-        Clob clob;
-        @Lob
-        Blob blob;
-        @Lob
-        String str;
-        @Lob
-        Character[] characters;
-        @Lob
-        char[] chars;
-        @Lob
-        Byte[] bytes;
-        @Lob
-        byte[] bytes2;
-        @Lob
-        Thing serializable;
-        String noLob;
-    }
-
-    class Thing implements Serializable {
-        int size;
-    }
-
-    private HibernateTypeDescriptor getTypeDescriptor(String attributeName) {
-        EntityBinding binding = getEntityBinding( Item.class );
-        AttributeBinding attributeBinding = binding.locateAttributeBinding( attributeName );
-        return attributeBinding.getHibernateTypeDescriptor();
-    }
-
-    private class ExpectedValue {
-        String explicitTypeName;
-        String javaTypeName;
-        boolean isResolvedTypeMappingNull;
-        Class resolvedTypeMappingClass;
-        boolean isTypeParametersNull;
-        boolean isTypeParametersEmpty;
-
-        private ExpectedValue(String explicitTypeName,
-                              String javaTypeName,
-                              boolean resolvedTypeMappingNull,
-                              Class resolvedTypeMappingClass,
-                              boolean typeParametersNull,
-                              boolean typeParametersEmpty
-        ) {
-            this.explicitTypeName = explicitTypeName;
-            this.isResolvedTypeMappingNull = resolvedTypeMappingNull;
-            this.isTypeParametersEmpty = typeParametersEmpty;
-            this.isTypeParametersNull = typeParametersNull;
-            this.javaTypeName = javaTypeName;
-            this.resolvedTypeMappingClass = resolvedTypeMappingClass;
-        }
-    }
-
-    private void checkHibernateTypeDescriptor(ExpectedValue expectedValue, String attributeName) {
-        HibernateTypeDescriptor descriptor = getTypeDescriptor( attributeName );
-        assertEquals( expectedValue.explicitTypeName, descriptor.getExplicitTypeName() );
-        assertEquals( expectedValue.javaTypeName, descriptor.getJavaTypeName() );
-        assertEquals( expectedValue.isResolvedTypeMappingNull, descriptor.getResolvedTypeMapping() == null );
-        assertEquals( expectedValue.resolvedTypeMappingClass, descriptor.getResolvedTypeMapping().getClass() );
-        assertEquals( expectedValue.isTypeParametersNull, descriptor.getTypeParameters() == null );
-        assertEquals( expectedValue.isTypeParametersEmpty, descriptor.getTypeParameters().isEmpty() );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testClobWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                "clob",
-                Clob.class.getName(),
-                false,
-                ClobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "clob" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testBlobWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                "blob",
-                Blob.class.getName(),
-                false,
-                BlobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "blob" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testStringWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                "materialized_clob",
-                String.class.getName(),
-                false,
-                MaterializedClobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "str" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testCharacterArrayWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                CharacterArrayClobType.class.getName(),
-                Character[].class.getName(),
-                false,
-                CharacterArrayClobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "characters" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testPrimitiveCharacterArrayWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                PrimitiveCharacterArrayClobType.class.getName(),
-                char[].class.getName(),
-                false,
-                PrimitiveCharacterArrayClobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "chars" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testByteArrayWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                WrappedMaterializedBlobType.class.getName(),
-                Byte[].class.getName(),
-                false,
-                WrappedMaterializedBlobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "bytes" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testPrimitiveByteArrayWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                StandardBasicTypes.MATERIALIZED_BLOB.getName(),
-                byte[].class.getName(),
-                false,
-                MaterializedBlobType.class,
-                false,
-                true
-        );
-        checkHibernateTypeDescriptor( expectedValue, "bytes2" );
-    }
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testSerializableWithLobAnnotation() {
-        ExpectedValue expectedValue = new ExpectedValue(
-                SerializableToBlobType.class.getName(),
-                Thing.class.getName(),
-                false,
-                SerializableToBlobType.class,
-                false,
-                false
-        );
-        checkHibernateTypeDescriptor( expectedValue, "serializable" );
-
-        assertTrue(
-                getTypeDescriptor( "serializable" ).getTypeParameters()
-                        .get( SerializableToBlobType.CLASS_NAME )
-                        .equals( Thing.class.getName() )
-        );
-    }
-
-
-    @Test
-    @Resources(annotatedClasses = Item.class)
-    public void testNoLobAttribute() {
-        assertNull( getTypeDescriptor( "noLob" ).getExplicitTypeName() );
-        assertTrue( getTypeDescriptor( "noLob" ).getTypeParameters().isEmpty() );
-
-    }
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MappedSuperclassTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MappedSuperclassTest.java
deleted file mode 100644
index a35651e39f..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MappedSuperclassTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.AttributeOverride;
-import javax.persistence.AttributeOverrides;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.MappedSuperclass;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.SingularAttributeBinding;
-import org.hibernate.metamodel.domain.NonEntity;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.testing.FailureExpected;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * Tests for {@link javax.persistence.MappedSuperclass} {@link javax.persistence.AttributeOverrides}
- * and {@link javax.persistence.AttributeOverride}.
- *
- * @author Hardy Ferentschik
- */
-@FailureExpected(jiraKey = "HHH-6447", message = "Work in progress")
-public class MappedSuperclassTest extends BaseAnnotationBindingTestCase {
-	@Test
-//	@Resources(annotatedClasses = { MyMappedSuperClass.class, MyEntity.class, MyMappedSuperClassBase.class })
-	public void testSimpleAttributeOverrideInMappedSuperclass() {
-		EntityBinding binding = getEntityBinding( MyEntity.class );
-		SingularAttributeBinding nameBinding = (SingularAttributeBinding) binding.locateAttributeBinding( "name" );
-		assertNotNull( "the name attribute should be bound to MyEntity", nameBinding );
-
-		Column column = (Column) nameBinding.getValue();
-		assertEquals( "Wrong column name", "MY_NAME", column.getColumnName().toString() );
-	}
-
-	@Test
-//	@Resources(annotatedClasses = { MyMappedSuperClass.class, MyEntity.class, MyMappedSuperClassBase.class })
-	public void testLastAttributeOverrideWins() {
-		EntityBinding binding = getEntityBinding( MyEntity.class );
-		SingularAttributeBinding fooBinding = (SingularAttributeBinding) binding.locateAttributeBinding( "foo" );
-		assertNotNull( "the foo attribute should be bound to MyEntity", fooBinding );
-
-		Column column = (Column) fooBinding.getValue();
-		assertEquals( "Wrong column name", "MY_FOO", column.getColumnName().toString() );
-	}
-
-	@Test
-//	@Resources(annotatedClasses = { SubclassOfNoEntity.class, NoEntity.class })
-	public void testNonEntityBaseClass() {
-		EntityBinding binding = getEntityBinding( SubclassOfNoEntity.class );
-		assertEquals( "Wrong entity name", SubclassOfNoEntity.class.getName(), binding.getEntity().getName() );
-		assertEquals( "Wrong entity name", NoEntity.class.getName(), binding.getEntity().getSuperType().getName() );
-		assertTrue( binding.getEntity().getSuperType() instanceof NonEntity );
-	}
-
-	@MappedSuperclass
-	class MyMappedSuperClassBase {
-		@Id
-		private int id;
-		String foo;
-	}
-
-	@MappedSuperclass
-	@AttributeOverride(name = "foo", column = @javax.persistence.Column(name = "SUPER_FOO"))
-	class MyMappedSuperClass extends MyMappedSuperClassBase {
-		String name;
-	}
-
-	@Entity
-	@AttributeOverrides( {
-			@AttributeOverride(name = "name", column = @javax.persistence.Column(name = "MY_NAME")),
-			@AttributeOverride(name = "foo", column = @javax.persistence.Column(name = "MY_FOO"))
-	})
-	class MyEntity extends MyMappedSuperClass {
-		private Long count;
-
-	}
-
-	class NoEntity {
-		String name;
-		int age;
-	}
-
-	@Entity
-	class SubclassOfNoEntity extends NoEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java
deleted file mode 100644
index 81b0a3b8b5..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Embeddable;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.MapsId;
-import javax.persistence.OneToMany;
-
-import org.junit.Test;
-
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.MappingException;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-/**
- * @author Hardy Ferentschik
- */
-public class MapsIdTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	public class Employee {
-		@Id
-		long empId;
-		String name;
-	}
-
-	@Embeddable
-	public class DependentId {
-		String name;
-		long empid; // corresponds to PK type of Employee
-	}
-
-	@Entity
-	public class Dependent {
-		@Id
-		// should be @EmbeddedId, but embedded id are not working atm
-				DependentId id;
-
-		@MapsId("empid")
-		@OneToMany
-		Employee emp; // maps the empid attribute of embedded id @ManyToOne Employee emp;
-	}
-
-	@Test
-	@Resources(annotatedClasses = DependentId.class)
-	public void testMapsIsOnOneToManyThrowsException() {
-		try {
-			sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-			sources.addAnnotatedClass( DependentId.class );
-			sources.addAnnotatedClass( Dependent.class );
-			sources.addAnnotatedClass( Employee.class );
-			sources.buildMetadata();
-			fail();
-		}
-		catch ( MappingException e ) {
-			assertTrue(
-					e.getMessage()
-							.startsWith( "@MapsId can only be specified on a many-to-one or one-to-one associations" )
-			);
-			assertEquals(
-					"Wrong error origin",
-					"org.hibernate.metamodel.source.annotations.entity.MapsIdTest$Dependent",
-					e.getOrigin().getName()
-			);
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/ProxyBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/ProxyBindingTest.java
deleted file mode 100644
index b27dea5399..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/ProxyBindingTest.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Proxy;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * Tests for {@code o.h.a.Cache}.
- *
- * @author Hardy Ferentschik
- */
-public class ProxyBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = ProxiedEntity.class)
-	public void testProxyNoAttributes() {
-		EntityBinding binding = getEntityBinding( ProxiedEntity.class );
-		assertTrue( "Wrong laziness", binding.isLazy() );
-		assertEquals( "Wrong proxy interface", ProxiedEntity.class, binding.getProxyInterfaceType().getValue() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = NoProxyEntity.class)
-	public void testNoProxy() {
-		EntityBinding binding = getEntityBinding( NoProxyEntity.class );
-		assertTrue( "Wrong laziness", binding.isLazy() );
-		assertEquals( "Wrong proxy interface", NoProxyEntity.class, binding.getProxyInterfaceType().getValue() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = ProxyDisabledEntity.class)
-	public void testProxyDisabled() {
-		EntityBinding binding = getEntityBinding( ProxyDisabledEntity.class );
-		assertFalse( "Wrong laziness", binding.isLazy() );
-		assertEquals( "Wrong proxy interface", null, binding.getProxyInterfaceType() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = ProxyInterfaceEntity.class)
-	public void testProxyInterface() {
-		EntityBinding binding = getEntityBinding( ProxyInterfaceEntity.class );
-		assertTrue( "Wrong laziness", binding.isLazy() );
-		assertEquals(
-				"Wrong proxy interface",
-				"org.hibernate.metamodel.source.annotations.entity.ProxyBindingTest$ProxyInterfaceEntity",
-				binding.getProxyInterfaceType().getValue().getName()
-		);
-	}
-
-	@Entity
-	class NoProxyEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Proxy
-	class ProxiedEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Proxy(lazy = false)
-	class ProxyDisabledEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Proxy(proxyClass = ProxyInterfaceEntity.class)
-	class ProxyInterfaceEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/QuotedIdentifierTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/QuotedIdentifierTest.java
deleted file mode 100644
index d139735248..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/QuotedIdentifierTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.Table;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.relational.Identifier;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Strong Liu
- */
-public class QuotedIdentifierTest extends BaseAnnotationBindingTestCase {
-	private final String ormPath = "org/hibernate/metamodel/source/annotations/xml/orm-quote-identifier.xml";
-
-	@Test
-	@Resources(annotatedClasses = { Item.class, Item2.class, Item3.class, Item4.class }, ormXmlPath = ormPath)
-	public void testDelimitedIdentifiers() {
-		EntityBinding item = getEntityBinding( Item.class );
-		assertIdentifierEquals( "`QuotedIdentifierTest$Item`", item );
-
-		item = getEntityBinding( Item2.class );
-		assertIdentifierEquals( "`TABLE_ITEM2`", item );
-
-		item = getEntityBinding( Item3.class );
-		assertIdentifierEquals( "`TABLE_ITEM3`", item );
-
-		// TODO: not sure about this -- revisit after metamodel merge
-//		item = getEntityBinding( Item4.class );
-//		assertIdentifierEquals( "`TABLE_ITEM4`", item );
-	}
-
-    //todo check if the column names are quoted
-
-	private void assertIdentifierEquals(String expected, EntityBinding realValue) {
-		org.hibernate.metamodel.relational.Table table = (org.hibernate.metamodel.relational.Table) realValue.getPrimaryTable();
-		assertEquals( Identifier.toIdentifier( expected ), table.getTableName() );
-	}
-
-	@Entity
-	private static class Item {
-		@Id
-		Long id;
-	}
-
-	@Entity
-	@Table(name = "TABLE_ITEM2")
-	private static class Item2 {
-		@Id
-		Long id;
-	}
-
-	@Entity
-	@Table(name = "`TABLE_ITEM3`")
-	private static class Item3 {
-		@Id
-		Long id;
-	}
-
-	@Entity
-	@Table(name = "\"TABLE_ITEM4\"")
-	private static class Item4 {
-		@Id
-		Long id;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/Resources.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/Resources.java
deleted file mode 100644
index f5f0fd3b9b..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/Resources.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.persistence.SharedCacheMode;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Allows to specify the annotated classes and xml configuration files for this test
- *
- * @author Hardy Ferentschik
- */
-@Target(METHOD)
-@Retention(RUNTIME)
-public @interface Resources {
-	Class<?>[] annotatedClasses() default { };
-
-	String ormXmlPath() default "";
-
-	SharedCacheMode cacheMode() default SharedCacheMode.ENABLE_SELECTIVE;
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/RowIdBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/RowIdBindingTests.java
deleted file mode 100644
index 7874ce1968..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/RowIdBindingTests.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.RowId;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-
-/**
- * Tests for {@code o.h.a.RowId}.
- *
- * @author Hardy Ferentschik
- */
-public class RowIdBindingTests extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = NoRowIdEntity.class)
-	public void testNoRowId() {
-		EntityBinding binding = getEntityBinding( NoRowIdEntity.class );
-		assertEquals( "Wrong row id", null, binding.getRowId() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = RowIdEntity.class)
-	public void testRowId() {
-		EntityBinding binding = getEntityBinding( RowIdEntity.class );
-		assertEquals( "Wrong row id", "rowid", binding.getRowId() );
-	}
-
-	@Entity
-	class NoRowIdEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@RowId("rowid")
-	class RowIdEntity {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SecondaryTableTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SecondaryTableTest.java
deleted file mode 100644
index 2ba3cd1168..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SecondaryTableTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.Iterator;
-import javax.persistence.Column;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.SecondaryTable;
-
-import org.junit.Test;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.relational.SimpleValue;
-import org.hibernate.metamodel.relational.Table;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-/**
- * @author Hardy Ferentschik
- */
-public class SecondaryTableTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	@SecondaryTable(name = "SECOND_TABLE")
-	class EntityWithSecondaryTable {
-		@Id
-		private long id;
-
-		@Column(table = "SECOND_TABLE")
-		private String name;
-	}
-
-	@Test
-	@Resources(annotatedClasses = EntityWithSecondaryTable.class)
-	public void testSecondaryTableExists() {
-		EntityBinding binding = getEntityBinding( EntityWithSecondaryTable.class );
-		Table table = (Table) binding.locateTable( "SECOND_TABLE" );
-		assertEquals( "The secondary table should exist", "SECOND_TABLE", table.getTableName().getName() );
-
-		Iterator<SimpleValue> valueIterator = table.values().iterator();
-		assertTrue( valueIterator.hasNext() );
-		org.hibernate.metamodel.relational.Column column = (org.hibernate.metamodel.relational.Column) valueIterator.next();
-		assertEquals( "Wrong column name", "name", column.getColumnName().getName() );
-		assertFalse( valueIterator.hasNext() );
-	}
-
-	@Test
-	@Resources(annotatedClasses = EntityWithSecondaryTable.class)
-	public void testRetrievingUnknownTable() {
-		EntityBinding binding = getEntityBinding( EntityWithSecondaryTable.class );
-		try {
-			binding.locateTable( "FOO" );
-			fail();
-		}
-		catch ( AssertionFailure e ) {
-			assertTrue( e.getMessage().startsWith( "Unable to find table" ) );
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SynchronizeBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SynchronizeBindingTest.java
deleted file mode 100644
index 04bf0ec8a9..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/SynchronizeBindingTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.Set;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Synchronize;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * Tests for {@code o.h.a.Synchronize}.
- *
- * @author Hardy Ferentschik
- */
-public class SynchronizeBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = TestEntityWithSynchronizeAnnotation.class)
-	public void testSynchronizeAnnotation() {
-		EntityBinding binding = getEntityBinding( TestEntityWithSynchronizeAnnotation.class );
-		Set<String> synchronizedTableNames = binding.getSynchronizedTableNames();
-		assertEquals( "Wrong number of synced tables", 2, synchronizedTableNames.size() );
-		assertTrue( "Table name missing", synchronizedTableNames.contains( "Foo" ) );
-		assertTrue( "Table name missing", synchronizedTableNames.contains( "Bar" ) );
-	}
-
-	@Test
-	@Resources(annotatedClasses = TestEntity.class)
-	public void testNoSynchronizeAnnotation() {
-		EntityBinding binding = getEntityBinding( TestEntity.class );
-		assertTrue( "There should be no cache binding", binding.getSynchronizedTableNames().size() == 0 );
-	}
-
-	@Entity
-	class TestEntity {
-		@Id
-		private int id;
-	}
-
-	@Entity
-	@Synchronize( { "Foo", "Bar" })
-	class TestEntityWithSynchronizeAnnotation {
-		@Id
-		private int id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java
deleted file mode 100644
index eb31eb09b9..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-import javax.persistence.Inheritance;
-import javax.persistence.Table;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.InheritanceType;
-
-import static junit.framework.Assert.assertEquals;
-
-/**
- * @author Hardy Ferentschik
- */
-public class TableNameTest extends BaseAnnotationBindingTestCase {
-	@Entity
-	class A {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	class B extends A {
-	}
-
-	@Test
-	@Resources(annotatedClasses = { A.class, B.class })
-	public void testSingleInheritanceDefaultTableName() {
-		EntityBinding binding = getEntityBinding( A.class );
-		assertEquals( "wrong inheritance type", InheritanceType.SINGLE_TABLE, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"TableNameTest$A",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-
-		binding = getEntityBinding( B.class );
-		assertEquals( "wrong inheritance type", InheritanceType.SINGLE_TABLE, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"TableNameTest$A",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-	}
-
-	@Entity
-	@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
-	@Table(name = "FOO")
-	class JoinedA {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	class JoinedB extends JoinedA {
-	}
-
-	@Test
-	@Resources(annotatedClasses = { JoinedA.class, JoinedB.class })
-	public void testJoinedSubclassDefaultTableName() {
-		EntityBinding binding = getEntityBinding( JoinedA.class );
-		assertEquals( "wrong inheritance type", InheritanceType.JOINED, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"FOO",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-
-		binding = getEntityBinding( JoinedB.class );
-		assertEquals( "wrong inheritance type", InheritanceType.JOINED, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"TableNameTest$JoinedB",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-	}
-
-
-	@Entity
-	@Inheritance(strategy = javax.persistence.InheritanceType.TABLE_PER_CLASS)
-	class TablePerClassA {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	class TablePerClassB extends TablePerClassA {
-	}
-
-	@Test
-	@Resources(annotatedClasses = { TablePerClassA.class, TablePerClassB.class })
-	public void testTablePerClassDefaultTableName() {
-		EntityBinding binding = getEntityBinding( TablePerClassA.class );
-		assertEquals( "wrong inheritance type", InheritanceType.TABLE_PER_CLASS, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"TableNameTest$TablePerClassA",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-
-		binding = getEntityBinding( TablePerClassB.class );
-		assertEquals( "wrong inheritance type", InheritanceType.TABLE_PER_CLASS, binding.getHierarchyDetails().getInheritanceType() );
-		assertEquals(
-				"wrong table name",
-				"TableNameTest$TablePerClassB",
-				( (org.hibernate.metamodel.relational.Table) binding.getPrimaryTable() ).getTableName().getName()
-		);
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TemporalBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TemporalBindingTest.java
deleted file mode 100644
index b85b6c9d32..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TemporalBindingTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.entity;
-
-import java.util.Date;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.Temporal;
-import javax.persistence.TemporalType;
-
-import org.junit.Test;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.metamodel.binding.AttributeBinding;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
-import org.hibernate.type.TimestampType;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Strong Liu
- */
-public class TemporalBindingTest extends BaseAnnotationBindingTestCase {
-    @Entity
-    class Item1 {
-        @Id
-        long id;
-        Date date;
-    }
-
-    @Test(expected = AnnotationException.class)
-    @Resources(annotatedClasses = TemporalBindingTest.Item1.class)
-    public void testNoTemporalAnnotationOnTemporalTypeAttribute() {
-        getEntityBinding( Item1.class );
-
-    }
-
-    @Entity
-    class Item2 {
-        @Id
-        long id;
-        @Temporal(TemporalType.TIMESTAMP)
-        Date date;
-    }
-
-    @Test
-    @Resources(annotatedClasses = TemporalBindingTest.Item2.class)
-    public void testTemporalTypeAttribute() {
-        EntityBinding binding = getEntityBinding( Item2.class );
-        AttributeBinding attributeBinding = binding.locateAttributeBinding( "date" );
-        HibernateTypeDescriptor descriptor = attributeBinding.getHibernateTypeDescriptor();
-        assertEquals( "timestamp", descriptor.getExplicitTypeName() );
-        assertEquals( Date.class.getName(), descriptor.getJavaTypeName() );
-        assertNotNull( descriptor.getResolvedTypeMapping() );
-        assertEquals( TimestampType.class, descriptor.getResolvedTypeMapping().getClass() );
-        assertNotNull( descriptor.getTypeParameters() );
-        assertTrue( descriptor.getTypeParameters().isEmpty() );
-    }
-
-    @Entity
-    class Item3 {
-        @Id
-        @Temporal(TemporalType.TIMESTAMP)
-        Date date;
-    }
-
-    @Test
-    @Resources(annotatedClasses = TemporalBindingTest.Item3.class)
-    public void testTemporalTypeAsId() {
-        EntityBinding binding = getEntityBinding( Item3.class );
-        AttributeBinding attributeBinding = binding.locateAttributeBinding( "date" );
-        HibernateTypeDescriptor descriptor = attributeBinding.getHibernateTypeDescriptor();
-        assertEquals( "timestamp", descriptor.getExplicitTypeName() );
-        assertEquals( Date.class.getName(), descriptor.getJavaTypeName() );
-        assertNotNull( descriptor.getResolvedTypeMapping() );
-        assertEquals( TimestampType.class, descriptor.getResolvedTypeMapping().getClass() );
-        assertNotNull( descriptor.getTypeParameters() );
-        assertTrue( descriptor.getTypeParameters().isEmpty() );
-    }
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintBindingTest.java
deleted file mode 100644
index bccbc2ecc7..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/UniqueConstraintBindingTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.Table;
-import javax.persistence.UniqueConstraint;
-
-import org.junit.Test;
-
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.relational.Column;
-import org.hibernate.metamodel.relational.TableSpecification;
-import org.hibernate.metamodel.relational.UniqueKey;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * test for {@link javax.persistence.UniqueConstraint}
- *
- * @author Strong Liu
- */
-public class UniqueConstraintBindingTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = TableWithUniqueConstraint.class)
-	public void testTableUniqueConstraints() {
-		EntityBinding binding = getEntityBinding( TableWithUniqueConstraint.class );
-		TableSpecification table = binding.getPrimaryTable();
-		Iterable<UniqueKey> uniqueKeyIterable = table.getUniqueKeys();
-		assertNotNull( uniqueKeyIterable );
-		int i = 0;
-		for ( UniqueKey key : uniqueKeyIterable ) {
-			i++;
-			assertEquals( "u1", key.getName() );
-			assertTrue( table == key.getTable() );
-			assertNotNull( key.getColumns() );
-			int j = 0;
-			for ( Column column : key.getColumns() ) {
-				j++;
-			}
-			assertEquals( "There should be two columns in the unique constraint", 2, j );
-		}
-		assertEquals( "There should only be one unique constraint", 1, i );
-	}
-
-	@Entity
-	@Table(uniqueConstraints = { @UniqueConstraint(name = "u1", columnNames = { "name", "age" }) })
-	class TableWithUniqueConstraint {
-		@Id
-		int id;
-		String name;
-		int age;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/WhereClauseTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/WhereClauseTest.java
deleted file mode 100644
index 6b3702e754..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/WhereClauseTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.hibernate.metamodel.source.annotations.entity;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Where;
-import org.hibernate.metamodel.binding.EntityBinding;
-
-import static junit.framework.Assert.assertEquals;
-
-/**
- * @author Hardy Ferentschik
- */
-public class WhereClauseTest extends BaseAnnotationBindingTestCase {
-	@Test
-	@Resources(annotatedClasses = Foo.class)
-	public void testWhereFilter() {
-		EntityBinding binding = getEntityBinding( Foo.class );
-		assertEquals( "Wrong where filter", "1=1", binding.getWhereFilter() );
-	}
-
-	@Entity
-	@Where(clause = "1=1")
-	class Foo {
-		@Id
-		private long id;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
deleted file mode 100644
index a686f1b03e..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import java.util.Iterator;
-
-import org.jboss.jandex.Index;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.hibernate.MappingException;
-import org.hibernate.annotations.FetchMode;
-import org.hibernate.annotations.FetchProfile;
-import org.hibernate.annotations.FetchProfiles;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static junit.framework.Assert.fail;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Hardy Ferentschik
- */
-public class FetchProfileBinderTest extends BaseUnitTestCase {
-
-	private StandardServiceRegistryImpl serviceRegistry;
-	private ClassLoaderService service;
-	private MetadataImpl meta;
-
-	@Before
-	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().build();
-		service = serviceRegistry.getService( ClassLoaderService.class );
-		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
-	}
-
-	@After
-	public void tearDown() {
-		serviceRegistry.destroy();
-	}
-
-	@Test
-	public void testSingleFetchProfile() {
-		@FetchProfile(name = "foo", fetchOverrides = {
-				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.JOIN)
-		})
-		class Foo {
-		}
-		Index index = JandexHelper.indexForClass( service, Foo.class );
-
-		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
-
-		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
-		assertTrue( mappedFetchProfiles.hasNext() );
-		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
-		assertEquals( "Wrong fetch profile name", "foo", profile.getName() );
-		org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
-		assertEquals( "Wrong association name", "bar", fetch.getAssociation() );
-		assertEquals( "Wrong association type", Foo.class.getName(), fetch.getEntity() );
-	}
-
-	@Test
-	public void testFetchProfiles() {
-		Index index = JandexHelper.indexForClass( service, FooBar.class );
-		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
-
-		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
-		assertTrue( mappedFetchProfiles.hasNext() );
-		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
-		assertProfiles( profile );
-
-		assertTrue( mappedFetchProfiles.hasNext() );
-		profile = mappedFetchProfiles.next();
-		assertProfiles( profile );
-	}
-
-	private void assertProfiles(org.hibernate.metamodel.binding.FetchProfile profile) {
-		if ( profile.getName().equals( "foobar" ) ) {
-			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
-			assertEquals( "Wrong association name", "foobar", fetch.getAssociation() );
-			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
-		}
-		else if ( profile.getName().equals( "fubar" ) ) {
-			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
-			assertEquals( "Wrong association name", "fubar", fetch.getAssociation() );
-			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
-		}
-		else {
-			fail( "Wrong fetch name:" + profile.getName() );
-		}
-	}
-
-	@Test(expected = MappingException.class)
-	public void testNonJoinFetchThrowsException() {
-		@FetchProfile(name = "foo", fetchOverrides = {
-				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.SELECT)
-		})
-		class Foo {
-		}
-		Index index = JandexHelper.indexForClass( service, Foo.class );
-
-		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
-	}
-
-	@FetchProfiles( {
-			@FetchProfile(name = "foobar", fetchOverrides = {
-					@FetchProfile.FetchOverride(entity = FooBar.class, association = "foobar", mode = FetchMode.JOIN)
-			}),
-			@FetchProfile(name = "fubar", fetchOverrides = {
-					@FetchProfile.FetchOverride(entity = FooBar.class, association = "fubar", mode = FetchMode.JOIN)
-			})
-	})
-	class FooBar {
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
deleted file mode 100644
index dc27113eb1..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.global;
-
-import javax.persistence.NamedNativeQuery;
-
-import org.jboss.jandex.Index;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.cfg.NotYetImplementedException;
-import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
-import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
-import org.hibernate.engine.spi.NamedSQLQueryDefinition;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * @author Hardy Ferentschik
- */
-public class QueryBinderTest extends BaseUnitTestCase {
-
-	private StandardServiceRegistryImpl serviceRegistry;
-	private ClassLoaderService service;
-	private MetadataImpl meta;
-
-	@Before
-	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().build();
-		service = serviceRegistry.getService( ClassLoaderService.class );
-		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
-	}
-
-	@After
-	public void tearDown() {
-		serviceRegistry.destroy();
-	}
-
-	@Test(expected = NotYetImplementedException.class)
-	public void testNoResultClass() {
-		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO")
-		class Foo {
-		}
-		Index index = JandexHelper.indexForClass( service, Foo.class );
-		QueryBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
-	}
-
-	@Test
-	public void testResultClass() {
-		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO", resultClass = Foo.class)
-		class Foo {
-		}
-		Index index = JandexHelper.indexForClass( service, Foo.class );
-		QueryBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
-
-		NamedSQLQueryDefinition namedQuery = meta.getNamedNativeQuery( "fubar" );
-		assertNotNull( namedQuery );
-		NativeSQLQueryReturn queryReturns[] = namedQuery.getQueryReturns();
-		assertTrue( "Wrong number of returns", queryReturns.length == 1 );
-		assertTrue( "Wrong query return type", queryReturns[0] instanceof NativeSQLQueryRootReturn );
-		NativeSQLQueryRootReturn rootReturn = (NativeSQLQueryRootReturn) queryReturns[0];
-		assertEquals( "Wrong result class", Foo.class.getName(), rootReturn.getReturnEntityName() );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
deleted file mode 100644
index fd57f6d3fe..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import java.util.Set;
-import javax.persistence.AccessType;
-
-import org.jboss.jandex.Index;
-import org.junit.After;
-import org.junit.Before;
-
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
-import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
-import org.hibernate.metamodel.source.annotations.EntityHierarchyBuilder;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableHierarchy;
-import org.hibernate.metamodel.source.binder.EntityHierarchy;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-/**
- * @author Hardy Ferentschik
- */
-public abstract class BaseAnnotationIndexTestCase extends BaseUnitTestCase {
-	private MetadataImpl meta;
-
-	@Before
-	public void setUp() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		meta = (MetadataImpl) sources.buildMetadata();
-	}
-
-	@After
-	public void tearDown() {
-	}
-
-	public Set<EntityHierarchy> createEntityHierarchies(Class<?>... clazz) {
-		Index index = JandexHelper.indexForClass(
-				meta.getServiceRegistry().getService( ClassLoaderService.class ),
-				clazz
-		);
-		AnnotationBindingContext context = new AnnotationBindingContextImpl( meta, index );
-		return EntityHierarchyBuilder.createEntityHierarchies( context );
-	}
-
-	public EmbeddableHierarchy createEmbeddableHierarchy(AccessType accessType, Class<?>... configuredClasses) {
-		Index index = JandexHelper.indexForClass(
-				meta.getServiceRegistry().getService( ClassLoaderService.class ),
-				configuredClasses
-		);
-		AnnotationBindingContext context = new AnnotationBindingContextImpl( meta, index );
-		return EmbeddableHierarchy.createEmbeddableHierarchy( configuredClasses[0], "", accessType, context );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EmbeddableHierarchyTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EmbeddableHierarchyTest.java
deleted file mode 100644
index deae20dbd7..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EmbeddableHierarchyTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import java.util.Iterator;
-import javax.persistence.AccessType;
-import javax.persistence.Embeddable;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableHierarchy;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static org.junit.Assert.assertFalse;
-
-/**
- * @author Hardy Ferentschik
- */
-@Ignore("fails on openjdk")
-public class EmbeddableHierarchyTest extends BaseAnnotationIndexTestCase {
-	@Test
-    @Ignore("HHH-6606 ignore for now")
-	public void testEmbeddableHierarchy() {
-		@Embeddable
-		class A {
-			String foo;
-		}
-
-		class B extends A {
-		}
-
-		@Embeddable
-		class C extends B {
-			String bar;
-		}
-
-		EmbeddableHierarchy hierarchy = createEmbeddableHierarchy(
-				AccessType.FIELD,
-				C.class,
-				A.class,
-				B.class
-		);
-		Iterator<EmbeddableClass> iter = hierarchy.iterator();
-		ClassInfo info = iter.next().getClassInfo();
-		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
-		info = iter.next().getClassInfo();
-		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
-		info = iter.next().getClassInfo();
-		assertEquals( "wrong class", DotName.createSimple( C.class.getName() ), info.name() );
-		assertFalse( iter.hasNext() );
-		assertNotNull( hierarchy );
-	}
-
-	@Test(expected = AssertionFailure.class)
-	public void testEmbeddableHierarchyWithNotAnnotatedEntity() {
-		class NonAnnotatedEmbeddable {
-		}
-
-		createEmbeddableHierarchy( AccessType.FIELD, NonAnnotatedEmbeddable.class );
-	}
-
-	@Entity
-	public class Foo {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	public class A {
-		@Id
-		@GeneratedValue
-		private int id;
-	}
-
-	@Entity
-	public class B extends A {
-		private String name;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java
deleted file mode 100644
index 202a0acbdd..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import java.util.Iterator;
-import java.util.Set;
-import javax.persistence.Embeddable;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-import javax.persistence.Inheritance;
-import javax.persistence.MappedSuperclass;
-
-import org.junit.Test;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.binder.EntityHierarchy;
-import org.hibernate.metamodel.source.binder.RootEntitySource;
-import org.hibernate.metamodel.source.binder.SubclassEntitySource;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * @author Hardy Ferentschik
- */
-public class EntityHierarchyTest extends BaseAnnotationIndexTestCase {
-
-	@Test
-	public void testSingleEntity() {
-		@Entity
-		class Foo {
-			@Id
-			@GeneratedValue
-			private int id;
-		}
-
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies( Foo.class );
-		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-
-		EntityHierarchy hierarchy = hierarchies.iterator().next();
-		assertEquals(
-				"wrong entity name",
-				Foo.class.getName(),
-				hierarchy.getRootEntitySource().getEntityName()
-		);
-	}
-
-	@Test
-	public void testSimpleInheritance() {
-		@Entity
-		class A {
-			@Id
-			@GeneratedValue
-			private int id;
-		}
-
-		@Entity
-		class B extends A {
-			private String name;
-		}
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies( B.class, A.class );
-		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-
-		EntityHierarchy hierarchy = hierarchies.iterator().next();
-		RootEntitySource rootSource = hierarchy.getRootEntitySource();
-		assertEquals(
-				"wrong entity name",
-				A.class.getName(),
-				rootSource.getEntityName()
-		);
-
-		Iterator<SubclassEntitySource> iter = rootSource.subclassEntitySources().iterator();
-		assertTrue( "There should be a subclass entity source", iter.hasNext() );
-		assertEquals( "wrong class", B.class.getName(), iter.next().getEntityName() );
-		assertFalse( "There should be no more subclass entity sources", iter.hasNext() );
-	}
-
-	@Test
-	public void testMultipleHierarchies() {
-		@Entity
-		class Foo {
-			@Id
-			@GeneratedValue
-			private int id;
-		}
-
-		@Entity
-		class A {
-			@Id
-			@GeneratedValue
-			private int id;
-		}
-
-		@Entity
-		class B extends A {
-			private String name;
-		}
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies( B.class, Foo.class, A.class );
-		assertEquals( "There should be only one hierarchy", 2, hierarchies.size() );
-	}
-
-	@Test
-	public void testMappedSuperClass() {
-		@MappedSuperclass
-		class MappedSuperClass {
-			@Id
-			@GeneratedValue
-			private int id;
-		}
-
-		class UnmappedSubClass extends MappedSuperClass {
-			private String unmappedProperty;
-		}
-
-		@Entity
-		class MappedSubClass extends UnmappedSubClass {
-			private String mappedProperty;
-		}
-
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies(
-				MappedSubClass.class,
-				MappedSuperClass.class,
-				UnmappedSubClass.class
-		);
-		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-
-		EntityHierarchy hierarchy = hierarchies.iterator().next();
-		assertEquals(
-				"wrong entity name",
-				MappedSubClass.class.getName(),
-				hierarchy.getRootEntitySource().getEntityName()
-		);
-	}
-
-	@Test(expected = AnnotationException.class)
-	public void testEntityAndMappedSuperClassAnnotations() {
-		@Entity
-		@MappedSuperclass
-		class EntityAndMappedSuperClass {
-		}
-
-		createEntityHierarchies( EntityAndMappedSuperClass.class );
-	}
-
-	@Test(expected = AnnotationException.class)
-	public void testEntityAndEmbeddableAnnotations() {
-		@Entity
-		@Embeddable
-		class EntityAndEmbeddable {
-		}
-
-		createEntityHierarchies( EntityAndEmbeddable.class );
-	}
-
-	@Test(expected = AnnotationException.class)
-	public void testNoIdAnnotation() {
-		@Entity
-		class A {
-			String id;
-		}
-
-		@Entity
-		class B extends A {
-		}
-
-		createEntityHierarchies( B.class, A.class );
-	}
-
-	@Test
-	public void testDefaultInheritanceStrategy() {
-		@Entity
-		class A {
-			@Id
-			String id;
-		}
-
-		@Entity
-		class B extends A {
-		}
-
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies( B.class, A.class );
-		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-
-		EntityHierarchy hierarchy = hierarchies.iterator().next();
-		assertEquals(
-				"wrong entity name",
-				A.class.getName(),
-				hierarchy.getRootEntitySource().getEntityName()
-		);
-		assertEquals( "Wrong inheritance type", InheritanceType.SINGLE_TABLE, hierarchy.getHierarchyInheritanceType() );
-	}
-
-	@Test
-	public void testExplicitInheritanceStrategy() {
-		@MappedSuperclass
-		class MappedSuperClass {
-
-		}
-
-		@Entity
-		@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
-		class A extends MappedSuperClass {
-			@Id
-			String id;
-		}
-
-		@Entity
-		class B extends A {
-		}
-
-		Set<EntityHierarchy> hierarchies = createEntityHierarchies(
-				B.class,
-				MappedSuperClass.class,
-				A.class
-		);
-
-		EntityHierarchy hierarchy = hierarchies.iterator().next();
-		assertEquals(
-				"wrong entity name",
-				A.class.getName(),
-				hierarchy.getRootEntitySource().getEntityName()
-		);
-		assertEquals( "Wrong inheritance type", InheritanceType.JOINED, hierarchy.getHierarchyInheritanceType() );
-	}
-
-	@Test(expected = AnnotationException.class)
-	public void testMultipleConflictingInheritanceDefinitions() {
-
-		@Entity
-		@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
-		class A {
-			String id;
-		}
-
-		@Entity
-		@Inheritance(strategy = javax.persistence.InheritanceType.TABLE_PER_CLASS)
-		class B extends A {
-		}
-
-		createEntityHierarchies( B.class, A.class );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
deleted file mode 100644
index 4d29116a91..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-import javax.persistence.ManyToOne;
-import javax.persistence.MappedSuperclass;
-
-import org.junit.Test;
-
-/**
- * @author Hardy Ferentschik
- */
-public class GenericTypeDiscoveryTest extends BaseAnnotationIndexTestCase {
-
-	@Test
-	public void testGenericClassHierarchy() {
-//		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies(
-//				Paper.class,
-//				Stuff.class,
-//				Item.class,
-//				PricedStuff.class
-//		);
-//		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-//
-//		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
-//		ConfiguredClass configuredClass = iter.next();
-//		ClassInfo info = configuredClass.getClassInfo();
-//		assertEquals( "wrong class", DotName.createSimple( Stuff.class.getName() ), info.name() );
-//		MappedAttribute property = configuredClass.getMappedAttribute( "value" );
-//		assertEquals( Price.class, property.getJavaType() );
-//
-//		assertTrue( iter.hasNext() );
-//		configuredClass = iter.next();
-//		info = configuredClass.getClassInfo();
-//		assertEquals( "wrong class", DotName.createSimple( PricedStuff.class.getName() ), info.name() );
-//		assertFalse(
-//				"PricedStuff should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext()
-//		);
-//
-//		assertTrue( iter.hasNext() );
-//		configuredClass = iter.next();
-//		info = configuredClass.getClassInfo();
-//		assertEquals( "wrong class", DotName.createSimple( Item.class.getName() ), info.name() );
-//		// properties are alphabetically ordered!
-//		property = configuredClass.getMappedAttribute( "owner" );
-//		assertEquals( SomeGuy.class, property.getJavaType() );
-//		property = configuredClass.getMappedAttribute( "type" );
-//		assertEquals( PaperType.class, property.getJavaType() );
-//
-//		assertTrue( iter.hasNext() );
-//		configuredClass = iter.next();
-//		info = configuredClass.getClassInfo();
-//		assertEquals( "wrong class", DotName.createSimple( Paper.class.getName() ), info.name() );
-//		assertFalse( "Paper should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext() );
-//
-//		assertFalse( iter.hasNext() );
-	}
-
-	@Test
-	public void testUnresolvedType() {
-//		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( UnresolvedType.class );
-//		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-	}
-
-	@MappedSuperclass
-	public class Stuff<Value> {
-		private Value value;
-
-		@ManyToOne
-		public Value getValue() {
-			return value;
-		}
-
-		public void setValue(Value value) {
-			this.value = value;
-		}
-	}
-
-	@MappedSuperclass
-	public class PricedStuff extends Stuff<Price> {
-	}
-
-	@MappedSuperclass
-	public class Item<Type, Owner> extends PricedStuff {
-		private Integer id;
-		private String name;
-		private Type type;
-		private Owner owner;
-
-		@Id
-		@GeneratedValue
-		public Integer getId() {
-			return id;
-		}
-
-		public void setId(Integer id) {
-			this.id = id;
-		}
-
-		public String getName() {
-			return name;
-		}
-
-		public void setName(String name) {
-			this.name = name;
-		}
-
-		@ManyToOne
-		public Type getType() {
-			return type;
-		}
-
-		public void setType(Type type) {
-			this.type = type;
-		}
-
-		@ManyToOne
-		public Owner getOwner() {
-			return owner;
-		}
-
-		public void setOwner(Owner owner) {
-			this.owner = owner;
-		}
-	}
-
-	@Entity
-	public class Paper extends Item<PaperType, SomeGuy> {
-	}
-
-	@Entity
-	public class PaperType {
-		private Integer id;
-		private String name;
-
-		@Id
-		@GeneratedValue
-		public Integer getId() {
-			return id;
-		}
-
-		public void setId(Integer id) {
-			this.id = id;
-		}
-
-		public String getName() {
-			return name;
-		}
-
-		public void setName(String name) {
-			this.name = name;
-		}
-
-	}
-
-	@Entity
-	public class Price {
-		private Integer id;
-		private Double amount;
-		private String currency;
-
-		@Id
-		@GeneratedValue
-		public Integer getId() {
-			return id;
-		}
-
-		public void setId(Integer id) {
-			this.id = id;
-		}
-
-		public Double getAmount() {
-			return amount;
-		}
-
-		public void setAmount(Double amount) {
-			this.amount = amount;
-		}
-
-		public String getCurrency() {
-			return currency;
-		}
-
-		public void setCurrency(String currency) {
-			this.currency = currency;
-		}
-	}
-
-	@Entity
-	public class SomeGuy {
-		private Integer id;
-
-		@Id
-		@GeneratedValue
-		public Integer getId() {
-			return id;
-		}
-
-		public void setId(Integer id) {
-			this.id = id;
-		}
-	}
-
-	@Entity
-	public class UnresolvedType<T> {
-
-		private Integer id;
-		private T state;
-
-		@Id
-		@GeneratedValue
-		public Integer getId() {
-			return id;
-		}
-
-		public void setId(Integer id) {
-			this.id = id;
-		}
-
-		//@Type(type = "org.hibernate.test.annotations.generics.StateType")
-		public T getState() {
-			return state;
-		}
-
-		public void setState(T state) {
-			this.state = state;
-		}
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
deleted file mode 100644
index 10edc54a44..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.List;
-import java.util.Map;
-import javax.persistence.AttributeConverter;
-import javax.persistence.AttributeOverride;
-import javax.persistence.Basic;
-import javax.persistence.Column;
-import javax.persistence.Converter;
-import javax.persistence.Entity;
-import javax.persistence.LockModeType;
-import javax.persistence.NamedQuery;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.hibernate.AssertionFailure;
-import org.hibernate.HibernateException;
-import org.hibernate.annotations.NamedNativeQuery;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-
-import static junit.framework.Assert.assertTrue;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-
-/**
- * Tests for the helper class {@link JandexHelper}.
- *
- * @author Hardy Ferentschik
- */
-public class JandexHelperTest extends BaseUnitTestCase {
-	private StandardServiceRegistryImpl serviceRegistry;
-	private ClassLoaderService classLoaderService;
-
-	@Before
-	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().build();
-		classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
-	}
-
-	@After
-	public void tearDown() {
-		serviceRegistry.destroy();
-	}
-
-	@Test
-	public void testGetMemberAnnotations() {
-		class Foo {
-			@Column
-			@Basic
-			private String bar;
-			private String fubar;
-		}
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-
-		ClassInfo classInfo = index.getClassByName( DotName.createSimple( Foo.class.getName() ) );
-		Map<DotName, List<AnnotationInstance>> memberAnnotations = JandexHelper.getMemberAnnotations(
-				classInfo, "bar"
-		);
-		assertTrue(
-				"property bar should defines @Column annotation",
-				memberAnnotations.containsKey( DotName.createSimple( Column.class.getName() ) )
-		);
-		assertTrue(
-				"property bar should defines @Basic annotation",
-				memberAnnotations.containsKey( DotName.createSimple( Basic.class.getName() ) )
-		);
-
-		memberAnnotations = JandexHelper.getMemberAnnotations( classInfo, "fubar" );
-		assertTrue( "there should be no annotations in fubar", memberAnnotations.isEmpty() );
-	}
-
-	@Test
-	public void testGettingNestedAnnotation() {
-		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		// try to retrieve the name
-		String name = JandexHelper.getValue( annotationInstance, "name", String.class );
-		assertEquals( "Wrong nested annotation", "foo", name );
-
-		// try to retrieve the nested column annotation instance
-		AnnotationInstance columnAnnotationInstance = JandexHelper.getValue(
-				annotationInstance,
-				"column",
-				AnnotationInstance.class
-		);
-		assertNotNull( columnAnnotationInstance );
-		assertEquals(
-				"Wrong nested annotation",
-				"javax.persistence.Column",
-				columnAnnotationInstance.name().toString()
-		);
-	}
-
-	@Test(expected = AssertionFailure.class)
-	public void testTryingToRetrieveWrongType() {
-		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		JandexHelper.getValue( annotationInstance, "name", Float.class );
-	}
-
-	@Test
-	public void testRetrieveDefaultEnumElement() {
-		@NamedQuery(name = "foo", query = "fubar")
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		LockModeType lockMode = JandexHelper.getEnumValue( annotationInstance, "lockMode", LockModeType.class );
-		assertEquals( "Wrong lock mode", LockModeType.NONE, lockMode );
-	}
-
-	@Test
-	public void testRetrieveExplicitEnumElement() {
-		@NamedQuery(name = "foo", query = "bar", lockMode = LockModeType.OPTIMISTIC)
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		LockModeType lockMode = JandexHelper.getEnumValue( annotationInstance, "lockMode", LockModeType.class );
-		assertEquals( "Wrong lock mode", LockModeType.OPTIMISTIC, lockMode );
-	}
-
-	@Test
-	public void testRetrieveStringArray() {
-		class Foo {
-			@org.hibernate.annotations.Index(name = "index", columnNames = { "a", "b", "c" })
-			private String foo;
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.INDEX );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		String[] columnNames = JandexHelper.getValue( annotationInstance, "columnNames", String[].class );
-		Assert.assertTrue( columnNames.length == 3 );
-	}
-
-	@Test(expected = AssertionFailure.class)
-	public void testRetrieveClassParameterAsClass() {
-		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		JandexHelper.getValue( annotationInstance, "resultClass", Class.class );
-	}
-
-	@Test
-	public void testRetrieveClassParameterAsString() {
-		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		String fqcn = JandexHelper.getValue( annotationInstance, "resultClass", String.class );
-		assertEquals( "Wrong class names", Foo.class.getName(), fqcn );
-	}
-
-	@Test
-	public void testRetrieveUnknownParameter() {
-		@Entity
-		class Foo {
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ENTITY );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		try {
-			JandexHelper.getValue( annotationInstance, "foo", String.class );
-			fail();
-		}
-		catch ( AssertionFailure e ) {
-			assertTrue(
-					e.getMessage()
-							.startsWith( "The annotation javax.persistence.Entity does not define a parameter 'foo'" )
-			);
-		}
-	}
-
-
-	@Test
-	public void testPrimitiveAnnotationAttributeTypes() {
-		@Converter( autoApply = true )
-		class MyConverter implements AttributeConverter<URL,String> {
-
-			@Override
-			public String convertToDatabaseColumn(URL attribute) {
-				return attribute.toExternalForm();
-			}
-
-			@Override
-			public URL convertToEntityAttribute(String dbData) {
-				try {
-					return new URL( dbData );
-				}
-				catch (MalformedURLException e) {
-					throw new HibernateException( "Could not convert string [" + dbData + "] to url", e );
-				}
-			}
-		}
-
-		Index index = JandexHelper.indexForClass( classLoaderService, MyConverter.class );
-		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.CONVERTER );
-		assertTrue( annotationInstances.size() == 1 );
-		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
-
-		boolean value = JandexHelper.getValue( annotationInstance, "autoApply", boolean.class );
-		Assert.assertTrue( value );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
deleted file mode 100644
index 2d2753440d..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.util;
-
-import javax.persistence.Id;
-
-import org.junit.Test;
-
-import org.hibernate.annotations.Parameter;
-import org.hibernate.annotations.Type;
-
-/**
- * @author Hardy Ferentschik
- */
-public class TypeDiscoveryTest extends BaseAnnotationIndexTestCase {
-
-	@Test
-	public void testImplicitAndExplicitType() {
-//		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( Entity.class );
-//		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
-//
-//		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
-//		ConfiguredClass configuredClass = iter.next();
-//
-//		MappedAttribute property = configuredClass.getMappedAttribute( "id" );
-//		assertEquals( "Unexpected property type", int.class, property.getJavaType() );
-//
-//		property = configuredClass.getMappedAttribute( "string" );
-//		assertEquals( "Unexpected property type", String.class, property.getJavaType() );
-//
-//		property = configuredClass.getMappedAttribute( "customString" );
-//		assertEquals( "Unexpected property type", "my.custom.Type", property.getExplicitHibernateTypeName() );
-//
-//		Map<String, String> typeParameters = property.getExplicitHibernateTypeParameters();
-//		assertEquals( "There should be a type parameter", "bar", typeParameters.get( "foo" ) );
-	}
-
-	@javax.persistence.Entity
-	class Entity {
-		@Id
-		private int id;
-		private String string;
-		@Type(type = "my.custom.Type", parameters = { @Parameter(name = "foo", value = "bar") })
-		private String customString;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Father.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Father.java
deleted file mode 100644
index 76f829b9d7..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Father.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml;
-
-/**
- * @author Hardy Ferentschik
- */
-public class Father {
-	private int id;
-
-	private String name;
-
-	public int getId() {
-		return id;
-	}
-
-	public void setId(int id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
deleted file mode 100644
index e31cea2ea4..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml;
-
-import static junit.framework.Assert.assertNotNull;
-
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.junit.Test;
-
-/**
- * @author Hardy Ferentschik
- */
-public class OrmXmlParserTests extends BaseUnitTestCase {
-	@Test
-	public void testSimpleOrmVersion2() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-father.xml" );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-
-		EntityBinding binding = metadata.getEntityBinding( Father.class.getName() );
-		assertNotNull( binding );
-	}
-
-	@Test
-	public void testSimpleOrmVersion1() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-star.xml" );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-
-		EntityBinding binding = metadata.getEntityBinding( Star.class.getName() );
-		assertNotNull( binding );
-	}
-
-	@Test(expected = MappingException.class)
-	public void testInvalidOrmXmlThrowsException() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-invalid.xml" );
-		sources.buildMetadata();
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Star.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Star.java
deleted file mode 100644
index 5131a0a319..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/Star.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml;
-
-import javax.persistence.Entity;
-
-/**
- * @author Hardy Ferentschik
- */
-@Entity
-public class Star {
-	private int id;
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
deleted file mode 100644
index 4b9f23a999..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import javax.xml.bind.JAXBException;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.jboss.jandex.Indexer;
-
-import org.hibernate.AnnotationException;
-import org.hibernate.HibernateException;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
-import org.hibernate.service.ServiceRegistry;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.testing.ServiceRegistryBuilder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * @author Strong Liu
- */
-public abstract class AbstractMockerTest {
-	private static final String ORM1_MAPPING_XSD = "org/hibernate/jpa/orm_1_0.xsd";
-	private static final String ORM2_MAPPING_XSD = "org/hibernate/jpa/orm_2_0.xsd";
-
-	private IndexBuilder indexBuilder;
-	private Index index;
-	private ServiceRegistry serviceRegistry;
-	protected String packagePrefix = getClass().getPackage().getName().replace( '.', '/' ) + '/';
-
-	protected IndexBuilder getIndexBuilder() {
-		if ( indexBuilder == null ) {
-			indexBuilder = new IndexBuilder( getIndex(), getServiceRegistry() );
-		}
-		return indexBuilder;
-
-	}
-
-	protected EntityMappingsMocker getEntityMappingsMocker(String... mappingFiles) {
-		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
-		List<JaxbEntityMappings> xmlEntityMappingsList = new ArrayList<JaxbEntityMappings>();
-		for ( String fileName : mappingFiles ) {
-			JaxbEntityMappings entityMappings;
-			try {
-				entityMappings = XmlHelper.unmarshallXml(
-						packagePrefix + fileName, ORM2_MAPPING_XSD, JaxbEntityMappings.class, classLoaderService
-				).getRoot();
-			}
-			catch ( JAXBException orm2Exception ) {
-				// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility
-				try {
-					entityMappings = XmlHelper.unmarshallXml(
-							packagePrefix + fileName, ORM1_MAPPING_XSD, JaxbEntityMappings.class, classLoaderService
-					).getRoot();
-				}
-				catch ( JAXBException orm1Exception ) {
-					throw new AnnotationException( "Unable to parse xml configuration.", orm1Exception );
-				}
-			}
-			xmlEntityMappingsList.add( entityMappings );
-		}
-		return new EntityMappingsMocker( xmlEntityMappingsList, getIndex(), getServiceRegistry() );
-	}
-
-	protected Index getIndex() {
-		if ( index == null ) {
-			Indexer indexer = new Indexer();
-			for ( Class<?> clazz : getAnnotatedClasses() ) {
-				indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
-			}
-
-			// add package-info from the configured packages
-			for ( String packageName : getAnnotatedPackages() ) {
-				indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
-			}
-			index = indexer.complete();
-		}
-		return index;
-
-	}
-
-	protected Index getMockedIndex(String ormFileName) {
-		EntityMappingsMocker mocker = getEntityMappingsMocker( ormFileName );
-		return mocker.mockNewIndex();
-	}
-
-	private void indexClass(Indexer indexer, String className) {
-		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
-		InputStream stream = classLoaderService.locateResourceStream( className );
-		try {
-			indexer.index( stream );
-		}
-		catch ( IOException e ) {
-			throw new HibernateException( "Unable to open input stream for class " + className, e );
-		}
-	}
-
-	protected Class[] getAnnotatedClasses() {
-		return new Class[0];
-	}
-
-	protected String[] getAnnotatedPackages() {
-		return new String[0];
-	}
-
-	protected ServiceRegistry getServiceRegistry() {
-		if ( serviceRegistry == null ) {
-			serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry();
-		}
-		return serviceRegistry;
-	}
-
-	protected void assertHasNoAnnotation(Index index, DotName className, DotName annName) {
-		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
-		if ( annotationInstanceList != null ) {
-			if ( !annotationInstanceList.isEmpty() ) {
-				fail( className + " has Annotation " + annName );
-			}
-		}
-	}
-	protected void assertHasAnnotation(Index index,  DotName annName) {
-		assertHasAnnotation( index, null, annName, 1 );
-	}
-	protected void assertHasAnnotation(Index index, DotName className, DotName annName) {
-		assertHasAnnotation( index, className, annName, 1 );
-	}
-
-	protected void assertHasAnnotation(Index index, DotName className, DotName annName, int size) {
-		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
-		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
-			fail( "Expected annotation " + annName + " size is " + size + ", but no one can be found in Index" );
-		}
-		assertEquals(
-				"Expected annotation " + annName + " size is " + size + ", but it actually is " + annotationInstanceList
-						.size(), size, annotationInstanceList.size()
-		);
-	}
-
-	protected void assertStringAnnotationValue(String expected, AnnotationValue annotationValue) {
-		if ( annotationValue == null ) {
-			fail( "Annotation Value is null." );
-		}
-		assertEquals( expected, annotationValue.asString() );
-	}
-
-	protected void assertAnnotationValue(Index index, DotName className, DotName annName, AnnotationValueChecker checker) {
-		assertAnnotationValue( index, className, annName, 1, checker );
-	}
-
-	protected void assertAnnotationValue(Index index, DotName className, DotName annName, int size, AnnotationValueChecker checker) {
-		assertHasAnnotation( index, className, annName, size );
-		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index,className,annName );
-		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
-			checker.check( annotationInstance );
-		}
-	}
-
-	private List<AnnotationInstance> getAnnotationInstances(Index index, DotName className, DotName annName) {
-		if ( className != null ) {
-			ClassInfo classInfo = index.getClassByName( className );
-			if ( classInfo == null ) {
-				fail( "Can't find " + className + " from Index" );
-			}
-			if ( classInfo.annotations() == null ) {
-				fail( classInfo + " doesn't have any annotations defined" );
-			}
-			return classInfo.annotations().get( annName );
-		}
-		else {
-			return index.getAnnotations( annName );
-		}
-	}
-
-	static interface AnnotationValueChecker {
-		void check(AnnotationInstance annotationInstance);
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java
deleted file mode 100644
index 0a2868d18d..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.List;
-import javax.persistence.CascadeType;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-import javax.persistence.OneToMany;
-import javax.persistence.SequenceGenerator;
-
-/**
- * @author Strong Liu
- */
-@Entity
-public class Author {
-	private Long id;
-	private String name;
-	private List<Book> books = new ArrayList<Book>();
-
-	@Id
-	@GeneratedValue(generator = "SEQ_GEN")
-	@SequenceGenerator(name = "SEQ_GEN", initialValue = 123)
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	@OneToMany(mappedBy = "author",cascade = CascadeType.MERGE)
-	public List<Book> getBooks() {
-		return books;
-	}
-
-	public void setBooks(List<Book> books) {
-		this.books = books;
-	}
-
-
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java
deleted file mode 100644
index f53b4f2314..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.junit.Test;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbGeneratedValue;
-import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Strong Liu
- */
-public class BasicMockerTest extends AbstractMockerTest {
-	@Test
-	public void testEntity() {
-		JaxbEntity entity = createEntity();
-		IndexBuilder indexBuilder = getIndexBuilder();
-		EntityMocker entityMocker = new EntityMocker( indexBuilder, entity, new EntityMappingsMocker.Default() );
-		entityMocker.preProcess();
-		entityMocker.process();
-
-		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
-		assertEquals( 1, index.getKnownClasses().size() );
-		DotName itemName = DotName.createSimple( Item.class.getName() );
-		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
-		assertHasAnnotation( index, itemName, JPADotNames.ID );
-		assertHasAnnotation( index, itemName, JPADotNames.GENERATED_VALUE );
-	}
-
-	@Test
-	public void testEntityWithEntityMappingsConfiguration() {
-		JaxbEntity entity = new JaxbEntity();
-		entity.setName( "Item" );
-		entity.setClazz( "Item" );
-		IndexBuilder indexBuilder = getIndexBuilder();
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setPackageName( getClass().getPackage().getName() );
-		defaults.setSchema( "HIBERNATE_SCHEMA" );
-		defaults.setCatalog( "HIBERNATE_CATALOG" );
-		EntityMocker entityMocker = new EntityMocker( indexBuilder, entity, defaults );
-		entityMocker.preProcess();
-		entityMocker.process();
-
-		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
-		assertEquals( 1, index.getKnownClasses().size() );
-		DotName itemName = DotName.createSimple( Item.class.getName() );
-		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
-		assertHasAnnotation( index, itemName, JPADotNames.TABLE );
-		assertAnnotationValue(
-				index, itemName, JPADotNames.TABLE, new AnnotationValueChecker() {
-					@Override
-					public void check(AnnotationInstance annotationInstance) {
-						AnnotationValue schemaValue = annotationInstance.value( "schema" );
-						AnnotationValue catalogValue = annotationInstance.value( "catalog" );
-						assertStringAnnotationValue( "HIBERNATE_SCHEMA", schemaValue );
-						assertStringAnnotationValue( "HIBERNATE_CATALOG", catalogValue );
-					}
-				}
-		);
-
-	}
-
-
-	private JaxbEntity createEntity() {
-		JaxbEntity entity = new JaxbEntity();
-		entity.setName( "Item" );
-		entity.setClazz( Item.class.getName() );
-		JaxbAttributes attributes = new JaxbAttributes();
-		JaxbId id = new JaxbId();
-		id.setName( "id" );
-		id.setGeneratedValue( new JaxbGeneratedValue() );
-		attributes.getId().add( id );
-		entity.setAttributes( attributes );
-		return entity;
-	}
-
-
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java
deleted file mode 100644
index ccfebfa64e..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import javax.persistence.AttributeOverride;
-import javax.persistence.CascadeType;
-import javax.persistence.Column;
-import javax.persistence.ElementCollection;
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
-import javax.persistence.ManyToOne;
-import javax.persistence.TableGenerator;
-import javax.persistence.Temporal;
-import javax.persistence.TemporalType;
-import javax.persistence.Version;
-
-/**
- * @author Strong Liu
- */
-@Entity
-@TableGenerator(name = "TABLE_GEN", catalog = "ANNOTATION_CATALOG", schema = "ANNOTATION_SCHEMA")
-public class Book {
-	@Id
-	@GeneratedValue(generator = "TABLE_GEN")
-	private Long id;
-	@Temporal(TemporalType.TIMESTAMP)
-	private Date publishDate;
-	@ManyToOne(cascade = CascadeType.DETACH)
-	private Author author;
-	@ElementCollection
-	@AttributeOverride(name = "title", column = @Column(name = "TOC_TITLE"))
-	private List<Topic> topics = new ArrayList<Topic>();
-
-	public List<Topic> getTopics() {
-		return topics;
-	}
-
-	public void setTopics(List<Topic> topics) {
-		this.topics = topics;
-	}
-
-	@Version
-	private Long version;
-
-	public Author getAuthor() {
-		return author;
-	}
-
-	public void setAuthor(Author author) {
-		this.author = author;
-	}
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public Date getPublishDate() {
-		return publishDate;
-	}
-
-	public void setPublishDate(Date publishDate) {
-		this.publishDate = publishDate;
-	}
-
-	public Long getVersion() {
-		return version;
-	}
-
-	public void setVersion(Long version) {
-		this.version = version;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
deleted file mode 100644
index 2a5e913c73..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.persistence.CascadeType;
-import javax.persistence.Entity;
-import javax.persistence.Id;
-import javax.persistence.ManyToOne;
-import javax.persistence.OneToMany;
-import javax.persistence.SecondaryTable;
-import javax.persistence.SecondaryTables;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.junit.Test;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Strong Liu
- */
-public class DefaultConfigurationHelperTest extends AbstractMockerTest {
-	@Test
-	public void applyNullDefaultToEntity() {
-		JaxbEntity entity = new JaxbEntity();
-		entity.setClazz( "Entity" );
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, null );
-		assertNull( entity.getTable() );
-		assertEquals( "Entity", entity.getClazz() );
-	}
-
-	@Test
-	public void applyDefaultToEntity() {
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setPackageName( "org.test" );
-		defaults.setSchema( "schema" );
-		defaults.setMetadataComplete( true );
-		JaxbEntity entity = new JaxbEntity();
-		entity.setClazz( "Entity" );
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, defaults );
-		assertNotNull( entity.getTable() );
-		assertNull( entity.getTable().getSchema() );
-		assertNull( entity.getTable().getCatalog() );
-		assertTrue( entity.isMetadataComplete() );
-		assertEquals( "org.test.Entity", entity.getClazz() );
-		DefaultConfigurationHelper.INSTANCE
-				.applyDefaults( new SchemaAware.TableSchemaAware( entity.getTable() ), defaults );
-		assertEquals( "schema", entity.getTable().getSchema() );
-		assertNull( entity.getTable().getCatalog() );
-	}
-
-	@Test
-	public void testDefaultCascadePersist() {
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setCascadePersist( true );
-		Index index = getIndex();
-		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
-		annotations.putAll( index.getClassByName( DotName.createSimple( Parent.class.getName() ) ).annotations() );
-		assertEquals( 4, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
-
-		assertEquals( 4, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-		AnnotationInstance oneToMany = annotations.get( JPADotNames.ONE_TO_MANY ).get( 0 );
-		String[] cascadeTypes = oneToMany.value( "cascade" ).asEnumArray();
-		assertArrayEquals( new String[] { "ALL", "DETACH", "PERSIST" }, cascadeTypes );
-		AnnotationInstance manyToOne = annotations.get( JPADotNames.MANY_TO_ONE ).get( 0 );
-		cascadeTypes = manyToOne.value( "cascade" ).asEnumArray();
-		assertArrayEquals( new String[] { "PERSIST" }, cascadeTypes );
-
-		annotations.clear();
-		annotations.putAll( index.getClassByName( DotName.createSimple( Child.class.getName() ) ).annotations() );
-		assertEquals( 3, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
-
-		assertEquals( 3, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-
-		manyToOne = annotations.get( JPADotNames.MANY_TO_ONE ).get( 0 );
-		cascadeTypes = manyToOne.value( "cascade" ).asEnumArray();
-		assertArrayEquals( new String[] { "PERSIST", "ALL", "DETACH" }, cascadeTypes );
-	}
-
-	@Test
-	public void testDefaultSchemaToAnnotationInstance() {
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setSchema( "hib_schema" );
-		defaults.setCatalog( "hib_catalog" );
-		Index index = getIndex();
-		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
-		annotations.putAll( index.getClassByName( DotName.createSimple( Parent.class.getName() ) ).annotations() );
-		assertEquals( 4, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
-		assertEquals( 5, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
-		assertEquals( 1, annotations.get( JPADotNames.TABLE ).size() );
-		AnnotationInstance table = annotations.get( JPADotNames.TABLE ).get( 0 );
-		assertEquals( "hib_schema", table.value( "schema" ).asString() );
-		assertEquals( "hib_catalog", table.value( "catalog" ).asString() );
-
-		annotations.clear();
-		annotations.putAll( index.getClassByName( DotName.createSimple( Name.class.getName() ) ).annotations() );
-		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
-		assertEquals( 1, annotations.size() );
-		assertEquals( 1, annotations.get( JPADotNames.SECONDARY_TABLES ).size() );
-		AnnotationInstance[] secondaryTables = annotations.get( JPADotNames.SECONDARY_TABLES )
-				.get( 0 )
-				.value()
-				.asNestedArray();
-		assertEquals( 2, secondaryTables.length );
-		AnnotationInstance secondaryTable = secondaryTables[0];
-		String name = secondaryTable.value( "name" ).asString();
-		if ( name.equals( "sec1" ) ) {
-			assertSt1( secondaryTable );
-			assertSt2( secondaryTables[1] );
-		}
-		else {
-			assertSt1( secondaryTables[1] );
-			assertSt2( secondaryTable );
-		}
-
-
-	}
-
-	private void assertSt1(AnnotationInstance secondaryTable) {
-		assertEquals( "hib_schema", secondaryTable.value( "schema" ).asString() );
-		assertEquals( "sec1_catalog", secondaryTable.value( "catalog" ).asString() );
-	}
-
-	private void assertSt2(AnnotationInstance secondaryTable) {
-		assertEquals( "sec2_schema", secondaryTable.value( "schema" ).asString() );
-		assertEquals( "hib_catalog", secondaryTable.value( "catalog" ).asString() );
-	}
-
-	@Override
-	protected Class[] getAnnotatedClasses() {
-		return new Class[] { Parent.class, Child.class, Name.class };
-	}
-
-	@SecondaryTables( {
-			@SecondaryTable(name = "sec1", catalog = "sec1_catalog"),
-			@SecondaryTable(name = "sec2", schema = "sec2_schema")
-	})
-	class Name {
-	}
-
-	@Entity
-	class Parent {
-		@Id
-		long id;
-		@OneToMany(cascade = { CascadeType.ALL, CascadeType.DETACH, CascadeType.PERSIST })
-		Set<Child> children = new HashSet<Child>();
-		@ManyToOne
-		Parent parent;
-
-
-	}
-
-	@Entity
-	class Child {
-		@Id
-		long id;
-		@ManyToOne(cascade = { CascadeType.ALL, CascadeType.DETACH })
-		Parent parent;
-
-	}
-
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java
deleted file mode 100644
index 392e5430ff..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.junit.Test;
-
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Strong Liu
- */
-public class EntityListenerTest extends AbstractMockerTest {
-	@Test
-	public void basicEntityListenerMockTest() {
-		Index index = getMockedIndex( "listener.xml" );
-		DotName itemName = DotName.createSimple( Item.class.getName() );
-		DotName itemListenerName = DotName.createSimple( ItemListener.class.getName() );
-		ClassInfo itemClassInfo = index.getClassByName( itemName );
-		assertEquals( 2, itemClassInfo.annotations().size() );
-		//entity
-		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
-		assertHasAnnotation( index, itemName, JPADotNames.ENTITY_LISTENERS );
-		//listener
-		assertHasAnnotation( index, itemListenerName, JPADotNames.PRE_PERSIST );
-		assertHasAnnotation( index, itemListenerName, JPADotNames.POST_PERSIST );
-		//assert global configurations
-		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS );
-		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_ACCESS );
-		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
-		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_PRE_PERSIST );
-		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_POST_PERSIST );
-
-
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java
deleted file mode 100644
index 52d1189241..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import org.junit.Test;
-
-/**
- * @author Strong Liu
- */
-public class IndexBuilderTest extends AbstractMockerTest {
-	@Test
-	public void test() {
-		IndexBuilder builder = getIndexBuilder();
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java
deleted file mode 100644
index fa5be30fc4..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-/**
- * @author Strong Liu
- */
-public class Item {
-	private Long id;
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java
deleted file mode 100644
index dc1852b0b6..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-/**
- * @author Strong Liu
- */
-public class ItemListener {
-	public void prePersist(){}
-	public void postPersist(){}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java
deleted file mode 100644
index 2f796486de..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.util.List;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
-import org.jboss.jandex.Index;
-import org.junit.Test;
-
-import org.hibernate.internal.jaxb.mapping.orm.JaxbEntity;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-/**
- * @author Strong Liu
- */
-public class OverrideTest extends AbstractMockerTest {
-	@Override
-	protected Class[] getAnnotatedClasses() {
-		return new Class[] {
-				Author.class,
-				Book.class,
-				Topic.class
-		};
-	}
-
-	@Test
-	public void testPersistenceUnitMetadataMetadataComplete() {
-		JaxbEntity author = new JaxbEntity();
-		author.setClazz( Author.class.getName() );
-		IndexBuilder indexBuilder = getIndexBuilder();
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setMetadataComplete( true );
-		EntityMocker entityMocker = new EntityMocker( indexBuilder, author, defaults );
-		entityMocker.preProcess();
-		entityMocker.process();
-		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
-		DotName className = DotName.createSimple( Author.class.getName() );
-		ClassInfo classInfo = index.getClassByName( className );
-		assertEquals( 1, classInfo.annotations().size() );
-		assertHasAnnotation( index, className, JPADotNames.ENTITY );
-	}
-
-	@Test
-	public void testEntityMetadataComplete() {
-		Index index = getMockedIndex( "entity-metadata-complete.xml" );
-		DotName authorName = DotName.createSimple( Author.class.getName() );
-		ClassInfo authorClassInfo = index.getClassByName( authorName );
-		assertHasAnnotation( index, authorName, JPADotNames.ENTITY );
-		assertHasAnnotation( index, authorName, JPADotNames.ID_CLASS );
-		assertEquals( 2, authorClassInfo.annotations().size() );
-		DotName bookName = DotName.createSimple( Book.class.getName() );
-		assertHasAnnotation( index, bookName, JPADotNames.ENTITY );
-	}
-
-	@Test
-	public void testOverrideToMappedSuperClass() {
-		Index index = getMockedIndex( "override-to-mappedsuperclass.xml" );
-		index.printAnnotations();
-		DotName authorName = DotName.createSimple( Author.class.getName() );
-		assertHasAnnotation( index, authorName, JPADotNames.ENTITY );
-		assertHasNoAnnotation( index, authorName, JPADotNames.TABLE );
-		DotName bookName = DotName.createSimple( Book.class.getName() );
-		assertHasAnnotation( index, bookName, JPADotNames.MAPPED_SUPERCLASS );
-		assertHasNoAnnotation( index, bookName, JPADotNames.TABLE );
-
-	}
-
-	@Test
-	public void testPersistenceUnitDefaultsCascadePersistInAnnotation() {
-		JaxbEntity author = new JaxbEntity();
-		author.setClazz( Author.class.getName() );
-		IndexBuilder indexBuilder = getIndexBuilder();
-		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
-		defaults.setCascadePersist( true );
-		EntityMocker entityMocker = new EntityMocker( indexBuilder, author, defaults );
-		entityMocker.preProcess();
-		entityMocker.process();
-		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
-		DotName className = DotName.createSimple( Author.class.getName() );
-		assertAnnotationValue(
-				index, className, JPADotNames.ONE_TO_MANY, new CascadeAnnotationValueChecker( "PERSIST", "MERGE" )
-		);
-	}
-
-
-	@Test
-	public void testPersistenceUnitDefaultsCascadePersistInXML() {
-		Index index = getMockedIndex( "AttributeOverride.xml" );
-		DotName className = DotName.createSimple( Author.class.getName() );
-		assertAnnotationValue(
-				index,
-				className,
-				JPADotNames.ONE_TO_MANY,
-				new CascadeAnnotationValueChecker( new String[] { "PERSIST", "ALL" } )
-		);
-	}
-
-	protected class CascadeAnnotationValueChecker implements AnnotationValueChecker {
-		private String[] expected = new String[0];
-
-		public CascadeAnnotationValueChecker(String... expected) {
-			this.expected = expected;
-		}
-
-		@Override
-		public void check(AnnotationInstance annotationInstance) {
-			AnnotationValue cascadeValue = annotationInstance.value( "cascade" );
-			assertNotNull(
-					"Cascade is null in @OneToMany, but should be added a Cascade persist", cascadeValue
-			);
-			String[] enumArray = cascadeValue.asEnumArray();
-			assertEquals( expected.length, enumArray.length );
-			assertArrayEquals( expected, enumArray );
-		}
-	}
-
-	/**
-	 * Entity has a @AttributeOverride on property topic
-	 * and this property also has a <attribute-override> in orm.xml but with different name
-	 * by jpa override rules, this two attribute-override should be merged into one @AttributeOverrides
-	 */
-	@Test
-	public void testAttributeOverride() {
-		Index index = getMockedIndex( "AttributeOverride.xml" );
-		DotName className = DotName.createSimple( Book.class.getName() );
-		index.printAnnotations();
-		assertHasNoAnnotation(
-				index,
-				className,
-				JPADotNames.ATTRIBUTE_OVERRIDE
-		);
-		assertAnnotationValue(
-				index,
-				className,
-				JPADotNames.ATTRIBUTE_OVERRIDES, new AnnotationValueChecker() {
-					@Override
-					public void check(AnnotationInstance annotationInstance) {
-						AnnotationValue value = annotationInstance.value();
-						assertNotNull( value );
-						AnnotationInstance[] annotationInstances = value.asNestedArray();
-						assertEquals( 2, annotationInstances.length );
-						AnnotationInstance ai = annotationInstances[0];
-						String name = ai.value( "name" ).asString();
-						AnnotationValue columnValue = ai.value( "column" ).asNested().value( "name" );
-						if ( name.equals( "title" ) ) {
-							assertEquals( "TOC_TITLE", columnValue.asString() );
-
-						}
-						else if ( name.equals( "summary" ) ) {
-							assertEquals( "TOPIC_SUMMARY", columnValue.asString() );
-						}
-						else {
-							fail( "AttributeOverride's name is " + name + ", should be either 'title' or 'summary'" );
-						}
-					}
-				}
-		);
-	}
-
-	@Test
-	public void testSchemaInPersistenceMetadata() {
-		Index index = getMockedIndex( "default-schema.xml" );
-		index.printAnnotations();
-		//Global Configuration should be accessed like this, not from ClassInfo
-		List<AnnotationInstance> annotationInstanceList = index.getAnnotations( JPADotNames.TABLE_GENERATOR );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 1, annotationInstanceList.size() );
-		AnnotationInstance generator = annotationInstanceList.get( 0 );
-		assertEquals( "TABLE_GEN", generator.value( "name" ).asString() );
-		assertEquals( "ANNOTATION_CATALOG", generator.value( "catalog" ).asString() );
-		assertEquals( "ANNOTATION_SCHEMA", generator.value( "schema" ).asString() );
-
-		annotationInstanceList = index.getAnnotations( JPADotNames.SEQUENCE_GENERATOR );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 1, annotationInstanceList.size() );
-		generator = annotationInstanceList.get( 0 );
-		assertEquals( "SEQ_GEN", generator.value( "name" ).asString() );
-		assertEquals( "XML_CATALOG", generator.value( "catalog" ).asString() );
-		assertEquals( "XML_SCHEMA", generator.value( "schema" ).asString() );
-		assertEquals( 123, generator.value( "initialValue" ).asInt() );
-		//Book and Author and Topic are all not defined @Table
-		//but orm xml defines default schema and catalog in persistence-unit-metadata
-		//so, we have to mock @Table for entities, Book and Author but not Topic which is a Embeddable
-		annotationInstanceList = index.getAnnotations( JPADotNames.TABLE );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 2, annotationInstanceList.size() );
-		for ( AnnotationInstance table : annotationInstanceList ) {
-			assertEquals( "XML_CATALOG", table.value( "catalog" ).asString() );
-			assertEquals( "XML_SCHEMA", table.value( "schema" ).asString() );
-		}
-
-	}
-
-	@Test
-	public void testSchemaInEntityMapping() {
-		Index index = getMockedIndex( "default-schema2.xml" );
-		index.printAnnotations();
-		//Global Configuration should be accessed like this, not from ClassInfo
-		List<AnnotationInstance> annotationInstanceList = index.getAnnotations( JPADotNames.TABLE_GENERATOR );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 1, annotationInstanceList.size() );
-		AnnotationInstance generator = annotationInstanceList.get( 0 );
-		assertEquals( "TABLE_GEN", generator.value( "name" ).asString() );
-		assertEquals( "ANNOTATION_CATALOG", generator.value( "catalog" ).asString() );
-		assertEquals( "ANNOTATION_SCHEMA", generator.value( "schema" ).asString() );
-
-		annotationInstanceList = index.getAnnotations( JPADotNames.SEQUENCE_GENERATOR );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 1, annotationInstanceList.size() );
-		generator = annotationInstanceList.get( 0 );
-		assertEquals( "SEQ_GEN", generator.value( "name" ).asString() );
-		assertNull( generator.value( "catalog" ) );
-		assertNull( generator.value( "schema" ) );
-		assertEquals( 123, generator.value( "initialValue" ).asInt() );
-
-		annotationInstanceList = index.getAnnotations( JPADotNames.TABLE );
-		assertNotNull( annotationInstanceList );
-		assertEquals( 0, annotationInstanceList.size() );
-
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
deleted file mode 100644
index 0086b8975e..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import javax.persistence.AccessType;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.Index;
-import org.junit.Test;
-
-import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Strong Liu
- */
-public class PersistenceMetadataMockerTest extends AbstractMockerTest {
-	@Test
-	public void testPersistenceMetadata() {
-		Index index = getMockedIndex( "persistence-metadata.xml" );
-		assertHasAnnotation( index, null, PseudoJpaDotNames.DEFAULT_ACCESS, 1 );
-		assertAnnotationValue(index,null, PseudoJpaDotNames.DEFAULT_ACCESS,new AnnotationValueChecker(){
-			@Override
-			public void check(AnnotationInstance annotationInstance) {
-			assertEquals( AccessType.FIELD.toString(), annotationInstance.value().asEnum());
-			}
-		});
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java
deleted file mode 100644
index cf74904525..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc..
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import javax.persistence.Embeddable;
-
-/**
- * @author Strong Liu
- */
-@Embeddable
-public class Topic {
-	private String title;
-	private String summary;
-	private int position;
-
-	public int getPosition() {
-		return position;
-	}
-
-	public void setPosition(int position) {
-		this.position = position;
-	}
-
-	public String getSummary() {
-		return summary;
-	}
-
-	public void setSummary(String summary) {
-		this.summary = summary;
-	}
-
-	public String getTitle() {
-		return title;
-	}
-
-	public void setTitle(String title) {
-		this.title = title;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
deleted file mode 100644
index e7cc270ade..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.annotations.xml.mocker;
-
-import java.io.InputStream;
-import java.net.URL;
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBElement;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-
-import org.jboss.logging.Logger;
-import org.xml.sax.SAXException;
-
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.jaxb.JaxbRoot;
-import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-
-/**
- * @author Hardy Ferentschik
- */
-public class XmlHelper {
-    private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, XmlHelper.class.getName() );
-
-    private XmlHelper() {
-    }
-
-    public static <T> JaxbRoot<T> unmarshallXml(String fileName, String schemaName, Class<T> clazz, ClassLoaderService classLoaderService)
-            throws JAXBException {
-        Schema schema = getMappingSchema( schemaName, classLoaderService );
-        InputStream in = classLoaderService.locateResourceStream( fileName );
-        JAXBContext jc = JAXBContext.newInstance( clazz );
-        Unmarshaller unmarshaller = jc.createUnmarshaller();
-        unmarshaller.setSchema( schema );
-        StreamSource stream = new StreamSource( in );
-        JAXBElement<T> elem = unmarshaller.unmarshal( stream, clazz );
-        Origin origin = new Origin( null, fileName );
-        return new JaxbRoot<T>( elem.getValue(), origin );
-    }
-
-    private static Schema getMappingSchema(String schemaVersion, ClassLoaderService classLoaderService) {
-        URL schemaUrl = classLoaderService.locateResource( schemaVersion );
-        SchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );
-        Schema schema = null;
-        try {
-            schema = sf.newSchema( schemaUrl );
-        }
-        catch ( SAXException e ) {
-            LOG.debugf( "Unable to create schema for %s: %s", schemaVersion, e.getMessage() );
-        }
-        return schema;
-    }
-}
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/Foo.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/Foo.java
deleted file mode 100644
index f06395ca3d..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/Foo.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-/**
- * @author Hardy Ferentschik
- */
-public class Foo {
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
deleted file mode 100644
index 828719c709..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-import java.util.Iterator;
-
-import org.hibernate.HibernateException;
-import org.hibernate.SessionFactory;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.Metadata;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.junit.Test;
-
-/**
- * @author Hardy Ferentschik
- */
-public class MetadataImplTest extends BaseUnitTestCase {
-
-	@Test(expected = IllegalArgumentException.class)
-	public void testAddingNullClass() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addClass( null );
-		sources.buildMetadata();
-	}
-
-	@Test(expected = IllegalArgumentException.class)
-	public void testAddingNullPackageName() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addPackage( null );
-		sources.buildMetadata();
-	}
-
-	@Test(expected = HibernateException.class)
-	public void testAddingNonExistingPackageName() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addPackage( "not.a.package" );
-		sources.buildMetadata();
-	}
-
-	@Test
-	public void testAddingPackageName() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addPackage( "org.hibernate.metamodel.source.internal" );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-
-		assertFetchProfile( metadata );
-	}
-
-	@Test
-	public void testAddingPackageNameWithTrailingDot() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addPackage( "org.hibernate.metamodel.source.internal." );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-
-		assertFetchProfile( metadata );
-	}
-
-	@Test
-	public void testGettingSessionFactoryBuilder() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		Metadata metadata = sources.buildMetadata();
-
-		SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();
-		assertNotNull( sessionFactoryBuilder );
-		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
-
-		SessionFactory sessionFactory = metadata.buildSessionFactory();
-		assertNotNull( sessionFactory );
-		sessionFactory.close();
-	}
-
-	private void assertFetchProfile(MetadataImpl metadata) {
-		Iterator<FetchProfile> profiles = metadata.getFetchProfiles().iterator();
-		assertTrue( profiles.hasNext() );
-		FetchProfile profile = profiles.next();
-		assertEquals( "wrong profile name", "package-configured-profile", profile.getName() );
-		assertFalse( profiles.hasNext() );
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
deleted file mode 100644
index 43e87b6fb5..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import java.io.Serializable;
-import java.util.Iterator;
-
-import org.junit.Test;
-
-import org.hibernate.CallbackException;
-import org.hibernate.EmptyInterceptor;
-import org.hibernate.EntityMode;
-import org.hibernate.Interceptor;
-import org.hibernate.ObjectNotFoundException;
-import org.hibernate.SessionFactory;
-import org.hibernate.Transaction;
-import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.proxy.EntityNotFoundDelegate;
-
-import org.hibernate.testing.junit4.BaseUnitTestCase;
-import org.hibernate.type.Type;
-
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertSame;
-import static junit.framework.Assert.assertTrue;
-
-/**
- * @author Gail Badner
- */
-public class SessionFactoryBuilderImplTest extends BaseUnitTestCase {
-
-	@Test
-	public void testGettingSessionFactoryBuilder() {
-		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
-		assertNotNull( sessionFactoryBuilder );
-		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
-	}
-
-	@Test
-	public void testBuildSessionFactoryWithDefaultOptions() {
-		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
-		SessionFactory sessionFactory = sessionFactoryBuilder.build();
-		assertSame( EmptyInterceptor.INSTANCE, sessionFactory.getSessionFactoryOptions().getInterceptor() );
-		assertTrue( EntityNotFoundDelegate.class.isInstance(
-				sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate()
-		) );
-		sessionFactory.close();
-	}
-
-	@Test
-	public void testBuildSessionFactoryWithUpdatedOptions() {
-		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
-		Interceptor interceptor = new AnInterceptor();
-		EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
-			@Override
-			public void handleEntityNotFound(String entityName, Serializable id) {
-				throw new ObjectNotFoundException( id, entityName );
-			}
-		};
-		sessionFactoryBuilder.with( interceptor );
-		sessionFactoryBuilder.with( entityNotFoundDelegate );
-		SessionFactory sessionFactory = sessionFactoryBuilder.build();
-		assertSame( interceptor, sessionFactory.getSessionFactoryOptions().getInterceptor() );
-		assertSame( entityNotFoundDelegate, sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate() );
-		sessionFactory.close();
-	}
-
-	private SessionFactoryBuilder getSessionFactoryBuilder() {
-		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().build() );
-		sources.addAnnotatedClass( SimpleEntity.class );
-		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
-		return  metadata.getSessionFactoryBuilder();
-	}
-
-	private static class AnInterceptor implements Interceptor {
-		private static final Interceptor INSTANCE = EmptyInterceptor.INSTANCE;
-
-		@Override
-		public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
-				throws CallbackException {
-			return INSTANCE.onLoad( entity, id, state, propertyNames, types );
-		}
-
-		@Override
-		public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types)
-				throws CallbackException {
-			return INSTANCE.onFlushDirty( entity, id, currentState, previousState, propertyNames, types );
-		}
-
-		@Override
-		public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
-				throws CallbackException {
-			return INSTANCE.onSave( entity, id, state, propertyNames, types );
-		}
-
-		@Override
-		public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
-				throws CallbackException {
-			INSTANCE.onDelete( entity, id, state, propertyNames, types );
-		}
-
-		@Override
-		public void onCollectionRecreate(Object collection, Serializable key) throws CallbackException {
-			INSTANCE.onCollectionRecreate( collection, key );
-		}
-
-		@Override
-		public void onCollectionRemove(Object collection, Serializable key) throws CallbackException {
-			INSTANCE.onCollectionRemove( collection, key );
-		}
-
-		@Override
-		public void onCollectionUpdate(Object collection, Serializable key) throws CallbackException {
-			INSTANCE.onCollectionUpdate( collection, key );
-		}
-
-		@Override
-		public void preFlush(Iterator entities) throws CallbackException {
-			INSTANCE.preFlush( entities );
-		}
-
-		@Override
-		public void postFlush(Iterator entities) throws CallbackException {
-			INSTANCE.postFlush( entities );
-		}
-
-		@Override
-		public Boolean isTransient(Object entity) {
-			return INSTANCE.isTransient( entity );
-		}
-
-		@Override
-		public int[] findDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) {
-			return INSTANCE.findDirty( entity, id, currentState, previousState, propertyNames, types );
-		}
-
-		@Override
-		public Object instantiate(String entityName, EntityMode entityMode, Serializable id)
-				throws CallbackException {
-			return INSTANCE.instantiate( entityName, entityMode, id );
-		}
-
-		@Override
-		public String getEntityName(Object object) throws CallbackException {
-			return INSTANCE.getEntityName( object );
-		}
-
-		@Override
-		public Object getEntity(String entityName, Serializable id) throws CallbackException {
-			return INSTANCE.getEntity( entityName, id );
-		}
-
-		@Override
-		public void afterTransactionBegin(Transaction tx) {
-			INSTANCE.afterTransactionBegin( tx );
-		}
-
-		@Override
-		public void beforeTransactionCompletion(Transaction tx) {
-			INSTANCE.beforeTransactionCompletion( tx );
-		}
-
-		@Override
-		public void afterTransactionCompletion(Transaction tx) {
-			INSTANCE.afterTransactionCompletion( tx );
-		}
-
-		@Override
-		public String onPrepareStatement(String sql) {
-			return INSTANCE.onPrepareStatement( sql );
-		}
-	}
-}
-
-
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SimpleEntity.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SimpleEntity.java
deleted file mode 100644
index c6f1c5c763..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SimpleEntity.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.source.internal;
-
-import javax.persistence.Entity;
-import javax.persistence.Id;
-
-/**
- * @author Steve Ebersole
- */
-@Entity
-public class SimpleEntity {
-	@Id
-	private Long id;
-	private String name;
-
-	public SimpleEntity() {
-	}
-
-	public SimpleEntity(String name) {
-		this.name = name;
-	}
-
-	public Long getId() {
-		return id;
-	}
-
-	public void setId(Long id) {
-		this.id = id;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/package-info.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/package-info.java
deleted file mode 100644
index cf82afd1f1..0000000000
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/package-info.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-@FetchProfile(name = "package-configured-profile", fetchOverrides = {
-		@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.JOIN)
-})
-package org.hibernate.metamodel.source.internal;
-
-import org.hibernate.annotations.FetchMode;
-import org.hibernate.annotations.FetchProfile;
-
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/InvestorIntegrator.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/InvestorIntegrator.java
index 651003e947..306164d77d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/InvestorIntegrator.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/InvestorIntegrator.java
@@ -1,57 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.embeddables;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Chris Pheby
  */
 public class InvestorIntegrator implements Integrator {
 
 	@Override
 	public void integrate(Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		configuration.registerTypeOverride(new DollarValueUserType(), new String[] {DollarValue.class.getName()});
 		configuration.registerTypeOverride(new MyDateUserType(), new String[] {MyDate.class.getName()});
 	}
 
 	@Override
-	public void integrate(MetadataImplementor metadata,
-			SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		// No-op
-	}
-
-	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {		
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/GoofyPersisterClassProvider.java b/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/GoofyPersisterClassProvider.java
index f1ded8bd34..d516436875 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/GoofyPersisterClassProvider.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/GoofyPersisterClassProvider.java
@@ -1,878 +1,866 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * JBoss, Home of Professional Open Source
  * Copyright 2011 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.cfg.persister;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.FilterAliasGenerator;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.CollectionElementDefinition;
 import org.hibernate.persister.walking.spi.CollectionIndexDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.tuple.entity.NonPojoInstrumentationMetadata;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  */
 public class GoofyPersisterClassProvider implements PersisterClassResolver {
 	@Override
 	public Class<? extends EntityPersister> getEntityPersisterClass(PersistentClass metadata) {
 		return NoopEntityPersister.class;
 	}
 
 	@Override
-	public Class<? extends EntityPersister> getEntityPersisterClass(EntityBinding metadata) {
-		return NoopEntityPersister.class;
-	}
-
-	@Override
 	public Class<? extends CollectionPersister> getCollectionPersisterClass(Collection metadata) {
 		return NoopCollectionPersister.class;
 	}
 
-	@Override
-	public Class<? extends CollectionPersister> getCollectionPersisterClass(PluralAttributeBinding metadata) {
-		return NoopCollectionPersister.class;
-	}
-
 	public static class NoopEntityPersister implements EntityPersister {
 
 		public NoopEntityPersister(org.hibernate.mapping.PersistentClass persistentClass,
 								   org.hibernate.cache.spi.access.EntityRegionAccessStrategy strategy,
 								   NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 								   SessionFactoryImplementor sf,
 								   Mapping mapping) {
 			throw new GoofyException(NoopEntityPersister.class);
 		}
 
 		@Override
 		public EntityMode getEntityMode() {
 			return null;
 		}
 
 		@Override
 		public EntityTuplizer getEntityTuplizer() {
 			return null;
 		}
 
 		@Override
 		public EntityInstrumentationMetadata getInstrumentationMetadata() {
 			return new NonPojoInstrumentationMetadata( null );
 		}
 
 		@Override
 		public void generateEntityDefinition() {
 		}
 
 		@Override
 		public void postInstantiate() throws MappingException {
 
 		}
 
 		@Override
 		public SessionFactoryImplementor getFactory() {
 			return null;
 		}
 
 		@Override
 		public String getRootEntityName() {
 			return null;
 		}
 
 		@Override
 		public String getEntityName() {
 			return null;
 		}
 
 		@Override
 		public EntityMetamodel getEntityMetamodel() {
 			return null;
 		}
 
 		@Override
 		public boolean isSubclassEntityName(String entityName) {
 			return false;
 		}
 
 		@Override
 		public Serializable[] getPropertySpaces() {
 			return new Serializable[0];
 		}
 
 		@Override
 		public Serializable[] getQuerySpaces() {
 			return new Serializable[0];
 		}
 
 		@Override
 		public boolean hasProxy() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCollections() {
 			return false;
 		}
 
 		@Override
 		public boolean hasMutableProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean hasSubselectLoadableCollections() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCascades() {
 			return false;
 		}
 
 		@Override
 		public boolean isMutable() {
 			return false;
 		}
 
 		@Override
 		public boolean isInherited() {
 			return false;
 		}
 
 		@Override
 		public boolean isIdentifierAssignedByInsert() {
 			return false;
 		}
 
 		@Override
 		public Type getPropertyType(String propertyName) throws MappingException {
 			return null;
 		}
 
 		@Override
 		public int[] findDirty(Object[] currentState, Object[] previousState, Object owner, SessionImplementor session) {
 			return new int[0];
 		}
 
 		@Override
 		public int[] findModified(Object[] old, Object[] current, Object object, SessionImplementor session) {
 			return new int[0];
 		}
 
 		@Override
 		public boolean hasIdentifierProperty() {
 			return false;
 		}
 
 		@Override
 		public boolean canExtractIdOutOfEntity() {
 			return false;
 		}
 
 		@Override
 		public boolean isVersioned() {
 			return false;
 		}
 
 		@Override
 		public Comparator getVersionComparator() {
 			return null;
 		}
 
 		@Override
 		public VersionType getVersionType() {
 			return null;
 		}
 
 		@Override
 		public int getVersionProperty() {
 			return 0;
 		}
 
 		@Override
 		public boolean hasNaturalIdentifier() {
 			return false;
 		}
 
 		@Override
 		public int[] getNaturalIdentifierProperties() {
 			return new int[0];
 		}
 
 		@Override
 		public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) {
 			return new Object[0];
 		}
 
 		@Override
 		public Serializable loadEntityIdByNaturalId(Object[] naturalIdValues, LockOptions lockOptions,
 				SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public IdentifierGenerator getIdentifierGenerator() {
 			return null;
 		}
 
 		@Override
 		public boolean hasLazyProperties() {
 			return false;
 		}
 
 		@Override
 		public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) {
 		}
 
 		@Override
 		public void lock(Serializable id, Object version, Object object, LockOptions lockOptions, SessionImplementor session) {
 		}
 
 		@Override
 		public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) {
 		}
 
 		@Override
 		public Serializable insert(Object[] fields, Object object, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void delete(Serializable id, Object version, Object object, SessionImplementor session) {
 		}
 
 		@Override
 		public void update(Serializable id, Object[] fields, int[] dirtyFields, boolean hasDirtyCollection, Object[] oldFields, Object oldVersion, Object object, Object rowId, SessionImplementor session) {
 		}
 
 		@Override
 		public Type[] getPropertyTypes() {
 			return new Type[0];
 		}
 
 		@Override
 		public String[] getPropertyNames() {
 			return new String[0];
 		}
 
 		@Override
 		public boolean[] getPropertyInsertability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 			return new ValueInclusion[0];
 		}
 
 		@Override
 		public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 			return new ValueInclusion[0];
 		}
 
 		@Override
 		public boolean[] getPropertyUpdateability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyCheckability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyNullability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyVersionability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyLaziness() {
 			return new boolean[0];
 		}
 
 		@Override
 		public CascadeStyle[] getPropertyCascadeStyles() {
 			return new CascadeStyle[0];
 		}
 
 		@Override
 		public Type getIdentifierType() {
 			return null;
 		}
 
 		@Override
 		public String getIdentifierPropertyName() {
 			return null;
 		}
 
 		@Override
 		public boolean isCacheInvalidationRequired() {
 			return false;
 		}
 
 		@Override
 		public boolean isLazyPropertiesCacheable() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCache() {
 			return false;
 		}
 
 		@Override
 		public EntityRegionAccessStrategy getCacheAccessStrategy() {
 			return null;
 		}
 		
 		@Override
 		public boolean hasNaturalIdCache() {
 			return false;
 		}
 
 		@Override
 		public NaturalIdRegionAccessStrategy getNaturalIdCacheAccessStrategy() {
 			return null;
 		}
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return null;
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(
 				Object entity, Object[] state, Object version, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public ClassMetadata getClassMetadata() {
 			return null;
 		}
 
 		@Override
 		public boolean isBatchLoadable() {
 			return false;
 		}
 
 		@Override
 		public boolean isSelectBeforeUpdateRequired() {
 			return false;
 		}
 
 		@Override
 		public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 			return new Object[0];
 		}
 
 		@Override
 		public Serializable getIdByUniqueKey(Serializable key, String uniquePropertyName, SessionImplementor session) {
 			throw new UnsupportedOperationException( "not supported" );
 		}
 
 		@Override
 		public Object getCurrentVersion(Serializable id, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public boolean isInstrumented() {
 			return false;
 		}
 
 		@Override
 		public boolean hasInsertGeneratedProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean hasUpdateGeneratedProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean isVersionPropertyGenerated() {
 			return false;
 		}
 
 		@Override
 		public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		}
 
 		@Override
 		public void afterReassociate(Object entity, SessionImplementor session) {
 		}
 
 		@Override
 		public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Boolean isTransient(Object object, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) {
 			return new Object[0];
 		}
 
 		@Override
 		public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		}
 
 		@Override
 		public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		}
 
 		@Override
 		public Class getMappedClass() {
 			return null;
 		}
 
 		@Override
 		public boolean implementsLifecycle() {
 			return false;
 		}
 
 		@Override
 		public Class getConcreteProxyClass() {
 			return null;
 		}
 
 		@Override
 		public void setPropertyValues(Object object, Object[] values) {
 		}
 
 		@Override
 		public void setPropertyValue(Object object, int i, Object value) {
 		}
 
 		@Override
 		public Object[] getPropertyValues(Object object) {
 			return new Object[0];
 		}
 
 		@Override
 		public Object getPropertyValue(Object object, int i) {
 			return null;
 		}
 
 		@Override
 		public Object getPropertyValue(Object object, String propertyName) {
 			return null;
 		}
 
 		@Override
 		public Serializable getIdentifier(Object object) {
 			return null;
 		}
 
 		@Override
 		public Serializable getIdentifier(Object entity, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		}
 
 		@Override
 		public Object getVersion(Object object) {
 			return null;
 		}
 
 		@Override
 		public Object instantiate(Serializable id, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public boolean isInstance(Object object) {
 			return false;
 		}
 
 		@Override
 		public boolean hasUninitializedLazyProperties(Object object) {
 			return false;
 		}
 
 		@Override
 		public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		}
 
 		@Override
 		public EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory) {
 			return null;
 		}
 
 		@Override
 		public FilterAliasGenerator getFilterAliasGenerator(String rootAlias) {
 			// TODO Auto-generated method stub
 			return null;
 		}
 
 		@Override
 		public EntityPersister getEntityPersister() {
 			return this;
 		}
 
 		@Override
 		public EntityIdentifierDefinition getEntityKeyDefinition() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		@Override
 		public Iterable<AttributeDefinition> getAttributes() {
 			throw new NotYetImplementedException();
 		}
 
         @Override
         public int[] resolveAttributeIndexes(Set<String> attributes) {
             return null;
         }
 
 		@Override
 		public boolean canUseReferenceCacheEntries() {
 			return false;
 		}
 	}
 
 	public static class NoopCollectionPersister implements CollectionPersister {
 
 		public NoopCollectionPersister(org.hibernate.mapping.Collection collection,
 									   org.hibernate.cache.spi.access.CollectionRegionAccessStrategy strategy,
 									   org.hibernate.cfg.Configuration configuration,
 									   SessionFactoryImplementor sf) {
 			throw new GoofyException(NoopCollectionPersister.class);
 		}
 
 		public void initialize(Serializable key, SessionImplementor session) throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean hasCache() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public CollectionRegionAccessStrategy getCacheAccessStrategy() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public CacheEntryStructure getCacheEntryStructure() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		@Override
 		public CollectionPersister getCollectionPersister() {
 			return this;
 		}
 
 		public CollectionType getCollectionType() {
 			throw new NotYetImplementedException();
 		}
 
 		@Override
 		public CollectionIndexDefinition getIndexDefinition() {
 			throw new NotYetImplementedException();
 		}
 
 		@Override
 		public CollectionElementDefinition getElementDefinition() {
 			throw new NotYetImplementedException();
 		}
 
 		public Type getKeyType() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Type getIndexType() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Type getElementType() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Class getElementClass() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Object readKey(ResultSet rs, String[] keyAliases, SessionImplementor session)
 				throws HibernateException, SQLException {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Object readElement(ResultSet rs, Object owner, String[] columnAliases, SessionImplementor session)
 				throws HibernateException, SQLException {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Object readIndex(ResultSet rs, String[] columnAliases, SessionImplementor session)
 				throws HibernateException, SQLException {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Object readIdentifier(ResultSet rs, String columnAlias, SessionImplementor session)
 				throws HibernateException, SQLException {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isPrimitiveArray() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isArray() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isOneToMany() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isManyToMany() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getManyToManyFilterFragment(String alias, Map enabledFilters) {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean hasIndex() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isLazy() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isInverse() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void remove(Serializable id, SessionImplementor session) throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void recreate(PersistentCollection collection, Serializable key, SessionImplementor session)
 				throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void deleteRows(PersistentCollection collection, Serializable key, SessionImplementor session)
 				throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void updateRows(PersistentCollection collection, Serializable key, SessionImplementor session)
 				throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void insertRows(PersistentCollection collection, Serializable key, SessionImplementor session)
 				throws HibernateException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getRole() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public EntityPersister getOwnerEntityPersister() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public IdentifierGenerator getIdentifierGenerator() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Type getIdentifierType() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean hasOrphanDelete() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean hasOrdering() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean hasManyToManyOrdering() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Serializable[] getCollectionSpaces() {
 			return new Serializable[0];  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public CollectionMetadata getCollectionMetadata() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isCascadeDeleteEnabled() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isVersioned() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isMutable() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getNodeName() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getElementNodeName() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getIndexNodeName() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public void postInstantiate() throws MappingException {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public SessionFactoryImplementor getFactory() {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isAffectedByEnabledFilters(SessionImplementor session) {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String[] getKeyColumnAliases(String suffix) {
 			return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String[] getIndexColumnAliases(String suffix) {
 			return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String[] getElementColumnAliases(String suffix) {
 			return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public String getIdentifierColumnAlias(String suffix) {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean isExtraLazy() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public int getSize(Serializable key, SessionImplementor session) {
 			return 0;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean indexExists(Serializable key, Object index, SessionImplementor session) {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public boolean elementExists(Serializable key, Object element, SessionImplementor session) {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		public Object getElementByIndex(Serializable key, Object index, SessionImplementor session, Object owner) {
 			return null;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		@Override
 		public int getBatchSize() {
 			return 0;
 		}
 
 		@Override
 		public String getMappedByProperty() {
 			return null;
 		}
 
 		@Override
 		public void processQueuedOps(PersistentCollection collection, Serializable key, SessionImplementor session)
 				throws HibernateException {
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritance.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritance.hbm.xml
index 1becbdfefc..132ba8ead0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritance.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritance.hbm.xml
@@ -1,60 +1,56 @@
 <?xml version="1.0"?>
-<hibernate-mapping package="org.hibernate.test.discriminator" default-access="field"
-                   xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                   xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
-<!--
 <!DOCTYPE hibernate-mapping PUBLIC
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
+
 <hibernate-mapping
 	package="org.hibernate.test.discriminator"
 	default-access="field">
--->
+
 <!--
 
   This mapping demonstrates a simple table-per-hierarchy mapping strategy;
   each subclass has simple properties
 
 -->
 
 	<class name="Person"
 		discriminator-value="P">
 		
 		<id name="id" 
 			column="person_id" 
 			unsaved-value="0">
 			<generator class="assigned"/>
 		</id>
 		
         <discriminator column="`TYPE`" type="character"/>
 
 		<property name="name"
 			not-null="true"
 			length="80"/>
 
 		<property name="sex"
 			not-null="true"
 			update="false"/>
 		
 		<subclass name="Employee"
 			discriminator-value="E">
 				<property name="title" length="20"/>
 				<property name="salary" />
             <!-- commented out until HHH-6551 is fixed
 			<subclass name="PartTimeEmployee" discriminator-value="M">
 				<property name="percent"/>
 			</subclass>
 			-->
    		</subclass>
 		
 		<subclass name="Customer" 
 			discriminator-value="C">
 				<property name="comments"/>
 		</subclass>
 		
 	</class>
 	
 
 </hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritanceTest.java b/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritanceTest.java
index f39f1362e1..5f58f9b36a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritanceTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/discriminator/SimpleInheritanceTest.java
@@ -1,273 +1,272 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.discriminator;
 
 import java.math.BigDecimal;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.criterion.Property;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
 public class SimpleInheritanceTest extends BaseCoreFunctionalTestCase {
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
-		cfg.setProperty( USE_NEW_METADATA_MAPPINGS, "true");
 	}
 
 	@Override
 	public String[] getMappings() {
 		return new String[] { "discriminator/SimpleInheritance.hbm.xml" };
 	}
 
 	@Test
 	public void testDiscriminatorSubclass() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Employee mark = new Employee();
 		mark.setId( 1 );
 		mark.setName( "Mark" );
 		mark.setTitle( "internal sales" );
 		mark.setSex( 'M' );
 
 		Customer joe = new Customer();
 		joe.setId( 2 );
 		joe.setName( "Joe" );
 		joe.setComments( "Very demanding" );
 		joe.setSex( 'M' );
 
 		Person yomomma = new Person();
 		yomomma.setId( 3 );
 		yomomma.setName("mum");
 		yomomma.setSex('F');
 
 		s.save(yomomma);
 		s.save(mark);
 		s.save(joe);
 
 		assertEquals( s.createQuery("from java.io.Serializable").list().size(), 0 );
 
 		assertEquals( s.createQuery("from org.hibernate.test.discriminator.Person").list().size(), 3 );
 		assertEquals( s.createQuery("from org.hibernate.test.discriminator.Person p where p.class = org.hibernate.test.discriminator.Person").list().size(), 1 );
 		assertEquals( s.createQuery("from org.hibernate.test.discriminator.Person p where p.class = org.hibernate.test.discriminator.Customer").list().size(), 1 );
 		assertEquals( s.createQuery("from org.hibernate.test.discriminator.Person p where type(p) = :who").setParameter("who", Person.class).list().size(), 1 );
 		assertEquals( s.createQuery("from org.hibernate.test.discriminator.Person p where type(p) in :who").setParameterList("who", new Class[] {Customer.class, Person.class}).list().size(), 2 );
 		s.clear();
 
 		List customers = s.createQuery("from org.hibernate.test.discriminator.Customer").list();
 		for ( Object customer : customers ) {
 			Customer c = (Customer) customer;
 			assertEquals( "Very demanding", c.getComments() );
 		}
 		assertEquals( customers.size(), 1 );
 		s.clear();
 
 		mark = (Employee) s.get( Employee.class, mark.getId() );
 		joe = (Customer) s.get( Customer.class, joe.getId() );
 
  		s.delete(mark);
 		s.delete(joe);
 		s.delete(yomomma);
 		assertTrue( s.createQuery("from org.hibernate.test.discriminator.Person").list().isEmpty() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAccessAsIncorrectSubclass() {
 		Session s = openSession();
 		s.beginTransaction();
 		Employee e = new Employee();
 		e.setId( 4 );
 		e.setName( "Steve" );
 		e.setSex( 'M' );
 		e.setTitle( "grand poobah" );
 		s.save( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Customer c = ( Customer ) s.get( Customer.class, e.getId() );
 		s.getTransaction().commit();
 		s.close();
 		assertNull( c );
 
 		s = openSession();
 		s.beginTransaction();
 		e = ( Employee ) s.get( Employee.class, e.getId() );
 		c = ( Customer ) s.get( Customer.class, e.getId() );
 		s.getTransaction().commit();
 		s.close();
 		assertNotNull( e );
 		assertNull( c );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( e );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQuerySubclassAttribute() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Person p = new Person();
 		p.setId( 5 );
 		p.setName("Emmanuel");
 		p.setSex('M');
 		s.save( p );
 		Employee q = new Employee();
 		q.setId( 6 );
 		q.setName("Steve");
 		q.setSex('M');
 		q.setTitle("Mr");
 		q.setSalary( new BigDecimal(1000) );
 		s.save( q );
 
 		List result = s.createQuery("from org.hibernate.test.discriminator.Person where salary > 100").list();
 		assertEquals( result.size(), 1 );
 		assertSame( result.get(0), q );
 
 		result = s.createQuery("from org.hibernate.test.discriminator.Person where salary > 100 or name like 'E%'").list();
 		assertEquals( result.size(), 2 );
 
 		result = s.createCriteria(Person.class)
 			.add( Property.forName("salary").gt( new BigDecimal(100) ) )
 			.list();
 		assertEquals( result.size(), 1 );
 		assertSame( result.get(0), q );
 
 		//TODO: make this work:
 		/*result = s.createQuery("select salary from Person where salary > 100").list();
 		assertEquals( result.size(), 1 );
 		assertEquals( result.get(0), new BigDecimal(1000) );*/
 
 		s.delete(p);
 		s.delete(q);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadSuperclassProxyPolymorphicAccess() {
 		Session s = openSession();
 		s.beginTransaction();
 		Employee e = new Employee();
 		e.setId( 7 );
 		e.setName( "Steve" );
 		e.setSex( 'M' );
 		e.setTitle( "grand poobah" );
 		s.save( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		// load the superclass proxy.
 		Person pLoad = ( Person ) s.load( Person.class, new Long( e.getId() ) );
 		assertTrue( pLoad instanceof HibernateProxy);
 		Person pGet = ( Person ) s.get( Person.class, e.getId());
 		Person pQuery = ( Person ) s.createQuery( "from org.hibernate.test.discriminator.Person where id = :id" )
 				.setLong( "id", e.getId() )
 				.uniqueResult();
 		Person pCriteria = ( Person ) s.createCriteria( Person.class )
 				.add( Restrictions.idEq( e.getId() ) )
 				.uniqueResult();
 		// assert that executing the queries polymorphically returns the same proxy
 		assertSame( pLoad, pGet );
 		assertSame( pLoad, pQuery );
 		assertSame( pLoad, pCriteria );
 
 		// assert that the proxy is not an instance of Employee
 		assertFalse( pLoad instanceof Employee );
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( e );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadSuperclassProxyEvictPolymorphicAccess() {
 		Session s = openSession();
 		s.beginTransaction();
 		Employee e = new Employee();
 		e.setId( 8 );
 		e.setName( "Steve" );
 		e.setSex( 'M' );
 		e.setTitle( "grand poobah" );
 		s.save( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		// load the superclass proxy.
 		Person pLoad = ( Person ) s.load( Person.class, new Long( e.getId() ) );
 		assertTrue( pLoad instanceof HibernateProxy);
 		// evict the proxy
 		s.evict( pLoad );
 		Employee pGet = ( Employee ) s.get( Person.class, e.getId() );
 		Employee pQuery = ( Employee ) s.createQuery( "from org.hibernate.test.discriminator.Person where id = :id" )
 				.setLong( "id", e.getId() )
 				.uniqueResult();
 		Employee pCriteria = ( Employee ) s.createCriteria( Person.class )
 				.add( Restrictions.idEq( e.getId() ) )
 				.uniqueResult();
 		// assert that executing the queries polymorphically returns the same Employee instance
 		assertSame( pGet, pQuery );
 		assertSame( pGet, pCriteria );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( e );
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
index 80b971ab19..abc50678fe 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
@@ -1,91 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.dynamicentity.tuplizer2;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.test.dynamicentity.ProxyHelper;
 import org.hibernate.test.dynamicentity.tuplizer.MyEntityInstantiator;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.PojoEntityTuplizer;
 
 /**
  * @author Steve Ebersole
  */
 public class MyEntityTuplizer extends PojoEntityTuplizer {
 
 	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
-	public MyEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappedEntity) {
-		super( entityMetamodel, mappedEntity );
-	}
-
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
 	}
 
 	protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		return new MyEntityInstantiator( persistentClass.getEntityName() );
 	}
 
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		String entityName = ProxyHelper.extractEntityName( entityInstance );
 		if ( entityName == null ) {
 			entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
 		}
 		return entityName;
 	}
 
 	protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// allows defining a custom proxy factory, which is responsible for
 		// generating lazy proxies for a given entity.
 		//
 		// Here we simply use the default...
 		return super.buildProxyFactory( persistentClass, idGetter, idSetter );
 	}
 
 	public static class MyEntityNameResolver implements EntityNameResolver {
 		public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();
 
 		public String resolveEntityName(Object entity) {
 			return ProxyHelper.extractEntityName( entity );
 		}
 
 		public boolean equals(Object obj) {
 			return getClass().equals( obj.getClass() );
 		}
 
 		public int hashCode() {
 			return getClass().hashCode();
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/detached/AggregatedCollectionEventListener.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/detached/AggregatedCollectionEventListener.java
index 1f2b2cd7e0..baa9280846 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/detached/AggregatedCollectionEventListener.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/detached/AggregatedCollectionEventListener.java
@@ -1,202 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection.detached;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.AbstractCollectionEvent;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.InitializeCollectionEvent;
 import org.hibernate.event.spi.InitializeCollectionEventListener;
 import org.hibernate.event.spi.PostCollectionRecreateEvent;
 import org.hibernate.event.spi.PostCollectionRecreateEventListener;
 import org.hibernate.event.spi.PostCollectionRemoveEvent;
 import org.hibernate.event.spi.PostCollectionRemoveEventListener;
 import org.hibernate.event.spi.PostCollectionUpdateEvent;
 import org.hibernate.event.spi.PostCollectionUpdateEventListener;
 import org.hibernate.event.spi.PreCollectionRecreateEvent;
 import org.hibernate.event.spi.PreCollectionRecreateEventListener;
 import org.hibernate.event.spi.PreCollectionRemoveEvent;
 import org.hibernate.event.spi.PreCollectionRemoveEventListener;
 import org.hibernate.event.spi.PreCollectionUpdateEvent;
 import org.hibernate.event.spi.PreCollectionUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class AggregatedCollectionEventListener
 		implements InitializeCollectionEventListener,
 				   PreCollectionRecreateEventListener,
 				   PostCollectionRecreateEventListener,
 				   PreCollectionRemoveEventListener,
 				   PostCollectionRemoveEventListener,
 				   PreCollectionUpdateEventListener,
 				   PostCollectionUpdateEventListener {
 
 	private static final Logger log = Logger.getLogger( AggregatedCollectionEventListener.class );
 
 	private final List<EventEntry> eventEntryList = new ArrayList<EventEntry>();
 
 	public void reset() {
 		eventEntryList.clear();
 	}
 
 	public List<EventEntry> getEventEntryList() {
 		return eventEntryList;
 	}
 
 	@Override
 	public void onInitializeCollection(InitializeCollectionEvent event) throws HibernateException {
 		addEvent( event );
 	}
 
 	protected void addEvent(AbstractCollectionEvent event) {
 		log.debugf( "Added collection event : %s", event );
 		eventEntryList.add( new EventEntry( event ) );
 	}
 
 
 	// recreate ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public void onPreRecreateCollection(PreCollectionRecreateEvent event) {
 		addEvent( event );
 	}
 
 	@Override
 	public void onPostRecreateCollection(PostCollectionRecreateEvent event) {
 		addEvent( event );
 	}
 
 
 	// remove ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public void onPreRemoveCollection(PreCollectionRemoveEvent event) {
 		addEvent( event );
 	}
 
 	@Override
 	public void onPostRemoveCollection(PostCollectionRemoveEvent event) {
 		addEvent( event );
 	}
 
 
 	// update ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public void onPreUpdateCollection(PreCollectionUpdateEvent event) {
 		addEvent( event );
 	}
 
 	@Override
 	public void onPostUpdateCollection(PostCollectionUpdateEvent event) {
 		addEvent( event );
 	}
 
 	public static class EventEntry {
 		private final AbstractCollectionEvent event;
 		private final Serializable snapshotAtTimeOfEventHandling;
 
 		public EventEntry(AbstractCollectionEvent event) {
 			this.event = event;
 			// make a copy of the collection?
 			this.snapshotAtTimeOfEventHandling = event.getSession()
 					.getPersistenceContext()
 					.getCollectionEntry( event.getCollection() )
 					.getSnapshot();
 		}
 
 		public AbstractCollectionEvent getEvent() {
 			return event;
 		}
 
 		public Serializable getSnapshotAtTimeOfEventHandling() {
 			return snapshotAtTimeOfEventHandling;
 		}
 	}
 
 	public static class IntegratorImpl implements Integrator {
 		private AggregatedCollectionEventListener listener;
 
 		public AggregatedCollectionEventListener getListener() {
 			if ( listener == null ) {
 				throw new HibernateException( "Integrator not yet processed" );
 			}
 			return listener;
 		}
 
 		@Override
 		public void integrate(
 				Configuration configuration,
 				SessionFactoryImplementor sessionFactory,
 				SessionFactoryServiceRegistry serviceRegistry) {
 			integrate( serviceRegistry );
 		}
 
 		protected void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 			if ( listener != null ) {
 				log.warn( "integrate called second time on testing collection listener Integrator (could be result of rebuilding SF on test failure)" );
 			}
 			listener = new AggregatedCollectionEventListener();
 
 			final EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 			listenerRegistry.appendListeners( EventType.INIT_COLLECTION, listener );
 			listenerRegistry.appendListeners( EventType.PRE_COLLECTION_RECREATE, listener );
 			listenerRegistry.appendListeners( EventType.POST_COLLECTION_RECREATE, listener );
 			listenerRegistry.appendListeners( EventType.PRE_COLLECTION_REMOVE, listener );
 			listenerRegistry.appendListeners( EventType.POST_COLLECTION_REMOVE, listener );
 			listenerRegistry.appendListeners( EventType.PRE_COLLECTION_UPDATE, listener );
 			listenerRegistry.appendListeners( EventType.POST_COLLECTION_UPDATE, listener );
 		}
 
-
-		@Override
-		public void integrate(
-				MetadataImplementor metadata,
-				SessionFactoryImplementor sessionFactory,
-				SessionFactoryServiceRegistry serviceRegistry) {
-			integrate( serviceRegistry );
-		}
-
 		@Override
 		public void disintegrate(
 				SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 			//To change body of implemented methods use File | Settings | File Templates.
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
index acf281804b..bf53bbe0f7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
@@ -1,144 +1,136 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.events;
 
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.DeleteEvent;
 import org.hibernate.event.spi.DeleteEventListener;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 
 /**
  * CallbackTest implementation
  *
  * @author Steve Ebersole
  */
 public class CallbackTest extends BaseCoreFunctionalTestCase {
 	private TestingObserver observer = new TestingObserver();
 	private TestingListener listener = new TestingListener();
 
 	@Override
     public String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	@Override
     public void configure(Configuration cfg) {
 		cfg.setSessionFactoryObserver( observer );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 				    @Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
                         integrate(serviceRegistry);
 					}
 
-                    @Override
-				    public void integrate( MetadataImplementor metadata,
-				                           SessionFactoryImplementor sessionFactory,
-				                           SessionFactoryServiceRegistry serviceRegistry ) {
-                        integrate(serviceRegistry);
-				    }
-
                     private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                         serviceRegistry.getService( EventListenerRegistry.class ).setListeners(EventType.DELETE, listener);
                         listener.initialize();
                     }
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 						listener.cleanup();
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testCallbacks() {
 		assertEquals( "observer not notified of creation", 1, observer.creationCount );
 		assertEquals( "listener not notified of creation", 1, listener.initCount );
 
 		sessionFactory().close();
 
 		assertEquals( "observer not notified of close", 1, observer.closedCount );
 		assertEquals( "listener not notified of close", 1, listener.destoryCount );
 	}
 
 	private static class TestingObserver implements SessionFactoryObserver {
 		private int creationCount = 0;
 		private int closedCount = 0;
 
 		public void sessionFactoryCreated(SessionFactory factory) {
 			creationCount++;
 		}
 
 		public void sessionFactoryClosed(SessionFactory factory) {
 			closedCount++;
 		}
 	}
 
 	private static class TestingListener implements DeleteEventListener {
 		private int initCount = 0;
 		private int destoryCount = 0;
 
 		public void initialize() {
 			initCount++;
 		}
 
 		public void cleanup() {
 			destoryCount++;
 		}
 
 		public void onDelete(DeleteEvent event) throws HibernateException {
 		}
 
 		public void onDelete(DeleteEvent event, Set transientEntities) throws HibernateException {
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/ClearEventListenerTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/ClearEventListenerTest.java
index a843d481b0..70d1723aee 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/ClearEventListenerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/ClearEventListenerTest.java
@@ -1,121 +1,113 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.events;
 
 import org.hibernate.Session;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.ClearEvent;
 import org.hibernate.event.spi.ClearEventListener;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class ClearEventListenerTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testExplicitClear() {
 		listener.callCount = 0;
 
 		Session s = openSession();
 		s.clear();
 		assertEquals( 1, listener.callCount );
 		s.close();
 		assertEquals( 1, listener.callCount );
 	}
 
 	@Test
 	public void testAutoClear() {
 		listener.callCount = 0;
 
 		Session s = openSession();
 		( (SessionImplementor) s ).setAutoClear( true );
 		s.beginTransaction();
 		assertEquals( 0, listener.callCount );
 		s.getTransaction().commit();
 		assertEquals( 1, listener.callCount );
 		s.close();
 		assertEquals( 1, listener.callCount );
 	}
 
 	private TheListener listener = new TheListener();
 
 	private static class TheListener implements ClearEventListener {
 		private int callCount;
 
 		@Override
 		public void onClear(ClearEvent event) {
 			callCount++;
 		}
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate(serviceRegistry);
 					}
 
-					@Override
-					public void integrate( MetadataImplementor metadata,
-										   SessionFactoryImplementor sessionFactory,
-										   SessionFactoryServiceRegistry serviceRegistry ) {
-						integrate(serviceRegistry);
-					}
-
 					private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
 						serviceRegistry.getService( EventListenerRegistry.class ).setListeners(
 								EventType.CLEAR,
 								listener
 						);
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/LegacyPostCommitListenerTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/LegacyPostCommitListenerTest.java
index c180c366d9..7293b8a9b1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/LegacyPostCommitListenerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/LegacyPostCommitListenerTest.java
@@ -1,265 +1,261 @@
 package org.hibernate.test.events;
 
 import org.hibernate.IrrelevantEntity;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
-import org.hibernate.event.spi.*;
+import org.hibernate.event.spi.EventType;
+import org.hibernate.event.spi.PostDeleteEvent;
+import org.hibernate.event.spi.PostDeleteEventListener;
+import org.hibernate.event.spi.PostInsertEvent;
+import org.hibernate.event.spi.PostInsertEventListener;
+import org.hibernate.event.spi.PostUpdateEvent;
+import org.hibernate.event.spi.PostUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
-
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * Test to ensure that the existing post commit behavior when using plain PostXEventListeners fire on both success and failure.
  * 
  * @author ShawnClowater
  */
 public class LegacyPostCommitListenerTest extends BaseCoreFunctionalTestCase {
 	private PostInsertEventListener postCommitInsertEventListener = new LegacyPostCommitInsertEventListener();
 	private PostDeleteEventListener postCommitDeleteEventListener = new LegacyPostCommitDeleteEventListener();
 	private PostUpdateEventListener postCommitUpdateEventListener = new LegacyPostCommitUpdateEventListener();
 
 	@Override
 	protected void prepareTest() throws Exception {
 		((LegacyPostCommitInsertEventListener) postCommitInsertEventListener).fired = 0;
 		((LegacyPostCommitDeleteEventListener) postCommitDeleteEventListener).fired = 0;
 		((LegacyPostCommitUpdateEventListener) postCommitUpdateEventListener).fired = 0;
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
-					@Override
-					public void integrate(
-							MetadataImplementor metadata,
-							SessionFactoryImplementor sessionFactory,
-							SessionFactoryServiceRegistry serviceRegistry) {
-						integrate( serviceRegistry );
-					}
-
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_DELETE
 						).appendListener( postCommitDeleteEventListener );
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_UPDATE
 						).appendListener( postCommitUpdateEventListener );
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_INSERT
 						).appendListener( postCommitInsertEventListener );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitInsertListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		Assert.assertEquals( 1, ((LegacyPostCommitInsertEventListener) postCommitInsertEventListener).fired );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitInsertListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 		session.close();
 
 		//the legacy implementation fires the listener on failure as well 
 		Assert.assertEquals( 1, ((LegacyPostCommitInsertEventListener) postCommitInsertEventListener).fired );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitUpdateListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		irrelevantEntity.setName( "Irrelevant 2" );
 		session.update( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session.close();
 
 		Assert.assertEquals( 1, ((LegacyPostCommitUpdateEventListener) postCommitUpdateEventListener).fired );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitUpdateListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		irrelevantEntity.setName( "Irrelevant 2" );
 		session.update( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 
 		session.close();
 
 		//the legacy implementation fires the listener on failure as well
 		Assert.assertEquals( 1, ((LegacyPostCommitUpdateEventListener) postCommitUpdateEventListener).fired );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitDeleteListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		session.delete( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session.close();
 
 		Assert.assertEquals( 1, ((LegacyPostCommitDeleteEventListener) postCommitDeleteEventListener).fired );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitDeleteListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		session.delete( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 
 		session.close();
 
 		//the legacy implementation fires the listener on failure as well
 		Assert.assertEquals( 1, ((LegacyPostCommitDeleteEventListener) postCommitDeleteEventListener).fired );
 	}
 
 	private class LegacyPostCommitDeleteEventListener implements PostDeleteEventListener {
 		int fired;
 
 		@Override
 		public void onPostDelete(PostDeleteEvent event) {
 			fired++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	private class LegacyPostCommitUpdateEventListener implements PostUpdateEventListener {
 		int fired;
 
 		@Override
 		public void onPostUpdate(PostUpdateEvent event) {
 			fired++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	private class LegacyPostCommitInsertEventListener implements PostInsertEventListener {
 		int fired;
 
 		@Override
 		public void onPostInsert(PostInsertEvent event) {
 			fired++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {IrrelevantEntity.class};
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/PostCommitListenerTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/PostCommitListenerTest.java
index ca4d007451..cf422e468f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/PostCommitListenerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/PostCommitListenerTest.java
@@ -1,298 +1,289 @@
 package org.hibernate.test.events;
 
 import org.hibernate.IrrelevantEntity;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PostCommitDeleteEventListener;
 import org.hibernate.event.spi.PostCommitInsertEventListener;
 import org.hibernate.event.spi.PostCommitUpdateEventListener;
 import org.hibernate.event.spi.PostDeleteEvent;
 import org.hibernate.event.spi.PostDeleteEventListener;
 import org.hibernate.event.spi.PostInsertEvent;
 import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.event.spi.PostUpdateEvent;
 import org.hibernate.event.spi.PostUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * Test to ensure that the existing post commit behavior when using plain PostXEventListeners fire on both success and failure.
  * 
  * @author ShawnClowater
  */
 public class PostCommitListenerTest extends BaseCoreFunctionalTestCase {
 	private PostInsertEventListener postCommitInsertEventListener = new TestPostCommitInsertEventListener();
 	private PostDeleteEventListener postCommitDeleteEventListener = new TestPostCommitDeleteEventListener();
 	private PostUpdateEventListener postCommitUpdateEventListener = new TestPostCommitUpdateEventListener();
 
 	@Override
 	protected void prepareTest() throws Exception {
 		((TestPostCommitInsertEventListener) postCommitInsertEventListener).success = 0;
 		((TestPostCommitInsertEventListener) postCommitInsertEventListener).failed = 0;
 		((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).success = 0;
 		((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).failed = 0;
 		((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).sucess = 0;
 		((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).failed = 0;
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
-					@Override
-					public void integrate(
-							MetadataImplementor metadata,
-							SessionFactoryImplementor sessionFactory,
-							SessionFactoryServiceRegistry serviceRegistry) {
-						integrate( serviceRegistry );
-					}
-
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_DELETE
 						).appendListener( postCommitDeleteEventListener );
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_UPDATE
 						).appendListener( postCommitUpdateEventListener );
 						serviceRegistry.getService( EventListenerRegistry.class ).getEventListenerGroup(
 								EventType.POST_COMMIT_INSERT
 						).appendListener( postCommitInsertEventListener );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitInsertListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		Assert.assertEquals( 1, ((TestPostCommitInsertEventListener) postCommitInsertEventListener).success );
 		Assert.assertEquals( 0, ((TestPostCommitInsertEventListener) postCommitInsertEventListener).failed );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitInsertListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 		session.close();
 
 		Assert.assertEquals( 0, ((TestPostCommitInsertEventListener) postCommitInsertEventListener).success );
 		Assert.assertEquals( 1, ((TestPostCommitInsertEventListener) postCommitInsertEventListener).failed );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitUpdateListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		irrelevantEntity.setName( "Irrelevant 2" );
 		session.update( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session.close();
 
 		Assert.assertEquals( 1, ((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).sucess );
 		Assert.assertEquals( 0, ((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).failed );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitUpdateListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		irrelevantEntity.setName( "Irrelevant 2" );
 		session.update( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 
 		session.close();
 
 		Assert.assertEquals( 0, ((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).sucess );
 		Assert.assertEquals( 1, ((TestPostCommitUpdateEventListener) postCommitUpdateEventListener).failed );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitDeleteListenerSuccess() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		session.delete( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 
 		session.close();
 
 		Assert.assertEquals( 1, ((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).success );
 		Assert.assertEquals( 0, ((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).failed );
 	}
 
 	@Test
 	@TestForIssue(jiraKey = "HHH-1582")
 	public void testPostCommitDeleteListenerRollback() {
 		Session session = openSession();
 		Transaction transaction = session.beginTransaction();
 
 		IrrelevantEntity irrelevantEntity = new IrrelevantEntity();
 		irrelevantEntity.setName( "Irrelevant" );
 
 		session.save( irrelevantEntity );
 		session.flush();
 		transaction.commit();
 		session.close();
 
 		session = openSession();
 		transaction = session.beginTransaction();
 		session.delete( irrelevantEntity );
 		session.flush();
 		transaction.rollback();
 
 		session.close();
 
 		Assert.assertEquals( 0, ((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).success );
 		Assert.assertEquals( 1, ((TestPostCommitDeleteEventListener) postCommitDeleteEventListener).failed );
 	}
 
 	private class TestPostCommitDeleteEventListener implements PostCommitDeleteEventListener {
 		int success;
 		int failed;
 
 		@Override
 		public void onPostDelete(PostDeleteEvent event) {
 			success++;
 		}
 
 		@Override
 		public void onPostDeleteCommitFailed(PostDeleteEvent event) {
 			failed++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	private class TestPostCommitUpdateEventListener implements PostCommitUpdateEventListener {
 		int sucess;
 		int failed;
 
 		@Override
 		public void onPostUpdate(PostUpdateEvent event) {
 			sucess++;
 		}
 
 		@Override
 		public void onPostUpdateCommitFailed(PostUpdateEvent event) {
 			failed++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	private class TestPostCommitInsertEventListener implements PostCommitInsertEventListener {
 		int success;
 		int failed;
 
 		@Override
 		public void onPostInsert(PostInsertEvent event) {
 			success++;
 		}
 
 		@Override
 		public void onPostInsertCommitFailed(PostInsertEvent event) {
 			failed++;
 		}
 
 		@Override
 		public boolean requiresPostCommitHanding(EntityPersister persister) {
 			return true;
 		}
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {IrrelevantEntity.class};
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java b/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
index b86bf36cfa..7ed8dcc4ee 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
@@ -1,290 +1,281 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PreUpdateEvent;
 import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.SessionImpl;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gail Badner
  */
 @TestForIssue( jiraKey = "HHH-6960" )
 public class TestAutoFlushBeforeQueryExecution extends BaseCoreFunctionalTestCase {
 
 	@Test
 	public void testAutoflushIsRequired() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Publisher publisher = new Publisher();
 		publisher.setName( "name" );
 		s.save( publisher );
 		assertTrue( "autoflush entity create", s.createQuery( "from Publisher p" ).list().size() == 1 );
 		publisher.setName( "name" );
 		assertTrue( "autoflush entity update", s.createQuery( "from Publisher p where p.name='name'" ).list().size() == 1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		assertTrue( publisher.getAuthors().isEmpty() );
 
 		final PersistenceContext persistenceContext = ( (SessionImplementor) s ).getPersistenceContext();
 		final ActionQueue actionQueue = ( (SessionImpl) s ).getActionQueue();
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Author author1 = new Author( );
 		author1.setPublisher( publisher );
 		publisher.getAuthors().add( author1 );
 		assertTrue(
 				"autoflush collection update",
 				s.createQuery( "select a from Publisher p join p.authors a" ).list().size() == 1
 		);
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author1.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		author1.setPublisher( null );
 		s.delete( author1 );
 		publisher.getAuthors().clear();
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 		assertTrue( "autoflush collection update",
 				s.createQuery( "select a from Publisher p join p.authors a" ).list().size() == 0
 		);
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Set<Author> authorsOld = publisher.getAuthors();
 		publisher.setAuthors( new HashSet<Author>() );
 		Author author2 = new Author( );
 		author2.setName( "author2" );
 		author2.setPublisher( publisher );
 		publisher.getAuthors().add( author2 );
 		List results = s.createQuery( "select a from Publisher p join p.authors a" ).list();
 		assertEquals( 1, results.size() );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author2.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.delete(publisher);
 		assertTrue( "autoflush delete", s.createQuery( "from Publisher p" ).list().size()==0 );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAutoflushIsNotRequiredWithUnrelatedCollectionChange() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Publisher publisher = new Publisher();
 		publisher.setName( "name" );
 		s.save( publisher );
 		assertTrue( "autoflush entity create", s.createQuery( "from Publisher p" ).list().size() == 1 );
 		publisher.setName( "name" );
 		assertTrue( "autoflush entity update", s.createQuery( "from Publisher p where p.name='name'" ).list().size() == 1 );
 		UnrelatedEntity unrelatedEntity = new UnrelatedEntity( );
 		s.save( unrelatedEntity );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		unrelatedEntity = (UnrelatedEntity) s.get( UnrelatedEntity.class, unrelatedEntity.getId() );
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		assertTrue( publisher.getAuthors().isEmpty() );
 
 		final PersistenceContext persistenceContext = ( (SessionImplementor) s ).getPersistenceContext();
 		final ActionQueue actionQueue = ( (SessionImpl) s ).getActionQueue();
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Author author1 = new Author( );
 		author1.setPublisher( publisher );
 		publisher.getAuthors().add( author1 );
 		assertTrue(	s.createQuery( "from UnrelatedEntity" ).list().size() == 1 );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		author1.setPublisher( null );
 		s.delete( author1 );
 		publisher.getAuthors().clear();
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 		assertTrue( s.createQuery( "from UnrelatedEntity" ).list().size() == 1 );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Set<Author> authorsOld = publisher.getAuthors();
 		publisher.setAuthors( new HashSet<Author>() );
 		Author author2 = new Author( );
 		author2.setName( "author2" );
 		author2.setPublisher( publisher );
 		publisher.getAuthors().add( author2 );
 		List results = s.createQuery( "from UnrelatedEntity" ).list();
 		assertEquals( 1, results.size() );
 		assertEquals( 4, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( authorsOld ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( authorsOld ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.flush();
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author2.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.delete(publisher);
 		assertTrue( "autoflush delete", s.createQuery( "from UnrelatedEntity" ).list().size()==1 );
 		s.delete( unrelatedEntity );
 		txn.commit();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { Author.class, Book.class, Publisher.class, UnrelatedEntity.class };
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
-					@Override
-					public void integrate(
-							MetadataImplementor metadata,
-							SessionFactoryImplementor sessionFactory,
-							SessionFactoryServiceRegistry serviceRegistry) {
-						integrate( serviceRegistry );
-					}
-
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class )
 								.getEventListenerGroup( EventType.PRE_UPDATE )
 								.appendListener( InitializingPreUpdateEventListener.INSTANCE );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	public static class InitializingPreUpdateEventListener implements PreUpdateEventListener {
 		public static final InitializingPreUpdateEventListener INSTANCE = new InitializingPreUpdateEventListener();
 
 		private boolean executed = false;
 		private boolean foundAny = false;
 
 		@Override
 		public boolean onPreUpdate(PreUpdateEvent event) {
 			executed = true;
 
 			final Object[] oldValues = event.getOldState();
 			final String[] properties = event.getPersister().getPropertyNames();
 
 			// Iterate through all fields of the updated object
 			for ( int i = 0; i < properties.length; i++ ) {
 				if ( oldValues != null && oldValues[i] != null ) {
 					if ( ! Hibernate.isInitialized( oldValues[i] ) ) {
 						// force any proxies and/or collections to initialize to illustrate HHH-2763
 						foundAny = true;
 						Hibernate.initialize( oldValues );
 					}
 				}
 			}
 			return true;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
index 8170107e61..c1ce39cd6e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
@@ -1,152 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PreUpdateEvent;
 import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 @TestForIssue( jiraKey = "HHH-2763" )
 public class TestCollectionInitializingDuringFlush extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testInitializationDuringFlush() {
 		assertFalse( InitializingPreUpdateEventListener.INSTANCE.executed );
 		assertFalse( InitializingPreUpdateEventListener.INSTANCE.foundAny );
 
 		Session s = openSession();
 		s.beginTransaction();
 		Publisher publisher = new Publisher( "acme" );
 		Author author = new Author( "john" );
 		author.setPublisher( publisher );
 		publisher.getAuthors().add( author );
 		author.getBooks().add( new Book( "Reflections on a Wimpy Kid", author ) );
 		s.save( author );
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		publisher.setName( "random nally" );
 		s.flush();
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( author );
 		s.getTransaction().commit();
 		s.clear();
 
 		assertTrue( InitializingPreUpdateEventListener.INSTANCE.executed );
 		assertTrue( InitializingPreUpdateEventListener.INSTANCE.foundAny );
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { Author.class, Book.class, Publisher.class };
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
-					@Override
-					public void integrate(
-							MetadataImplementor metadata,
-							SessionFactoryImplementor sessionFactory,
-							SessionFactoryServiceRegistry serviceRegistry) {
-						integrate( serviceRegistry );
-					}
-
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class )
 								.getEventListenerGroup( EventType.PRE_UPDATE )
 								.appendListener( InitializingPreUpdateEventListener.INSTANCE );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	public static class InitializingPreUpdateEventListener implements PreUpdateEventListener {
 		public static final InitializingPreUpdateEventListener INSTANCE = new InitializingPreUpdateEventListener();
 
 		private boolean executed = false;
 		private boolean foundAny = false;
 
 		@Override
 		public boolean onPreUpdate(PreUpdateEvent event) {
 			executed = true;
 
 			final Object[] oldValues = event.getOldState();
 			final String[] properties = event.getPersister().getPropertyNames();
 
 			// Iterate through all fields of the updated object
 			for ( int i = 0; i < properties.length; i++ ) {
 				if ( oldValues != null && oldValues[i] != null ) {
 					if ( ! Hibernate.isInitialized( oldValues[i] ) ) {
 						// force any proxies and/or collections to initialize to illustrate HHH-2763
 						foundAny = true;
 						Hibernate.initialize( oldValues );
 					}
 				}
 			}
 			return true;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
index 06ec5a95ea..7f89c61ab3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
@@ -1,192 +1,183 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jpa;
 
 import java.io.Serializable;
 import java.util.IdentityHashMap;
 import javax.persistence.EntityNotFoundException;
 
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.internal.DefaultAutoFlushEventListener;
 import org.hibernate.event.internal.DefaultFlushEntityEventListener;
 import org.hibernate.event.internal.DefaultFlushEventListener;
 import org.hibernate.event.internal.DefaultPersistEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.AutoFlushEventListener;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.FlushEntityEventListener;
 import org.hibernate.event.spi.FlushEventListener;
 import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * An abstract test for all JPA spec related tests.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractJPATest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "jpa/Part.hbm.xml", "jpa/Item.hbm.xml", "jpa/MyEntity.hbm.xml" };
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.JPAQL_STRICT_COMPLIANCE, "true" );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "false" );
 		cfg.setEntityNotFoundDelegate( new JPAEntityNotFoundDelegate() );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
-					@Override
-					public void integrate(
-							MetadataImplementor metadata,
-							SessionFactoryImplementor sessionFactory,
-							SessionFactoryServiceRegistry serviceRegistry) {
-						integrate( serviceRegistry );
-					}
-
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 						eventListenerRegistry.setListeners( EventType.PERSIST, buildPersistEventListeners() );
 						eventListenerRegistry.setListeners(
 								EventType.PERSIST_ONFLUSH, buildPersisOnFlushEventListeners()
 						);
 						eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, buildAutoFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH, buildFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, buildFlushEntityEventListeners() );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		// no second level caching
 		return null;
 	}
 
 
 	// mimic specific exception aspects of the JPA environment ~~~~~~~~~~~~~~~~
 
 	private static class JPAEntityNotFoundDelegate implements EntityNotFoundDelegate {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException("Unable to find " + entityName  + " with id " + id);
 		}
 	}
 
 	// mimic specific event aspects of the JPA environment ~~~~~~~~~~~~~~~~~~~~
 
 	protected PersistEventListener[] buildPersistEventListeners() {
 		return new PersistEventListener[] { new JPAPersistEventListener() };
 	}
 
 	protected PersistEventListener[] buildPersisOnFlushEventListeners() {
 		return new PersistEventListener[] { new JPAPersistOnFlushEventListener() };
 	}
 
 	protected AutoFlushEventListener[] buildAutoFlushEventListeners() {
 		return new AutoFlushEventListener[] { JPAAutoFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEventListener[] buildFlushEventListeners() {
 		return new FlushEventListener[] { JPAFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEntityEventListener[] buildFlushEntityEventListeners() {
 		return new FlushEntityEventListener[] { new JPAFlushEntityEventListener() };
 	}
 
 	public static class JPAPersistEventListener extends DefaultPersistEventListener {
 		// overridden in JPA impl for entity callbacks...
 	}
 
 	public static class JPAPersistOnFlushEventListener extends JPAPersistEventListener {
 		@Override
         protected CascadingAction getCascadeAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 	}
 
 	public static class JPAAutoFlushEventListener extends DefaultAutoFlushEventListener {
 		// not sure why EM code has this ...
 		public static final AutoFlushEventListener INSTANCE = new JPAAutoFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return new IdentityHashMap( 10 );
 		}
 	}
 
 	public static class JPAFlushEventListener extends DefaultFlushEventListener {
 		// not sure why EM code has this ...
 		public static final FlushEventListener INSTANCE = new JPAFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return new IdentityHashMap( 10 );
 		}
 	}
 
 	public static class JPAFlushEntityEventListener extends DefaultFlushEntityEventListener {
 		// in JPA, used mainly for preUpdate callbacks...
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
index 6b22592a89..a9606edca0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
@@ -1,210 +1,202 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.keymanytoone.bidir.component;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.internal.DefaultLoadEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.LoadEvent;
 import org.hibernate.event.spi.LoadEventListener;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"unchecked"})
 public class EagerKeyManyToOneTest extends BaseCoreFunctionalTestCase {
 	@Override
     public String[] getMappings() {
 		return new String[] { "keymanytoone/bidir/component/EagerMapping.hbm.xml" };
 	}
 
 	@Override
     public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 				    @Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
                         integrate(serviceRegistry);
 					}
 
-                    @Override
-				    public void integrate( MetadataImplementor metadata,
-				                           SessionFactoryImplementor sessionFactory,
-				                           SessionFactoryServiceRegistry serviceRegistry ) {
-                        integrate(serviceRegistry);
-				    }
-
                     private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                         serviceRegistry.getService( EventListenerRegistry.class ).prependListeners(EventType.LOAD,
                                                                                                    new CustomLoadListener());
                     }
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testSaveCascadedToKeyManyToOne() {
 		sessionFactory().getStatistics().clear();
 
 		// test cascading a save to an association with a key-many-to-one which refers to a
 		// just saved entity
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.flush();
 		assertEquals( 2, sessionFactory().getStatistics().getEntityInsertCount() );
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadingStrategies() {
 		sessionFactory().getStatistics().clear();
 
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		cust = ( Customer ) s.createQuery( "from Customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders as o join fetch o.id.customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createCriteria( Customer.class ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2277")
 	public void testLoadEntityWithEagerFetchingToKeyManyToOneReferenceBackToSelf() {
 		sessionFactory().getStatistics().clear();
 
 		// long winded method name to say that this is a test specifically for HHH-2277 ;)
 		// essentially we have a bidirectional association where one side of the
 		// association is actually part of a composite PK.
 		//
 		// The way these are mapped causes the problem because both sides
 		// are defined as eager which leads to the infinite loop; if only
 		// one side is marked as eager, then all is ok.  In other words the
 		// problem arises when both pieces of instance data are coming from
 		// the same result set.  This is because no "entry" can be placed
 		// into the persistence context for the association with the
 		// composite key because we are in the process of trying to build
 		// the composite-id instance
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		try {
 			cust = ( Customer ) s.get( Customer.class, cust.getId() );
 		}
 		catch( OverflowCondition overflow ) {
 			fail( "get()/load() caused overflow condition" );
 		}
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private static class OverflowCondition extends RuntimeException {
 	}
 
 	private static class CustomLoadListener extends DefaultLoadEventListener {
 		private int internalLoadCount = 0;
 		@Override
         public void onLoad(LoadEvent event, LoadType loadType) throws HibernateException {
 			if ( LoadEventListener.INTERNAL_LOAD_EAGER.getName().equals( loadType.getName() ) ) {
 				internalLoadCount++;
 				if ( internalLoadCount > 10 ) {
 					throw new OverflowCondition();
 				}
 			}
 			super.onLoad( event, loadType );
 			internalLoadCount--;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleEntity.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleEntity.hbm.xml
index 4b95bb2804..0df68d69c4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleEntity.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleEntity.hbm.xml
@@ -1,14 +1,17 @@
 <?xml version="1.0"?>
-<hibernate-mapping package="org.hibernate.test.ops" xmlns="http://www.hibernate.org/xsd/hibernate-mapping"
-                   xsi:schemaLocation="http://www.hibernate.org/xsd/hibernate-mapping hibernate-mapping-4.0.xsd"
-                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+
+<!DOCTYPE hibernate-mapping PUBLIC
+        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
+        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
+
+<hibernate-mapping package="org.hibernate.test.ops">
 
     <class name="SimpleEntity">
 
     	<id name="id">
     		<generator class="assigned"/>
     	</id>
         <property name="name"/>
 	</class>
 
 </hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleOpsTest.java b/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleOpsTest.java
index 61c73d8a11..711e0059bd 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleOpsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ops/SimpleOpsTest.java
@@ -1,126 +1,125 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ops;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gail Badner
  */
 public class SimpleOpsTest extends AbstractOperationTestCase {
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
-		cfg.setProperty( USE_NEW_METADATA_MAPPINGS, "true");
 	}
 
 	public String[] getMappings() {
 		return new String[] { "ops/SimpleEntity.hbm.xml" };
 	}
 
 	@Test
 	public void testBasicOperations() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		SimpleEntity entity = new SimpleEntity(  );
 		entity.setId( 1L );
 		entity.setName( "name" );
 		s.save( entity );
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		clearCounts();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		entity = ( SimpleEntity ) s.get( SimpleEntity.class, entity.getId() );
 		assertEquals( Long.valueOf( 1L ), entity.getId() );
 		assertEquals( "name", entity.getName() );
 		entity.setName( "new name" );
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 1 );
 		assertDeleteCount( 0 );
 
 		clearCounts();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		entity = ( SimpleEntity ) s.load( SimpleEntity.class, entity.getId() );
 		assertFalse( Hibernate.isInitialized( entity ) );
 		assertEquals( Long.valueOf( 1L ), entity.getId() );
 		assertEquals( "new name", entity.getName() );
 		assertTrue( Hibernate.isInitialized( entity ) );
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		entity.setName( "another new name" );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.merge( entity );
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 1 );
 		assertDeleteCount( 0 );
 
 		clearCounts();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		entity = ( SimpleEntity ) s.get( SimpleEntity.class, entity.getId() );
 		assertEquals( Long.valueOf( 1L ), entity.getId() );
 		assertEquals( "another new name", entity.getName() );
 		s.delete( entity );
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/service/TestIntegrator.java b/hibernate-core/src/test/java/org/hibernate/test/service/TestIntegrator.java
index 1ff447eafb..be89e8c5d7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/service/TestIntegrator.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/service/TestIntegrator.java
@@ -1,51 +1,44 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.service;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Brett Meyer
  */
 public class TestIntegrator implements Integrator {
 
 	@Override
 	public void integrate(Configuration configuration, SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		
 	}
 
 	@Override
-	public void integrate(MetadataImplementor metadata, SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		
-	}
-
-	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		
 	}
 
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
index 86d4ee51ff..368da0a42a 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
@@ -1,1324 +1,1351 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.boot.internal;
 
 import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Serializable;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import javax.persistence.AttributeConverter;
+import javax.persistence.Converter;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.EntityNotFoundException;
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import javax.sql.DataSource;
 
+import org.hibernate.AssertionFailure;
 import org.hibernate.Interceptor;
 import org.hibernate.InvalidMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.boot.registry.selector.spi.StrategySelector;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.beanvalidation.BeanValidationIntegrator;
 import org.hibernate.cfg.naming.NamingStrategyDelegator;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.scan.internal.StandardScanOptions;
 import org.hibernate.jpa.boot.scan.internal.StandardScanner;
 import org.hibernate.jpa.boot.scan.spi.ScanOptions;
 import org.hibernate.jpa.boot.scan.spi.ScanResult;
 import org.hibernate.jpa.boot.scan.spi.Scanner;
 import org.hibernate.jpa.boot.spi.ClassDescriptor;
 import org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;
 import org.hibernate.jpa.boot.spi.InputStreamAccess;
 import org.hibernate.jpa.boot.spi.IntegratorProvider;
 import org.hibernate.jpa.boot.spi.MappingFileDescriptor;
 import org.hibernate.jpa.boot.spi.NamedInputStream;
 import org.hibernate.jpa.boot.spi.PackageDescriptor;
 import org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;
 import org.hibernate.jpa.boot.spi.StrategyRegistrationProviderList;
 import org.hibernate.jpa.boot.spi.TypeContributorList;
 import org.hibernate.jpa.event.spi.JpaIntegrator;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.internal.schemagen.JpaSchemaGenerator;
 import org.hibernate.jpa.internal.util.LogHelper;
 import org.hibernate.jpa.internal.util.PersistenceUnitTransactionTypeHelper;
 import org.hibernate.jpa.spi.IdentifierGeneratorStrategyProvider;
-import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.spi.GrantedPermission;
 import org.hibernate.secure.spi.JaccService;
 import org.hibernate.service.ConfigLoader;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 import org.jboss.jandex.AnnotationInstance;
+import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.IndexView;
 import org.jboss.jandex.Indexer;
 import org.jboss.logging.Logger;
 
 /**
  * @author Steve Ebersole
  */
 public class EntityManagerFactoryBuilderImpl implements EntityManagerFactoryBuilder {
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(
 			EntityManagerMessageLogger.class,
 			EntityManagerFactoryBuilderImpl.class.getName()
 	);
 
 	private static final String META_INF_ORM_XML = "META-INF/orm.xml";
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// New settings
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	/**
 	 * Names a {@link IntegratorProvider}
 	 */
 	public static final String INTEGRATOR_PROVIDER = "hibernate.integrator_provider";
 	
 	/**
 	 * Names a {@link StrategyRegistrationProviderList}
 	 */
 	public static final String STRATEGY_REGISTRATION_PROVIDERS = "hibernate.strategy_registration_provider";
 	
 	/**
 	 * Names a {@link TypeContributorList}
 	 */
 	public static final String TYPE_CONTRIBUTORS = "hibernate.type_contributors";
 
 	/**
 	 * Names a Jandex {@link Index} instance to use.
 	 */
 	public static final String JANDEX_INDEX = "hibernate.jandex_index";
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Explicit "injectables"
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private Object validatorFactory;
 	private DataSource dataSource;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final PersistenceUnitDescriptor persistenceUnit;
 	private final SettingsImpl settings = new SettingsImpl();
 	private final StandardServiceRegistryBuilder serviceRegistryBuilder;
 	private final Map configurationValues;
 
 	private final List<GrantedPermission> grantedJaccPermissions = new ArrayList<GrantedPermission>();
 	private final List<CacheRegionDefinition> cacheRegionDefinitions = new ArrayList<CacheRegionDefinition>();
 	// todo : would much prefer this as a local variable...
 	private final List<JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping> cfgXmlNamedMappings = new ArrayList<JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping>();
 	private Interceptor sessionFactoryInterceptor;
 	private NamingStrategy namingStrategy;
 	private NamingStrategyDelegator namingStrategyDelegator;
 	private SessionFactoryObserver suppliedSessionFactoryObserver;
 
 	private MetadataSources metadataSources;
 	private Configuration hibernateConfiguration;
 
 	private static EntityNotFoundDelegate jpaEntityNotFoundDelegate = new JpaEntityNotFoundDelegate();
 	
 	private ClassLoader providedClassLoader;
 
 	private static class JpaEntityNotFoundDelegate implements EntityNotFoundDelegate, Serializable {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException( "Unable to find " + entityName  + " with id " + id );
 		}
 	}
 
 	public EntityManagerFactoryBuilderImpl(PersistenceUnitDescriptor persistenceUnit, Map integrationSettings) {
 		this( persistenceUnit, integrationSettings, null );
 	}
 
 	public EntityManagerFactoryBuilderImpl(
 			PersistenceUnitDescriptor persistenceUnit,
 			Map integrationSettings,
 			ClassLoader providedClassLoader ) {
 		
 		LogHelper.logPersistenceUnitInformation( persistenceUnit );
 
 		this.persistenceUnit = persistenceUnit;
 
 		if ( integrationSettings == null ) {
 			integrationSettings = Collections.emptyMap();
 		}
 		
 		this.providedClassLoader = providedClassLoader;
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// First we build the boot-strap service registry, which mainly handles class loader interactions
 		final BootstrapServiceRegistry bootstrapServiceRegistry = buildBootstrapServiceRegistry( integrationSettings );
 		// And the main service registry.  This is needed to start adding configuration values, etc
 		this.serviceRegistryBuilder = new StandardServiceRegistryBuilder( bootstrapServiceRegistry );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Next we build a merged map of all the configuration values
 		this.configurationValues = mergePropertySources( persistenceUnit, integrationSettings, bootstrapServiceRegistry );
 		// add all merged configuration values into the service registry builder
 		this.serviceRegistryBuilder.applySettings( configurationValues );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Next we do a preliminary pass at metadata processing, which involves:
 		//		1) scanning
 		final ScanResult scanResult = scan( bootstrapServiceRegistry );
 		final DeploymentResources deploymentResources = buildDeploymentResources( scanResult, bootstrapServiceRegistry );
 		//		2) building a Jandex index
 		final IndexView jandexIndex = locateOrBuildJandexIndex( deploymentResources );
 		//		3) building "metadata sources" to keep for later to use in building the SessionFactory
 		metadataSources = prepareMetadataSources( jandexIndex, deploymentResources, bootstrapServiceRegistry );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		withValidatorFactory( configurationValues.get( AvailableSettings.VALIDATION_FACTORY ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// push back class transformation to the environment; for the time being this only has any effect in EE
 		// container situations, calling back into PersistenceUnitInfo#addClassTransformer
 		final boolean useClassTransformer = "true".equals( configurationValues.remove( AvailableSettings.USE_CLASS_ENHANCER ) );
 		if ( useClassTransformer ) {
 			persistenceUnit.pushClassTransformer( metadataSources.collectMappingClassNames() );
 		}
 	}
 
 	private static interface DeploymentResources {
 		public Iterable<ClassDescriptor> getClassDescriptors();
 		public Iterable<PackageDescriptor> getPackageDescriptors();
 		public Iterable<MappingFileDescriptor> getMappingFileDescriptors();
 	}
 
 	private DeploymentResources buildDeploymentResources(
 			ScanResult scanResult,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 
 		// mapping files ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		final ArrayList<MappingFileDescriptor> mappingFileDescriptors = new ArrayList<MappingFileDescriptor>();
 
 		final Set<String> nonLocatedMappingFileNames = new HashSet<String>();
 		final List<String> explicitMappingFileNames = persistenceUnit.getMappingFileNames();
 		if ( explicitMappingFileNames != null ) {
 			nonLocatedMappingFileNames.addAll( explicitMappingFileNames );
 		}
 
 		for ( MappingFileDescriptor mappingFileDescriptor : scanResult.getLocatedMappingFiles() ) {
 			mappingFileDescriptors.add( mappingFileDescriptor );
 			nonLocatedMappingFileNames.remove( mappingFileDescriptor.getName() );
 		}
 
 		for ( String name : nonLocatedMappingFileNames ) {
 			MappingFileDescriptor descriptor = buildMappingFileDescriptor( name, bootstrapServiceRegistry );
 			mappingFileDescriptors.add( descriptor );
 		}
 
 
 		// classes and packages ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		final HashMap<String, ClassDescriptor> classDescriptorMap = new HashMap<String, ClassDescriptor>();
 		final HashMap<String, PackageDescriptor> packageDescriptorMap = new HashMap<String, PackageDescriptor>();
 
 		for ( ClassDescriptor classDescriptor : scanResult.getLocatedClasses() ) {
 			classDescriptorMap.put( classDescriptor.getName(), classDescriptor );
 		}
 
 		for ( PackageDescriptor packageDescriptor : scanResult.getLocatedPackages() ) {
 			packageDescriptorMap.put( packageDescriptor.getName(), packageDescriptor );
 		}
 
 		final List<String> explicitClassNames = persistenceUnit.getManagedClassNames();
 		if ( explicitClassNames != null ) {
 			for ( String explicitClassName : explicitClassNames ) {
 				// IMPL NOTE : explicitClassNames can contain class or package names!!!
 				if ( classDescriptorMap.containsKey( explicitClassName ) ) {
 					continue;
 				}
 				if ( packageDescriptorMap.containsKey( explicitClassName ) ) {
 					continue;
 				}
 
 				// try it as a class name first...
 				final String classFileName = explicitClassName.replace( '.', '/' ) + ".class";
 				final URL classFileUrl = bootstrapServiceRegistry.getService( ClassLoaderService.class )
 						.locateResource( classFileName );
 				if ( classFileUrl != null ) {
 					classDescriptorMap.put(
 							explicitClassName,
 							new ClassDescriptorImpl( explicitClassName, new UrlInputStreamAccess( classFileUrl ) )
 					);
 					continue;
 				}
 
 				// otherwise, try it as a package name
 				final String packageInfoFileName = explicitClassName.replace( '.', '/' ) + "/package-info.class";
 				final URL packageInfoFileUrl = bootstrapServiceRegistry.getService( ClassLoaderService.class )
 						.locateResource( packageInfoFileName );
 				if ( packageInfoFileUrl != null ) {
 					packageDescriptorMap.put(
 							explicitClassName,
 							new PackageDescriptorImpl( explicitClassName, new UrlInputStreamAccess( packageInfoFileUrl ) )
 					);
 					continue;
 				}
 
 				LOG.debugf(
 						"Unable to resolve class [%s] named in persistence unit [%s]",
 						explicitClassName,
 						persistenceUnit.getName()
 				);
 			}
 		}
 
 		return new DeploymentResources() {
 			@Override
 			public Iterable<ClassDescriptor> getClassDescriptors() {
 				return classDescriptorMap.values();
 			}
 
 			@Override
 			public Iterable<PackageDescriptor> getPackageDescriptors() {
 				return packageDescriptorMap.values();
 			}
 
 			@Override
 			public Iterable<MappingFileDescriptor> getMappingFileDescriptors() {
 				return mappingFileDescriptors;
 			}
 		};
 	}
 
 	private MappingFileDescriptor buildMappingFileDescriptor(
 			String name,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final URL url = bootstrapServiceRegistry.getService( ClassLoaderService.class ).locateResource( name );
 		if ( url == null ) {
 			throw persistenceException( "Unable to resolve named mapping-file [" + name + "]" );
 		}
 
 		return new MappingFileDescriptorImpl( name, new UrlInputStreamAccess( url ) );
 	}
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// temporary!
 	@SuppressWarnings("unchecked")
 	public Map getConfigurationValues() {
 		return Collections.unmodifiableMap( configurationValues );
 	}
 
 	public Configuration getHibernateConfiguration() {
 		return hibernateConfiguration;
 	}
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
+	private final DotName CONVERTER_DOT_NAME = DotName.createSimple( Converter.class.getName() );
+
 	@SuppressWarnings("unchecked")
 	private MetadataSources prepareMetadataSources(
 			IndexView jandexIndex,
 			DeploymentResources deploymentResources,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 		// todo : this needs to tie into the metamodel branch...
 		MetadataSources metadataSources = new MetadataSources();
 
 		for ( ClassDescriptor classDescriptor : deploymentResources.getClassDescriptors() ) {
 			final String className = classDescriptor.getName();
 			final ClassInfo classInfo = jandexIndex.getClassByName( DotName.createSimple( className ) );
 			if ( classInfo == null ) {
 				// Not really sure what this means.  Most likely it is explicitly listed in the persistence unit,
 				// but mapped via mapping file.  Anyway assume its a mapping class...
 				metadataSources.annotatedMappingClassNames.add( className );
 				continue;
 			}
 
 			// logic here assumes an entity is not also a converter...
-			AnnotationInstance converterAnnotation = JandexHelper.getSingleAnnotation(
+			AnnotationInstance converterAnnotation = getSingleAnnotation(
 					classInfo.annotations(),
-					JPADotNames.CONVERTER
+					CONVERTER_DOT_NAME
 			);
 			if ( converterAnnotation != null ) {
 				metadataSources.converterDescriptors.add(
 						new MetadataSources.ConverterDescriptor(
 								className,
-								JandexHelper.getValue( converterAnnotation, "autoApply", boolean.class,
-										bootstrapServiceRegistry.getService( ClassLoaderService.class ) )
+								asBoolean( converterAnnotation.value( "autoApply" ) )
 						)
 				);
 			}
 			else {
 				metadataSources.annotatedMappingClassNames.add( className );
 			}
 		}
 
 		for ( PackageDescriptor packageDescriptor : deploymentResources.getPackageDescriptors() ) {
 			metadataSources.packageNames.add( packageDescriptor.getName() );
 		}
 
 		for ( MappingFileDescriptor mappingFileDescriptor : deploymentResources.getMappingFileDescriptors() ) {
 			metadataSources.namedMappingFileInputStreams.add( mappingFileDescriptor.getStreamAccess().asNamedInputStream() );
 		}
 
 		final String explicitHbmXmls = (String) configurationValues.remove( AvailableSettings.HBXML_FILES );
 		if ( explicitHbmXmls != null ) {
 			metadataSources.mappingFileResources.addAll( Arrays.asList( StringHelper.split( ", ", explicitHbmXmls ) ) );
 		}
 
 		final List<String> explicitOrmXml = (List<String>) configurationValues.remove( AvailableSettings.XML_FILE_NAMES );
 		if ( explicitOrmXml != null ) {
 			metadataSources.mappingFileResources.addAll( explicitOrmXml );
 		}
 
 		return metadataSources;
 	}
 
+	private boolean asBoolean(AnnotationValue value) {
+		return value != null && value.asBoolean();
+	}
+
+	public static AnnotationInstance getSingleAnnotation(
+			Map<DotName, List<AnnotationInstance>> annotations,
+			DotName annotationName) throws AssertionFailure {
+		List<AnnotationInstance> annotationList = annotations.get( annotationName );
+		if ( annotationList == null ) {
+			// we found no annotations of the given annotation type
+			return null;
+		}
+		if ( annotationList.size() == 0 ) {
+			return null;
+		}
+		else if ( annotationList.size() == 1 ) {
+			return annotationList.get( 0 );
+		}
+		else {
+			throw new AssertionFailure(
+					"Found more than one instance of the annotation " + annotationName.toString()
+			);
+		}
+	}
+
 	private IndexView locateOrBuildJandexIndex(DeploymentResources deploymentResources) {
 		// for now create a whole new Index to work with, eventually we need to:
 		//		1) accept an Index as an incoming config value
 		//		2) pass that Index along to the metamodel code...
 		IndexView jandexIndex = (IndexView) configurationValues.get( JANDEX_INDEX );
 		if ( jandexIndex == null ) {
 			jandexIndex = buildJandexIndex( deploymentResources );
 		}
 		return jandexIndex;
 	}
 
 	private IndexView buildJandexIndex(DeploymentResources deploymentResources) {
 		Indexer indexer = new Indexer();
 
 		for ( ClassDescriptor classDescriptor : deploymentResources.getClassDescriptors() ) {
 			indexStream( indexer, classDescriptor.getStreamAccess() );
 		}
 
 		for ( PackageDescriptor packageDescriptor : deploymentResources.getPackageDescriptors() ) {
 			indexStream( indexer, packageDescriptor.getStreamAccess() );
 		}
 
 		// for now we just skip entities defined in (1) orm.xml files and (2) hbm.xml files.  this part really needs
 		// metamodel branch...
 
 		// for now, we also need to wrap this in a CompositeIndex until Jandex is updated to use a common interface
 		// between the 2...
 		return indexer.complete();
 	}
 
 	private void indexStream(Indexer indexer, InputStreamAccess streamAccess) {
 		try {
 			InputStream stream = streamAccess.accessInputStream();
 			try {
 				indexer.index( stream );
 			}
 			finally {
 				try {
 					stream.close();
 				}
 				catch (Exception ignore) {
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw persistenceException( "Unable to index from stream " + streamAccess.getStreamName(), e );
 		}
 	}
 
 	/**
 	 * Builds the {@link BootstrapServiceRegistry} used to eventually build the {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder}; mainly
 	 * used here during instantiation to define class-loading behavior.
 	 *
 	 * @param integrationSettings Any integration settings passed by the EE container or SE application
 	 *
 	 * @return The built BootstrapServiceRegistry
 	 */
 	private BootstrapServiceRegistry buildBootstrapServiceRegistry(Map integrationSettings) {
 		final BootstrapServiceRegistryBuilder bootstrapServiceRegistryBuilder = new BootstrapServiceRegistryBuilder();
 		bootstrapServiceRegistryBuilder.with( new JpaIntegrator() );
 
 		final IntegratorProvider integratorProvider = (IntegratorProvider) integrationSettings.get( INTEGRATOR_PROVIDER );
 		if ( integratorProvider != null ) {
 			for ( Integrator integrator : integratorProvider.getIntegrators() ) {
 				bootstrapServiceRegistryBuilder.with( integrator );
 			}
 		}
 		
 		final StrategyRegistrationProviderList strategyRegistrationProviderList
 				= (StrategyRegistrationProviderList) integrationSettings.get( STRATEGY_REGISTRATION_PROVIDERS );
 		if ( strategyRegistrationProviderList != null ) {
 			for ( StrategyRegistrationProvider strategyRegistrationProvider : strategyRegistrationProviderList
 					.getStrategyRegistrationProviders() ) {
 				bootstrapServiceRegistryBuilder.withStrategySelectors( strategyRegistrationProvider );
 			}
 		}
 
 		// TODO: If providedClassLoader is present (OSGi, etc.) *and*
 		// an APP_CLASSLOADER is provided, should throw an exception or
 		// warn?
 		ClassLoader classLoader;
 		ClassLoader appClassLoader = (ClassLoader) integrationSettings.get( org.hibernate.cfg.AvailableSettings.APP_CLASSLOADER );
 		if ( providedClassLoader != null ) {
 			classLoader = providedClassLoader;
 		}
 		else if ( appClassLoader != null ) {
 			classLoader = appClassLoader;
 		}
 		else {
 			classLoader = persistenceUnit.getClassLoader();
 		}
 		bootstrapServiceRegistryBuilder.with( classLoader );
 
 		return bootstrapServiceRegistryBuilder.build();
 	}
 
 	@SuppressWarnings("unchecked")
 	private Map mergePropertySources(
 			PersistenceUnitDescriptor persistenceUnit,
 			Map integrationSettings,
 			final BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final Map merged = new HashMap();
 		// first, apply persistence.xml-defined settings
 		if ( persistenceUnit.getProperties() != null ) {
 			merged.putAll( persistenceUnit.getProperties() );
 		}
 
 		merged.put( AvailableSettings.PERSISTENCE_UNIT_NAME, persistenceUnit.getName() );
 
 		// see if the persistence.xml settings named a Hibernate config file....
 		final ValueHolder<ConfigLoader> configLoaderHolder = new ValueHolder<ConfigLoader>(
 				new ValueHolder.DeferredInitializer<ConfigLoader>() {
 					@Override
 					public ConfigLoader initialize() {
 						return new ConfigLoader( bootstrapServiceRegistry );
 					}
 				}
 		);
 
 		final String cfgXmlResourceName1 = (String) merged.remove( AvailableSettings.CFG_FILE );
 		if ( StringHelper.isNotEmpty( cfgXmlResourceName1 ) ) {
 			// it does, so load those properties
 			JaxbHibernateConfiguration configurationElement = configLoaderHolder.getValue()
 					.loadConfigXmlResource( cfgXmlResourceName1 );
 			processHibernateConfigurationElement( configurationElement, merged );
 		}
 
 		// see if integration settings named a Hibernate config file....
 		final String cfgXmlResourceName2 = (String) integrationSettings.get( AvailableSettings.CFG_FILE );
 		if ( StringHelper.isNotEmpty( cfgXmlResourceName2 ) ) {
 			integrationSettings.remove( AvailableSettings.CFG_FILE );
 			// it does, so load those properties
 			JaxbHibernateConfiguration configurationElement = configLoaderHolder.getValue().loadConfigXmlResource(
 					cfgXmlResourceName2
 			);
 			processHibernateConfigurationElement( configurationElement, merged );
 		}
 
 		// finally, apply integration-supplied settings (per JPA spec, integration settings should override other sources)
 		merged.putAll( integrationSettings );
 
 		if ( !merged.containsKey( AvailableSettings.VALIDATION_MODE ) ) {
 			if ( persistenceUnit.getValidationMode() != null ) {
 				merged.put( AvailableSettings.VALIDATION_MODE, persistenceUnit.getValidationMode() );
 			}
 		}
 
 		if ( !merged.containsKey( AvailableSettings.SHARED_CACHE_MODE ) ) {
 			if ( persistenceUnit.getSharedCacheMode() != null ) {
 				merged.put( AvailableSettings.SHARED_CACHE_MODE, persistenceUnit.getSharedCacheMode() );
 			}
 		}
 
 		// was getting NPE exceptions from the underlying map when just using #putAll, so going this safer route...
 		Iterator itr = merged.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			if ( entry.getValue() == null ) {
 				itr.remove();
 			}
 		}
 
 		return merged;
 	}
 
 	@SuppressWarnings("unchecked")
 	private void processHibernateConfigurationElement(
 			JaxbHibernateConfiguration configurationElement,
 			Map mergeMap) {
 		if ( ! mergeMap.containsKey( org.hibernate.cfg.AvailableSettings.SESSION_FACTORY_NAME ) ) {
 			String cfgName = configurationElement.getSessionFactory().getName();
 			if ( cfgName != null ) {
 				mergeMap.put( org.hibernate.cfg.AvailableSettings.SESSION_FACTORY_NAME, cfgName );
 			}
 		}
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbProperty jaxbProperty : configurationElement.getSessionFactory().getProperty() ) {
 			mergeMap.put( jaxbProperty.getName(), jaxbProperty.getValue() );
 		}
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping jaxbMapping : configurationElement.getSessionFactory().getMapping() ) {
 			cfgXmlNamedMappings.add( jaxbMapping );
 		}
 
 		for ( Object cacheDeclaration : configurationElement.getSessionFactory().getClassCacheOrCollectionCache() ) {
 			if ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache.class.isInstance( cacheDeclaration ) ) {
 				final JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache jaxbClassCache
 						= (JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache) cacheDeclaration;
 				cacheRegionDefinitions.add(
 						new CacheRegionDefinition(
 								CacheRegionDefinition.CacheType.ENTITY,
 								jaxbClassCache.getClazz(),
 								jaxbClassCache.getUsage().value(),
 								jaxbClassCache.getRegion(),
 								"all".equals( jaxbClassCache.getInclude() )
 						)
 				);
 			}
 			else {
 				final JaxbHibernateConfiguration.JaxbSessionFactory.JaxbCollectionCache jaxbCollectionCache
 						= (JaxbHibernateConfiguration.JaxbSessionFactory.JaxbCollectionCache) cacheDeclaration;
 				cacheRegionDefinitions.add(
 						new CacheRegionDefinition(
 								CacheRegionDefinition.CacheType.COLLECTION,
 								jaxbCollectionCache.getCollection(),
 								jaxbCollectionCache.getUsage().value(),
 								jaxbCollectionCache.getRegion(),
 								false
 						)
 				);
 			}
 		}
 
 		if ( configurationElement.getSecurity() != null ) {
 			for ( JaxbHibernateConfiguration.JaxbSecurity.JaxbGrant grant : configurationElement.getSecurity().getGrant() ) {
 				grantedJaccPermissions.add(
 						new GrantedPermission(
 								grant.getRole(),
 								grant.getEntityName(),
 								grant.getActions()
 						)
 				);
 			}
 		}
 	}
 
 	private String jaccContextId;
 
 	private void addJaccDefinition(String key, Object value) {
 		if ( jaccContextId == null ) {
 			jaccContextId = (String) configurationValues.get( AvailableSettings.JACC_CONTEXT_ID );
 			if ( jaccContextId == null ) {
 				throw persistenceException(
 						"Entities have been configured for JACC, but "
 								+ AvailableSettings.JACC_CONTEXT_ID + " has not been set"
 				);
 			}
 		}
 
 		try {
 			final int roleStart = AvailableSettings.JACC_PREFIX.length() + 1;
 			final String role = key.substring( roleStart, key.indexOf( '.', roleStart ) );
 			final int classStart = roleStart + role.length() + 1;
 			final String clazz = key.substring( classStart, key.length() );
 
 			grantedJaccPermissions.add( new GrantedPermission( role, clazz, (String) value ) );
 		}
 		catch ( IndexOutOfBoundsException e ) {
 			throw persistenceException( "Illegal usage of " + AvailableSettings.JACC_PREFIX + ": " + key );
 		}
 	}
 
 	private void addCacheRegionDefinition(String role, String value, CacheRegionDefinition.CacheType cacheType) {
 		final StringTokenizer params = new StringTokenizer( value, ";, " );
 		if ( !params.hasMoreTokens() ) {
 			StringBuilder error = new StringBuilder( "Illegal usage of " );
 			if ( cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 				error.append( AvailableSettings.CLASS_CACHE_PREFIX )
 						.append( ": " )
 						.append( AvailableSettings.CLASS_CACHE_PREFIX );
 			}
 			else {
 				error.append( AvailableSettings.COLLECTION_CACHE_PREFIX )
 						.append( ": " )
 						.append( AvailableSettings.COLLECTION_CACHE_PREFIX );
 			}
 			error.append( '.' )
 					.append( role )
 					.append( ' ' )
 					.append( value )
 					.append( ".  Was expecting configuration, but found none" );
 			throw persistenceException( error.toString() );
 		}
 
 		String usage = params.nextToken();
 		String region = null;
 		if ( params.hasMoreTokens() ) {
 			region = params.nextToken();
 		}
 		boolean lazyProperty = true;
 		if ( cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 			if ( params.hasMoreTokens() ) {
 				lazyProperty = "all".equalsIgnoreCase( params.nextToken() );
 			}
 		}
 		else {
 			lazyProperty = false;
 		}
 
 		final CacheRegionDefinition def = new CacheRegionDefinition( cacheType, role, usage, region, lazyProperty );
 		cacheRegionDefinitions.add( def );
 	}
 
 	@SuppressWarnings("unchecked")
 	private ScanResult scan(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final Scanner scanner = locateOrBuildScanner( bootstrapServiceRegistry );
 		final ScanOptions scanOptions = determineScanOptions();
 
 		return scanner.scan( persistenceUnit, scanOptions );
 	}
 
 	private ScanOptions determineScanOptions() {
 		return new StandardScanOptions(
 				(String) configurationValues.get( AvailableSettings.AUTODETECTION ),
 				persistenceUnit.isExcludeUnlistedClasses()
 		);
 	}
 
 	@SuppressWarnings("unchecked")
 	private Scanner locateOrBuildScanner(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final Object value = configurationValues.remove( AvailableSettings.SCANNER );
 		if ( value == null ) {
 			return new StandardScanner();
 		}
 
 		if ( Scanner.class.isInstance( value ) ) {
 			return (Scanner) value;
 		}
 
 		Class<? extends Scanner> scannerClass;
 		if ( Class.class.isInstance( value ) ) {
 			try {
 				scannerClass = (Class<? extends Scanner>) value;
 			}
 			catch ( ClassCastException e ) {
 				throw persistenceException( "Expecting Scanner implementation, but found " + ((Class) value).getName() );
 			}
 		}
 		else {
 			final String scannerClassName = value.toString();
 			try {
 				scannerClass = bootstrapServiceRegistry.getService( ClassLoaderService.class ).classForName( scannerClassName );
 			}
 			catch ( ClassCastException e ) {
 				throw persistenceException( "Expecting Scanner implementation, but found " + scannerClassName );
 			}
 		}
 
 		try {
 			return scannerClass.newInstance();
 		}
 		catch ( Exception e ) {
 			throw persistenceException( "Unable to instantiate Scanner class: " + scannerClass, e );
 		}
 	}
 
 	@Override
 	public EntityManagerFactoryBuilder withValidatorFactory(Object validatorFactory) {
 		this.validatorFactory = validatorFactory;
 
 		if ( validatorFactory != null ) {
 			BeanValidationIntegrator.validateFactory( validatorFactory );
 		}
 		return this;
 	}
 
 	@Override
 	public EntityManagerFactoryBuilder withDataSource(DataSource dataSource) {
 		this.dataSource = dataSource;
 
 		return this;
 	}
 
 	@Override
 	public void cancel() {
 		// todo : close the bootstrap registry (not critical, but nice to do)
 
 	}
 
 	@Override
 	public void generateSchema() {
 		processProperties();
 
 		final ServiceRegistry serviceRegistry = buildServiceRegistry();
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		// IMPL NOTE : TCCL handling here is temporary.
 		//		It is needed because this code still uses Hibernate Configuration and Hibernate commons-annotations
 		// 		in turn which relies on TCCL being set.
 
 		( (ClassLoaderServiceImpl) classLoaderService ).withTccl(
 				new ClassLoaderServiceImpl.Work() {
 					@Override
 					public Object perform() {
 						final Configuration hibernateConfiguration = buildHibernateConfiguration( serviceRegistry );
 						
 						// This seems overkill, but building the SF is necessary to get the Integrators to kick in.
 						// Metamodel will clean this up...
 						try {
 							hibernateConfiguration.buildSessionFactory( serviceRegistry );
 						}
 						catch (MappingException e) {
 							throw persistenceException( "Unable to build Hibernate SessionFactory", e );
 						}
 						
 						JpaSchemaGenerator.performGeneration( hibernateConfiguration, serviceRegistry );
 						
 						return null;
 					}
 				}
 		);
 
 		// release this builder
 		cancel();
 	}
 
 	@SuppressWarnings("unchecked")
 	public EntityManagerFactory build() {
 		processProperties();
 
 		final ServiceRegistry serviceRegistry = buildServiceRegistry();
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		// IMPL NOTE : TCCL handling here is temporary.
 		//		It is needed because this code still uses Hibernate Configuration and Hibernate commons-annotations
 		// 		in turn which relies on TCCL being set.
 
 		return ( (ClassLoaderServiceImpl) classLoaderService ).withTccl(
 				new ClassLoaderServiceImpl.Work<EntityManagerFactoryImpl>() {
 					@Override
 					public EntityManagerFactoryImpl perform() {
 						hibernateConfiguration = buildHibernateConfiguration( serviceRegistry );
 
 						SessionFactoryImplementor sessionFactory;
 						try {
 							sessionFactory = (SessionFactoryImplementor) hibernateConfiguration.buildSessionFactory( serviceRegistry );
 						}
 						catch (MappingException e) {
 							throw persistenceException( "Unable to build Hibernate SessionFactory", e );
 						}
 						
 						// must do after buildSessionFactory to let the Integrators kick in
 						JpaSchemaGenerator.performGeneration( hibernateConfiguration, serviceRegistry );
 
 						if ( suppliedSessionFactoryObserver != null ) {
 							sessionFactory.addObserver( suppliedSessionFactoryObserver );
 						}
 						sessionFactory.addObserver( new ServiceRegistryCloser() );
 
 						// NOTE : passing cfg is temporary until
 						return new EntityManagerFactoryImpl(
 								persistenceUnit.getName(),
 								sessionFactory,
 								settings,
 								configurationValues,
 								hibernateConfiguration
 						);
 					}
 				}
 		);
 	}
 
 	private void processProperties() {
 		applyJdbcConnectionProperties();
 		applyTransactionProperties();
 
 		Object validationFactory = this.validatorFactory;
 		if ( validationFactory == null ) {
 			validationFactory = configurationValues.get( AvailableSettings.VALIDATION_FACTORY );
 		}
 		if ( validationFactory != null ) {
 			BeanValidationIntegrator.validateFactory( validationFactory );
 			serviceRegistryBuilder.applySetting( AvailableSettings.VALIDATION_FACTORY, validationFactory );
 			configurationValues.put( AvailableSettings.VALIDATION_FACTORY, this.validatorFactory );
 		}
 
 		// flush before completion validation
 		if ( "true".equals( configurationValues.get( Environment.FLUSH_BEFORE_COMPLETION ) ) ) {
 			serviceRegistryBuilder.applySetting( Environment.FLUSH_BEFORE_COMPLETION, "false" );
 			LOG.definingFlushBeforeCompletionIgnoredInHem( Environment.FLUSH_BEFORE_COMPLETION );
 		}
 
 		final StrategySelector strategySelector = serviceRegistryBuilder.getBootstrapServiceRegistry().getService( StrategySelector.class );
 
 		for ( Object oEntry : configurationValues.entrySet() ) {
 			Map.Entry entry = (Map.Entry) oEntry;
 			if ( entry.getKey() instanceof String ) {
 				final String keyString = (String) entry.getKey();
 
 				if ( AvailableSettings.INTERCEPTOR.equals( keyString ) ) {
 					sessionFactoryInterceptor = strategySelector.resolveStrategy( Interceptor.class, entry.getValue() );
 				}
 				else if ( AvailableSettings.SESSION_INTERCEPTOR.equals( keyString ) ) {
 					settings.setSessionInterceptorClass(
 							loadSessionInterceptorClass( entry.getValue(), strategySelector )
 					);
 				}
 				else if ( AvailableSettings.NAMING_STRATEGY.equals( keyString ) ) {
 					namingStrategy = strategySelector.resolveStrategy( NamingStrategy.class, entry.getValue() );
 				}
 				else if ( AvailableSettings.NAMING_STRATEGY_DELEGATOR.equals( keyString ) ) {
 					namingStrategyDelegator = strategySelector.resolveStrategy( NamingStrategyDelegator.class, entry.getValue() );
 				}
 				else if ( AvailableSettings.SESSION_FACTORY_OBSERVER.equals( keyString ) ) {
 					suppliedSessionFactoryObserver = strategySelector.resolveStrategy( SessionFactoryObserver.class, entry.getValue() );
 				}
 				else if ( AvailableSettings.DISCARD_PC_ON_CLOSE.equals( keyString ) ) {
 					settings.setReleaseResourcesOnCloseEnabled( "true".equals( entry.getValue() ) );
 				}
 				else if ( keyString.startsWith( AvailableSettings.CLASS_CACHE_PREFIX ) ) {
 					addCacheRegionDefinition(
 							keyString.substring( AvailableSettings.CLASS_CACHE_PREFIX.length() + 1 ),
 							(String) entry.getValue(),
 							CacheRegionDefinition.CacheType.ENTITY
 					);
 				}
 				else if ( keyString.startsWith( AvailableSettings.COLLECTION_CACHE_PREFIX ) ) {
 					addCacheRegionDefinition(
 							keyString.substring( AvailableSettings.COLLECTION_CACHE_PREFIX.length() + 1 ),
 							(String) entry.getValue(),
 							CacheRegionDefinition.CacheType.COLLECTION
 					);
 				}
 				else if ( keyString.startsWith( AvailableSettings.JACC_PREFIX )
 						&& ! ( keyString.equals( AvailableSettings.JACC_CONTEXT_ID )
 						|| keyString.equals( AvailableSettings.JACC_ENABLED ) ) ) {
 					addJaccDefinition( (String) entry.getKey(), entry.getValue() );
 				}
 			}
 		}
 	}
 
 	private void applyJdbcConnectionProperties() {
 		if ( dataSource != null ) {
 			serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.DATASOURCE, dataSource );
 		}
 		else if ( persistenceUnit.getJtaDataSource() != null ) {
 			if ( ! serviceRegistryBuilder.getSettings().containsKey( org.hibernate.cfg.AvailableSettings.DATASOURCE ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.DATASOURCE, persistenceUnit.getJtaDataSource() );
 				// HHH-8121 : make the PU-defined value available to EMF.getProperties()
 				configurationValues.put( AvailableSettings.JTA_DATASOURCE, persistenceUnit.getJtaDataSource() );
 			}
 		}
 		else if ( persistenceUnit.getNonJtaDataSource() != null ) {
 			if ( ! serviceRegistryBuilder.getSettings().containsKey( org.hibernate.cfg.AvailableSettings.DATASOURCE ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.DATASOURCE, persistenceUnit.getNonJtaDataSource() );
 				// HHH-8121 : make the PU-defined value available to EMF.getProperties()
 				configurationValues.put( AvailableSettings.NON_JTA_DATASOURCE, persistenceUnit.getNonJtaDataSource() );
 			}
 		}
 		else {
 			final String driver = (String) configurationValues.get( AvailableSettings.JDBC_DRIVER );
 			if ( StringHelper.isNotEmpty( driver ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.DRIVER, driver );
 			}
 			final String url = (String) configurationValues.get( AvailableSettings.JDBC_URL );
 			if ( StringHelper.isNotEmpty( url ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.URL, url );
 			}
 			final String user = (String) configurationValues.get( AvailableSettings.JDBC_USER );
 			if ( StringHelper.isNotEmpty( user ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.USER, user );
 			}
 			final String pass = (String) configurationValues.get( AvailableSettings.JDBC_PASSWORD );
 			if ( StringHelper.isNotEmpty( pass ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.PASS, pass );
 			}
 		}
 	}
 
 	private void applyTransactionProperties() {
 		PersistenceUnitTransactionType txnType = PersistenceUnitTransactionTypeHelper.interpretTransactionType(
 				configurationValues.get( AvailableSettings.TRANSACTION_TYPE )
 		);
 		if ( txnType == null ) {
 			txnType = persistenceUnit.getTransactionType();
 		}
 		if ( txnType == null ) {
 			// is it more appropriate to have this be based on bootstrap entry point (EE vs SE)?
 			txnType = PersistenceUnitTransactionType.RESOURCE_LOCAL;
 		}
 		settings.setTransactionType( txnType );
 		boolean hasTxStrategy = configurationValues.containsKey( Environment.TRANSACTION_STRATEGY );
 		if ( hasTxStrategy ) {
 			LOG.overridingTransactionStrategyDangerous( Environment.TRANSACTION_STRATEGY );
 		}
 		else {
 			if ( txnType == PersistenceUnitTransactionType.JTA ) {
 				serviceRegistryBuilder.applySetting( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class );
 			}
 			else if ( txnType == PersistenceUnitTransactionType.RESOURCE_LOCAL ) {
 				serviceRegistryBuilder.applySetting( Environment.TRANSACTION_STRATEGY, JdbcTransactionFactory.class );
 			}
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	private Class<? extends Interceptor> loadSessionInterceptorClass(Object value, StrategySelector strategySelector) {
 		if ( value == null ) {
 			return null;
 		}
 
 		return Class.class.isInstance( value )
 				? (Class<? extends Interceptor>) value
 				: strategySelector.selectStrategyImplementor( Interceptor.class, value.toString() );
 	}
 
 	public ServiceRegistry buildServiceRegistry() {
 		return serviceRegistryBuilder.build();
 	}
 
 	public Configuration buildHibernateConfiguration(ServiceRegistry serviceRegistry) {
 		Properties props = new Properties();
 		props.putAll( configurationValues );
 		Configuration cfg = new Configuration();
 		cfg.getProperties().putAll( props );
 
 		cfg.setEntityNotFoundDelegate( jpaEntityNotFoundDelegate );
 
 		if ( namingStrategy != null && namingStrategyDelegator != null ) {
 			throw persistenceException(
 					AvailableSettings.NAMING_STRATEGY + " and " + AvailableSettings.NAMING_STRATEGY_DELEGATOR +
 							" properties cannot be used together. To be valid, only one of these properties can be set."
 			);
 		}
 		if ( namingStrategy != null ) {
 			cfg.setNamingStrategy( namingStrategy );
 		}
 		else if ( namingStrategyDelegator != null ) {
 			cfg.setNamingStrategyDelegator( namingStrategyDelegator );
 		}
 
 		if ( sessionFactoryInterceptor != null ) {
 			cfg.setInterceptor( sessionFactoryInterceptor );
 		}
 
 		final Object strategyProviderValue = props.get( AvailableSettings.IDENTIFIER_GENERATOR_STRATEGY_PROVIDER );
 		final IdentifierGeneratorStrategyProvider strategyProvider = strategyProviderValue == null
 				? null
 				: serviceRegistry.getService( StrategySelector.class )
 						.resolveStrategy( IdentifierGeneratorStrategyProvider.class, strategyProviderValue );
 
 		if ( strategyProvider != null ) {
 			final MutableIdentifierGeneratorFactory identifierGeneratorFactory = cfg.getIdentifierGeneratorFactory();
 			for ( Map.Entry<String,Class<?>> entry : strategyProvider.getStrategies().entrySet() ) {
 				identifierGeneratorFactory.register( entry.getKey(), entry.getValue() );
 			}
 		}
 
 		if ( grantedJaccPermissions != null ) {
 			final JaccService jaccService = serviceRegistry.getService( JaccService.class );
 			for ( GrantedPermission grantedPermission : grantedJaccPermissions ) {
 				jaccService.addPermission( grantedPermission );
 			}
 		}
 
 		if ( cacheRegionDefinitions != null ) {
 			for ( CacheRegionDefinition cacheRegionDefinition : cacheRegionDefinitions ) {
 				if ( cacheRegionDefinition.cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 					cfg.setCacheConcurrencyStrategy(
 							cacheRegionDefinition.role,
 							cacheRegionDefinition.usage,
 							cacheRegionDefinition.region,
 							cacheRegionDefinition.cacheLazy
 					);
 				}
 				else {
 					cfg.setCollectionCacheConcurrencyStrategy(
 							cacheRegionDefinition.role,
 							cacheRegionDefinition.usage,
 							cacheRegionDefinition.region
 					);
 				}
 			}
 		}
 
 
 		// todo : need to have this use the metamodel codebase eventually...
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping jaxbMapping : cfgXmlNamedMappings ) {
 			if ( jaxbMapping.getClazz() != null ) {
 				cfg.addAnnotatedClass(
 						serviceRegistry.getService( ClassLoaderService.class ).classForName( jaxbMapping.getClazz() )
 				);
 			}
 			else if ( jaxbMapping.getResource() != null ) {
 				cfg.addResource( jaxbMapping.getResource() );
 			}
 			else if ( jaxbMapping.getJar() != null ) {
 				cfg.addJar( new File( jaxbMapping.getJar() ) );
 			}
 			else if ( jaxbMapping.getPackage() != null ) {
 				cfg.addPackage( jaxbMapping.getPackage() );
 			}
 		}
 
 		List<Class> loadedAnnotatedClasses = (List<Class>) configurationValues.remove( AvailableSettings.LOADED_CLASSES );
 		if ( loadedAnnotatedClasses != null ) {
 			for ( Class cls : loadedAnnotatedClasses ) {
 				if ( AttributeConverter.class.isAssignableFrom( cls ) ) {
 					cfg.addAttributeConverter( (Class<? extends AttributeConverter>) cls );
 				}
 				else {
 					cfg.addAnnotatedClass( cls );
 				}
 			}
 		}
 
 		for ( String className : metadataSources.getAnnotatedMappingClassNames() ) {
 			cfg.addAnnotatedClass( serviceRegistry.getService( ClassLoaderService.class ).classForName( className ) );
 		}
 
 		for ( MetadataSources.ConverterDescriptor converterDescriptor : metadataSources.getConverterDescriptors() ) {
 			final Class<? extends AttributeConverter> converterClass;
 			try {
 				Class theClass = serviceRegistry.getService( ClassLoaderService.class ).classForName( converterDescriptor.converterClassName );
 				converterClass = (Class<? extends AttributeConverter>) theClass;
 			}
 			catch (ClassCastException e) {
 				throw persistenceException(
 						String.format(
 								"AttributeConverter implementation [%s] does not implement AttributeConverter interface",
 								converterDescriptor.converterClassName
 						)
 				);
 			}
 			cfg.addAttributeConverter( converterClass, converterDescriptor.autoApply );
 		}
 
 		for ( String resourceName : metadataSources.mappingFileResources ) {
 			Boolean useMetaInf = null;
 			try {
 				if ( resourceName.endsWith( META_INF_ORM_XML ) ) {
 					useMetaInf = true;
 				}
 				cfg.addResource( resourceName );
 			}
 			catch( MappingNotFoundException e ) {
 				if ( ! resourceName.endsWith( META_INF_ORM_XML ) ) {
 					throw persistenceException( "Unable to find XML mapping file in classpath: " + resourceName );
 				}
 				else {
 					useMetaInf = false;
 					//swallow it, the META-INF/orm.xml is optional
 				}
 			}
 			catch( MappingException me ) {
 				throw persistenceException( "Error while reading JPA XML file: " + resourceName, me );
 			}
 
 			if ( Boolean.TRUE.equals( useMetaInf ) ) {
 				LOG.exceptionHeaderFound( getExceptionHeader(), META_INF_ORM_XML );
 			}
 			else if (Boolean.FALSE.equals(useMetaInf)) {
 				LOG.exceptionHeaderNotFound( getExceptionHeader(), META_INF_ORM_XML );
 			}
 		}
 		for ( NamedInputStream namedInputStream : metadataSources.namedMappingFileInputStreams ) {
 			try {
 				//addInputStream has the responsibility to close the stream
 				cfg.addInputStream( new BufferedInputStream( namedInputStream.getStream() ) );
 			}
 			catch ( InvalidMappingException e ) {
 				// try our best to give the file name
 				if ( StringHelper.isNotEmpty( namedInputStream.getName() ) ) {
 					throw new InvalidMappingException(
 							"Error while parsing file: " + namedInputStream.getName(),
 							e.getType(),
 							e.getPath(),
 							e
 					);
 				}
 				else {
 					throw e;
 				}
 			}
 			catch (MappingException me) {
 				// try our best to give the file name
 				if ( StringHelper.isNotEmpty( namedInputStream.getName() ) ) {
 					throw new MappingException("Error while parsing file: " + namedInputStream.getName(), me );
 				}
 				else {
 					throw me;
 				}
 			}
 		}
 		for ( String packageName : metadataSources.packageNames ) {
 			cfg.addPackage( packageName );
 		}
 		
 		final TypeContributorList typeContributorList
 				= (TypeContributorList) configurationValues.get( TYPE_CONTRIBUTORS );
 		if ( typeContributorList != null ) {
 			configurationValues.remove( TYPE_CONTRIBUTORS );
 			for ( TypeContributor typeContributor : typeContributorList.getTypeContributors() ) {
 				cfg.registerTypeContributor( typeContributor );
 			}
 		}
 		
 		return cfg;
 	}
 
 	public static class ServiceRegistryCloser implements SessionFactoryObserver {
 		@Override
 		public void sessionFactoryCreated(SessionFactory sessionFactory) {
 			// nothing to do
 		}
 
 		@Override
 		public void sessionFactoryClosed(SessionFactory sessionFactory) {
 			SessionFactoryImplementor sfi = ( (SessionFactoryImplementor) sessionFactory );
 			sfi.getServiceRegistry().destroy();
 			ServiceRegistry basicRegistry = sfi.getServiceRegistry().getParentServiceRegistry();
 			( (ServiceRegistryImplementor) basicRegistry ).destroy();
 		}
 	}
 
 	private PersistenceException persistenceException(String message) {
 		return persistenceException( message, null );
 	}
 
 	private PersistenceException persistenceException(String message, Exception cause) {
 		return new PersistenceException(
 				getExceptionHeader() + message,
 				cause
 		);
 	}
 
 	private String getExceptionHeader() {
 		return "[PersistenceUnit: " + persistenceUnit.getName() + "] ";
 	}
 
 	public static class CacheRegionDefinition {
 		public static enum CacheType { ENTITY, COLLECTION }
 
 		public final CacheType cacheType;
 		public final String role;
 		public final String usage;
 		public final String region;
 		public final boolean cacheLazy;
 
 		public CacheRegionDefinition(
 				CacheType cacheType,
 				String role,
 				String usage,
 				String region, boolean cacheLazy) {
 			this.cacheType = cacheType;
 			this.role = role;
 			this.usage = usage;
 			this.region = region;
 			this.cacheLazy = cacheLazy;
 		}
 	}
 
 	public static class JaccDefinition {
 		public final String contextId;
 		public final String role;
 		public final String clazz;
 		public final String actions;
 
 		public JaccDefinition(String contextId, String role, String clazz, String actions) {
 			this.contextId = contextId;
 			this.role = role;
 			this.clazz = clazz;
 			this.actions = actions;
 		}
 	}
 
 	public static class MetadataSources {
 		private final List<String> annotatedMappingClassNames = new ArrayList<String>();
 		private final List<ConverterDescriptor> converterDescriptors = new ArrayList<ConverterDescriptor>();
 		private final List<NamedInputStream> namedMappingFileInputStreams = new ArrayList<NamedInputStream>();
 		private final List<String> mappingFileResources = new ArrayList<String>();
 		private final List<String> packageNames = new ArrayList<String>();
 
 		public List<String> getAnnotatedMappingClassNames() {
 			return annotatedMappingClassNames;
 		}
 
 		public List<ConverterDescriptor> getConverterDescriptors() {
 			return converterDescriptors;
 		}
 
 		public List<NamedInputStream> getNamedMappingFileInputStreams() {
 			return namedMappingFileInputStreams;
 		}
 
 		public List<String> getPackageNames() {
 			return packageNames;
 		}
 
 		public List<String> collectMappingClassNames() {
 			// todo : the complete answer to this involves looking through the mapping files as well.
 			// 		Really need the metamodel branch code to do that properly
 			return annotatedMappingClassNames;
 		}
 
 		public static class ConverterDescriptor {
 			private final String converterClassName;
 			private final boolean autoApply;
 
 			public ConverterDescriptor(String converterClassName, boolean autoApply) {
 				this.converterClassName = converterClassName;
 				this.autoApply = autoApply;
 			}
 		}
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
index 05fc13ff71..f758785a33 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
@@ -1,488 +1,488 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.boot.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import javax.xml.XMLConstants;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
 
 import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.archive.internal.ArchiveHelper;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.internal.util.ConfigurationHelper;
-import org.hibernate.metamodel.source.XsdException;
+import org.hibernate.internal.util.xml.XsdException;
 
 import org.jboss.logging.Logger;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 
 /**
  * Used by Hibernate to parse {@code persistence.xml} files in SE environments.
  *
  * @author Steve Ebersole
  */
 public class PersistenceXmlParser {
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(
 			EntityManagerMessageLogger.class,
 			PersistenceXmlParser.class.getName()
 	);
 
 	private final ClassLoaderService classLoaderService;
 	private final PersistenceUnitTransactionType defaultTransactionType;
 
 	public static List<ParsedPersistenceXmlDescriptor> locatePersistenceUnits(Map integration) {
 		final PersistenceXmlParser parser = new PersistenceXmlParser(
 				ClassLoaderServiceImpl.fromConfigSettings( integration ),
 				PersistenceUnitTransactionType.RESOURCE_LOCAL
 		);
 
 		return parser.doResolve( integration );
 	}
 
 
 	public PersistenceXmlParser(ClassLoaderService classLoaderService, PersistenceUnitTransactionType defaultTransactionType) {
 		this.classLoaderService = classLoaderService;
 		this.defaultTransactionType = defaultTransactionType;
 	}
 
 	public List<ParsedPersistenceXmlDescriptor> doResolve(Map integration) {
 		final List<ParsedPersistenceXmlDescriptor> persistenceUnits = new ArrayList<ParsedPersistenceXmlDescriptor>();
 
 		final List<URL> xmlUrls = classLoaderService.locateResources( "META-INF/persistence.xml" );
 		if ( xmlUrls.isEmpty() ) {
 			LOG.unableToFindPersistenceXmlInClasspath();
 		}
 		else {
 			for ( URL xmlUrl : xmlUrls ) {
 				persistenceUnits.addAll( parsePersistenceXml( xmlUrl, integration ) );
 			}
 		}
 
 		return persistenceUnits;
 	}
 
 	private List<ParsedPersistenceXmlDescriptor> parsePersistenceXml(URL xmlUrl, Map integration) {
 		LOG.tracef( "Attempting to parse persistence.xml file : %s", xmlUrl.toExternalForm() );
 
 		final Document doc = loadUrl( xmlUrl );
 		final Element top = doc.getDocumentElement();
 
 		final List<ParsedPersistenceXmlDescriptor> persistenceUnits = new ArrayList<ParsedPersistenceXmlDescriptor>();
 
 		final NodeList children = top.getChildNodes();
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.ELEMENT_NODE ) {
 				final Element element = (Element) children.item( i );
 				final String tag = element.getTagName();
 				if ( tag.equals( "persistence-unit" ) ) {
 					final URL puRootUrl = ArchiveHelper.getJarURLFromURLEntry( xmlUrl, "/META-INF/persistence.xml" );
 					ParsedPersistenceXmlDescriptor persistenceUnit = new ParsedPersistenceXmlDescriptor( puRootUrl );
 					bindPersistenceUnit( persistenceUnit, element );
 
 					// per JPA spec, any settings passed in to PersistenceProvider bootstrap methods should override
 					// values found in persistence.xml
 					if ( integration.containsKey( AvailableSettings.PROVIDER ) ) {
 						persistenceUnit.setProviderClassName( (String) integration.get( AvailableSettings.PROVIDER ) );
 					}
 					if ( integration.containsKey( AvailableSettings.TRANSACTION_TYPE ) ) {
 						String transactionType = (String) integration.get( AvailableSettings.TRANSACTION_TYPE );
 						persistenceUnit.setTransactionType( parseTransactionType( transactionType ) );
 					}
 					if ( integration.containsKey( AvailableSettings.JTA_DATASOURCE ) ) {
 						persistenceUnit.setJtaDataSource( integration.get( AvailableSettings.JTA_DATASOURCE ) );
 					}
 					if ( integration.containsKey( AvailableSettings.NON_JTA_DATASOURCE ) ) {
 						persistenceUnit.setNonJtaDataSource( integration.get( AvailableSettings.NON_JTA_DATASOURCE ) );
 					}
 
 					decodeTransactionType( persistenceUnit );
 
 					Properties properties = persistenceUnit.getProperties();
 					ConfigurationHelper.overrideProperties( properties, integration );
 
 					persistenceUnits.add( persistenceUnit );
 				}
 			}
 		}
 		return persistenceUnits;
 	}
 
 	private void decodeTransactionType(ParsedPersistenceXmlDescriptor persistenceUnit) {
 		// if transaction type is set already
 		// 		use that value
 		// else
 		//		if JTA DS
 		//			use JTA
 		//		else if NOT JTA DS
 		//			use RESOURCE_LOCAL
 		//		else
 		//			use defaultTransactionType
 		if ( persistenceUnit.getTransactionType() != null ) {
 			return;
 		}
 
 		if ( persistenceUnit.getJtaDataSource() != null ) {
 			persistenceUnit.setTransactionType( PersistenceUnitTransactionType.JTA );
 		}
 		else if ( persistenceUnit.getNonJtaDataSource() != null ) {
 			persistenceUnit.setTransactionType( PersistenceUnitTransactionType.RESOURCE_LOCAL );
 		}
 		else {
 			persistenceUnit.setTransactionType( defaultTransactionType );
 		}
 	}
 
 	private void bindPersistenceUnit(ParsedPersistenceXmlDescriptor persistenceUnit, Element persistenceUnitElement) {
 		final String name = persistenceUnitElement.getAttribute( "name" );
 		if ( StringHelper.isNotEmpty( name ) ) {
             LOG.tracef( "Persistence unit name from persistence.xml : %s", name );
 			persistenceUnit.setName( name );
 		}
 
 		final PersistenceUnitTransactionType transactionType = parseTransactionType(
 				persistenceUnitElement.getAttribute( "transaction-type" )
 		);
 		if ( transactionType != null ) {
 			persistenceUnit.setTransactionType( transactionType );
 		}
 
 
 		NodeList children = persistenceUnitElement.getChildNodes();
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.ELEMENT_NODE ) {
 				Element element = (Element) children.item( i );
 				String tag = element.getTagName();
 				if ( tag.equals( "non-jta-data-source" ) ) {
 					persistenceUnit.setNonJtaDataSource( extractContent( element ) );
 				}
 				else if ( tag.equals( "jta-data-source" ) ) {
 					persistenceUnit.setJtaDataSource( extractContent( element ) );
 				}
 				else if ( tag.equals( "provider" ) ) {
 					persistenceUnit.setProviderClassName( extractContent( element ) );
 				}
 				else if ( tag.equals( "class" ) ) {
 					persistenceUnit.addClasses( extractContent( element ) );
 				}
 				else if ( tag.equals( "mapping-file" ) ) {
 					persistenceUnit.addMappingFiles( extractContent( element ) );
 				}
 				else if ( tag.equals( "jar-file" ) ) {
 					persistenceUnit.addJarFileUrl( ArchiveHelper.getURLFromPath( extractContent( element ) ) );
 				}
 				else if ( tag.equals( "exclude-unlisted-classes" ) ) {
 					persistenceUnit.setExcludeUnlistedClasses( extractBooleanContent(element, true) );
 				}
 				else if ( tag.equals( "delimited-identifiers" ) ) {
 					persistenceUnit.setUseQuotedIdentifiers( true );
 				}
 				else if ( tag.equals( "validation-mode" ) ) {
 					persistenceUnit.setValidationMode( extractContent( element ) );
 				}
 				else if ( tag.equals( "shared-cache-mode" ) ) {
 					persistenceUnit.setSharedCacheMode( extractContent( element ) );
 				}
 				else if ( tag.equals( "properties" ) ) {
 					NodeList props = element.getChildNodes();
 					for ( int j = 0; j < props.getLength() ; j++ ) {
 						if ( props.item( j ).getNodeType() == Node.ELEMENT_NODE ) {
 							Element propElement = (Element) props.item( j );
 							if ( !"property".equals( propElement.getTagName() ) ) {
 								continue;
 							}
 							String propName = propElement.getAttribute( "name" ).trim();
 							String propValue = propElement.getAttribute( "value" ).trim();
 							if ( StringHelper.isEmpty( propValue ) ) {
 								//fall back to the natural (Hibernate) way of description
 								propValue = extractContent( propElement, "" );
 							}
 							persistenceUnit.getProperties().put( propName, propValue );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private static String extractContent(Element element) {
 		return extractContent( element, null );
 	}
 
 	private static String extractContent(Element element, String defaultStr) {
 		if ( element == null ) {
 			return defaultStr;
 		}
 
 		NodeList children = element.getChildNodes();
 		StringBuilder result = new StringBuilder("");
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.TEXT_NODE ||
 					children.item( i ).getNodeType() == Node.CDATA_SECTION_NODE ) {
 				result.append( children.item( i ).getNodeValue() );
 			}
 		}
 		return result.toString().trim();
 	}
 
 	private static boolean extractBooleanContent(Element element, boolean defaultBool) {
 		String content = extractContent( element );
 		if (content != null && content.length() > 0) {
 			return Boolean.valueOf(content);
 		}
 		return defaultBool;
 	}
 
 	private static PersistenceUnitTransactionType parseTransactionType(String value) {
 		if ( StringHelper.isEmpty( value ) ) {
 			return null;
 		}
 		else if ( value.equalsIgnoreCase( "JTA" ) ) {
 			return PersistenceUnitTransactionType.JTA;
 		}
 		else if ( value.equalsIgnoreCase( "RESOURCE_LOCAL" ) ) {
 			return PersistenceUnitTransactionType.RESOURCE_LOCAL;
 		}
 		else {
 			throw new PersistenceException( "Unknown persistence unit transaction type : " + value );
 		}
 	}
 
 	private Document loadUrl(URL xmlUrl) {
 		final String resourceName = xmlUrl.toExternalForm();
 		try {
 			URLConnection conn = xmlUrl.openConnection();
 			conn.setUseCaches( false ); //avoid JAR locking on Windows and Tomcat
 			try {
 				InputStream inputStream = conn.getInputStream();
 				try {
 					final InputSource inputSource = new InputSource( inputStream );
 					try {
 						DocumentBuilder documentBuilder = documentBuilderFactory().newDocumentBuilder();
 						try {
 							Document document = documentBuilder.parse( inputSource );
 							validate( document );
 							return document;
 						}
 						catch (SAXException e) {
 							throw new PersistenceException( "Unexpected error parsing [" + resourceName + "]", e );
 						}
 						catch (IOException e) {
 							throw new PersistenceException( "Unexpected error parsing [" + resourceName + "]", e );
 						}
 					}
 					catch (ParserConfigurationException e) {
 						throw new PersistenceException( "Unable to generate javax.xml.parsers.DocumentBuilder instance", e );
 					}
 				}
 				finally {
 					try {
 						inputStream.close();
 					}
 					catch (Exception ignored) {
 					}
 				}
 			}
 			catch (IOException e) {
 				throw new PersistenceException( "Unable to obtain input stream from [" + resourceName + "]", e );
 			}
 		}
 		catch (IOException e) {
 			throw new PersistenceException( "Unable to access [" + resourceName + "]", e );
 		}
 	}
 
 	private void validate(Document document) {
 		// todo : add ability to disable validation...
 
 		final Validator validator;
 		final String version = document.getDocumentElement().getAttribute( "version" );
 		if ( "2.1".equals( version ) ) {
 			validator = v21Schema().newValidator();
 		}
 		else if ( "2.0".equals( version ) ) {
 			validator = v2Schema().newValidator();
 		}
 		else if ( "1.0".equals(  version ) ) {
 			validator = v1Schema().newValidator();
 		}
 		else {
 			throw new PersistenceException( "Unrecognized persistence.xml version [" + version + "]" );
 		}
 
 		List<SAXException> errors = new ArrayList<SAXException>();
 		validator.setErrorHandler( new ErrorHandlerImpl( errors ) );
 		try {
 			validator.validate( new DOMSource( document ) );
 		}
 		catch (SAXException e) {
 			errors.add( e );
 		}
 		catch (IOException e) {
 			throw new PersistenceException( "Unable to validate persistence.xml", e );
 		}
 
 		if ( errors.size() != 0 ) {
 			//report all errors in the exception
 			StringBuilder errorMessage = new StringBuilder( );
 			for ( SAXException error : errors ) {
 				errorMessage.append( extractInfo( error ) ).append( '\n' );
 			}
 			throw new PersistenceException( "Invalid persistence.xml.\n" + errorMessage.toString() );
 		}
 	}
 
 	private DocumentBuilderFactory documentBuilderFactory;
 
 	private DocumentBuilderFactory documentBuilderFactory() {
 		if ( documentBuilderFactory == null ) {
 			documentBuilderFactory = buildDocumentBuilderFactory();
 		}
 		return documentBuilderFactory;
 	}
 
 	private DocumentBuilderFactory buildDocumentBuilderFactory() {
 		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
 		documentBuilderFactory.setNamespaceAware( true );
 		return documentBuilderFactory;
 	}
 
 	private Schema v21Schema;
 
 	private Schema v21Schema() {
 		if ( v21Schema == null ) {
 			v21Schema = resolveLocalSchema( "org/hibernate/jpa/persistence_2_1.xsd" );
 		}
 		return v21Schema;
 	}
 
 	private Schema v2Schema;
 
 	private Schema v2Schema() {
 		if ( v2Schema == null ) {
 			v2Schema = resolveLocalSchema( "org/hibernate/jpa/persistence_2_0.xsd" );
 		}
 		return v2Schema;
 	}
 
 	private Schema v1Schema;
 
 	private Schema v1Schema() {
 		if ( v1Schema == null ) {
 			v1Schema = resolveLocalSchema( "org/hibernate/jpa/persistence_1_0.xsd" );
 		}
 		return v1Schema;
 	}
 
 
 	private Schema resolveLocalSchema(String schemaName) {
 		// These XSD resources should be available on the Hibernate ClassLoader
 		final URL url = classLoaderService.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( XMLConstants.W3C_XML_SCHEMA_NS_URI );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					LOG.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 
 	public static class ErrorHandlerImpl implements ErrorHandler {
 		private List<SAXException> errors;
 
 		ErrorHandlerImpl(List<SAXException> errors) {
 			this.errors = errors;
 		}
 
 		public void error(SAXParseException error) {
 			errors.add( error );
 		}
 
 		public void fatalError(SAXParseException error) {
 			errors.add( error );
 		}
 
 		public void warning(SAXParseException warn) {
 			LOG.trace( extractInfo( warn ) );
 		}
 	}
 
 	private static String extractInfo(SAXException error) {
 		if ( error instanceof SAXParseException ) {
 			return "Error parsing XML [line : " + ( (SAXParseException) error ).getLineNumber()
 					+ ", column : " + ( (SAXParseException) error ).getColumnNumber()
 					+ "] : " + error.getMessage();
 		}
 		else {
 			return "Error parsing XML : " + error.getMessage();
 		}
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/spi/TypeContributorList.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/spi/TypeContributorList.java
index e984c70257..0d8b1600d2 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/spi/TypeContributorList.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/spi/TypeContributorList.java
@@ -1,37 +1,37 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.boot.spi;
 
 import java.util.List;
 
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 
 /**
  * @author Brett Meyer
  * 
  * TODO: Not a fan of this name or entry point into EMFBuilderImpl
  */
 public interface TypeContributorList {
 	public List<TypeContributor> getTypeContributors();
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java
deleted file mode 100644
index d7bcda53f5..0000000000
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.jpa.event.internal.jpa;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.hibernate.MappingException;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
-import org.hibernate.jpa.event.spi.jpa.Callback;
-import org.hibernate.jpa.event.spi.jpa.ListenerFactory;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.service.spi.SessionFactoryServiceRegistry;
-
-import org.jboss.logging.Logger;
-
-/**
- * @author Steve Ebersole
- */
-public class CallbackProcessorImpl implements CallbackProcessor {
-	private static final Logger log = Logger.getLogger( CallbackProcessorImpl.class );
-
-	private final ListenerFactory jpaListenerFactory;
-	private final MetadataImplementor metadata;
-
-	private final ClassLoaderService classLoaderService;
-
-	public CallbackProcessorImpl(
-			ListenerFactory jpaListenerFactory,
-			MetadataImplementor metadata,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		this.jpaListenerFactory = jpaListenerFactory;
-		this.metadata = metadata;
-		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
-	}
-
-	@Override
-	public void processCallbacksForEntity(Object entityObject, CallbackRegistryImpl callbackRegistry) {
-		final EntityBinding entityBinding = (EntityBinding) entityObject;
-		final String entityClassName = entityBinding.getEntity().getClassName();
-		if ( entityClassName == null ) {
-			return;
-		}
-
-		try {
-			final Class entityClass = classLoaderService.classForName( entityClassName );
-			for ( Class annotationClass : CALLBACK_ANNOTATION_CLASSES ) {
-				callbackRegistry.addEntityCallbacks(
-						entityClass,
-						annotationClass,
-						collectCallbacks( entityBinding, entityClass, annotationClass )
-				);
-			}
-		}
-		catch (ClassLoadingException e) {
-			throw new MappingException( "entity class not found: " + entityClassName, e );
-		}
-	}
-
-	private Callback[] collectCallbacks(EntityBinding entityBinding, Class entityClass, Class annotationClass) {
-		final List<Callback> callbacks = new ArrayList<Callback>();
-		for ( JpaCallbackClass jpaCallbackClass : entityBinding.getJpaCallbackClasses() ) {
-			final Class listenerClass = classLoaderService.classForName( jpaCallbackClass.getName() );
-			final String methodName = jpaCallbackClass.getCallbackMethod( annotationClass );
-
-			log.debugf(
-					"Adding $s.%s as %s callback for entity %s",
-					listenerClass.getName(),
-					methodName,
-					annotationClass.getName(),
-					entityClass.getName()
-			);
-
-			final Callback callback = jpaCallbackClass.isListener()
-					? createListenerCallback( listenerClass, entityClass, methodName )
-					: createBeanCallback( listenerClass, methodName );
-			assert callback != null;
-			callbacks.add(callback);
-		}
-		return callbacks.toArray(new Callback[callbacks.size()]);
-	}
-
-	private Callback createListenerCallback(
-			Class listenerClass,
-			Class entityClass,
-			String methodName ) {
-		final Class<?> callbackSuperclass = listenerClass.getSuperclass();
-		if ( callbackSuperclass != null ) {
-			Callback callback = createListenerCallback( entityClass, callbackSuperclass, methodName );
-			if ( callback != null ) {
-				return callback;
-			}
-		}
-
-		final Object listenerInstance = jpaListenerFactory.buildListener( listenerClass );
-		for ( Method method : listenerClass.getDeclaredMethods() ) {
-			if ( !method.getName().equals(methodName) ) {
-				continue;
-			}
-
-			final Class<?>[] argTypes = method.getParameterTypes();
-			if (argTypes.length != 1) {
-				continue;
-			}
-
-			final Class<?> argType = argTypes[0];
-			if (argType != Object.class && argType != entityClass) {
-				continue;
-			}
-			method.setAccessible( true );
-
-			return new ListenerCallback( listenerInstance, method );
-		}
-		return null;
-	}
-
-	private Callback createBeanCallback( Class<?> callbackClass,
-												String methodName ) {
-		Class<?> callbackSuperclass = callbackClass.getSuperclass();
-		if (callbackSuperclass != null) {
-			Callback callback = createBeanCallback(callbackSuperclass, methodName);
-			if (callback != null) return callback;
-		}
-		for (Method method : callbackClass.getDeclaredMethods()) {
-			if (!method.getName().equals(methodName)) continue;
-			if (method.getParameterTypes().length != 0) continue;
-			method.setAccessible(true);
-			return new EntityCallback(method);
-		}
-		return null;
-	}
-
-	@Override
-	public void release() {
-	}
-}
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
index 0688d81389..ae091bdb2a 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
@@ -1,312 +1,237 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.event.spi;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.event.internal.core.HibernateEntityManagerEventListener;
 import org.hibernate.jpa.event.internal.core.JpaAutoFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaDeleteEventListener;
 import org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener;
 import org.hibernate.jpa.event.internal.core.JpaFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaMergeEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPersistEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPersistOnFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostDeleteEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostInsertEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostLoadEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostUpdateEventListener;
 import org.hibernate.jpa.event.internal.core.JpaSaveEventListener;
 import org.hibernate.jpa.event.internal.core.JpaSaveOrUpdateEventListener;
 import org.hibernate.jpa.event.internal.jpa.CallbackProcessor;
-import org.hibernate.jpa.event.internal.jpa.CallbackProcessorImpl;
 import org.hibernate.jpa.event.internal.jpa.CallbackRegistryConsumer;
 import org.hibernate.jpa.event.internal.jpa.CallbackRegistryImpl;
 import org.hibernate.jpa.event.internal.jpa.LegacyCallbackProcessor;
 import org.hibernate.jpa.event.internal.jpa.StandardListenerFactory;
 import org.hibernate.jpa.event.spi.jpa.ListenerFactory;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Hibernate EntityManager specific Integrator, performing JPA setup.
  *
  * @author Steve Ebersole
  */
 public class JpaIntegrator implements Integrator {
 	private ListenerFactory jpaListenerFactory;
 	private CallbackProcessor callbackProcessor;
 	private CallbackRegistryImpl callbackRegistry;
 
 	private static final DuplicationStrategy JPA_DUPLICATION_STRATEGY = new JPADuplicationStrategy();
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// first, register the JPA-specific persist cascade style
 		CascadeStyles.registerCascadeStyle(
 				"persist",
                 new PersistCascadeStyle()
 		);
 
 
 		// then prepare listeners
 		final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 
 		eventListenerRegistry.addDuplicationStrategy( JPA_DUPLICATION_STRATEGY );
 
 		// op listeners
 		eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, JpaAutoFlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.DELETE, new JpaDeleteEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, new JpaFlushEntityEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH, JpaFlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.MERGE, new JpaMergeEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST, new JpaPersistEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST_ONFLUSH, new JpaPersistOnFlushEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE, new JpaSaveEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE_UPDATE, new JpaSaveOrUpdateEventListener() );
 
 		// post op listeners
 		eventListenerRegistry.prependListeners( EventType.POST_DELETE, new JpaPostDeleteEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_INSERT, new JpaPostInsertEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_LOAD, new JpaPostLoadEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_UPDATE, new JpaPostUpdateEventListener() );
 
 		for ( Map.Entry<?,?> entry : configuration.getProperties().entrySet() ) {
 			if ( ! String.class.isInstance( entry.getKey() ) ) {
 				continue;
 			}
 			final String propertyName = (String) entry.getKey();
 			if ( ! propertyName.startsWith( AvailableSettings.EVENT_LISTENER_PREFIX ) ) {
 				continue;
 			}
 			final String eventTypeName = propertyName.substring( AvailableSettings.EVENT_LISTENER_PREFIX.length() + 1 );
 			final EventType eventType = EventType.resolveEventTypeByName( eventTypeName );
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( String listenerImpl : ( (String) entry.getValue() ).split( " ," ) ) {
 				eventListenerGroup.appendListener( instantiate( listenerImpl, serviceRegistry ) );
 			}
 		}
 
 		// handle JPA "entity listener classes"...
 
 		this.callbackRegistry = new CallbackRegistryImpl();
 		final Object beanManagerRef = configuration.getProperties().get( AvailableSettings.CDI_BEAN_MANAGER );
 		this.jpaListenerFactory = beanManagerRef == null
 				? new StandardListenerFactory()
 				: buildBeanManagerListenerFactory( beanManagerRef );
 		this.callbackProcessor = new LegacyCallbackProcessor( jpaListenerFactory, configuration.getReflectionManager() );
 
 		Iterator classes = configuration.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass clazz = (PersistentClass) classes.next();
 			if ( clazz.getClassName() == null ) {
 				// we can have non java class persisted by hibernate
 				continue;
 			}
 			callbackProcessor.processCallbacksForEntity( clazz.getClassName(), callbackRegistry );
 		}
 
 		for ( EventType eventType : EventType.values() ) {
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( Object listener : eventListenerGroup.listeners() ) {
 				if ( CallbackRegistryConsumer.class.isInstance( listener ) ) {
 					( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );
 				}
 			}
 		}
 	}
 
 	private static final String CDI_LISTENER_FACTORY_CLASS = "org.hibernate.jpa.event.internal.jpa.BeanManagerListenerFactory";
 
 	private ListenerFactory buildBeanManagerListenerFactory(Object beanManagerRef) {
 		try {
 			// specifically using our classloader here...
 			final Class beanManagerListenerFactoryClass = getClass().getClassLoader()
 					.loadClass( CDI_LISTENER_FACTORY_CLASS );
 			final Method beanManagerListenerFactoryBuilderMethod = beanManagerListenerFactoryClass.getMethod(
 					"fromBeanManagerReference",
 					Object.class
 			);
 
 			try {
 				return (ListenerFactory) beanManagerListenerFactoryBuilderMethod.invoke( null, beanManagerRef );
 			}
 			catch (InvocationTargetException e) {
 				throw e.getTargetException();
 			}
 		}
 		catch (ClassNotFoundException e) {
 			throw new HibernateException( "Could not locate BeanManagerListenerFactory class to handle CDI extensions", e );
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Throwable e) {
 			throw new HibernateException( "Could not access BeanManagerListenerFactory class to handle CDI extensions", e );
 		}
 	}
 
 	@Override
-	public void integrate(
-			MetadataImplementor metadata,
-			SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry ) {
-		// first, register the JPA-specific persist cascade style
-		CascadeStyles.registerCascadeStyle(
-				"persist",
-				new PersistCascadeStyle()
-		);
-
-		// then prepare listeners
-        final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
-
-        eventListenerRegistry.addDuplicationStrategy( JPA_DUPLICATION_STRATEGY );
-
-        // op listeners
-        eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, JpaAutoFlushEventListener.INSTANCE );
-        eventListenerRegistry.setListeners( EventType.DELETE, new JpaDeleteEventListener() );
-        eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, new JpaFlushEntityEventListener() );
-        eventListenerRegistry.setListeners( EventType.FLUSH, JpaFlushEventListener.INSTANCE );
-        eventListenerRegistry.setListeners( EventType.MERGE, new JpaMergeEventListener() );
-        eventListenerRegistry.setListeners( EventType.PERSIST, new JpaPersistEventListener() );
-        eventListenerRegistry.setListeners( EventType.PERSIST_ONFLUSH, new JpaPersistOnFlushEventListener() );
-        eventListenerRegistry.setListeners( EventType.SAVE, new JpaSaveEventListener() );
-        eventListenerRegistry.setListeners( EventType.SAVE_UPDATE, new JpaSaveOrUpdateEventListener() );
-
-        // post op listeners
-        eventListenerRegistry.prependListeners( EventType.POST_DELETE, new JpaPostDeleteEventListener() );
-        eventListenerRegistry.prependListeners( EventType.POST_INSERT, new JpaPostInsertEventListener() );
-        eventListenerRegistry.prependListeners( EventType.POST_LOAD, new JpaPostLoadEventListener() );
-        eventListenerRegistry.prependListeners( EventType.POST_UPDATE, new JpaPostUpdateEventListener() );
-
-        for ( Map.Entry<?,?> entry : sessionFactory.getProperties().entrySet() ) {
-            if ( ! String.class.isInstance( entry.getKey() ) ) {
-                continue;
-            }
-            final String propertyName = (String) entry.getKey();
-            if ( ! propertyName.startsWith( AvailableSettings.EVENT_LISTENER_PREFIX ) ) {
-                continue;
-            }
-            final String eventTypeName = propertyName.substring( AvailableSettings.EVENT_LISTENER_PREFIX.length() + 1 );
-            final EventType eventType = EventType.resolveEventTypeByName( eventTypeName );
-            final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
-            for ( String listenerImpl : ( (String) entry.getValue() ).split( " ," ) ) {
-                eventListenerGroup.appendListener( instantiate( listenerImpl, serviceRegistry ) );
-            }
-        }
-
-		// handle JPA "entity listener classes"...
-
-		this.callbackRegistry = new CallbackRegistryImpl();
-		final Object beanManagerRef = sessionFactory.getProperties().get( AvailableSettings.CDI_BEAN_MANAGER );
-		this.jpaListenerFactory = beanManagerRef == null
-				? new StandardListenerFactory()
-				: buildBeanManagerListenerFactory( beanManagerRef );
-		this.callbackProcessor = new CallbackProcessorImpl( jpaListenerFactory, metadata, serviceRegistry );
-
-        for ( EntityBinding binding : metadata.getEntityBindings() ) {
-			callbackProcessor.processCallbacksForEntity( binding, callbackRegistry );
-        }
-
-        for ( EventType eventType : EventType.values() ) {
-            final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
-            for ( Object listener : eventListenerGroup.listeners() ) {
-                if ( CallbackRegistryConsumer.class.isInstance( listener ) ) {
-                    ( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );
-                }
-            }
-        }
-	}
-
-	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		if ( callbackRegistry != null ) {
 			callbackRegistry.release();
 		}
 		if ( callbackProcessor != null ) {
 			callbackProcessor.release();
 		}
 		if ( jpaListenerFactory != null ) {
 			jpaListenerFactory.release();
 		}
 	}
 
 	private Object instantiate(String listenerImpl, ServiceRegistryImplementor serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( listenerImpl ).newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not instantiate requested listener [" + listenerImpl + "]", e );
         }
     }
 
     private static class PersistCascadeStyle extends CascadeStyles.BaseCascadeStyle {
         @Override
         public boolean doCascade(CascadingAction action) {
             return action == JpaPersistEventListener.PERSIST_SKIPLAZY
                     || action == CascadingActions.PERSIST_ON_FLUSH;
         }
 
         @Override
         public String toString() {
             return "STYLE_PERSIST_SKIPLAZY";
         }
     }
 
     private static class JPADuplicationStrategy implements DuplicationStrategy {
         @Override
         public boolean areMatch(Object listener, Object original) {
             return listener.getClass().equals( original.getClass() ) &&
                     HibernateEntityManagerEventListener.class.isInstance( original );
         }
 
         @Override
         public Action getAction() {
             return Action.KEEP_ORIGINAL;
         }
     }
 }
diff --git a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/criteria/paths/SingularAttributeJoinTest.java b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/criteria/paths/SingularAttributeJoinTest.java
index 6221330ed5..67c7958213 100755
--- a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/criteria/paths/SingularAttributeJoinTest.java
+++ b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/criteria/paths/SingularAttributeJoinTest.java
@@ -1,214 +1,219 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.test.criteria.paths;
 
+import java.sql.Types;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import javax.persistence.EntityManager;
+import javax.persistence.TypedQuery;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.From;
+import javax.persistence.criteria.JoinType;
+import javax.persistence.criteria.Path;
+import javax.persistence.metamodel.Attribute;
+import javax.persistence.metamodel.Bindable;
+import javax.persistence.metamodel.SingularAttribute;
+import javax.persistence.metamodel.Type;
+
 import org.hibernate.EntityMode;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.IntegratorProvider;
 import org.hibernate.jpa.criteria.CriteriaBuilderImpl;
 import org.hibernate.jpa.criteria.PathSource;
 import org.hibernate.jpa.criteria.path.SingularAttributeJoin;
 import org.hibernate.jpa.test.metamodel.AbstractMetamodelSpecificTest;
-import org.hibernate.mapping.*;
-import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.mapping.Column;
+import org.hibernate.mapping.ManyToOne;
+import org.hibernate.mapping.PrimaryKey;
+import org.hibernate.mapping.Property;
+import org.hibernate.mapping.RootClass;
+import org.hibernate.mapping.SimpleValue;
+import org.hibernate.mapping.Table;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.tuple.entity.DynamicMapEntityTuplizer;
-import org.hibernate.type.EntityType;
-import org.junit.Test;
-
-import javax.persistence.EntityManager;
-import javax.persistence.TypedQuery;
-import javax.persistence.criteria.*;
-import javax.persistence.metamodel.Attribute;
-import javax.persistence.metamodel.Bindable;
-import javax.persistence.metamodel.SingularAttribute;
-import javax.persistence.metamodel.Type;
 
-import java.sql.Types;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
 
 /**
  * @author Brad Koehn
  */
 public class SingularAttributeJoinTest extends AbstractMetamodelSpecificTest {
 
     /**
      * When building a join from a non-class based entity (EntityMode.MAP), make sure you get the Bindable from
      * the SingularAttribute as the join model. If you don't, you'll get the first non-classed based entity
      * you added to your configuration. Regression for HHH-9142.
      */
     @Test
     public void testEntityModeMapJoins() throws Exception {
         CriteriaBuilderImpl criteriaBuilder = mock(CriteriaBuilderImpl.class);
         PathSource pathSource = mock(PathSource.class);
         SingularAttribute joinAttribute = mock(SingularAttribute.class);
         when(joinAttribute.getPersistentAttributeType()).thenReturn(Attribute.PersistentAttributeType.MANY_TO_ONE);
         Type joinType = mock(Type.class, withSettings().extraInterfaces(Bindable.class));
         when(joinAttribute.getType()).thenReturn(joinType);
         SingularAttributeJoin join = new SingularAttributeJoin(criteriaBuilder, null, pathSource, joinAttribute, JoinType.LEFT);
 
         assertEquals(joinType, join.getModel());
     }
 
     @Test
     public void testEntityModeMapJoinCriteriaQuery() throws Exception {
         final EntityManager entityManager = entityManagerFactory().createEntityManager();
         CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
         CriteriaQuery criteriaQuery = criteriaBuilder.createQuery();
         javax.persistence.metamodel.EntityType distributionEntity = getEntityType("Distribution");
         From distributionFrom = criteriaQuery.from(distributionEntity);
         From policyJoin = distributionFrom.join("policy");
         Path policyId = policyJoin.get("policyId");
         criteriaQuery.select(policyId);
         TypedQuery typedQuery = entityManager.createQuery(criteriaQuery);
 //        typedQuery.getResultList();
     }
 
     private javax.persistence.metamodel.EntityType getEntityType(String entityName) {
         for(javax.persistence.metamodel.EntityType entityType : entityManagerFactory().getMetamodel().getEntities()) {
             if (entityType.getName().equals("Distribution")) {
                 return entityType;
             }
         }
 
         throw new IllegalStateException("Unable to find entity " + entityName);
     }
 
     @Override
     protected Map buildSettings() {
         Map<Object, Object> config = super.buildSettings();
 
         IntegratorProvider integratorProvider = getIntegratorProvider();
         config.put(EntityManagerFactoryBuilderImpl.INTEGRATOR_PROVIDER, integratorProvider);
 
         return config;
     }
 
     private IntegratorProvider getIntegratorProvider() {
         return new IntegratorProvider() {
 
             @Override
             public List<Integrator> getIntegrators() {
                 return Arrays.asList(getIntegrator());
             }
         };
     }
 
     private Integrator getIntegrator() {
         return new Integrator() {
 
             @Override
             public void integrate(Configuration configuration, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
                 Mappings mappings = configuration.createMappings();
                 addPolicy(mappings);
                 addDistribution(mappings);
             }
 
             @Override
-            public void integrate(MetadataImplementor metadata, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
-
-            }
-
-            @Override
             public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 
             }
         };
     }
 
     private void addPolicy(Mappings mappings) {
         RootClass policyRootClass = new RootClass();
         policyRootClass.addTuplizer(EntityMode.MAP, DynamicMapEntityTuplizer.class.getName());
         policyRootClass.setJpaEntityName("Policy");
         policyRootClass.setEntityName("Policy");
         Table policyTable = new Table("POLICY_TABLE");
         PrimaryKey policyPrimaryKey = new PrimaryKey();
         policyTable.setPrimaryKey(policyPrimaryKey);
         Column policyIdColumn = new Column("policyId");
         policyIdColumn.setSqlTypeCode(Types.INTEGER);
         policyTable.addColumn(policyIdColumn);
         SimpleValue identifierValue = new SimpleValue(mappings, policyTable);
         identifierValue.setTypeName("int");
         identifierValue.addColumn(policyIdColumn);
         identifierValue.setIdentifierGeneratorStrategy("assigned");
         policyPrimaryKey.addColumn(policyIdColumn);
         policyRootClass.setIdentifier(identifierValue);
         Property policyIdProperty = new Property();
         policyIdProperty.setValue(identifierValue);
         policyIdProperty.setName("policyId");
         policyRootClass.addProperty(policyIdProperty);
 
         policyRootClass.setTable(policyTable);
         mappings.addClass(policyRootClass);
         mappings.addTable(null, null, policyTable.getName(), null, false);
     }
 
     private void addDistribution(Mappings mappings) {
         RootClass distRootClass = new RootClass();
         distRootClass.addTuplizer(EntityMode.MAP, DynamicMapEntityTuplizer.class.getName());
         distRootClass.setEntityName("Distribution");
         distRootClass.setJpaEntityName("Distribution");
         Table distTable = new Table("DISTRIBUTION_TABLE");
         PrimaryKey distPrimaryKey = new PrimaryKey();
         distTable.setPrimaryKey(distPrimaryKey);
         Column distIdColumn = new Column("distributionId");
         distIdColumn.setSqlTypeCode(Types.INTEGER);
         distTable.addColumn(distIdColumn);
         SimpleValue identifierValue = new SimpleValue(mappings, distTable);
         identifierValue.setTypeName("int");
         identifierValue.addColumn(distIdColumn);
         identifierValue.setIdentifierGeneratorStrategy("assigned");
         distPrimaryKey.addColumn(distIdColumn);
         distRootClass.setIdentifier(identifierValue);
         Property distIdProperty = new Property();
         distIdProperty.setValue(identifierValue);
         distIdProperty.setName("distributionId");
         distRootClass.addProperty(distIdProperty);
         Property policyProperty = new Property();
         policyProperty.setName("policy");
         ManyToOne policyValue = new ManyToOne(mappings, distTable);
         policyProperty.setValue(policyValue);
         policyValue.setTypeName("Policy");
         policyValue.setReferencedEntityName("Policy");
         Column policyColumn = new Column("policyId");
         policyValue.addColumn(policyColumn);
         policyColumn.setSqlTypeCode(Types.INTEGER);
         distRootClass.addProperty(policyProperty);
 
 
         distRootClass.setTable(distTable);
         mappings.addClass(distRootClass);
         mappings.addTable(null, null, distTable.getName(), null, false);
     }
 
 }
diff --git a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/ejb3configuration/PersisterClassProviderTest.java b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/ejb3configuration/PersisterClassProviderTest.java
index 787ba76fbf..9d96115e7c 100644
--- a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/ejb3configuration/PersisterClassProviderTest.java
+++ b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/ejb3configuration/PersisterClassProviderTest.java
@@ -1,648 +1,636 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * JBoss, Home of Professional Open Source
  * Copyright 2011 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.jpa.test.ejb3configuration;
 
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.PersistenceException;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.jpa.test.SettingsGenerator;
 import org.hibernate.jpa.test.PersistenceUnitDescriptorAdapter;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.FilterAliasGenerator;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metadata.ClassMetadata;
-import org.hibernate.metamodel.binding.EntityBinding;
-import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.internal.PersisterClassResolverInitiator;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.tuple.entity.NonPojoInstrumentationMetadata;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  */
 public class PersisterClassProviderTest {
 	@Test
 	@SuppressWarnings("unchecked")
 	public void testPersisterClassProvider() {
 		Map settings = SettingsGenerator.generateSettings(
 				PersisterClassResolverInitiator.IMPL_NAME, GoofyPersisterClassProvider.class,
 				AvailableSettings.LOADED_CLASSES, Arrays.asList( Bell.class )
 		);
 		try {
 			EntityManagerFactory entityManagerFactory = Bootstrap.getEntityManagerFactoryBuilder(
 					new PersistenceUnitDescriptorAdapter(),
 					settings
 			).build();
 			entityManagerFactory.close();
 		}
 		catch ( PersistenceException e ) {
             Assert.assertNotNull( e.getCause() );
 			Assert.assertNotNull( e.getCause().getCause() );
 			Assert.assertEquals( GoofyException.class, e.getCause().getCause().getClass() );
 
 		}
 	}
 
 	public static class GoofyPersisterClassProvider implements PersisterClassResolver {
 		@Override
 		public Class<? extends EntityPersister> getEntityPersisterClass(PersistentClass metadata) {
 			return GoofyProvider.class;
 		}
 
 		@Override
-		public Class<? extends EntityPersister> getEntityPersisterClass(EntityBinding metadata) {
-			return GoofyProvider.class;
-		}
-
-		@Override
 		public Class<? extends CollectionPersister> getCollectionPersisterClass(Collection metadata) {
 			return null;
 		}
-
-		@Override
-		public Class<? extends CollectionPersister> getCollectionPersisterClass(PluralAttributeBinding metadata) {
-			return null;
-		}
 	}
 
 	public static class GoofyProvider implements EntityPersister {
 
 		@SuppressWarnings( {"UnusedParameters"})
 		public GoofyProvider(
 				org.hibernate.mapping.PersistentClass persistentClass,
 				org.hibernate.cache.spi.access.EntityRegionAccessStrategy strategy,
 				NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 				SessionFactoryImplementor sf,
 				Mapping mapping) {
 			throw new GoofyException();
 		}
 
 		@Override
 		public EntityMode getEntityMode() {
 			return null;
 		}
 
 		@Override
 		public EntityTuplizer getEntityTuplizer() {
 			return null;
 		}
 
 		@Override
 		public EntityInstrumentationMetadata getInstrumentationMetadata() {
 			return new NonPojoInstrumentationMetadata( getEntityName() );
 		}
 
 		@Override
 		public void generateEntityDefinition() {
 		}
 
 		@Override
 		public void postInstantiate() throws MappingException {
 
 		}
 
 		@Override
 		public SessionFactoryImplementor getFactory() {
 			return null;
 		}
 
 		@Override
 		public String getRootEntityName() {
 			return null;
 		}
 
 		@Override
 		public String getEntityName() {
 			return null;
 		}
 
 		@Override
 		public EntityMetamodel getEntityMetamodel() {
 			return null;
 		}
 
 		@Override
 		public boolean isSubclassEntityName(String entityName) {
 			return false;
 		}
 
 		@Override
 		public Serializable[] getPropertySpaces() {
 			return new Serializable[0];
 		}
 
 		@Override
 		public Serializable[] getQuerySpaces() {
 			return new Serializable[0];
 		}
 
 		@Override
 		public boolean hasProxy() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCollections() {
 			return false;
 		}
 
 		@Override
 		public boolean hasMutableProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean hasSubselectLoadableCollections() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCascades() {
 			return false;
 		}
 
 		@Override
 		public boolean isMutable() {
 			return false;
 		}
 
 		@Override
 		public boolean isInherited() {
 			return false;
 		}
 
 		@Override
 		public boolean isIdentifierAssignedByInsert() {
 			return false;
 		}
 
 		@Override
 		public Type getPropertyType(String propertyName) throws MappingException {
 			return null;
 		}
 
 		@Override
 		public int[] findDirty(Object[] currentState, Object[] previousState, Object owner, SessionImplementor session) {
 			return new int[0];
 		}
 
 		@Override
 		public int[] findModified(Object[] old, Object[] current, Object object, SessionImplementor session) {
 			return new int[0];
 		}
 
 		@Override
 		public boolean hasIdentifierProperty() {
 			return false;
 		}
 
 		@Override
 		public boolean canExtractIdOutOfEntity() {
 			return false;
 		}
 
 		@Override
 		public boolean isVersioned() {
 			return false;
 		}
 
 		@Override
 		public Comparator getVersionComparator() {
 			return null;
 		}
 
 		@Override
 		public VersionType getVersionType() {
 			return null;
 		}
 
 		@Override
 		public int getVersionProperty() {
 			return 0;
 		}
 
 		@Override
 		public boolean hasNaturalIdentifier() {
 			return false;
 		}
 		
         @Override
 		public int[] getNaturalIdentifierProperties() {
 			return new int[0];
 		}
 
 		@Override
 		public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) {
 			return new Object[0];
 		}
 
 		@Override
 		public Serializable loadEntityIdByNaturalId(Object[] naturalIdValues, LockOptions lockOptions,
 				SessionImplementor session) {
 			return null;
 		}
 		
 		@Override
         public boolean hasNaturalIdCache() {
             return false;
         }
 
         @Override
         public NaturalIdRegionAccessStrategy getNaturalIdCacheAccessStrategy() {
             return null;
         }
 
         @Override
 		public IdentifierGenerator getIdentifierGenerator() {
 			return null;
 		}
 
 		@Override
 		public boolean hasLazyProperties() {
 			return false;
 		}
 
 		@Override
 		public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) {
 		}
 
 		@Override
 		public void lock(Serializable id, Object version, Object object, LockOptions lockOptions, SessionImplementor session) {
 		}
 
 		@Override
 		public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) {
 		}
 
 		@Override
 		public Serializable insert(Object[] fields, Object object, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void delete(Serializable id, Object version, Object object, SessionImplementor session) {
 		}
 
 		@Override
 		public void update(Serializable id, Object[] fields, int[] dirtyFields, boolean hasDirtyCollection, Object[] oldFields, Object oldVersion, Object object, Object rowId, SessionImplementor session) {
 		}
 
 		@Override
 		public Type[] getPropertyTypes() {
 			return new Type[0];
 		}
 
 		@Override
 		public String[] getPropertyNames() {
 			return new String[0];
 		}
 
 		@Override
 		public boolean[] getPropertyInsertability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 			return new ValueInclusion[0];
 		}
 
 		@Override
 		public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 			return new ValueInclusion[0];
 		}
 
 		@Override
 		public boolean[] getPropertyUpdateability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyCheckability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyNullability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyVersionability() {
 			return new boolean[0];
 		}
 
 		@Override
 		public boolean[] getPropertyLaziness() {
 			return new boolean[0];
 		}
 
 		@Override
 		public CascadeStyle[] getPropertyCascadeStyles() {
 			return new CascadeStyle[0];
 		}
 
 		@Override
 		public Type getIdentifierType() {
 			return null;
 		}
 
 		@Override
 		public String getIdentifierPropertyName() {
 			return null;
 		}
 
 		@Override
 		public boolean isCacheInvalidationRequired() {
 			return false;
 		}
 
 		@Override
 		public boolean isLazyPropertiesCacheable() {
 			return false;
 		}
 
 		@Override
 		public boolean hasCache() {
 			return false;
 		}
 
 		@Override
 		public EntityRegionAccessStrategy getCacheAccessStrategy() {
 			return null;
 		}
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return null;
 		}
 
 		@Override
 		public ClassMetadata getClassMetadata() {
 			return null;
 		}
 
 		@Override
 		public boolean isBatchLoadable() {
 			return false;
 		}
 
 		@Override
 		public boolean isSelectBeforeUpdateRequired() {
 			return false;
 		}
 
 		@Override
 		public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 			return new Object[0];
 		}
 
 		@Override
 		public Serializable getIdByUniqueKey(Serializable key, String uniquePropertyName, SessionImplementor session) {
 			throw new UnsupportedOperationException( "Not supported" );
 		}
 
 		@Override
 		public Object getCurrentVersion(Serializable id, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public boolean isInstrumented() {
 			return false;
 		}
 
 		@Override
 		public boolean hasInsertGeneratedProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean hasUpdateGeneratedProperties() {
 			return false;
 		}
 
 		@Override
 		public boolean isVersionPropertyGenerated() {
 			return false;
 		}
 
 		@Override
 		public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		}
 
 		@Override
 		public void afterReassociate(Object entity, SessionImplementor session) {
 		}
 
 		@Override
 		public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Boolean isTransient(Object object, SessionImplementor session) throws HibernateException {
 			return null;
 		}
 
 		@Override
 		public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) {
 			return new Object[0];
 		}
 
 		@Override
 		public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		}
 
 		@Override
 		public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		}
 
 		@Override
 		public Class getMappedClass() {
 			return null;
 		}
 
 		@Override
 		public boolean implementsLifecycle() {
 			return false;
 		}
 
 		@Override
 		public Class getConcreteProxyClass() {
 			return null;
 		}
 
 		@Override
 		public void setPropertyValues(Object object, Object[] values) {
 		}
 
 		@Override
 		public void setPropertyValue(Object object, int i, Object value) {
 		}
 
 		@Override
 		public Object[] getPropertyValues(Object object) {
 			return new Object[0];
 		}
 
 		@Override
 		public Object getPropertyValue(Object object, int i) {
 			return null;
 		}
 
 		@Override
 		public Object getPropertyValue(Object object, String propertyName) {
 			return null;
 		}
 
 		@Override
 		public Serializable getIdentifier(Object object) {
 			return null;
 		}
 
 		@Override
 		public Serializable getIdentifier(Object entity, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		}
 
 		@Override
 		public Object getVersion(Object object) {
 			return null;
 		}
 
 		@Override
 		public Object instantiate(Serializable id, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public boolean isInstance(Object object) {
 			return false;
 		}
 
 		@Override
 		public boolean hasUninitializedLazyProperties(Object object) {
 			return false;
 		}
 
 		@Override
 		public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		}
 
 		@Override
 		public EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory) {
 			return null;
 		}
 
 		@Override
 		public FilterAliasGenerator getFilterAliasGenerator(String rootAlias) {
 			return null;
 		}
 
 		@Override
 		public int[] resolveAttributeIndexes(Set<String> properties) {
 			return new int[0];
 		}
 
 		@Override
 		public boolean canUseReferenceCacheEntries() {
 			return false;  //To change body of implemented methods use File | Settings | File Templates.
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 			return null;
 		}
 
 		@Override
 		public EntityPersister getEntityPersister() {
 			return this;
 		}
 
 		@Override
 		public EntityIdentifierDefinition getEntityKeyDefinition() {
 			return null;
 		}
 
 		@Override
 		public Iterable<AttributeDefinition> getAttributes() {
 			return null;
 		}
 	}
 
 	public static class GoofyException extends RuntimeException {
 
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java
index 1539db52da..30b7d619ed 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java
@@ -1,133 +1,119 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 import org.jboss.logging.Logger;
 
 /**
  * Provides integration for Envers into Hibernate, which mainly means registering the proper event listeners.
  *
  * @author Steve Ebersole
  */
 public class EnversIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			EnversIntegrator.class.getName()
 	);
 
 	/**
 	 * The name of a configuration setting that can be used to control whether auto registration of envers listeners
 	 * should happen or not.  Default is true
 	 */
 	public static final String AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
     private AuditConfiguration enversConfiguration;
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		final boolean autoRegister = ConfigurationHelper.getBoolean(
 				AUTO_REGISTER,
 				configuration.getProperties(),
 				true
 		);
 		if ( !autoRegister ) {
 			LOG.debug( "Skipping Envers listener auto registration" );
 			return;
 		}
 
 		final EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		listenerRegistry.addDuplicationStrategy( EnversListenerDuplicationStrategy.INSTANCE );
 
         enversConfiguration = AuditConfiguration.getFor(
 				configuration,
 				serviceRegistry.getService(
 						ClassLoaderService.class
 				)
 		);
 
 		if ( enversConfiguration.getEntCfg().hasAuditedEntities() ) {
 			listenerRegistry.appendListeners(
 					EventType.POST_DELETE, new EnversPostDeleteEventListenerImpl(
 					enversConfiguration
 			)
 			);
 			listenerRegistry.appendListeners(
 					EventType.POST_INSERT, new EnversPostInsertEventListenerImpl(
 					enversConfiguration
 			)
 			);
 			listenerRegistry.appendListeners(
 					EventType.POST_UPDATE, new EnversPostUpdateEventListenerImpl(
 					enversConfiguration
 			)
 			);
 			listenerRegistry.appendListeners(
 					EventType.POST_COLLECTION_RECREATE,
 					new EnversPostCollectionRecreateEventListenerImpl( enversConfiguration )
 			);
 			listenerRegistry.appendListeners(
 					EventType.PRE_COLLECTION_REMOVE,
 					new EnversPreCollectionRemoveEventListenerImpl( enversConfiguration )
 			);
 			listenerRegistry.appendListeners(
 					EventType.PRE_COLLECTION_UPDATE,
 					new EnversPreCollectionUpdateEventListenerImpl( enversConfiguration )
 			);
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		if ( enversConfiguration != null ) {
 			enversConfiguration.destroy();
 		}
 	}
-
-	/**
-	 * {@inheritDoc}
-	 *
-	 * @see org.hibernate.integrator.spi.Integrator#integrate(org.hibernate.metamodel.source.MetadataImplementor, org.hibernate.engine.spi.SessionFactoryImplementor, org.hibernate.service.spi.SessionFactoryServiceRegistry)
-	 */
-	@Override
-	public void integrate(
-			MetadataImplementor metadata,
-			SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
-		// TODO: implement
-	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java
index e2366a0b80..c60751a7d1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities;
 
-import org.hibernate.metamodel.spi.TypeContributions;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributions;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * Envers specific TypeContributor
  *
  * @author Brett Meyer
  */
 public class TypeContributorImpl implements TypeContributor {
 	@Override
 	public void contribute(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {
 		typeContributions.contributeType(
 				new RevisionTypeType(),
 				new String[] { RevisionTypeType.class.getName() }
 		);
 	}
 
 }
diff --git a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.metamodel.spi.TypeContributor b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor
similarity index 100%
rename from hibernate-envers/src/main/resources/META-INF/services/org.hibernate.metamodel.spi.TypeContributor
rename to hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor
diff --git a/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml b/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
index 9fc677c57e..93892568ed 100644
--- a/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
+++ b/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <blueprint  default-activation="eager" 
             xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
   <bean id="integrator" class="org.hibernate.envers.event.spi.EnversIntegrator"/>
   <service ref="integrator" interface="org.hibernate.integrator.spi.Integrator"/>
 
   <bean id="typeContributor" class="org.hibernate.envers.internal.entities.TypeContributorImpl"/>
-  <service ref="typeContributor" interface="org.hibernate.metamodel.spi.TypeContributor"/>
+  <service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor"/>
   
 </blueprint>
diff --git a/hibernate-osgi/hibernate-osgi.gradle b/hibernate-osgi/hibernate-osgi.gradle
index 62d066dee9..15c83a03db 100644
--- a/hibernate-osgi/hibernate-osgi.gradle
+++ b/hibernate-osgi/hibernate-osgi.gradle
@@ -1,161 +1,167 @@
 configurations {
 	osgiRuntime
 	osgiRuntimeBnd
 }
 
 sourceSets {
 	testClientBundle
 }
 
 sourceSets.test {
 	compileClasspath += sourceSets.testClientBundle.output
 	runtimeClasspath += sourceSets.testClientBundle.output
 }
 
+
+// temporary for HHH-9466
+test {
+    enabled = false;
+}
+
 dependencies {
 	compile( project( ':hibernate-core' ) )
 	compile( project( ':hibernate-entitymanager' ) )
 	// MUST use 4.3.1!  4.3.0 was compiled with "-target jsr14".
 	// http://blog.osgi.org/2012/10/43-companion-code-for-java-7.html
 	compile( "org.osgi:org.osgi.core:4.3.1" )
 	compile( "org.osgi:org.osgi.compendium:4.3.1" )
 	
 	testCompile( libraries.shrinkwrap_api )
 	testCompile( libraries.shrinkwrap )
 	testCompile( "org.jboss.arquillian.junit:arquillian-junit-container:1.0.3.Final" )
 	testCompile( "org.jboss.osgi.metadata:jbosgi-metadata:3.0.0.CR1" )
 	testRuntime( "org.jboss.arquillian.container:arquillian-osgi-felix:2.0.0.CR4" )
 	testRuntime( "org.apache.felix:org.apache.felix.framework:4.0.3" )
 	testRuntime( "org.apache.felix:org.apache.felix.main:4.0.3" )
 	testRuntime( "org.jboss.logmanager:jboss-logmanager:1.4.1.Final" )
 	
 	// Local copies of all jars needed fur the OSGi runtime.  Ignore the transitive dependencies.
 	// ORDER DEPENDENT!!!
 	osgiRuntime( "org.jboss.arquillian.osgi:arquillian-osgi-bundle:1.0.3.Final" ) { transitive = false }
 	osgiRuntime( libraries.jpa ) { transitive = false }
 	osgiRuntime( "org.jboss.spec.javax.interceptor:jboss-interceptors-api_1.2_spec:1.0.0.Alpha1" ) { transitive = false }
 	osgiRuntime( libraries.jta ) { transitive = false }
 	osgiRuntime( "com.h2database:h2:1.3.170" ) { transitive = false }
 	osgiRuntime( "org.apache.servicemix.bundles:org.apache.servicemix.bundles.antlr:2.7.7_5" ) { transitive = false }
 	osgiRuntime( libraries.javassist ) { transitive = false }
 	osgiRuntime( "org.apache.servicemix.specs:org.apache.servicemix.specs.stax-api-1.2:2.2.0" ) { transitive = false }
 	osgiRuntime( "org.apache.servicemix.bundles:org.apache.servicemix.bundles.dom4j:1.6.1_5" ) { transitive = false }
 	osgiRuntime( libraries.commons_annotations ) { transitive = false }
 	osgiRuntime( libraries.classmate ) { transitive = false }
 	osgiRuntime( libraries.logging ) { transitive = false }
 	
 	// needed for BND
 	osgiRuntimeBnd( libraries.jandex ) { transitive = false }
 	osgiRuntimeBnd( "javax.enterprise:cdi-api:1.1" ) { transitive = false }
 	osgiRuntimeBnd( "javax.el:el-api:2.2" ) { transitive = false }
 	
 	testClientBundleCompile( project( ':hibernate-core' ) )
 	testClientBundleCompile( project( ':hibernate-entitymanager' ) )
 	// MUST use 4.3.1!  4.3.0 was compiled with "-target jsr14".
 	// http://blog.osgi.org/2012/10/43-companion-code-for-java-7.html
 	testClientBundleCompile( "org.osgi:org.osgi.core:4.3.1" )
 }
 
 def pomName() {
 	return 'Hibernate OSGi Support'
 }
 
 def pomDescription() {
 	return 'Support for running Hibernate O/RM in OSGi environments'
 }
 
 def osgiDescription() {
 	return pomDescription()
 }
 
 jar {
 	manifest {
 		instruction 'Bundle-Activator', 'org.hibernate.osgi.HibernateBundleActivator'
 
 		instructionFirst 'Import-Package',
 			// TODO: Shouldn't have to explicitly list this, but the plugin
 			// generates it with a [1.0,2) version.
 			'javax.persistence;version="2.1.0"',
 			'javax.persistence.spi;version="2.1.0"'
 	}
 }
 
 task copyBnd(type: Copy) {
 	from "src/test/resources/bnd"
 	into "$buildDir/osgi-lib/bnd"
 }
 
 task runBnd(type: JavaExec){
 	main = "-jar"
 	args "$buildDir/osgi-lib/bnd/bnd-2.1.0.jar", "$buildDir/osgi-lib/bnd/cdi-api.bnd", "$buildDir/osgi-lib/bnd/el-api.bnd", "$buildDir/osgi-lib/bnd/jandex.bnd"
 }
 
 task copyToLib(type: Copy) {
 	from configurations.osgiRuntime
 	from configurations.osgiRuntimeBnd
 	into "$buildDir/osgi-lib"
 }
 
 task felixProperties << {
 	copy {
 		from "src/test/resources/felix-framework.properties-ORIGINAL"
 		into "$buildDir/osgi-lib"
 		rename { String fileName ->
 			fileName.replace("-ORIGINAL", "")
 		}
 	}
 	
 	propertiesFile = file("$buildDir/osgi-lib/felix-framework.properties")
 	
 	// append jars wrapped using BND
 	FileTree tree = fileTree(dir: "$buildDir/osgi-lib/bnd")
 	tree.exclude "*bnd*"
 	tree.each {File file ->
 		propertiesFile << " \\\nfile:target/osgi-lib/bnd/" + file.name
 	}
 	
 	// append all jars in osgiRuntime configuration
 	configurations.osgiRuntime.each { File file ->
 		propertiesFile << " \\\nfile:target/osgi-lib/" + file.name
 	}
 	
 	// append ORM jars
 	// TODO: Is there a better, dynamic way of doing this?
 	propertiesFile << " \\\nfile:../hibernate-core/target/libs/hibernate-core-" + hibernateTargetVersion + ".jar"
 	propertiesFile << " \\\nfile:../hibernate-entitymanager/target/libs/hibernate-entitymanager-" + hibernateTargetVersion + ".jar"
 	propertiesFile << " \\\nfile:target/libs/hibernate-osgi-" + hibernateTargetVersion + ".jar"
 }
 
 task testClientBundleJar(type: Jar) {
 	from sourceSets.testClientBundle.output
 	destinationDir new File("$buildDir/osgi-lib")
 	archiveName "testClientBundle.jar"
 	
 	// The OSGi plugin acts up when we need to export multiple source sets.  Just do it manually.
 	manifest {
 		attributes("Export-Package" : "org.hibernate.osgi.test.client,org.hibernate.osgi.test.result",
 					"Bundle-Name" : "testClientBundle",
 					"Bundle-Activator" : "org.hibernate.osgi.test.client.OsgiTestActivator",
 					"Bundle-ManifestVersion" : "2",
 					"Bundle-SymbolicName" : "testClientBundle",
 					"Import-Package" : "javassist.util.proxy,javax.persistence,javax.persistence.spi,org.h2,org.osgi.framework,"
 							+ "org.hibernate,"
 							+ "org.hibernate.boot.registry.selector,"
 							+ "org.hibernate.boot.registry.selector.spi,"
 							+ "org.hibernate.cfg,"
 							+ "org.hibernate.engine.spi,"
 							+ "org.hibernate.integrator.spi,"
 							+ "org.hibernate.metamodel.source,"
 							+ "org.hibernate.metamodel.spi,"
 							+ "org.hibernate.proxy,"
 							+ "org.hibernate.service,"
 							+ "org.hibernate.service.spi")
 	}
 }
 
 runBnd.dependsOn copyToLib
 runBnd.dependsOn copyBnd
 felixProperties.dependsOn runBnd
 test.dependsOn felixProperties
 test.dependsOn testClientBundleJar
 test.dependsOn jar
diff --git a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProvider.java b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProvider.java
index 622def1e9d..83dc6057c7 100644
--- a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProvider.java
+++ b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiPersistenceProvider.java
@@ -1,154 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.osgi;
 
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.spi.PersistenceUnitInfo;
 
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.jpa.HibernatePersistenceProvider;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;
 import org.hibernate.jpa.boot.spi.IntegratorProvider;
 import org.hibernate.jpa.boot.spi.StrategyRegistrationProviderList;
 import org.hibernate.jpa.boot.spi.TypeContributorList;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleReference;
 
 /**
  * Acts as the PersistenceProvider service in OSGi environments
  *
  * @author Brett Meyer
  * @author Tim Ward
  */
 public class OsgiPersistenceProvider extends HibernatePersistenceProvider {
 	private OsgiClassLoader osgiClassLoader;
 	private OsgiJtaPlatform osgiJtaPlatform;
 	private OsgiServiceUtil osgiServiceUtil;
 	private Bundle requestingBundle;
 
 	/**
 	 * Constructs a OsgiPersistenceProvider
 	 *
 	 * @param osgiClassLoader The ClassLoader we built from OSGi Bundles
 	 * @param osgiJtaPlatform The OSGi-specific JtaPlatform impl we built
 	 * @param requestingBundle The OSGi Bundle requesting the PersistenceProvider
 	 * @param context The OSGi context
 	 */
 	public OsgiPersistenceProvider(
 			OsgiClassLoader osgiClassLoader,
 			OsgiJtaPlatform osgiJtaPlatform,
 			OsgiServiceUtil osgiServiceUtil,
 			Bundle requestingBundle) {
 		this.osgiClassLoader = osgiClassLoader;
 		this.osgiJtaPlatform = osgiJtaPlatform;
 		this.osgiServiceUtil = osgiServiceUtil;
 		this.requestingBundle = requestingBundle;
 	}
 
 	// TODO: Does "hibernate.classloaders" and osgiClassLoader need added to the
 	// EMFBuilder somehow?
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) {
 		final Map settings = generateSettings( properties );
 
 		// TODO: This needs tested.
 		settings.put( org.hibernate.jpa.AvailableSettings.SCANNER, new OsgiScanner( requestingBundle ) );
 		// TODO: This is temporary -- for PersistenceXmlParser's use of
 		// ClassLoaderServiceImpl#fromConfigSettings
 		settings.put( AvailableSettings.ENVIRONMENT_CLASSLOADER, osgiClassLoader );
 
 		osgiClassLoader.addBundle( requestingBundle );
 
 		final EntityManagerFactoryBuilder builder = getEntityManagerFactoryBuilderOrNull( persistenceUnitName, settings, osgiClassLoader );
 		return builder == null ? null : builder.build();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties) {
 		final Map settings = generateSettings( properties );
 
 		// OSGi ClassLoaders must implement BundleReference
 		settings.put(
 				org.hibernate.jpa.AvailableSettings.SCANNER,
 				new OsgiScanner( ( (BundleReference) info.getClassLoader() ).getBundle() )
 		);
 
 		osgiClassLoader.addClassLoader( info.getClassLoader() );
 
 		return Bootstrap.getEntityManagerFactoryBuilder( info, settings, osgiClassLoader ).build();
 	}
 
 	@SuppressWarnings("unchecked")
 	private Map generateSettings(Map properties) {
 		final Map settings = new HashMap();
 		if ( properties != null ) {
 			settings.putAll( properties );
 		}
 
 		settings.put( AvailableSettings.JTA_PLATFORM, osgiJtaPlatform );
 
 		final Integrator[] integrators = osgiServiceUtil.getServiceImpls( Integrator.class );
 		final IntegratorProvider integratorProvider = new IntegratorProvider() {
 			@Override
 			public List<Integrator> getIntegrators() {
 				return Arrays.asList( integrators );
 			}
 		};
 		settings.put( EntityManagerFactoryBuilderImpl.INTEGRATOR_PROVIDER, integratorProvider );
 
 		final StrategyRegistrationProvider[] strategyRegistrationProviders = osgiServiceUtil.getServiceImpls(
 				StrategyRegistrationProvider.class );
 		final StrategyRegistrationProviderList strategyRegistrationProviderList = new StrategyRegistrationProviderList() {
 			@Override
 			public List<StrategyRegistrationProvider> getStrategyRegistrationProviders() {
 				return Arrays.asList( strategyRegistrationProviders );
 			}
 		};
 		settings.put( EntityManagerFactoryBuilderImpl.STRATEGY_REGISTRATION_PROVIDERS, strategyRegistrationProviderList );
 
 		final TypeContributor[] typeContributors = osgiServiceUtil.getServiceImpls( TypeContributor.class );
 		final TypeContributorList typeContributorList = new TypeContributorList() {
 			@Override
 			public List<TypeContributor> getTypeContributors() {
 				return Arrays.asList( typeContributors );
 			}
 		};
 		settings.put( EntityManagerFactoryBuilderImpl.TYPE_CONTRIBUTORS, typeContributorList );
 		
 		return settings;
 	}
 }
diff --git a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
index 1268c799e1..42394de5e9 100644
--- a/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
+++ b/hibernate-osgi/src/main/java/org/hibernate/osgi/OsgiSessionFactoryService.java
@@ -1,135 +1,135 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.osgi;
 
 import java.util.Collection;
 
 import org.hibernate.SessionFactory;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.service.ServiceRegistry;
 import org.jboss.logging.Logger;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.ServiceFactory;
 import org.osgi.framework.ServiceRegistration;
 import org.osgi.framework.wiring.BundleWiring;
 
 /**
  * Hibernate 4.2 and 4.3 still heavily rely on TCCL for ClassLoading.  Although
  * our ClassLoaderService removed some of the reliance, the service is
  * unfortunately not available during Configuration.  An OSGi
  * bundle manually creating a SessionFactory would require numerous ClassLoader
  * tricks (or may be impossible altogether).
  * <p/>
  * In order to fully control the TCCL issues and shield users from the
  * knowledge, we're requiring that bundles use this OSGi ServiceFactory.  It
  * configures and provides a SessionFactory as an OSGi service.
  * <p/>
  * Note that an OSGi ServiceFactory differs from a Service.  The ServiceFactory
  * allows individual instances of Services to be created and provided to
  * multiple client Bundles.
  *
  * @author Brett Meyer
  * @author Tim Ward
  */
 public class OsgiSessionFactoryService implements ServiceFactory {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
 			OsgiSessionFactoryService.class.getName());
 	
 	private OsgiClassLoader osgiClassLoader;
 	private OsgiJtaPlatform osgiJtaPlatform;
 	private OsgiServiceUtil osgiServiceUtil;
 
 	/**
 	 * Constructs a OsgiSessionFactoryService
 	 *
 	 * @param osgiClassLoader The OSGi-specific ClassLoader created in HibernateBundleActivator
 	 * @param osgiJtaPlatform The OSGi-specific JtaPlatform created in HibernateBundleActivator
 	 * @param context The OSGi context
 	 */
 	public OsgiSessionFactoryService(
 			OsgiClassLoader osgiClassLoader,
 			OsgiJtaPlatform osgiJtaPlatform,
 			OsgiServiceUtil osgiServiceUtil) {
 		this.osgiClassLoader = osgiClassLoader;
 		this.osgiJtaPlatform = osgiJtaPlatform;
 		this.osgiServiceUtil = osgiServiceUtil;
 	}
 
 	@Override
 	public Object getService(Bundle requestingBundle, ServiceRegistration registration) {
 		osgiClassLoader.addBundle( requestingBundle );
 
 		final Configuration configuration = new Configuration();
 		configuration.getProperties().put( AvailableSettings.JTA_PLATFORM, osgiJtaPlatform );
 		
 		// Allow bundles to put the config file somewhere other than the root level.
 		final BundleWiring bundleWiring = (BundleWiring) requestingBundle.adapt( BundleWiring.class );
 		final Collection<String> cfgResources = bundleWiring.listResources( "/", "hibernate.cfg.xml",
 				BundleWiring.LISTRESOURCES_RECURSE );
 		if (cfgResources.size() == 0) {
 			configuration.configure();
 		}
 		else {
 			if (cfgResources.size() > 1) {
 				LOG.warn( "Multiple hibernate.cfg.xml files found in the persistence bundle.  Using the first one discovered." );
 			}
 			String cfgResource = "/" + cfgResources.iterator().next();
 			configuration.configure( cfgResource );
 		}
 
 		final BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();
 		final OSGiClassLoaderServiceImpl classLoaderService = new OSGiClassLoaderServiceImpl( osgiClassLoader, osgiServiceUtil );
 		builder.with( classLoaderService );
 
 		final Integrator[] integrators = osgiServiceUtil.getServiceImpls( Integrator.class );
 		for ( Integrator integrator : integrators ) {
 			builder.with( integrator );
 		}
 
 		final StrategyRegistrationProvider[] strategyRegistrationProviders
 				= osgiServiceUtil.getServiceImpls( StrategyRegistrationProvider.class );
 		for ( StrategyRegistrationProvider strategyRegistrationProvider : strategyRegistrationProviders ) {
 			builder.withStrategySelectors( strategyRegistrationProvider );
 		}
 
 		final TypeContributor[] typeContributors = osgiServiceUtil.getServiceImpls( TypeContributor.class );
 		for ( TypeContributor typeContributor : typeContributors ) {
 			configuration.registerTypeContributor( typeContributor );
 		}
 
 		final ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder( builder.build() )
 				.applySettings( configuration.getProperties() ).build();
 		return configuration.buildSessionFactory( serviceRegistry );
 	}
 
 	@Override
 	public void ungetService(Bundle requestingBundle, ServiceRegistration registration, Object service) {
 		((SessionFactory) service).close();
 	}
 
 }
diff --git a/hibernate-osgi/src/test/java/org/hibernate/osgi/test/OsgiTestCase.java b/hibernate-osgi/src/test/java/org/hibernate/osgi/test/OsgiTestCase.java
index cf32c4fc60..01fe925397 100644
--- a/hibernate-osgi/src/test/java/org/hibernate/osgi/test/OsgiTestCase.java
+++ b/hibernate-osgi/src/test/java/org/hibernate/osgi/test/OsgiTestCase.java
@@ -1,289 +1,289 @@
 /*
  * JBoss, Home of Professional Open Source
  * Copyright 2013, Red Hat Middleware LLC, and individual contributors
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  * http://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package org.hibernate.osgi.test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 import java.io.InputStream;
 
 import org.hibernate.Hibernate;
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.osgi.OsgiPersistenceProviderService;
 import org.hibernate.osgi.OsgiSessionFactoryService;
 import org.hibernate.osgi.test.client.DataPoint;
 import org.hibernate.osgi.test.client.TestService;
 import org.jboss.arquillian.container.test.api.Deployment;
 import org.jboss.arquillian.junit.Arquillian;
 import org.jboss.arquillian.junit.InSequence;
 import org.jboss.arquillian.test.api.ArquillianResource;
 import org.jboss.osgi.metadata.OSGiManifestBuilder;
 import org.jboss.shrinkwrap.api.ShrinkWrap;
 import org.jboss.shrinkwrap.api.asset.Asset;
 import org.jboss.shrinkwrap.api.spec.JavaArchive;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
 
 /**
  * A separate sourceset, testClientBundle, contains a persistence unit and an OSGi service interface providing
  * multiple uses of Native and JPA functionality.  The use of a SF/EMF must occur in that separate bundle, rather than
  * attempting to programmatically create a bundle and obtain/use an SF/EMF here.  There are
  * MANY ClassLoader issues with that sort of setup.  JPA annotations are "stripped", since one ClassLoader is used here
  * to create the entity's stream and another is used to parse it within core.  Further, the entire Felix framework
  * is given to hibernate-osgi as the "requestingBundle" in that setup, regardless of Arquillian vs. Pax Exam.  That
  * causes another slew of ClassLoader issues as well.
  * 
  * This is the most "realistic" type of test anyway with a *real* client bundle.
  * 
  * IMPORTANT: There are a few maintenance points that need addressed for new versions of Hibernate and library upgrades:
  * 1.) Updated library versions in hibernate-osgi.gradle.  libraries.gradle is used wherever possible.  But, there
  *     may be a few manual updates needed.
  * 2.) If a new version of Felix is used, download and start it manually in the command line.  Run
  *     "felix:headers 0" to obtain the list of packages exported and used by the framework.  As of this writing,
  *     the framework has javax.transaction.* and javax.xml.stream.* in "uses" attributes.  I had to remove all instances
  *     of those packages in the "uses" to correct dependency conflicts that are fairly well documented in the community.
  *     "org.osgi.framework.BundleException: Uses constraint violation..." occurs when a specific version of a package is exported
  *     by a bundle (ex: our JPA 2.1), the same package is exported by another bundle (without a version), and the package appears in a
  *     "uses" attribute (without a version).  Rather than do something hacky in the hibernate-osgi manifest itself,
  *     src/test/resources/felix-framework.properties contains the entire list as a property ("org.osgi.framework.system.packages"),
  *     stripped of the javax.transaction nonsense.  This may need to be repeated if Felix is ever updated in ORM
  *     (should be rare).
  *     
  * This should largerly be considered an integration test, rather than a granular unit test.  Also, this is almost
  * guaranteed to not work in your IDE.
  *
  * @author Brett Meyer
  */
 @RunWith(Arquillian.class)
 public class OsgiTestCase {
 
 	@ArquillianResource
 	BundleContext context;
 
 	/**
 	 * Sets up the Arquillian "deployment", creating a bundle with this test class and the framework.
 	 * 
 	 * @return JavaArchive
 	 */
 	@Deployment
 	public static JavaArchive deployment() {
 		final JavaArchive archive = ShrinkWrap.create( JavaArchive.class, "hibernate-osgi-test" );
 
 		archive.setManifest( new Asset() {
 			@Override
 			public InputStream openStream() {
 				final OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();
 				builder.addBundleSymbolicName( archive.getName() );
 				builder.addBundleManifestVersion( 2 );
 				builder.addImportPackages( TestService.class );
 				// ORM packages needed in the tests
 				builder.addImportPackages( Hibernate.class );
 				builder.addImportPackages( Integrator.class );
 				builder.addImportPackages( StrategyRegistrationProvider.class );
 				builder.addImportPackages( TypeContributor.class );
 				builder.addImportPackages( OsgiSessionFactoryService.class );
 				return builder.openStream();
 			}
 		} );
 
 		return archive;
 	}
 
 	/**
 	 * Test the persistence unit bundle.
 	 * 
 	 * @throws Exception
 	 */
 	@Test
 	@InSequence(1)
 	public void testClientBundle() throws Exception {
 		commonTests();
 
 		final Bundle testClientBundle = findHibernateBundle( "testClientBundle" );
 		assertNotNull( "The test client bundle was not found!", testClientBundle );
 		testClientBundle.start();
 		assertEquals( "The test client bundle was not activated!", Bundle.ACTIVE, testClientBundle.getState() );
 	}
 	
 	@Test
 	@InSequence(2)
 	public void testJpa() throws Exception {
 		commonTests();
 
 		final TestService testService = getTestService();
 		
 		DataPoint dp = new DataPoint();
 		dp.setName( "Brett" );
 		testService.saveJpa( dp );
 
 		dp = testService.getJpa(dp.getId());
 		assertNotNull( dp );
 		assertEquals( "Brett", dp.getName() );
 		
 		dp.setName( "Brett2" );
 		testService.updateJpa( dp );
 
 		dp = testService.getJpa(dp.getId());
 		assertNotNull( dp );
 		assertEquals( "Brett2", dp.getName() );
 
 		testService.deleteJpa();
 
 		dp = testService.getJpa(dp.getId());
 		assertNull( dp );
 	}
 	
 	@Test
 	@InSequence(2)
 	public void testNative() throws Exception {
 		commonTests();
 
 		final TestService testService = getTestService();
 		
 		DataPoint dp = new DataPoint();
 		dp.setName( "Brett" );
 		testService.saveNative( dp );
 
 		dp = testService.getNative(dp.getId());
 		assertNotNull( dp );
 		assertEquals( "Brett", dp.getName() );
 		
 		dp.setName( "Brett2" );
 		testService.updateNative( dp );
 
 		dp = testService.getNative(dp.getId());
 		assertNotNull( dp );
 		assertEquals( "Brett2", dp.getName() );
 
 		testService.deleteNative();
 
 		dp = testService.getNative(dp.getId());
 		assertNull( dp );
 	}
 	
 	@Test
 	@InSequence(2)
 	public void testLazyLoading() throws Exception {
 		commonTests();
 
 		final TestService testService = getTestService();
 		
 		DataPoint dp = new DataPoint();
 		dp.setName( "Brett" );
 		testService.saveNative( dp );
 		
 		// #lazyLoad will init dp on its own
 		dp = testService.lazyLoad( dp.getId() );
 		assertNotNull( dp );
 		assertTrue( Hibernate.isInitialized( dp ) );
 		assertEquals( "Brett", dp.getName() );
 	}
 	
 	@Test
 	@InSequence(2)
 	public void testExtensionPoints() throws Exception {
 		commonTests();
 		
 		final TestService testService = getTestService();
 
 		assertNotNull( testService.getTestIntegrator() );
 		assertTrue( testService.getTestIntegrator().passed() );
 		
 		assertNotNull( testService.getTestStrategyRegistrationProvider() );
 		assertTrue( testService.getTestStrategyRegistrationProvider().passed() );
 		
 		assertNotNull( testService.getTestTypeContributor() );
 		assertTrue( testService.getTestTypeContributor().passed() );
 	}
 
 	/*
 	 * FIXME: Arquillian testing infrastructure is not ready to
 	 * handle the blueprints configuration yet.
 	 *
 	 * This implies the following test might be wrong as it never worked;
 	 * we know the feature works because of a different test in the
 	 * Hibernate Search project which is using PAX rather than Arquillian.
 	 *
 	@Test
 	@InSequence(2)
 	public void testServiceContributorDiscovery() throws Exception {
 		commonTests();
 
 		final TestService testService = getTestService();
 
 		assertTrue( testService.isCustomServiceContributorRegistered() );
 	}
 	*/
 
 	/**
 	 * Test that stopping the hibernate-osgi bundle happens cleanly.
 	 * 
 	 * TODO: This will be really simplistic at first, but should be expanded upon.
 	 * 
 	 * @throws Exception
 	 */
 	@Test
 	// Arquillian does not restart the container between runs (afaik).  Without the ordering, the tests will
 	// intermittently fail since this method stops the bundle.
 	@InSequence(3)
 	public void testStop() throws Exception {
 		commonTests();
 
 		findHibernateBundle( "org.hibernate.osgi" ).stop();
 		testHibernateBundle( "org.hibernate.osgi", Bundle.RESOLVED );
 		
 		assertNull( context.getServiceReference( OsgiSessionFactoryService.class ) );
 		assertNull( context.getServiceReference( OsgiPersistenceProviderService.class ) );
 	}
 	
 	private void commonTests() {
 		assertNotNull( "BundleContext injected", context );
 		assertEquals( "System Bundle ID", 0, context.getBundle().getBundleId() );
 
 		testHibernateBundle( "org.hibernate.core", Bundle.ACTIVE );
 		testHibernateBundle( "org.hibernate.entitymanager", Bundle.ACTIVE );
 		testHibernateBundle( "org.hibernate.osgi", Bundle.ACTIVE );
 	}
 
 	private Bundle findHibernateBundle(String symbolicName) {
 		for ( Bundle bundle : context.getBundles() ) {
 			if ( bundle.getSymbolicName().equals( symbolicName ) ) {
 				return bundle;
 			}
 		}
 		return null;
 	}
 
 	private void testHibernateBundle(String symbolicName, int state) {
 		final Bundle bundle = findHibernateBundle( symbolicName );
 
 		assertNotNull( "Bundle " + symbolicName + " was not found!", bundle );
 		assertEquals( "Bundle " + symbolicName + " was not in the expected state!", state, bundle.getState() );
 	}
 	
 	private TestService getTestService() {
 		final ServiceReference<?> serviceReference = context.getServiceReference( TestService.class.getName() );
 		return (TestService) context.getService( serviceReference );
 	}
 }
diff --git a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/OsgiTestActivator.java b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/OsgiTestActivator.java
index 98bc774ae8..b71306ee3d 100644
--- a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/OsgiTestActivator.java
+++ b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/OsgiTestActivator.java
@@ -1,60 +1,60 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.osgi.test.client;
 
 import java.util.Hashtable;
 
 import org.hibernate.boot.registry.selector.StrategyRegistrationProvider;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributor;
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
 
 /**
  * @author Brett Meyer
  */
 public class OsgiTestActivator implements BundleActivator {
 
 	private TestService testService;
 
 	@Override
 	public void start(BundleContext context) throws Exception {
 		
 		final TestIntegrator integrator = new TestIntegrator();
 		final TestStrategyRegistrationProvider strategyRegistrationProvider = new TestStrategyRegistrationProvider();
 		final TestTypeContributor typeContributor = new TestTypeContributor();
 		
 		// register example extension point services
 		context.registerService( Integrator.class, integrator, new Hashtable() );
 		context.registerService( StrategyRegistrationProvider.class, strategyRegistrationProvider, new Hashtable() );
 		context.registerService( TypeContributor.class, typeContributor, new Hashtable() );
 
 		// register the test result service
 		testService = new TestServiceImpl(context, integrator, strategyRegistrationProvider, typeContributor);
 		context.registerService( TestService.class, testService, new Hashtable() );
 	}
 
 	@Override
 	public void stop(BundleContext context) throws Exception {
 
 	}
 
 }
diff --git a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestIntegrator.java b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestIntegrator.java
index 89eabd5eb3..b6f44f856a 100644
--- a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestIntegrator.java
+++ b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestIntegrator.java
@@ -1,53 +1,48 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.osgi.test.client;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 
 /**
  * @author Brett Meyer
  */
 public class TestIntegrator implements Integrator {
 	
 	private boolean passed = false;
 
 	public void integrate(Configuration configuration, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		passed = true;
 	}
 
-	public void integrate(MetadataImplementor metadata, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
-		passed = true;
-	}
-
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		passed = true;
 	}
 	
 	public boolean passed() {
 		return passed;
 	}
 
 }
diff --git a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestTypeContributor.java b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestTypeContributor.java
index 8cf3e32894..fdf588d99a 100644
--- a/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestTypeContributor.java
+++ b/hibernate-osgi/src/testClientBundle/java/org/hibernate/osgi/test/client/TestTypeContributor.java
@@ -1,43 +1,43 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.osgi.test.client;
 
-import org.hibernate.metamodel.spi.TypeContributions;
-import org.hibernate.metamodel.spi.TypeContributor;
+import org.hibernate.boot.model.TypeContributions;
+import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.service.ServiceRegistry;
 
 
 /**
  * @author Brett Meyer
  */
 public class TestTypeContributor implements TypeContributor {
 	
 	private boolean passed = false;
 
 	public void contribute(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {
 		passed = true;
 	}
 	
 	public boolean passed() {
 		return passed;
 	}
 
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
index 64da3a4662..26d950cedf 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
@@ -1,560 +1,493 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.junit4;
 
 import java.io.InputStream;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.Session;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
-import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.AbstractReturningWork;
 import org.hibernate.jdbc.Work;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.SimpleValue;
-import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.MetadataImplementor;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.OnExpectedFailure;
 import org.hibernate.testing.OnFailure;
 import org.hibernate.testing.SkipLog;
 import org.hibernate.testing.cache.CachingRegionFactory;
 import org.junit.After;
 import org.junit.Before;
 
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
 
 /**
  * Applies functional testing logic for core Hibernate testing on top of {@link BaseUnitTestCase}
  *
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"deprecation"} )
 public abstract class BaseCoreFunctionalTestCase extends BaseUnitTestCase {
 	public static final String VALIDATE_DATA_CLEANUP = "hibernate.test.validateDataCleanup";
-	public static final String USE_NEW_METADATA_MAPPINGS = "hibernate.test.new_metadata_mappings";
 
 	public static final Dialect DIALECT = Dialect.getDialect();
 
-	private boolean isMetadataUsed;
 	private Configuration configuration;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 
 	protected Session session;
 
 	protected static Dialect getDialect() {
 		return DIALECT;
 	}
 
 	protected Configuration configuration() {
 		return configuration;
 	}
 
 	protected StandardServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected SessionFactoryImplementor sessionFactory() {
 		return sessionFactory;
 	}
 
 	protected Session openSession() throws HibernateException {
 		session = sessionFactory().openSession();
 		return session;
 	}
 
 	protected Session openSession(Interceptor interceptor) throws HibernateException {
 		session = sessionFactory().withOptions().interceptor( interceptor ).openSession();
 		return session;
 	}
 
 
 	// before/after test class ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@BeforeClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected void buildSessionFactory() {
 		// for now, build the configuration to get all the property settings
 		configuration = constructAndConfigureConfiguration();
 		BootstrapServiceRegistry bootRegistry = buildBootstrapServiceRegistry();
 		serviceRegistry = buildServiceRegistry( bootRegistry, configuration );
-		isMetadataUsed = serviceRegistry.getService( ConfigurationService.class ).getSetting(
-				USE_NEW_METADATA_MAPPINGS,
-				new ConfigurationService.Converter<Boolean>() {
-					@Override
-					public Boolean convert(Object value) {
-						return Boolean.parseBoolean( ( String ) value );
-					}
-				},
-				false
-		);
-		if ( isMetadataUsed ) {
-			MetadataImplementor metadataImplementor = buildMetadata( bootRegistry, serviceRegistry );
-			afterConstructAndConfigureMetadata( metadataImplementor );
-			sessionFactory = ( SessionFactoryImplementor ) metadataImplementor.buildSessionFactory();
-		}
-		else {
-			// this is done here because Configuration does not currently support 4.0 xsd
-			afterConstructAndConfigureConfiguration( configuration );
-			sessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );
-		}
+		// this is done here because Configuration does not currently support 4.0 xsd
+		afterConstructAndConfigureConfiguration( configuration );
+		sessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );
 		afterSessionFactoryBuilt();
 	}
 
 	protected void rebuildSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		try {
 			sessionFactory.close();
 			sessionFactory = null;
 			configuration = null;
 			serviceRegistry.destroy();
 			serviceRegistry = null;
 		}
 		catch (Exception ignore) {
 		}
 
 		buildSessionFactory();
 	}
 
-
-	protected void afterConstructAndConfigureMetadata(MetadataImplementor metadataImplementor) {
-
-	}
-
-	private MetadataImplementor buildMetadata(
-			BootstrapServiceRegistry bootRegistry,
-			StandardServiceRegistryImpl serviceRegistry) {
-		MetadataSources sources = new MetadataSources( bootRegistry );
-		addMappings( sources );
-		return (MetadataImplementor) sources.getMetadataBuilder( serviceRegistry ).build();
-	}
-
-	// TODO: is this still needed?
 	protected Configuration buildConfiguration() {
 		Configuration cfg = constructAndConfigureConfiguration();
 		afterConstructAndConfigureConfiguration( cfg );
 		return cfg;
 	}
 
 	protected Configuration constructAndConfigureConfiguration() {
 		Configuration cfg = constructConfiguration();
 		configure( cfg );
 		return cfg;
 	}
 
 	private void afterConstructAndConfigureConfiguration(Configuration cfg) {
 		addMappings( cfg );
 		cfg.buildMappings();
 		applyCacheSettings( cfg );
 		afterConfigurationBuilt( cfg );
 	}
 
 	protected Configuration constructConfiguration() {
 		Configuration configuration = new Configuration()
 				.setProperty(Environment.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName()  );
 		configuration.setProperty( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		if ( createSchema() ) {
 			configuration.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 			final String secondSchemaName = createSecondSchema();
 			if ( StringHelper.isNotEmpty( secondSchemaName ) ) {
 				if ( !( getDialect() instanceof H2Dialect ) ) {
 					throw new UnsupportedOperationException( "Only H2 dialect supports creation of second schema." );
 				}
 				Helper.createH2Schema( secondSchemaName, configuration );
 			}
 		}
 		configuration.setProperty( Environment.DIALECT, getDialect().getClass().getName() );
 		return configuration;
 	}
 
 	protected void configure(Configuration configuration) {
 	}
 
 	protected void addMappings(Configuration configuration) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			for ( String mapping : mappings ) {
 				configuration.addResource(
 						getBaseForMappings() + mapping,
 						getClass().getClassLoader()
 				);
 			}
 		}
 		Class<?>[] annotatedClasses = getAnnotatedClasses();
 		if ( annotatedClasses != null ) {
 			for ( Class<?> annotatedClass : annotatedClasses ) {
 				configuration.addAnnotatedClass( annotatedClass );
 			}
 		}
 		String[] annotatedPackages = getAnnotatedPackages();
 		if ( annotatedPackages != null ) {
 			for ( String annotatedPackage : annotatedPackages ) {
 				configuration.addPackage( annotatedPackage );
 			}
 		}
 		String[] xmlFiles = getXmlFiles();
 		if ( xmlFiles != null ) {
 			for ( String xmlFile : xmlFiles ) {
 				InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( xmlFile );
 				configuration.addInputStream( is );
 			}
 		}
 	}
 
-	protected void addMappings(MetadataSources sources) {
-		String[] mappings = getMappings();
-		if ( mappings != null ) {
-			for ( String mapping : mappings ) {
-				sources.addResource(
-						getBaseForMappings() + mapping
-				);
-			}
-		}
-		Class<?>[] annotatedClasses = getAnnotatedClasses();
-		if ( annotatedClasses != null ) {
-			for ( Class<?> annotatedClass : annotatedClasses ) {
-				sources.addAnnotatedClass( annotatedClass );
-			}
-		}
-		String[] annotatedPackages = getAnnotatedPackages();
-		if ( annotatedPackages != null ) {
-			for ( String annotatedPackage : annotatedPackages ) {
-				sources.addPackage( annotatedPackage );
-			}
-		}
-		String[] xmlFiles = getXmlFiles();
-		if ( xmlFiles != null ) {
-			for ( String xmlFile : xmlFiles ) {
-				InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( xmlFile );
-				sources.addInputStream( is );
-			}
-		}
-	}
-
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected String getBaseForMappings() {
 		return "org/hibernate/test/";
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return NO_MAPPINGS;
 	}
 
 	protected String[] getXmlFiles() {
 		// todo : rename to getOrmXmlFiles()
 		return NO_MAPPINGS;
 	}
 
 	protected void applyCacheSettings(Configuration configuration) {
 		if ( getCacheConcurrencyStrategy() != null ) {
 			Iterator itr = configuration.getClassMappings();
 			while ( itr.hasNext() ) {
 				PersistentClass clazz = (PersistentClass) itr.next();
 				Iterator props = clazz.getPropertyClosureIterator();
 				boolean hasLob = false;
 				while ( props.hasNext() ) {
 					Property prop = (Property) props.next();
 					if ( prop.getValue().isSimpleValue() ) {
 						String type = ( (SimpleValue) prop.getValue() ).getTypeName();
 						if ( "blob".equals(type) || "clob".equals(type) ) {
 							hasLob = true;
 						}
 						if ( Blob.class.getName().equals(type) || Clob.class.getName().equals(type) ) {
 							hasLob = true;
 						}
 					}
 				}
 				if ( !hasLob && !clazz.isInherited() && overrideCacheStrategy() ) {
 					configuration.setCacheConcurrencyStrategy( clazz.getEntityName(), getCacheConcurrencyStrategy() );
 				}
 			}
 			itr = configuration.getCollectionMappings();
 			while ( itr.hasNext() ) {
 				Collection coll = (Collection) itr.next();
 				configuration.setCollectionCacheConcurrencyStrategy( coll.getRole(), getCacheConcurrencyStrategy() );
 			}
 		}
 	}
 
 	protected boolean overrideCacheStrategy() {
 		return true;
 	}
 
 	protected String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	protected void afterConfigurationBuilt(Configuration configuration) {
 		afterConfigurationBuilt( configuration.createMappings(), getDialect() );
 	}
 
 	protected void afterConfigurationBuilt(Mappings mappings, Dialect dialect) {
 	}
 
 	protected BootstrapServiceRegistry buildBootstrapServiceRegistry() {
 		final BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();
 		prepareBootstrapRegistryBuilder( builder );
 		return builder.build();
 	}
 
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 	}
 
 	protected StandardServiceRegistryImpl buildServiceRegistry(BootstrapServiceRegistry bootRegistry, Configuration configuration) {
 		Properties properties = new Properties();
 		properties.putAll( configuration.getProperties() );
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
 
 		StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder( bootRegistry ).applySettings( properties );
 		prepareBasicRegistryBuilder( registryBuilder );
 		return (StandardServiceRegistryImpl) registryBuilder.build();
 	}
 
 	protected void prepareBasicRegistryBuilder(StandardServiceRegistryBuilder serviceRegistryBuilder) {
 	}
 
 	protected void afterSessionFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	/**
 	 * Feature supported only by H2 dialect.
 	 * @return Provide not empty name to create second schema.
 	 */
 	protected String createSecondSchema() {
 		return null;
 	}
 
 	protected boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@AfterClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected void releaseSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		sessionFactory.close();
 		sessionFactory = null;
 		configuration = null;
         if ( serviceRegistry != null ) {
 			if ( serviceRegistry.isActive() ) {
 				try {
 					serviceRegistry.destroy();
 				}
 				catch (Exception ignore) {
 				}
 				fail( "StandardServiceRegistry was not closed down as expected" );
 			}
 		}
         serviceRegistry=null;
 	}
 
 	@OnFailure
 	@OnExpectedFailure
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void onFailure() {
 		if ( rebuildSessionFactoryOnError() ) {
 			rebuildSessionFactory();
 		}
 	}
 
 
 	// before/after each test ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Before
 	public final void beforeTest() throws Exception {
 		prepareTest();
 	}
 
 	protected void prepareTest() throws Exception {
 	}
 
 	@After
 	public final void afterTest() throws Exception {
 		if ( isCleanupTestDataRequired() ) {
 			cleanupTestData();
 		}
 		cleanupTest();
 
 		cleanupSession();
 
 		assertAllDataRemoved();
 
 	}
 
 	protected void cleanupCache() {
 		if ( sessionFactory != null ) {
 			sessionFactory.getCache().evictAllRegions();
 		}
 	}
 	
 	protected boolean isCleanupTestDataRequired() { return false; }
 	
 	protected void cleanupTestData() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete from java.lang.Object" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 
 	private void cleanupSession() {
 		if ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {
 			if ( session.isConnected() ) {
 				session.doWork( new RollbackWork() );
 			}
 			session.close();
 		}
 		session = null;
 	}
 
 	public class RollbackWork implements Work {
 		public void execute(Connection connection) throws SQLException {
 			connection.rollback();
 		}
 	}
 
 	protected void cleanupTest() throws Exception {
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	protected void assertAllDataRemoved() {
 		if ( !createSchema() ) {
 			return; // no tables were created...
 		}
 		if ( !Boolean.getBoolean( VALIDATE_DATA_CLEANUP ) ) {
 			return;
 		}
 
 		Session tmpSession = sessionFactory.openSession();
 		try {
 			List list = tmpSession.createQuery( "select o from java.lang.Object o" ).list();
 
 			Map<String,Integer> items = new HashMap<String,Integer>();
 			if ( !list.isEmpty() ) {
 				for ( Object element : list ) {
 					Integer l = items.get( tmpSession.getEntityName( element ) );
 					if ( l == null ) {
 						l = 0;
 					}
 					l = l + 1 ;
 					items.put( tmpSession.getEntityName( element ), l );
 					System.out.println( "Data left: " + element );
 				}
 				fail( "Data is left in the database: " + items.toString() );
 			}
 		}
 		finally {
 			try {
 				tmpSession.close();
 			}
 			catch( Throwable t ) {
 				// intentionally empty
 			}
 		}
 	}
 
 	protected boolean readCommittedIsolationMaintained(String scenario) {
 		int isolation = java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
 		Session testSession = null;
 		try {
 			testSession = openSession();
 			isolation = testSession.doReturningWork(
 					new AbstractReturningWork<Integer>() {
 						@Override
 						public Integer execute(Connection connection) throws SQLException {
 							return connection.getTransactionIsolation();
 						}
 					}
 			);
 		}
 		catch( Throwable ignore ) {
 		}
 		finally {
 			if ( testSession != null ) {
 				try {
 					testSession.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		if ( isolation < java.sql.Connection.TRANSACTION_READ_COMMITTED ) {
 			SkipLog.reportSkip( "environment does not support at least read committed isolation", scenario );
 			return false;
 		}
 		else {
 			return true;
 		}
 	}
 }
diff --git a/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/CompilationRunner.java b/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/CompilationRunner.java
index edd6c8d9ef..cd961e137e 100644
--- a/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/CompilationRunner.java
+++ b/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/CompilationRunner.java
@@ -1,140 +1,140 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat, Inc. and/or its affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat, Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpamodelgen.test.util;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.junit.runners.BlockJUnit4ClassRunner;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
 
 /**
  * Custom JUnit runner which makes sure the annotation processor runs prior to the test method.
  *
  * @author Hardy Ferentschik
  * @see CompilationStatement
  */
 public class CompilationRunner extends BlockJUnit4ClassRunner {
 	private final List<Class<?>> testEntities;
 	private final List<Class<?>> preCompileEntities;
 	private final List<String> mappingFiles;
 	private final Map<String, String> processorOptions;
 	private final String packageName;
 	private boolean ignoreCompilationErrors;
 
 
 	public CompilationRunner(Class<?> clazz) throws InitializationError {
 		super( clazz );
 		this.testEntities = new ArrayList<Class<?>>();
 		this.preCompileEntities = new ArrayList<Class<?>>();
 		this.mappingFiles = new ArrayList<String>();
 		this.processorOptions = new HashMap<String, String>();
 		Package pkg = clazz.getPackage();
 		this.packageName = pkg != null ? pkg.getName() : null;
 
 		processWithClasses( clazz.getAnnotation( WithClasses.class ) );
 		processWithMappingFiles( clazz.getAnnotation( WithMappingFiles.class ) );
 		processOptions(
 				clazz.getAnnotation( WithProcessorOption.class ),
 				clazz.getAnnotation( WithProcessorOption.List.class )
 		);
 
 		ignoreCompilationErrors = clazz.getAnnotation( IgnoreCompilationErrors.class ) != null;
 	}
 
 	@Override
 	protected Statement methodBlock(FrameworkMethod method) {
 		Statement statement = super.methodBlock( method );
 		processAnnotations( method );
 		if ( !annotationProcessorNeedsToRun() ) {
 			return statement;
 		}
 
 		return new CompilationStatement(
 				statement,
 				testEntities,
 				preCompileEntities,
 				mappingFiles,
 				processorOptions,
 				ignoreCompilationErrors
 		);
 	}
 
 	private void processWithClasses(WithClasses withClasses) {
 		if ( withClasses != null ) {
 			Collections.addAll( testEntities, withClasses.value() );
 			Collections.addAll( preCompileEntities, withClasses.preCompile() );
 		}
 	}
 
 	private void processWithMappingFiles(WithMappingFiles withMappingFiles) {
 		if ( withMappingFiles != null ) {
 			String packageNameAsPath = TestUtil.fcnToPath( packageName );
 			for ( String mappingFile : withMappingFiles.value() ) {
-				mappingFiles.add( packageNameAsPath + File.separator + mappingFile );
+				mappingFiles.add( packageNameAsPath + TestUtil.RESOURCE_SEPARATOR + mappingFile );
 			}
 		}
 	}
 
 	private void processOptions(WithProcessorOption withProcessorOption,
 			WithProcessorOption.List withProcessorOptionsListAnnotation) {
 		addOptions( withProcessorOption );
 		if ( withProcessorOptionsListAnnotation != null ) {
 			for ( WithProcessorOption option : withProcessorOptionsListAnnotation.value() ) {
 				addOptions( option );
 			}
 		}
 	}
 
 	private void processAnnotations(FrameworkMethod method) {
 		// configuration will be added to potential class level configuration
 		processWithClasses( method.getAnnotation( WithClasses.class ) );
 		processWithMappingFiles( method.getAnnotation( WithMappingFiles.class ) );
 		processOptions(
 				method.getAnnotation( WithProcessorOption.class ),
 				method.getAnnotation( WithProcessorOption.List.class )
 		);
 
 		// overrides potential class level configuration
 		ignoreCompilationErrors = method.getAnnotation( IgnoreCompilationErrors.class ) != null;
 	}
 
 	private void addOptions(WithProcessorOption withProcessorOptionsAnnotation) {
 		if ( withProcessorOptionsAnnotation != null ) {
 			processorOptions.put( withProcessorOptionsAnnotation.key(), withProcessorOptionsAnnotation.value() );
 		}
 	}
 
 	private boolean annotationProcessorNeedsToRun() {
 		return !testEntities.isEmpty() || !mappingFiles.isEmpty();
 	}
 }
 
 
diff --git a/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/TestUtil.java b/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/TestUtil.java
index 571bff07fc..75255a4631 100644
--- a/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/TestUtil.java
+++ b/tooling/metamodel-generator/src/test/java/org/hibernate/jpamodelgen/test/util/TestUtil.java
@@ -1,337 +1,338 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat, Inc. and/or its affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat, Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpamodelgen.test.util;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileFilter;
 import java.io.FileReader;
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.List;
 import javax.tools.Diagnostic;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * @author Hardy Ferentschik
  */
 public class TestUtil {
 	private static final Logger log = LoggerFactory.getLogger( TestUtil.class );
-	private static final String PATH_SEPARATOR = System.getProperty( "file.separator" );
+	private static final String PATH_SEPARATOR = File.separator;
+	public static final String RESOURCE_SEPARATOR = "/";
 	private static final String PACKAGE_SEPARATOR = ".";
 	private static final String META_MODEL_CLASS_POSTFIX = "_";
 	private static final File OUT_BASE_DIR;
 
 	static {
 		File targetDir = getTargetDir();
 		OUT_BASE_DIR = new File( targetDir, "processor-generated-test-classes" );
 		if ( !OUT_BASE_DIR.exists() ) {
 			if ( !OUT_BASE_DIR.mkdirs() ) {
 				fail( "Unable to create test output directory " + OUT_BASE_DIR.toString() );
 			}
 		}
 	}
 
 	private TestUtil() {
 	}
 
 	public static void assertNoSourceFileGeneratedFor(Class<?> clazz) {
 		assertNotNull( "Class parameter cannot be null", clazz );
 		File sourceFile = getMetaModelSourceFileFor( clazz );
 		assertFalse( "There should be no source file: " + sourceFile.getName(), sourceFile.exists() );
 	}
 
 	public static void assertAbsenceOfFieldInMetamodelFor(Class<?> clazz, String fieldName) {
 		assertAbsenceOfFieldInMetamodelFor(
 				clazz,
 				fieldName,
 				"'" + fieldName + "' should not appear in metamodel class"
 		);
 	}
 
 	public static void assertAbsenceOfFieldInMetamodelFor(Class<?> clazz, String fieldName, String errorString) {
 		assertFalse( buildErrorString( errorString, clazz ), hasFieldInMetamodelFor( clazz, fieldName ) );
 	}
 
 	public static void assertPresenceOfFieldInMetamodelFor(Class<?> clazz, String fieldName) {
 		assertPresenceOfFieldInMetamodelFor(
 				clazz,
 				fieldName,
 				"'" + fieldName + "' should appear in metamodel class"
 		);
 	}
 
 	public static void assertPresenceOfFieldInMetamodelFor(Class<?> clazz, String fieldName, String errorString) {
 		assertTrue( buildErrorString( errorString, clazz ), hasFieldInMetamodelFor( clazz, fieldName ) );
 	}
 
 	public static void assertAttributeTypeInMetaModelFor(Class<?> clazz, String fieldName, Class<?> expectedType, String errorString) {
 		Field field = getFieldFromMetamodelFor( clazz, fieldName );
 		assertNotNull( "Cannot find field '" + fieldName + "' in " + clazz.getName(), field );
 		ParameterizedType type = (ParameterizedType) field.getGenericType();
 		Type actualType = type.getActualTypeArguments()[1];
 		if ( expectedType.isArray() ) {
 			expectedType = expectedType.getComponentType();
 			actualType = getComponentType( actualType );
 		}
 		assertEquals(
 				"Types do not match: " + buildErrorString( errorString, clazz ),
 				expectedType,
 				actualType
 		);
 	}
 
 	public static void assertMapAttributesInMetaModelFor(Class<?> clazz, String fieldName, Class<?> expectedMapKey, Class<?> expectedMapValue, String errorString) {
 		Field field = getFieldFromMetamodelFor( clazz, fieldName );
 		assertNotNull( field );
 		ParameterizedType type = (ParameterizedType) field.getGenericType();
 		Type actualMapKeyType = type.getActualTypeArguments()[1];
 		assertEquals( buildErrorString( errorString, clazz ), expectedMapKey, actualMapKeyType );
 
 		Type actualMapKeyValue = type.getActualTypeArguments()[2];
 		assertEquals( buildErrorString( errorString, clazz ), expectedMapValue, actualMapKeyValue );
 	}
 
 	public static void assertSuperClassRelationShipInMetamodel(Class<?> entityClass, Class<?> superEntityClass) {
 		Class<?> clazz = getMetamodelClassFor( entityClass );
 		Class<?> superClazz = getMetamodelClassFor( superEntityClass );
 		assertEquals(
 				"Entity " + superClazz.getName() + " should be the superclass of " + clazz.getName(),
 				superClazz.getName(),
 				clazz.getSuperclass().getName()
 		);
 	}
 
 	public static void assertNoCompilationError(List<Diagnostic<?>> diagnostics) {
 		for ( Diagnostic<?> diagnostic : diagnostics ) {
 			if ( diagnostic.getKind().equals( Diagnostic.Kind.ERROR ) ) {
 				fail( "There was a compilation error during annotation processing:\n" + diagnostic.getMessage( null ) );
 			}
 		}
 	}
 
 	/**
 	 * Asserts that a metamodel class for the specified class got generated.
 	 *
 	 * @param clazz the class for which a metamodel class should have been generated.
 	 */
 	public static void assertMetamodelClassGeneratedFor(Class<?> clazz) {
 		assertNotNull( getMetamodelClassFor( clazz ) );
 	}
 
 	/**
 	 * Deletes recursively all files found in the output directory for the annotation processor.
 	 */
 	public static void deleteProcessorGeneratedFiles() {
 		for ( File file : OUT_BASE_DIR.listFiles() ) {
 			deleteFilesRecursive( file );
 		}
 	}
 
 	/**
 	 * @return the output directory for the generated source and class files.
 	 */
 	public static File getOutBaseDir() {
 		return OUT_BASE_DIR;
 	}
 
 	/**
 	 * Returns the static metamodel class for the specified entity.
 	 *
 	 * @param entityClass the entity for which to retrieve the metamodel class. Cannot be {@code null}.
 	 *
 	 * @return the static metamodel class for the specified entity.
 	 */
 	public static Class<?> getMetamodelClassFor(Class<?> entityClass) {
 		assertNotNull( "Class parameter cannot be null", entityClass );
 		String metaModelClassName = entityClass.getName() + META_MODEL_CLASS_POSTFIX;
 		try {
 			URL outDirUrl = OUT_BASE_DIR.toURI().toURL();
 			URL[] urls = new URL[1];
 			urls[0] = outDirUrl;
 			URLClassLoader classLoader = new URLClassLoader( urls, TestUtil.class.getClassLoader() );
 			return classLoader.loadClass( metaModelClassName );
 		}
 		catch ( Exception e ) {
 			fail( metaModelClassName + " was not generated." );
 		}
 		// keep the compiler happy
 		return null;
 	}
 
 	public static File getMetaModelSourceFileFor(Class<?> clazz) {
 		String metaModelClassName = clazz.getName() + META_MODEL_CLASS_POSTFIX;
 		// generate the file name
 		String fileName = metaModelClassName.replace( PACKAGE_SEPARATOR, PATH_SEPARATOR );
 		fileName = fileName.concat( ".java" );
 		return new File( OUT_BASE_DIR + PATH_SEPARATOR + fileName );
 	}
 
 	public static String getMetaModelSourceAsString(Class<?> clazz) {
 		File sourceFile = getMetaModelSourceFileFor( clazz );
 		StringBuilder contents = new StringBuilder();
 
 		try {
 			BufferedReader input = new BufferedReader( new FileReader( sourceFile ) );
 			try {
 				String line;
 				/*
 						* readLine is a bit quirky :
 						* it returns the content of a line MINUS the newline.
 						* it returns null only for the END of the stream.
 						* it returns an empty String if two newlines appear in a row.
 						*/
 				while ( ( line = input.readLine() ) != null ) {
 					contents.append( line );
 					contents.append( System.getProperty( "line.separator" ) );
 				}
 			}
 			finally {
 				input.close();
 			}
 		}
 		catch ( IOException ex ) {
 			ex.printStackTrace();
 		}
 
 		return contents.toString();
 	}
 
 	public static void dumpMetaModelSourceFor(Class<?> clazz) {
 		log.info( "Dumping meta model source for " + clazz.getName() + ":" );
 		log.info( getMetaModelSourceAsString( clazz ) );
 	}
 
 	public static Field getFieldFromMetamodelFor(Class<?> entityClass, String fieldName) {
 		Class<?> metaModelClass = getMetamodelClassFor( entityClass );
 		Field field;
 		try {
 			field = metaModelClass.getDeclaredField( fieldName );
 		}
 		catch ( NoSuchFieldException e ) {
 			field = null;
 		}
 		return field;
 	}
 
 	public static String fcnToPath(String fcn) {
-		return fcn.replace( PACKAGE_SEPARATOR, PATH_SEPARATOR );
+		return fcn.replace( PACKAGE_SEPARATOR, RESOURCE_SEPARATOR );
 	}
 
 	private static boolean hasFieldInMetamodelFor(Class<?> clazz, String fieldName) {
 		return getFieldFromMetamodelFor( clazz, fieldName ) != null;
 	}
 
 	private static String buildErrorString(String baseError, Class<?> clazz) {
 		StringBuilder builder = new StringBuilder();
 		builder.append( baseError );
 		builder.append( ".\n\n" );
 		builder.append( "Source code for " );
 		builder.append( clazz.getName() );
 		builder.append( "_.java:" );
 		builder.append( "\n" );
 		builder.append( getMetaModelSourceAsString( clazz ) );
 		return builder.toString();
 	}
 
 	private static Type getComponentType(Type actualType) {
 		if ( actualType instanceof Class ) {
 			Class<?> clazz = (Class<?>) actualType;
 			if ( clazz.isArray() ) {
 				return clazz.getComponentType();
 			}
 			else {
 				fail( "Unexpected component type" );
 			}
 		}
 
 		if ( actualType instanceof GenericArrayType ) {
 			return ( (GenericArrayType) actualType ).getGenericComponentType();
 		}
 		else {
 			fail( "Unexpected component type" );
 			return null;
 		}
 	}
 
 	private static class MetaModelFilenameFilter implements FileFilter {
 		@Override
 		public boolean accept(File pathName) {
 			if ( pathName.isDirectory() ) {
 				return true;
 			}
 			else {
 				return pathName.getAbsolutePath().endsWith( "_.java" )
 						|| pathName.getAbsolutePath().endsWith( "_.class" );
 			}
 		}
 	}
 
 	private static void deleteFilesRecursive(File file) {
 		if ( file.isDirectory() ) {
 			for ( File c : file.listFiles() ) {
 				deleteFilesRecursive( c );
 			}
 		}
 		if ( !file.delete() ) {
 			fail( "Unable to delete file: " + file );
 		}
 	}
 
 	/**
 	 * Returns the target directory of the build.
 	 *
 	 * @return the target directory of the build
 	 */
 	public static File getTargetDir() {
 		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
 		// get a URL reference to something we now is part of the classpath (our own classes)
 		String currentTestClass = TestUtil.class.getName();
 		int hopsToCompileDirectory = currentTestClass.split( "\\." ).length;
 		int hopsToTargetDirectory = hopsToCompileDirectory + 2;
 		URL classURL = contextClassLoader.getResource( currentTestClass.replace( '.', '/' ) + ".class" );
 		// navigate back to '/target'
 		File targetDir = new File( classURL.getFile() );
 		// navigate back to '/target'
 		for ( int i = 0; i < hopsToTargetDirectory; i++ ) {
 			targetDir = targetDir.getParentFile();
 		}
 		return targetDir;
 	}
 }
 
 
